ver
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

    // update config displays any necessary error dialogs
    if (!UpdateConfig())
        return E_FAIL;

    DWORD err = ERROR_SUCCESS;

    // now write to server
    if (m_fUpdateConfig)
    {
        err = m_pConfig->Store();
        if (err != ERROR_SUCCESS)
        {
            // something bad happened
            WinsMessageBox(err);
        }
        else
        {   
            // success update our local copy
            pServer->SetConfig(*m_pConfig);
        }
    }

    return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CServerPropGeneral::UpdateConfig()
		Updates the Config object in the server handler
---------------------------------------------------------------------------*/
BOOL 
CServerPropGeneral::UpdateConfig()
{
	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	CString strTemp;
	m_editBackupPath.GetWindowText(strTemp);

    // backup path needs to be non-null when backup on termination is set
    if (m_fBackupDB && strTemp.IsEmpty())
    {
        AfxMessageBox(IDS_SPECIFY_DEFAULT_BACKUP_PATH);
        return FALSE;
    }

    if (m_fUpdateConfig)
    {
        m_pConfig->m_strBackupPath = strTemp;
	    m_pConfig->m_fBackupOnTermination = m_fBackupDB;
    }

    pServer->m_dwRefreshInterval = CalculateRefrInt();
	
    if (m_fEnableAutoRefresh)
	{
		pServer->m_dwFlags |= FLAG_AUTO_REFRESH;
	}
	else
	{
		pServer->m_dwFlags &= ~FLAG_AUTO_REFRESH;
	}

    // since these settins are stored in the console file, mark it as dirty
    SPITFSNode spRootNode;
    spNode->GetParent(&spRootNode);
    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);

    return TRUE;
}


/*---------------------------------------------------------------------------
	CServerPropGeneral::CalculateRefrInt()
		Rteurns the refresh interval in seconds
---------------------------------------------------------------------------*/
int 
CServerPropGeneral::CalculateRefrInt()
{
	UpdateData();
	CString strValue;

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

	int nHour = m_spinRefreshHr.GetPos();
	int nMinute = m_spinRefreshmn.GetPos();
	int nSecond = m_spinRefreshSc.GetPos();

	int nRenewInterval = nHour * SEC_PER_HOUR + 
						 nMinute * SEC_PER_MINUTE +
  						 nSecond;

	pServer->m_dwRefreshInterval = nRenewInterval;
    pServer->m_dlgStats.ReInitRefresherThread();

	return nRenewInterval;
}


/*---------------------------------------------------------------------------
	CServerPropGeneral::ToString(int nNumber)
		Returns string value of an integer
---------------------------------------------------------------------------*/
CString 
CServerPropGeneral::ToString(int nNumber)
{
	TCHAR szStr[20];
	_itot(nNumber, szStr, 10);
	CString str(szStr);
	return str;
}


/*---------------------------------------------------------------------------
		CServerPropGeneral::SetRefreshData()
		 Sets the variables' dtata for the refresh group.
---------------------------------------------------------------------------*/
void 
CServerPropGeneral::SetRefreshData()
{
	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	DWORD dwInterval = pServer->m_dwRefreshInterval;

	m_spinRefreshmn.SetRange(0, MAX_MINUTES);
	m_spinRefreshSc.SetRange(0, MAX_SECONDS);
	m_spinRefreshHr.SetRange(0, UD_MAXVAL);

	int nHours, nMinutes, nSeconds;

	nHours = dwInterval / SEC_PER_HOUR;
	
	dwInterval -= nHours * SEC_PER_HOUR;

	nMinutes = dwInterval / SEC_PER_MINUTE;
	dwInterval -= nMinutes * SEC_PER_MINUTE;

	nSeconds = dwInterval ;

	// convert them to strings
	CString strHr = ToString(nHours);
	CString strMn = ToString(nMinutes);
	CString strSc = ToString(nSeconds);
	
	m_spinRefreshHr.SetPos(nHours);
	m_spinRefreshmn.SetPos(nMinutes);
	m_spinRefreshSc.SetPos(nSeconds);
}


/*---------------------------------------------------------------------------
	CServerPropGeneral::GetConfig()
		Gets the Configuration object from the server
---------------------------------------------------------------------------*/
HRESULT 
CServerPropGeneral::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    m_pConfig = ((CServerProperties *) GetHolder())->GetConfig();

	return hr;
}


void CServerPropGeneral::OnCheckEnableAutorefresh() 
{
	SetDirty(TRUE);

	UpdateData();
	
    if (m_check_EnableAutoRefresh.GetCheck() == 1)
	{
		m_fEnableAutoRefresh = TRUE;
		m_spinRefreshHr.EnableWindow(TRUE);
		m_spinRefreshmn.EnableWindow(TRUE);
		m_spinRefreshSc.EnableWindow(TRUE);
		
		m_editRefreshHr.EnableWindow(TRUE);
		m_editRefreshMn.EnableWindow(TRUE);
		m_editRefreshSc.EnableWindow(TRUE);
	}
	else
	{
		m_fEnableAutoRefresh = FALSE;
		m_spinRefreshHr.EnableWindow(FALSE);
		m_spinRefreshmn.EnableWindow(FALSE);
		m_spinRefreshSc.EnableWindow(FALSE);
		
		m_editRefreshHr.EnableWindow(FALSE);
		m_editRefreshMn.EnableWindow(FALSE);
		m_editRefreshSc.EnableWindow(FALSE);
	}

	// mark the snap-in as dirty, so as to prompt the user
		// mark the snap-in as dirty
	SPITFSNode spNode ;
	spNode = GetHolder()->GetNode();
	
	SPITFSNodeMgr spNodeManager;
	SPITFSNode spRootNode;

	spNode->GetNodeMgr(&spNodeManager);
	spNodeManager->GetRootNode(&spRootNode);

	// mark the data as dirty so that we'll ask the user to save.
    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
	
}






/////////////////////////////////////////////////////////////////////////////
// CServerPropDBRecord property page

IMPLEMENT_DYNCREATE(CServerPropDBRecord, CPropertyPageBase)

CServerPropDBRecord::CServerPropDBRecord() : CPropertyPageBase(CServerPropDBRecord::IDD)
{
	//{{AFX_DATA_INIT(CServerPropDBRecord)
	m_nExtintDay = 0;
	m_nExtIntHour = 0;
	m_nExtIntMinute = 0;
	m_nExtTmDay = 0;
	m_nExtTmHour = 0;
	m_nExtTmMinute = 0;
	m_nRenewDay = 0;
	m_nrenewMinute = 0;
	m_nRenewMinute = 0;
	m_nVerifyDay = 0;
	m_nVerifyHour = 0;
	m_nVerifyMinute = 0;
	//}}AFX_DATA_INIT
}


CServerPropDBRecord::~CServerPropDBRecord()
{
}


void CServerPropDBRecord::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerPropDBRecord)
	DDX_Control(pDX, IDC_EDIT_EXTINCT_INT_MINUTE, m_editExtIntMinute);
	DDX_Control(pDX, IDC_SPIN_VERIFY_INT_MINUTE, m_spinVerifyMinute);
	DDX_Control(pDX, IDC_SPIN_VERIFY_INT_HOUR, m_spinVerifyHour);
	DDX_Control(pDX, IDC_SPIN_VERIFY_INT_DAY, m_spinVerifyDay);
	DDX_Control(pDX, IDC_SPIN_RENEW_INT_MINUTE, m_spinRefrIntMinute);
	DDX_Control(pDX, IDC_SPIN_RENEW_INT_HOUR, m_spinRefrIntHour);
	DDX_Control(pDX, IDC_SPIN_RENEW_INT_DAY, m_spinRefrIntDay);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_TM_MINUTE, m_spinExtTmMinute);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_TM_HOUR, m_spinExtTmHour);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_TM_DAY, m_spinExtTmDay);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_INT_MINUTE, m_spinExtIntMinute);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_INT_HOUR, m_spinExtIntHour);
	DDX_Control(pDX, IDC_SPIN_EXTINCT_INT_DAY, m_spinExtIntDay);
	DDX_Control(pDX, IDC_EDIT_VERIFY_MINUTE, m_editVerifyMinute);
	DDX_Control(pDX, IDC_EDIT_VERIFY_HOUR, m_editVerifyHour);
	DDX_Control(pDX, IDC_EDIT_VERIFY_DAY, m_editVerifyDay);
	DDX_Control(pDX, IDC_EDIT_RENEW_MINUTE, m_editRefrIntMinute);
	DDX_Control(pDX, IDC_EDIT_RENEW_HOUR, m_editRefrIntHour);
	DDX_Control(pDX, IDC_EDIT_RENEW_DAY, m_editRefrIntDay);
	DDX_Control(pDX, IDC_EDIT_EXTINCT_TIMEOUT_HOUR, m_editExtTmHour);
	DDX_Control(pDX, IDC_EDIT_EXTINCT_TIMEOUT_MINUTE, m_editExtTmMinute);
	DDX_Control(pDX, IDC_EDIT_EXTINCT_TIMEOUT_DAY, m_editExtTmDay);
	DDX_Control(pDX, IDC_EDIT_EXTINCT_INT_HOUR, m_editExtIntHour);
	DDX_Control(pDX, IDC_EDIT_EXTINCT_INT_DAY, m_editExtIntDay);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_INT_DAY, m_nExtintDay);
	DDV_MinMaxInt(pDX, m_nExtintDay, 0, 365);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_INT_HOUR, m_nExtIntHour);
	DDV_MinMaxInt(pDX, m_nExtIntHour, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_INT_MINUTE, m_nExtIntMinute);
	DDV_MinMaxInt(pDX, m_nExtIntMinute, 0, MAX_MINUTES);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_TIMEOUT_DAY, m_nExtTmDay);
	DDV_MinMaxInt(pDX, m_nExtTmDay, 0, 365);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_TIMEOUT_HOUR, m_nExtTmHour);
	DDV_MinMaxInt(pDX, m_nExtTmHour, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_EXTINCT_TIMEOUT_MINUTE, m_nExtTmMinute);
	DDV_MinMaxInt(pDX, m_nExtTmMinute, 0, MAX_MINUTES);
	DDX_Text(pDX, IDC_EDIT_RENEW_DAY, m_nRenewDay);
	DDV_MinMaxInt(pDX, m_nRenewDay, 0, 365);
	DDX_Text(pDX, IDC_EDIT_RENEW_HOUR, m_nrenewMinute);
	DDV_MinMaxInt(pDX, m_nrenewMinute, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_RENEW_MINUTE, m_nRenewMinute);
	DDV_MinMaxInt(pDX, m_nRenewMinute, 0, MAX_MINUTES);
	DDX_Text(pDX, IDC_EDIT_VERIFY_DAY, m_nVerifyDay);
	DDV_MinMaxInt(pDX, m_nVerifyDay, 0, 365);
	DDX_Text(pDX, IDC_EDIT_VERIFY_HOUR, m_nVerifyHour);
	DDV_MinMaxInt(pDX, m_nVerifyHour, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_VERIFY_MINUTE, m_nVerifyMinute);
	DDV_MinMaxInt(pDX, m_nVerifyMinute, 0, MAX_MINUTES);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropDBRecord, CPropertyPageBase)
	//{{AFX_MSG_MAP(CServerPropDBRecord)
	ON_BN_CLICKED(IDC_BUTTON_SET_DEFAULT, OnButtonSetDefault)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_INT_DAY, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_INT_HOUR, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_INT_MINUTE, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_TIMEOUT_DAY, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_TIMEOUT_HOUR, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_EXTINCT_TIMEOUT_MINUTE, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_RENEW_DAY, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_RENEW_HOUR, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_RENEW_MINUTE, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_VERIFY_DAY, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_VERIFY_HOUR, OnChangeEditExtinctIntHour)
	ON_EN_CHANGE(IDC_EDIT_VERIFY_MINUTE, OnChangeEditExtinctIntHour)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropDBRecord message handlers

BOOL 
CServerPropDBRecord::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

		// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	// get the interval stuff from the server and display in the spinner controlss
	HRESULT hr = GetConfig();
	
	DWORD m_dwRefreshInterval = m_pConfig->m_dwRefreshInterval;

	m_spinRefrIntHour.SetRange(0, MAX_HOURS);
	m_spinRefrIntMinute.SetRange(0, MAX_MINUTES);
	m_spinRefrIntDay.SetRange(0, UD_MAXVAL);       

    int nDays = 0, nHours = 0, nMinutes = 0;

	nDays = m_dwRefreshInterval /86400;// SEC_PER_DAY;
	m_dwRefreshInterval -= (nDays * SEC_PER_DAY);

	if (m_dwRefreshInterval)
	{
		nHours = m_dwRefreshInterval / SEC_PER_HOUR;

		m_dwRefreshInterval -= (nHours * SEC_PER_HOUR);
		
		if(m_dwRefreshInterval)
		{
			nMinutes = m_dwRefreshInterval / SEC_PER_MINUTE;
			m_dwRefreshInterval -= (nMinutes * SEC_PER_MINUTE);
		}
	}

	m_spinRefrIntDay.SetPos(nDays);
	m_spinRefrIntHour.SetPos(nHours);
	m_spinRefrIntMinute.SetPos(nMinutes);

	SetVerifyData();
	SetExtTimeData();
	SetExtIntData();

    SetDirty(FALSE);
 
    return TRUE;  
}


BOOL 
CServerPropDBRecord::OnApply() 
{
	if (!CheckValues())
    {
        return FALSE;
    }

	HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return FALSE;
    }
    else
    {
	    return CPropertyPageBase::OnApply();
    }
}


void 
CServerPropDBRecord::OnOK() 
{
	HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return;
    }
    else
    {
    	CPropertyPageBase::OnOK();
    }
}

/*---------------------------------------------------------------------------
	CServerPropDBRecord::CalculateRenewInt()
		Returns the Renew interval in seconds
---------------------------------------------------------------------------*/
DWORD 
CServerPropDBRecord::CalculateRenewInt()
{
	UpdateData();

	int nDay = m_spinRefrIntDay.GetPos();
	int nHour = m_spinRefrIntHour.GetPos();
	int nMinute = m_spinRefrIntMinute.GetPos();

	int nRenewInterval = nDay * SEC_PER_DAY +
 						 nHour * SEC_PER_HOUR +
						 nMinute * SEC_PER_MINUTE;

	return nRenewInterval;
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::CalculateExtInt()
		Returns the Extinction interval in seconds
---------------------------------------------------------------------------*/
DWORD
CServerPropDBRecord::CalculateExtInt()
{
	UpdateData();

	int nDay = m_spinExtIntDay.GetPos();
	int nHour = m_spinExtIntHour.GetPos();
	int nMinute = m_spinExtIntMinute.GetPos();

	int nExtInterval = nDay * SEC_PER_DAY +
						nHour * SEC_PER_HOUR +
						nMinute * SEC_PER_MINUTE;

	return nExtInterval;
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::CalculateExtTm()
		Returns the Extinction timeout interval in seconds
---------------------------------------------------------------------------*/
DWORD
CServerPropDBRecord::CalculateExtTm()
{
	UpdateData();

	int nDay = m_spinExtTmDay.GetPos();
	int nHour = m_spinExtTmHour.GetPos();
	int nMinute = m_spinExtTmMinute.GetPos();

	int nExtTm = nDay * SEC_PER_DAY +
				 nHour * SEC_PER_HOUR +
				 nMinute * SEC_PER_MINUTE;

	return nExtTm;
}


/*----------------------------------------------------------------------------
	CServerPropDBRecord::CalculateVerifyInt()
		Returns the Verify interval in seconds
---------------------------------------------------------------------------*/
DWORD
CServerPropDBRecord::CalculateVerifyInt()
{
	UpdateData();

	int nDay = m_spinVerifyDay.GetPos();
	int nHour = m_spinVerifyHour.GetPos();
	int nMinute = m_spinVerifyMinute.GetPos();

	int nVerifyInt = nDay * SEC_PER_DAY +
					 nHour * SEC_PER_HOUR +
 					 nMinute * SEC_PER_MINUTE;

    return nVerifyInt;
}

/*---------------------------------------------------------------------------
	CServerPropDBRecord::UpdateServerConfiguration()
		Updates the server handler variables
---------------------------------------------------------------------------*/
HRESULT
CServerPropDBRecord::UpdateServerConfiguration()
{
    UpdateData();

	// Reflect the changes in the server's CConfiguration object
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

 	m_pConfig->m_dwRefreshInterval = CalculateRenewInt();
	m_pConfig->m_dwTombstoneInterval = CalculateExtInt();
	m_pConfig->m_dwTombstoneTimeout = CalculateExtTm();
	m_pConfig->m_dwVerifyInterval = CalculateVerifyInt();

    // now write to server
    DWORD err = m_pConfig->Store();
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
    }
    else
    {   
        // success update our local copy
        pServer->SetConfig(*m_pConfig);
    }

    return HRESULT_FROM_WIN32(err);
}


void 
CServerPropDBRecord::OnButtonSetDefault() 
{
	SetDefaultRenewInt();
	SetDefaultExtInt();
	SetDefaultExtTm();
	SetDefaultVerifyInt();
}

//
//  note, these defaults come from winscnf.c in the wins server code.
//  if that code changes, these function will need to change as well.
//

/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetDefaultRenewInt() 
		Sets the defalut values for the Renew interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetDefaultRenewInt() 
{
	int nValue = WINSCNF_DEF_REFRESH_INTERVAL;

    int nDays = 0, nHours = 0, nMinutes = 0;

    CalcDaysHoursMinutes(nValue, nDays, nHours, nMinutes);

	m_spinRefrIntDay.SetPos(nDays);
	m_spinRefrIntHour.SetPos(nHours);
	m_spinRefrIntMinute.SetPos(nMinutes);
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetDefaultExtInt() 
		Sets the defalut values for the Extinction interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetDefaultExtInt() 
{
	int nValue = WINSCNF_MAKE_TOMB_INTVL_M(WINSCNF_DEF_REFRESH_INTERVAL, 0);

    int nDays = 0, nHours = 0, nMinutes = 0;

    CalcDaysHoursMinutes(nValue, nDays, nHours, nMinutes);

    m_spinExtIntDay.SetPos(nDays);
	m_spinExtIntHour.SetPos(nHours);
	m_spinExtIntMinute.SetPos(nMinutes);
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetDefaultExtTm() 
		Sets the defalut values for the Extinction timeout interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetDefaultExtTm() 
{
	int nValue = WINSCNF_DEF_REFRESH_INTERVAL;

    int nDays = 0, nHours = 0, nMinutes = 0;

    CalcDaysHoursMinutes(nValue, nDays, nHours, nMinutes);

    m_spinExtTmDay.SetPos(nDays);
	m_spinExtTmHour.SetPos(nHours);
	m_spinExtTmMinute.SetPos(nMinutes);
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetDefaultExtTm() 
		Sets the defalut values for the verify interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetDefaultVerifyInt() 
{
	int nValue = WINSCNF_MAKE_VERIFY_INTVL_M(WINSCNF_MAKE_TOMB_INTVL_M(WINSCNF_DEF_REFRESH_INTERVAL, 0));

    int nDays = 0, nHours = 0, nMinutes = 0;

    CalcDaysHoursMinutes(nValue, nDays, nHours, nMinutes);

    m_spinVerifyDay.SetPos(nDays);
	m_spinVerifyHour.SetPos(nHours);
	m_spinVerifyMinute.SetPos(nMinutes);
}


void 
CServerPropDBRecord::CalcDaysHoursMinutes(int nValue, int & nDays, int & nHours, int & nMinutes)
{
    nDays = 0;
    nHours = 0;
    nMinutes = 0;

	nDays = nValue / SEC_PER_DAY; // 86400;
	nValue -= (nDays * SEC_PER_DAY);

	if (nValue)
	{
		nHours = nValue / SEC_PER_HOUR;

		nValue -= (nHours * SEC_PER_HOUR);
		
		if (nValue)
		{
			nMinutes = nValue / SEC_PER_MINUTE;
			nValue -= (nMinutes * SEC_PER_MINUTE);
		}
	}
}

/*---------------------------------------------------------------------------
	CServerPropDBRecord::GetConfig()
		Updates the configuration object from the server handler
---------------------------------------------------------------------------*/
HRESULT 
CServerPropDBRecord::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

    m_pConfig = ((CServerProperties *) GetHolder())->GetConfig();

	return hr;
}

/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetVerifyData()
		Sets the controls' data for verify interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetVerifyData()
{
	DWORD dwInterval = m_pConfig->m_dwVerifyInterval;

	m_spinVerifyHour.SetRange(0, MAX_HOURS);
	m_spinVerifyMinute.SetRange(0, MAX_MINUTES);
	m_spinVerifyDay.SetRange(0, UD_MAXVAL);

	int nDays =0, nHours =0, nMinutes =0;

	if(dwInterval)
	{
		nDays = dwInterval / SEC_PER_DAY;
		dwInterval -= nDays * SEC_PER_DAY;
		if(dwInterval)
		{
			nHours = dwInterval / SEC_PER_HOUR;
			dwInterval -= nHours * SEC_PER_HOUR;
			if(dwInterval)
			{

				nMinutes = dwInterval / SEC_PER_MINUTE;
				dwInterval -= nMinutes * SEC_PER_MINUTE;
			}
		}
	}

	m_spinVerifyDay.SetPos(nDays);
	m_spinVerifyHour.SetPos(nHours);
	m_spinVerifyMinute.SetPos(nMinutes);
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetExtTimeData()
		Sets the controls' data for extinction timeout interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetExtTimeData()
{
	DWORD dwInterval = m_pConfig->m_dwTombstoneTimeout;

	m_spinExtTmHour.SetRange(0, MAX_HOURS);
	m_spinExtTmMinute.SetRange(0, MAX_MINUTES);
	m_spinExtTmDay.SetRange(0, UD_MAXVAL);

	int nHours = 0, nMinutes =0, nDays =0;

	if(dwInterval)
	{
		nDays = dwInterval / SEC_PER_DAY;
		dwInterval -= nDays * SEC_PER_DAY;
		if(dwInterval)
		{
			nHours = dwInterval / SEC_PER_HOUR;
			dwInterval -= nHours * SEC_PER_HOUR;

			if(dwInterval)
			{
				nMinutes = dwInterval / SEC_PER_MINUTE;
				dwInterval -= nMinutes * SEC_PER_MINUTE;
			}
		}
	}

	m_spinExtTmDay.SetPos(nDays);
	m_spinExtTmHour.SetPos(nHours);
	m_spinExtTmMinute.SetPos(nMinutes);

}

/*---------------------------------------------------------------------------
	CServerPropDBRecord::SetExtData()
		Sets the controls' data for extinction interval
---------------------------------------------------------------------------*/
void 
CServerPropDBRecord::SetExtIntData()
{
	DWORD dwInterval = m_pConfig->m_dwTombstoneInterval;

	m_spinExtIntHour.SetRange(0, MAX_HOURS);
	m_spinExtIntMinute.SetRange(0, MAX_MINUTES);
	m_spinExtIntDay.SetRange(0, UD_MAXVAL);

	int nHours =0, nMinutes =0, nDays =0;

	if(dwInterval)
	{
		nDays = dwInterval / SEC_PER_DAY;
		dwInterval -= nDays * SEC_PER_DAY;

		if(dwInterval)
		{
			nHours = dwInterval / SEC_PER_HOUR;
			dwInterval -= nHours * SEC_PER_HOUR;

			if(dwInterval)
			{
				nMinutes = dwInterval / SEC_PER_MINUTE;
				dwInterval -= nMinutes * SEC_PER_MINUTE;
			}
		}
		
	}
	m_spinExtIntDay.SetPos(nDays);
	m_spinExtIntHour.SetPos(nHours);
	m_spinExtIntMinute.SetPos(nMinutes);

}


void CServerPropDBRecord::OnChangeEditExtinctIntHour() 
{
	SetDirty(TRUE);	
	
}


/*---------------------------------------------------------------------------
	CServerPropDBRecord::CheckValues() 
        checks if the values are valid
        NOTE: All of these checks mimic what the server does since we write
        directly to the registry and don't go through an API.  If these
        every change, the error messages will need to be updated as well.
    Author: EricDav
---------------------------------------------------------------------------*/
BOOL
CServerPropDBRecord::CheckValues() 
{
    BOOL  fValid = TRUE;

	UpdateData();

    do 
    {
        DWORD dwRenew = CalculateRenewInt();
    
        if (dwRenew < WINSCNF_MIN_REFRESH_INTERVAL)
        {
            AfxMessageBox(IDS_ERR_RENEW_INTERVAL);
            fValid = FALSE;
            break;
        }

        DWORD dwExtTm = CalculateExtTm();

        if (dwExtTm < WINSCNF_MIN_TOMBSTONE_TIMEOUT)
        {
            // minimum value
            AfxMessageBox(IDS_ERR_EXTINCTION_TIMEOUT_MIN);
            fValid = FALSE;
            break;
        }

        if (dwExtTm < dwRenew)
        {
            // bad... must be at least this value
            AfxMessageBox(IDS_ERR_EXTINCTION_TIMEOUT);
            fValid = FALSE;
            break;
        }

        DWORD dwExtInt = CalculateExtInt();
        
        //--ft:07/10/00--
        // replaced WINSCNF_MAKE_TOMB_INTVL_M macro with its expansion..
        // otherwise, the compiler with CLEAN64_BIT=1 reports an error
        // since max(any_dword, 0) is always true - and the compiler is dumb enough
        // to signal this as an error..
        //
        //if (dwExtInt < WINSCNF_MAKE_TOMB_INTVL_M(dwRenew, 0))
        if (dwExtInt < min(dwRenew, FOUR_DAYS))
        {
            // bad...  must be at least that value
            AfxMessageBox(IDS_ERR_EXTINCTION_INTERVAL);
            fValid = FALSE;
            break;
        }

        DWORD dwVerifyInt = CalculateVerifyInt();

        if (dwVerifyInt < WINSCNF_MAKE_VERIFY_INTVL_M(dwExtInt))
        {
            // bad... must be at least this value
            if (WINSCNF_MAKE_VERIFY_INTVL_M(dwExtInt) == TWENTY_FOUR_DAYS)
            {
                AfxMessageBox(IDS_ERR_VERIFY_INTERVAL_24_DAYS);
            }
            else
            {
                CString strTemp;
                strTemp.Format(IDS_ERR_VERIFY_INTERVAL_CALC, TOMB_MULTIPLIER_FOR_VERIFY);
                AfxMessageBox(strTemp);
            }

            fValid = FALSE;
            break;
        }
    }
    while (FALSE);

    return fValid;
}





/////////////////////////////////////////////////////////////////////////////
// CServerPropDBVerification property page

IMPLEMENT_DYNCREATE(CServerPropDBVerification, CPropertyPageBase)

CServerPropDBVerification::CServerPropDBVerification() : CPropertyPageBase(CServerPropDBVerification::IDD)
{
	//{{AFX_DATA_INIT(CServerPropDBVerification)
	m_fCCPeriodic = FALSE;
	m_nCCCheckRandom = -1;
	m_nCCHour = 0;
	m_nCCMinute = 0;
	m_nCCSecond = 0;
	m_nCCMaxChecked = 0;
	m_nCCTimeInterval = 0;
	//}}AFX_DATA_INIT
}


CServerPropDBVerification::~CServerPropDBVerification()
{
}


void CServerPropDBVerification::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerPropDBVerification)
	DDX_Control(pDX, IDC_EDIT_CC_START_SECOND, m_editCCSecond);
	DDX_Control(pDX, IDC_EDIT_CC_START_MINUTE, m_editCCMinute);
	DDX_Control(pDX, IDC_EDIT_CC_START_HOUR, m_editCCHour);
	DDX_Control(pDX, IDC_SPIN_CC_START_MINUTE, m_spinCCMinute);
	DDX_Control(pDX, IDC_EDIT_CC_INTERVAL, m_editCCInterval);
	DDX_Control(pDX, IDC_EDIT_CC_MAX_CHECKED, m_editCCMaxChecked);
	DDX_Control(pDX, IDC_RADIO_CHECK_OWNER, m_radioCheckOwner);
	DDX_Control(pDX, IDC_CHECK_PERIODIC_CC, m_checkEnableCC);
	DDX_Control(pDX, IDC_SPIN_CC_START_SECOND, m_spinCCSecond);
	DDX_Control(pDX, IDC_SPIN_CC_START_HOUR, m_spinCCHour);
	DDX_Check(pDX, IDC_CHECK_PERIODIC_CC, m_fCCPeriodic);
	DDX_Radio(pDX, IDC_RADIO_CHECK_OWNER, m_nCCCheckRandom);
	DDX_Text(pDX, IDC_EDIT_CC_START_HOUR, m_nCCHour);
	DDV_MinMaxInt(pDX, m_nCCHour, 0, MAX_HOURS);
	DDX_Text(pDX, IDC_EDIT_CC_START_MINUTE, m_nCCMinute);
	DDV_MinMaxInt(pDX, m_nCCMinute, 0, MAX_MINUTES);
	DDX_Text(pDX, IDC_EDIT_CC_START_SECOND, m_nCCSecond);
	DDV_MinMaxInt(pDX, m_nCCSecond, 0, MAX_SECONDS);
	DDX_Text(pDX, IDC_EDIT_CC_MAX_CHECKED, m_nCCMaxChecked);
	DDV_MinMaxUInt(pDX, m_nCCMaxChecked, WINSCNF_CC_MIN_RECS_AAT, 4294967295);
	DDX_Text(pDX, IDC_EDIT_CC_INTERVAL, m_nCCTimeInterval);
	DDV_MinMaxUInt(pDX, m_nCCTimeInterval, WINSCNF_CC_MIN_INTERVAL/(60*60), 24);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropDBVerification, CPropertyPageBase)
	//{{AFX_MSG_MAP(CServerPropDBVerification)
	ON_BN_CLICKED(IDC_CHECK_PERIODIC_CC, OnCheckPeriodicCc)
	ON_EN_CHANGE(IDC_EDIT_CC_INTERVAL, OnChangeEditCcInterval)
	ON_EN_CHANGE(IDC_EDIT_CC_MAX_CHECKED, OnChangeEditCcMaxChecked)
	ON_EN_CHANGE(IDC_EDIT_CC_START_HOUR, OnChangeEditCcStartHour)
	ON_EN_CHANGE(IDC_EDIT_CC_START_MINUTE, OnChangeEditCcStartMinute)
	ON_EN_CHANGE(IDC_EDIT_CC_START_SECOND, OnChangeEditCcStartSecond)
	ON_BN_CLICKED(IDC_RADIO_CHECK_OWNER, OnRadioCheckOwner)
	ON_BN_CLICKED(IDC_RADIO_CHECK_RANDOM, OnRadioCheckRandom)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropDBVerification message handlers

BOOL 
CServerPropDBVerification::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

		// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	// get the interval stuff from the server and display in the spinner controlss
	HRESULT hr = GetConfig();
	
	m_spinCCHour.SetRange(0, MAX_HOURS);
	m_spinCCMinute.SetRange(0, MAX_MINUTES);
	m_spinCCSecond.SetRange(0, MAX_SECONDS);       
    
    SetCCInfo();
    UpdateCCControls();

    SetDirty(FALSE);
 
    return TRUE;  
}

BOOL 
CServerPropDBVerification::OnApply() 
{
	HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return FALSE;
    }
    else
    {
	    return CPropertyPageBase::OnApply();
    }
}


void 
CServerPropDBVerification::OnOK() 
{
	HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return;
    }
    else
    {
    	CPropertyPageBase::OnOK();
    }
}

void CServerPropDBVerification::OnCheckPeriodicCc() 
{
    UpdateCCControls();
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnChangeEditCcInterval() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnChangeEditCcMaxChecked() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnChangeEditCcStartHour() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnChangeEditCcStartMinute() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnChangeEditCcStartSecond() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnRadioCheckOwner() 
{
    SetDirty(TRUE);
}

void CServerPropDBVerification::OnRadioCheckRandom() 
{
    SetDirty(TRUE);
}

/*---------------------------------------------------------------------------
	CServerPropDBVerification::UpdateServerConfiguration()
		Updates the server handler variables
---------------------------------------------------------------------------*/
HRESULT
CServerPropDBVerification::UpdateServerConfiguration()
{
    UpdateData();

	// Reflect the changes in the server's CConfiguration object
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

    // consistency check
	m_pConfig->m_fPeriodicConsistencyCheck = m_fCCPeriodic;
    m_pConfig->m_fCCUseRplPnrs = m_nCCCheckRandom;
    m_pConfig->m_dwMaxRecsAtATime = m_nCCMaxChecked;
        
    // convert to seconds
    m_pConfig->m_dwCCTimeInterval = m_nCCTimeInterval * (60*60);
    
    // start time
    CTime curTime = CTime::GetCurrentTime();

    int nYear = curTime.GetYear();
    int nMonth = curTime.GetMonth();
    int nDay = curTime.GetDay();

    CTime tempTime(nYear, nMonth, nDay, m_nCCHour, m_nCCMinute, m_nCCSecond);
    m_pConfig->m_itmCCStartTime = tempTime;

    // now write to server
    DWORD err = m_pConfig->Store();
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
    }
    else
    {   
        // success update our local copy
        pServer->SetConfig(*m_pConfig);
    }

    return HRESULT_FROM_WIN32(err);
}

/*---------------------------------------------------------------------------
	CServerPropDBVerification::GetConfig()
		Updates the configuration object from the server handler
---------------------------------------------------------------------------*/
HRESULT 
CServerPropDBVerification::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

    m_pConfig = ((CServerProperties *) GetHolder())->GetConfig();

	return hr;
}

/*---------------------------------------------------------------------------
	CServerPropDBVerification::UpdateCCControls()
		Enables/disables depending on checkbox
    Author: EricDav
---------------------------------------------------------------------------*/
void 
CServerPropDBVerification::UpdateCCControls()
{
    UpdateData();
    BOOL fEnable = FALSE;

    if (m_fCCPeriodic)
    {
        fEnable = TRUE;
    }

    m_spinCCHour.EnableWindow(fEnable);
    m_spinCCMinute.EnableWindow(fEnable);
    m_spinCCSecond.EnableWindow(fEnable);

    m_editCCHour.EnableWindow(fEnable);
    m_editCCMinute.EnableWindow(fEnable);
    m_editCCSecond.EnableWindow(fEnable);

    m_editCCMaxChecked.EnableWindow(fEnable);
    m_editCCInterval.EnableWindow(fEnable);
    m_radioCheckOwner.EnableWindow(fEnable);
    GetDlgItem(IDC_RADIO_CHECK_RANDOM)->EnableWindow(fEnable);

    // TODO: static text
}

/*---------------------------------------------------------------------------
	CServerPropDBVerification::SetCCInfo()
		Sets the interval values for Consistency checking
    Author: EricDav
---------------------------------------------------------------------------*/
void 
CServerPropDBVerification::SetCCInfo()
{
	CString strTemp;
    CButton * pRadio;

    m_checkEnableCC.SetCheck(m_pConfig->m_fPeriodicConsistencyCheck);
    
    if (m_pConfig->m_fCCUseRplPnrs)
    {
        pRadio = (CButton *) GetDlgItem(IDC_RADIO_CHECK_RANDOM);
    }
    else
    {
        pRadio = (CButton *) GetDlgItem(IDC_RADIO_CHECK_OWNER);
    }

    pRadio->SetCheck(TRUE);

    strTemp.Format(_T("%lu"), m_pConfig->m_dwMaxRecsAtATime);
    m_editCCMaxChecked.SetWindowText(strTemp);

    // convert the TimeInterval into hours from seconds
    int nTimeTemp = m_pConfig->m_dwCCTimeInterval / (60 * 60);

    strTemp.Format(_T("%lu"), nTimeTemp);
    m_editCCInterval.SetWindowText(strTemp);
    
    m_spinCCHour.SetPos(m_pConfig->m_itmCCStartTime.GetHour());
    m_spinCCMinute.SetPos(m_pConfig->m_itmCCStartTime.GetMinute());
    m_spinCCSecond.SetPos(m_pConfig->m_itmCCStartTime.GetSecond());
}


/////////////////////////////////////////////////////////////////////////////
// CServerPropAdvanced property page

IMPLEMENT_DYNCREATE(CServerPropAdvanced, CPropertyPageBase)

CServerPropAdvanced::CServerPropAdvanced() : CPropertyPageBase(CServerPropAdvanced::IDD)
{
	//{{AFX_DATA_INIT(CServerPropAdvanced)
	m_fLogEvents = FALSE;
	m_strStartVersion = _T("");
	m_fLanNames = FALSE;
	m_fBurstHandling = FALSE;
	m_nQueSelection = -1;
	m_strDbPath = _T("");
	//}}AFX_DATA_INIT

	m_fRestart = FALSE;
}

CServerPropAdvanced::~CServerPropAdvanced()
{
}

void CServerPropAdvanced::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerPropAdvanced)
	DDX_Control(pDX, IDC_BUTTON_BROWSE_DATABASE, m_buttonBrowse);
	DDX_Control(pDX, IDC_EDIT_DATABASE_PATH, m_editDbPath);
	DDX_Control(pDX, IDC_CHECK_BURST_HANDLING, m_checkBurstHandling);
	DDX_Control(pDX, IDC_CHECK_LANNAMES, m_checkLanNames);
	DDX_Control(pDX, IDC_EDIT_START_VERSION, m_editVersionCount);
	DDX_Control(pDX, IDC_CHECK_LOGEVENTS, m_checkLogDetailedEvents);
	DDX_Check(pDX, IDC_CHECK_LOGEVENTS, m_fLogEvents);
	DDX_Text(pDX, IDC_EDIT_START_VERSION, m_strStartVersion);
	DDV_MaxChars(pDX, m_strStartVersion, 16);
	DDX_Check(pDX, IDC_CHECK_LANNAMES, m_fLanNames);
	DDX_Check(pDX, IDC_CHECK_BURST_HANDLING, m_fBurstHandling);
	DDX_Radio(pDX, IDC_RADIO_LOW, m_nQueSelection);
	DDX_Text(pDX, IDC_EDIT_DATABASE_PATH, m_strDbPath);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropAdvanced, CPropertyPageBase)
	//{{AFX_MSG_MAP(CServerPropAdvanced)
	ON_BN_CLICKED(IDC_CHECK_LANNAMES, OnCheckLannames)
	ON_BN_CLICKED(IDC_CHECK_BURST_HANDLING, OnCheckBurstHandling)
	ON_BN_CLICKED(IDC_RADIO_CUSTOM, OnRadioCustom)
	ON_BN_CLICKED(IDC_RADIO_HIGH, OnRadioHigh)
	ON_BN_CLICKED(IDC_RADIO_LOW, OnRadioLow)
	ON_BN_CLICKED(IDC_RADIO_MEDIUM, OnRadioMedium)
	ON_EN_CHANGE(IDC_EDIT_CUSTOM_VALUE, OnChangeEditCustomValue)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_DATABASE, OnButtonBrowseDatabase)
	ON_BN_CLICKED(IDC_CHECK_LOGEVENTS, MarkDirty)
	ON_EN_CHANGE(IDC_EDIT_START_VERSION, MarkDirty)
	ON_EN_CHANGE(IDC_EDIT_DATABASE_PATH, OnChangeEditDatabasePath)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropAdvanced message handlers

BOOL 
CServerPropAdvanced::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	GetConfig();

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler *pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);
	
	m_fLogEvents =  m_pConfig->m_fLogDetailedEvents;
	if (m_fLogEvents)
	{
		m_checkLogDetailedEvents.SetCheck(1);
	}
	else
	{
		m_checkLogDetailedEvents.SetCheck(0);
	}

	if (pServer->m_dwFlags & FLAG_LANMAN_COMPATIBLE)
	{
		m_fLanNames = TRUE;
		m_checkLanNames.SetCheck(TRUE);
	}
	else
	{
		m_fLanNames = FALSE;
		m_checkLanNames.SetCheck(FALSE);
	}

	LONG lLowWord = m_pConfig->m_dwVersCountStart_LowWord;
    LONG lHighWord = m_pConfig->m_dwVersCountStart_HighWord;

	CString strVersion = GetVersionInfo(lLowWord, lHighWord);
	m_editVersionCount.SetWindowText(strVersion);

    // burst que stuff   
    m_checkBurstHandling.SetCheck(m_pConfig->m_fBurstHandling);
    
    ((CEdit *) GetDlgItem(IDC_EDIT_CUSTOM_VALUE))->LimitText(5);
    SetQueSize();
    UpdateBurstHandling();

	// db path stuff
    // browse only available on local machine
	// get the server
	m_buttonBrowse.ShowWindow(FALSE);  // we may add this back in later
    m_buttonBrowse.EnableWindow(pServer->IsLocalConnection());

	m_editDbPath.EnableWindow(pServer->IsLocalConnection());
	m_editDbPath.SetWindowText(m_pConfig->m_strDbPath);

    SetDirty(FALSE);
	m_fRestart = FALSE;

    return TRUE;  
}

void 
CServerPropAdvanced::OnOK() 
{
    HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return;
    }
    else
    {
    	CPropertyPageBase::OnOK();
    }
}

BOOL 
CServerPropAdvanced::OnApply() 
{
	BOOL fRestartNow = FALSE;

	UpdateData();

	// validate the value for Hex
	for (int i=0; i < m_strStartVersion.GetLength(); i++)
    {
        if (!(((m_strStartVersion[i] >= _T('0') ) &&
               (m_strStartVersion[i] <= _T('9') )) ||
              ((m_strStartVersion[i] >= _T('A') ) &&
               (m_strStartVersion[i] <= _T('F') )) ||
			  ((m_strStartVersion[i] >= _T('a') ) &&
               (m_strStartVersion[i] <= _T('f') ))
		   )) 
		{
            ::WinsMessageBox(IDS_ERR_VERSION_NUMBER);
			m_editVersionCount.SetFocus();
            m_editVersionCount.SetSel(0,-1);
            return FALSE;
        }
    }

    DWORD dwSize = GetQueSize();
    if (dwSize < WINS_QUEUE_HWM_MIN ||
        dwSize > WINS_QUEUE_HWM_MAX)
    {
        CString strMin, strMax, strDisplay;

        strMin.Format(_T("%d"), WINS_QUEUE_HWM_MIN);
        strMax.Format(_T("%d"), WINS_QUEUE_HWM_MAX);

        AfxFormatString2(strDisplay, IDS_ERR_BURST_QUE_SIZE, strMin, strMax);

        AfxMessageBox(strDisplay);

        GetDlgItem(IDC_EDIT_CUSTOM_VALUE)->SetFocus();
        return FALSE;
    }

	// warn the user 
	if (m_fRestart)
	{
		int nRet = AfxMessageBox(IDS_DATABASE_PATH_CHANGE, MB_YESNOCANCEL);
		if (nRet == IDCANCEL)
		{
			return FALSE;
		}
		else
		if (nRet == IDYES)
		{
			fRestartNow = TRUE;
		}
	}

    HRESULT hr = UpdateServerConfiguration();
    if (FAILED(hr))
    {
        return FALSE;
    }

	if (fRestartNow)
	{
		CString strServiceName;
		strServiceName.LoadString(IDS_SERVICE_NAME);


		// get the server
		SPITFSNode spNode;
		CWinsServerHandler *pServer;

		spNode = GetHolder()->GetNode();
		pServer = GETHANDLER(CWinsServerHandler, spNode);

		DWORD dwError = TFSStopServiceEx(m_pConfig->GetOwner(), _T("WINS"), _T("WINS Service"), strServiceName);
		if (dwError)
		{
			WinsMessageBox(dwError);
		}
		else
		{
			dwError = TFSStartServiceEx(m_pConfig->GetOwner(), _T("WINS"), _T("WINS Service"), strServiceName);
			if (dwError)
			{
				WinsMessageBox(dwError);
			}
		}

		pServer->ConnectToWinsServer(spNode);
	}

	m_fRestart = FALSE;

    return CPropertyPageBase::OnApply();
}


/*---------------------------------------------------------------------------
	CServerPropAdvanced::GetConfig()
		Updates the configuration object from the server handler
---------------------------------------------------------------------------*/
HRESULT 
CServerPropAdvanced::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

    m_pConfig = ((CServerProperties *) GetHolder())->GetConfig();

	return hr;
}


/*---------------------------------------------------------------------------
	CServerPropAdvanced::UpdateServerConfiguration()
		Updates the variables in the server handler
---------------------------------------------------------------------------*/
HRESULT
CServerPropAdvanced::UpdateServerConfiguration()
{
	UpdateData();

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler * pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

	// update our settings
	m_pConfig->m_fLogDetailedEvents = m_fLogEvents;
	if (m_fLanNames)
	{
		pServer->m_dwFlags |= FLAG_LANMAN_COMPATIBLE;
	}
	else
	{
		pServer->m_dwFlags &= (~FLAG_LANMAN_COMPATIBLE);
	}

	// version stuff
    LONG lLowWord, lHighWord;
	FillVersionInfo(lLowWord, lHighWord);

	m_pConfig->m_dwVersCountStart_HighWord = lHighWord;
	m_pConfig->m_dwVersCountStart_LowWord = lLowWord;
	
    // burst handling
    m_pConfig->m_fBurstHandling = m_fBurstHandling;
    m_pConfig->m_dwBurstQueSize = GetQueSize();

    // db path
	if (m_fRestart)
	{
		m_pConfig->m_strDbPath = m_strDbPath;
	}

    // now write to server
    DWORD err = m_pConfig->Store();
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
    }
    else
    {   
        // success update our local copy
        pServer->SetConfig(*m_pConfig);
    }

    return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CServerPropAdvanced::FillVersionInfo(LONG &lLowValue, LONG &lHighValue)
		fills the version info in the related controls 
---------------------------------------------------------------------------*/
void 
CServerPropAdvanced::FillVersionInfo(LONG &lLowValue, LONG &lHighValue)
{
	CString str ;
	m_editVersionCount.GetWindowText(str);

    int j = str.GetLength();

    if ( j > 16 || !j )
    {
        //
        // Invalid string
        //
        return;
    }

    TCHAR sz[] = _T("0000000000000000");
    TCHAR *pch;

    ::_tcscpy(sz + 16 - j, (LPCTSTR)str);
    pch = sz + 8;
    ::_stscanf(pch, _T("%08lX"),&lLowValue);
    *pch = '\0';
    ::_stscanf(sz, _T("%08lX"),&lHighValue);

    return;
}


CString 
CServerPropAdvanced::GetVersionInfo(LONG lLowWord, LONG lHighWord)
{
	CString strVersionCount;

	TCHAR sz[20];
    TCHAR *pch = sz;
    ::wsprintf(sz, _T("%08lX%08lX"), lHighWord, lLowWord);
    // Kill leading zero's
    while (*pch == '0')
    {
        ++pch;
    }
    // At least one digit...
    if (*pch == '\0')
    {
        --pch;
    }

    strVersionCount = pch;

    return strVersionCount;

}

void CServerPropAdvanced::OnCheckLannames() 
{
	SetDirty(TRUE);

	// mark the snap-in as dirty
	SPITFSNode spNode ;
	spNode = GetHolder()->GetNode();
	
	SPITFSNodeMgr spNodeManager;
	SPITFSNode spRootNode;

	spNode->GetNodeMgr(&spNodeManager);
	spNodeManager->GetRootNode(&spRootNode);

	// mark the data as dirty so that we'll ask the user to save.
    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
	
}

void CServerPropAdvanced::MarkDirty() 
{
	SetDirty(TRUE);	
}

void CServerPropAdvanced::OnCheckBurstHandling() 
{
    SetDirty(TRUE);
    UpdateBurstHandling();	
}

void CServerPropAdvanced::OnRadioCustom() 
{
    SetDirty(TRUE);
    EnableCustomEntry();	
}

void CServerPropAdvanced::OnRadioHigh() 
{
    SetDirty(TRUE);
    EnableCustomEntry();	
}

void CServerPropAdvanced::OnRadioLow() 
{
    SetDirty(TRUE);
    EnableCustomEntry();	
}

void CServerPropAdvanced::OnRadioMedium() 
{
    SetDirty(TRUE);
    EnableCustomEntry();	
}

void CServerPropAdvanced::OnChangeEditCustomValue() 
{
    SetDirty(TRUE);
}

void CServerPropAdvanced::OnButtonBrowseDatabase() 
{
	// TODO: browse for a path
}

void CServerPropAdvanced::OnChangeEditDatabasePath() 
{
    SetDirty(TRUE);
	m_fRestart = TRUE;
}

void CServerPropAdvanced::UpdateBurstHandling()
{
    if (IsWindow(m_checkBurstHandling.GetSafeHwnd()))
    {
        EnableQueSelection(m_checkBurstHandling.GetCheck());
    }
}

void CServerPropAdvanced::EnableQueSelection(BOOL bEnable)
{
    GetDlgItem(IDC_RADIO_LOW)->EnableWindow(bEnable);
    GetDlgItem(IDC_RADIO_MEDIUM)->EnableWindow(bEnable);
    GetDlgItem(IDC_RADIO_HIGH)->EnableWindow(bEnable);
    GetDlgItem(IDC_RADIO_CUSTOM)->EnableWindow(bEnable);
    GetDlgItem(IDC_EDIT_CUSTOM_VALUE)->EnableWindow(bEnable);

    EnableCustomEntry();
}

void CServerPropAdvanced::EnableCustomEntry()
{
    BOOL bEnable = ((CButton *)GetDlgItem(IDC_RADIO_CUSTOM))->GetCheck() &&
                   m_checkBurstHandling.GetSafeHwnd() &&
                   m_checkBurstHandling.GetCheck();

    GetDlgItem(IDC_EDIT_CUSTOM_VALUE)->EnableWindow(bEnable);
}

void CServerPropAdvanced::SetQueSize()
{   
    UINT uControlID = IDC_RADIO_CUSTOM;

    switch (m_pConfig->m_dwBurstQueSize)
    {
        case BURST_QUE_SIZE_LOW:
            uControlID = IDC_RADIO_LOW;
            m_nQueSelection = 0;
            break;

        case BURST_QUE_SIZE_MEDIUM:
            uControlID = IDC_RADIO_MEDIUM;
            m_nQueSelection = 1;
            break;

        case BURST_QUE_SIZE_HIGH:
            uControlID = IDC_RADIO_HIGH;
            m_nQueSelection = 2;
            break;
        
        default:
            {
                TCHAR szBuf[10];

                _itot(m_pConfig->m_dwBurstQueSize, szBuf, 10);
                m_nQueSelection = 3;
                GetDlgItem(IDC_EDIT_CUSTOM_VALUE)->SetWindowText(szBuf);
            }
            break;
    }

    ((CButton *) GetDlgItem(uControlID))->SetCheck(TRUE);
}

DWORD CServerPropAdvanced::GetQueSize()
{
    DWORD dwSize = 0;

    UpdateData();

    if (IsDlgButtonChecked(IDC_RADIO_LOW))
    {
        dwSize = BURST_QUE_SIZE_LOW;
    }
    else
    if (IsDlgButtonChecked(IDC_RADIO_MEDIUM))
    {
        dwSize = BURST_QUE_SIZE_MEDIUM;
    }
    else
    if (IsDlgButtonChecked(IDC_RADIO_HIGH))
    {
        dwSize = BURST_QUE_SIZE_HIGH;
    }
    else
    {
        // must be custom
        CString strText;

        GetDlgItem(IDC_EDIT_CUSTOM_VALUE)->GetWindowText(strText);
        dwSize = (DWORD) _ttoi(strText);
    }

    return dwSize;
}

/////////////////////////////////////////////////////////////////////////////
//
// CServerProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CServerProperties::CServerProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)

{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);
	AddPageToList((CPropertyPageBase*) &m_pageDBRecord);
	AddPageToList((CPropertyPageBase*) &m_pageDBVerification);
	AddPageToList((CPropertyPageBase*) &m_pageAdvanced);

	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}

CServerProperties::~CServerProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageDBRecord, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageDBVerification, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageAdvanced, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\snappp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	snappp.h
		Brings up the Snapin property page
		
    FILE HISTORY:
        
*/


// Snappp.cpp : implementation file
//

#include "stdafx.h"
#include "Snappp.h"
#include "root.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MILLISEC_PER_MINUTE  60 * 1000

/////////////////////////////////////////////////////////////////////////////
// CSnapinPropGeneral property page

IMPLEMENT_DYNCREATE(CSnapinPropGeneral, CPropertyPageBase)

CSnapinPropGeneral::CSnapinPropGeneral() : CPropertyPageBase(CSnapinPropGeneral::IDD)
{
	//{{AFX_DATA_INIT(CSnapinPropGeneral)
	m_fLongName = FALSE;
	m_nOrderByName = 0;
	m_fValidateServers = FALSE;
	//}}AFX_DATA_INIT
}


CSnapinPropGeneral::~CSnapinPropGeneral()
{
}


void CSnapinPropGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSnapinPropGeneral)
	DDX_Control(pDX, IDC_CHECK2, m_checkValidateServers);
	DDX_Check(pDX, IDC_CHECK1, m_fLongName);
	DDX_Radio(pDX, IDC_RADIO1, m_nOrderByName);
	DDX_Control(pDX, IDC_CHECK1, m_checkLongName);
	DDX_Control(pDX, IDC_RADIO1, m_buttonSortByName);
	DDX_Control(pDX, IDC_RADIO2, m_buttonSortByIP);
	DDX_Check(pDX, IDC_CHECK2, m_fValidateServers);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSnapinPropGeneral, CPropertyPageBase)
	//{{AFX_MSG_MAP(CSnapinPropGeneral)
	ON_BN_CLICKED(IDC_CHECK2, OnChange)
	ON_BN_CLICKED(IDC_CHECK1, OnChange)
	ON_BN_CLICKED(IDC_RADIO1, OnChange)
	ON_BN_CLICKED(IDC_RADIO2, OnChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSnapinPropGeneral message handlers

BOOL CSnapinPropGeneral::OnApply() 
{
	if(!IsDirty())
		return TRUE;

	UpdateData();

    GetHolder()->EnablePeekMessageDuringNotifyConsole(TRUE);

	// get the root node 
	SPITFSNode spRootNode;
    CWinsRootHandler * pRoot;

	spRootNode = ((CSnapinProperties*)(GetHolder()))->GetNode();
    pRoot = GETHANDLER(CWinsRootHandler, spRootNode);

	// set the values in the root handler
	if (m_fValidateServers)
		pRoot->m_dwFlags |= FLAG_VALIDATE_CACHE;
	else
		pRoot->m_dwFlags &= ~FLAG_VALIDATE_CACHE;

	// need to do this bcoz' changing the server order and the display name takes a
	// long time
    BOOL fOrderByName = (m_nOrderByName == 0) ? TRUE : FALSE;

	m_bDisplayServerOrderChanged = (fOrderByName == pRoot->GetOrderByName()) ? FALSE : TRUE;

	m_bDisplayFQDNChanged = (m_fLongName == pRoot->GetShowLongName()) ? FALSE : TRUE;

	// don't do anything, if the properties remained the same
	if (!m_bDisplayFQDNChanged && !m_bDisplayServerOrderChanged)
		return TRUE;
		
	// set the servername of the rootnode to the one updated
	pRoot->SetShowLongName(m_fLongName);
    pRoot->SetOrderByName(fOrderByName);

    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);

    return CPropertyPageBase::OnApply();
}


BOOL CSnapinPropGeneral::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	// get the root node 
	// now add the node to the tree
	
	SPITFSNode spRootNode;
    CWinsRootHandler * pRoot;

	spRootNode = ((CSnapinProperties*)(GetHolder()))->GetNode();
    pRoot = GETHANDLER(CWinsRootHandler, spRootNode);

	m_uImage = (UINT) spRootNode->GetData(TFS_DATA_IMAGEINDEX);

	m_fLongName = pRoot->GetShowLongName();
	BOOL fOrderByName = pRoot->GetOrderByName();

    m_nOrderByName = (fOrderByName) ? 0 : 1;

	if (m_fLongName)
		m_checkLongName.SetCheck(TRUE);
	else
		m_checkLongName.SetCheck(FALSE);

	if (m_nOrderByName == 0)
	{
		m_buttonSortByName.SetCheck(TRUE);
		m_buttonSortByIP.SetCheck(FALSE);
	}
	else
	{
		m_buttonSortByName.SetCheck(FALSE);
		m_buttonSortByIP.SetCheck(TRUE);
	}

	if (pRoot->m_dwFlags & FLAG_VALIDATE_CACHE)
		m_checkValidateServers.SetCheck(TRUE);
	else
		m_checkValidateServers.SetCheck(FALSE);

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }

	SetDirty(FALSE);
	
	return TRUE;  
}


/////////////////////////////////////////////////////////////////////////////
//
// CSnapinProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CSnapinProperties::CSnapinProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);
	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}

CSnapinProperties::~CSnapinProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

BOOL 
CSnapinPropGeneral::OnPropertyChange(BOOL bScope, LONG_PTR * ChangeMask)
{
	SPITFSNode spRootNode;
    CWinsRootHandler * pRoot;

	spRootNode = ((CSnapinProperties*)(GetHolder()))->GetNode();
    pRoot = GETHANDLER(CWinsRootHandler, spRootNode);

	// enumerate thro' all the nodes
	HRESULT hr = hrOK;
	SPITFSNodeEnum spNodeEnum;
	SPITFSNodeEnum spNodeEnumAdd;
    SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;
	
    BEGIN_WAIT_CURSOR;

    if (m_bDisplayFQDNChanged)
	{
		CHAR szStringName[MAX_PATH] = {0};
		
		// get the enumerator for this node
		spRootNode->GetEnum(&spNodeEnum);

		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
		
		while (nNumReturned)
		{
			// if the status node is encountered, just ignore
			const GUID *pGuid;

			pGuid = spCurrentNode->GetNodeType();

			if(*pGuid == GUID_WinsServerStatusNodeType)
			{
				spCurrentNode.Release();
			
				// get the next Server in the list
				spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

				continue;
			}

			// walk the list of servers 
            CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, spCurrentNode);

            pServer->SetDisplay(spCurrentNode, m_fLongName);

            spCurrentNode.Release();
			
            // get the next Server in the list
            spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

        }// while
	}

    END_WAIT_CURSOR;

    BOOL fValidate = pRoot->m_fValidate;

    // turn off validation if it is on.
    pRoot->m_fValidate = FALSE;

    if (spNodeEnum)
        spNodeEnum.Set(NULL);

    if (m_bDisplayServerOrderChanged)
	{
		const GUID *pGuid;
        CTFSNodeList tfsNodeList;

        // get the enumerator for this node
		spRootNode->GetEnum(&spNodeEnum);

        // first remove all of the server nodes from the UI
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
		while (nNumReturned)
		{
			pGuid = spCurrentNode->GetNodeType();

			if (*pGuid == GUID_WinsServerStatusNodeType)
			{
				spCurrentNode.Release();
			
				// get the next Server in the list
				spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

				continue;
			}

            // remove from the UI
            spRootNode->ExtractChild(spCurrentNode);

            // add ref the pointer since we need to put it on the list
            // and adding it to the list doesn't addref
            spCurrentNode->AddRef();
            tfsNodeList.AddTail(spCurrentNode);

            // reset our smart pointer
            spCurrentNode.Set(NULL);

            // get the next Server in the list
			spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

        // Next put them back in sorted
		while (tfsNodeList.GetCount() > 0)
		{
			// get the next Server in the list
    		spCurrentNode = tfsNodeList.RemoveHead();

            // if the status node is encountered, just ignore
			pGuid = spCurrentNode->GetNodeType();

			if (*pGuid == GUID_WinsServerStatusNodeType)
			{
				spCurrentNode.Release();
			
				continue;
			}

            // walk the list of servers 
			CWinsServerHandler *pServer = GETHANDLER(CWinsServerHandler, spCurrentNode);

			pRoot->AddServer(pServer->m_strServerAddress,
							FALSE,
							pServer->m_dwIPAdd,
							pServer->GetConnected(),
							pServer->m_dwFlags,
							pServer->m_dwRefreshInterval);

            // releasing here destroys the object
            spCurrentNode.Release();
		}
	}

    // restore the flag
    pRoot->m_fValidate = fValidate;

	return FALSE;
}


void CSnapinPropGeneral::OnChange() 
{
	SetDirty(TRUE);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\statmap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	statmap.cpp
		WINS static mappings node information. 
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "statmap.h"

/*---------------------------------------------------------------------------
	CStaticMappingsHandler::CStaticMappingsHandler
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CStaticMappingsHandler::CStaticMappingsHandler(ITFSComponentData *pCompData) : CWinsHandler(pCompData)
{
}

/*!--------------------------------------------------------------------------
	CStaticMappingsHandler::InitializeNode
		Initializes node specific data
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CStaticMappingsHandler::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString strTemp;
	strTemp.LoadString(IDS_ROOT_NODENAME);

	SetDisplayName(strTemp);

	// Make the node immediately visible
	//pNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
	pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_SERVER);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_SERVER);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);

	SetColumnStringIDs(&aColumns[WINSSNAP_ROOT][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_ROOT][0]);

	return hrOK;
}

/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CStaticMappingsHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CStaticMappingsHandler::GetString
(
	ITFSNode *	pNode, 
	int			nCol
)
{
	if (nCol == 0 || nCol == -1)
		return GetDisplayName();
	else
		return NULL;
}

/*---------------------------------------------------------------------------
	CStaticMappingsHandler::OnAddMenuItems
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CStaticMappingsHandler::OnAddMenuItems
(
	ITFSNode *				pNode,
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	LPDATAOBJECT			lpDataObject, 
	DATA_OBJECT_TYPES		type, 
	DWORD					dwType
)
{ 
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	CString strMenuItem;

	strMenuItem.LoadString(IDS_ADD_SERVER);

	if (type == CCT_SCOPE)
	{
		// these menu items go in the new menu, 
		// only visible from scope pane

		ASSERT( SUCCEEDED(hr) );
	}

	return hr; 
}

/*---------------------------------------------------------------------------
	CStaticMappingsHandler::OnCommand
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CStaticMappingsHandler::OnCommand
(
	ITFSNode *			pNode, 
	long				nCommandId, 
	DATA_OBJECT_TYPES	type, 
	LPDATAOBJECT		pDataObject, 
	DWORD				dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

	return hr;
}

/*!--------------------------------------------------------------------------
	CStaticMappingsHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CStaticMappingsHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = hrFalse;
	}
	else
	{
		// we have property pages in the normal case
		hr = hrFalse;
	}
	return hr;
}

/*---------------------------------------------------------------------------
	CStaticMappingsHandler::CreatePropertyPages
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CStaticMappingsHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT	hr = hrOK;
	HPROPSHEETPAGE hPage;

	Assert(pNode->GetData(TFS_DATA_COOKIE) == 0);
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		//
		// We are loading this snapin for the first time, put up a property
		// page to allow them to name this thing.
		// 
	}
	else
	{
		//
		// Object gets deleted when the page is destroyed
		//
	}

Error:
	return hr;
}

/*---------------------------------------------------------------------------
	CStaticMappingsHandler::OnPropertyChange
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CStaticMappingsHandler::OnPropertyChange
(	
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataobject, 
	DWORD			dwType, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return hrOK;
}

/*---------------------------------------------------------------------------
	Command handlers
 ---------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\statmap.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	statmap.h
		WINS static mappings node information. 
		
    FILE HISTORY:
        
*/

#ifndef _STATMAP_H
#define _STATMAP_H

#ifndef _WINSHAND_H
#include "winshand.h"
#endif

/*---------------------------------------------------------------------------
	Class:	CStaticMappingsHandler
 ---------------------------------------------------------------------------*/
class CStaticMappingsHandler : public CWinsHandler
{
// Interface
public:
	CStaticMappingsHandler(ITFSComponentData *pCompData);


	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();

	OVERRIDE_NodeHandler_GetString();

	// helper routines
	HRESULT GetGroupName(CString * pstrGroupName);
	HRESULT SetGroupName(LPCTSTR pszGroupName);

public:
	// CWinsHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

    OVERRIDE_BaseHandlerNotify_OnPropertyChange()

// Implementation
private:
};

#endif _STATMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\statmapp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	statmapp.cpp
		Property Page for Active Registrations Record

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "winssnap.h"
#include "statmapp.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Static Record Types
CString g_strStaticTypeUnique;
CString g_strStaticTypeDomainName;
CString g_strStaticTypeMultihomed;
CString g_strStaticTypeGroup;
CString g_strStaticTypeInternetGroup;
CString g_strStaticTypeUnknown;

/////////////////////////////////////////////////////////////////////////////
static const char rgchHex[16*2+1] = "00112233445566778899aAbBcCdDeEfF";

/*---------------------------------------------------------------------------
	FGetByte()

	Return the byte value of a string.
	Return TRUE pbNum is set to the byte value (only if the string contains
	valid digits)
	Return FALSE if string has unrecognized digits or byte overflow.
	
	eg:
	szNum =	"xFF"	=> return TRUE
	szNum =	"255"	=> return TRUE
	szNum = "256"	=> return FALSE (overflow)
	szNum = "26a"	=> return TRUE (*pbNum = 26, *ppchNext = "a")
	szNum = "ab"	=> return FALSE (unrecognized digits)
 ---------------------------------------------------------------------------*/
BOOL 
FGetByte(IN const char szNum[], OUT BYTE * pbNum, OUT const char ** ppchNext)
{
	ASSERT(szNum);
	ASSERT(pbNum);
	ASSERT(ppchNext);
	
	int nResult;
	char * pchNum = (char *)szNum;
	int iBase = 10;			// Assume a decimal base
	
	if (*pchNum == 'x' || *pchNum == 'X')			// Check if we are using hexadecimal base
	{
		iBase = 16;
		pchNum++;
	}

	char * pchDigit = strchr(rgchHex, *pchNum++);
	
	if (pchDigit == NULL)
		return FALSE;
	
	int iDigit = (int) ((pchDigit - rgchHex) >> 1);
	
	if (iDigit >= iBase)
	{
		// Hexadecimal character in a decimal integer
		return FALSE;
	}
	
	nResult = iDigit;
	pchDigit = strchr(rgchHex, *pchNum);
	iDigit = (int) ((pchDigit - rgchHex) >> 1);

	if (pchDigit == NULL || iDigit >= iBase)
	{
		// Only one character was valid
		*pbNum = (BYTE) nResult;
		*ppchNext = pchNum;
		return TRUE;
	}
	
	pchNum++;
	nResult = (nResult * iBase) + iDigit;
	
	ASSERT(nResult < 256);
	
	if (iBase == 16)
	{
		// Hexadecimal value, stop there
		*pbNum = (BYTE) nResult;
		*ppchNext = pchNum;
		return TRUE;
	}
	
	// Decimal digit, so search for an optional third character
	pchDigit = strchr(rgchHex, *pchNum);
	iDigit = (int) ((pchDigit - rgchHex) >> 1);
	
	if (pchDigit == NULL || iDigit >= iBase)
	{
		*pbNum = (BYTE) nResult;
		*ppchNext = pchNum;
		return TRUE;
	}
	
	nResult = (nResult * iBase) + iDigit;
	
	if (nResult >= 256)
		return FALSE;
	
	pchNum++;
	*pbNum = (BYTE) nResult;
	*ppchNext = pchNum;
	
	return TRUE;
} // FGetByte


/////////////////////////////////////////////////////////////////////////////
// CStaticMappingProp property page

IMPLEMENT_DYNCREATE(CStaticMappingProp, CPropertyPageBase)

CStaticMappingProp::CStaticMappingProp(UINT uIDD) 
	:	CPropertyPageBase(uIDD), 
		m_fStaticPropChanged (TRUE),
		m_uIDD(uIDD)
{
	//{{AFX_DATA_INIT(CStaticMappingProp)
	m_strName = _T("");
	m_strType = _T("");
	m_strScopeName = _T("");
	//}}AFX_DATA_INIT
}


CStaticMappingProp::~CStaticMappingProp()
{
}

void 
CStaticMappingProp::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStaticMappingProp)
	DDX_Control(pDX, IDC_EDIT_SCOPE_NAME, m_editScopeName);
	DDX_Control(pDX, IDC_LIST_IPADD, m_listIPAdd);
	DDX_Control(pDX, IDC_BUTTON_REMOVE, m_buttonRemove);
	DDX_Control(pDX, IDC_BUTTON_ADD, m_buttonAdd);
	DDX_Control(pDX, IDC_EDIT_COMPNAME, m_editName);
	DDX_Control(pDX, IDC_COMBO_STATIC_TYPE, m_comboType);
	DDX_Text(pDX, IDC_EDIT_COMPNAME, m_strName);
	DDX_CBString(pDX, IDC_COMBO_STATIC_TYPE, m_strType);
	DDX_Text(pDX, IDC_EDIT_SCOPE_NAME, m_strScopeName);
	//}}AFX_DATA_MAP

	DDX_Control(pDX, IDC_IPADD, m_editCustomIPAdd);
	//DDX_Control(pDX, IDC_IPADD, m_ipControl);
	DDX_Text(pDX, IDC_IPADD, m_strIPAdd);
}


BEGIN_MESSAGE_MAP(CStaticMappingProp, CPropertyPageBase)
	//{{AFX_MSG_MAP(CStaticMappingProp)
	ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
	ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
	ON_CBN_SELCHANGE(IDC_COMBO_STATIC_TYPE, OnSelchangeComboType)
	ON_EN_CHANGE(IDC_EDIT_COMPNAME, OnChangeEditCompname)
	ON_LBN_SELCHANGE(IDC_LIST_IPADD, OnSelChangeListIpAdd)
	//}}AFX_MSG_MAP

	// IP Address control
	ON_EN_CHANGE(IDC_IPADD, OnChangeIpAddress)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CStaticMappingProp message handlers
void CStaticMappingProp::OnOK() 
{
	CPropertyPageBase::OnOK();
}


BOOL 
CStaticMappingProp::OnApply() 
{
	HRESULT hr = hrOK;
    BOOL    bRet = TRUE;

	// if not dirtied return
	if (!IsDirty())
		return TRUE;

	if (((CStaticMappingProperties*)GetHolder())->m_bWizard)
	{
		UpdateData();

		CActiveRegistrationsHandler *pActReg;

		SPITFSNode  spNode;
		spNode = GetHolder()->GetNode();

		pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

		m_strName.TrimLeft();
		m_strName.TrimRight();

        int nMax = (pActReg->IsLanManCompatible()) ? 15 : 16;
		if (m_strName.IsEmpty())
		{
            CString strMessage, strTemp;
            strTemp.Format(_T("%d"), nMax);

            AfxFormatString1(strMessage, IDS_INVALID_NAME, strTemp);
			AfxMessageBox(strMessage);

            m_editName.SetFocus();
			m_editName.SetSel(0, -1);
			
            return FALSE;
		}
		else 
        if (m_strType.IsEmpty())
		{
			AfxMessageBox(IDS_INVALID_TYPE, MB_OK);
			m_comboType.SetFocus();
			return FALSE;
		}

		CString strTemp;

		// check this only for Unique and Normal Group addresses,
		// for the rest, the ipcontrol is balnk and the list box holds the IP a
		// IP addresses for them.

		DWORD dwIp1, dwIp2, dwIp3, dwIp4;
		int nAdd = m_ipControl.GetAddress(&dwIp1, &dwIp2, &dwIp3, &dwIp4);

		LONG lIPAdd = (LONG) MAKEIPADDRESS(dwIp1, dwIp2, dwIp3, dwIp4);

		// it's so bcoz' only in the case of Unique and Normal Group names,
		// IP address is read from the IP control, else from the list box

		if ( (m_strType.CompareNoCase(g_strStaticTypeUnique) == 0) || (m_strType.CompareNoCase(g_strStaticTypeGroup) == 0) )
		{
			if (nAdd != 4)
			{
				AfxMessageBox(IDS_INVALID_IPADDRESS, MB_OK);
				m_editCustomIPAdd.SetFocus();
				return FALSE;
			}

            // check if broadcast address has been entered
			if (m_strIPAdd.CompareNoCase(_T("255.255.255.255")) == 0)
			{
				AfxMessageBox(IDS_INVALID_IPADDRESS, MB_OK);
				m_editCustomIPAdd.SetFocus();
				return FALSE;
			}

            // check to make sure something was entered
            if ( (m_strIPAdd.IsEmpty()) ||
                 (m_strIPAdd.CompareNoCase(_T("0.0.0.0")) == 0) )
            {
			    AfxMessageBox(IDS_INVALID_IPADDRESS, MB_OK);
			    m_editCustomIPAdd.SetFocus();
			    m_editCustomIPAdd.SetSel(0,-1);
			    return FALSE;
            }
		}
        else
        {
            if (m_listIPAdd.GetCount() == 0)
		    {
			    AfxMessageBox(IDS_INVALID_IPADDRESS, MB_OK);
			    m_editCustomIPAdd.SetFocus();
			    m_editCustomIPAdd.SetSel(0,-1);
			    return FALSE;
    		}
        }

		BOOL fInternetGroup = FALSE;

		if (m_strType.CompareNoCase(g_strStaticTypeInternetGroup) == 0)
			fInternetGroup = TRUE;

		// Parse the string
		BOOL fValid = TRUE;
		BOOL fBrackets = FALSE;
		BYTE rgbData[100];
		BYTE bDataT;
		int cbData = 0;
		LPSTR szTemp = (char*) alloca(100);

        // just use ACP here because we are just looking at the string
        // we will do the OEM conversion later.
        WideToMBCS(m_strName, szTemp);

		const char * pch = (LPCSTR)szTemp;

		while (*pch)
		{
			if (fBrackets)
			{
				fValid = FALSE;
				goto Done;
			}
		
			if (cbData > 16)
				goto Done;
					
			switch (*pch)
			{
			case '\\':
				pch++;
			
				if (*pch == '\\' || *pch == '[')
				{
					rgbData[cbData++] = *pch++;
					break;	
				}
			
				if (!FGetByte(pch, &bDataT, &pch) || !bDataT)
				{
					fValid = FALSE;
					goto Done;
				}
				
				rgbData[cbData++] = bDataT;
				
				break;

			case '[':
			{
				char szT[4] = { 0 };
				const char * pchT;

				fBrackets = TRUE;
				pch++;
				
				if (*(pch + 1) == 'h' || *(pch + 1) == 'H')
				{
					szT[0] = 'x';
					szT[1] = *pch;
					pch += 2;
				}
				
				else if (*(pch + 2) == 'h' || *(pch + 2) == 'H')
				{
					szT[0] = 'x';
					szT[1] = *pch;
					szT[2] = *(pch + 1);
					pch += 3;
				}
				
				if (szT[0])
				{
					if (!FGetByte(szT, &bDataT, &pchT) || !bDataT || *pchT)
					{
						fValid = FALSE;
						goto Done;
					}
				}
				
				else if (!FGetByte(pch, &bDataT, &pch) || !bDataT)
				{
					fValid = FALSE;
					goto Done;
				}
				
				if (*pch++ != ']')
				{
					fValid = FALSE;
					goto Done;
				}
				
				while (cbData < 15)
					rgbData[cbData++] = ' ';
				
				rgbData[cbData++] = bDataT;
			}
			break;

			default:

	#ifdef FE_SB

				if (::IsDBCSLeadByte(*pch))
					rgbData[cbData++] = *pch++;

	#endif
				
				rgbData[cbData++] = *pch++;
				
			} // switch

		}
		
			
		
	Done:
		// Put a null-terminator at end of string
		rgbData[cbData] = 0;

		if (!cbData || cbData > nMax)
		{
            CString strMessage, strTemp;
            strTemp.Format(_T("%d"), nMax);

            AfxFormatString1(strMessage, IDS_INVALID_NAME, strTemp);
			AfxMessageBox(strMessage);

            m_editName.SetFocus();
			m_editName.SetSel(0,-1);
			
            return FALSE;
		}
		
		if (!fValid)
		{
            CString strMessage, strTemp;
            strTemp.Format(_T("%d"), nMax);

            AfxFormatString1(strMessage, IDS_INVALID_NAME, strTemp);
			AfxMessageBox(strMessage);

            m_editName.SetFocus();
			m_editName.SetSel(0,-1);
			
            return FALSE;
		}
		
		if (fInternetGroup && rgbData[15] == 0x1C)
		{
			AfxMessageBox(IDS_INVALID_INTERNET_GROUP_NAME);
			m_editName.SetFocus();
			m_editName.SetSel(0,-1);
			
            return FALSE;
		}

		if (fInternetGroup)
        {
			while (cbData <= 15)
				rgbData[cbData++] = ' ';
		
        	rgbData[cbData] = 0;
        }

		szTemp = (LPSTR)rgbData;

        // convert our touched up string back to unicode for use later
        MBCSToWide(szTemp, pActReg->m_strStaticMappingName);
        
        //pActReg->m_strStaticMappingName = rgbData;
		pActReg->m_strStaticMappingScope = m_strScopeName;
		pActReg->m_strStaticMappingType = m_strType;
		
        AssignMappingType();
		
        pActReg->m_nStaticMappingType = m_fType;

		// clear the IP adress array maintained in theactreg handler first
		pActReg->m_strArrayStaticMappingIPAddress.RemoveAll();
		pActReg->m_lArrayIPAddress.RemoveAll();

		if ( (m_strType.CompareNoCase(g_strStaticTypeUnique) == 0) || (m_strType.CompareNoCase(g_strStaticTypeGroup) == 0) )
		{
			pActReg->m_strArrayStaticMappingIPAddress.Add(m_strIPAdd);
			pActReg->m_lArrayIPAddress.Add(lIPAdd);
		}
		// copy from the array
		else
		{
			for (int i = 0; i < m_strArrayIPAdd.GetSize(); i++)
			{
				pActReg->m_strArrayStaticMappingIPAddress.Add(m_strArrayIPAdd.GetAt(i));
				pActReg->m_lArrayIPAddress.Add(m_dwArrayIPAdd.GetAt(i));
			}
		}

        // do the thread context switch so we can update the UI as well
	    bRet = CPropertyPageBase::OnApply();

	    if (bRet == FALSE)
	    {
		    // Something bad happened... grab the error code
		    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		    ::WinsMessageBox(GetHolder()->GetError());
	    }
		else
		{
			// set back the defaults for the controls
			m_comboType.SelectString(-1, g_strStaticTypeUnique);
							
			m_editCustomIPAdd.ShowWindow(TRUE);
			m_editCustomIPAdd.SetWindowText(_T(""));
			m_editName.SetWindowText(_T(""));
			m_editScopeName.SetWindowText(_T(""));

			// clear and hide the list box and the Add and Remove buttons
			m_buttonAdd.ShowWindow(FALSE);
			m_buttonRemove.ShowWindow(FALSE);

			int nCount = m_listIPAdd.GetCount();

			for (int i= 0; i < nCount; i++)
			{
				m_listIPAdd.DeleteString(i);
			}

			m_listIPAdd.ShowWindow(FALSE);
			m_listIPAdd.ResetContent();
			m_strArrayIPAdd.RemoveAll();
			m_dwArrayIPAdd.RemoveAll();

			SetRemoveButtonState();

            SetDirty(FALSE);
		}
	}
	// if static mapping properties are modified, we need to do this
	else 
	{
		// validate the data and copy to ActReg node
		UpdateData();

		SPITFSNode  spNode;
		spNode = GetHolder()->GetNode();

		CActiveRegistrationsHandler *pActReg;

		pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

		// clear the array of IP addresses maintained in the act reg handler
		pActReg->m_strArrayStaticMappingIPAddress.RemoveAll();
		pActReg->m_lArrayIPAddress.RemoveAll();


		DWORD dwIp1, dwIp2, dwIp3, dwIp4;
		int nAdd = m_ipControl.GetAddress(&dwIp1, &dwIp2, &dwIp3, &dwIp4);

		if ( (m_strType.CompareNoCase(g_strStaticTypeUnique) == 0)|| (m_strType.CompareNoCase(g_strStaticTypeGroup) == 0))
		{
			if (nAdd != 4)
			{
				AfxMessageBox(IDS_ERR_INVALID_IP, MB_OK);
				// set focus to the IP address control
				m_editCustomIPAdd.SetFocus();
				return hrFalse;
			}
			
		}
		
		LONG lIPAdd = (LONG) MAKEIPADDRESS(dwIp1, dwIp2, dwIp3, dwIp4);

		pActReg->m_strStaticMappingName = m_strName;
		pActReg->m_strStaticMappingType = m_strType;

		AssignMappingType();
		
		pActReg->m_nStaticMappingType = m_fType;

	
		if ( (m_strType.CompareNoCase(g_strStaticTypeUnique) == 0)|| (m_strType.CompareNoCase(g_strStaticTypeGroup) == 0))
		{
			pActReg->m_strArrayStaticMappingIPAddress.Add(m_strIPAdd);
			pActReg->m_lArrayIPAddress.Add(lIPAdd);
		}
		// copy from the array
		else
		{
			for (int i = 0; i < m_strArrayIPAdd.GetSize(); i++)
			{
				pActReg->m_strArrayStaticMappingIPAddress.Add(m_strArrayIPAdd.GetAt(i));
				pActReg->m_lArrayIPAddress.Add(m_dwArrayIPAdd.GetAt(i));
			}
		}

        // do the thread context switch so we can update the UI as well
	    bRet = CPropertyPageBase::OnApply();

	    if (bRet == FALSE)
	    {
		    // Something bad happened... grab the error code
		    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		    ::WinsMessageBox(GetHolder()->GetError());
	    }
	}

	return bRet;
}

void 
CStaticMappingProp::AssignMappingType()
{
	if (m_strType.CompareNoCase(g_strStaticTypeInternetGroup) == 0)
		m_fType = WINSINTF_E_SPEC_GROUP;
	else 
    if (m_strType.CompareNoCase(g_strStaticTypeUnique) == 0)
		m_fType = WINSINTF_E_UNIQUE;
	else 
    if (m_strType.CompareNoCase(g_strStaticTypeMultihomed) == 0)
		m_fType = WINSINTF_E_MULTIHOMED;
	else 
    if (m_strType.CompareNoCase(g_strStaticTypeGroup) == 0)
		m_fType = WINSINTF_E_NORM_GROUP;
	else 
    if (m_strType.CompareNoCase(g_strStaticTypeDomainName)== 0)
		m_fType = WINSINTF_E_SPEC_GROUP;
}


void 
CStaticMappingProp::OnChangeIpAddress()
{
	SetDirty(TRUE);
	CString strText;
	m_editCustomIPAdd.GetWindowText(strText);

	if (strText.IsEmpty())
	{
		// disable the Add and Remove buttons
        CWnd * pCurFocus = GetFocus();

        if (m_buttonAdd.GetSafeHwnd() == pCurFocus->GetSafeHwnd() ||
            m_buttonRemove.GetSafeHwnd() == pCurFocus->GetSafeHwnd())
        {
            m_editCustomIPAdd.SetFocus();
        }

		m_buttonAdd.EnableWindow(FALSE);
		m_buttonRemove.EnableWindow(FALSE);
	}

	UpdateData();

	DWORD dwIp1, dwIp2, dwIp3, dwIp4;
	int nAdd = m_ipControl.GetAddress(&dwIp1, &dwIp2, &dwIp3, &dwIp4);

	if (nAdd != 4)
	{
        CWnd * pCurFocus = GetFocus();

        if (m_buttonAdd.GetSafeHwnd() == pCurFocus->GetSafeHwnd())
        {
            m_editCustomIPAdd.SetFocus();
        }

        m_buttonAdd.EnableWindow(FALSE);
	}
	else
	{
		m_buttonAdd.EnableWindow(TRUE);
	}

	SetRemoveButtonState();
}


BOOL 
CStaticMappingProp::OnInitDialog() 
{
	// Initialize the IP address controls
	m_ipControl.Create(m_hWnd, IDC_IPADD);
	m_ipControl.SetFieldRange(0, 0, 255);
    
	CPropertyPageBase::OnInitDialog();

    // fill in the type strings
    m_comboType.AddString(g_strStaticTypeUnique);
    m_comboType.AddString(g_strStaticTypeGroup);
    m_comboType.AddString(g_strStaticTypeDomainName);
    m_comboType.AddString(g_strStaticTypeInternetGroup);
    m_comboType.AddString(g_strStaticTypeMultihomed);

    if (((CStaticMappingProperties*)GetHolder())->m_bWizard)
	{
        // set control states for the wizard part
        HWND hWndSheet = ((CStaticMappingProperties*)GetHolder())->GetSheetWindow();
        CString strTitle;

        strTitle.LoadString(IDS_CREATE_STATIC_MAPPING);
        ::SetWindowText(hWndSheet, strTitle);

        SetDefaultControlStates();
		m_editScopeName.SetReadOnly(FALSE);

		m_comboType.SelectString(-1, g_strStaticTypeUnique);
	}
	else
	{
        m_editScopeName.SetReadOnly(TRUE);
		m_buttonAdd.ShowWindow(FALSE);
		m_buttonRemove.ShowWindow(FALSE);
		m_listIPAdd.ShowWindow(FALSE);
		
        SetRemoveButtonState();

		// owner only visible in properties mode
		WinsRecord ws = ((CStaticMappingProperties*)GetHolder())->m_wsRecord;

        if (ws.dwOwner != INVALID_OWNER_ID)
        {
		    CString strOwner;
		    MakeIPAddress(ws.dwOwner, strOwner);
            GetDlgItem(IDC_EDIT_OWNER)->SetWindowText(strOwner);
        }
		
        FillControls();
	}

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }

    SetDirty(FALSE);

	return TRUE;  
}


BOOL 
CStaticMappingProp::FillControls()
{
	// get the actreg node
	BOOL                            fHasScope = FALSE;
    CActiveRegistrationsHandler *   pActReg;
    SPITFSNode                      spNode;
	
    spNode = GetHolder()->GetNode();
	pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

	WinsRecord ws = ((CStaticMappingProperties*)GetHolder())->m_wsRecord;

	// name and the IP address ypu anyway fill. the reamining depending on
	// whether it's a static or dynamic record

    if (ws.dwNameLen > 16)
    {
        fHasScope = TRUE;
    }

	// build the name string
	CString strName, strScopeName;
    pActReg->CleanNetBIOSName(ws.szRecordName,
                              strName,
						      TRUE,   // Expand
							  TRUE,   // Truncate
							  pActReg->IsLanManCompatible(), 
							  TRUE,   // name is OEM
							  FALSE,  // No double backslash
                              ws.dwNameLen);

	// check if it has a scope name attached to it., looking for a period
    if (fHasScope)
    {
        LPSTR pScope = &ws.szRecordName[17];

        // INTL$ should this be OEMCP, not ACP
        MBCSToWide(pScope, strScopeName, WINS_NAME_CODE_PAGE);

        int nPos = strName.Find(strScopeName);
	    // means that the scope name is attached
	    if ( (nPos != -1) &&
             (!strScopeName.IsEmpty()) )
	    {
            // all we want here is the name
            strName = strName.Left(nPos - 1);
        }
    }
    
    m_strName = strName;
	m_strScopeName = strScopeName;

    // IP address
	CString strIP;

	if (ws.dwState & WINSDB_REC_UNIQUE || ws.dwState & WINSDB_REC_NORM_GROUP)
	{
		for (DWORD i = 0; i < ws.dwNoOfAddrs; i++)
		{
			MakeIPAddress(ws.dwIpAdd[i], strIP);
            m_strArrayIPAdd.Add(strIP);
            m_dwArrayIPAdd.Add(ws.dwIpAdd[i]);
		}
	}
	// in this case the first IP address is that of the owner,
	else
	{
		DWORD dwPos = 1;

		for (DWORD i = 0; i < ws.dwNoOfAddrs/2; ++i)
		{
            ::MakeIPAddress(ws.dwIpAdd[dwPos], strIP);
			m_strArrayIPAdd.Add(strIP);
            m_dwArrayIPAdd.Add(ws.dwIpAdd[dwPos]);
			++dwPos;
			++dwPos;
		}
	}
	
	// text in the controls now
	m_editName.SetWindowText(m_strName);
	m_editScopeName.SetWindowText(m_strScopeName);

	//check if the record is static
	if (ws.dwState & WINSDB_REC_STATIC)
	{
		// active status
		CString strStaticType;
		pActReg->GetStaticTypeString(ws.dwState, strStaticType);

		if (strStaticType.CompareNoCase(g_strStaticTypeDomainName) == 0)
		{
			//could be either Internet Group or Domain Name
			// check for the 15th character , if 1C, then Domain Name 
			// else Internet Group Name

			if ((BYTE)ws.szRecordName[15] == 0x1C)
				strStaticType = g_strStaticTypeDomainName;
			else
				strStaticType = g_strStaticTypeInternetGroup;
		}
		
		FillStaticRecData(strStaticType);

		//m_fStaticPropChanged = TRUE;
		m_strType = strStaticType;
	}
	else
	{
	}
	
	return TRUE;
}


void 
CStaticMappingProp::FillStaticRecData(CString& strType)
{
	// hide the combobox too, show the IPAdd control
	m_editCustomIPAdd.ShowWindow(TRUE);

	// display the combobox
	m_comboType.ShowWindow(TRUE);

	// disable thew type combobox
	m_comboType.EnableWindow(FALSE);

	// get the type of record
	m_comboType.SelectString(-1, strType);

	// make the records read only.
	m_editName.SetReadOnly();

	// depending on the type, hide/show the list control
	// and the add remove buttons.
	if ( (strType.CompareNoCase(g_strStaticTypeUnique) == 0) || strType.CompareNoCase(g_strStaticTypeGroup) == 0)
	{
		m_listIPAdd.ShowWindow(FALSE);
		m_buttonAdd.ShowWindow(FALSE);
		m_buttonRemove.ShowWindow(FALSE);

		m_editCustomIPAdd.ShowWindow(TRUE);
		m_editCustomIPAdd.SetReadOnly(FALSE);
		
		// set it's text to that in the combo box
		CString strIP;
        strIP = m_strArrayIPAdd.GetAt(0);

		m_strOnInitIPAdd = strIP;

		m_ipControl.SetAddress(strIP);
	}
	else
	{
		m_listIPAdd.ShowWindow(TRUE);
		m_buttonAdd.ShowWindow(TRUE);
		m_buttonRemove.ShowWindow(TRUE);

		m_editCustomIPAdd.ShowWindow(TRUE);
		m_editCustomIPAdd.SetReadOnly(FALSE);

		// fill the contents with that from the combo box
		FillList();

		if (m_strArrayIPAdd.GetSize() > 0)
			m_strOnInitIPAdd = m_strArrayIPAdd.GetAt(0);
	}

	SetRemoveButtonState();
}


void 
CStaticMappingProp::FillList()
{
    CString strIP;

	// clear the list box next
	for (int i = 0; i < m_listIPAdd.GetCount(); i++)
		m_listIPAdd.DeleteString(i);

	int nCount = (int) m_strArrayIPAdd.GetSize();

	for (i = 0; i < nCount; i++)
	{
        strIP = m_strArrayIPAdd.GetAt(i);

        m_listIPAdd.AddString(strIP);
        
        if (nCount == 1)
            m_ipControl.SetAddress(strIP);
	}

	m_ipControl.SetAddress(_T(""));
	m_editCustomIPAdd.SetWindowText(_T(""));
	
	SetRemoveButtonState();
}


void 
CStaticMappingProp::FillDynamicRecData(CString& strType, CString& strActive, CString& strExpiration, CString& strVersion)
{
}


void 
CStaticMappingProp::SetDefaultControlStates()
{
	m_comboType.EnableWindow(TRUE);
	m_comboType.ShowWindow(TRUE);

	m_editCustomIPAdd.ShowWindow(TRUE);

	SetRemoveButtonState();
}


void 
CStaticMappingProp::OnButtonAdd() 
{
	UpdateData();

	// add the IPAdd in the IPControl to the list box
	// if valid

	// check if broadcast address is being added
	if (m_strIPAdd.CompareNoCase(_T("255.255.255.255")) == 0)
	{
		AfxMessageBox(IDS_INVALID_IPADDRESS, MB_OK);
		m_editCustomIPAdd.SetFocus();
		return;
	}

	DWORD dwIp1, dwIp2, dwIp3, dwIp4;
	int nAdd = m_ipControl.GetAddress(&dwIp1, &dwIp2, &dwIp3, &dwIp4);

	// check if the address is alreay in the list
	for (int i = 0; i < m_strArrayIPAdd.GetSize() ; i++)
	{
		if (m_strArrayIPAdd[i].CompareNoCase(m_strIPAdd) == 0)
		{
			AfxMessageBox(IDS_ERR_IP_EXISTS, MB_OK);
			m_editCustomIPAdd.SetFocus();
			m_editCustomIPAdd.SetSel(0,-1);
			return;
		}
	}

    if (m_dwArrayIPAdd.GetSize() == WINSINTF_MAX_MEM)
    {
        // cannot add any more addresses
        AfxMessageBox(IDS_ERR_TOOMANY_IP);
        return;
    }

	LONG lIPAdd = (LONG) MAKEIPADDRESS(dwIp1, dwIp2, dwIp3, dwIp4);

    // add to the list 	
	m_listIPAdd.AddString(m_strIPAdd);
	m_strArrayIPAdd.Add(m_strIPAdd);
	m_dwArrayIPAdd.Add(lIPAdd);

	//m_fStaticPropChanged = TRUE; 

	m_editCustomIPAdd.SetWindowText(_T(""));

	SetDirty(TRUE);
}

void 
CStaticMappingProp::OnButtonRemove() 
{
	SPITFSNode  spNode;
	spNode = GetHolder()->GetNode();

	CActiveRegistrationsHandler* pActReg;

	pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

	// remove from the list 	
	int nSel = m_listIPAdd.GetCurSel();
	CString strSel;

	if (nSel != -1)
	{
		m_listIPAdd.GetText(nSel, strSel);
		m_listIPAdd.DeleteString(nSel);
	}

	// set the IP address in the IP Control
	m_ipControl.SetAddress(strSel);

	UpdateData();

	// delete from the CStringArray
	for (int i = 0; i < m_strArrayIPAdd.GetSize(); i++)
	{
		if (strSel == m_strArrayIPAdd.GetAt(i))
		{
			m_strArrayIPAdd.RemoveAt(i);
			m_dwArrayIPAdd.RemoveAt(i);
			break;
		}
	}

	// set the focus to the IP address control
	m_editCustomIPAdd.SetFocus();

	//m_fStaticPropChanged = TRUE; 

	SetDirty(TRUE);
}


void 
CStaticMappingProp::OnSelchangeComboType() 
{
	SetDirty(TRUE);

	if (m_comboType.GetCurSel() == 2 || m_comboType.GetCurSel() == 3 || m_comboType.GetCurSel() == 4)
	{
		// show the list control and the add and the remove buttons
		m_buttonAdd.ShowWindow(TRUE);
		m_buttonRemove.ShowWindow(TRUE);
		m_listIPAdd.ShowWindow(TRUE);
	}
	// hide them
	else
	{
		m_buttonAdd.ShowWindow(FALSE);
		m_buttonRemove.ShowWindow(FALSE);
		m_listIPAdd.ShowWindow(FALSE);
	}
	SetRemoveButtonState();
}

void CStaticMappingProp::OnChangeEditCompname() 
{
	SetDirty(TRUE);
}

void 
CStaticMappingProp::SetRemoveButtonState()
{
	UpdateData();

	if (m_listIPAdd.GetCurSel() == -1)
    {
        CWnd * pCurFocus = GetFocus();

        if (m_buttonRemove.GetSafeHwnd() == pCurFocus->GetSafeHwnd())
        {
            m_editCustomIPAdd.SetFocus();
        }

        m_buttonRemove.EnableWindow(FALSE);
    }
	else
    {
		m_buttonRemove.EnableWindow(TRUE);
    }

	DWORD dwIp1, dwIp2, dwIp3, dwIp4;
	int nAdd = m_ipControl.GetAddress(&dwIp1, &dwIp2, &dwIp3, &dwIp4);

	if (nAdd != 4)
	{
        CWnd * pCurFocus = GetFocus();

        if (m_buttonAdd.GetSafeHwnd() == pCurFocus->GetSafeHwnd())
        {
            m_editCustomIPAdd.SetFocus();
        }

        m_buttonAdd.EnableWindow(FALSE);
	}
	else
	{
		m_buttonAdd.EnableWindow(TRUE);

	}
}

void 
CStaticMappingProp::OnSelChangeListIpAdd()
{
	SetRemoveButtonState();
}

BOOL 
CStaticMappingProp::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT         hr = hrOK;
    SPITFSComponent spComponent;
	SPITFSNode      spNode;
	
    spNode = GetHolder()->GetNode();
    CActiveRegistrationsHandler * pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

	if (((CStaticMappingProperties*)GetHolder())->m_bWizard)
	{
		hr = pActReg->AddMapping(spNode);
		if (FAILED(hr))
		{
			GetHolder()->SetError(WIN32_FROM_HRESULT(hr));
		}
		else
		{
			*ChangeMask = RESULT_PANE_CHANGE_ITEM_DATA;
		}
	}
	else
	{
	    ((CStaticMappingProperties *) GetHolder())->GetComponent(&spComponent);

    	DWORD dwErr = pActReg->EditMapping(spNode, spComponent, pActReg->m_nSelectedIndex);
		if (dwErr != ERROR_SUCCESS)
		{
			GetHolder()->SetError(dwErr);
		}
		else
		{
			*ChangeMask = RESULT_PANE_CHANGE_ITEM_DATA;
		}
	}
	
	return FALSE;
}


CStaticMappingProperties::CStaticMappingProperties
(
	ITFSNode *			pNode,
	IComponent *	    pComponent,
	LPCTSTR				pszSheetName,
	WinsRecord *	    pwRecord,
	BOOL				bWizard
) : CPropertyPageHolderBase(pNode, pComponent, pszSheetName), m_bWizard(bWizard)
{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	InitPage(bWizard);

	AddPageToList((CPropertyPageBase*) m_ppageGeneral);

    Init(pwRecord);
}

CStaticMappingProperties::CStaticMappingProperties
(
	ITFSNode *			pNode,
	IComponentData *    pComponentData,
	LPCTSTR				pszSheetName,
	WinsRecord *        pwRecord,
	BOOL				bWizard
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName), m_bWizard(bWizard)
{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	InitPage(bWizard);

	AddPageToList((CPropertyPageBase*) m_ppageGeneral);

    Init(pwRecord);
}

CStaticMappingProperties::~CStaticMappingProperties()
{
	RemovePageFromList((CPropertyPageBase*) m_ppageGeneral, FALSE);

	delete m_ppageGeneral;
	m_ppageGeneral = NULL;
}

void
CStaticMappingProperties::InitPage(BOOL fWizard)
{
	if (fWizard)
	{
		m_ppageGeneral = new CStaticMappingProp(IDD_STATIC_MAPPING_WIZARD);
	}
	else
	{
		m_ppageGeneral = new CStaticMappingProp(IDD_STATIC_MAPPING_PROPERTIES);
	}
}

void
CStaticMappingProperties::Init(WinsRecord * pwRecord)
{
	if (pwRecord)
	{
		strcpy(m_wsRecord.szRecordName , pwRecord->szRecordName);
		m_wsRecord.dwExpiration = pwRecord->dwExpiration;
		m_wsRecord.dwExpiration = pwRecord->dwExpiration;
		m_wsRecord.dwNoOfAddrs = pwRecord->dwNoOfAddrs;

		for (DWORD i = 0; i < pwRecord->dwNoOfAddrs; i++)
		{
			m_wsRecord.dwIpAdd[i] = pwRecord->dwIpAdd[i];
		}

        m_wsRecord.liVersion = pwRecord->liVersion;
		m_wsRecord.dwNameLen = pwRecord->dwNameLen;
		m_wsRecord.dwOwner = pwRecord->dwOwner;
		m_wsRecord.dwState = pwRecord->dwState;
		m_wsRecord.dwType = pwRecord->dwType;
	}
}

HRESULT 
CStaticMappingProperties::SetComponent(ITFSComponent * pComponent)
{
    m_spTFSComponent.Set(pComponent);

    return hrOK;
}

HRESULT 
CStaticMappingProperties::GetComponent(ITFSComponent ** ppComponent)
{
    if (ppComponent)
    {
        *ppComponent = m_spTFSComponent;
        m_spTFSComponent->AddRef();
    }

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\statmapp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	statmapp.h
		Property Page for Active Registrations Record

	FILE HISTORY:
        
*/

#if !defined _STATMAPP_H
#define _STATMAPP_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CStaticMappingProp dialog

#ifndef _IPCTRL_H
#include "ipctrl.h"
#endif

#ifndef _ACTREG_H
#include "actreg.h"
#endif

// Static Record Types
extern CString g_strStaticTypeUnique;
extern CString g_strStaticTypeDomainName;
extern CString g_strStaticTypeMultihomed;
extern CString g_strStaticTypeGroup;
extern CString g_strStaticTypeInternetGroup;
extern CString g_strStaticTypeUnknown;

class CStaticMappingProp : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CStaticMappingProp)

// Construction
public:
	CStaticMappingProp(UINT uIDD = IDD_STATIC_MAPPING_PROPERTIES);
	~CStaticMappingProp();

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

// Dialog Data
	//{{AFX_DATA(CStaticMappingProp)
	enum { IDD = IDD_STATIC_MAPPING_PROPERTIES };
	CEdit	m_editScopeName;
	CListBox	m_listIPAdd;
	CButton	m_buttonRemove;
	CButton	m_buttonAdd;
	CComboBox	m_comboIPAdd;
	CEdit	m_editName;
	CComboBox	m_comboType;
	CString	m_strName;
	CString	m_strType;
	CString	m_strScopeName;
	//}}AFX_DATA

	CEdit	m_editCustomIPAdd;
	CString m_strIPAdd;
	LONG	m_lIPAddress;
	CString m_strOnInitIPAdd;

	UINT	m_uImage;
	UINT	m_uIDD;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CStaticMappingProp)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CStaticMappingProp)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonAdd();
	afx_msg void OnButtonRemove();
	afx_msg void OnSelchangeComboType();
	afx_msg void OnChangeEditCompname();
	afx_msg void OnSelChangeListIpAdd();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// single ip address controls
	afx_msg void OnChangeIpAddress();


private:

	BOOL FillControls();
	
	void AssignMappingType();
	void FillDynamicRecData(CString& strType, CString& strActive, CString& strExpiration, CString& strVersion);
	void FillStaticRecData(CString& strType);
	void SetDefaultControlStates();
	void FillList();
	void SetRemoveButtonState();
	
	int						m_fType;
	IPControl				m_ipControl;
	CStringArray			m_strArrayIPAdd;
	CDWordArray				m_dwArrayIPAdd;

	// set if property changed for static mapping
	BOOL					m_fStaticPropChanged;

	
public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(m_uIDD);}
};

class CStaticMappingProperties:public CPropertyPageHolderBase
{
	
public:
	CStaticMappingProperties(ITFSNode *	        pNode,
							 IComponent *	    pComponent,
							 LPCTSTR			pszSheetName,
							 WinsRecord*		pwRecord = NULL,
							 BOOL				bWizard = FALSE);
	
    CStaticMappingProperties(ITFSNode *	        pNode,
							 IComponentData *   pComponentData,
							 LPCTSTR			pszSheetName,
							 WinsRecord*		pwRecord = NULL,
							 BOOL				bWizard = FALSE);

    virtual ~CStaticMappingProperties();

    void Init(WinsRecord * pwRecord);
    void InitPage(BOOL fWizard);

    HRESULT GetComponent(ITFSComponent ** ppComponent);
    HRESULT SetComponent(ITFSComponent * pComponent);

public:
	CStaticMappingProp * 	m_ppageGeneral;
	WinsRecord				m_wsRecord;
	BOOL					m_bWizard;

    SPITFSComponent         m_spTFSComponent;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined _STATMAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\statndpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    statndpp.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "winssnap.h"
#include "StatNdpp.h"
#include "status.h"
#include "root.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MILLISEC_PER_MINUTE		(60 * 1000)

/////////////////////////////////////////////////////////////////////////////
// CStatusNodePropGen property page

IMPLEMENT_DYNCREATE(CStatusNodePropGen, CPropertyPageBase)

CStatusNodePropGen::CStatusNodePropGen() : CPropertyPageBase(CStatusNodePropGen::IDD)
{
	//{{AFX_DATA_INIT(CStatusNodePropGen)
	m_nUpdateInterval = 0;
	//}}AFX_DATA_INIT
}


CStatusNodePropGen::~CStatusNodePropGen()
{
}


void CStatusNodePropGen::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStatusNodePropGen)
	DDX_Text(pDX, IDC_EDIT_UPDATE, m_nUpdateInterval);
	DDV_MinMaxInt(pDX, m_nUpdateInterval, 1, 59);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStatusNodePropGen, CPropertyPageBase)
	//{{AFX_MSG_MAP(CStatusNodePropGen)
	ON_EN_CHANGE(IDC_EDIT_UPDATE, OnChangeEditUpdate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStatusNodePropGen message handlers

void CStatusNodePropGen::OnChangeEditUpdate() 
{
	// mark the root node as dirty so that the user is prompted to save the
	// file, refresh interval is part of the .msc file
	SPITFSNode spNode, spParent;
	
	spNode = GetHolder()->GetNode();

	// set the upadte interval from the root node
	spNode->GetParent(&spParent);

	// mark the data as dirty so that we'll ask the user to save.
    spParent->SetData(TFS_DATA_DIRTY, TRUE);

	SetDirty(TRUE);
}

BOOL CStatusNodePropGen::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	SPITFSNode spNode, spParent;
	
	spNode = GetHolder()->GetNode();

	// set the upadte interval from the root node
	spNode->GetParent(&spParent);

	CWinsRootHandler *pRoot 
		= GETHANDLER(CWinsRootHandler, spParent);

	m_nUpdateInterval = pRoot->GetUpdateInterval()/(MILLISEC_PER_MINUTE);

	UpdateData(FALSE);

	m_uImage = (UINT) spNode->GetData(TFS_DATA_IMAGEINDEX);

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }

	SetDirty(FALSE);

	return TRUE;  
}

BOOL 
CStatusNodePropGen::OnApply() 
{
	UpdateData();

	// update the m_dwInterval for the status node
	SPITFSNode spNode, spParent;
	CWinsRootHandler *pRoot= NULL;
	CWinsStatusHandler	*pStat = NULL;

	spNode = GetHolder()->GetNode();
	spNode->GetParent(&spParent);

	pRoot = GETHANDLER(CWinsRootHandler, spParent);
	pStat = GETHANDLER(CWinsStatusHandler, spNode);

	DWORD dwValue = m_nUpdateInterval * MILLISEC_PER_MINUTE;

	pStat->SetUpdateInterval(dwValue);

	pRoot->SetUpdateInterval(dwValue);

	return CPropertyPageBase::OnApply();   
}


/////////////////////////////////////////////////////////////////////////////
//	CRepNodeProperties Handlers
/////////////////////////////////////////////////////////////////////////////
CStatusNodeProperties::CStatusNodeProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)

{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);
	
	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}


CStatusNodeProperties::~CStatusNodeProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\srvlatpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	srvlatpp.h
		Brings up the property page for the server node
		
    FILE HISTORY:
        
*/


#if !defined(AFX_SRVLATPP_H__35B59246_47F9_11D1_B9A6_00C04FBF914A__INCLUDED_)
#define AFX_SRVLATPP_H__35B59246_47F9_11D1_B9A6_00C04FBF914A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _CONFIG_H
#include "config.h"
#endif

#define BURST_QUE_SIZE_LOW      300
#define BURST_QUE_SIZE_MEDIUM   500
#define BURST_QUE_SIZE_HIGH     1000

/////////////////////////////////////////////////////////////////////////////
// CServerPropGeneral dialog

class CServerPropGeneral : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CServerPropGeneral)

// Construction
public:
	CServerPropGeneral();
	~CServerPropGeneral();

// Dialog Data
	//{{AFX_DATA(CServerPropGeneral)
	enum { IDD = IDD_SERVER_PROP_GEN };
	CStatic	m_staticrefresh;
	CStatic	m_staticDesc;
	CEdit	m_editRefreshMn;
	CEdit	m_editRefreshHr;
	CEdit	m_editRefreshSc;
	CSpinButtonCtrl	m_spinRefreshSc;
	CSpinButtonCtrl	m_spinRefreshmn;
	CSpinButtonCtrl	m_spinRefreshHr;
	CEdit	m_editBackupPath;
	CButton	m_check_BackupOnTermination;
	CButton	m_check_EnableAutoRefresh;
	CButton	m_button_Browse;
	BOOL	m_fBackupDB;
	BOOL	m_fEnableAutoRefresh;
	CString	m_strBackupPath;
	int		m_nRefreshHours;
	int		m_nRefreshMinutes;
	int		m_nRefreshSeconds;
	//}}AFX_DATA

	UINT	m_uImage;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropGeneral)
	public:
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServerPropGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonBrowse();
	afx_msg void OnCheckEnableAutorefresh();
	afx_msg void OnChangeEditBackuppath();
	afx_msg void OnChangeRefresh();
	afx_msg void OnChangeCheckBackupdb();
    //}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CConfiguration *		m_pConfig;
    BOOL                    m_fUpdateRefresh;
    BOOL                    m_fUpdateConfig;

	HRESULT	GetConfig();
	
	HRESULT UpdateServerConfiguration();
	BOOL    UpdateConfig();
	void    SetRefreshData();

	int CalculateRefrInt();

	CString ToString(int nNumber);

	BOOL IsLocalConnection();

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CServerPropGeneral::IDD);};

};

/////////////////////////////////////////////////////////////////////////////
// CServerPropDBRecord dialog

class CServerPropDBRecord : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CServerPropDBRecord)

// Construction
public:
	CServerPropDBRecord();
	~CServerPropDBRecord();

// Dialog Data
	//{{AFX_DATA(CServerPropDBRecord)
	enum { IDD = IDD_SERVER_PROP_DBRECORD };
	CEdit	m_editExtIntMinute;
	CSpinButtonCtrl	m_spinVerifyMinute;
	CSpinButtonCtrl	m_spinVerifyHour;
	CSpinButtonCtrl	m_spinVerifyDay;
	CSpinButtonCtrl	m_spinRefrIntMinute;
	CSpinButtonCtrl	m_spinRefrIntHour;
	CSpinButtonCtrl	m_spinRefrIntDay;
	CSpinButtonCtrl	m_spinExtTmMinute;
	CSpinButtonCtrl	m_spinExtTmHour;
	CSpinButtonCtrl	m_spinExtTmDay;
	CSpinButtonCtrl	m_spinExtIntMinute;
	CSpinButtonCtrl	m_spinExtIntHour;
	CSpinButtonCtrl	m_spinExtIntDay;
	CEdit	m_editVerifyMinute;
	CEdit	m_editVerifyHour;
	CEdit	m_editVerifyDay;
	CEdit	m_editRefrIntMinute;
	CEdit	m_editRefrIntHour;
	CEdit	m_editRefrIntDay;
	CEdit	m_editExtTmHour;
	CEdit	m_editExtTmMinute;
	CEdit	m_editExtTmDay;
	CEdit	m_editExtIntHour;
	CEdit	m_editExtIntDay;
	int		m_nExtintDay;
	int		m_nExtIntHour;
	int		m_nExtIntMinute;
	int		m_nExtTmDay;
	int		m_nExtTmHour;
	int		m_nExtTmMinute;
	int		m_nRenewDay;
	int		m_nrenewMinute;
	int		m_nRenewMinute;
	int		m_nVerifyDay;
	int		m_nVerifyHour;
	int		m_nVerifyMinute;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropDBRecord)
	public:
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServerPropDBRecord)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonSetDefault();
	afx_msg void OnChangeEditExtinctIntHour();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private :
	CConfiguration *    m_pConfig;
	HRESULT				GetConfig();
	
	void SetVerifyData();
	void SetExtTimeData();
	void SetExtIntData();

	DWORD CalculateRenewInt();
	DWORD CalculateExtTm();
	DWORD CalculateExtInt();
	DWORD CalculateVerifyInt();

	void SetDefaultRenewInt();
	void SetDefaultExtInt();
	void SetDefaultExtTm();
	void SetDefaultVerifyInt();
    void CalcDaysHoursMinutes(int nValue, int & nDays, int & nHours, int & nMinutes);
	
	HRESULT UpdateServerConfiguration();

	BOOL CheckValues(); 

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CServerPropDBRecord::IDD);};
};


/////////////////////////////////////////////////////////////////////////////
// CServerPropDBVerification dialog

class CServerPropDBVerification : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CServerPropDBVerification)

// Construction
public:
	CServerPropDBVerification();
	~CServerPropDBVerification();

// Dialog Data
	//{{AFX_DATA(CServerPropDBVerification)
	enum { IDD = IDD_SERVER_PROP_DBVERIFICATION };
	CEdit	m_editCCSecond;
	CEdit	m_editCCMinute;
	CEdit	m_editCCHour;
	CSpinButtonCtrl	m_spinCCMinute;
	CEdit	m_editCCInterval;
	CEdit	m_editCCMaxChecked;
	CButton	m_radioCheckOwner;
	CButton	m_checkEnableCC;
	CSpinButtonCtrl	m_spinCCSecond;
	CSpinButtonCtrl	m_spinCCHour;
	BOOL	m_fCCPeriodic;
	int		m_nCCCheckRandom;
	int		m_nCCHour;
	int		m_nCCMinute;
	int		m_nCCSecond;
	UINT	m_nCCMaxChecked;
	UINT	m_nCCTimeInterval;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropDBVerification)
	public:
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServerPropDBVerification)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckPeriodicCc();
	afx_msg void OnChangeEditCcInterval();
	afx_msg void OnChangeEditCcMaxChecked();
	afx_msg void OnChangeEditCcStartHour();
	afx_msg void OnChangeEditCcStartMinute();
	afx_msg void OnChangeEditCcStartSecond();
	afx_msg void OnRadioCheckOwner();
	afx_msg void OnRadioCheckRandom();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private :
	CConfiguration *    m_pConfig;
	HRESULT				GetConfig();
	
	HRESULT UpdateServerConfiguration();
	
    void    SetCCInfo();
    void    UpdateCCControls();

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CServerPropDBVerification::IDD);};
};


/////////////////////////////////////////////////////////////////////////////
// CServerPropAdvanced dialog

class CServerPropAdvanced : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CServerPropAdvanced)

// Construction
public:
	CServerPropAdvanced();
	~CServerPropAdvanced();

// Dialog Data
	//{{AFX_DATA(CServerPropAdvanced)
	enum { IDD = IDD_SERVER_PROP_ADVANCED };
	CButton	m_buttonBrowse;
	CEdit	m_editDbPath;
	CButton	m_checkBurstHandling;
	CButton	m_checkLanNames;
	CEdit	m_editVersionCount;
	CButton	m_checkLogDetailedEvents;
	BOOL	m_fLogEvents;
	CString	m_strStartVersion;
	BOOL	m_fLanNames;
	BOOL	m_fBurstHandling;
	int		m_nQueSelection;
	CString	m_strDbPath;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropAdvanced)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServerPropAdvanced)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckLannames();
	afx_msg void MarkDirty();
	afx_msg void OnCheckBurstHandling();
	afx_msg void OnRadioCustom();
	afx_msg void OnRadioHigh();
	afx_msg void OnRadioLow();
	afx_msg void OnRadioMedium();
	afx_msg void OnChangeEditCustomValue();
	afx_msg void OnButtonBrowseDatabase();
	afx_msg void OnChangeEditDatabasePath();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	
	CConfiguration*			m_pConfig;
	BOOL					m_fRestart;

	// helper functions
	HRESULT GetConfig();
	CString GetVersionInfo(LONG lLowWord, LONG lHighWord);
	
	HRESULT UpdateServerConfiguration();
	void    FillVersionInfo(LONG &lLowWord, LONG &lHighWord);

    void    UpdateBurstHandling();
    void    EnableQueSelection(BOOL bEnable);
    void    EnableCustomEntry();
    void    SetQueSize();
    DWORD   GetQueSize();

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CServerPropAdvanced::IDD);};
};


class CServerProperties : public CPropertyPageHolderBase
{
	
public:
	CServerProperties(ITFSNode *		  pNode,
					  IComponentData *	  pComponentData,
					  ITFSComponentData * pTFSCompData,
					  LPCTSTR			  pszSheetName
					  );
	virtual ~CServerProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

	void SetConfig(CConfiguration * pConfig)
	{
		m_Config = *pConfig;
	}

    CConfiguration * GetConfig()
    {
        return &m_Config;
    }

public:
	CServerPropGeneral			m_pageGeneral;
	CServerPropDBRecord			m_pageDBRecord;
	CServerPropDBVerification	m_pageDBVerification;
	CServerPropAdvanced			m_pageAdvanced;	
	CConfiguration              m_Config;

protected:
	SPITFSComponentData		m_spTFSCompData;
	WINSINTF_RESULTS_T		m_wrResults;
	handle_t				m_hBinding;
	DWORD					m_dwStatus;
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SRVLATPP_H__35B59246_47F9_11D1_B9A6_00C04FBF914A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	stdafx.cpp	
		precompiled header file

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\statnode.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	statnode.cpp
		Status leaf node

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "statnode.h"

CServerStatus::CServerStatus(ITFSComponentData *pCompData):
							CWinsHandler(pCompData)
{
	m_bExpanded = FALSE;
	m_nState = loaded;
	dwState = SERVER_ADDED;

	m_uImage = ICON_IDX_SERVER;
    m_timeLast = 0;
}


HRESULT
CServerStatus::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString strDisplay;
	
	FormDisplayName(strDisplay);

	SetDisplayName(strDisplay);

	// Make the node immediately visible
	pNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, WINSSNAP_STATUS_LEAF_NODE);
	pNode->SetData(TFS_DATA_IMAGEINDEX, m_uImage);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, m_uImage);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

	SetColumnStringIDs(&aColumns[WINSSNAP_REPLICATION_PARTNER][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_REPLICATION_PARTNER][0]);
	
	return hrOK;
}

/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CServerStatus::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CServerStatus::GetString
(
	ITFSComponent * pComponent,	
	MMC_COOKIE 	    cookie,
	int				nCol
)
{
	if (nCol == 0 || nCol == -1)
		return GetDisplayName();
	switch(nCol)
	{
	    case -1:
	    case 0:
		    return GetDisplayName();
	    
        case 1:
		    return m_strStatus;

        case 2:
            if (m_timeLast == 0)
                m_strLastChecked.Empty();
            else
            {
                FormatDateTime(m_strLastChecked, m_timeLast);
            }
            
            return m_strLastChecked;
            
        default:
		    return NULL;
	}
}


/*---------------------------------------------------------------------------
	Command handlers
 ---------------------------------------------------------------------------*/

void 
CServerStatus:: FormDisplayName(CString &strDisplay)
{
	WCHAR wString[MAX_PATH] = {0};
	int nBytes  = 0;
	
	// form the string for the first column
	nBytes = ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szServerName, -1, wString, 0);
	::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szServerName, -1, wString, nBytes);

	CString strServer(wString);
	m_strServerName = strServer;

	if(dwIPAddress != 0)
	{
		::MakeIPAddress(dwIPAddress, m_strIPAddress);
		strDisplay.Format(IDS_SERVER_NAME_FORMAT, m_strServerName, m_strIPAddress);
	}
	else
	{
		strDisplay = m_strServerName;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\statndpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	statndpp.h
		WINS scope pane status node property pages
		
    FILE HISTORY:
        
*/

#if !defined _STATNDPP_H
#define _STATNDPP_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// StatNdpp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStatusNodePropGen dialog

class CStatusNodePropGen : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CStatusNodePropGen)

// Construction
public:
	CStatusNodePropGen();
	~CStatusNodePropGen();

// Dialog Data
	//{{AFX_DATA(CStatusNodePropGen)
	enum { IDD = IDD_STATUS_NODE_PROPERTIES };
	int		m_nUpdateInterval;
	//}}AFX_DATA

	UINT	m_uImage;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CStatusNodePropGen)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CStatusNodePropGen)
	afx_msg void OnChangeEditUpdate();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CStatusNodePropGen::IDD);}

};

class CStatusNodeProperties : public CPropertyPageHolderBase
{
	
public:
	CStatusNodeProperties(ITFSNode *		  pNode,
					  IComponentData *	  pComponentData,
					  ITFSComponentData * pTFSCompData,
					  LPCTSTR			  pszSheetName
					  );
	virtual ~CStatusNodeProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

public:
	CStatusNodePropGen		m_pageGeneral;
	
protected:
	SPITFSComponentData		m_spTFSCompData;
	
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined _STATNDPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\verify.c ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    verify.c
        Comment goes here

    FILE HISTORY:

*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "tchar.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>

#include <fcntl.h>
#include <ctype.h>

#include <windows.h>
#include <windowsx.h>
#include <tdi.h>

#include <winsock.h>
#include <wsahelp.h>
#include <nameser.h>
#include <resolve.h>
#include <nb30.h>
#include <nbtioctl.h>

#define WINS_CLIENT_APIS
#include "winsintf.h"
#include "resource.h"
#include "verify.h"


//
// The format of Adapter Status responses
//
typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;


#define WINSTEST_FOUND            0
#define WINSTEST_NOT_FOUND        1
#define WINSTEST_NO_RESPONSE      2

#define WINSTEST_VERIFIED         0
#define WINSTEST_OUT_OF_MEMORY    3
#define WINSTEST_BAD_IP_ADDRESS   4
#define WINSTEST_HOST_NOT_FOUND   5
#define WINSTEST_NOT_VERIFIED     6

#define WINSTEST_INVALID_ARG      7
#define WINSTEST_OPEN_FAILED      8

TCHAR    *messages[] = {
                        L"success",
                        L"name not found",
                        L"no response",
                        L"out of memory",
                        L"bad ip address",
                        L"host not found",
                        L"host address not verified",
                        L"invalid argument",
                        L"failed to open NBT driver"
                     };



#define MAX_NB_NAMES 1000
#define MAX_SERVERS  1000
#define MAX_SIZE     1024

SOCKET  sd;
WSADATA WsaData;

HWND	    g_wndDlg = NULL;
HWND        g_hwndParent = NULL;
HANDLE      g_hThread = NULL;
HINSTANCE   g_hInstance = NULL;

HRESULT foo;

struct  sockaddr_in myad;
struct  sockaddr_in recvad;
int     addrlen;
u_short TranID;
u_long  NonBlocking = 1;

int      NumWinServers = 0;
int      NumNBNames = 0;
u_char * NBNames[MAX_NB_NAMES];
u_long   VerifiedAddress[MAX_NB_NAMES];

//char  lpResults[MAX_SIZE];
//TCHAR  lpResults[MAX_SIZE];
//lpResults = (char*) malloc  (64536);

WINSERVERS WinServers[MAX_SERVERS];

#define NBT_NONCODED_NMSZ   17
#define NBT_NAMESIZE        34

ULONG   NetbtIpAddress;
CHAR    pScope[128];

NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    );


INT_PTR CALLBACK
dlgProc(
		 HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    int ntest;

	switch (Message)
	{
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hWnd, IDCANCEL);
                    return TRUE;
            }
            break;

        case WM_INITDIALOG:
            g_wndDlg = hWnd;
            break;

        default:
            return FALSE;
    }

	return TRUE;
}

void ToWCS(LPCSTR szMBCSString, LPWSTR lpWideString)
{
	int nResult;

	// determone the size first
	nResult = MultiByteToWideChar(
						CP_ACP,
						MB_COMPOSITE,
						szMBCSString,
						-1,
						lpWideString,
						0);

	MultiByteToWideChar(
						CP_ACP,
						MB_COMPOSITE,
						szMBCSString,
						-1,
						lpWideString,
						nResult);

    lpWideString[nResult + 1] = '\0';
}

void AddStatusMessageW(LPCWSTR pszMessage)
{
    HWND    hwndEdit;
    MSG     msg;

    hwndEdit = GetDlgItem(g_wndDlg, IDC_EDIT_MESSAGE);

	SetFocus (hwndEdit);
    SendMessage (hwndEdit, EM_SETSEL, -1, -1);
    SendMessage (hwndEdit, EM_REPLACESEL, 0, (LPARAM) ((LPCTSTR) pszMessage));

    // give the window some time to process the message
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
}

void AddStatusMessage(LPCSTR pszMessage)
{
    WCHAR   szBuffer[MAX_SIZE];

    ToWCS(pszMessage, szBuffer);

    AddStatusMessageW(szBuffer);
}

DWORD
GetStatus(
        BOOL            fPrint,
        LPVOID          pResultsA,
        BOOL            fNew,
        BOOL            fShort,
        PUCHAR          IpAddr
        )
{
        DWORD                     Status, i;
        struct in_addr            InAddr;
        PWINSINTF_RESULTS_T       pResults = pResultsA;
        PWINSINTF_RESULTS_NEW_T   pResultsN = pResultsA;
        PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps;
        DWORD                     NoOfOwners;
        handle_t                  BindHdl;
        WINSINTF_BIND_DATA_T      BindData;
        char                      lpResults[MAX_SIZE] = {0};
        TCHAR                     szErrMsg[MAX_SIZE];

		WCHAR  WcharString1[WINSINTF_MAX_NAME_SIZE] = {0};

		int nSize = MultiByteToWideChar(CP_ACP,
							MB_PRECOMPOSED,
							IpAddr,
							-1,
							WcharString1,
							0
							);

		MultiByteToWideChar(CP_ACP,
							MB_PRECOMPOSED,
							IpAddr,
							-1,
							WcharString1,
							nSize
							);

		WcharString1[nSize] = '\0';

		BindData.fTcpIp = TRUE;
        BindData.pServerAdd = (LPSTR) (LPTSTR) WcharString1;

		strcpy(lpResults, "");
		strcat(lpResults, "*****\r\n" );
		strcat(lpResults, "Getting map table from " );
		strcat(lpResults, IpAddr);
		strcat(lpResults, "\r\n");

        AddStatusMessage(lpResults);

        BindHdl = WinsBind(&BindData);
        if (BindHdl == NULL)
        {
    		strcpy(lpResults, "");
            strcat(lpResults, "Unable to bind to " );
            strcat(lpResults, IpAddr);
            strcat(lpResults, "\r\n");

            AddStatusMessage(lpResults);

            return STATUS_SUCCESS;
        }

        if (!fNew)
        {
#ifdef WINS_CLIENT_APIS
            Status = WinsStatus(BindHdl, WINSINTF_E_CONFIG, pResultsA);
#else
            Status = WinsStatus(WINSINTF_E_CONFIG, pResultsA);
#endif  WINS_CLIENT_APIS
        }
        else
        {
            pResultsN->pAddVersMaps = NULL;

#ifdef WINS_CLIENT_APIS
            Status = WinsStatusNew(BindHdl, WINSINTF_E_CONFIG, pResultsN);
#else
            Status = WinsStatusNew(WINSINTF_E_CONFIG, pResultsN);
#endif WINS_CLIENT_APIS
        }

		if (Status == 0)
		{
			//strcpy(lpResults, "");
			//strcat(lpResults, "SUCCESS \r\n");

            //AddStatusMessage(lpResults);
        }
		else
		{
            wsprintfA(lpResults, "Get Wins Status failed! Error: %d\r\n", Status);
            AddStatusMessage(lpResults);
		}

        if (Status == WINSINTF_SUCCESS)
        {
            if (fPrint)
            {
                if (!fNew)
                {
                     pAddVersMaps = pResults->AddVersMaps;
                     NoOfOwners = pResults->NoOfOwners;
                }
                else
                {
                     pAddVersMaps = pResultsN->pAddVersMaps;
                     NoOfOwners = pResultsN->NoOfOwners;
                }

                if (NoOfOwners == 0)
                {
					strcpy(lpResults, "");
                    strcat(lpResults, "The database list of owners is empty.\r\n");

                    AddStatusMessage(lpResults);

         		    Status = WINSINTF_FAILURE;
                }
            }
        }

        WinsUnbind(&BindData, BindHdl);

        return(Status);
}

//------------------------------------------------------------------------
NTSTATUS
GetIpAddress(
    IN HANDLE           fd,
    OUT PULONG          pIpAddress
    )

/*++

Routine Description:

    This function calls into netbt to get the ip address.

Arguments:

   fd - file handle to netbt
   pIpAddress - the ip address returned

Return Value:

   ntstatus

History:
    27-Dec-1995 CDermody    copied from nbtstat.c

--*/

{
    NTSTATUS    status;
    ULONG       BufferSize=100;
    PVOID       pBuffer;

    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = DeviceIoCtrl(fd,
                         pBuffer,
                         BufferSize,
                         IOCTL_NETBT_GET_IP_ADDRS,
                         NULL,
                         0);

    if (NT_SUCCESS(status))
    {
        *pIpAddress = *(ULONG *)pBuffer;
    }
    else
    {
        *pIpAddress = 0;
    }

    LocalFree(pBuffer);

    return(status);
}

//------------------------------------------------------------------------
NTSTATUS
GetInterfaceList
(
    char pDeviceName[][MAX_NAME+1]
)
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string, AnsiString;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    char                pNbtWinsDeviceName[MAX_NAME] = "\\Device\\NetBt_Wins_Export";

    PUCHAR  SubKeyParms = "system\\currentcontrolset\\services\\netbt\\parameters";
    PUCHAR  Scope = "ScopeId";
    CHAR    pScopeBuffer[BUFF_SIZE];
    HKEY    Key;
    LONG    Type;
    ULONG   size;

    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    ULONG                   InterfaceInfoSize = 10 * sizeof(NETBT_ADAPTER_INDEX_MAP) + sizeof(ULONG);
    PVOID                   pInput = NULL;
    ULONG                   SizeInput = 0;

    LONG    i, index = 0;

    pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
    if (!pInterfaceInfo)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlInitString(&name_string, pNbtWinsDeviceName);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    RtlFreeUnicodeString(&uc_name_string);

    if (NT_SUCCESS (status))
    {
        do
        {
            status = DeviceIoCtrl(StreamHandle,
                                 pInterfaceInfo,
                                 InterfaceInfoSize,
                                 IOCTL_NETBT_GET_INTERFACE_INFO,
                                 pInput,
                                 SizeInput);

            if (status == STATUS_BUFFER_OVERFLOW)
            {
                LocalFree(pInterfaceInfo);

                InterfaceInfoSize *= 2;
                pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
                if (!pInterfaceInfo || (InterfaceInfoSize == 0xFFFF))
                {
                    NtClose(StreamHandle);
                    //NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }
            else if (!NT_SUCCESS (status))
            {
                NtClose(StreamHandle);
                return(status);
            }

        } while (status == STATUS_BUFFER_OVERFLOW);
        NtClose (StreamHandle);

        for (i = 0; i<pInterfaceInfo->NumAdapters; i++)
        {
            RtlInitString(&name_string, NULL);
            RtlInitUnicodeString(&uc_name_string, pInterfaceInfo->Adapter[i].Name);
            if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&name_string, &uc_name_string, TRUE)))
            {
                size = (name_string.Length > MAX_NAME) ? MAX_NAME : name_string.Length;

                strncpy(pDeviceName[index], name_string.Buffer, size);
                pDeviceName[index][size] = '\0';
                RtlFreeAnsiString (&name_string);

                index++;
            }
        }

        //
        // NULL out the next device string ptr
        //
        if (index < NBT_MAXIMUM_BINDINGS)
        {
            pDeviceName[index][0] = '\0';
        }

        //
        // Read the ScopeId key!
        //
        size = BUFF_SIZE;
        *pScope = '\0';     // By default
        status = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                     SubKeyParms,
                     0,
                     KEY_READ,
                     &Key);

        if (status == ERROR_SUCCESS)
        {
            // now read the Scope key
            status = RegQueryValueExA(Key, Scope, NULL, &Type, pScopeBuffer, &size);
            if (status == ERROR_SUCCESS)
            {
                strcpy(pScope,pScopeBuffer);
            }
            status = RegCloseKey(Key);
        }

        status = STATUS_SUCCESS;
    }

    return status;
}

//------------------------------------------------------------------------
NTSTATUS
OpenNbt(
    IN char path[][MAX_NAME+1],
    OUT PHANDLE pHandle,
    int max_paths
    )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    LONG                index=0;

    ASSERT ( max_paths <= NBT_MAXIMUM_BINDINGS );

    while ((path[index][0] != '\0') && (index < max_paths))
    {
        RtlInitString(&name_string, path[index]);
        RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &uc_name_string,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

        status =
        NtCreateFile(
            &StreamHandle,
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0);

        RtlFreeUnicodeString(&uc_name_string);

        if (NT_SUCCESS(status))
        {
            *pHandle = StreamHandle;
            return(status);
        }

        ++index;
    }

    return (status);
} // s_open

//------------------------------------------------------------------------
NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, non-zero otherwise.

History:
    27-Dec-1995 CDermody    copied from nbtstat.c
--*/

{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    IO_STATUS_BLOCK                 iosb;


    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    return(status);
}

/****************************************************************************/
/*      CheckRemoteTable                                                    */
/*                                                                          */
/*  This routine does an adapter status query to get the remote name table  */
/*  then checks to see if a netbios name is contained in it.                */
/*                                                                          */
/*  Parameters:                                                             */
/*      RemoteName, the IP address (asci nn.nn.nn.nn format) of a server to */
/*                  query.                                                  */
/*      SearchName, a net bios name.                                        */
/*                                                                          */
/*  Return:                                                                 */
/*      WINSTEST_VERIFIED       The name exists in the remote name table    */
/*      WINSTEST_NOT_VERIFIED   The name does not exist in the remote table */
/*      WINSTEST_BAD_IP_ADDRESS inet_addr could not convert the ip address  */
/*                              character string.                           */
/*      WINSTEST_HOST_NOT_FOUND Could not reach ip address                  */
/*      WINSTEST_OUT_OF_MEMORY  Out of memory                               */
/*  History:                                                                */
/*      27-Dec-1995     CDermody    created following example of nbtstat.c  */
/****************************************************************************/

int
CheckRemoteTable(
    IN HANDLE   fd,
    IN PCHAR    RemoteName,
    IN PCHAR    SearchName
    )

{
    LONG                        Count;
    LONG                        i;
    PVOID                       pBuffer;
    ULONG                       BufferSize=600;
    NTSTATUS                    status;
    tADAPTERSTATUS              *pAdapterStatus;
    NAME_BUFFER                 *pNames;
    CHAR                        MacAddress[20];
    tIPANDNAMEINFO              *pIpAndNameInfo;
    ULONG                       SizeInput;
    ULONG                       IpAddress;
    USHORT                      BytesToCopy;


    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(WINSTEST_OUT_OF_MEMORY);
    }

    status = STATUS_BUFFER_OVERFLOW;
    pIpAndNameInfo = LocalAlloc(LMEM_FIXED,sizeof(tIPANDNAMEINFO));
    if (!pIpAndNameInfo)
    {
        LocalFree(pBuffer);
        return(WINSTEST_OUT_OF_MEMORY);
    }

    RtlZeroMemory((PVOID)pIpAndNameInfo,sizeof(tIPANDNAMEINFO));

    //
    // Convert the remote name which is really a dotted decimal ip address
    // into a ulong
    //
    IpAddress = inet_addr(RemoteName);

    //
    // Don't allow zero for the address since it sends a broadcast and
    // every one responds
    //
    if ((IpAddress == INADDR_NONE) || (IpAddress == 0))
    {
        LocalFree(pBuffer);
        LocalFree(pIpAndNameInfo);

        return(WINSTEST_BAD_IP_ADDRESS);
    }

    pIpAndNameInfo->IpAddress = ntohl(IpAddress);

    pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0] = '*';


    pIpAndNameInfo->NetbiosAddress.TAAddressCount = 1;
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressLength
        = sizeof(TDI_ADDRESS_NETBIOS);
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressType
        = TDI_ADDRESS_TYPE_NETBIOS;
    pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosNameType
        = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    SizeInput = sizeof(tIPANDNAMEINFO);

    while (status == STATUS_BUFFER_OVERFLOW)
    {
        status = DeviceIoCtrl(fd,
                             pBuffer,
                             BufferSize,
                             IOCTL_NETBT_ADAPTER_STATUS,
                             pIpAndNameInfo,
                             SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pBuffer);

            BufferSize *=2;
            pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
            if (!pBuffer || (BufferSize == 0xFFFF))
            {
                LocalFree(pIpAndNameInfo);

                return(WINSTEST_OUT_OF_MEMORY);
            }
        }
    }

    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    if ((pAdapterStatus->AdapterInfo.name_count == 0) ||
        (status != STATUS_SUCCESS))
    {
        LocalFree(pIpAndNameInfo);
        LocalFree(pBuffer);

        return(WINSTEST_HOST_NOT_FOUND);
    }

    pNames = pAdapterStatus->Names;
    Count = pAdapterStatus->AdapterInfo.name_count;

    status = 1;

    while (Count--)
    {
        if (0 == _strnicmp(SearchName, pNames->name, strlen(SearchName)))
        {
            LocalFree(pIpAndNameInfo);
            LocalFree(pBuffer);

            return WINSTEST_VERIFIED; // found
        }

        pNames++;
    }

    LocalFree(pIpAndNameInfo);
    LocalFree(pBuffer);

    return WINSTEST_NOT_VERIFIED;
}


/****************************************************************************/
/*      VerifyRemote                                                        */
/*                                                                          */
/*  This routine checks to see if a netbios name is contained in the remote */
/*  name table at a given IP address.                                       */
/*                                                                          */
/*  Parameters:                                                             */
/*      RemoteName, the IP address (asci nn.nn.nn.nn format) of a server to */
/*                  query.                                                  */
/*      NBName,     a net bios name.                                        */
/*                                                                          */
/*  Return:                                                                 */
/*      WINSTEST_VERIFIED       The name exists in the remote name table    */
/*      WINSTEST_NOT_VERIFIED   The name does not exist in the remote table */
/*      WINSTEST_BAD_IP_ADDRESS inet_addr could not convert the ip address  */
/*                              character string.                           */
/*      WINSTEST_OPEN_FAILED    Could not open NBT driver or could not read */
/*                              the NBT driver info from the registry.      */
/*      WINSTEST_HOST_NOT_FOUND Could not reach ip address                  */
/*      WINSTEST_OUT_OF_MEMORY  Out of memory                               */
/*  History:                                                                */
/*      27-Dec-1995     CDermody    created following example of nbtstat.c  */
/****************************************************************************/

int VerifyRemote(IN PCHAR RemoteName, IN PCHAR NBName)
{
    NTSTATUS    status;
    LONG        interval=-1;
    HANDLE      nbt = 0;
    int         nStatus;
    int         index;
    CHAR        pDeviceName[NBT_MAXIMUM_BINDINGS+1][MAX_NAME+1];

    status = GetInterfaceList(pDeviceName);
    if (!NT_SUCCESS(status))
    {
        return WINSTEST_OPEN_FAILED;
    }

    for (index = 0; index < NBT_MAXIMUM_BINDINGS && pDeviceName[index][0]; index++)
    {
        //
        //  Open the device of the appropriate streams module to start with.
        //
        status = OpenNbt(&pDeviceName[index], &nbt, NBT_MAXIMUM_BINDINGS-index);
        if (!NT_SUCCESS(status))
        {
            //
            // Try the next binding!
            //
            continue;
        }

        GetIpAddress(nbt, &NetbtIpAddress);

        if (RemoteName[0] == '\0')
            return WINSTEST_INVALID_ARG;

        nStatus = CheckRemoteTable(nbt,RemoteName,NBName);
        if (nStatus == WINSTEST_VERIFIED)
            break;
    }

    return nStatus;
}


/*************************************************************/
/*        NBDecode(name,name2)                               */
/*                                                           */
/* This routine decodes a netbios name from level2 to leve1. */
/* name is 16 bytes long, remember that.                     */
/*                                                           */
/*************************************************************/

void
NBDecode(
    unsigned char *name,
    unsigned char *name2
    )
{
  int i;

  for (i = 0; i < NBT_NONCODED_NMSZ - 1; i++)
  {
     name[i] = (name2[2*i+1] - 0x41)*(NBT_NONCODED_NMSZ-1) +
               (name2[2*i+2] - 0x41);
  }

}

/*************************************************************/
/*        NBEncode(name2,name)                               */
/*                                                           */
/* This routine code a netbios name from level1 to level2.   */
/* name2 has to be NBT_NAMESIZE bytes long, remember that.   */
/*************************************************************/

void
NBEncode(
    unsigned char *name2,
    unsigned char *name
    )
{
    int i;

    name2[0] = 0x20;        /* length of first block */

    for (i = 0; i < NBT_NONCODED_NMSZ - 1; i++)
    {
        name2[ 2*i+1 ] =  ((name[ i ] >> 4) & 0x0f) + 0x41;
        name2[ 2*i+2 ] =  (name[ i ]  & 0x0f) + 0x41;
    }

    name2[ NBT_NAMESIZE-1 ] = 0;    /* length of next block */
}

ULONG
AddWins(
    IN  ULONG   IPAddr
    )
{
    INT i;

    for (i = 0; i < MAX_SERVERS; i++)
    {
        if (WinServers[i].Server.s_addr == IPAddr)
        {
            return 0;
        }

        if (WinServers[i].Server.s_addr == 0)
        {
            WinServers[i].Server.s_addr = IPAddr;
			NumWinServers++;
            return i;
        }
    }

    return 0;
}

VOID
PurgeWinsAddr(
    IN  ULONG   IPAddr
    )
{
    INT i;

    for (i = 0; i < MAX_SERVERS; i++)
    {
        if (WinServers[i].Server.s_addr == IPAddr)
        {
            INT j = i + 1;

            while (WinServers[j].Server.s_addr)
            {
                WinServers[j - 1] = WinServers[j];
                j++;
            }

            //
            // Zap the last entry
            //
            WinServers[j - 1].Server.s_addr = 0;

            break;
        }
    }
}

/*******************************************************************/
/*                                                                 */
/* Initialize the WinServers table and set NumWinServers to count  */
/*                                                                 */
/*******************************************************************/

BOOLEAN
InitServers(char *szServer, BOOL fVerifyWithPartners)
{
    FILE *                  sf = NULL;
    int                     i = 0;
    ULONG                   j = 0;
    u_char                  buffer[100] = {0};
    WINSINTF_RESULTS_NEW_T  ResultsN;
    struct in_addr          InAddr;
    char	                szNum[10] = {0};
    char                    lpResults[MAX_SIZE] = {0};

	strcpy(buffer, szServer);

    //WinServers[i].Server.s_addr = inet_addr(buffer);
	InAddr.s_addr = inet_addr(buffer);
    AddWins(InAddr.s_addr);

	if (fVerifyWithPartners)
	{
		if (GetStatus(TRUE, &ResultsN, TRUE, FALSE, inet_ntoa(InAddr)))
		{
			strcpy(lpResults, "");
			strcat(lpResults, "Unable to verify against the WINS server: ");
			strcat(lpResults, inet_ntoa(InAddr));
			strcat(lpResults, "\r\n\r\n");

			AddStatusMessage(lpResults);

			return FALSE;
		}

		//
		// Enter all the WINS server names into the server table
		//
		for (j = 0; j < ResultsN.NoOfOwners; j++)
		{
			//
			// Add addresses; check for duplicates
			//
			struct  in_addr InAddr;
			InAddr.s_addr = htonl(ResultsN.pAddVersMaps[j].Add.IPAdd);
			(VOID)AddWins(htonl(ResultsN.pAddVersMaps[j].Add.IPAdd));
		}

		//NumWinServers = ResultsN.NoOfOwners;

		strcpy(lpResults, "");
		_itoa(NumWinServers, szNum, 10);
		strcat(lpResults, szNum);
		strcat(lpResults, " Wins servers will be Queried:\r\n");

		AddStatusMessage(lpResults);

		for (i = 0; i < NumWinServers; i++)
		{
			struct in_addr  InAddr;

			InAddr.s_addr = WinServers[i].Server.s_addr;

			strcpy(lpResults, "");
			strcat(lpResults, inet_ntoa(InAddr));
			strcat(lpResults,"\r\n");

			AddStatusMessage(lpResults);
		}
	}

    return  TRUE;
}



/*******************************************************************/
/*                                                                 */
/* Send a Name Query to a WINS Server                              */
/*                                                                 */
/* name is the name to query                                       */
/* winsaddr is the ip address of the wins server to query          */
/* TransID is the transaction ID to use for the query              */
/*                                                                 */
/*******************************************************************/

void
_stdcall
SendNameQuery(
    unsigned char *name,
    u_long winsaddr,
    u_short TransID
    )
{
    struct sockaddr_in destad;
    char    lpResults[MAX_SIZE] = {0};
    char    paddedname[NBT_NONCODED_NMSZ];

    struct
    {
        u_short TransactionID;
        u_short Flags;
        u_short QuestionCount;
        u_short AnswerCount;
        u_short NSCount;
        u_short AdditionalRec;
        u_char  QuestionName[NBT_NAMESIZE];
        u_short QuestionType;
        u_short QuestionClass;
    } NameQuery;

    memset(paddedname, 0x20, sizeof(paddedname));
    memcpy(paddedname, name, strlen(name));

    NBEncode(NameQuery.QuestionName, paddedname);

    NameQuery.TransactionID = htons(TransID);
    NameQuery.Flags = htons(0x0100);
    NameQuery.QuestionCount = htons(1);
    NameQuery.AnswerCount = 0;
    NameQuery.NSCount = 0;
    NameQuery.AdditionalRec = 0;
    NameQuery.QuestionType = htons(0x0020);
    NameQuery.QuestionClass = htons(1);

    destad.sin_family = AF_INET;
    destad.sin_port = htons(137);
    destad.sin_addr.s_addr = winsaddr;

    if (sendto(sd, (char *)&NameQuery, sizeof(NameQuery), 0,
                   (struct sockaddr *)&destad, sizeof(destad)) == SOCKET_ERROR)
    {
        wsprintfA(lpResults, "sendto() failed. Error %d. \r\n", WSAGetLastError());

        AddStatusMessage(lpResults);

        // exit(1);
        return;
    }
}

/*******************************************************************/
/*                                                                 */
/* Wait for a Name Response which matches the Transaction ID       */
/*                                                                 */
/* recvaddr is the ip address returned by the wins server          */
/*                                                                 */
/*******************************************************************/

int
_stdcall
GetNameResponse(
    u_long * recvaddr,
	u_short  TransactionID
    )

{
    char lpResults[100] = {0};
    int i;
    int len;
    int rslt;
    u_long AnswerAddr;
    struct sockaddr_in addr;
    NameResponse * pNameResponse = NULL;
    BYTE Buf[NAME_RESPONSE_BUFFER_SIZE] = {0};

    i = 0;
    while (i < 15)
    {
        addrlen = sizeof(addr);
        if ((len=recvfrom(sd, (char *) Buf, sizeof(Buf), 0,
                     (struct sockaddr *)&addr, &addrlen)) < 0)
        {
            rslt = WSAGetLastError();
            if (rslt == WSAEWOULDBLOCK)
            {
                Sleep(100);
                i++;
                continue;
            }
            else
            {
                wsprintfA(lpResults, "recvfrom() failed. Error %d. \r\n", rslt);
                AddStatusMessage(lpResults);

                return WINSTEST_NO_RESPONSE;
            }
        }

        pNameResponse = (NameResponse *) Buf;

        if (TransactionID == htons(pNameResponse->TransactionID))
        {
            if (htons(pNameResponse->AnswerCount) == 0)
            {
                *recvaddr = 0;
                return(WINSTEST_NOT_FOUND);
            }

            AnswerAddr = (pNameResponse->AnswerAddr2 << 16) | pNameResponse->AnswerAddr1;
            *recvaddr = AnswerAddr;

            return(WINSTEST_FOUND);
        }
    }

    *recvaddr = 0;

    return(WINSTEST_NO_RESPONSE);
}

INT
_stdcall
InitNameCheckSocket()
{
	char lpResults[MAX_SIZE];

    /*  Set up a socket to use for querys and responses   */

    WSAStartup( 0x0101, &WsaData ); // make sure winsock is happy - noop for now

    if ((sd = socket( AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
    {
        //wsprintfA(lpResults, "socket() failed.  Error %d. \r\n", WSAGetLastError());
        //AddStatusMessage(lpResults);

		return WSAGetLastError();
    }

    myad.sin_family = AF_INET;
    myad.sin_addr.s_addr = INADDR_ANY;
    myad.sin_port = htons(0);

    if (bind( sd, (struct sockaddr *)&myad, sizeof(myad) ) < 0)
    {
        //wsprintfA(lpResults, "bind() failed. Error %d. \r\n", WSAGetLastError());
        //AddStatusMessage(lpResults);

        closesocket( sd );
		return WSAGetLastError();
    }

    if (ioctlsocket(sd, FIONBIO, &NonBlocking) < 0)
    {
        //wsprintfA(lpResults, "ioctlsocket() failed. Error %d. \r\n", WSAGetLastError());
        //AddStatusMessage(lpResults);
		return WSAGetLastError();
    }

	return 0;
}

INT
_stdcall
CloseNameCheckSocket()
{
	closesocket(sd);

	WSACleanup();

	return 0;
}

DWORD WINAPI ThreadProc(LPVOID pData)
{
    DialogBox(g_hInstance,
	 	      MAKEINTRESOURCE(IDD_VERSION_CONSIS),
			  g_hwndParent,
			  dlgProc);

    return 29;
}

void CreateConsistencyStatusWindow(HINSTANCE hInstance, HWND hWndParent)
{
	// dialog creation
    // create a new window if we don't have one or it possibly went away
    DWORD dwId;
    MSG   msg;

    g_hInstance = hInstance;
    g_hwndParent = hWndParent;

    if (g_wndDlg && !IsWindow(g_wndDlg))
    {
        CloseHandle(g_hThread);
        g_wndDlg = NULL;
    }

    if (!g_wndDlg)
    {
        g_hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &dwId);
        while (g_wndDlg == NULL)
        {
            // give the thread a chance to run
            Sleep(0);

            // since we are all on the same message pump, we need to
            // give the system a chance to handle messages
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	        {
		        TranslateMessage(&msg);
		        DispatchMessage(&msg);
	        }
        }
    }
}

void DestroyConsistencyStatusWindow()
{
    BOOL bResult;

	if (IsWindow(g_wndDlg))
    {
        bResult = PostMessage(g_wndDlg, WM_COMMAND, MAKEWPARAM(0, IDCANCEL), 0);
    }

    if (g_wndDlg)
    {
        WaitForSingleObject(g_hThread, 5000);

        CloseHandle(g_hThread);

        g_hThread = NULL;
        g_wndDlg = NULL;
    }
}

void EnableConsistencyCloseButton(BOOL bEnable)
{
    HWND    hButton;
    HMENU   hSysMenu;
    RECT    rect;

    if (IsWindow(g_wndDlg))
    {
        // enable/disable the button
        hButton = GetDlgItem(g_wndDlg, IDCANCEL);
        EnableWindow(hButton, bEnable);

        // now the system menu
        hSysMenu = GetSystemMenu(GetConsistencyStatusWnd(), FALSE);
        EnableMenuItem(hSysMenu, SC_CLOSE, bEnable ? MF_ENABLED : MF_DISABLED);

        GetWindowRect(GetConsistencyStatusWnd(), &rect);
        InvalidateRect(GetConsistencyStatusWnd(), &rect, TRUE);
    }
}

void ClearConsistencyStatusWindow()
{
    HWND hEdit;

    if (IsWindow(g_wndDlg))
    {
        hEdit = GetDlgItem(g_wndDlg, IDC_EDIT_MESSAGE);
        SetWindowText(hEdit, (LPCTSTR) "");
    }
}

HWND GetConsistencyStatusWnd()
{
    return g_wndDlg;
}

// this function should be called once before calling either AddWinsServer
// or CheckRegisteredNames
INT
_stdcall
InitNameConsistency(HINSTANCE hInstance, HWND hWnd)
{
	int status = 0;

    // initialize things
	NumWinServers = 0;
    memset(WinServers, 0, sizeof(WinServers));

    CreateConsistencyStatusWindow(hInstance, hWnd);

    InitNameCheckSocket();

	return status;
}

INT
_stdcall
AddWinsServer(char * szServer, BOOL fVerifyWithPartners)
{
    if (!InitServers(szServer, fVerifyWithPartners))
	{
        return FALSE;
	}

	return TRUE;
}

/*********************************************************************/
/*      M a i n                                                      */
/*                                                                   */
/* 27-Dec-1995  CDermody    Rather that report 'is not responding'   */
/*                          for partial response, use multiple       */
/*                          passes over those that were incomplete   */
/*                          and report 'never responded' only for    */
/*                          those that never did.                    */
/*                          Add mechanism to query the purported     */
/*                          owner of the address to see if the       */
/*                          service really exists there.             */
/*********************************************************************/
/*
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
*/
INT
_stdcall
CheckNameConsistency(char* szName)
{
    int             status = 0;
    int             i;
    int             Pass;
    int             ServerInx, NameInx, Inx;
    struct in_addr  retaddr;
    struct in_addr  tempaddr;
    u_long          temp;
    WINSERVERS *    ServerTemp;
    int             retry;
	FILE *          nf;
    TCHAR           szBuffer[MAX_SIZE] = {0};
    TCHAR           szNum[10];
    char            lpResults[100] = {0};

	// initialize some things
    memset(NBNames, 0, sizeof(NBNames));
    memset(VerifiedAddress, 0, sizeof(VerifiedAddress));

    for (i = 0; i < MAX_SERVERS; i++)
    {
        WinServers[i].LastResponse = -1;
        WinServers[i].fQueried = FALSE;
        WinServers[i].Valid = 0;
        WinServers[i].Failed = 0;
        WinServers[i].Retries = 0;
        WinServers[i].Completed = 0;
    }

	SetCursor(LoadCursor(0, MAKEINTRESOURCE(IDC_WAIT)));

	// call InitNameConsistency, then AddWinsServer to build the list of servers
	// to verify this name against.
	NumNBNames = 1;
	NameInx = 0;

	NBNames[NameInx] = malloc(NBT_NONCODED_NMSZ);
    if (NBNames[NameInx] == NULL)
    {
        strcat(lpResults, "malloc(17) failed.\r\n");

        //DestroyStatusWindow();

        return FALSE;
    }

	strcpy(NBNames[NameInx], szName);

    for (Pass = 1; Pass < 3; Pass++)
    {
		_tcscpy(szBuffer, L"");
		_tcscat(szBuffer, L"\r\n");
        _tcscat(szBuffer, L"Pass ");
		_itot(Pass, szNum, 10);
		_tcscat(szBuffer, szNum);
		_tcscat(szBuffer, L"\r\n");
		_tcscat(szBuffer, L"\r\n");

        AddStatusMessageW(szBuffer);

        /*  We initially have no failed servers   */

        for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
        {
            ServerTemp = &WinServers[ServerInx];
			ServerTemp->Failed = 0;
        }

        for (NameInx = 0; NameInx < NumNBNames; NameInx++)
        {
            for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
            {
                ServerTemp = &WinServers[ServerInx];

                if (ServerTemp->Completed)
                {
                    continue;
                }

                retry = 0;
                TranID++;

RetryLoop:
                strcpy(lpResults, "");
                strcat(lpResults, "Sending NameQuery to the server [");
				strcat(lpResults, inet_ntoa(ServerTemp->Server));
				strcat(lpResults, "] for name " );
				strcat(lpResults, NBNames[NameInx]);

                //AddStatusMessage(lpResults);
                SendNameQuery(NBNames[NameInx],
                              ServerTemp->Server.s_addr,
                              TranID);

                switch (GetNameResponse(&retaddr.s_addr, TranID))
                {
                case WINSTEST_FOUND:     // found
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 1;
                    ServerTemp->LastResponse = NameInx;

                    if (retaddr.s_addr == VerifiedAddress[NameInx])
                    {
                        // this address has already been verified... don't
                        // do the checking again
						strcat(lpResults, "; OK.\r\n");

                        AddStatusMessage(lpResults);
                        break;
                    }

                    status = VerifyRemote(inet_ntoa(ServerTemp->RetAddr),
                                          NBNames[NameInx]);


                    if (WINSTEST_VERIFIED == status)
                    {
						strcat(lpResults, "; OK.\r\n");

                        AddStatusMessage(lpResults);

                        VerifiedAddress[NameInx] = retaddr.s_addr;
                    }
                    else
                    {
						strcat(lpResults, "; could not be verified.\r\n");

                        AddStatusMessage(lpResults);
                    }

                    break;

                case WINSTEST_NOT_FOUND:     // responded -- name not found
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 0;
                    ServerTemp->LastResponse = NameInx;

					strcat(lpResults, "; Name not found!\r\n");

                    AddStatusMessage(lpResults);

                    break;

                case WINSTEST_NO_RESPONSE:     // no response
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 0;
                    ServerTemp->Retries++;

					strcat(lpResults, "; No response.\r\n");

                    AddStatusMessage(lpResults);

                    retry++;
                    if (retry > 2)
                    {
                        ServerTemp->Failed = 1;
                        continue;
                    }

                    goto RetryLoop;

                }   // switch GetNameResponse
            }   // for ServerInx

            for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
            {
                ServerTemp = &WinServers[ServerInx];
                if (ServerTemp->Completed)
                {
                    continue;
                }

                if (ServerTemp->Valid)
                {
                    temp = ServerTemp->RetAddr.s_addr;
                    break;
                }
            }   // for ServerInx

            for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
            {
                ServerTemp = &WinServers[ServerInx];
                if (ServerTemp->Completed)
                {
                    continue;
                }

                if ( (ServerTemp->Valid) )
                {
                    if ((temp != ServerTemp->RetAddr.s_addr)
                        || (0 != VerifiedAddress[NameInx]
                            && temp != VerifiedAddress[NameInx]) )
                    {
						strcpy(lpResults, "");
                        strcat(lpResults, "Inconsistency found with WINS for NetBIOS name ");
						strcat(lpResults, NBNames[NameInx]);
						strcat(lpResults, "\r\n");

                        AddStatusMessage(lpResults);

                        if (0 != VerifiedAddress[NameInx])
                        {
                            tempaddr.s_addr = VerifiedAddress[NameInx];

							strcpy(lpResults, "");
							strcat(lpResults,"NetBIOS name has verified address (");
							strcat(lpResults,inet_ntoa(tempaddr));
							strcat(lpResults, "). \r\n");

                            AddStatusMessage(lpResults);
                        }

                        for (Inx = 0; Inx < NumWinServers; Inx++)
                        {
                            if (WinServers[Inx].Valid)
                            {
								strcpy(lpResults, "");
                                strcat(lpResults,"    NameQuery(");
								strcat(lpResults,inet_ntoa(WinServers[Inx].Server));
								strcat(lpResults, " \\");
								strcat(lpResults, NBNames[NameInx]);
								strcat(lpResults, ")");

                                strcat(lpResults , " = ");
								strcat(lpResults, inet_ntoa(WinServers[Inx].RetAddr));
								strcat(lpResults, " \r\n");

                                AddStatusMessage(lpResults);
                            }
                        }
                        break;
                    }
                }
            }   // for ServerInx
        }   // for NameInx

        for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
        {
            ServerTemp = &WinServers[ServerInx];
            if (!ServerTemp->Failed)
            {
                ServerTemp->Completed = 1;
            }
        } // for ServerInx
    }   // for Pass

    for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
    {
        ServerTemp = &WinServers[ServerInx];
        if ((-1) == ServerTemp->LastResponse)
        {
			strcpy(lpResults, "");
            strcat(lpResults,"WINS Server ");
			strcat(lpResults, inet_ntoa(ServerTemp->Server));
			strcat(lpResults, " never responded! \r\n");

            AddStatusMessage(lpResults);
        }
        else if (0 == ServerTemp->Completed)
        {
			strcpy(lpResults, "");
            strcat(lpResults, "WINS Server ");
			strcat(lpResults, inet_ntoa(ServerTemp->Server));
			strcat(lpResults, " incomplete!\r\n");

            AddStatusMessage(lpResults);
        }
    }   // for ServerInx

    for (NameInx = 0; NameInx < NumNBNames; NameInx++)
    {
        if (0 == VerifiedAddress[NameInx])
        {
			strcpy(lpResults, "");
            strcat(lpResults,"Could not verify address for name (");
			strcat(lpResults, NBNames[NameInx]);
			strcat(lpResults, ").\r\n\r\n");

            AddStatusMessage(lpResults);
        }
    }   // for NameInx
    // exit(0);

	if (NBNames[0])
        free(NBNames[0]);

    return 1;   // just to keep the compiler happy -- why do we have to?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\svrstats.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	svrstats.h
		The server statistics dialog
		
    FILE HISTORY:
        
*/

#ifndef _SVRSTATS_H
#define _SVRSTATS_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

#ifndef _WINSSNAP_H
#include "winssnap.h"
#endif

#ifndef _LISTVIEW_H
#include "listview.h"
#endif

// WINS Service file
extern "C" {
    #include "winsintf.h"
    #include "ipaddr.h"
}

#define SERVER_STATS_DEFAULT_WIDTH      450
#define SERVER_STATS_DEFAULT_HEIGHT     300

class CServerStatsFrame;

// structure used for the back ground thread in refreshing the stats
struct ThreadInfo
{
    DWORD dwInterval;
	CServerStatsFrame*  pDlg;
};


class CServerStatsFrame : public StatsDialog
{
public:
	CServerStatsFrame();
	~CServerStatsFrame();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	virtual void Sort(UINT nColumnId);

    // custom methods
    afx_msg long OnNewStatsAvailable(UINT wParam, LONG lParam);
    afx_msg long OnUpdateStats(UINT wParam, LONG lParam);
    
    void  UpdateWindow(PWINSINTF_RESULTS_T  pwrResults);
    DWORD GetStats();

    void SetNode(ITFSNode * pNode) { m_spNode.Set(pNode); }
    void SetServer(LPCTSTR pServer) { m_strServerAddress = pServer; }

	// message handlers
	afx_msg void OnDestroy();
	afx_msg	void OnClear();

    DECLARE_MESSAGE_MAP()
    
protected:
    CString         m_strServerAddress;
    SPITFSNode      m_spNode;

	CWinThread *	m_pRefreshThread;
	HANDLE			m_hmutStatistics;

    // helper functions 
	void StartRefresherThread();
	void UpdatePartnerStats();

public:
	WINSINTF_RESULTS_T  m_wrResults;
    HANDLE              m_hAbortEvent;
	
    DWORD	GetRefreshInterval();
    void    ReInitRefresherThread();
	void    KillRefresherThread();

	// Context Help Support
    virtual DWORD * GetHelpMap() { return WinsGetHelpMap(IDD_STATS_NARROW); }
};

#endif _SERVSTAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\verify.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	verify.h	
		WINS defines from ntdef.h 
		
    FILE HISTORY:
        
*/

#ifndef _VERIFY_H
#define _VERIFY_H

#ifdef __cplusplus
extern "C"
{
#endif
	
typedef struct
{
    BOOLEAN         fQueried;
    struct in_addr  Server;
    struct in_addr  RetAddr;
    int             Valid;
    int             Failed;
    int             Retries;
    int             LastResponse;
    int             Completed;
} WINSERVERS;

#define MAX_SERVERS		1000

#define NBT_NONCODED_NMSZ   17
#define NBT_NAMESIZE        34

#define WINSTEST_FOUND            0
#define WINSTEST_NOT_FOUND        1
#define WINSTEST_NO_RESPONSE      2

#define WINSTEST_VERIFIED         0
#define WINSTEST_OUT_OF_MEMORY    3
#define WINSTEST_BAD_IP_ADDRESS   4
#define WINSTEST_HOST_NOT_FOUND   5
#define WINSTEST_NOT_VERIFIED     6
#define WINSTEST_INVALID_ARG      7
#define WINSTEST_OPEN_FAILED      8

#define BUFF_SIZE                 1024

typedef struct _NameResponse
{
    u_short TransactionID;
    u_short Flags;
    u_short QuestionCount;
    u_short AnswerCount;
    u_short NSCount;
    u_short AdditionalRec;
    u_char  AnswerName[NBT_NAMESIZE];
    u_short AnswerType;
    u_short AnswerClass;
    u_short AnswerTTL1;
    u_short AnswerTTL2;
    u_short AnswerLength;
    u_short AnswerFlags;
    u_short AnswerAddr1;
    u_short AnswerAddr2;
} NameResponse;

#define NAME_RESPONSE_BUFFER_SIZE sizeof(NameResponse) * 10

extern int VerifyRemote(IN PCHAR RemoteName, IN PCHAR NBName);
extern INT _stdcall CheckNameConsistency(char * szName);
extern INT _stdcall InitNameConsistency(HINSTANCE hInstance, HWND hWnd);
extern INT _stdcall AddWinsServer(char * szServer, BOOL fVerifyWithPartners);
extern INT _stdcall InitNameCheckSocket();
extern INT _stdcall CloseNameCheckSocket();
extern void _stdcall SendNameQuery(unsigned char *name, u_long winsaddr, u_short TransID);
extern int _stdcall GetNameResponse(u_long *recvaddr, u_short TransactionID);

extern void CreateConsistencyStatusWindow(HINSTANCE hInstance, HWND hWndParent);
extern void DestroyConsistencyStatusWindow();
extern void ClearConsistencyStatusWindow();
extern void EnableConsistencyCloseButton(BOOL bEnable);
extern void AddStatusMessageW(LPCWSTR pszMessage);
extern HWND GetConsistencyStatusWnd();

#ifdef __cplusplus
}
#endif

#endif _VERIFY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\statnode.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	statnode.h
		WINS scope pane status node
		
    FILE HISTORY:
        
*/

#ifndef _STATNODE_H
#define _STATNODE_H

#ifndef _WINSHAND_H
#include "winshand.h"
#endif

#ifndef _STATUS_H
#include "status.h"
#endif


class CServerStatus : public CWinsHandler
{
	public:
		CServerStatus(ITFSComponentData * pTFSCompData);
		~CServerStatus(){	};

	// Interface
	public:
		// Result handler functionality
//		OVERRIDE_ResultHandler_HasPropertyPages() { return hrOK; }
		OVERRIDE_ResultHandler_GetString();
		
	// Implementation
public:
	// CWinsHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

	// Get/Set Functions
	const CString &GetServerName()
	{
		return m_strServerName;
	}

	void SetRecordName(CString& strName)
	{
		m_strServerName = strName;
	}

	const CString &GetStatus()
	{
		return m_strStatus;
	}

	void SetStatus(CString &strType)
	{
		m_strStatus = strType;
	}

	const CString &GetIPAddress()
	{
		return m_strIPAddress;
	}

	void SetIPAddress(CString& strName)
	{
		m_strIPAddress = strName;
	}

	void FormDisplayName(CString &strDisplay);
	
	char			szServerName[MAX_PATH];
	char			szIPAddress[MAX_PATH];
	DWORD			dwIPAddress;
	DWORD			dwMsgCount;
	DWORD			dwState;							// checks if the server has been deleted from the list
    char			szNameToQry[STR_BUF_SIZE];          // the name to use in the queries
    char			nbtFrameBuf[MAX_NBT_PACKET_SIZE];   // buffer to store the NetBT frame
	CString			m_strStatus;
	CTime           m_timeLast;
	UINT			m_uImage;
    
private:
	CString			m_strServerName;
	CString			m_strIPAddress;
	CString         m_strLastChecked;

	// info from the Wins Record Object
	DWORD			m_dwIPAddress;
};

#endif //SRVNODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

	FILE HISTORY:
        
*/

// so that the winscnst.h file compiles
#define FUTURES(x)
#define MCAST       1

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxtempl.h>
#include <afxcview.h>
#include <afxext.h>
#include <afxmt.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//#pragma comment(lib, "mmc")
#include <mmc.h>


extern "C"
{
	#include "winsock.h"     // WinSock definitions
	#include "lmerr.h"       // Network error codes 
}

// WINS Service file
#define WINS_CLIENT_APIS

extern "C" 
{
    #include "winsintf.h"   // WINS RPC interfaces
    #include "rnraddrs.h"   // needed by winscnst.h
    #include "winscnst.h"   // WINS constants and default values
    #include "ipaddr.h"     // ip address stuff
}


#include "resource.h"

// Global defines for WINS snapin
#include "winssnap.h"

// macros for memory exception handling
#define CATCH_MEM_EXCEPTION             \
	TRY

#define END_MEM_EXCEPTION(err)          \
	CATCH_ALL(e) {                      \
       err = ERROR_NOT_ENOUGH_MEMORY ;  \
    } END_CATCH_ALL

// Files from ..\tfscore
#include <dbgutil.h>
#include <std.h>
#include <errutil.h>
#include <register.h>
#include <htmlhelp.h>

// Files from ..\common
#include <ccdata.h>
#include <about.h>
#include <dataobj.h>
#include <proppage.h>
#include <ipaddr.hpp>
#include <objplus.h>
#include <intltime.h>
#include <intlnum.h>

// project specific
#include "winscomp.h"
#include "WinsSup.h"
#include "helparr.h"
#include "ipnamepr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\status.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	status.h
		WINS result pane state nodes
		
    FILE HISTORY:
        
*/

#ifndef _STATUS_H
#define _STATUS_H

#ifndef _WINSHAND_H
#include "winshand.h"
#endif

#ifndef _WINSMON_H
#include "winsmon.h"
#endif

#ifndef _STATNODE_H
#include "statnode.h"
#endif

#ifndef _SERVER_H
#include "server.h"
#endif

#include "afxmt.h"

class  CServerStatus;


/*---------------------------------------------------------------------------
	Class:	CWinsStatusHandler
 ---------------------------------------------------------------------------*/
class CWinsStatusHandler : public CMTWinsHandler
{
// Interface
public:
	CWinsStatusHandler(ITFSComponentData *pCompData, DWORD dwUpdateInterval);

	~CWinsStatusHandler();

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_DestroyHandler();

	STDMETHODIMP_(LPCTSTR) GetString(ITFSNode * pNode, int nCol);

    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

public:
	// CWinsHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

    OVERRIDE_BaseHandlerNotify_OnPropertyChange();
	OVERRIDE_BaseHandlerNotify_OnExpand();
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

    OVERRIDE_ResultHandler_CompareItems();

public:
	DWORD GetUpdateInterval()
	{
		return m_dwUpdateInterval;
	}

	void SetUpdateInterval(DWORD dwValue)
	{
		// set the new interval and wakeup the main probe thread
        // since we are resetting the interval, do a check now and
        // then wait the new interval
        m_dwUpdateInterval = dwValue;
        SetEvent(m_hWaitIntervalMain);
	}

	DWORD WINAPI ExecuteMonitoring();
	DWORD WINAPI ListeningThreadFunc() ;

	HRESULT AddNode(ITFSNode *pNode, CWinsServerHandler *pServer);
	HRESULT DeleteNode(ITFSNode *pNode, CWinsServerHandler *pServer);

    // we don't use query object, but being a MTHandler requires this
    virtual ITFSQueryObject* OnCreateQuery(ITFSNode *pNode) { return NULL; }
	STDMETHOD(OnNotifyHaveData)(LPARAM);

	typedef CArray <CServerStatus *, CServerStatus *> listServers;

	listServers		m_listServers;

// Implementation
private:
	HRESULT CreateListeningSockets( );
	void    StartMonitoring(ITFSNode *pNode);
	int     Probe(CServerStatus *pServer, SOCKET listenNameSvcSock);
	void    CloseSockets();

	void    RemoveServer(int i);
	void    AddServer(CServerStatus* pServer);
	void    BuildServerList(ITFSNode *pNode);
	void    SetIPAddress(int i, LPSTR szIP);
	CServerStatus* GetServer(int i);

	HRESULT CreateNodes(ITFSNode *pNode);
	void    UpdateStatusColumn(ITFSNode *pNode);
	
	int     GetListSize();
	void    UpdateStatus(int nIndex, UINT uStatusId, UINT uImage);
	
	BOOL    IsServerDeleted(CServerStatus *pStat);
	void    MarkAsDeleted(LPSTR szBuffer, BOOL bDelete = TRUE);
	CServerStatus* GetExistingServer(LPSTR szBuffer);

    void    NotifyMainThread();

	BOOL	FCheckForAbort();

private:
	// variables for monitoring
	fd_set					m_listenSockSet;
	SOCKET					listenNameSvcSock;   // 2DO: for the listening thread...
	SOCKET					listenSockCl;	    // socket listening for frames from DHCP srvs
	SOCKET					listenSockSrv;	    // socket listening for frames from DHCP srvs
	
    // thread handles
    HANDLE					m_hMainMonThread;
	HANDLE					m_hListenThread;

    // event handles
    HANDLE					m_hAbortListen;
    HANDLE					m_hAbortMain;
    HANDLE					m_hAnswer;
    HANDLE					m_hWaitIntervalListen;
    HANDLE					m_hWaitIntervalMain;
    HANDLE					m_hPauseListening;
	
    int						m_nServersUpdated;
	DWORD					m_dwUpdateInterval;	// Holds the value in milliSec

	CCriticalSection		m_cs;
    SPITFSNode              m_spNode;
};

// thread proc the background thread initially is called on
DWORD WINAPI MonThreadProc(LPVOID lParam);
DWORD WINAPI MainMonThread(LPVOID lParam);


#endif _STATUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\status.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	status.cpp
		wins status scope pane node handler. 
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "status.h"
#include "server.h"
#include "statnode.h"
#include "dhcp.h"
#include "statndpp.h"

#define WINS_MESSAGE_SIZE       576   
#define ANSWER_TIMEOUT          20000


/*---------------------------------------------------------------------------
	CWinsStatusHandler::CWinsStatusHandler
		Description
 ---------------------------------------------------------------------------*/
CWinsStatusHandler::CWinsStatusHandler
(
    ITFSComponentData * pCompData,
	DWORD               dwUpdateInterval
) : CMTWinsHandler(pCompData),
	m_hListenThread(NULL),
	m_hMainMonThread(NULL),
	m_hPauseListening(NULL),
	m_nServersUpdated(0)
{
	m_bExpanded = FALSE;
	m_nState = loaded;
	m_dwUpdateInterval = dwUpdateInterval;
    
    // from class ThreadHandler
    m_uMsgBase = 0;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::CWinsStatusHandler
		Destructor
 ---------------------------------------------------------------------------*/
CWinsStatusHandler::~CWinsStatusHandler()
{
	m_listServers.RemoveAll();
	
    if (m_uMsgBase)
    {
        ::SendMessage(m_hwndHidden, WM_HIDDENWND_REGISTER, FALSE, m_uMsgBase);
        m_uMsgBase = 0;
    }

    CloseSockets();
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::DestroyHandler
	    Release and pointers we have here
    Author: EricDav
----------------------------------------------------------------------------*/
HRESULT
CWinsStatusHandler::DestroyHandler
(
	ITFSNode * pNode
)
{
    m_spNode.Set(NULL);
    return hrOK;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::OnCreateNodeId2
		Returns a unique string for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CWinsStatusHandler::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    strId = strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::InitializeNode
		Initializes node specific data
----------------------------------------------------------------------------*/
HRESULT
CWinsStatusHandler::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = hrOK;
	SPITFSNode spParent;
	
	CString strTemp;
	strTemp.LoadString(IDS_SERVER_STATUS_FOLDER);

	SetDisplayName(strTemp);
	
	// Make the node immediately visible
	pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
	pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_SERVER);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_SERVER);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);
	pNode->SetData(TFS_DATA_TYPE, WINSSNAP_SERVER_STATUS);
	pNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

	SetColumnStringIDs(&aColumns[WINSSNAP_SERVER_STATUS][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_SERVER_STATUS][0]);

  	// the event to signal the Listen thread to abort
	m_hAbortListen = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hAbortListen == NULL)
    {
        Trace1("WinsStatusHandler::InitializeNode - CreateEvent Failed m_hAbortListen %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }

   	// the event to signal the main thread to abort
	m_hAbortMain = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hAbortListen == NULL)
    {
        Trace1("WinsStatusHandler::InitializeNode - CreateEvent Failed m_hAbortMain %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }

    // the event to signal the threads to wakeup
	m_hWaitIntervalListen = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hWaitIntervalListen == NULL)
    {
        Trace1("WinsStatusHandler::InitializeNode - CreateEvent Failed m_hWaitIntervalListen %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }

	m_hWaitIntervalMain = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hWaitIntervalMain == NULL)
    {
        Trace1("WinsStatusHandler::InitializeNode - CreateEvent Failed m_hWaitIntervalMain %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }

	// when sending a probe, the thread waits for this
	m_hAnswer = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hAnswer == NULL)
    {
        Trace1("WinsStatusHandler::InitializeNode - CreateEvent Failed m_hAnswer %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }

	return hr;
}


/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
	CWinsStatusHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CWinsStatusHandler::GetString
(
	ITFSNode *	pNode, 
	int			nCol
)
{
	if (nCol == 0 || nCol == -1)
		return GetDisplayName();

	else
		return NULL;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::OnAddMenuItems
		Description
---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsStatusHandler::OnAddMenuItems
(
	ITFSNode *				pNode,
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	LPDATAOBJECT			lpDataObject, 
	DATA_OBJECT_TYPES		type, 
	DWORD					dwType,
	long *					pInsertionAllowed
)
{ 
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	
	return hr; 
}


/*!--------------------------------------------------------------------------
	CWinsStatusHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsStatusHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = hrOK;
	}
	else
	{
		// we have property pages in the normal case
		hr = hrOK;
	}

    return hr;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::CreatePropertyPages
		Description
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsStatusHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR    			handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT	hr = hrOK;

	Assert(pNode->GetData(TFS_DATA_COOKIE) != 0);

	// Object gets deleted when the page is destroyed
	SPIComponentData spComponentData;
	m_spNodeMgr->GetComponentData(&spComponentData);

	CStatusNodeProperties * pStatProp = 
								new CStatusNodeProperties(pNode, 
															spComponentData, 
															m_spTFSCompData, 
															NULL);

	Assert(lpProvider != NULL);

	return pStatProp->CreateModelessSheet(lpProvider, handle);
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::OnPropertyChange
		Description
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsStatusHandler::OnPropertyChange
(	
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataobject, 
	DWORD			dwType, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	LONG_PTR changeMask = 0;

	CStatusNodeProperties * pProp 
		= reinterpret_cast<CStatusNodeProperties *>(lParam);

	// tell the property page to do whatever now that we are back on the
	// main thread
	pProp->OnPropertyChange(TRUE, &changeMask);

	pProp->AcknowledgeNotify();

	if (changeMask)
		pNode->ChangeNode(changeMask);

	return hrOK;
}

HRESULT 
CWinsStatusHandler::OnExpand
(
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM			arg, 
	LPARAM			param
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = hrOK;

	if (m_bExpanded)
		return hr;

    m_spNode.Set(pNode);

	// build the list to hold the list of the servers
	BuildServerList(pNode);

	// Create the result pane data here
	CreateNodes(pNode);

	// start monitoring
	StartMonitoring(pNode);

	m_bExpanded  = TRUE;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsStatusHandler::OnNotifyHaveData
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CWinsStatusHandler::OnNotifyHaveData
(
	LPARAM			lParam
)
{
    // The background wins monitoring stuff sends us a message to update the 
    // status column information
    UpdateStatusColumn(m_spNode);

    return hrOK;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::OnResultRefresh
		Base handler override
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsStatusHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    // wait up the monitoring thread
    SetEvent(m_hWaitIntervalMain);

    return hrOK;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::CompareItems
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CWinsStatusHandler::CompareItems
(
	ITFSComponent * pComponent, 
	MMC_COOKIE		cookieA, 
	MMC_COOKIE		cookieB, 
	int				nCol
) 
{ 
	SPITFSNode spNode1, spNode2;

	m_spNodeMgr->FindNode(cookieA, &spNode1);
	m_spNodeMgr->FindNode(cookieB, &spNode2);
	
	int nCompare = 0; 

	CServerStatus * pWins1 = GETHANDLER(CServerStatus, spNode1);
	CServerStatus * pWins2 = GETHANDLER(CServerStatus, spNode2);

	switch (nCol)
	{
		// name
        case 0:
            {
       			nCompare = lstrcmp(pWins1->GetServerName(), pWins2->GetServerName());
            }
            break;

        // status
        case 1:
            {
                CString str1;

                str1 = pWins1->GetStatus();
                nCompare = str1.CompareNoCase(pWins2->GetStatus());
            }
            break;
    }

    return nCompare;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::BuildServerList
		Description
	Author: v-shubk
 ---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::BuildServerList(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// get the root node
	SPITFSNode  spRootNode;

	m_spNodeMgr->GetRootNode(&spRootNode);

	// enumerate thro' all the nodes
	HRESULT hr = hrOK;
	SPITFSNodeEnum spNodeEnum;
	SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;
	BOOL bFound = FALSE;

	// get the enumerator for this node
	spRootNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	while (nNumReturned)
	{
		// iterate to teh next node, if the status handler node is seen
		const GUID*               pGuid;
		
		pGuid = spCurrentNode->GetNodeType();

		if (*pGuid != GUID_WinsServerStatusNodeType)
		{
			// add to the list
			CServerStatus* pServ = NULL;
			
			char	szBuffer[MAX_PATH];
			
			CWinsServerHandler * pServer 
				= GETHANDLER(CWinsServerHandler, spCurrentNode);

            CString strTemp = pServer->GetServerAddress();

            // this should be ACP
            WideToMBCS(strTemp, szBuffer);

			pServ = new CServerStatus(m_spTFSCompData);

			strcpy(pServ->szServerName, szBuffer);
			pServ->dwIPAddress = pServer->GetServerIP();
			pServ->dwMsgCount = 0;
			strcpy(pServ->szIPAddress, "");

			m_listServers.Add(pServ);
		}
        
		// get the next Server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}
}


/*---------------------------------------------------------------------------
		CWinsStatusHandler::CreateListeningSockets( ) 
  Abstract:                                                              
      This function initializes Winsock and opens a socket that listens  
      to bcasts the DHCP srv sends to UDP port 68.                       
  Arguments:                                                             
      pListenSockCl  - reference to the socket we're going to open       
                       (argument passed by reference - clean but hidden) 
                       this socket will listen on the DHCP client port   
                       so that it can pick up bcasts on the local segmnt 
      pListenSockSrv - reference to the socket we're going to open       
                       (argument passed by reference - clean but hidden) 
                       this socket will listen on the DHCP server port   
                       so that it can pick up unicasts to the "relay"    
      listenNameSvcSock - reference to the socket we're going to open    
                       (argument passed by reference - clean but hidden) 
                       this socket will listen on the NBT name svc port  
                       so that it can pick up answers from the WINS srv  
                       We have to do this on the socket layer because on 
                       the NetBIOS layer we wouldn't notice that a name  
                       query has been resolved by bcasting.              
  Return value:                                                          
      none                                                               
--------------------------------------------------------------------------*/
HRESULT
CWinsStatusHandler::CreateListeningSockets( ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    int         nResult = 0;    // status info returned from function calls
    WSADATA     wsaData;        // WinSock startup details buffer
	DWORD	    optionValue;	// helper var for setsockopt()
    SOCKADDR_IN	sockAddr;		// struct holding source socket info

	// the event to signal listening thread to pause
	m_hPauseListening = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hPauseListening == NULL)
    {
        Trace1("WinsStatusHandler::CreateListeningSockets - CreateEvent Failed m_hPauseListening %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }
	
    //  create socket to listen to the WINS servers on the client port (same subnet)
    listenSockCl = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( listenSockCl  == INVALID_SOCKET ) 
	{
        Trace1("\nError %d creating socket to listen to WINS traffic.\n", 
														WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    optionValue = TRUE;
    if ( setsockopt(listenSockCl, SOL_SOCKET, SO_REUSEADDR, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
											WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

	optionValue = TRUE;
    if ( setsockopt(listenSockCl, SOL_SOCKET, SO_BROADCAST, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
										WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = 0;			// use any local address
    sockAddr.sin_port = htons( DHCP_CLIENT_PORT );
    RtlZeroMemory( sockAddr.sin_zero, 8 );

    if ( bind(listenSockCl, (LPSOCKADDR )&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR ) 
	{
        Trace1("\nError %d binding the listening socket.\n", 
											WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }


    //  create socket to listen to the WINS servers on the server port (remote subnet, fake relay)
    listenSockSrv = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( listenSockSrv  == INVALID_SOCKET ) 
	{
        Trace1("\nError %d creating socket to listen to DHCP traffic.\n", 
													WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    optionValue = TRUE;
    if ( setsockopt(listenSockSrv, SOL_SOCKET, SO_REUSEADDR, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
												WSAGetLastError() );
		return HRESULT_FROM_WIN32(WSAGetLastError());
    }

	optionValue = TRUE;
    if ( setsockopt(listenSockSrv, SOL_SOCKET, SO_BROADCAST, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
											WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = 0;			// use any local address
    sockAddr.sin_port = htons( DHCP_SERVR_PORT );
    RtlZeroMemory( sockAddr.sin_zero, 8 );

    if ( bind(listenSockSrv, (LPSOCKADDR )&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR ) 
	{
        Trace1("\nError %d binding the listening socket.\n", 
													WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

	
    //  create socket to listen to name svc responses from the WINS server
    listenNameSvcSock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( listenNameSvcSock  == INVALID_SOCKET ) 
	{
        Trace1("\nError %d creating socket to listen to WINS traffic.\n", WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    optionValue = TRUE;
    if ( setsockopt(listenNameSvcSock, SOL_SOCKET, SO_REUSEADDR, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
													WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

	optionValue = FALSE;
    if ( setsockopt(listenNameSvcSock, SOL_SOCKET, SO_BROADCAST, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
												WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = INADDR_ANY;
    sockAddr.sin_port = 0;
    RtlZeroMemory( sockAddr.sin_zero, 8 );

    if ( bind(listenNameSvcSock, (LPSOCKADDR )&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR ) 
	{
        Trace1("\nError %d binding the listening socket.\n", 
											WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

	return hrOK;

} 


/*---------------------------------------------------------------------------
		CWinsStatusHandler::ListeningThreadFunc( ) 
  Abstract:                                                              
      A blocking recvfrom() is sitting in an infinite loop. Whenever we  
      receive anything on our listening socket we do a quick sanity chk  
      on the packet and then increment a counter.                        
      The processing is kept minimal to spare the CPU cycles.            
  Arguments:                                                             
      pListenSock - pointer to the socket set we've opened to listen for 
                    xmits from the server                                
  Return value:                                                          
      none                                                               
---------------------------------------------------------------------------*/
DWORD WINAPI 
CWinsStatusHandler::ListeningThreadFunc( ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    SOCKADDR_IN   senderSockAddr;
	int			  nSockAddrSize = sizeof( senderSockAddr );
	int		      nBytesRcvd = 0;
    int           nSocksReady;
	char		  MsgBuf[WINS_MESSAGE_SIZE];
    int           nSockNdx;
    LPBYTE        MagicCookie;
    SOCKET        listenSock;
    fd_set        localSockSet;         // to take care of reinit for select()
	char		  szOutput[MAX_PATH];
    
    while ( TRUE ) 
	{
		// check if the thread needs to be aborted
		if (WaitForSingleObject(m_hPauseListening, 0) == WAIT_OBJECT_0)
        {
    		Trace0("CWinsStatusHandler::ListenThreadFun - going to sleep\n");

            // wait until we are woken up or the next time interval expires
		    WaitForSingleObject(m_hWaitIntervalListen, INFINITE);
    		Trace0("CWinsStatusHandler::ListenThreadFun - waking up\n");
        }

        if (WaitForSingleObject(m_hAbortListen, 0) == WAIT_OBJECT_0)
        {
            // we are going away.. break out man
    		Trace0("CWinsStatusHandler::ListenThreadFun - abort detected, bye bye\n");
            break;
        }

        // reinit the select set in every loop
        localSockSet = m_listenSockSet;

		timeval tm;
		tm.tv_sec = 5;

		// number of sockets ready
        nSocksReady = select( 0, &localSockSet, NULL, NULL, &tm );
		if ( nSocksReady == SOCKET_ERROR ) 
		{ 
            Trace1("select() failed with error %d.\n", WSAGetLastError() );
        }

	    for ( nSockNdx = 0; nSockNdx < nSocksReady; nSockNdx++ ) 
		{
            listenSock = localSockSet.fd_array[nSockNdx];

            nBytesRcvd = recvfrom( listenSock, MsgBuf, sizeof(MsgBuf), 0, (LPSOCKADDR )&senderSockAddr, &nSockAddrSize );
		    if ( nBytesRcvd == SOCKET_ERROR ) 
			{ 
                Trace1( "recvfrom() failed with error %d.\n", WSAGetLastError() );
            }

			strcpy(szOutput, (LPSTR)inet_ntoa(senderSockAddr.sin_addr));
			CString strOutput(szOutput);

            Trace2("ListeningThreadFunc(): processing frame from %s port %d \n", strOutput, ntohs(senderSockAddr.sin_port));
            
			//  process incoming WINS
            if ( (listenSock == listenNameSvcSock) && 
                 (senderSockAddr.sin_port == NBT_NAME_SERVICE_PORT) 
               ) 
            {
				strcpy(szOutput, (LPSTR)inet_ntoa(senderSockAddr.sin_addr));
				CString str(szOutput);

                Trace1("ListeningThreadFunc(): processing WINS frame from %s \n", str);
                 
               	int nCount = GetListSize();
				for ( int i=0; i < nCount ; i++) 
				{
					CServerStatus *pWinsSrvEntry = GetServer(i);

					// check if the server has been deleted in the scope pane
					if (IsServerDeleted(pWinsSrvEntry))
						continue;

					// get the iP address for the server
					DWORD dwIPAdd = pWinsSrvEntry->dwIPAddress;
					CString strIP;
					::MakeIPAddress(dwIPAdd, strIP);

                    char szBuffer[MAX_PATH] = {0};

					// convert to mbcs
                    // NOTE: this should be ACP because its being handed to a winsock call
                    WideToMBCS(strIP, szBuffer);
					
					// check if the server has been deleted in the scope pane
					if (IsServerDeleted(pWinsSrvEntry))
						continue;

					if (dwIPAdd == 0)
						strcpy(szBuffer, pWinsSrvEntry->szIPAddress);
					
					DWORD dwSrvIPAdd = inet_addr( szBuffer );

					if ( senderSockAddr.sin_addr.s_addr == dwSrvIPAdd ) 
					{
						// check if the server has been deleted in the scope pane
						if (IsServerDeleted(pWinsSrvEntry))
							continue;

						pWinsSrvEntry->dwMsgCount++;

                        struct in_addr addrStruct;
                        addrStruct.s_addr = dwSrvIPAdd;

						strcpy(szOutput, inet_ntoa(addrStruct));
						CString str(szOutput);
                        Trace1("ListeningThreadFunc(): WINS msg received from %s \n", str );

                        // notify the thread we got something
                        SetEvent(m_hAnswer);
                    }
					
                }
            }
            
        } /* END OF for() processing indicated sockets from select() */

    } /* END OF while( TRUE ) */

    return TRUE;
} 


/*---------------------------------------------------------------------------
  int CWinsHandler::Probe()  
      Assembles and sends a name query to the WINS server.               
  Arguments:                                                             
      none                                                               
  Return value:                                                          
      TRUE if a response has been received from the server               
      FALSE otherwise  
    Author: v-shubk
---------------------------------------------------------------------------*/
int 
CWinsStatusHandler::Probe( 
						CServerStatus	*pServer,
						SOCKET listenNameSvcSock 
					   )
{
    NM_FRAME_HDR       *pNbtHeader = (NM_FRAME_HDR *)pServer->nbtFrameBuf;
    NM_QUESTION_SECT   *pNbtQuestion = (NM_QUESTION_SECT *)( pServer->nbtFrameBuf + sizeof(NM_FRAME_HDR) );
    char               *pDest, *pName;
    struct sockaddr_in  destSockAddr;   // struct holding dest socket info
    int		            nBytesSent = 0;
//	char				m_szNameToQry[MAX_PATH] = "Rhino1";


    /* RFC 1002 section 4.2.12

                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         NAME_TRN_ID           |0|  0x0  |0|0|1|0|0 0|B|  0x0  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          0x0001               |           0x0000              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          0x0000               |           0x0000              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                         QUESTION_NAME                         /
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           NB (0x0020)         |        IN (0x0001)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   */
    
    pNbtHeader->xid            = NM_QRY_XID;
	pNbtHeader->flags          = NBT_NM_OPC_QUERY | 
                                 NBT_NM_OPC_REQUEST | 
                                 NBT_NM_FLG_RECURS_DESRD;
	pNbtHeader->question_cnt   = 0x0100;
	pNbtHeader->answer_cnt     = 0;
	pNbtHeader->name_serv_cnt  = 0;
	pNbtHeader->additional_cnt = 0;

    // pDest is filling nbtQuestion->q_name 
    pNbtQuestion->q_type       = NBT_NM_QTYP_NB;
    pNbtQuestion->q_class      = NBT_NM_QCLASS_IN;

    //
    //  translate the name
    //
    pDest = (char *)&(pNbtQuestion->q_name);
    pName = pServer->szServerName;
    // the first byte of the name is the length field = 2*16
    *pDest++ = NBT_NAME_SIZE;

    // step through name converting ascii to half ascii, for 32 times
    
	for ( int i = 0; i < (NBT_NAME_SIZE / 2) ; i++ ) {
        *pDest++ = (*pName >> 4) + 'A';
        *pDest++ = (*pName++ & 0x0F) + 'A';
    }
    *pDest++ = '\0';
    *pDest = '\0';

	// check if the server has been deleted in the scope pane
	if (IsServerDeleted(pServer))
		return FALSE;

	CString strIP;
	DWORD dwIPAdd = pServer->dwIPAddress;

	// even then 0 means, invalid server
	if (dwIPAdd == 0 && strcmp(pServer->szIPAddress, "") == 0)
		return FALSE;

	::MakeIPAddress(dwIPAdd, strIP);
    char szBuffer[MAX_PATH] = {0};

    // convert to mbcs
	// NOTE: this should be ACP because it is being used in a winsock call
    WideToMBCS(strIP, szBuffer);

	// if the name is not yet resolved
	if (dwIPAdd == 0)
	{
		strcpy(szBuffer, pServer->szIPAddress);
	}
	
	DWORD dwSrvIPAdd = inet_addr( szBuffer );

    //
    // send the name query frame
    // 
    destSockAddr.sin_family = PF_INET;
    destSockAddr.sin_port = NBT_NAME_SERVICE_PORT;
    destSockAddr.sin_addr.s_addr = dwSrvIPAdd;
    for (int k = 0; k < 8 ; k++ ) { destSockAddr.sin_zero[k] = 0; }

    struct in_addr addrStruct; 
    addrStruct.s_addr = dwSrvIPAdd;
    Trace1( "CWinsSrv::Probe(): sending probe Name Query to %s \n", strIP);
    
    nBytesSent = sendto( listenNameSvcSock,
                         (PCHAR )pServer->nbtFrameBuf, 
                         sizeof(NM_FRAME_HDR) + sizeof(NM_QUESTION_SECT),
                         0,
                         (struct sockaddr *)&destSockAddr,
                         sizeof( struct sockaddr )
                       );

    if ( nBytesSent == SOCKET_ERROR ) 
	{
        Trace1("CWinsSrv::Probe(): Error %d in sendto().\n", WSAGetLastError() );
    }

    //
    //  the other thread should see the incoming frame and increment dwMsgCount
    //
    WaitForSingleObject(m_hAnswer, ANSWER_TIMEOUT);

    if ( pServer->dwMsgCount == 0 ) 
		return FALSE; 
    
	return TRUE;
} /* END OF Probe() */


/*---------------------------------------------------------------------------
	CWinsStatusHandler::ExecuteMonitoring()
		Starts monitoring thread for the servers
    Author: v-shubk
----------------------------------------------------------------------------*/
DWORD WINAPI 
CWinsStatusHandler::ExecuteMonitoring()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HANDLE          hListeningThread;
	CServerStatus	*pWinsSrvEntry = NULL;
	
    //  create listening thread
    FD_ZERO( &m_listenSockSet );
	FD_SET( listenSockCl,      &m_listenSockSet );
    FD_SET( listenSockSrv,     &m_listenSockSet );
    FD_SET( listenNameSvcSock, &m_listenSockSet );
	
	m_hListenThread = CreateThread( NULL,					// handle can't be inherited
									 0,						// default stack size
									 MonThreadProc,			// thread function
									 this,					// argument to the thread function
									 0,						// start thread immediately
									 NULL
		                           );

	if (m_hListenThread == NULL ) 
	{
		Trace0("CWinsStatusHandler::ExecuteMonitoring() - Listening thread failed to start\n");
		return hrOK;
    }
	
    //  main checking loop
    while ( TRUE ) 
	{
		//  scanning the list of WINS servers
		POSITION pos;
		int nCount = GetListSize();
		m_nServersUpdated = 0;
      
        for (int i = 0; i < nCount; i++)
		{
			pWinsSrvEntry = GetServer(i);

			if (IsServerDeleted(pWinsSrvEntry))
				continue;

			UpdateStatus(i, IDS_ROOTNODE_STATUS_WORKING, ICON_IDX_SERVER_BUSY);
            NotifyMainThread();

            DWORD dwIPAdd = pWinsSrvEntry->dwIPAddress;

			// if the server is not connected, try to get the host IP address
			if (dwIPAdd == 0)
			{
				// get the server name and convert to MBCS. Get the IP for this server and try
				// to check the status
				char* dest_ip=NULL;
				char hostname[MAX_PATH] ;
				struct sockaddr_in dest;
				unsigned addr =0;

				if (IsServerDeleted(pWinsSrvEntry))
					continue;

				strcpy(hostname,pWinsSrvEntry->szServerName); 

				HOSTENT *hp = gethostbyname(hostname);
						
				if ((!hp)  && (addr == INADDR_NONE) ) 
				{ 
					CString str(hostname);
					Trace1("Unable to resolve %s \n",str);
					SetIPAddress(i, NULL);
				}    
				else if (!hp)
				{ 
					addr = inet_addr(hostname); 
					SetIPAddress(i, hostname);
				}   
				else
				{

					if (hp != NULL)   
						memcpy(&(dest.sin_addr),hp->h_addr, hp->h_length); 
					else   
						dest.sin_addr.s_addr = addr;    

					if (hp)   
						dest.sin_family = hp->h_addrtype;   
					else 
						dest.sin_family = AF_INET;  

					dest_ip = inet_ntoa(dest.sin_addr); 
					SetIPAddress(i, dest_ip);
				}
			}

			CString strIP;

			if (IsServerDeleted(pWinsSrvEntry))
				continue;

			::MakeIPAddress(pWinsSrvEntry->dwIPAddress, strIP);
         
            //  TRY to probe max 3 times
            if (pWinsSrvEntry->dwMsgCount == 0)
			{
				UINT uStatus = 0;
				UINT uImage;

				if (IsServerDeleted(pWinsSrvEntry))
					continue;

                BOOL fResponding = FALSE;

                if (pWinsSrvEntry->dwIPAddress != 0)
                {

                    for (int j = 0; j < 3; j++)
                    {
                        fResponding = Probe(pWinsSrvEntry, listenNameSvcSock);
                        if (fResponding)
                            break;

				        if (FCheckForAbort())
				        {
					        // we are going away.. break out man
    				        Trace0("CWinsStatusHandler::ExecuteMonitoring() - abort detected, bye bye \n");
					        break;
				        }
                    }
                }

				// check to see if we need to clear out 
				if (FCheckForAbort())
				{
					// we are going away.. break out man
    				Trace0("CWinsStatusHandler::ExecuteMonitoring() - abort detected, bye bye \n");
					break;
				}

                if (!fResponding)
				{
					Trace1("Status is DOWN for the server %s \n", strIP);
					uStatus = IDS_ROOTNODE_STATUS_DOWN;
					uImage = ICON_IDX_SERVER_LOST_CONNECTION;
				}
				else
				{
					Trace1("Status is UP for the server %s \n", strIP);
					uStatus = IDS_ROOTNODE_STATUS_UP;
					uImage = ICON_IDX_SERVER_CONNECTED;
				}

				if (IsServerDeleted(pWinsSrvEntry))
					continue;

				UpdateStatus(i, uStatus, uImage);
				m_nServersUpdated++;

                // update the last checked time
                pWinsSrvEntry->m_timeLast = CTime::GetCurrentTime();

                NotifyMainThread();
			}
            else
			{
				Trace2( "%d WINS msg from server %s - zeroing counter\n", 
                        pWinsSrvEntry->dwMsgCount, strIP);

				if (IsServerDeleted(pWinsSrvEntry))
					continue;

                pWinsSrvEntry->dwMsgCount = 0;
                
			}

            pWinsSrvEntry->dwMsgCount = 0;

		}
		
        // tell the listening thread to go to sleep
        SetEvent(m_hPauseListening);
		m_nServersUpdated = 0;
			
        // wait for the next interval or if we are triggered
   	    Trace1("CWinsStatusHandler::ExecuteMonitoring() - going to sleep for %d \n", m_dwUpdateInterval);
        WaitForSingleObject(m_hWaitIntervalMain, m_dwUpdateInterval);
   	    Trace0("CWinsStatusHandler::ExecuteMonitoring() - waking up\n");

        // wake up the listening thread
        SetEvent(m_hWaitIntervalListen);

        if (FCheckForAbort())
        {
            // we are going away.. break out man
    	    Trace0("CWinsStatusHandler::ExecuteMonitoring() - abort detected, bye bye \n");
            break;
        }
    } 

    return TRUE;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::CloseSockets
		Closes all the socket connections that were opened
	Author: v-shubk
---------------------------------------------------------------------------*/
BOOL
CWinsStatusHandler::FCheckForAbort()
{
	BOOL fAbort = FALSE;

    if (WaitForSingleObject(m_hAbortMain, 0) == WAIT_OBJECT_0)
    {
        // we are going away.. break out man
        fAbort = TRUE;
    }

	return fAbort;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::CloseSockets
		Closes all the socket connections that were opened
	Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::CloseSockets()
{
	//	final clean up
    if (closesocket(listenSockCl) == SOCKET_ERROR) 
	{
	    Trace1("closesocket(listenSockCl) failed with error %d.\n", WSAGetLastError());
    }
    
    if (closesocket(listenSockSrv) == SOCKET_ERROR) 
	{
	    Trace1("closesocket(listenSockSrv) failed with error %d.\n", WSAGetLastError());
    }

	if (closesocket(listenNameSvcSock) == SOCKET_ERROR)
	{
		Trace1("closesocket(listenNameSvcSock) failed with error %d \n", WSAGetLastError());
	}

    // we're going away...
    Trace0("CWinsStatusHandler::CloseSockets() - Setting abort event.\n");
    SetEvent(m_hAbortListen);
    SetEvent(m_hAbortMain);

    // wake everybody up
    Trace0("CWinsStatusHandler::CloseSockets() - waking up threads.\n");
    SetEvent(m_hWaitIntervalListen);
    SetEvent(m_hWaitIntervalMain);
    SetEvent(m_hAnswer);

    // terminate the threads
	if (m_hListenThread)
	{
        if (WaitForSingleObject(m_hListenThread, 5000) != WAIT_OBJECT_0)
        {
            Trace0("CWinsStatusHandler::CloseSockets() - ListenThread failed to cleanup!\n");
        }

        ::CloseHandle(m_hListenThread);
		m_hListenThread = NULL;
	}

	if (m_hMainMonThread)
	{
        if (WaitForSingleObject(m_hMainMonThread, 5000) != WAIT_OBJECT_0)
        {
            Trace0("CWinsStatusHandler::CloseSockets() - MainMonThread failed to cleanup!\n");
        }

		::CloseHandle(m_hMainMonThread);
		m_hMainMonThread = NULL;   
	}

    // clean up our events
	if (m_hPauseListening)
	{
		::CloseHandle(m_hPauseListening);
		m_hPauseListening = NULL;
	}

	if (m_hAbortListen)
	{
		::CloseHandle(m_hAbortListen);
		m_hAbortListen = NULL;
	}
	
	if (m_hAbortMain)
	{
		::CloseHandle(m_hAbortMain);
		m_hAbortMain = NULL;
	}

    if (m_hWaitIntervalListen)
	{
		::CloseHandle(m_hWaitIntervalListen);
		m_hWaitIntervalListen = NULL;
	}

    if (m_hWaitIntervalMain)
	{
		::CloseHandle(m_hWaitIntervalMain);
		m_hWaitIntervalMain = NULL;
	}

    if (m_hAnswer)
	{
		::CloseHandle(m_hAnswer);
		m_hAnswer = NULL;
	}
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::CreateNodes(ITFSNode *pNode)
		Displays the result pane nodes for the servers
    Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsStatusHandler::CreateNodes(ITFSNode *pNode)
{
	HRESULT hr = hrOK;
	POSITION pos = NULL;

	int nCount = (int)m_listServers.GetSize();

	for(int i = 0; i < nCount; i++)
	{
		SPITFSNode spStatLeaf;

		CServerStatus *pWinsSrvEntry = m_listServers.GetAt(i);
		
		CreateLeafTFSNode(&spStatLeaf,
						  &GUID_WinsServerStatusLeafNodeType,
						  pWinsSrvEntry, 
						  pWinsSrvEntry,
						  m_spNodeMgr);

		// Tell the handler to initialize any specific data
		pWinsSrvEntry->InitializeNode((ITFSNode *) spStatLeaf);

		// Add the node as a child to the Active Leases container
		pNode->AddChild(spStatLeaf);
		
		pWinsSrvEntry->Release();
	}
	return hr;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::UpdateStatusColumn(ITFSNode *pNode)
		Updates the status column of the servers in the result pane
    Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::UpdateStatusColumn(ITFSNode *pNode)
{
	HRESULT hr = hrOK;

	// enumerate thro' all the nodes
	SPITFSNodeEnum spNodeEnum;
	SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;
	BOOL bFound = FALSE;

	// get the enumerator for this node
	pNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	
	while (nNumReturned)
	{
		CServerStatus * pStat = GETHANDLER(CServerStatus, spCurrentNode);

		spCurrentNode->SetData(TFS_DATA_IMAGEINDEX, pStat->m_uImage);
		spCurrentNode->SetData(TFS_DATA_OPENIMAGEINDEX, pStat->m_uImage);

		// fillup the status column
		spCurrentNode->ChangeNode(RESULT_PANE_CHANGE_ITEM);

		// get the next Server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::AddNode(ITFSNode *pNode, CWinsServerHandler *pServer)
		Adds a node to the result pane, used when a new server is added to 
		tree that has to be reflected for the status node
    Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsStatusHandler::AddNode(ITFSNode *pNode, CWinsServerHandler *pServer)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = hrOK;
	CServerStatus* pServ = NULL;
    char	szBuffer[MAX_PATH] = {0};
	SPITFSNode spStatLeaf;

    // if we haven't been expanded, don't add now.  Will get done
    // when we are expanded.
    if (!m_bExpanded)
        return hr;

	// add to the list
    // NOTE: this should be ACP because it's being used through winsock
    CString strTemp = pServer->GetServerAddress();
    WideToMBCS(strTemp, szBuffer);

	// check if the server already exists, if so, just change the 
	// state stored to SERVER_ADDED and change the variables
	// appropriately
	if ((pServ = GetExistingServer(szBuffer)) == NULL)
	{
		pServ = new CServerStatus(m_spTFSCompData);
		strcpy(pServ->szServerName, szBuffer);
		AddServer(pServ);
	}
	else
	{
		// just add the related data to the CServerStatus and add the node
		// to the UI
		strcpy(pServ->szServerName, szBuffer);
		// set the flag to SERVER_ADDED
		MarkAsDeleted(szBuffer, FALSE);
	}

	pServ->dwIPAddress = pServer->GetServerIP();
	pServ->dwMsgCount = 0;
	strcpy(pServ->szIPAddress, "");

	// create the new node here
	CreateLeafTFSNode(&spStatLeaf,
					  &GUID_WinsServerStatusLeafNodeType,
					  pServ, 
					  pServ,
					  m_spNodeMgr);

	// Tell the handler to initialize any specific data
	pServ->InitializeNode((ITFSNode *) spStatLeaf);

	// Add the node as a child to the Active Leases container
	pNode->AddChild(spStatLeaf);
	
	pServ->Release();

	spStatLeaf->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
	pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM);

	return hr;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::DeleteNode(ITFSNode *pNode, 
								CWinsServerHandler *pServer)
		Removes the particular server from tehresult pane
    Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsStatusHandler::DeleteNode(ITFSNode *pNode, CWinsServerHandler *pServer)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = hrOK;
	CServerStatus* pServ = NULL;
	char	szBuffer[MAX_PATH];
	SPITFSNode spStatLeaf;

	// loop thro' the status nodes and set the flag to deleted so that this 
	// server is not seen in the result pane

	SPITFSNodeEnum			spNodeEnum;
	SPITFSNode				spCurrentNode;
	ULONG					nNumReturned = 0;

	// get the enumerator
	pNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

	while (nNumReturned)
	{
		char szBuffer[MAX_PATH];

		// iterate thro' all the nodes and get the one that matches the 
		// current server
		CServerStatus * pStat = GETHANDLER(CServerStatus, spCurrentNode);

		// convert to ANSI
        CString strTemp = pServer->GetServerAddress();
        WideToMBCS(strTemp, szBuffer);

		// if found
		if (_stricmp(szBuffer, pStat->szServerName) == 0)
		{
			// mark as deleted and break
			MarkAsDeleted(szBuffer, TRUE);
				
			// remove this node
			spCurrentNode->SetVisibilityState(TFS_VIS_HIDE);
				
			spCurrentNode->ChangeNode(RESULT_PANE_DELETE_ITEM);

			// do the cleanup and break
			//spCurrentNode.Release();

			//break;
		}

		// get the next server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	return hr;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::StartMonitoring
		Spawns off the monitoring thread
	Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::StartMonitoring(ITFSNode *pNode)
{
	HRESULT hr = hrOK;

	// create the sockets, they need to be closed at the end
	hr = CreateListeningSockets();

	if (hr != hrOK)
	{
		Trace0("CWinsStatusHandler::StartMonitoring, Initializing the sockets failed\n");
		// no point continuing
		return;
	}

	m_hMainMonThread = CreateThread(NULL,
									0,
									MainMonThread,
									this,
									0,
									NULL
									);

	if (m_hMainMonThread == NULL)
	{
		Trace0("CWinsStatusHandler:: Main Monitoring thread failed to start\n");
		return;
	}

}


/*---------------------------------------------------------------------------
    CWinsStatusHandler::GetServer(int i)
		Returns the Server given the index
    Author: v-shubk
---------------------------------------------------------------------------*/
CServerStatus*
CWinsStatusHandler::GetServer(int i)
{
	CSingleLock sl(&m_cs);
	sl.Lock();

	return m_listServers.GetAt(i);
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::AddServer(CServerStatus* pServer)
		Adds a server to the array maintained
    Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::AddServer(CServerStatus* pServer)
{
	CSingleLock		sl(&m_cs);
	sl.Lock();

	m_listServers.Add(pServer);
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::RemoveServer(int i)
		Removes a server from the array
    Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::RemoveServer(int i)
{
	CSingleLock		sl(&m_cs);
	sl.Lock();

	m_listServers.RemoveAt(i);
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::UpdateStatus(UINT nID, int i)
		Upadtes the status string for the server
    Author: v-shubk
---------------------------------------------------------------------------*/
void
CWinsStatusHandler::UpdateStatus(int nIndex, UINT uStatusId, UINT uImage)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CSingleLock		sl(&m_cs);
	sl.Lock();

	CServerStatus *pStat = m_listServers.GetAt(nIndex);

	pStat->m_strStatus.LoadString(uStatusId);
	pStat->m_uImage = uImage;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::GetListSize()
		Retruns the number of elements in the array
    Author: v-shubk
---------------------------------------------------------------------------*/
int 
CWinsStatusHandler::GetListSize()
{
	CSingleLock		sl(&m_cs);
	sl.Lock();

	return (int)m_listServers.GetSize();
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::SetIPAddress(int i, LPSTR szIP)
		Sets the iP Address of the server, this is the case when the server
		is added with Do not connect option, but we still need to update the 
		status
    Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::SetIPAddress(int i, LPSTR szIP)
{
	CSingleLock		sl(&m_cs);
	sl.Lock();

	CServerStatus *pStat = m_listServers.GetAt(i);

	strcpy(pStat->szIPAddress, szIP);

}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::MarkAsDeleted(LPSTR szBuffer, BOOL bDelete)
		Marks the flag to DELETED if bDelete is TRUE, else to ADDED
		All the servers with the flag DELETED set are not processed
		and are not shown in the UI.
    Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::MarkAsDeleted(LPSTR szBuffer, BOOL bDelete)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CSingleLock		sl(&m_cs);
	sl.Lock();

	int				nCount = 0;
	CServerStatus	*pStat = NULL;

	// get the list of the servers maintained
	nCount = (int)m_listServers.GetSize();

	for(int i = 0; i < nCount; i++)
	{
		pStat = m_listServers.GetAt(i);

		if (_stricmp(szBuffer, pStat->szServerName) == 0)
		{
			// set the deleted flag
			if (bDelete)
				pStat->dwState = SERVER_DELETED;
			else
				pStat->dwState = SERVER_ADDED;
			break;
		}
	}

	return;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::GetExistingServer(LPSTR szBuffer)	
		Gets the pointer to the existing server in the array
		This function is useful when the server is deletd and again added back 
		to the scope tree.
    Author: v-shubk
----------------------------------------------------------------------------*/
CServerStatus *
CWinsStatusHandler::GetExistingServer(LPSTR szBuffer)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CSingleLock		sl(&m_cs);
	sl.Lock();

	int					nCount = 0;
	CServerStatus		*pStat = NULL;

	for(int i = 0; i < nCount; i++)
	{
		pStat = m_listServers.GetAt(i);

		if (_strcmpi(pStat->szServerName, szBuffer) == 0)
			return pStat;
	}

	return NULL;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::IsServerDeleted(CServerStatus *pStat)
		Checks if a server has been deleted, such servers
		sre not considered for monitoring
    Author: v-shubk
---------------------------------------------------------------------------*/
BOOL 
CWinsStatusHandler::IsServerDeleted(CServerStatus *pStat)
{
	return (pStat->dwState == SERVER_DELETED) ? TRUE : FALSE;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::NotifyMainThread()
        Description
    Author: EricDav
---------------------------------------------------------------------------*/
void
CWinsStatusHandler::NotifyMainThread()
{
    if (!m_uMsgBase)
    {
	    m_uMsgBase = (INT) ::SendMessage(m_spTFSCompData->GetHiddenWnd(), WM_HIDDENWND_REGISTER, TRUE, 0);
    }

    ::PostMessage(m_spTFSCompData->GetHiddenWnd(), 
                  m_uMsgBase + WM_HIDDENWND_INDEX_HAVEDATA,
				 (WPARAM)(ITFSThreadHandler *)this, 
                 NULL);
}


// listening thread for the main monitoring thread
DWORD WINAPI 
MonThreadProc(LPVOID pParam)
{
    DWORD dwReturn;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        CWinsStatusHandler * pWinsStatus = (CWinsStatusHandler *) pParam;
	    
        Trace0("MonThreadProc - Thread started.\n");

        dwReturn = pWinsStatus->ListeningThreadFunc();

        Trace0("MonThreadProc - Thread ending.\n");
    }
    COM_PROTECT_CATCH

    return dwReturn;
}


// main monitoring thread
DWORD WINAPI MainMonThread(LPVOID pParam)
{
    DWORD dwReturn;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        CWinsStatusHandler * pWinsStatus = (CWinsStatusHandler *) pParam;
	    
        Trace0("MainMonThread - Thread started.\n");

        dwReturn = pWinsStatus->ExecuteMonitoring();

        Trace0("MainMonThread - Thread ending.\n");
    }
    COM_PROTECT_CATCH

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\svrstats.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ServStat.cpp
		The server statistics dialog
		
    FILE HISTORY:
        
*/

#include <afx.h>
#include "dbgutil.h"
#include "stdafx.h"
#include "winssnap.h"
#include "server.h"
#include "resource.h"
#include "svrstats.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define INTLTIMESTR(time) (((CIntlTime)(time)).CIntlTime::operator const CString())
#define TMST1(x) INTLTIMESTR((m_wrResults).WinsStat.TimeStamps.x)
#define INTLNUMSTR(num) (((CIntlNumber)(num)).CIntlNumber::operator const CString())
#define TCTR(x) INTLNUMSTR((m_wrResults).WinsStat.Counters.x)

#define STATMUTEXNAME       _T("WINSADMNGETSTATISTICS")
#define WM_UPDATE_STATS     WM_USER + 1099

enum 
{
    SERVER_STAT_START_TIME = 0,
	SERVER_STAT_DB_INIT_TIME,
    SERVER_STAT_STAT_CLEAR_TIME,
	SERVER_STAT_BLANK0,
    SERVER_STAT_LAST_PERIODIC_REP,
    SERVER_STAT_LAST_ADMIN_REP,
    SERVER_STAT_LAST_NET_UPDATE_REP,
    SERVER_STAT_LAST_ADDRESS_CHANGE_REP,
	SERVER_STAT_BLANK1,
    SERVER_STAT_TOTAL_QUERIES,
    SERVER_STAT_SUCCESSFUL_QUERRIES,
    SERVER_STAT_FAILED_QUERRIES,
	SERVER_STAT_BLANK2,
    SERVER_STAT_TOTAL_RELEASES,
    SERVER_STAT_SUCCESSFUL_RELEASES,
    SERVER_STAT_FAILED_RELEASES,
	SERVER_STAT_BLANK3,
    SERVER_STAT_UNIQUE_REGISTRATIONS,
    SERVER_STAT_UNIQUE_CONFLICTS,
    SERVER_STAT_UNIQUE_RENEWALS,
	SERVER_STAT_BLANK4,
    SERVER_STAT_GROUP_REGISTRATIONS,
    SERVER_STAT_GROUP_CONFLICTS,
    SERVER_STAT_GROUP_RENEWALS,
	SERVER_STAT_BLANK5,
    SERVER_STAT_TOTAL_REG,
	SERVER_STAT_BLANK6,
    SERVER_STAT_LAST_PERIODIC_SCAV,
    SERVER_STAT_LAST_ADMIN_SCAV,
    SERVER_STAT_LAST_EXTINCTION_SCAV,
    SERVER_STAT_LAST_VERIFICATION_SCAV,
	SERVER_STAT_BLANK7,
    SERVER_STAT_PARTNERS_HEADER,
	SERVER_STAT_MAX
};


/*---------------------------------------------------------------------------
	CServerStatsFrame implementation
 ---------------------------------------------------------------------------*/
const ContainerColumnInfo s_rgServerStatsColumnInfo[] =
{
	{ IDS_SERVER_STATS_START_TIME,					0,		TRUE },
	{ IDS_SERVER_STATS_DB_INIT_TIME,   				0,		TRUE },
	{ IDS_SERVER_STATS_LAST_CLEAR_TIME,   			0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_LAST_PREP,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_AREP,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_NREP,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_ACREP,   		        0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_TOTAL_QUERRIES,   	        0,		TRUE },
	{ IDS_SERVER_STATS_SUCCESSFUL,   			    0,		TRUE },
	{ IDS_SERVER_STATS_FAILED,   				    0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_TOTAL_RELEASES,   	        0,		TRUE },
	{ IDS_SERVER_STATS_SUCCESSFUL,   			    0,		TRUE },
	{ IDS_SERVER_STATS_FAILED,   				    0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_UNIQUE_REGISTRATIONS,   	    0,		TRUE },
	{ IDS_SERVER_STATS_CONFLICTS,   			    0,		TRUE },
	{ IDS_SERVER_STATS_RENEWALS,   				    0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_GROUP_REGISTRATIONS,   	    0,		TRUE },
	{ IDS_SERVER_STATS_CONFLICTS,   			    0,		TRUE },
	{ IDS_SERVER_STATS_RENEWALS,   				    0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_TOTAL_REGISTRATIONS,			0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_LAST_PSCAV,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_ASCAV,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_ESCAV,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_VSCAV,   		        0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_PARTNERS_HEADER,				0,		TRUE },
};

UINT _cdecl
RefreshStatsThread(LPVOID pParam)
{
    DWORD           dw;
	ThreadInfo *    pInfo = (ThreadInfo *)(pParam);
    HANDLE          hmutStatistics = NULL;
    HRESULT         hr = hrOK;

    COM_PROTECT_TRY
    {
        // Open the existing mutex
        while (hmutStatistics == NULL)
        {
            if ((hmutStatistics = ::OpenMutex(SYNCHRONIZE, FALSE, STATMUTEXNAME)) == NULL)
            {
                ::Sleep(2000L);
            }
        }

        // This is where the work gets done
        for (;;)
        {
		    pInfo->dwInterval = pInfo->pDlg->GetRefreshInterval();

            //::Sleep((pInfo->dwInterval)*1000);
            if (::WaitForSingleObject(pInfo->pDlg->m_hAbortEvent, (pInfo->dwInterval) * 1000) == WAIT_OBJECT_0)
            {
                // we're going away, lets get outta here
                break;
            }

            // Wait until we get the go ahead
            dw = ::WaitForSingleObject(hmutStatistics, INFINITE);
            if (dw == WAIT_OBJECT_0)
            {
			    dw = pInfo->pDlg->GetStats();
                if (dw == ERROR_SUCCESS)
                {
                    PostMessage(pInfo->pDlg->GetSafeHwnd(), WM_UPDATE_STATS, 0, 0);
                }

                ::ReleaseMutex(hmutStatistics);
            }
        }

        delete pInfo;
    }
    COM_PROTECT_CATCH

    return 0;
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::CServerStatsFrame()
		Constructor
---------------------------------------------------------------------------*/
CServerStatsFrame::CServerStatsFrame()
	: StatsDialog(STATSDLG_VERTICAL|STATSDLG_CLEAR)
{
    SetColumnInfo(s_rgServerStatsColumnInfo,
				  DimensionOf(s_rgServerStatsColumnInfo));

    m_hmutStatistics = NULL;
    m_hAbortEvent = NULL;
    m_pRefreshThread = NULL;

    ZeroMemory(&m_wrResults, sizeof(m_wrResults));
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::CServerStatsFrame()
		Destructor
---------------------------------------------------------------------------*/
CServerStatsFrame::~CServerStatsFrame()
{
}


BEGIN_MESSAGE_MAP(CServerStatsFrame, StatsDialog)
	//{{AFX_MSG_MAP(CServerStatistics)
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_NEW_STATS_AVAILABLE, OnNewStatsAvailable)
    ON_MESSAGE(WM_UPDATE_STATS, OnUpdateStats)
	ON_BN_CLICKED(IDC_STATSDLG_BTN_CLEAR, OnClear)
	ON_WM_DESTROY()
END_MESSAGE_MAP()

/*---------------------------------------------------------------------------
	CServerStatsFrame::CServerStatsFrame()
		Gets the statistics from the server handler and updates the 
		internal variable m_wrResults
---------------------------------------------------------------------------*/
HRESULT CServerStatsFrame::RefreshData(BOOL fGrabNewData)
{
    if (fGrabNewData)
    {
	    DWORD dwError = 0;

        BEGIN_WAIT_CURSOR;
        dwError = GetStats();
        END_WAIT_CURSOR;
    
        if (dwError != ERROR_SUCCESS)
	    {
		    WinsMessageBox(dwError);
	    }
		else
		{
            UpdateWindow(&m_wrResults);
        }
    }

    return hrOK;
}

DWORD CServerStatsFrame::GetStats()
{
    DWORD                dwError = 0;
	SPITFSNode           spNode;
	PWINSINTF_RESULTS_T  pResults = NULL;
	CWinsServerHandler * pServer;

	pServer = GETHANDLER(CWinsServerHandler, m_spNode);
	
    dwError = pServer->GetStatistics(m_spNode, &pResults);
    if (dwError == ERROR_SUCCESS)
    {
    	m_wrResults = *(pResults);
    }

    return dwError;
}


BOOL CServerStatsFrame::OnInitDialog()
{
	CString	st;
    BOOL bRet;

    AfxFormatString1(st, IDS_SERVER_STATS_TITLE, m_strServerAddress);

    SetWindowText((LPCTSTR) st);
	
    bRet = StatsDialog::OnInitDialog();

	// add the blank column because the replication partner stats need them
	m_listCtrl.InsertColumn(2, _T("            "), LVCFMT_LEFT, 100);

    // Set the default column widths to the width of the widest column
    SetColumnWidths(2 /* Number of Columns */);

    UpdateWindow(&m_wrResults);

    // set the default window size
    RECT rect;
    GetWindowRect(&rect);

	int nWidth = 0;
    for (int i = 0; i < 3; i++)
	{
		nWidth += m_listCtrl.GetColumnWidth(i);	
	}

	SetWindowPos(NULL, rect.left, rect.top, nWidth + 20, SERVER_STATS_DEFAULT_HEIGHT, SWP_SHOWWINDOW);

	if ((m_hmutStatistics = ::CreateMutex(NULL, FALSE, STATMUTEXNAME)) == NULL)
    {
        Trace1("CServerStatsFrame::OnInitDialog() - CreateMutex failed! %lx\n", GetLastError());
        return FALSE;
    }

    if ((m_hAbortEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
    {
        Trace1("CServerStatsFrame::OnInitDialog() - CreateEvent failed! %lx\n", GetLastError());
        return FALSE;
    }

    StartRefresherThread();

    return bRet;
}


void CServerStatsFrame::Sort(UINT nColumnId)
{
    // we don't sort any of our stats
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::OnNewStatsAvailable(UINT wParam, LONG lParam)
		called in response to the message ON_NEW_STATS_AVAILABLE
    Author: EricDav
---------------------------------------------------------------------------*/
afx_msg long 
CServerStatsFrame::OnNewStatsAvailable(UINT wParam, LONG lParam)
{
    DWORD dwErr = GetStats();
    if (dwErr == ERROR_SUCCESS)
    {
        UpdateWindow(&m_wrResults);
    }
    else
    {
        WinsMessageBox(dwErr);
    }

    return 0;
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::OnNewStatsAvailable(UINT wParam, LONG lParam)
		called in response to the message WM_UPDATE_STATS
        The background thread updates the stats, now we need to update
        the UI on the correct thread.
    Author: EricDav
---------------------------------------------------------------------------*/
afx_msg long 
CServerStatsFrame::OnUpdateStats(UINT wParam, LONG lParam)
{
    UpdateWindow(&m_wrResults);

    return 0;
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::UpdateWindow(PWINSINTF_RESULTS_T  pwrResults)
		Updates the contents of the dialog
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::UpdateWindow(PWINSINTF_RESULTS_T  pwrResults)
{

	SPITFSNode    spNode;
    CWinsServerHandler * pServer;

	CString str;

    UINT i;
    int nTotalAddresses = 0, nTotalInUse = 0, nTotalAvailable = 0;
   
	// now fill in the data
    for (i = 0; i < SERVER_STAT_MAX; i++)
	{
        if (!pwrResults)
            str = _T("---");
        else
        {
            switch (i)
		    {
                // server stsrt time
                case SERVER_STAT_START_TIME:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.WinsStartTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.WinsStartTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

				// database initialized time
                case SERVER_STAT_DB_INIT_TIME:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastInitDbTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastInitDbTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
	            	break;
				
				// statistics last cleared time
				case SERVER_STAT_STAT_CLEAR_TIME:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.CounterResetTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.CounterResetTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                	break;

                // some blank lines in between
				case SERVER_STAT_BLANK0:
				case SERVER_STAT_BLANK1:
				case SERVER_STAT_BLANK2:
				case SERVER_STAT_BLANK3:
				case SERVER_STAT_BLANK4:
				case SERVER_STAT_BLANK5:
				case SERVER_STAT_BLANK6:
				case SERVER_STAT_BLANK7:
					str = _T("");
                    break;
                
                case SERVER_STAT_LAST_PERIODIC_REP:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastPRplTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastPRplTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;
                
                case SERVER_STAT_LAST_ADMIN_REP:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastATRplTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastATRplTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

                case SERVER_STAT_LAST_NET_UPDATE_REP:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastNTRplTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastNTRplTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;
                
                // last address changed time
                case SERVER_STAT_LAST_ADDRESS_CHANGE_REP:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastACTRplTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastACTRplTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
	                break;
                
				// total queries received
                case SERVER_STAT_TOTAL_QUERIES:
	                str = TCTR(NoOfQueries);
                    break;

				// successful queries
                case SERVER_STAT_SUCCESSFUL_QUERRIES:
	                str = TCTR(NoOfSuccQueries);
                    break;

				// Queries that failed
                case SERVER_STAT_FAILED_QUERRIES:
	                str = TCTR(NoOfFailQueries);
                    break;
                
                case SERVER_STAT_TOTAL_RELEASES:
                    str = TCTR(NoOfRel);
                    break;
                
                case SERVER_STAT_SUCCESSFUL_RELEASES:
                    str = TCTR(NoOfSuccRel);
                    break;
                
                case SERVER_STAT_FAILED_RELEASES:
                    str = TCTR(NoOfFailRel);
                    break;

    			// unique registrations
                case SERVER_STAT_UNIQUE_REGISTRATIONS:
                    str = TCTR(NoOfUniqueReg);
                    break;

                case SERVER_STAT_UNIQUE_CONFLICTS:
                    str = TCTR(NoOfUniqueCnf);
                    break;

                case SERVER_STAT_UNIQUE_RENEWALS:
                    str = TCTR(NoOfUniqueRef);
                    break;

				// group registrations
                case SERVER_STAT_GROUP_REGISTRATIONS:
            	    str = TCTR(NoOfGroupReg);
                    break;

                case SERVER_STAT_GROUP_CONFLICTS:
            	    str = TCTR(NoOfGroupCnf);
                    break;

                case SERVER_STAT_GROUP_RENEWALS:
            	    str = TCTR(NoOfGroupRef);
                    break;
				
                // total registrations
				case SERVER_STAT_TOTAL_REG:
	               str = INTLNUMSTR(m_wrResults.WinsStat.Counters.NoOfGroupReg + 
									m_wrResults.WinsStat.Counters.NoOfUniqueReg);
                    break;

                case SERVER_STAT_LAST_PERIODIC_SCAV:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastPScvTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastPScvTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

                case SERVER_STAT_LAST_ADMIN_SCAV:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastATScvTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastATScvTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

                case SERVER_STAT_LAST_EXTINCTION_SCAV:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastTombScvTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastTombScvTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

                case SERVER_STAT_LAST_VERIFICATION_SCAV:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastVerifyScvTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastVerifyScvTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

                case SERVER_STAT_PARTNERS_HEADER:
					{
						str.LoadString(IDS_SERVER_STATS_NO_OF_FAILED);
						m_listCtrl.SetItemText(i, 2, (LPCTSTR) str);

						str.LoadString(IDS_SERVER_STATS_NO_OF_REPLS);
					}
					break;

                default:
                    Assert("Invalid server statistic type!");
                    break;
		    }
        }

		// now the string is set, display in the dlg
		m_listCtrl.SetItemText(i, 1, (LPCTSTR) str);
	}

	UpdatePartnerStats();
}


/*---------------------------------------------------------------------------
	CServerStatsFrame::StartRefresherThread()
		Starts the refresher thread, called as soon as the dilog is 
		brought up
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::StartRefresherThread()
{
	ThreadInfo *info = new ThreadInfo;

	CWinsServerHandler * pServer;
	pServer = GETHANDLER(CWinsServerHandler, m_spNode);
	
	info->dwInterval = pServer->m_dwRefreshInterval;
	info->pDlg = this;

    m_pRefreshThread = ::AfxBeginThread(RefreshStatsThread, info);
	
	if (m_pRefreshThread == NULL)
    {
        Trace0("Failed to create thread\n");
        m_pRefreshThread = NULL;
        return;
    }

    Trace0("Auto refresh thread succesfully started\n");

}


/*---------------------------------------------------------------------------
	CServerStatsFrame::ReInitRefresherThread()
		If the refresher thread was running, re-start it. It is needed
        in order to pick on the fly the new refresh intervals
---------------------------------------------------------------------------*/
void
CServerStatsFrame::ReInitRefresherThread()
{
    // if there is a refresher thread, just restart it
    if (m_pRefreshThread != NULL)
    {
        KillRefresherThread();
        StartRefresherThread();
    }
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::KillRefresherThread()
		Kills the refresh data thread, caled when the dlg is destroyed
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::KillRefresherThread()
{
    //
    // Kill refresher thread if necessary.
    //
    if (m_pRefreshThread == NULL)
    {
        //
        // No thread running
        //
        return;
    }

    //::TerminateThread(m_pRefreshThread->m_hThread, 0);
    //::CloseHandle(m_pRefreshThread->m_hThread);
    ::SetEvent(m_hAbortEvent);
    ::WaitForSingleObject(m_pRefreshThread->m_hThread, 5000);
    
    m_pRefreshThread = NULL;
}


/*---------------------------------------------------------------------------
	CServerStatsFrame::OnDestroy( )
		Message Handler
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::OnDestroy( )
{
	KillRefresherThread();

    if (m_hmutStatistics)
    {
        ::CloseHandle(m_hmutStatistics);
        m_hmutStatistics = NULL;
    }

    if (m_hAbortEvent)
    {
        ::CloseHandle(m_hAbortEvent);
        m_hAbortEvent = NULL;
    }

}


/*---------------------------------------------------------------------------
	CServerStatsFrame::GetRefreshInterval()
	 Returns the refresh interval, stored in the server handler
---------------------------------------------------------------------------*/
DWORD
CServerStatsFrame::GetRefreshInterval()
{
	CWinsServerHandler * pServer;
	pServer = GETHANDLER(CWinsServerHandler, m_spNode);
	
	return pServer->m_dwRefreshInterval;

}


/*---------------------------------------------------------------------------
	CServerStatsFrame::OnClear()
		Calls the wins api to reset counters and updates data, in response to 
		click of the clear button
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::OnClear()
{
    DWORD dwErr = ERROR_SUCCESS;
    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, m_spNode);

	// clear the ststistics
	BEGIN_WAIT_CURSOR
	dwErr = pServer->ClearStatistics(m_spNode);
	END_WAIT_CURSOR

    if (dwErr == ERROR_SUCCESS)
    {
        // refresh the data now
	    RefreshData(TRUE);

	    UpdateWindow(&m_wrResults);
    }
    else
    {
        WinsMessageBox(dwErr);
    }
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::UpdatePartnerStats()
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::UpdatePartnerStats()
{
	UINT i, uCount;
	CString strText;

	// first remove all old partner info
	uCount = m_listCtrl.GetItemCount();
	for (i = 0; i < (uCount - SERVER_STAT_MAX); i++)
	{
		m_listCtrl.DeleteItem(SERVER_STAT_MAX);
	}

	int nPartner = 0;

	// now add all of the partner information in
	for (i = SERVER_STAT_MAX; i < SERVER_STAT_MAX + m_wrResults.WinsStat.NoOfPnrs; i++)
	{
		m_listCtrl.InsertItem(i, _T(""));

		// ip address
		::MakeIPAddress(m_wrResults.WinsStat.pRplPnrs[nPartner].Add.IPAdd, strText);
		m_listCtrl.SetItemText(i, 0, strText);

		// replication count
		strText.Format(_T("%d"), m_wrResults.WinsStat.pRplPnrs[nPartner].NoOfRpls);
		m_listCtrl.SetItemText(i, 1, strText);

		// failed count
		strText.Format(_T("%d"), m_wrResults.WinsStat.pRplPnrs[nPartner].NoOfCommFails);
		m_listCtrl.SetItemText(i, 2, strText);

		nPartner++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\vrfysrv.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    vrfysrv.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "winssnap.h"
#include "VrfySrv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVerifyWins dialog


CVerifyWins::CVerifyWins(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CVerifyWins::IDD, pParent), m_fCancelPressed(FALSE)
{
	//{{AFX_DATA_INIT(CVerifyWins)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

//	Create(CVerifyWins::IDD, pParent);
}


void CVerifyWins::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVerifyWins)
	DDX_Control(pDX, IDCANCEL, m_buttonCancel);
	DDX_Control(pDX, IDC_STATIC_SERVERNAME, m_staticServerName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVerifyWins, CBaseDialog)
	//{{AFX_MSG_MAP(CVerifyWins)
	ON_WM_SETCURSOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVerifyWins message handlers

void CVerifyWins::OnCancel() 
{
	// TODO: Add extra cleanup here
	m_fCancelPressed = TRUE;
	//CBaseDialog::OnCancel();
}

//
// Dismiss the dialog
//
void 
CVerifyWins::Dismiss()
{
    DestroyWindow();
}

void 
CVerifyWins::PostNcDestroy()
{
//    delete this;
}

void 
CVerifyWins::SetServerName(CString strName)
{
	m_staticServerName.SetWindowText(strName);
}

BOOL CVerifyWins::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	//m_buttonCancel.ShowWindow(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CVerifyWins::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	// TODO: Add your message handler code here and/or call default
	SetCursor(LoadCursor(NULL, IDC_ARROW));
	
	return CBaseDialog::OnSetCursor(pWnd, nHitTest, message);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\vrfysrv.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	vrfysrv.h
		verify wins dialog
		
    FILE HISTORY:
        
*/

#if !defined(AFX_VERIFYSRV_H__6DB886C1_8E0F_11D1_BA0B_00C04FBF914A__INCLUDED_)
#define AFX_VERIFYSRV_H__6DB886C1_8E0F_11D1_BA0B_00C04FBF914A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CVerifyWins dialog

#ifndef _DIALOG_H
#include "dialog.h"
#endif

class CVerifyWins : public CBaseDialog
{
// Construction
public:
	CVerifyWins(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CVerifyWins)
	enum { IDD = IDD_VERIFY_WINS };
	CButton	m_buttonCancel;
	CStatic	m_staticServerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVerifyWins)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CVerifyWins)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	BOOL m_fCancelPressed;

public:
	BOOL IsCancelPressed()
	{
		return m_fCancelPressed;
	}

	void Dismiss();

	virtual void PostNcDestroy();

	void SetServerName(CString strName);

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CVerifyWins::IDD);};

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VERIFYSRV_H__6DB886C1_8E0F_11D1_BA0B_00C04FBF914A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winsdb.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	winsdb.h
		Wins database enumerator

	FILE HISTORY:
    Oct 13  1997    EricDav     Modified        

*/

#ifndef _WINDDB_H
#define _WINSDB_H

#include "wins.h"

#ifndef _MEMMNGR_H
#include "memmngr.h"
#endif

#ifndef _HARRAY_H
#include "harray.h"
#endif

class CWinsDatabase : public IWinsDatabase
{
public:
    CWinsDatabase();
    ~CWinsDatabase();

 	DeclareIUnknownMembers(IMPL)
	DeclareIWinsDatabaseMembers(IMPL)

    // helper to set the current state
    HRESULT SetCurrentState(WINSDB_STATE winsdbState);

    // for background threading
    DWORD Execute();
    DWORD ReadRecords(handle_t hBinding);
	DWORD ReadRecordsByOwner(handle_t hBinding);

    // ??
    int GetIndex(HROW hrow);
	HROW GetHRow(WinsRecord wRecord, BYTE bLast, BOOL fAllRecords);

protected:
	// Holds all of the sorted and filtered indicies
    CIndexMgr               m_IndexMgr;
    // handles memory allocation
    CMemoryManager			m_cMemMan;
    // total number of records scanned
    DWORD                   m_dwRecsCount;


    LONG					m_cRef;
	BOOL					m_fFiltered;
    BOOL                    m_fInitialized;
    BOOL                    m_bShutdown;

    CString					m_strName;
	CString					m_strIp;
    
	HANDLE					m_hThread;
	HANDLE					m_hStart;
	HANDLE					m_hAbort;

    HRESULT                 m_hrLastError;

	WINSDB_STATE			m_DBState;

    handle_t				m_hBinding;

    CCriticalSection        m_csState;

//    CDWordArray             m_dwaOwnerFilter;
    BOOL                    m_bEnableCache;
    DWORD                   m_dwOwner;
    LPSTR                   m_strPrefix;
};

typedef ComSmartPointer<IWinsDatabase, &IID_IWinsDatabase> SPIWinsDatabase;

// thread proc the background thread initially is called on
DWORD WINAPI ThreadProc(LPVOID lParam);

// converts records from the server to WinsRecords
void WinsIntfToWinsRecord(PWINSINTF_RECORD_ACTION_T pRecord, WinsRecord & wRecord);

// helper to create and initialize the WinsDatabase
extern HRESULT CreateWinsDatabase(CString&  strName, CString&  strIP, IWinsDatabase **ppWinsDB);

#endif // _WINSDB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winscomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winscomp.cpp
		This file contains the derived implementations from CComponent
		and CComponentData for the WINS admin snapin.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "winscomp.h"
#include "root.h"
#include "server.h"
#include "vrfysrv.h"
#include "status.h"

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define HI HIDDEN
#define EN ENABLED

LARGE_INTEGER gliWinssnapVersion;

UINT aColumns[WINSSNAP_NODETYPE_MAX][MAX_COLUMNS] =
{
	{IDS_ROOT_NAME,             IDS_STATUS,              0,                       0,                    0,                   0,                0,                     0,0}, // WINSSNAP_ROOT
	{IDS_WINSSERVER_NAME,       IDS_DESCRIPTION,         0,                       0,                    0,                   0,                0,                     0,0}, // WINSSNAP_SERVER
	{IDS_ACTIVEREG_RECORD_NAME, IDS_ACTIVEREG_TYPE,      IDS_ACTIVEREG_IPADDRESS, IDS_ACTIVEREG_ACTIVE, IDS_ACTIVEREG_STATIC,IDS_ACTREG_OWNER, IDS_ACTIVEREG_VERSION, IDS_ACTIVEREG_EXPIRATION,0}, // WINSSNAP_ACTIVE_REGISTRATIONS
	{IDS_REPLICATION_SERVERNAME,IDS_ACTIVEREG_IPADDRESS, IDS_ACTIVEREG_TYPE,      0,                    0,                   0,                0,					  0,0}, // WINSSNAP_REPLICATION_PARTNERS
	{IDS_ROOT_NODENAME,         IDS_ROOT_NODE_STATUS,    IDS_LAST_UPDATE,         0,                    0,                   0,                0,                     0,0}, // STATUS
	{0,0,0,0,0,0,0,0,0}
};

//
// CODEWORK this should be in a resource, for example code on loading data resources see
//   D:\nt\private\net\ui\common\src\applib\applib\lbcolw.cxx ReloadColumnWidths()
//   JonN 10/11/96
//
// StatusRemove
int aColumnWidths[WINSSNAP_NODETYPE_MAX][MAX_COLUMNS] =
{	
	{250,       150,       50,        AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // WINSSNAP_ROOT
	{250,       250,       AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // WINSSNAP_SERVER
	{150,       120,       100,       75,        50,        100,       100,       150,       AUTO_WIDTH}, // WINSSNAP_ACTIVE_REGISTRATIONS
	{100,       100,       100,       150,       AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // WINSSNAP_REPLICATION_PARTNERS
	{250,       100,       200,       AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // WINSSNAP_SERVER_STATUS
	{AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // WINSSNAP_SERVER_STATUS

};

// icon defines
UINT g_uIconMap[ICON_IDX_MAX + 1][2] = 
{
    {IDI_ICON01,	    ICON_IDX_ACTREG_FOLDER_CLOSED},
    {IDI_ICON02,		ICON_IDX_ACTREG_FOLDER_CLOSED_BUSY},
    {IDI_ICON03,		ICON_IDX_ACTREG_FOLDER_OPEN},
    {IDI_ICON04,		ICON_IDX_ACTREG_FOLDER_OPEN_BUSY},
    {IDI_ICON05,		ICON_IDX_CLIENT},
    {IDI_ICON06,		ICON_IDX_CLIENT_GROUP},
    {IDI_ICON07,		ICON_IDX_PARTNER},
    {IDI_ICON08,		ICON_IDX_REP_PARTNERS_FOLDER_CLOSED},
    {IDI_ICON09,		ICON_IDX_REP_PARTNERS_FOLDER_CLOSED_BUSY},
    {IDI_ICON10,		ICON_IDX_REP_PARTNERS_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON11,		ICON_IDX_REP_PARTNERS_FOLDER_OPEN},
    {IDI_ICON12,		ICON_IDX_REP_PARTNERS_FOLDER_OPEN_BUSY},
    {IDI_ICON13,		ICON_IDX_REP_PARTNERS_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON14,		ICON_IDX_SERVER},
    {IDI_ICON15,		ICON_IDX_SERVER_BUSY},
    {IDI_ICON16,		ICON_IDX_SERVER_CONNECTED},
    {IDI_ICON17,		ICON_IDX_SERVER_LOST_CONNECTION},
    {IDI_ICON18,        ICON_IDX_SERVER_NO_ACCESS},
	{IDI_WINS_SNAPIN,	ICON_IDX_WINS_PRODUCT}, 
    {0, 0}
};

// help mapper for dialogs and property pages
struct ContextHelpMap
{
    UINT            uID;
    const DWORD *   pdwMap;
};

ContextHelpMap g_uContextHelp[WINSSNAP_NUM_HELP_MAPS] =
{
    {IDD_ACTREG_FIND_RECORD,				g_aHelpIDs_IDD_ACTREG_FIND_RECORD},
    {IDD_CHECK_REG_NAMES,                   g_aHelpIDs_IDD_CHECK_REG_NAMES},
    {IDD_DELTOMB_RECORD,                    g_aHelpIDs_IDD_DELTOMB_RECORD},
    {IDD_DYN_PROPERTIES,					g_aHelpIDs_IDD_DYN_PROPERTIES},
    {IDD_FILTER_SELECT,				        g_aHelpIDs_IDD_FILTER_SELECT},
    {IDD_GETIPADDRESS,                      g_aHelpIDs_IDD_GETIPADDRESS},
    {IDD_GETNETBIOSNAME,                    g_aHelpIDs_IDD_GETNETBIOSNAME},
    {IDD_IPADDRESS,                         g_aHelpIDs_IDD_IPADDRESS},
    {IDD_NAME_TYPE,                         g_aHelpIDs_IDD_NAME_TYPE},
    {IDD_OWNER_DELETE,						g_aHelpIDs_IDD_OWNER_DELETE},
    {IDD_OWNER_FILTER,						g_aHelpIDs_IDD_OWNER_FILTER},
    {IDD_FILTER_IPADDR,                     g_aHelpIDs_IDD_FILTER_IPADDR},
    {IDD_PULL_TRIGGER,						NULL},
    {IDD_REP_NODE_ADVANCED,					g_aHelpIDs_IDD_REP_NODE_ADVANCED},
    {IDD_REP_NODE_PUSH,                     g_aHelpIDs_IDD_REP_NODE_PUSH},
    {IDD_REP_NODE_PULL,                     g_aHelpIDs_IDD_REP_NODE_PULL},
    {IDD_REP_NODE_GENERAL,                  g_aHelpIDs_IDD_REP_NODE_GENERAL},
    {IDD_REP_PROP_ADVANCED,					g_aHelpIDs_IDD_REP_PROP_ADVANCED},
    {IDD_REP_PROP_GENERAL,					g_aHelpIDs_IDD_REP_PROP_GENERAL},
    {IDD_SEND_PUSH_TRIGGER,					g_aHelpIDs_IDD_SEND_PUSH_TRIGGER},
    {IDD_SERVER_PROP_ADVANCED,				g_aHelpIDs_IDD_SERVER_PROP_ADVANCED},
    {IDD_SERVER_PROP_DBRECORD,				g_aHelpIDs_IDD_SERVER_PROP_DBRECORD},
    {IDD_SERVER_PROP_DBVERIFICATION,		g_aHelpIDs_IDD_SERVER_PROP_DBVERIFICATION},
    {IDD_SERVER_PROP_GEN,					g_aHelpIDs_IDD_SERVER_PROP_GEN},
    {IDD_SNAPIN_PP_GENERAL,					g_aHelpIDs_IDD_SNAPIN_PP_GENERAL},
    {IDD_STATIC_MAPPING_PROPERTIES,         g_aHelpIDs_IDD_STATIC_MAPPING_PROPERTIES},
    {IDD_STATIC_MAPPING_WIZARD,             g_aHelpIDs_IDD_STATIC_MAPPING_WIZARD},
	{IDD_STATS_NARROW,						NULL},
    {IDD_STATUS_NODE_PROPERTIES,            g_aHelpIDs_IDD_STATUS_NODE_PROPERTIES},
    {IDD_VERIFY_WINS,		                NULL},
    {IDD_VERSION_CONSIS,                    g_aHelpIDs_IDD_VERSION_CONSIS},
};

CWinsContextHelpMap     g_winsContextHelpMap;

DWORD * WinsGetHelpMap(UINT uID) 
{
    DWORD * pdwMap = NULL;
    g_winsContextHelpMap.Lookup(uID, pdwMap);
    return pdwMap;
}



CString aMenuButtonText[3][2];

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

/////////////////////////////////////////////////////////////////////////////
// CWinsComponent implementation

/*---------------------------------------------------------------------------
	Class CWinsComponent implementation
 ---------------------------------------------------------------------------*/
CWinsComponent::CWinsComponent()
{
}

CWinsComponent::~CWinsComponent()
{
}

STDMETHODIMP CWinsComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(m_spImageList != NULL);
    HICON   hIcon;

    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            m_spImageList->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1]);
        }
    }

	return S_OK;
}

/*!--------------------------------------------------------------------------
	CWinsComponent::QueryDataObject
		Implementation of IComponent::QueryDataObject.  We need this for
        virtual listbox support.  MMC calls us back normally with the cookie
        we handed it...  In the case of the VLB, it hands us the index of 
        the item.  So, we need to do some extra checking...
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponent::QueryDataObject
(
	MMC_COOKIE              cookie, 
	DATA_OBJECT_TYPES       type,
    LPDATAOBJECT*           ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    SPITFSNode          spSelectedNode;
    SPITFSNode          spRootNode;
    SPITFSResultHandler spResultHandler;
    long                lViewOptions = 0;
    LPOLESTR            pViewType = NULL;
    CDataObject *       pDataObject;

    COM_PROTECT_TRY
    {
        // check to see what kind of result view type the selected node has
        CORg (GetSelectedNode(&spSelectedNode));
        CORg (spSelectedNode->GetResultHandler(&spResultHandler));
   
    	CORg (spResultHandler->OnGetResultViewType(this, spSelectedNode->GetData(TFS_DATA_COOKIE), &pViewType, &lViewOptions));

        if ( (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) ||
             (cookie == MMC_MULTI_SELECT_COOKIE) )
        {
            if (cookie == MMC_MULTI_SELECT_COOKIE)
            {
                // this is a special case for multiple select.  We need to build a list
                // of GUIDs and the code to do this is in the handler...
                spResultHandler->OnCreateDataObject(this, cookie, type, ppDataObject);
            }
            else
            {
                // this node has a virtual listbox for the result pane.  Gerenate
                // a special data object using the selected node as the cookie
                Assert(m_spComponentData != NULL);
                CORg (m_spComponentData->QueryDataObject(reinterpret_cast<LONG_PTR>((ITFSNode *) spSelectedNode), type, ppDataObject));
            }

            pDataObject = reinterpret_cast<CDataObject *>(*ppDataObject);
            pDataObject->SetVirtualIndex((int) cookie);
        }
        else
        if (cookie == MMC_WINDOW_COOKIE)
        {
            // this cookie needs the text for the static root node, so build the DO with
            // the root node cookie
            m_spNodeMgr->GetRootNode(&spRootNode);
            CORg (m_spComponentData->QueryDataObject((MMC_COOKIE) spRootNode->GetData(TFS_DATA_COOKIE), type, ppDataObject));
        }
        else
        {
            // just forward this to the component data
            Assert(m_spComponentData != NULL);
            CORg (m_spComponentData->QueryDataObject(cookie, type, ppDataObject));
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsComponent::OnSnapinHelp
		-
	Author: v-shubk
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponent::OnSnapinHelp
(
	LPDATAOBJECT	pDataObject,
	LPARAM			arg, 
	LPARAM			param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

	HtmlHelpA(NULL, "WinsSnap.chm", HH_DISPLAY_TOPIC, 0);

	return hr;
}


/*!--------------------------------------------------------------------------
	CWinsComponent::CompareObjects
		Implementation of IComponent::CompareObjects
		MMC calls this to compare two objects
        We override this for the virtual listbox case.  With a virtual listbox,
        the cookies are the same, but the index in the internal structs 
        indicate which item the dataobject refers to.  So, we need to look
        at the indicies instead of just the cookies.
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponent::CompareObjects
(
	LPDATAOBJECT lpDataObjectA, 
	LPDATAOBJECT lpDataObjectB
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
		return E_POINTER;

    // Make sure both data object are mine
    SPINTERNAL spA;
    SPINTERNAL spB;
    HRESULT hr = S_FALSE;

	COM_PROTECT_TRY
	{
		spA = ExtractInternalFormat(lpDataObjectA);
		spB = ExtractInternalFormat(lpDataObjectB);

		if (spA != NULL && spB != NULL)
        {
            if (spA->HasVirtualIndex() && spB->HasVirtualIndex())
            {
                hr = (spA->GetVirtualIndex() == spB->GetVirtualIndex()) ? S_OK : S_FALSE;
            }
            else
            {
                hr = (spA->m_cookie == spB->m_cookie) ? S_OK : S_FALSE;
            }
        }
	}
	COM_PROTECT_CATCH

    return hr;
}



/*---------------------------------------------------------------------------
	Class CWinsComponentData implementation
 ---------------------------------------------------------------------------*/

CWinsComponentData::CWinsComponentData()
{
	// initialize our global help map
    for (int i = 0; i < WINSSNAP_NUM_HELP_MAPS; i++)
    {
        g_winsContextHelpMap.SetAt(g_uContextHelp[i].uID, (LPDWORD) g_uContextHelp[i].pdwMap);
    }
}

/*!--------------------------------------------------------------------------
	CWinsComponentData::OnInitialize
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CWinsComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HICON   hIcon;

    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            VERIFY(SUCCEEDED(pScopeImage->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
        }
    }

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsComponentData::OnDestroy
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CWinsComponentData::OnDestroy()
{
	m_spNodeMgr.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsComponentData::OnInitializeNodeMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponentData::OnInitializeNodeMgr
(
	ITFSComponentData *	pTFSCompData, 
	ITFSNodeMgr *		pNodeMgr
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// For now create a new node handler for each new node,
	// this is rather bogus as it can get expensive.  We can
	// consider creating only a single node handler for each
	// node type.
	CWinsRootHandler *	pHandler = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode;
	HRESULT				hr = hrOK;

	try
	{
		pHandler = new CWinsRootHandler(pTFSCompData);

		// Do this so that it will get released correctly
		spHandler = pHandler;
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
	}
	CORg( hr );
	
	// Create the root node for this sick puppy
	CORg( CreateContainerTFSNode(&spNode,
								 &GUID_WinsGenericNodeType,
								 pHandler,
								 pHandler,		 /* result handler */
								 pNodeMgr) );

	// Need to initialize the data for the root node
	pHandler->InitializeNode(spNode);
	
	CORg( pNodeMgr->SetRootNode(spNode) );
	m_spRootNode.Set(spNode);
	
    pTFSCompData->SetHTMLHelpFileName(_T("winssnap.chm"));

Error:	
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsComponentData::OnCreateComponent
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponentData::OnCreateComponent
(
	LPCOMPONENT *ppComponent
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ppComponent != NULL);
	
	HRESULT			  hr = hrOK;
	CWinsComponent *  pComp = NULL;

	try
	{
		pComp = new CWinsComponent;
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
	}

	if (FHrSucceeded(hr))
	{
		pComp->Construct(m_spNodeMgr,
						static_cast<IComponentData *>(this),
						m_spTFSComponentData);
		*ppComponent = static_cast<IComponent *>(pComp);
	}
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsComponentData::GetCoClassID
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) 
CWinsComponentData::GetCoClassID()
{
	return &CLSID_WinsSnapin;
}

/*!--------------------------------------------------------------------------
	CSfmComponentData::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponentData::OnCreateDataObject
(
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	
	pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*GetCoClassID());

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
STDMETHODIMP 
CWinsComponentData::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_WinsSnapin;

    return hrOK;
}

STDMETHODIMP 
CWinsComponentData::IsDirty()
{
	return m_spRootNode->GetData(TFS_DATA_DIRTY) ? hrOK : hrFalse;
}

STDMETHODIMP 
CWinsComponentData::Load
(
	IStream *pStm
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

	LARGE_INTEGER   liSavedVersion;
	CString         str;
    
	ASSERT(pStm);

    CDWordArray			dwArrayIp;
	CDWordArray			dwArrayFlags;
	CDWordArray			dwArrayRefreshInterval;
	CDWordArray			dwArrayColumnInfo;
	DWORD				dwUpdateInterval;
    DWORD               dwSnapinFlags;
    CStringArray		strArrayName;
	ULONG				nNumReturned = 0;
    DWORD				dwFileVersion;
	CWinsRootHandler *	pRootHandler;
    SPITFSNodeEnum		spNodeEnum;
    SPITFSNode			spCurrentNode;
	HCURSOR				hOldCursor;
	HCURSOR				hNewCursor;
	int					i;

    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_READ);    
    
    // read the version of the file format
    CORg(xferStream.XferDWORD(WINSSTRM_TAG_VERSION, &dwFileVersion));

    // Read the version # of the admin tool
    CORg(xferStream.XferLARGEINTEGER(WINSSTRM_TAG_VERSIONADMIN, &liSavedVersion));
	if (liSavedVersion.QuadPart < gliWinssnapVersion.QuadPart)
	{
		// File is an older version.  Warn the user and then don't
		// load anything else
		Assert(FALSE);
	}

	// Read the root node name
    CORg(xferStream.XferCString(WINSSTRM_TAB_SNAPIN_NAME, &str));
	Assert(m_spRootNode);
	pRootHandler = GETHANDLER(CWinsRootHandler, m_spRootNode);
	pRootHandler->SetDisplayName(str);

	// read the root node info
	CORg(xferStream.XferDWORD(WINSSTRM_TAG_SNAPIN_FLAGS, &dwSnapinFlags));
	pRootHandler->m_dwFlags = dwSnapinFlags;

    pRootHandler->m_fValidate = (dwSnapinFlags & FLAG_VALIDATE_CACHE) ? TRUE : FALSE;
    
	// read from the stream
	CORg(xferStream.XferDWORD(WINSSTRM_TAG_UPDATE_INTERVAL, &dwUpdateInterval));

	pRootHandler->SetUpdateInterval(dwUpdateInterval);
    
    // now read all of the server information
    CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_IP, &dwArrayIp));
	CORg(xferStream.XferCStringArray(WINSSTRM_TAG_SERVER_NAME, &strArrayName));
	CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_FLAGS, &dwArrayFlags));
	CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_REFRESHINTERVAL, &dwArrayRefreshInterval));
	
	hOldCursor = NULL;

	hNewCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
	if (hNewCursor)
		hOldCursor = SetCursor(hNewCursor);

	// now create the servers based on the information
    for (i = 0; i < dwArrayIp.GetSize(); i++)
	{
		//
		// now create the server object
		//
		pRootHandler->AddServer((LPCWSTR) strArrayName[i], 
                                FALSE, 
								dwArrayIp[i],
								FALSE, 
								dwArrayFlags[i],
								dwArrayRefreshInterval[i]
								);
	}

	pRootHandler->DismissVerifyDialog();

	// load the column information
	for (i = 0; i < NUM_SCOPE_ITEMS; i++)
	{
		CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));

		for (int j = 0; j < MAX_COLUMNS; j++)
		{
			aColumnWidths[i][j] = dwArrayColumnInfo[j];
		}

	}

	if (hOldCursor)
		SetCursor(hOldCursor);

Error:
	return SUCCEEDED(hr) ? S_OK : E_FAIL;
}


STDMETHODIMP 
CWinsComponentData::Save
(
	IStream *pStm, 
	BOOL	 fClearDirty
)
{
	HRESULT hr = hrOK;

    CDWordArray			dwArrayIp;
    CStringArray		strArrayName;
	CDWordArray			dwArrayFlags;
	CDWordArray			dwArrayRefreshInterval;
	CDWordArray			dwArrayColumnInfo;
	DWORD				dwUpdateInterval;
    DWORD               dwSnapinFlags;
    DWORD				dwFileVersion = WINSSNAP_FILE_VERSION;
	CString				str;
	CWinsRootHandler *	pRootHandler;
    int					nNumServers = 0, nVisibleCount = 0;
	SPITFSNodeEnum		spNodeEnum;
    SPITFSNode			spCurrentNode;
    ULONG				nNumReturned = 0;
    int					nCount = 0;
	const GUID *		pGuid;
	CWinsServerHandler *pServer;
	int					i;

	ASSERT(pStm);

	// set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_WRITE);    

	// Write the version # of the file format
    CORg(xferStream.XferDWORD(WINSSTRM_TAG_VERSION, &dwFileVersion));

	// Write the version # of the admin tool
    CORg(xferStream.XferLARGEINTEGER(WINSSTRM_TAG_VERSIONADMIN, &gliWinssnapVersion));

	// write the root node name
    Assert(m_spRootNode);
	pRootHandler = GETHANDLER(CWinsRootHandler, m_spRootNode);
	str = pRootHandler->GetDisplayName();

	CORg(xferStream.XferCString(WINSSTRM_TAB_SNAPIN_NAME, &str));

	//
	// Build our array of servers
	//
	hr = m_spRootNode->GetChildCount(&nVisibleCount, &nNumServers);

	dwArrayColumnInfo.SetSize(MAX_COLUMNS);

	// save the root node info
	dwSnapinFlags = pRootHandler->m_dwFlags;

    CORg(xferStream.XferDWORD(WINSSTRM_TAG_SNAPIN_FLAGS, &dwSnapinFlags));
	
	dwUpdateInterval = pRootHandler->GetUpdateInterval();
	CORg(xferStream.XferDWORD(WINSSTRM_TAG_UPDATE_INTERVAL, &dwUpdateInterval));
	
	//
	// loop and save off all the server's attributes
	//
    m_spRootNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		pGuid = spCurrentNode->GetNodeType();

		if (*pGuid == GUID_WinsServerStatusNodeType)
		{
			// go to the next node
			spCurrentNode.Release();
			spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
			//nCount++;
		
            continue;
		}

		pServer = GETHANDLER(CWinsServerHandler, spCurrentNode);

        // put the information in our array
		strArrayName.Add(pServer->GetServerAddress());
		dwArrayIp.Add(pServer->GetServerIP());
		dwArrayFlags.Add(pServer->m_dwFlags);
		dwArrayRefreshInterval.Add(pServer->m_dwRefreshInterval);

        // go to the next node
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

        nCount++;
	}

	// now write out all of the server information
    CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_IP, &dwArrayIp));
    CORg(xferStream.XferCStringArray(WINSSTRM_TAG_SERVER_NAME, &strArrayName));
	CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_FLAGS, &dwArrayFlags));
	CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_REFRESHINTERVAL, &dwArrayRefreshInterval));
		
	// save the column information
	for (i = 0; i < NUM_SCOPE_ITEMS; i++)
	{
		for (int j = 0; j < MAX_COLUMNS; j++)
		{
			dwArrayColumnInfo[j] = aColumnWidths[i][j];
		}

		CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));
	}
    
	if (fClearDirty)
	{
		m_spRootNode->SetData(TFS_DATA_DIRTY, FALSE);
	}

Error:
    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}


STDMETHODIMP 
CWinsComponentData::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 10000);

    return S_OK;
}

STDMETHODIMP 
CWinsComponentData::InitNew()
{
	return hrOK;
}

HRESULT 
CWinsComponentData::FinalConstruct()
{
	HRESULT				hr = hrOK;
	
	hr = CComponentData::FinalConstruct();
	
	if (FHrSucceeded(hr))
	{
		m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
	}
	return hr;
}

void 
CWinsComponentData::FinalRelease()
{
	CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winshand.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	Winshand.cpp
		WINS specifc handler base classes

    FILE HISTORY:
        
*/



#include "stdafx.h"
#include "winshand.h"
#include "snaputil.h"


MMC_CONSOLE_VERB g_ConsoleVerbs[] =
{
	MMC_VERB_OPEN,
    MMC_VERB_COPY,
	MMC_VERB_PASTE,
	MMC_VERB_DELETE,
	MMC_VERB_PROPERTIES,
	MMC_VERB_RENAME,
	MMC_VERB_REFRESH,
	MMC_VERB_PRINT
};

#define HI HIDDEN
#define EN ENABLED

// StatusRemove
MMC_BUTTON_STATE g_ConsoleVerbStates[WINSSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
    {HI, HI, HI, HI, EN, HI, HI, HI},   // WINSSNAP_ROOT
	{HI, HI, HI, EN, EN, HI, EN, HI},   // WINSSNAP_SERVER
	{HI, HI, HI, HI, HI, HI, EN, HI},   // WINSSNAP_ACTIVEREG
	{HI, HI, HI, HI, EN, HI, EN, HI},   // WINSSNAP_REPLICATION_PARTNERS	
	{HI, HI, HI, HI, EN, HI, EN, HI},	// WINSSNAP_SERVER_STATUS
	{HI, HI, HI, EN, EN, HI, HI, HI},   // WINSSNAP_REGISTRATION	
    {HI, HI, HI, EN, EN, HI, HI, HI},	// WINSSNAP_REPLICATION_PARTNER
	{HI, HI, HI, HI, HI, HI, HI, HI}	// WINSSNAP_STATUS_LEAF_NODE
};

//Status Remove
MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[WINSSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
    {HI, HI, HI, HI, HI, HI, HI, HI},   // WINSSNAP_ROOT
	{HI, HI, HI, HI, HI, HI, HI, HI},   // WINSSNAP_SERVER
	{HI, HI, HI, HI, HI, HI, EN, HI},   // WINSSNAP_ACTIVEREG
	{HI, HI, HI, EN, HI, HI, HI, HI},   // WINSSNAP_REPLICATION_PARTNERS	
	{HI, HI, HI, HI, HI, HI, HI, HI},   // WINSSNAP_SERVER_STATUS	
	{HI, HI, HI, EN, HI, HI, HI, HI},   // WINSSNAP_REGISTRATION	
    {HI, HI, HI, EN, HI, HI, HI, HI},	// WINSSNAP_REPLICATION_PARTNER
	{HI, HI, HI, HI, HI, HI, HI, HI}	// WINSSNAP_STATUS_LEAF_NODE
};

// Help ID array for help on scope items
DWORD g_dwMMCHelp[WINSSNAP_NODETYPE_MAX] =
{
	WINSSNAP_HELP_ROOT,                 // WINSSNAP_ROOT
	WINSSNAP_HELP_SERVER,               // WINSSNAP_SERVER
	WINSSNAP_HELP_ACT_REG_NODE,         // WINSSNAP_ACTIVEREG
	WINSSNAP_HELP_REP_PART_NODE,        // WINSSNAP_REPLICATION_PARTNERS
	WINSSNAP_HELP_ACTREG_ENTRY,         // WINSSNAP_SCOPE
	WINSSNAP_HELP_REP_PART_ENTRY        // WINSSNAP_REPLICATION_PARTNER
};


/*---------------------------------------------------------------------------
	Class:	CMTWinsHandler
 ---------------------------------------------------------------------------*/

//
// Called by the result handler when a command comes in that isn't handled 
// by the result handler.  If appropriate it passes it to the scope pane hander.
//
HRESULT
CMTWinsHandler::HandleScopeCommand
(
	MMC_COOKIE  	cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the handler to take care of this
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnCommand(spNode, nCommandID, dwType, pDataObject, (ULONG) spNode->GetData(TFS_DATA_TYPE));
    }
        
Error:
    return hr;
}

//
// Called by the result handler to add the scope pane menu items to the menu
// where appropriate.  Puts scope pane menu items in when action menu is clicked
// and the message view has focus as well as when a right click happens in the white 
// space of the result pane.
//
HRESULT
CMTWinsHandler::HandleScopeMenus
(
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the normal handler to put up the menu items
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnAddMenuItems(spNode, pContextMenuCallback, pDataObject, CCT_SCOPE, (ULONG) spNode->GetData(TFS_DATA_TYPE), pInsertionAllowed);
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
	CMTWinsHandler::OnChangeState
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
void CMTWinsHandler::OnChangeState
(
	ITFSNode * pNode
)
{
	// Increment the state to the next position

	switch (m_nState)
	{
		case notLoaded:
		case loaded:
		case unableToLoad:
			{
				m_nState = loading;
				m_dwErr = 0;
			}
			break;

		case loading:
			{
				m_nState = (m_dwErr != 0) ? unableToLoad : loaded;
                
                if (m_dwErr)
                {
                    CString strTitle, strBody;
                    IconIdentifier icon;

                    GetErrorInfo(strTitle, strBody, &icon);
                    ShowMessage(pNode, strTitle, strBody, icon);
                }
                else
                {
                    ClearMessage(pNode);
                }

                m_fSilent = FALSE;
			}
			break;
	
		default:
			ASSERT(FALSE);
	}

    // check to make sure we are still the visible node in the UI
    if (m_bSelected)
    {
        UpdateStandardVerbs(pNode, pNode->GetData(TFS_DATA_TYPE));
    }

	// Now check and see if there is a new image for this state for this handler
	int nImage, nOpenImage;

	nImage = GetImageIndex(FALSE);
	nOpenImage = GetImageIndex(TRUE);

	if (nImage >= 0)
		pNode->SetData(TFS_DATA_IMAGEINDEX, nImage);

	if (nOpenImage >= 0)
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nOpenImage);
	
	VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_ICON)));
}


 /*!--------------------------------------------------------------------------
	CMTWinsHandler::UpdateStandardVerbs
		Tells the IComponent to update the verbs for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTWinsHandler::UpdateStandardVerbs
(
    ITFSNode * pNode,
    LONG_PTR   dwNodeType
)
{
    HRESULT				hr = hrOK;
    SPIComponentData	spCompData;
	SPIConsole			spConsole;
    IDataObject*		pDataObject;

    m_spNodeMgr->GetComponentData(&spCompData);

    CORg ( spCompData->QueryDataObject(NULL, CCT_RESULT, &pDataObject) );

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );

    CORg ( spConsole->UpdateAllViews(pDataObject, 
                                     dwNodeType, 
                                     RESULT_PANE_UPDATE_VERBS) ); 

    pDataObject->Release();
	
Error:
    return;
}

/*---------------------------------------------------------------------------
	CMTWinsHandler::OnResultDelete
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTWinsHandler::OnResultDelete
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE		cookie, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	HRESULT hr = hrOK;

	Trace0("CMTWinsHandler::OnResultDelete received\n");

	// translate this call to the parent and let it handle deletion 
	// of result pane items
	SPITFSNode spNode, spParent;
	SPITFSResultHandler spParentRH;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));
	CORg (spNode->GetParent(&spParent));

	if (spParent == NULL)
		return hr;

	CORg (spParent->GetResultHandler(&spParentRH));

	CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_DELETE, arg, lParam));

Error:
	return hr;
}


 /*!--------------------------------------------------------------------------
	CMTWinsHandler::UpdateConsoleVerbs
		Updates the standard verbs depending upon the state of the node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTWinsHandler::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];	
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        ButtonState = g_ConsoleVerbStates[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
        
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;
        }
        
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::EnableVerbs
		Enables the toolbar buttons
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CMTWinsHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
									   
        }
    }
	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}

 /*!--------------------------------------------------------------------------
	CMTWinsHandler::ExpandNode
		Expands/compresses this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTWinsHandler::ExpandNode
(
    ITFSNode *  pNode,
    BOOL        fExpand
)
{
    SPIComponentData	spCompData;
    SPIDataObject       spDataObject;
    LPDATAOBJECT        pDataObject;
    SPIConsole          spConsole;
    HRESULT             hr = hrOK;

    // don't expand the node if we are handling the EXPAND_SYNC message,
    // this screws up the insertion of item, getting duplicates.
    if (!m_fExpandSync)
    {
        m_spNodeMgr->GetComponentData(&spCompData);

	    CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
        spDataObject = pDataObject;

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
	    CORg ( spConsole->UpdateAllViews(pDataObject, TRUE, RESULT_PANE_EXPAND) ); 
    }

Error:
    return;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::OnExpandSync
		Handles the MMCN_EXPANDSYNC notifcation 
        We need to do syncronous enumeration.  We'll fire off the background 
        thread like before, but we'll wait for it to exit before we return.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTWinsHandler::OnExpandSync
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    HRESULT hr = hrOK;
    MSG msg;

    m_fExpandSync = TRUE;

    hr = OnExpand(pNode, pDataObject, CCT_SCOPE, arg, lParam);

    // wait for the background thread to exit
    WaitForSingleObject(m_hThread, INFINITE);
    
    // The background thread posts messages to a hidden window to 
    // pass data back to the main thread. The messages won't go through since we are
    // blocking the main thread.  The data goes on a queue in the query object
    // which the handler has a pointer to so we can just fake the notification.
    if (m_spQuery.p)
        OnNotifyHaveData((LPARAM) m_spQuery.p);

    // Tell MMC we handled this message
    MMC_EXPANDSYNC_STRUCT * pES = reinterpret_cast<MMC_EXPANDSYNC_STRUCT *>(lParam);
    if (pES)
        pES->bHandled = TRUE;

    m_fExpandSync = FALSE;

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTWinsHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
    HRESULT         hr = hrOK;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    SPINTERNAL      spInternal;
    BOOL            bMultiSelect = FALSE;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

	m_bSelected = bSelect;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

    spInternal = ::ExtractInternalFormat(pDataObject);
    
    if (spInternal && 
        spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CORg (pComponent->GetSelectedNode(&spNode));
        bMultiSelect = TRUE;
    }
    else
    {
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    }

    UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE), bMultiSelect);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::OnCreateDataObject
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTWinsHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	    pObject = NULL;
	SPIDataObject	    spDataObject;
    long                lViewOptions;
    LPOLESTR            pViewType;
    BOOL                bVirtual;

    pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
    	OnGetResultViewType(pComponent, cookie, &pViewType, &lViewOptions);
        bVirtual = (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) ? TRUE : FALSE;
        
        CreateMultiSelectData(pComponent, pObject, bVirtual);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::CreateMultiSelectData
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTWinsHandler::CreateMultiSelectData
(
    ITFSComponent * pComponent, 
    CDataObject *   pObject,
    BOOL            bVirtual
)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList        listSelectedNodes;
    CVirtualIndexArray  arraySelectedIndicies;
    CGUIDArray          rgGuids;
    UINT                cb;
    GUID*               pGuid;
    const GUID *        pcGuid;
    int                 i;

    COM_PROTECT_TRY
    {
        if (bVirtual)
        {
            // build a list of the selected indicies in the virtual listbox
            CORg (BuildVirtualSelectedItemList(pComponent, &arraySelectedIndicies));

            // now call and get the GUIDs for each one
            for (i = 0; i < arraySelectedIndicies.GetSize(); i++)
            {
                pcGuid = GetVirtualGuid(arraySelectedIndicies[i]);
                if (pcGuid)
                    rgGuids.AddUnique(*pcGuid);
            }
        }
        else
        {
            CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

            // collect all of the unique guids
            while (listSelectedNodes.GetCount() > 0)
	        {
		        SPITFSNode   spCurNode;

		        spCurNode = listSelectedNodes.RemoveHead();

                pcGuid = spCurNode->GetNodeType();
			
                rgGuids.AddUnique(*pcGuid);
            }
        }

        // now put the information in the data object
        cb = (UINT)(rgGuids.GetSize() * sizeof(GUID));
        
        if (cb > 0)
        {
            pObject->SetMultiSelDobj();
    
            pGuid = new GUID[(size_t)rgGuids.GetSize()];
            CopyMemory(pGuid, rgGuids.GetData(), cb);
            pObject->SetMultiSelData((BYTE*)pGuid, cb);
        }
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::OnResultUpdateView
		Implementation of ITFSResultHandler::OnResultUpdateView
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CMTWinsHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LPARAM        hint
)
{
	HRESULT hr = hrOK;

    if (hint == RESULT_PANE_UPDATE_VERBS)
    {
	    SPIConsoleVerb  spConsoleVerb;
        SPITFSNode      spNode;

        CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

        UpdateConsoleVerbs(spConsoleVerb, data);
    }
    else
    {
        return CBaseResultHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CMTWinsHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

	    szHelpFilePath.ReleaseBuffer();
		szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::SaveColumns
		-
 ---------------------------------------------------------------------------*/
HRESULT 
CMTWinsHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        if (SUCCEEDED(spHeaderCtrl->GetColumnWidth(nCol, &nColWidth)) &&
            (aColumnWidths[dwNodeType][nCol] != nColWidth))
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}



/*---------------------------------------------------------------------------
	Class:	CWinsHandler
 ---------------------------------------------------------------------------*/

//
// Called by the result handler when a command comes in that isn't handled 
// by the result handler.  If appropriate it passes it to the scope pane hander.
//
HRESULT
CWinsHandler::HandleScopeCommand
(
	MMC_COOKIE  	cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the handler to take care of this
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnCommand(spNode, nCommandID, dwType, pDataObject, (ULONG) spNode->GetData(TFS_DATA_TYPE));
    }
        
Error:
    return hr;
}

//
// Called by the result handler to add the scope pane menu items to the menu
// where appropriate.  Puts scope pane menu items in when action menu is clicked
// and the message view has focus as well as when a right click happens in the white 
// space of the result pane.
//
HRESULT
CWinsHandler::HandleScopeMenus
(
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the normal handler to put up the menu items
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnAddMenuItems(spNode, pContextMenuCallback, pDataObject, CCT_SCOPE, (ULONG) spNode->GetData(TFS_DATA_TYPE), pInsertionAllowed);
    }

Error:
    return hr;
}


/*---------------------------------------------------------------------------
	CWinsHandler::Command
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

    // this may have come from the scope pane handler, so pass it up
    hr = HandleScopeCommand(cookie, nCommandID, pDataObject);

    return hr;
}


/*!--------------------------------------------------------------------------
	CWinsHandler::AddMenuItems
		Over-ride this to add our view menu item
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);
    
    return hr;
}



/*---------------------------------------------------------------------------
	CWinsHandler::OnResultDelete
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsHandler::OnResultDelete
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE		cookie, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	HRESULT hr = hrOK;

	Trace0("CWinsHandler::OnResultDelete received\n");

	// translate this call to the parent and let it handle deletion 
	// of result pane items
	SPITFSNode spNode, spParent;
	SPITFSResultHandler spParentRH;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));
	CORg (spNode->GetParent(&spParent));

	if (spParent == NULL)
		return hr;

	CORg (spParent->GetResultHandler(&spParentRH));

	CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_DELETE, arg, lParam));

Error:
	return hr;
}

 /*!--------------------------------------------------------------------------
	CWinsHandler::UpdateConsoleVerbs
		Updates the standard verbs depending upon the state of the node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CWinsHandler::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];	
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        /*
		ButtonState = g_ConsoleVerbStates[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
		*/

		ButtonState = g_ConsoleVerbStates[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
        
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
				for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;

            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;
        }
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*!--------------------------------------------------------------------------
	CWinsHandler::EnableVerbs
		Enables the toolbar buttons
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CWinsHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
									   
        }
    }

	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}

/*!--------------------------------------------------------------------------
	CWinsHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
    HRESULT         hr = hrOK;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    SPINTERNAL      spInternal;
    BOOL            bMultiSelect;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

    spInternal = ::ExtractInternalFormat(pDataObject);
    
    if (spInternal && 
        spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CORg (pComponent->GetSelectedNode(&spNode));
        bMultiSelect = TRUE;
    }
    else
    {
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
		bMultiSelect = FALSE;
    }

    UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE), bMultiSelect);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsHandler::OnCreateDataObject
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	    pObject = NULL;
	SPIDataObject	    spDataObject;
    long                lViewOptions;
    LPOLESTR            pViewType;
    BOOL                bVirtual;

    pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
    	OnGetResultViewType(pComponent, cookie, &pViewType, &lViewOptions);
        bVirtual = (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) ? TRUE : FALSE;
        
        CreateMultiSelectData(pComponent, pObject, bVirtual);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

 /*!--------------------------------------------------------------------------
	CWinsHandler::CreateMultiSelectData
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CWinsHandler::CreateMultiSelectData
(
    ITFSComponent * pComponent, 
    CDataObject *   pObject,
    BOOL            bVirtual
)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList        listSelectedNodes;
        CVirtualIndexArray  arraySelectedIndicies;
    CGUIDArray          rgGuids;
    UINT                cb;
    GUID*               pGuid;
    const GUID *        pcGuid;
    int                 i;

    COM_PROTECT_TRY
    {
        if (bVirtual)
        {
            // build a list of the selected indicies in the virtual listbox
            CORg (BuildVirtualSelectedItemList(pComponent, &arraySelectedIndicies));

            // now call and get the GUIDs for each one
            for (i = 0; i < arraySelectedIndicies.GetSize(); i++)
            {
                pcGuid = GetVirtualGuid(arraySelectedIndicies[i]);
                if (pcGuid)
                    rgGuids.AddUnique(*pcGuid);
            }
        }
        else
        {
            CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

            // collect all of the unique guids
            while (listSelectedNodes.GetCount() > 0)
	        {
		        SPITFSNode   spCurNode;

		        spCurNode = listSelectedNodes.RemoveHead();
                pcGuid = spCurNode->GetNodeType();
        
                rgGuids.AddUnique(*pcGuid);
            }
        }

        // now put the information in the data object
        cb = (UINT)(rgGuids.GetSize() * sizeof(GUID));
        
        if (cb > 0)
        {
            pObject->SetMultiSelDobj();
    
            pGuid = new GUID[(size_t)rgGuids.GetSize()];
            CopyMemory(pGuid, rgGuids.GetData(), cb);
            pObject->SetMultiSelData((BYTE*)pGuid, cb);
        }
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}


/*!--------------------------------------------------------------------------
	CWinsHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

	    szHelpFilePath.ReleaseBuffer();
		szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsHandler::SaveColumns
		-
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsHandler::SaveColumns
(   
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        if (SUCCEEDED(spHeaderCtrl->GetColumnWidth(nCol, &nColWidth)) &&
            (aColumnWidths[dwNodeType][nCol] != nColWidth))
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winsdb.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winsdb.cpp
		Wins database enumerator

	FILE HISTORY:
    Oct 13  1997    EricDav     Modified        

*/

#include "stdafx.h"
#include "wins.h"
#include "search.h"
#include "winsdb.h"
#include "tfschar.h"

IMPLEMENT_ADDREF_RELEASE(CWinsDatabase);

IMPLEMENT_SIMPLE_QUERYINTERFACE(CWinsDatabase, IWinsDatabase)

DEBUG_DECLARE_INSTANCE_COUNTER(CWinsDatabase)

CWinsDatabase::CWinsDatabase()
    : m_cRef(1), m_fFiltered(FALSE), m_fInitialized(FALSE), m_bShutdown(FALSE), m_hrLastError(hrOK)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(CWinsDatabase);

	SetCurrentState(WINSDB_NORMAL);

    m_hBinding = NULL;
	m_hThread = NULL;
	m_hStart = NULL;
	m_hAbort = NULL;
    m_dwOwner = (DWORD)-1;
    m_strPrefix = NULL;
    m_dwRecsCount = 0;
    m_bEnableCache = FALSE;
}

CWinsDatabase::~CWinsDatabase()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CWinsDatabase);
    
    m_bShutdown = TRUE;

    if (m_strPrefix != NULL)
        delete m_strPrefix;
    
    SetEvent(m_hAbort);
    SetEvent(m_hStart);
    
    if (WaitForSingleObject(m_hThread, 30000) != WAIT_OBJECT_0)
    {
        Trace0("WinsDatabase destructor thread never died!\n");       

        // TerminateThread
    }

    CloseHandle(m_hAbort);
    CloseHandle(m_hStart);
    CloseHandle(m_hThread);
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Init
		Implementation of IWinsDatabase::Init
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::Init()
{
	HRESULT         hr = hrOK;
    WINSDB_STATE    uCurrentState;

    m_dwRecsCount = 0;

    COM_PROTECT_TRY
	{
        CORg (GetCurrentState(&uCurrentState));
        if (uCurrentState != WINSDB_NORMAL)
        {
            Trace1("WinsDatabase::Init - called when database busy - state %d\n", uCurrentState);       
            return E_FAIL;
        }

		CORg (m_cMemMan.Initialize());
        CORg (m_IndexMgr.Initialize());

        m_hrLastError = hrOK;

        CORg (SetCurrentState(WINSDB_LOADING));

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH
	
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Start
		Implementation of IWinsDatabase::Start
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::Start()
{
    // signal the thread to start loading
    SetEvent(m_hStart);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Initialize
		Implementation of IWinsDatabase::Initialize
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::Initialize(LPCOLESTR	pszName, LPCOLESTR pszIP)
{
	HRESULT hr = hrOK;
	DWORD dwError; 
	DWORD dwThreadId;

	COM_PROTECT_TRY
	{
		m_strName = pszName;
		m_strIp   = pszIP;

		CORg (m_cMemMan.Initialize());
        CORg (m_IndexMgr.Initialize());

        m_hStart = ::CreateEvent(NULL, FALSE, FALSE, NULL);
		if (m_hStart == NULL)
        {
            dwError = ::GetLastError();
            Trace1("WinsDatabase::Initialize - CreateEvent Failed m_hStart %d\n", dwError);
          
            return HRESULT_FROM_WIN32(dwError);
        }

        m_hAbort = ::CreateEvent(NULL, FALSE, FALSE, NULL);
		if (m_hAbort == NULL)
        {
            dwError = ::GetLastError();
            Trace1("WinsDatabase::Initialize - CreateEvent Failed m_hAbort %d\n", dwError);
          
            return HRESULT_FROM_WIN32(dwError);
        }

        m_hThread = ::CreateThread(NULL, 0, ThreadProc, this, 0, &dwThreadId);
		if (m_hThread == NULL)
        {
            dwError = ::GetLastError();
            Trace1("WinsDatabase::Init - CreateThread Failed %d\n", dwError);
          
            return HRESULT_FROM_WIN32(dwError);
        }

        m_fInitialized = TRUE;
	
        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH
	
	return hr;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::GetName
		Implementation of IWinsDatabase::GetName
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetName(LPOLESTR pszName, UINT cchMax)
{
	HRESULT hr = hrOK;
	LPCTSTR pBuf;

	COM_PROTECT_TRY
	{
        if (cchMax < (UINT) (m_strName.GetLength() / sizeof(TCHAR)))
            return E_FAIL;

        StrnCpy(pszName, (LPCTSTR) m_strName, cchMax);
    }
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetIP
		Implementation of IWinsDatabase::GetIP
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetIP(LPOLESTR pszIP, UINT cchMax)
{
	HRESULT hr = hrOK;
	LPCTSTR pBuf;

    COM_PROTECT_TRY
	{
        if (cchMax < (UINT) (m_strIp.GetLength() / sizeof(TCHAR)))
            return E_FAIL;

        StrnCpy(pszIP, (LPCTSTR) m_strIp, cchMax);

    }
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Stop
		Implementation of IWinsDatabase::Stop
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::Stop()
{
	HRESULT         hr = hrOK;
	WINSDB_STATE    uState;

    COM_PROTECT_TRY
	{
		CORg (GetCurrentState(&uState));

        if (uState != WINSDB_LOADING)
            return hr;

		SetEvent(m_hAbort);

        CORg (SetCurrentState(WINSDB_NORMAL));

        COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Clear
		Clears the wins DB of all records
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::Clear()
{
	HRESULT         hr = hrOK;
	WINSDB_STATE    uState;

    COM_PROTECT_TRY
	{
		CORg (GetCurrentState(&uState));

        if (uState == WINSDB_SORTING ||
            uState == WINSDB_FILTERING)
            return E_FAIL;

        if (uState == WINSDB_LOADING)
        {
    		SetEvent(m_hAbort);
            CORg (SetCurrentState(WINSDB_NORMAL));
        }

   		CORg (m_cMemMan.Initialize());
        CORg (m_IndexMgr.Initialize());
        m_dwOwner = (DWORD)-1;
        if (m_strPrefix != NULL)
            delete m_strPrefix;
        m_strPrefix = NULL;

        COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

    return hr;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::GetLastError
		Returns the last error for async calls
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetLastError(HRESULT * pLastError)
{
	HRESULT         hr = hrOK;
	WINSDB_STATE    uState;

    COM_PROTECT_TRY
	{
        if (pLastError)
            *pLastError = m_hrLastError;

	}
	COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Sort
		Implementation of IWinsDatabase::Sort
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT	
CWinsDatabase::Sort(WINSDB_SORT_TYPE SortType, DWORD dwSortOptions)
{
	HRESULT         hr = hrOK;
	WINSDB_STATE    uState;

	COM_PROTECT_TRY
	{
		CORg (GetCurrentState(&uState));

        if (uState != WINSDB_NORMAL)
			return E_FAIL;

		CORg (SetCurrentState(WINSDB_SORTING));

        m_IndexMgr.Sort(SortType, dwSortOptions);

        CORg (SetCurrentState(WINSDB_NORMAL));

		COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetHRow
		Implementation of IWinsDatabase::GetHRow
        returns the HRow in the current sorted index
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetHRow(UINT		uIndex,
					   LPHROW   hRow)
{
	Assert(uIndex >= 0);

	HRESULT hr = hrOK;
    WINSDB_STATE uState;
    int          nCurrentCount;

	COM_PROTECT_TRY
	{
        CORg (GetCurrentCount(&nCurrentCount));

        if (uIndex > (UINT) nCurrentCount)
            return E_FAIL;

    	CORg (GetCurrentState(&uState));
        if (uState == WINSDB_SORTING || uState == WINSDB_FILTERING)
            return E_FAIL;

        m_IndexMgr.GetHRow(uIndex, hRow);

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

	return hr;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::GetRows
		Implementation of IWinsDatabase::GetRows
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT	CWinsDatabase::GetRows(	ULONG	uNumberOfRows,
							    ULONG	uStartPos,
								HROW*	pHRow,
								int*	nNumberOfRowsReturned)
{
    int             nCurrentCount;
    WINSDB_STATE    uState;
	HRESULT         hr = hrOK;
    int             nReturnedRows = 0;
    int             i;
    HROW            hrowCur;

    Assert (uStartPos >= 0);

    COM_PROTECT_TRY
	{
    	CORg (GetCurrentState(&uState));
		if (uState == WINSDB_SORTING || uState == WINSDB_FILTERING)
			return E_FAIL;

        CORg (GetCurrentCount(&nCurrentCount));
        Assert ((int) uStartPos <= nCurrentCount);
        if (uStartPos > (UINT) nCurrentCount)
            return E_FAIL;

		for (i = (int) uStartPos; i < (int) (uStartPos + uNumberOfRows); i++)
		{
			if( i > nCurrentCount )
			{
				break;
			}

            CORg (m_IndexMgr.GetHRow(i, &hrowCur));

			// if the row is marked deleted, don't add it to the array
            // REVIEW: directly accessing memory here.. we may want to change this
            // to go through the memory manager
            if ( ((LPWINSDBRECORD) hrowCur)->szRecordName[17] & WINSDB_INTERNAL_DELETED )
			{
				continue;
			}

            // fill in the data
            pHRow[i-uStartPos] = hrowCur;
            nReturnedRows++;
		}

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

    if (nNumberOfRowsReturned)
        *nNumberOfRowsReturned = nReturnedRows;

    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetData
		Implementation of IWinsDatabase::GetData
        returns the HRow in the current sorted index
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT CWinsDatabase::GetData(HROW         hRow,
							   LPWINSRECORD pRecordData)
{
	HRESULT hr = E_FAIL;

	COM_PROTECT_TRY
	{
        CORg (m_cMemMan.GetData(hRow, pRecordData));

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

	return hr;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::FindRow
		Implementation of IWinsDatabase::FindRow
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::FindRow(LPCOLESTR	pszName,
			   	       HROW		    hrowStart,
					   HROW *		phRow) 
{
	HRESULT     hr = E_FAIL;
	WinsRecord  ws;
    int         nIndex, nPos, nCurrentCount;
    HROW        hrowCur;
    HROW        hrowFound = NULL;
    char        szName[MAX_PATH];

    CString strTemp(pszName);

    // this should be OEM 
    WideToMBCS(strTemp, szName, WINS_NAME_CODE_PAGE);

	COM_PROTECT_TRY
	{
        CORg (m_IndexMgr.GetIndex(hrowStart, &nIndex));
		
		/////
		CORg(GetHRow(nIndex, &hrowCur));
		CORg (m_IndexMgr.GetIndex(hrowCur, &nIndex));

        CORg (GetCurrentCount(&nCurrentCount));

		if(nIndex != -1)
		{

			CORg(GetHRow(nIndex, &hrowCur));

			for (nPos = nIndex + 1; nPos < nCurrentCount; nPos++)
			{
				CORg(GetHRow(nPos, &hrowCur));
            
				CORg(GetData(hrowCur, &ws));
				if(!_strnicmp(ws.szRecordName, szName, strlen(szName) ))
				{
					hrowFound = hrowCur;
					hr = hrOK;
					break;
				}
			}
		}

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

    if (phRow)
        *phRow = hrowFound;

    return hr;
}
        
/*!--------------------------------------------------------------------------
	CWinsDatabase::GetTotalCount
		Implementation of IWinsDatabase::GetTotalCount
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT	
CWinsDatabase::GetTotalCount(int * nTotalCount)
{
	HRESULT hr = hrOK;
	COM_PROTECT_TRY
	{
		*nTotalCount = m_IndexMgr.GetTotalCount();
	}
	COM_PROTECT_CATCH
	return hr;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::GetCurrentCount
		Implementation of IWinsDatabase::GetCurrentCount
        returns the HRow in the current sorted index
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetCurrentCount(int * nCurrentCount)
{
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_DBState == WINSDB_SORTING)
			*nCurrentCount = 0;
		else
			*nCurrentCount = m_IndexMgr.GetCurrentCount();
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetCurrentScanned(int * nCurrentScanned)
		Implementation of IWinsDatabase::GetCurrentScanned
        returns the total number of records that were read from the server
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetCurrentScanned(int * nCurrentCount)
{
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
        *nCurrentCount = m_dwRecsCount;
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::AddRecord
		Implementation of IWinsDatabase::AddRecord
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CWinsDatabase::AddRecord(const LPWINSRECORD pRecordData)
{
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
		// critical sections taken care by the memory manager
		HROW hrow = NULL;
    
        CORg (m_cMemMan.AddData(*pRecordData, &hrow));
        CORg (m_IndexMgr.AddHRow(hrow));

        COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

	return hrOK;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::DeleteRecord
		Implementation of IWinsDatabase::DeleteRecord
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::DeleteRecord(HROW hrowRecord)
{
	HRESULT hr = hrOK;
    WINSDB_STATE uState;
    
	COM_PROTECT_TRY
	{
		CORg (GetCurrentState(&uState));

        if (uState != WINSDB_NORMAL)
			return E_FAIL;

		// make sure the hrow is a valid one
		if (!m_cMemMan.IsValidHRow(hrowRecord))
			return E_FAIL;

		// Tell the memmgr to delete this record
        CORg (m_cMemMan.Delete(hrowRecord));

        // now tell the index manager to remove this hrow
        CORg (m_IndexMgr.RemoveHRow(hrowRecord));

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetCurrentState
		Implementation of IWinsDatabase::GetCurrentState
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetCurrentState(WINSDB_STATE * pState)
{
	CSingleLock cl(&m_csState);
    cl.Lock();

    *pState = m_DBState;
	
    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::SetCurrentState
		Helper function to set the current state, protected
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::SetCurrentState(WINSDB_STATE winsdbState)
{
	CSingleLock cl(&m_csState);
    cl.Lock();

    m_DBState = winsdbState;
	
    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::FilterRecords
		Implementation of IWinsDatabase::FilterRecords
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::FilterRecords
(
    WINSDB_FILTER_TYPE  FilterType,
	DWORD			    dwParam1,
	DWORD			    dwParam2)
{
	HRESULT hr = E_NOTIMPL;
	WINSDB_STATE uState ;

	COM_PROTECT_TRY
	{
		// fail if the state is other then WINSDB_NORMAL
		CORg (GetCurrentState(&uState));

        if (uState == WINSDB_SORTING || uState == WINSDB_FILTERING)
			return E_FAIL;

		// if in the loading state the readrecords function takes care
		if(uState != WINSDB_LOADING)
			CORg (SetCurrentState(WINSDB_FILTERING));

        // do the filtering here, rebuild the filtered name Index
		m_IndexMgr.Filter(FilterType, dwParam1, dwParam2);

		if(uState != WINSDB_LOADING)
			CORg (SetCurrentState(WINSDB_NORMAL));

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH
	
    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::AddFilter
        Adds the filters specified to the list
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::AddFilter(WINSDB_FILTER_TYPE FilterType, DWORD dwParam1, DWORD dwParam2, LPCOLESTR strParam3)
{
	HRESULT hr = hrOK;
	
	COM_PROTECT_TRY
	{
		// for filter by type, dwParam1 is the type, dwParam2 is show/not show
		m_IndexMgr.AddFilter(FilterType, dwParam1, dwParam2, strParam3);
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::ClearFilter
        CLears all the filters
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/

HRESULT 
CWinsDatabase::ClearFilter(WINSDB_FILTER_TYPE FilterType)
{
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
		//CFilteredIndexName *pFilterName = (CFilteredIndexName *)m_IndexMgr.GetFilteredNameIndex();
		//pFilterName->ClearFilter();
		m_IndexMgr.ClearFilter(FilterType);
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::SetActiveView
		Implementation of IWinsDatabase::SetActiveView
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/

HRESULT 
CWinsDatabase::SetActiveView(WINSDB_VIEW_TYPE ViewType)
{
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
		m_IndexMgr.SetActiveView(ViewType);
	}
	COM_PROTECT_CATCH

	return hr;

}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Execute()
        The background thread calls into this to execute
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
DWORD
CWinsDatabase::Execute()
{
    DWORD dwStatus = 0;

    // wait for the other thread to signal us to start doing something

    while (::WaitForSingleObject(m_hStart, INFINITE) == WAIT_OBJECT_0)
    {
        if (m_bShutdown)
            break;

        Trace0("WinsDatabase::Execute - start event signaled\n");

		WINSINTF_BIND_DATA_T wbdBindData;
		handle_t		hBinding = NULL;

        do
        {
            // enumerate leases here
            SetCurrentState(WINSDB_LOADING);

	        // now that the server name and ip are valid, call
	        // WINSBind function directly.
	        
            WINSINTF_ADD_T  waWinsAddress;

	        DWORD			dwStatus;
	        CString strNetBIOSName;

		    // call WinsBind function with the IP address
		    wbdBindData.fTcpIp = 1;
		    wbdBindData.pPipeName = NULL;
		    
		    // convert wbdBindData.pServerAdd to wide char again as one of the internal 
		    // functions expects a wide char string, this is done in WinsABind which is bypassed for 
		    // unicode compatible apps

            wbdBindData.pServerAdd = (LPSTR) (LPCTSTR) m_strIp;

		    if ((hBinding = ::WinsBind(&wbdBindData)) == NULL)
		    {
			    dwStatus = ::GetLastError();
                Trace1("WinsDatabase::Execute - WinsBind failed %lx\n", dwStatus);
			    break;
		    }

#ifdef WINS_CLIENT_APIS
		    dwStatus = ::WinsGetNameAndAdd(
							hBinding,
			                &waWinsAddress,
			                (BYTE *)strNetBIOSName.GetBuffer(128));

#else
			dwStatus = ::WinsGetNameAndAdd(
							&waWinsAddress,
			                (BYTE *)strNetBIOSName.GetBuffer(128));

#endif WINS_CLIENT_APIS

            strNetBIOSName.ReleaseBuffer();

            if (dwStatus == ERROR_SUCCESS)
            {
				if(m_dwOwner == (DWORD)-1)
					dwStatus = ReadRecords(hBinding);
				else
					dwStatus = ReadRecordsByOwner(hBinding);

                break;
            }
            else
            {
                Trace1("WinsDatabase::Execute - WinsGetNameAndAdd failed %lx\n", dwStatus);
                break;
            }
        
        } while (FALSE);

        SetCurrentState(WINSDB_NORMAL);


		if(hBinding)
		{
			// call winsunbind here, the handle is invalid after this and that's fine
			WinsUnbind(&wbdBindData, hBinding);
			hBinding = NULL;
		}
        Trace0("WinsDatabase::Execute - all done, going to sleep now...\n");

    } // while !Start

    Trace0("WinsDatabase::Execute - exiting\n");
    return dwStatus;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::ReadRecords
        Reads records from the WINS server
    Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
DWORD 
CWinsDatabase::ReadRecords(handle_t hBinding)
{
	DWORD dwStatus = ERROR_SUCCESS;
	DWORD err = ERROR_SUCCESS;
	
    CWinsResults winsResults;
    err = winsResults.Update(hBinding);

	WINSINTF_RECS_T Recs;
	Recs.pRow = NULL;
	
	DWORD   NoOfRecsDesired = 500;
	DWORD   TypeOfRecs = 4;
	BOOL    fReadAllRecords ;

    PWINSINTF_RECORD_ACTION_T pRow;
    enum {ST_SCAN_1B_NAME, ST_SCAN_NORM_NAME} State;
	LPBYTE  pLastName;
	UINT    nLastNameLen, nLastBuffLen;

    pLastName       = NULL;
    nLastNameLen    = 0;
    nLastBuffLen    = 0;

#ifdef DEBUG
    CTime timeStart, timeFinish;
    timeStart = CTime::GetCurrentTime();
#endif

    m_dwRecsCount = 0;

    // initialize the state machine. If we have a name prefix filter we
    // start in ST_INIT_1B since we look first for the 1B names. These are
    // particular in a sense their type byte - i.e. 0x1B - has been swapped
    // with the first byte from the name. Consequently we need to do the same
    // to allow WINS to look first for these names. Once we get over the 1B zone
    // of our names, we restore the first byte and initiate another cycle for
    // the rest of the name.
    if (m_strPrefix != NULL)
    {
        nLastNameLen = nLastBuffLen = strlen(m_strPrefix) + 1;
        pLastName = (LPBYTE) new CHAR[nLastBuffLen];
        strcpy((LPSTR)pLastName, m_strPrefix);
        pLastName[0] = 0x1B;
        State = ST_SCAN_1B_NAME;
    }
    else
    {
        State = ST_SCAN_NORM_NAME;
    }

    do
	{

#ifdef WINS_CLIENT_APIS
        err = ::WinsGetDbRecsByName(
                    hBinding,
                    NULL,
                    WINSINTF_BEGINNING,
                    pLastName,
			        nLastNameLen,
                    NoOfRecsDesired, 
                    TypeOfRecs,
                    &Recs);

#else
		err = ::WinsGetDbRecsByName(
                    NULL,
                    WINSINTF_BEGINNING,
                    pFromName,
					LastNameLen,
                    NoOfRecsDesired,
                    TypeOfRecs,
                    &Recs);

#endif WINS_CLIENT_APIS 


        // check to see if we need to abort
        if (WaitForSingleObject(m_hAbort, 0) == WAIT_OBJECT_0)
        {
    		Trace0("CWinsDatabase::ReadRecords - abort detected\n");
            dwStatus = ERROR_OPERATION_ABORTED;
            break;
        }

        if (err == ERROR_REC_NON_EXISTENT)
		{
			//
			// Not a problem, there simply
			// are no records in the database
			//
            Trace0("WinsDatabase::ReadRecords - no records in the Datbase\n");
			fReadAllRecords = TRUE;
			err = ERROR_SUCCESS;
			break;
		}

		if (err == ERROR_SUCCESS)
		{
			fReadAllRecords  = Recs.NoOfRecs < NoOfRecsDesired;
            if (fReadAllRecords)
                Trace0("WinsDatabase::ReadRecords - Recs.NoOfRecs < NoOfRecsDesired, will exit\n");

            TRY
			{
				DWORD i;
				pRow = Recs.pRow;

				for (i = 0; i < Recs.NoOfRecs; ++i, ++pRow)
				{
					PWINSINTF_RECORD_ACTION_T pRow1 = Recs.pRow;
                    WinsRecord wRecord;
                    HROW hrow = NULL;

                    WinsIntfToWinsRecord(pRow, wRecord);
					if (pRow->OwnerId < (UINT) winsResults.AddVersMaps.GetSize())
                    {
						wRecord.dwOwner = winsResults.AddVersMaps[pRow->OwnerId].Add.IPAdd;
                    }
                    else
                    {
                        // having a record owned by a server which is not in the version map
                        // we got just earlier from WINS is not something that usually happens.
                        // It might happen only if the new owner was added right in between.
                        // Unlikely since this is a very small window - but if this happens
                        // just skip the record. From our point of view this owner doesn't exist
                        // hence the record doesn't belong to the view. It will show up with the
                        // first refresh.
                        continue;
                    }

					m_dwRecsCount++;

                    if (!m_bEnableCache && !m_IndexMgr.AcceptWinsRecord(&wRecord))
                        continue;

                    // add the data to our memory store and
                    // to the sorted index
                    m_cMemMan.AddData(wRecord, &hrow);
                    // if m_bEnableCache is 0 the the filter was checked
                    m_IndexMgr.AddHRow(hrow, TRUE, !m_bEnableCache);

                    //Trace1("%d records added to DB\n", m_dwRecsCount);
				}


                // if we reached the end of the DB there is no need to do
                // anything from below. Is just pLastName that needs to be
                // freed up - this is done outside the loop, before exiting
                // the call.
                if (!fReadAllRecords)
                {
                    BOOL fRangeOver = FALSE;

                    // get to the last record that was retrieved.
                    --pRow;

                    // check if the last name retrieved from the server is still
                    // mathing the pattern prefix (if any) or the range has been 
                    // passed over (fRangeOver)

                    if (m_strPrefix != NULL)
                    {
                        for (UINT i = 0; i < pRow->NameLen && m_strPrefix[i] != 0; i++)
                        {
                            if (m_strPrefix[i] != pRow->pName[i])
                            {
                                fRangeOver = TRUE;
                                break;
                            }
                        }
                    }

                    // here fRangeOver is either TRUE if the name doesn't match the pattern
                    // prefix or FALSE if the range is not passed yet. This latter thing means
                    // either the name is included in the prefix or the prefix isn't included in the name
                    // !!! We might want to invalidate the "name included in the prefix" case.
                    if (fRangeOver)
                    {
                        switch(State)
                        {
                        case ST_SCAN_1B_NAME:
                            // in this state pLastName is definitely not NULL and even more, 
                            // it once copied m_strPrefix. Since pLastName can only grow, it is
                            // certain it is large enough to cotain m_strPrefix one more time.
                            strcpy((LPSTR)pLastName, m_strPrefix);
					        nLastNameLen = strlen((LPCSTR)pLastName);
                            State = ST_SCAN_NORM_NAME;
                            break;
                        case ST_SCAN_NORM_NAME:
                            // we were scanning normal names and we passed
                            // over the range of names we are looking for
                            // so just get out of the loop.
                            fReadAllRecords = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        // enlarge the pLastName if needed
                        if (nLastBuffLen < pRow->NameLen+2)
                        {
                            if (pLastName != NULL)
                                delete pLastName;
                            nLastBuffLen = pRow->NameLen+2;
                            pLastName = (LPBYTE)new CHAR[nLastBuffLen];
                        }
                        // copy in pLastName the name of the last record
					    strcpy((LPSTR)pLastName, (LPCSTR)(pRow->pName));

                        if (pRow->NameLen >= 16 && pLastName[15] == 0x1B)
					    {
						    CHAR ch = pLastName[15];
						    pLastName[15] = pLastName[0];
						    pLastName[0] = ch;
					    }

                        strcat((LPSTR)pLastName, "\x01");
					    nLastNameLen = strlen((LPCSTR)pLastName);
                    }
                }
			}
			CATCH_ALL(e)
			{
				err = ::GetLastError();
                Trace1("WinsDatabase::ReadRecords - Exception! %d \n", err);
                m_hrLastError = HRESULT_FROM_WIN32(err);
			}
			END_CATCH_ALL
		}		
		else
		{
            Trace1("WinsDatabase::ReadRecords - GetRecsByName failed! %d \n", err);
            m_hrLastError = HRESULT_FROM_WIN32(err);
			break;
		}
		
		if (Recs.pRow != NULL)
        {
            ::WinsFreeMem(Recs.pRow);
        }

    } while(!fReadAllRecords );

    if (pLastName != NULL)
        delete pLastName;

#ifdef DEBUG
    timeFinish = CTime::GetCurrentTime();
    CTimeSpan timeDelta = timeFinish - timeStart;
	CString strTempTime = timeDelta.Format(_T("%H:%M:%S"));
    Trace2("WINS DB - ReadRecords: %d records read, total time %s\n", m_dwRecsCount, strTempTime);
#endif

    return dwStatus;
}

/*!--------------------------------------------------------------------------
	ThreadProc
        -
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
DWORD WINAPI 
ThreadProc(LPVOID pParam)
{
    DWORD dwReturn;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
	    CWinsDatabase *pWinsDB = (CWinsDatabase *) pParam;
	    
        Trace0("WinsDatabase Background Thread started.\n");

        dwReturn = pWinsDB->Execute();
    }
    COM_PROTECT_CATCH

    return dwReturn;
}


/*!--------------------------------------------------------------------------
	WinsIntfToWinsRecord
		Converts a wins record from the server into the WinsRecord struct
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
void
WinsIntfToWinsRecord(PWINSINTF_RECORD_ACTION_T  pRecord, WinsRecord & wRecord)
{
    ZeroMemory(&wRecord, sizeof(WinsRecord));

    //::strcpy(wRecord.szRecordName, (LPCSTR)pRecord->pName);
    ::memcpy(wRecord.szRecordName, (LPCSTR)pRecord->pName, pRecord->NameLen);

    wRecord.dwExpiration = (ULONG) pRecord->TimeStamp;
	wRecord.liVersion = pRecord->VersNo;
	wRecord.dwOwner = pRecord->OwnerId;
	wRecord.dwNameLen = WINSINTF_NAME_LEN_M(pRecord->NameLen);
    wRecord.dwType |= (BYTE) wRecord.szRecordName[15];

    // translate the state and types to our own definitions
    switch (pRecord->State_e)
    {
        case WINSINTF_E_TOMBSTONE:
		    wRecord.dwState |= WINSDB_REC_TOMBSTONE;
            break;

        case WINSINTF_E_DELETED:
            //Trace0("WinsIntfToWinsRecord - deleted record.\n");
		    wRecord.dwState |= WINSDB_REC_DELETED;
            break;

        case WINSINTF_E_RELEASED:
            //Trace0("WinsIntfToWinsRecord - released record.\n");
		    wRecord.dwState |= WINSDB_REC_RELEASED;
            break;

        default:  // WINSINTF_E_ACTIVE:
		    wRecord.dwState |= WINSDB_REC_ACTIVE;
            break;
    }

    switch (pRecord->TypOfRec_e)
    {
        case WINSINTF_E_NORM_GROUP:
		    wRecord.dwState |= WINSDB_REC_NORM_GROUP;
            break;

        case WINSINTF_E_SPEC_GROUP:
		    wRecord.dwState |= WINSDB_REC_SPEC_GROUP;
            break;

        case WINSINTF_E_MULTIHOMED:
		    wRecord.dwState |= WINSDB_REC_MULTIHOMED;
            break;

        default:  // WINSINTF_E_UNIQUE:
		    wRecord.dwState |= WINSDB_REC_UNIQUE;
            break;
    }

    // now do the type -- move the value into the high word
    DWORD dwTemp = (pRecord->TypOfRec_e << 16);
    wRecord.dwType |= dwTemp;

    // now set the static flag
    if (pRecord->fStatic)
		wRecord.dwState |= WINSDB_REC_STATIC;

    // store all of the IP addrs
    wRecord.dwNoOfAddrs = pRecord->NoOfAdds;
    if (pRecord->NoOfAdds > 1)
    {
        Assert(pRecord->NoOfAdds <= WINSDB_MAX_NO_IPADDRS);
        
        //if (wRecord.dwNoOfAddrs > 4)
        //    Trace1("WinsIntfToWinsRecord - record with multiple (>4) IP addrs: %d\n", wRecord.dwNoOfAddrs);

        wRecord.dwState |= WINSDB_REC_MULT_ADDRS;

        for (UINT i = 0; i < pRecord->NoOfAdds; i++)
            wRecord.dwIpAdd[i] = pRecord->pAdd[i].IPAdd;
    }
    else
    {   
        if (pRecord->NoOfAdds == 0)
        {
            //Trace2("WinsIntfToWinsRecord - record with NoOfAdds == 0; IP: %lx State: %lx \n", pRecord->Add.IPAdd, wRecord.dwState);
        }

        if (pRecord->Add.IPAdd == 0)
        {
            Trace1("WinsIntfToWinsRecord - record with 0 IP Address! State: %lx \n", wRecord.dwState);
        }

        wRecord.dwIpAdd[0] = pRecord->Add.IPAdd;
    }
}

/*!--------------------------------------------------------------------------
	CreateWinsDatabase
		-
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CreateWinsDatabase(CString&  strName, CString&  strIP, IWinsDatabase **ppWinsDB)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	CWinsDatabase *	pWinsDB = NULL;
	HRESULT		hr = hrOK;

	SPIWinsDatabase	spWinsDB;

	COM_PROTECT_TRY
	{
		pWinsDB = new CWinsDatabase();
		Assert(pWinsDB);
		
		spWinsDB = pWinsDB;
		CORg(pWinsDB->Initialize(strName, strIP));
		
		*ppWinsDB = spWinsDB.Transfer();

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
	
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::SetApiInfo
		Implementation of SetApiInfo of IWinsDatabase
	Author: FlorinT
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::SetApiInfo(DWORD dwOwner, LPCOLESTR strPrefix, BOOL bCache)
{
    // first cleanup the old prefix
    if (m_strPrefix != NULL)
    {
        delete m_strPrefix;
        m_strPrefix = NULL;
    }

    if (strPrefix != NULL)
    {
        UINT    nPxLen = 0;
        LPSTR   pPrefix;

        nPxLen = (_tcslen(strPrefix)+1)*sizeof(TCHAR);
        m_strPrefix = new char[nPxLen];
        if (m_strPrefix != NULL)
        {
#ifdef _UNICODE
            if (WideCharToMultiByte(CP_OEMCP,
                                    0,
                                    strPrefix,
                                    -1,
                                    m_strPrefix,
                                    nPxLen,
                                    NULL,
                                    NULL) == 0)
            {
                delete m_strPrefix;
                m_strPrefix = NULL;
            }
#else
            CharToOem(strPrefix, m_strPrefix);
#endif
            m_strPrefix = _strupr(m_strPrefix);

            for (pPrefix = m_strPrefix;
                 *pPrefix != '\0' && *pPrefix != '*' && *pPrefix != '?';
                 pPrefix++);
            *pPrefix = '\0';
        }
    }

    m_dwOwner = dwOwner;

    m_bEnableCache = bCache;

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetCachingFlag
		Implementation of GetCachingFlag of IWinsDatabase
	Author: FlorinT
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetCachingFlag(LPBOOL pbCache)
{
    *pbCache = m_bEnableCache;
    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::ReloadSuggested
		Implementation of ReloadSuggested of IWinsDatabase
	Author: FlorinT
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::ReloadSuggested(DWORD dwOwner, LPCOLESTR strPrefix, LPBOOL pbReload)
{
    // check whether we filtered on a particular owner.
    if (m_dwOwner != 0xFFFFFFFF)
    {
        // we did filter on owner previously, suggest RELOAD if we now
        // don't want to filter on any owner (dwOwner == 0xffffffff)
        // or the owner we want to filter is different from the original one
        *pbReload = (m_dwOwner != dwOwner);
    }
    else
    {
        // we didn't filter on any owner previously so we either loaded
        // all the records (if no name prefix was specified) or loaded
        // all the records matching the given prefix
        if (m_strPrefix != NULL)
        {
            // we did have a previous prefix to match so we need to see
            // if the new prefix is not by any chance more specific than
            // the original one. In which case there is no need to reload
            LPSTR   pPrefix;
            UINT    nPxLen;
            UINT    i;

            if (strPrefix == NULL)
            {
                // if now we're not filtering by name, since we did previously
                // we definitely need to reload the database
                *pbReload = TRUE;
                return hrOK;
            }

            nPxLen = (_tcslen(strPrefix)+1)*sizeof(TCHAR);
            pPrefix = new char[nPxLen];
            if (pPrefix != NULL)
            {
#ifdef _UNICODE
                if (WideCharToMultiByte(CP_OEMCP,
                                        0,
                                        strPrefix,
                                        -1,
                                        pPrefix,
                                        nPxLen,
                                        NULL,
                                        NULL) == 0)
                {
                    delete pPrefix;
                    *pbReload = TRUE;
                    return hrOK;
                }
#else
                CharToOem(strPrefix, pPrefix);
#endif
                pPrefix = _strupr(pPrefix);

                for (i = 0;
                     pPrefix[i] != '\0' && pPrefix[i] != '*' && pPrefix[i] != '?';
                     i++);
                pPrefix[i] = '\0';

                // we don't suggest database reloading only if the current prefix
                // is a prefix for the new one to be applied. This way, whatever 
                // was retrieved previously already contains the names having the
                // new prefix.
                *pbReload = (strncmp(m_strPrefix, pPrefix, strlen(m_strPrefix)) != 0);

                delete pPrefix;
            }
            else
            {
                // couldn't allocate memory -> serious enough to ask a full reload
                *pbReload = TRUE;
            }
        }
        else
        {
            // well, there was no prefix specified last time the db was loaded so
            // we should have the whole database in hand. No need to reload.
            *pbReload = FALSE;
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::ReadRecordsByOwner
        Reads records from the WINS server for a particular owner
    Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
#define MAX_DESIRED_RECORDS     400
#define LARGE_GAP_DETECT_COUNT  32
DWORD 
CWinsDatabase::ReadRecordsByOwner(handle_t hBinding)
{
    DWORD           err;
    CWinsResults    winsResults;
    WINSINTF_RECS_T Recs;
    DWORD           dwIP;
    LARGE_INTEGER   MinVersNo, MaxVersNo;
    LARGE_INTEGER   LowestVersNo;
    DWORD           dwDesired;
    DWORD           dwLargeGapCount;
    WINSINTF_ADD_T  OwnerAdd;
    DWORD           i;

    err = winsResults.Update(hBinding);
    if (err != ERROR_SUCCESS)
    {
        m_hrLastError = HRESULT_FROM_WIN32(err);
        return err;
    }

    MinVersNo.QuadPart= 0;
    for (i = 0; i < (int)winsResults.NoOfOwners; i++)
    {
        if (m_dwOwner == winsResults.AddVersMaps[i].Add.IPAdd)
        {
            MaxVersNo = winsResults.AddVersMaps[i].VersNo;
            break;
        }
    }

    // if we couldn't find the owner (highly unlikely) get out
    // with error INVALID_PARAMETER.
    if (i == winsResults.NoOfOwners)
    {
        err = ERROR_INVALID_PARAMETER;
        m_hrLastError = HRESULT_FROM_WIN32(err);
        return err;
    }

    m_dwRecsCount = 0;

    OwnerAdd.Type = 0;
    OwnerAdd.Len = 4;
    OwnerAdd.IPAdd = m_dwOwner;

    // This is what the server does to retrieve the records:
    // 1. sets an ascending index on owner & version number.
    // 2. goes to the first record owned by the given owner,
    //    having a version number larger or equal to MinVersNo.
    // 3. stop if the record's vers num is higher than the range specified
    // 4. stop if more than 1000 recs have been already received
    // 5. add the new record to the set to return and go to 3.
    //
    dwDesired       = MAX_DESIRED_RECORDS;
    dwLargeGapCount = LARGE_GAP_DETECT_COUNT;
    LowestVersNo.QuadPart = 0;
    if (MaxVersNo.QuadPart > dwDesired)
        MinVersNo.QuadPart = MaxVersNo.QuadPart-dwDesired;
    else
        MinVersNo.QuadPart = 0;
    Recs.pRow = NULL;
    while(MaxVersNo.QuadPart >= MinVersNo.QuadPart)
    {
        // clear up the previous array - if any
        if (Recs.pRow != NULL)
        {
            ::WinsFreeMem(Recs.pRow);
            Recs.pRow = NULL;
        }

        // go to WINS to get the data for the given Owner
#ifdef WINS_CLIENT_APIS
		err = ::WinsGetDbRecs(hBinding, &OwnerAdd, MinVersNo,
			MaxVersNo, &Recs);
#else
		err = ::WinsGetDbRecs(&OwnerAdd, MinVersNo,
			MaxVersNo, &Recs);
#endif WINS_CLIENT_APIS

        // if abort was requested, break out with "ABORTED"
		if (WaitForSingleObject(m_hAbort, 0) == WAIT_OBJECT_0)
		{
			err = ERROR_OPERATION_ABORTED;
			break;
		}

        // if there is any kind of error break out
        if (err != ERROR_SUCCESS)
        {
            if (err == ERROR_REC_NON_EXISTENT)
            {
                // I'm not sure this happens after all. The server side (WINS) has
                // not code path returning such an error code.
                err = ERROR_SUCCESS;
            }
            else
            {
                // if this happens, just get out with the error, and save the
                // meaning of the error
			    m_hrLastError = HRESULT_FROM_WIN32(err);
            }
            break;
        }

        // if got less than 1/4 of the size of the range, expand the range
        // to double of what it was + 1. (+1 is important to avoid the effect
        // of dramatic drop down because of DWORD roll-over
        if (Recs.NoOfRecs <= (dwDesired >> 2))
        {
            dwDesired <<= 1;
            dwDesired |= 1;
        }
        // else if got more than 3/4 of the size of the range, split the range in 2
        // but not less than MAX_DESIRED_RECORDS
        else if (Recs.NoOfRecs >= (dwDesired - (dwDesired >> 2)))
        {
            dwDesired = max (MAX_DESIRED_RECORDS, dwDesired >> 1);
        }

		TRY
		{
			DWORD                       j;
            PWINSINTF_RECORD_ACTION_T   pRow;

			for (j = 0, pRow = Recs.pRow; j < Recs.NoOfRecs; j++, ++pRow)
			{
				WinsRecord wRecord;
				HROW hrow = NULL;

				pRow->OwnerId = m_dwOwner;
				WinsIntfToWinsRecord(pRow, wRecord);

				m_dwRecsCount++;
                
                if (!m_bEnableCache && !m_IndexMgr.AcceptWinsRecord(&wRecord))
                    continue;

				// add the data to our memory store and
				// to the sorted index
				m_cMemMan.AddData(wRecord, &hrow);
				m_IndexMgr.AddHRow(hrow, FALSE, !m_bEnableCache);
			}

            // now setup the new range to search..
            //
            // if this is not the gap boundary detection cycle, the next MaxVersNo
            // needs to go right below the current MinVersNo. Otherwise, MaxVersNo
            // needs to remain untouched!
            if (dwLargeGapCount != 0)
                MaxVersNo.QuadPart = MinVersNo.QuadPart - 1;

            // if no records were found..
            if (Recs.NoOfRecs == 0)
            {
                // ..and we were already in the gap boundary detection cycle..
                if (dwLargeGapCount == 0)
                    // ..just break the loop - there are simply no more records
                    // for this owner in the database
                    break;

                // ..otherwise just decrease the gap boundary detection counter.
                // If it reaches 0, then next cycle we will attempt to see if
                // there is any record closer to the lowest edge of the range by
                // expanding for one time only the whole space.
                dwLargeGapCount--;
            }
            else
            {
                // if we just exited the gap boundary detection cycle by finding some
                // records, set the LowestVersNo to one more than the largest VersNo 
                // we found during this cycle.
                if (dwLargeGapCount == 0)
                {
                    pRow--;
                    LowestVersNo.QuadPart = pRow->VersNo.QuadPart+1;
                }

                // if there were any records found, just reset the gap boundary detection counter.
                dwLargeGapCount = LARGE_GAP_DETECT_COUNT;
            }

            // if the dwLargeGapCount counter is zero, it means the next cycle is a gap boundary detection one
            // which means the range should be set for the whole unexplored space.
            if (dwLargeGapCount != 0 && MaxVersNo.QuadPart > LowestVersNo.QuadPart + dwDesired)
                MinVersNo.QuadPart = MaxVersNo.QuadPart - dwDesired;
            else
                MinVersNo.QuadPart = LowestVersNo.QuadPart;
		}
		CATCH_ALL(e)
		{
			err = ::GetLastError();
			m_hrLastError = HRESULT_FROM_WIN32(err);
		}
		END_CATCH_ALL
		
	}

	if (Recs.pRow != NULL)
		::WinsFreeMem(Recs.pRow);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winscomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	winscomp.h
		This file contains the derived prototypes from CComponent
		and CComponentData for the WINS admin snapin.

    FILE HISTORY:
        
*/

#ifndef _WINSCOMP_H
#define _WINSCOMP_H

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _COMPONT_H
#include "compont.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#define COLORREF_PINK	0x00FF00FF
#define WINSSNAP_FILE_VERSION    0x00000001
#define GETHANDLER(classname, node) (reinterpret_cast<classname *>(node->GetData(TFS_DATA_USER)))

#define STRING_LENGTH_MAX		 256

enum WINSSTRM_TAG
{
	WINSSTRM_TAG_VERSION					=	XFER_TAG(1, XFER_DWORD),
	WINSSTRM_TAG_VERSIONADMIN				=	XFER_TAG(2, XFER_LARGEINTEGER),
    WINSSTRM_TAB_SNAPIN_NAME				=   XFER_TAG(3, XFER_STRING),
    WINSSTRM_TAG_SERVER_IP					=	XFER_TAG(4, XFER_DWORD_ARRAY),
	WINSSTRM_TAG_SERVER_NAME				=	XFER_TAG(5, XFER_STRING_ARRAY),
	WINSSTRM_TAG_SERVER_CONNECTED			=	XFER_TAG(6, XFER_STRING_ARRAY),
	WINSSTRM_TAG_SERVER_FLAGS				=	XFER_TAG(10, XFER_DWORD_ARRAY),
	WINSSTRM_TAG_SERVER_REFRESHINTERVAL		=	XFER_TAG(11, XFER_DWORD_ARRAY),
	WINSSTRM_TAG_COLUMN_INFO				=	XFER_TAG(12, XFER_DWORD_ARRAY),
	WINSSTRM_TAG_SNAPIN_FLAGS	            =	XFER_TAG(13, XFER_DWORD),
	WINSSTRM_TAG_UPDATE_INTERVAL			=	XFER_TAG(14, XFER_DWORD)
};

typedef enum _ICON_INDICIES
{
	ICON_IDX_ACTREG_FOLDER_CLOSED,
	ICON_IDX_ACTREG_FOLDER_CLOSED_BUSY,
	ICON_IDX_ACTREG_FOLDER_OPEN,
	ICON_IDX_ACTREG_FOLDER_OPEN_BUSY,
	ICON_IDX_CLIENT,
	ICON_IDX_CLIENT_GROUP,
	ICON_IDX_PARTNER,
	ICON_IDX_REP_PARTNERS_FOLDER_CLOSED,
	ICON_IDX_REP_PARTNERS_FOLDER_CLOSED_BUSY,
	ICON_IDX_REP_PARTNERS_FOLDER_CLOSED_LOST_CONNECTION,
	ICON_IDX_REP_PARTNERS_FOLDER_OPEN,
	ICON_IDX_REP_PARTNERS_FOLDER_OPEN_BUSY,
	ICON_IDX_REP_PARTNERS_FOLDER_OPEN_LOST_CONNECTION,
	ICON_IDX_SERVER,
	ICON_IDX_SERVER_BUSY,
	ICON_IDX_SERVER_CONNECTED,
	ICON_IDX_SERVER_LOST_CONNECTION,
    ICON_IDX_SERVER_NO_ACCESS,
	ICON_IDX_WINS_PRODUCT,
	ICON_IDX_MAX
} ICON_INDICIES, * LPICON_INDICIES;

// icon image map
extern UINT g_uIconMap[ICON_IDX_MAX + 1][2];

/////////////////////////////////////////////////////////////////////////////
// CWinsComponentData

class CWinsComponentData :
	public CComponentData,
	public CComObjectRoot
{
public:
	
BEGIN_COM_MAP(CWinsComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()
			
	// These are the interfaces that we MUST implement

	// We will implement our common behavior here, with the derived
	// classes implementing the specific behavior.
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompDataCallbackMembers(IMPL)

	CWinsComponentData();

	HRESULT FinalConstruct();
	void FinalRelease();
	
protected:
	SPITFSNodeMgr	m_spNodeMgr;
	SPITFSNode		m_spRootNode;

// Notify handler declarations
private:
};

/////////////////////////////////////////////////////////////////////////////
// CWinsComponent
class CWinsComponent : 
	public TFSComponent
{
public:
	CWinsComponent();
	~CWinsComponent();

	//DeclareITFSCompCallbackMembers(IMPL)
	STDMETHOD(InitializeBitmaps)(MMC_COOKIE cookie);
	STDMETHOD(QueryDataObject) (MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject);

    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    // snap-in help
	STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);

//Attributes
private:
};

/*---------------------------------------------------------------------------
	This is how the WINS snapin implements its extension functionality.
	It actually exposes two interfaces that are CoCreate-able.  One is the 
	primary interface, the other the extension interface.
	
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CWinsComponentDataPrimary : public CWinsComponentData,
	public CComCoClass<CWinsComponentDataPrimary, &CLSID_WinsSnapin>
{
public:
	DECLARE_REGISTRY(CWinsComponentDataPrimary, 
					 _T("WinsSnapin.WinsSnapin.1"), 
					 _T("WinsSnapin.WinsSnapin"), 
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

	STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_WinsSnapin; }
};


class CWinsComponentDataExtension : public CWinsComponentData,
    public CComCoClass<CWinsComponentDataExtension, &CLSID_WinsSnapinExtension>
{
public:
	DECLARE_REGISTRY(CWinsComponentDataExtension, 
					 _T("WinsSnapinExtension.WinsSnapinExtension.1"), 
					 _T("WinsSnapinExtension.WinsSnapinExtension"), 
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_WinsSnapinExtension; }
};


/*---------------------------------------------------------------------------
	This is the derived class for handling the IAbout interface from MMC
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CWinsAbout : 
	public CAbout,
    public CComCoClass<CWinsAbout, &CLSID_WinsSnapinAbout>
{
public:
DECLARE_REGISTRY(CWinsAbout, _T("WinsSnapin.About.1"), 
							 _T("WinsSnapin.About"), 
							 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CWinsAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
	COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CWinsAbout)

// these must be overridden to provide values to the base class
protected:
	virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
	virtual UINT GetAboutProviderId()	 { return IDS_ABOUT_PROVIDER; }
	virtual UINT GetAboutVersionId()	 { return IDS_ABOUT_VERSION; }
	virtual UINT GetAboutIconId()		 { return IDI_WINS_SNAPIN; }

	virtual UINT GetSmallRootId()		 { return IDB_ROOT_SMALL; }
	virtual UINT GetSmallOpenRootId()	 { return IDB_ROOT_SMALL; }
	virtual UINT GetLargeRootId()		 { return IDB_ROOT_LARGE; }
	virtual COLORREF GetLargeColorMask() { return (COLORREF) COLORREF_PINK; } 

};
    

#endif _WINSCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winshand.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winshand.h
		Header file for wins specific base handler classes and query obj

    FILE HISTORY:
        
*/

#ifndef _WINSHAND_H
#define _WINSHAND_H

#ifndef _HANDLERS_H
#include <handlers.h>
#endif

#ifndef _QUERYOBJ_H
#include <queryobj.h>
#endif

extern MMC_CONSOLE_VERB g_ConsoleVerbs[8];
extern MMC_BUTTON_STATE g_ConsoleVerbStates[WINSSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)];
extern MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[WINSSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)];

/*---------------------------------------------------------------------------
	Class:	CHandlerEx
 ---------------------------------------------------------------------------*/
class CHandlerEx
{
// Interface
public:
	virtual HRESULT InitializeNode(ITFSNode * pNode) = 0;
	LPCTSTR GetDisplayName() { return m_strDisplayName; }
	void    SetDisplayName(LPCTSTR pName) { m_strDisplayName = pName; }

private:
	CString m_strDisplayName;
};

/*---------------------------------------------------------------------------
	Class:	CWinsHandler
 ---------------------------------------------------------------------------*/
class CWinsHandler : 
		public CHandler,
		public CHandlerEx
{
public:

	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad
	} nodeStateType;

	CWinsHandler(ITFSComponentData *pCompData) 
        : CHandler(pCompData),
          m_verbDefault(MMC_VERB_OPEN)
	{
	};

	~CWinsHandler() {};

	// base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    // by default we don't allow nodes to be renamed
    OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }

    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    HRESULT HandleScopeCommand(MMC_COOKIE cookie, int nCommandID, LPDATAOBJECT pDataObject);
    HRESULT HandleScopeMenus(MMC_COOKIE	cookie,	LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pContextMenuCallback, long * pInsertionAllowed);

	void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);

    virtual const GUID * GetVirtualGuid(int nIndex) { return NULL; }

protected:
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject, BOOL bVirtual);
    void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);

	virtual DWORD UpdateStatistics(ITFSNode * pNode) { return 0; }

	// This is the default verb, by default it is set to MMC_VERB_OPEN
	MMC_CONSOLE_VERB	m_verbDefault;
};

/*---------------------------------------------------------------------------
	Class:	CMTWinsHandler
 ---------------------------------------------------------------------------*/
class CMTWinsHandler : 
		public CMTHandler,
		public CHandlerEx
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad
	} nodeStateType;

	CMTWinsHandler(ITFSComponentData *pCompData) 
        : CMTHandler(pCompData),
          m_verbDefault(MMC_VERB_OPEN),
          m_fSilent(FALSE),
          m_fExpandSync(FALSE)
	{ 
        m_nState = notLoaded; 
    }
	~CMTWinsHandler() {};

	// base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// by default we don't allow nodes to be renamed
	OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }
    OVERRIDE_BaseHandlerNotify_OnExpandSync();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
	OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    HRESULT HandleScopeCommand(MMC_COOKIE cookie, int nCommandID, LPDATAOBJECT pDataObject);
    HRESULT HandleScopeMenus(MMC_COOKIE	cookie,	LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pContextMenuCallback, long * pInsertionAllowed);
	
    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);
    
    virtual const GUID * GetVirtualGuid(int nIndex) { return NULL; }

	void	ExpandNode(ITFSNode * pNode, BOOL fExpand);

    // any node with taskpads should override this to identify itself
    virtual int   GetTaskpadIndex() { return 0; }

protected:
    virtual void GetErrorInfo(CString & strTitle, CString & strBody, IconIdentifier * pIcon) { };
	virtual void OnChangeState(ITFSNode* pNode);
	virtual void OnHaveData(ITFSNode * pParentNode, ITFSNode * pNewNode)
	{
		if (pNewNode->IsContainer())
		{
			// assume all the child containers are derived from this class
			//((CWinsMTContainer*)pNode)->SetServer(GetServer());
		}
		pParentNode->AddChild(pNewNode);
	}

    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject, BOOL bVirtual);
    void    UpdateStandardVerbs(ITFSNode * pToolbar, LONG_PTR dwNodeType);
    void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);

	// This is the default verb, by default it is set to MMC_VERB_OPEN
	MMC_CONSOLE_VERB	m_verbDefault;

	BOOL		m_bSelected;
    BOOL        m_fSilent;
    BOOL        m_fExpandSync;
};

/*---------------------------------------------------------------------------
	Class:	CWinsQueryObj : general purpose base class
 ---------------------------------------------------------------------------*/
class CWinsQueryObj : public CNodeQueryObject
{
public:
	CWinsQueryObj
	(
		ITFSComponentData *	pTFSCompData, 
		ITFSNodeMgr *		pNodeMgr
	) 
	{
		m_spTFSCompData.Set(pTFSCompData); 
	    m_spNodeMgr.Set(pNodeMgr);
	}

	CQueueDataListBase & GetQueue() { return m_dataQueue; }

public:
	CString				 m_strServer;
	SPITFSComponentData  m_spTFSCompData;
	SPITFSNodeMgr		 m_spNodeMgr;
};

#endif _WINSHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winsmon.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	winsmon.h
		wins monitoring defines
		
    FILE HISTORY:
        
*/


#ifndef _WINSMON_H
#define _WINSMON_H

// wins monitoring stuff
#define		 STR_BUF_SIZE	255      

//
//  WINS related constants
//
#define NM_QRY_XID 0x6DFC

const u_short NBT_NAME_SERVICE_PORT  = htons(137);    // UDP
const int     NBT_NAME_SIZE          = 32;
const int     MAX_NBT_PACKET_SIZE    = 1500;

const WORD NBT_NM_OPC_REQUEST      = 0x0000;
const WORD NBT_NM_OPC_RESPONSE     = 0x0080;

const WORD NBT_NM_OPC_QUERY        = 0x0000;
const WORD NBT_NM_OPC_REGISTRATION = 0x0028;
const WORD NBT_NM_OPC_RELEASE      = 0x0030;
const WORD NBT_NM_OPC_WACK         = 0x0038;
const WORD NBT_NM_OPC_REFRESH      = 0x0040;

//
//  Name Service Flags
//
const WORD NBT_NM_FLG_BCAST        = 0x1000;
const WORD NBT_NM_FLG_RECURS_AVAIL = 0x8000;   
const WORD NBT_NM_FLG_RECURS_DESRD = 0x0001;
const WORD NBT_NM_FLG_TRUNCATED    = 0x0002;
const WORD NBT_NM_FLG_AUTHORITATIV = 0x0004;

//
//  Name Service question types
//
const WORD NBT_NM_QTYP_NB          = 0x2000;
const WORD NBT_NM_QTYP_NBSTAT      = 0x2100;

const WORD NBT_NM_QCLASS_IN        = 0x0100;


typedef struct {
	WORD  xid;
	WORD  flags;
	WORD  question_cnt;
	WORD  answer_cnt;
	WORD  name_serv_cnt;
	WORD  additional_cnt;
} NM_FRAME_HDR;


typedef struct {
	BYTE q_name[NBT_NAME_SIZE+2];
	WORD q_type;
	WORD q_class;
} NM_QUESTION_SECT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winssnap.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winssnap.h
		global defines
		
    FILE HISTORY:
        
*/

#ifndef _WINSSNAP_H
#define _WINSSNAP_H

// message that gets posted to statistics windows to update their stats
#define WM_NEW_STATS_AVAILABLE  WM_USER + 100

// macro to get the handler for a node. This is a WINS snapin specific 
// implementation
#define GETHANDLER(classname, node) (reinterpret_cast<classname *>(node->GetData(TFS_DATA_USER)))

extern const GUID       GUID_WinsServerNodeType;			// Server NodeType GUID
// {90901AF6-7A31-11d0-97E0-00C04FC3357A}
extern const CLSID		CLSID_WinsSnapin ;

// {524CCE97-A886-11d0-AB86-00C04FC3357A}
extern const CLSID		CLSID_WinsSnapinExtension ;

// {1CE57F61-A88A-11d0-AB86-00C04FC3357A}
extern const GUID		CLSID_WinsSnapinAbout;

// {1AE7F339-AA00-11d0-AB88-00C04FC3357A}
extern const GUID		GUID_WinsRootNodeType ;

// {D5A5218E-BD09-11d0-AB96-00C04FC3357A}
extern const GUID		GUID_WinsGenericNodeType ;

extern const GUID		GUID_WinsReplicationNodeType;
// {E220FD88-1FE6-11d1-B967-00C04FBF914A}
extern const GUID		GUID_WinsActiveRegNodeType ;

// {FEC2D41A-2DF7-11d1-B97B-00C04FBF914A}
extern const GUID		GUID_WinsActiveRegistrationLeafNodeType;

// {6A112BB1-4577-11d1-B99F-00C04FBF914A}
extern const GUID		GUID_WinsReplicationPartnerLeafNodeType;

// {CC6473A7-A49C-11d1-BA4D-00C04FBF914A}
extern const GUID		GUID_WinsServerStatusNodeType;

extern const GUID		GUID_WinsServerStatusLeafNodeType;

// {DA1BDD17-8E54-11d1-93DB-00C04FC3357A}
extern const GUID       GUID_NetConsRootNodeType;

extern	const IID		IID_IWinsDatabase;// = {0x7B0C8BBF,0x3117,0x11d1,{0xB9,0x81,0x00,0xC0,0x4F,0xBF,0x91,0x4A}};

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

// Sample folder types
enum NODETYPES
{
// scope pane items
    WINSSNAP_ROOT,
    WINSSNAP_SERVER,
	WINSSNAP_ACTIVE_REGISTRATIONS,
    WINSSNAP_REPLICATION_PARTNERS,

	//StatusRemove
	WINSSNAP_SERVER_STATUS,

	
// result pane items
    WINSSNAP_REGISTRATION,
	WINSSNAP_REPLICATION_PARTNER,
	WINSSNAP_STATUS_LEAF_NODE,
    WINSSNAP_NODETYPE_MAX
};

#define GETIP_FIRST(x)             ((x>>24) & 0xff)
#define GETIP_SECOND(x)            ((x>>16) & 0xff)
#define GETIP_THIRD(x)             ((x>> 8) & 0xff)
#define GETIP_FOURTH(x)            ((x)     & 0xff)

#define INTLTIMESTR(time) (((CIntlTime)(time)).CIntlTime::operator const CString())
#define TMST(x) INTLTIMESTR(x)


// wait cursor stuff around functions.  If you need a wait cursor for 
// and entire fucntion, just use CWaitCursor.  To wrap a wait cursor
// around an rpc call, use these macros.
#define BEGIN_WAIT_CURSOR   {  CWaitCursor waitCursor;
#define RESTORE_WAIT_CURSOR    waitCursor.Restore();
#define END_WAIT_CURSOR     }


// Defines for help from the help menu and F1 help for scope pane items
#define WINSSNAP_HELP_BASE							0xA0000000
#define WINSSNAP_HELP_SNAPIN						WINSSNAP_HELP_BASE + 1
#define WINSSNAP_HELP_ROOT							WINSSNAP_HELP_BASE + 2
#define WINSSNAP_HELP_SERVER						WINSSNAP_HELP_BASE + 3
#define WINSSNAP_HELP_ACT_REG_NODE				    WINSSNAP_HELP_BASE + 4
#define WINSSNAP_HELP_REP_PART_NODE				    WINSSNAP_HELP_BASE + 5
#define WINSSNAP_HELP_ACTREG_ENTRY					WINSSNAP_HELP_BASE + 6
#define WINSSNAP_HELP_REP_PART_ENTRY				WINSSNAP_HELP_BASE + 7


class CWinsSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
    int     MessageBox (UINT nIdPrompt, UINT nType = MB_OK, UINT nHelpContext = -1);
    int     MessageBox (LPCTSTR pPrefixText, UINT nIdPrompt, UINT nType = MB_OK, UINT nHelpContext = -1);
    DWORD   GetSystemMessage(UINT nId, TCHAR * chBuffer, int cbBuffSize);

public:
	BOOL m_bWinsockInited;
};

extern CWinsSnapinApp theApp;

// help stuff here
typedef CMap<UINT, UINT, DWORD *, DWORD *> CWinsContextHelpMap;
extern CWinsContextHelpMap g_winsContextHelpMap;

#define WINSSNAP_NUM_HELP_MAPS  33

extern DWORD * WinsGetHelpMap(UINT uID);


#endif //_WINSSNAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winssup.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winsup.cpp
		Global functions

	FILE HISTORY:


*/

#include "stdafx.h"
#include "winssup.h"
#include "tregkey.h"
#include "resource.h"
#include "wins.h"
#include <clusapi.h>
#include "..\tfscore\cluster.h"

const TCHAR g_szPipeName[] = _T("\\pipe\\WinsPipe");
const TCHAR g_szDefaultHelpTopic[] = _T("\\help\\winsconcepts.chm::/sag_WINStopnode.htm");

/*---------------------------------------------------------------------------
	SendTrigger()
		Sends a pull or push replication trigger to a given wins server
---------------------------------------------------------------------------*/
DWORD
SendTrigger
(
	handle_t hWins,
    LONG     ipTarget,
    BOOL     fPush,
    BOOL     fPropagate
)
{
    DWORD           dwStatus;
    WINSINTF_ADD_T  WinsAdd;
    
    WinsAdd.Len  = 4;
    WinsAdd.Type = 0;
    WinsAdd.IPAdd  = ipTarget;

	WINSINTF_TRIG_TYPE_E	TrigType;

    TrigType = fPush ? (fPropagate ? WINSINTF_E_PUSH_PROP : WINSINTF_E_PUSH) : WINSINTF_E_PULL;

#ifdef WINS_CLIENT_APIS
    dwStatus = ::WinsTrigger(hWins,
		                     &WinsAdd, 
                             TrigType);
#else
	dwStatus = ::WinsTrigger(&WinsAdd, 
		                     TrigType);
#endif WINS_CLIENT_APIS
    
    return dwStatus;
}


/*---------------------------------------------------------------------------
	ControlWINSService(LPCTSTR pszName, BOOL bStop)
		Stops ot starts the WINS service on the local machine
---------------------------------------------------------------------------*/
DWORD ControlWINSService(LPCTSTR pszName, BOOL bStop)
{
    DWORD           dwState = bStop ? SERVICE_STOPPED : SERVICE_RUNNING;
    DWORD           dwPending = bStop ? SERVICE_STOP_PENDING : SERVICE_START_PENDING;
    DWORD           err = ERROR_SUCCESS;
	int             i;
    SERVICE_STATUS  ss;
    DWORD           dwControl;
    BOOL            fSuccess;
	SC_HANDLE       hService = NULL;
    SC_HANDLE       hScManager = NULL;

	// oepmnt he service control manager
    hScManager = ::OpenSCManager(pszName, NULL, SC_MANAGER_ALL_ACCESS);
    if (hScManager == NULL)
    {
        err = ::GetLastError();
        Trace1("ControlWINSService - OpenScManager failed! %d\n", err);
        goto Error;
    }

	// get the handle to the WINS service
    hService = OpenService(hScManager, _T("WINS"), SERVICE_ALL_ACCESS);
    if (hService == NULL)
    {
        err = ::GetLastError();
        Trace1("ControlWINSService - OpenService failed! %d\n", err);
        goto Error;
    }

	// if stop requested
	if (bStop)
	{
		dwControl = SERVICE_CONTROL_STOP;
		fSuccess = ::ControlService(hService, dwControl, &ss);
	    if (!fSuccess)
	    {
	        err = ::GetLastError();
            Trace1("ControlWINSService - ControlService failed! %d\n", err);
            goto Error;
	    }
    }
	// otherwise start the service
	else
	{
		fSuccess = ::StartService(hService, 0, NULL);
	    if (!fSuccess)
	    {
	        err = ::GetLastError();
            Trace1("ControlWINSService - StartService failed! %d\n", err);
            goto Error;
	    }
	}

#define LOOP_TIME   5000
#define NUM_LOOPS   600

    // wait for the service to start/stop.  
    for (i = 0; i < NUM_LOOPS; i++)
    {
        ::QueryServiceStatus(hService, &ss);

        // check to see if we are done
        if (ss.dwCurrentState == dwState)
        {
            int time = LOOP_TIME * i;
            Trace1("ControlWINSService - service stopped/started in approx %d ms!\n", time);
            break;
        }
        
        // now see if something bad happened
        if (ss.dwCurrentState != dwPending)
        {
            int time = LOOP_TIME * i;
            Trace1("ControlWINSService - service stop/start failed in approx %d ms!\n", time);
            break;
        }

        Sleep(LOOP_TIME);
    }

    if (i == NUM_LOOPS)
        Trace0("ControlWINSService - service did NOT stop/start in wait period!\n");

    if (ss.dwCurrentState != dwState)
        err = ERROR_SERVICE_REQUEST_TIMEOUT;

Error:
    // close the respective handles
	if (hService)
        ::CloseServiceHandle(hService);

    if (hScManager)
        ::CloseServiceHandle(hScManager);

	return err;
}





/*---------------------------------------------------------------------------
	GetNameIP(	const CString &strDisplay, 
				CString &strName, 
				CString &strIP)
		Returns the Server name and the IP Address string with the 
		group name
 ---------------------------------------------------------------------------*/
void 
GetNameIP
(
  const CString &strDisplay, 
  CString &strName, 
  CString &strIP
)
{
	CString strTemp = strDisplay;

	// find '['
	int nPos = strDisplay.Find(_T("["));

	// left of the positioncontains the name and right of it has the IP address

	// 1 to take care of the space before '['
	strName = strDisplay.Left(nPos-1);

	strIP = strDisplay.Right(strDisplay.GetLength() - nPos);

	// take out '[' and ']' in strIP

	int npos1 = strIP.Find(_T("["));
	int npos2 = strIP.Find(_T("]"));

	strIP = strIP.Mid(npos1+1, npos2-npos1-1);

	return;
}


/*---------------------------------------------------------------------------
	WideToMBCS()
		converts WCS to MBCS string

        NOTE: the caller of this function must make sure that szOut is big
              enough to hold any possible string in strIn.
 ---------------------------------------------------------------------------*/
DWORD 
WideToMBCS(CString & strIn, LPSTR szOut, UINT uCodePage, DWORD dwFlags, BOOL * pfDefaultUsed)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fDefaultCharUsed = FALSE;

    int nNumBytes = ::WideCharToMultiByte(uCodePage,
					                        dwFlags,
					                        strIn, 
					                        -1,
					                        szOut,
                                            0,
					                        NULL,
					                        &fDefaultCharUsed);
 
    dwErr = ::WideCharToMultiByte(uCodePage,
                                 dwFlags,
                                 strIn,
                                 -1,
                                 szOut,
                                 nNumBytes,
                                 NULL,
                                 &fDefaultCharUsed);

    szOut[nNumBytes] = '\0';

    if (pfDefaultUsed)
       *pfDefaultUsed = fDefaultCharUsed;

    return dwErr;
}

/*---------------------------------------------------------------------------
	MBCSToWide ()
		converts MBCS to Wide string
 ---------------------------------------------------------------------------*/
DWORD 
MBCSToWide(LPSTR szIn, CString & strOut, UINT uCodePage, DWORD dwFlags)
{
    DWORD dwErr = ERROR_SUCCESS;

    LPTSTR pBuf = strOut.GetBuffer(MAX_PATH * 2);
    ZeroMemory(pBuf, MAX_PATH * 2);

    
    dwErr = ::MultiByteToWideChar(uCodePage, 
                                  dwFlags, 
                                  szIn, 
                                  -1, 
                                  pBuf, 
                                  MAX_PATH * 2);

    strOut.ReleaseBuffer();

    return dwErr;
}

LONG 
GetSystemMessageA
(
    UINT	nId,
    CHAR *	chBuffer,
    int		cbBuffSize 
)
{
    CHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
        | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges, as well as
    //  WINS server error messages.
    //

    if( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = LoadLibrary( _T("netmsg.dll") );
    }
    else
	if( nId >= 0x40000000L )
    {
        hdll = LoadLibrary( _T("ntdll.dll") );
    }

    if( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    //  Let FormatMessage do the dirty work.
    //
    DWORD dwResult = ::FormatMessageA( flags,
                      (LPVOID) hdll,
                      nId,
                      0,
                      chBuffer,
                      cbBuffSize,
                      NULL ) ;

    if( hdll != NULL )
    {
        LONG err = GetLastError();
        FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? ERROR_SUCCESS : ::GetLastError() ;
}

LONG 
GetSystemMessage 
(
    UINT	nId,
    TCHAR *	chBuffer,
    int		cbBuffSize 
)
{
    TCHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
        | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges, as well as
    //  WINS server error messages.
    //

    if( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = LoadLibrary( _T("netmsg.dll") );
    }
    else
	if( nId >= 0x40000000L )
    {
        hdll = LoadLibrary( _T("ntdll.dll") );
    }

    if( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    //  Let FormatMessage do the dirty work.
    //
    DWORD dwResult = ::FormatMessage( flags,
                      (LPVOID) hdll,
                      nId,
                      0,
                      chBuffer,
                      cbBuffSize,
                      NULL ) ;

    if( hdll != NULL )
    {
        LONG err = GetLastError();
        FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? ERROR_SUCCESS : ::GetLastError() ;
}


/*!--------------------------------------------------------------------------
	LoadMessage
		Loads the error message from the correct DLL.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
LoadMessage 
(
    UINT	nIdPrompt,
    TCHAR *	chMsg,
    int		nMsgSize
)
{
    BOOL bOk;

    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
    if (nIdPrompt == EPT_S_NOT_REGISTERED ||
        nIdPrompt == RPC_S_SERVER_UNAVAILABLE)
    {
        nIdPrompt = IDS_ERR_WINS_DOWN;
    }

    //
    //  If it's a socket error or our error, the text is in our resource fork.
    //  Otherwise, use FormatMessage() and the appropriate DLL.
    //
    if (    (nIdPrompt >= IDS_ERR_BASE && nIdPrompt < IDS_MSG_LAST)  )
    {
        //
        //  It's in our resource fork
        //
        bOk = ::LoadString( AfxGetInstanceHandle(), nIdPrompt, chMsg, nMsgSize / sizeof(TCHAR) ) != 0 ;
    }
    else
    {
        //
        //  It's in the system somewhere.
        //
        bOk = GetSystemMessage( nIdPrompt, chMsg, nMsgSize ) == 0 ;
    }

    if (bOk && nIdPrompt == ERROR_ACCESS_DENIED)
    {
        // tack on our extra help to explain different acess levels 
        CString strAccessDeniedHelp;

        strAccessDeniedHelp.LoadString(IDS_ACCESS_DENIED_HELP);

        lstrcat(chMsg, _T("\n\n"));
        lstrcat(chMsg, strAccessDeniedHelp);
    }

    //
    //  If the error message did not compute, replace it.
    //
    if ( ! bOk ) 
    {
        TCHAR chBuff [STRING_LENGTH_MAX] ;
        static const TCHAR * pszReplacement = _T("System Error: %ld");
        const TCHAR * pszMsg = pszReplacement ;

        //
        //  Try to load the generic (translatable) error message text
        //
        if ( ::LoadString( AfxGetInstanceHandle(), IDS_ERR_MESSAGE_GENERIC, 
            chBuff, STRING_LENGTH_MAX ) != 0 ) 
        {
            pszMsg = chBuff ;
        }
        ::wsprintf( chMsg, pszMsg, nIdPrompt ) ;
    }

    return bOk;
}


/*!--------------------------------------------------------------------------
	WinsMessageBox
		Puts up a message box with the corresponding error text.
	Author: EricDav
 ---------------------------------------------------------------------------*/
int WinsMessageBox(UINT nIdPrompt, 
 				   UINT nType , 
				   const TCHAR * pszSuffixString,
				   UINT nHelpContext)
{
	TCHAR chMesg [4000] ;
    BOOL bOk ;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(TCHAR));
    if ( pszSuffixString ) 
    {
        ::lstrcat( chMesg, _T("  ") ) ;
        ::lstrcat( chMesg, pszSuffixString ) ; 
    }

    return ::AfxMessageBox( chMesg, nType, nHelpContext ) ;
}

/*!--------------------------------------------------------------------------
	WinsMessageBoxEx
		Puts up a message box with the corresponding error text.
	Author: EricDav
 ---------------------------------------------------------------------------*/
int 
WinsMessageBoxEx
(
    UINT        nIdPrompt,
    LPCTSTR     pszPrefixMessage,
    UINT        nType,
    UINT        nHelpContext
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR       chMesg[4000];
    CString     strMessage;
    BOOL        bOk;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(TCHAR));
    if ( pszPrefixMessage ) 
    {
        strMessage = pszPrefixMessage;
        strMessage += _T("\n");
        strMessage += _T("\n");
        strMessage += chMesg;
    }
    else
    {
        strMessage = chMesg;
    }

    return AfxMessageBox(strMessage, nType, nHelpContext);
}


// class NameTypeMapping handlers

/*!--------------------------------------------------------------------------
	MapDWORDToCString
		Generic mapping of a DWORD to a CString. 
		dwNameType is the 16th byte of the name.
		dwWinsType is Unique, multihomed, group, etc...
	Author: KennT
 ---------------------------------------------------------------------------*/
void MapDWORDToCString(DWORD dwNameType, DWORD dwWinsType, const CStringMapArray * pMap, CString & strName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CStringMapEntry mapEntry;

	for (int i = 0; i < pMap->GetSize(); i++)
	{
        mapEntry = pMap->GetAt(i);

		// break out if this is the correct type and the wins type
		// matches or is a don't care
		if ( (mapEntry.dwNameType == dwNameType) &&
			 ( (mapEntry.dwWinsType == -1) ||
			   (mapEntry.dwWinsType == dwWinsType) ) )
		{
            break;
		}

        mapEntry.dwNameType = 0xFFFFFFFF;
	}
	
    if (mapEntry.dwNameType == 0xFFFFFFFF)
    {
        MapDWORDToCString(NAME_TYPE_OTHER, dwWinsType, pMap, strName);
    }
    else
    {
        if (mapEntry.st.IsEmpty())
		    Verify(pMap->GetAt(i).st.LoadString(mapEntry.ulStringId));

        strName = pMap->GetAt(i).st;
    }
}

// this structure allows us to map name types to strings.  The secondary
// check is based on the wins defined record type.  In order for this to work
// correctly, place any names that need to be defined with the wins type before
// the entry with the wins type set to -1.
static const UINT s_NameTypeMappingDefault[NUM_DEFAULT_NAME_TYPES][3] =
{
	{ NAME_TYPE_WORKSTATION,		WINSINTF_E_NORM_GROUP,	IDS_NAMETYPE_MAP_WORKGROUP },
	{ NAME_TYPE_WORKSTATION,		-1,						IDS_NAMETYPE_MAP_WORKSTATION },
	{ NAME_TYPE_DC,					-1,						IDS_NAMETYPE_MAP_DC },
	{ NAME_TYPE_FILE_SERVER,		WINSINTF_E_SPEC_GROUP,	IDS_NAMETYPE_MAP_SPECIAL_INTERNET_GROUP },
	{ NAME_TYPE_FILE_SERVER,		-1,						IDS_NAMETYPE_MAP_FILE_SERVER },
	{ NAME_TYPE_DMB	,				-1,						IDS_NAMETYPE_MAP_DMB },
	{ NAME_TYPE_OTHER,				-1,						IDS_NAMETYPE_MAP_OTHER },
	{ NAME_TYPE_NETDDE,				-1,						IDS_NAMETYPE_MAP_NETDDE },
	{ NAME_TYPE_MESSENGER,			-1,						IDS_NAMETYPE_MAP_MESSENGER },
	{ NAME_TYPE_RAS_SERVER,			-1,						IDS_NAMETYPE_MAP_RAS_SERVER },
	{ NAME_TYPE_NORM_GRP_NAME,		-1,						IDS_NAMETYPE_MAP_NORMAL_GROUP_NAME },
	{ NAME_TYPE_WORK_NW_MON_AGENT,	-1,						IDS_NAMETYPE_MAP_NW_MON_AGENT },
	{ NAME_TYPE_WORK_NW_MON_NAME,	-1,						IDS_NAMETYPE_MAP_NMN},
};

const NameTypeMapping::REGKEYNAME NameTypeMapping::c_szNameTypeMapKey = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\NameTypeMap");
const NameTypeMapping::REGKEYNAME NameTypeMapping::c_szDefault= _T("(Default)");

NameTypeMapping ::NameTypeMapping()
{
}

NameTypeMapping ::~NameTypeMapping()
{
	Unload();
}

void
NameTypeMapping ::SetMachineName(LPCTSTR pszMachineName)
{
    m_strMachineName = pszMachineName;
}

HRESULT NameTypeMapping::Load()
{
	HRESULT		hr = hrOK;
	RegKey		regkey;
	RegKey		regkeyMachine;
	HKEY		hkeyMachine = HKEY_LOCAL_MACHINE;
	RegKey::CREGKEY_KEY_INFO	regkeyInfo;
	RegKeyIterator	regkeyIter;
	UINT		i;
	WORD		langID;
	RegKey		regkeyProto;
	DWORD		dwErr;
    CStringMapEntry mapEntry;

	::ZeroMemory(&regkeyInfo, sizeof(regkeyInfo));
	
	// Look for the registry key
	if (FHrSucceeded(hr))
		hr = HRESULT_FROM_WIN32( regkey.Open(hkeyMachine, c_szNameTypeMapKey, KEY_READ, m_strMachineName) );

    // Get the count of items
	if (FHrSucceeded(hr))
		hr = HRESULT_FROM_WIN32( regkey.QueryKeyInfo(&regkeyInfo) );
	
	// Alloc the array for the count of items + default items
	Unload();

	// Read in the registry data and add it to the internal array

    //
	// enumerate the keys
	//
	if (FHrSucceeded(hr))
		hr = regkeyIter.Init(&regkey);
		
	if (FHrSucceeded(hr))
	{
		HRESULT	hrIter;
		DWORD	dwProtoId;
		CString	stKey;
		CString	stLang;
		
		// Now that we have this key, look for the language id
		langID = GetUserDefaultLangID();
		stLang.Format(_T("%04x"), (DWORD)langID);
							
		for (hrIter = regkeyIter.Next(&stKey, NULL); hrIter == hrOK; hrIter = regkeyIter.Next(&stKey, NULL))
		{
			CString	st;
			
			// Given the name of the key, that is a hex value (the protocol id)
			// Convert that into a DWORD
			dwProtoId = _tcstoul((LPCTSTR) stKey, NULL, 16);

			// Open this key
			regkeyProto.Close();
			dwErr = regkeyProto.Open(regkey, stKey);
			if (!FHrSucceeded(HRESULT_FROM_WIN32(dwErr)))
				continue;

			// Ok, get the name value
			dwErr = regkeyProto.QueryValue(stLang, st);
			if (!FHrSucceeded(HRESULT_FROM_WIN32(dwErr)))
			{
				// Look for the key with the name of default
				dwErr = regkeyProto.QueryValue(c_szDefault, st);
			}

			if (FHrSucceeded(HRESULT_FROM_WIN32(dwErr)))
			{
				// Ok, add this value to the list
				mapEntry.dwNameType = dwProtoId;
				mapEntry.st = st;
				mapEntry.ulStringId = 0;

                Add(mapEntry);
			}
		}
	}

	// Read in the default item data and add it to the array
	for (i = 0; i < DimensionOf(s_NameTypeMappingDefault); i++)
	{
        mapEntry.dwNameType = s_NameTypeMappingDefault[i][0];
        mapEntry.dwWinsType = s_NameTypeMappingDefault[i][1];
		mapEntry.st.LoadString(s_NameTypeMappingDefault[i][2]);
		mapEntry.ulStringId = 0;

        Add(mapEntry);
	}
	
	return hrOK;
}

void NameTypeMapping::Unload()
{
    RemoveAll();   
}

void NameTypeMapping::TypeToCString(DWORD dwProtocolId, DWORD dwRecordType, CString & strName)
{
	MapDWORDToCString(dwProtocolId, dwRecordType, this, strName);
}

// add in the new id/name
HRESULT NameTypeMapping::AddEntry(DWORD dwProtocolId, LPCTSTR pstrName)
{
    HRESULT     hr = hrOK;
	RegKey		regkey;
    RegKey      regkeyID;
    HKEY		hkeyMachine = HKEY_LOCAL_MACHINE;
	WORD		langID;
    CStringMapEntry mapEntry;
    CString     stID, stLang, stNew;

	// Look for the registry key
	if (FHrSucceeded(hr))
		hr = HRESULT_FROM_WIN32( regkey.Create(hkeyMachine, c_szNameTypeMapKey, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strMachineName) );

	// build our new ID string
	stID.Format(_T("%04x"), (DWORD) dwProtocolId);

	// Now that we have this key, look for the language id
	langID = GetUserDefaultLangID();
	stLang.Format(_T("%04x"), (DWORD)langID);

    stNew = c_szNameTypeMapKey + _T("\\") + stID;

    // create the ID key
	if (FHrSucceeded(hr))
		hr = HRESULT_FROM_WIN32( regkeyID.Create(hkeyMachine, stNew, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strMachineName) );

	// set the name value
    if (FHrSucceeded(hr))
        hr = HRESULT_FROM_WIN32( regkeyID.SetValue(stLang, pstrName) );

	if (FHrSucceeded(hr))
    {
        // add to internal list
		mapEntry.dwNameType = dwProtocolId;
		mapEntry.st = pstrName;
		mapEntry.ulStringId = 0;

        Add(mapEntry);
    }

    return hr;
}

// modify the given ID's string name
HRESULT NameTypeMapping::ModifyEntry(DWORD dwProtocolId, LPCTSTR pstrName)
{
    HRESULT     hr = hrOK;
	RegKey		regkey;
    RegKey      regkeyID;
    HKEY		hkeyMachine = HKEY_LOCAL_MACHINE;
	int 		i;
	WORD		langID;
    CString     stID, stLang, stNew;

	// Look for the registry key
	if (FHrSucceeded(hr))
		hr = HRESULT_FROM_WIN32( regkey.Open(hkeyMachine, c_szNameTypeMapKey, KEY_READ, m_strMachineName) );

	// build our new ID string
	stID.Format(_T("%04x"), (DWORD) dwProtocolId);

    stNew = c_szNameTypeMapKey + _T("\\") + stID;

    // open the correct ID key
	if (FHrSucceeded(hr))
		hr = HRESULT_FROM_WIN32( regkeyID.Open(hkeyMachine, stNew, KEY_ALL_ACCESS, m_strMachineName) );

	// Now that we have this key, look for the language id
	langID = GetUserDefaultLangID();
	stLang.Format(_T("%04x"), (DWORD)langID);

    // set the new value
    if (FHrSucceeded(hr))
        hr = HRESULT_FROM_WIN32( regkeyID.SetValue(stLang, pstrName) );

	if (FHrSucceeded(hr))
    {
        // modify the internal list
		for (i = 0; i < GetSize(); i++)
        {
            if (GetAt(i).dwNameType == dwProtocolId)
            {
                m_pData[i].st = pstrName;
                break;
            }
        }
    }

    return hr;
}

// remove the given ID's string name
HRESULT NameTypeMapping::RemoveEntry(DWORD dwProtocolId)
{
    HRESULT     hr = hrOK;
	RegKey		regkey;
    HKEY		hkeyMachine = HKEY_LOCAL_MACHINE;
	int 		i;
    CString     stID;

	// Look for the registry key
	if (FHrSucceeded(hr))
		hr = HRESULT_FROM_WIN32( regkey.Open(hkeyMachine, c_szNameTypeMapKey, KEY_READ, m_strMachineName) );

	// build our new ID string
	stID.Format(_T("%04x"), (DWORD) dwProtocolId);

    // set the new value
    if (FHrSucceeded(hr))
        hr = HRESULT_FROM_WIN32( regkey.RecurseDeleteKey(stID) );

	if (FHrSucceeded(hr))
    {
        // modify the internal list
		for (i = 0; i < GetSize(); i++)
        {
            if (GetAt(i).dwNameType == dwProtocolId)
            {
                RemoveAt(i);
                break;
            }
        }
    }

    return hr;
}


BOOL        
NameTypeMapping::EntryExists(DWORD dwProtocolId)
{
    BOOL fExists = FALSE;

    for (int i = 0; i < GetSize(); i++)
    {
        if (GetAt(i).dwNameType == dwProtocolId)
        {
            fExists = TRUE;
            break;
        }
    }

    return fExists;
}

/*---------------------------------------------------------------------------
		CleanString(CString& str)
		Strip leading and trailing spaces from the string.
---------------------------------------------------------------------------*/
CString&
CleanString(
    CString& str
    )
{
    if (str.IsEmpty())
    {
        return str ;
    }
    int n = 0;
    while ((n < str.GetLength()) && (str[n] == ' '))
    {
        ++n;
    }

    if (n)
    {
        str = str.Mid(n);
    }
    n = str.GetLength();
    while (n && (str[--n] == ' '))
    {
        str.ReleaseBuffer(n);
    }

    return str;
}

/*---------------------------------------------------------------------------
	IsValidNetBIOSName
		Determine if the given netbios is valid, and pre-pend
		a double backslash if not already present (and the address
		is otherwise valid).	
---------------------------------------------------------------------------*/
BOOL
IsValidNetBIOSName(
    CString & strAddress,
    BOOL fLanmanCompatible,
    BOOL fWackwack // expand slashes if not present
    )
{
    TCHAR szWacks[] = _T("\\\\");

    if (strAddress.IsEmpty())
    {
        return FALSE;
    }

    if (strAddress[0] == _T('\\'))
    {
        if (strAddress.GetLength() < 3)
        {
            return FALSE;
        }

        if (strAddress[1] != _T('\\'))
        {
            // One slash only?  Not valid
            return FALSE;
        }
    }
    else
    {
        if (fWackwack)
        {
            // Add the backslashes
            strAddress = szWacks + strAddress;
        }
    }

    int nMaxAllowedLength = fLanmanCompatible
        ? LM_NAME_MAX_LENGTH
        : NB_NAME_MAX_LENGTH;

    if (fLanmanCompatible)
    {
        strAddress.MakeUpper();
    }

    return strAddress.GetLength() <= nMaxAllowedLength + 2;
}

/*---------------------------------------------------------------------------
	IsValidDomain
 
       Determine if the given domain name address is valid, and clean
       it up, if necessary
---------------------------------------------------------------------------*/
BOOL
IsValidDomain(CString & strDomain)
{
/*    int nLen;

    if ((nLen = strDomain.GetLength()) != 0)
    {
        if (nLen < DOMAINNAME_LENGTH)  // 255
        {
            int i;
            int istr = 0;
            TCHAR ch;
            BOOL fLet_Dig = FALSE;
            BOOL fDot = FALSE;
            int cHostname = 0;

            for (i = 0; i < nLen; i++)
            {
                // check each character
                ch = strDomain[i];

                BOOL fAlNum = iswalpha(ch) || iswdigit(ch);

                if (((i == 0) && !fAlNum) ||
                        // first letter must be a digit or a letter
                    (fDot && !fAlNum) ||
                        // first letter after dot must be a digit or a letter
                    ((i == (nLen - 1)) && !fAlNum) ||
                        // last letter must be a letter or a digit
                    (!fAlNum && ( ch != _T('-') && ( ch != _T('.') && ( ch != _T('_'))))) ||
                        // must be letter, digit, - or "."
                    (( ch == _T('.')) && ( !fLet_Dig )))
                        // must be letter or digit before '.'
                {
                    return FALSE;
                }
                fLet_Dig = fAlNum;
                fDot = (ch == _T('.'));
                cHostname++;
                if ( cHostname > HOSTNAME_LENGTH )
                {
                    return FALSE;
                }
                if ( fDot )
                {
                    cHostname = 0;
                }
            }
        }
    } 
*/
    return TRUE;
}

/*---------------------------------------------------------------------------
	IsValidIpAddress
 
		Determine if the given IP address is valid, and clean
		it up, if necessary
 ---------------------------------------------------------------------------*/
BOOL
IsValidIpAddress(CString & strAddress)
{
    if (strAddress.IsEmpty())
    {
        return FALSE;
    }

    CIpAddress ia(strAddress);
    BOOL fValid = ia.IsValid();
    if (fValid)
    {
        // Fill out the IP address string for clarity
        strAddress = ia;
        return TRUE;
    }

    return FALSE;
}


/*---------------------------------------------------------------------------
	IsValidAddress
		Determine if the given address is a valid NetBIOS or
		TCP/IP address, judging by the name only.  Note that
		validation may clean up the given string
		NetBIOS names not beginning with "\\" will have those characters
		pre-pended, and otherwise valid IP Addresses are filled out to
		4 octets.
        Leading and trailing spaces are removed from the string.
  --------------------------------------------------------------------------*/
BOOL
IsValidAddress(
				CString& strAddress,
				BOOL * fIpAddress,
				BOOL fLanmanCompatible,
				BOOL fWackwack          // expand netbios slashes
			  )
{
    int i;

    // Remove leading and trailing spaces
    CleanString(strAddress);

    if (strAddress.IsEmpty()) {
        *fIpAddress = FALSE;
        return FALSE;
    }
    
	if (strAddress[0] == _T('\\')) {
        *fIpAddress = FALSE;
        return IsValidNetBIOSName(strAddress, fLanmanCompatible, fWackwack);
    }

    if (IsValidIpAddress(strAddress)) 
	{
        *fIpAddress = TRUE;
        return TRUE;
    } 
	else 
	{
        *fIpAddress = FALSE;
    }
    if (IsValidDomain (strAddress)) {
        return TRUE;
    }

    // last chance, maybe its a NetBIOS name w/o wackwack
    return IsValidNetBIOSName(strAddress, fLanmanCompatible, fWackwack);
}

/*---------------------------------------------------------------------------
	VerifyWinsServer(CString& strServer,CString& strIP)
		Called if the server is not coonected yet, gets the name and 
		IP address od the server
	Author:v-shubk
---------------------------------------------------------------------------*/
/*
DWORD 
VerifyWinsServer(CString &strAddress, CString &strServerName, DWORD & dwIP)
{
	CString strNameIP = strAddress;
	BOOL fIp;
	DWORD err = ERROR_SUCCESS;

	if (IsValidAddress(strNameIP, &fIp, TRUE, TRUE))
	{
		CWinsServerObj ws(NULL,"", TRUE, TRUE);

		if (fIp) 
        {
    		// IP address specified
		    ws = CWinsServerObj(CIpAddress(strNameIP), "", TRUE, TRUE);
        }
        else 
		{
    		// machine name specified
			ws = CWinsServerObj(CIpAddress(), strNameIP, TRUE, TRUE);
        }

		WINSINTF_BIND_DATA_T    wbdBindData;
		handle_t                hBinding = NULL;
		WINSINTF_ADD_T          waWinsAddress;
        char                    szNetBIOSName[256] = {0};

		do
		{
			// First attempt to bind to the new address
			wbdBindData.fTcpIp = ws.GetNetBIOSName().IsEmpty();
			CString strTempAddress;

			if (wbdBindData.fTcpIp)
			{
				strTempAddress = ((CString)ws.GetIpAddress());
			}
			else
			{
				//strTempAddress = _T("\\\\") + ws.GetNetBIOSName();

                CString tmp;

                tmp = ws.GetNetBIOSName();

                if  ( (tmp[0] == _T('\\')) && (tmp[1] == _T('\\')) )
                    strTempAddress = ws.GetNetBIOSName();
                else
                    strTempAddress = _T("\\\\") + ws.GetNetBIOSName(); 
			}

            wbdBindData.pPipeName = wbdBindData.fTcpIp ? NULL : (LPSTR) g_szPipeName;
			wbdBindData.pServerAdd = (LPSTR) (LPCTSTR) strTempAddress;

			if ((hBinding = ::WinsBind(&wbdBindData)) == NULL)
			{
				err = ::GetLastError();
				break;
			}

#ifdef WINS_CLIENT_APIS
			err = ::WinsGetNameAndAdd(hBinding, 
				                      &waWinsAddress,
				                      (LPBYTE) szNetBIOSName);
#else
			err = ::WinsGetNameAndAdd(&waWinsAddress,
				                      (LPBYTE) szNetBIOSName);
#endif WINS_CLIENT_APIS

		}
		while (FALSE);

		if (err == ERROR_SUCCESS)
		{
			// Always use the IP address used for connection
            // if we went over tcpip (not the address returned
            // by the WINS service.
            if (wbdBindData.fTcpIp)
            {
                CIpNamePair ip(ws.GetIpAddress(), szNetBIOSName);
                ws = ip;
			}
            else
            {
                CIpNamePair ip(waWinsAddress.IPAdd, szNetBIOSName);
                ws = ip;
			}

            // convert the dbcs netbios name to wide char
            WCHAR szTempIP[20] = {0};

			int nNumBytes = MultiByteToWideChar(CP_ACP, 
												0, 
												szNetBIOSName,
												-1,
												szTempIP, 
												20); 
            // now fill in the name for return
            strServerName = szTempIP;

            // fill in the IP
            dwIP = (LONG) ws.QueryIpAddress();
        }

		if (hBinding)
		{
			// call winsunbind here, No more WINS apis called atfer this
			WinsUnbind(&wbdBindData, hBinding);
			hBinding = NULL;
		}
	}
	
    return err;
}
*/

/*---------------------------------------------------------------------------
	VerifyWinsServer(CString& strServer,CString& strIP)
		Called if the server is not coonected yet, gets the name and 
		IP address od the server
	Author: ericdav
---------------------------------------------------------------------------*/
DWORD 
VerifyWinsServer(CString &strAddress, CString &strServerName, DWORD & dwIP)
{
	CString strNameIP = strAddress;
	BOOL fIp;
	DWORD err = ERROR_SUCCESS;

	if (IsValidAddress(strNameIP, &fIp, TRUE, TRUE))
	{
		CWinsServerObj ws(NULL, "", TRUE, TRUE);

		if (fIp) 
        {
            BOOL bIsCluster = ::FIsComputerInRunningCluster(strNameIP);

    		// IP address specified
		    ws = CWinsServerObj(CIpAddress(strNameIP), "", TRUE, TRUE);

            // if the ip address given to us is a cluster address..
            if (bIsCluster)
            {
                err = GetClusterInfo(
                        strNameIP,
                        strServerName,
                        &dwIP);
                if (err == ERROR_SUCCESS)
                {
                    DWORD dwCheckIP;

                    err = GetHostAddress(strServerName, &dwCheckIP);
                    if (dwCheckIP != dwIP)
                    {
                        bIsCluster = FALSE;
                    }
                }
            }

            // this is not a cluster address
            if (!bIsCluster)
            {
                err = GetHostName((LONG) ws.GetIpAddress(), strServerName);
                if (err == ERROR_SUCCESS)
                {
                    if (strServerName.IsEmpty())
                    {
                        err = DNS_ERROR_NAME_DOES_NOT_EXIST;
                    }
                    else
                    {
                        // just want the host name
                        int nDot = strServerName.Find('.');
                        if (nDot != -1)
                        {
                            strServerName = strServerName.Left(nDot);
                        }
                    }

                    dwIP = (LONG) ws.GetIpAddress();
                }
            }
        }
        else 
		{
    		// machine name specified
			ws = CWinsServerObj(CIpAddress(), strNameIP, TRUE, TRUE);

            err = GetHostAddress(strNameIP, &dwIP);
            if (err == ERROR_SUCCESS)
            {
                // just want the host name
                int nDot = strNameIP.Find('.');
                if (nDot != -1)
                {
                    strServerName = strNameIP.Left(nDot);
                }
                else
                {
                    strServerName = strNameIP;
                }
            }
        }
    }

    return err;
}

void MakeIPAddress(DWORD dwIP, CString & strIP)
{
	CString strTemp;
	
    DWORD   dwFirst = GETIP_FIRST(dwIP);
	DWORD   dwSecond = GETIP_SECOND(dwIP);
	DWORD   dwThird = GETIP_THIRD(dwIP);
	DWORD   dwLast = GETIP_FOURTH(dwIP);

    strIP.Empty();

	// wrap it into CString object
    TCHAR szStr[20] = {0};

	_itot(dwFirst, szStr, 10);
    strTemp = szStr;
    strTemp += _T(".");

	_itot(dwSecond, szStr, 10);
	strTemp += szStr;
    strTemp += _T(".");

	_itot(dwThird, szStr, 10);
	strTemp += szStr;
    strTemp += _T(".");

	_itot(dwLast, szStr, 10);
	strTemp += szStr;
    
    strIP = strTemp;
}

DWORD
GetHostName
(
    DWORD       dwIpAddr,
    CString &   strHostName
)
{
    CString strName;

    //
    //  Call the Winsock API to get host name information.
    //
    strHostName.Empty();

    u_long ulAddrInNetOrder = ::htonl( (u_long) dwIpAddr ) ;

    HOSTENT * pHostInfo = ::gethostbyaddr( (CHAR *) & ulAddrInNetOrder,
										   sizeof ulAddrInNetOrder,
										   PF_INET ) ;
    if ( pHostInfo == NULL )
    {
        return ::WSAGetLastError();
	}

    // copy the name
    MBCSToWide(pHostInfo->h_name, strName);

    strName.MakeUpper();

    int nDot = strName.Find(_T("."));

    if (nDot != -1)
        strHostName = strName.Left(nDot);
    else
        strHostName = strName;

    return NOERROR;
}

/*---------------------------------------------------------------------------
	GetHostAddress
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
GetHostAddress 
(
    LPCTSTR		pszHostName,
    DWORD  *	pdwIp
)
{
    DWORD err = ERROR_SUCCESS;
    CHAR szString [ MAX_PATH ] = {0};

    CString strTemp(pszHostName);
    WideToMBCS(strTemp, szString);

    HOSTENT * pHostent = ::gethostbyname( szString ) ;

    if ( pHostent )
    {
        *pdwIp = ::ntohl( *((u_long *) pHostent->h_addr_list[0]) ) ;
    }
    else
    {
        err = ::WSAGetLastError() ;
	}

    return err ;
}

//
// This function makes the appropriate call to either WinsStatus or WinsStatusNew
//
CWinsResults::CWinsResults()
{
    NoOfOwners = 0;
    AddVersMaps.RemoveAll();
    MyMaxVersNo.QuadPart = 0;
    RefreshInterval = 0;
    TombstoneInterval = 0;
    TombstoneTimeout = 0;
    VerifyInterval = 0;
    WinsPriorityClass = 0;
    NoOfWorkerThds = 0;
    memset(&WinsStat, 0, sizeof(WinsStat));
}

CWinsResults::CWinsResults(WINSINTF_RESULTS_T * pwrResults)
{
    Set(pwrResults);
}

CWinsResults::CWinsResults(WINSINTF_RESULTS_NEW_T * pwrResults)
{
    Set(pwrResults);
}

DWORD
CWinsResults::Update(handle_t hBinding)
{
    DWORD err;

    //
    // First try the new API which does not
    // not have the 25 partner limitation.  If
    // this fails with RPC_S_PROCNUM_OUT_OF_RANGE,
    // we know the server is a down-level server,
    // and we need to call the old method.
    //
    err = GetNewConfig(hBinding);

	if (err == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        //
        // Try old API
        //
        err = GetConfig(hBinding);
    }

    return err;
}
    
DWORD 
CWinsResults::GetNewConfig(handle_t hBinding)
{
    WINSINTF_RESULTS_NEW_T wrResults;

	wrResults.WinsStat.NoOfPnrs = 0;
    wrResults.WinsStat.pRplPnrs = NULL;
    wrResults.NoOfWorkerThds = 1;
    wrResults.pAddVersMaps = NULL;

#ifdef WINS_CLIENT_APIS
    DWORD dwStatus = ::WinsStatusNew(hBinding, WINSINTF_E_CONFIG_ALL_MAPS, &wrResults);
#else
    DWORD dwStatus = ::WinsStatusNew(WINSINTF_E_CONFIG_ALL_MAPS, &wrResults);
#endif WINS_CLIENT_APIS

    if (dwStatus == ERROR_SUCCESS)
    {
        Set(&wrResults);
    }
    else
    {
        Clear();
    }

	return dwStatus;
}

DWORD 
CWinsResults::GetConfig(handle_t hBinding)
{
    WINSINTF_RESULTS_T wrResults;

	wrResults.WinsStat.NoOfPnrs = 0;
    wrResults.WinsStat.pRplPnrs = NULL;
    wrResults.NoOfWorkerThds = 1;

#ifdef WINS_CLIENT_APIS
    DWORD dwStatus = ::WinsStatus(hBinding, WINSINTF_E_CONFIG_ALL_MAPS, &wrResults);
#else
	DWORD dwStatus = ::WinsStatus(WINSINTF_E_CONFIG_ALL_MAPS, &wrResults);
#endif WINS_CLIENT_APIS

    if (dwStatus == ERROR_SUCCESS)
    {
        Set(&wrResults);
    }
    else
    {
        Clear();
    }

	return dwStatus;
}

void 
CWinsResults::Clear()
{
    AddVersMaps.RemoveAll();

    NoOfOwners = 0;
    MyMaxVersNo.QuadPart = 0;
    RefreshInterval = 0;
    TombstoneInterval = 0;
    TombstoneTimeout = 0;
    VerifyInterval = 0;
    WinsPriorityClass = 0;
    NoOfWorkerThds = 0;
    memset(&WinsStat, 0, sizeof(WinsStat));
}

void
CWinsResults::Set(WINSINTF_RESULTS_NEW_T * pwrResults)
{
    if (pwrResults)
    {
        NoOfOwners = pwrResults->NoOfOwners;
    
        AddVersMaps.RemoveAll();
    
        for (UINT i = 0; i < NoOfOwners; i++)
        {
            AddVersMaps.Add(pwrResults->pAddVersMaps[i]);
        }

        MyMaxVersNo.QuadPart = pwrResults->MyMaxVersNo.QuadPart;
    
        RefreshInterval = pwrResults->RefreshInterval;
        TombstoneInterval = pwrResults->TombstoneInterval;
        TombstoneTimeout = pwrResults->TombstoneTimeout;
        VerifyInterval = pwrResults->VerifyInterval;
        WinsPriorityClass = pwrResults->WinsPriorityClass;
        NoOfWorkerThds = pwrResults->NoOfWorkerThds;
        WinsStat = pwrResults->WinsStat;
    }
}

void
CWinsResults::Set(WINSINTF_RESULTS_T * pwrResults)
{
    if (pwrResults == NULL)
    {
        Clear();
    }
    else
    {
        NoOfOwners = pwrResults->NoOfOwners;
    
        AddVersMaps.RemoveAll();

        for (UINT i = 0; i < NoOfOwners; i++)
        {
            AddVersMaps.Add(pwrResults->AddVersMaps[i]);
        }

        MyMaxVersNo.QuadPart = pwrResults->MyMaxVersNo.QuadPart;
    
        RefreshInterval = pwrResults->RefreshInterval;
        TombstoneInterval = pwrResults->TombstoneInterval;
        TombstoneTimeout = pwrResults->TombstoneTimeout;
        VerifyInterval = pwrResults->VerifyInterval;
        WinsPriorityClass = pwrResults->WinsPriorityClass;
        NoOfWorkerThds = pwrResults->NoOfWorkerThds;
        WinsStat = pwrResults->WinsStat;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winssup.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winsup.cpp
		Global functions and variables

	FILE HISTORY:


*/


#ifndef _WINSSUP_H
#define _WINSSUP_H

// some global defines we need
#define WINS_NAME_CODE_PAGE     CP_OEMCP 
#define INVALID_OWNER_ID        0xFFFFFFFF


// Constants used in samples
const int NUM_FOLDERS = 6;
const int MAX_COLUMNS = 9;
const int NUM_SCOPE_ITEMS = 4;

extern const TCHAR g_szPipeName[];
extern const TCHAR g_szDefaultHelpTopic[];

extern const CLSID      CLSID_WinsSnapin;               // In-Proc server GUID
extern const CLSID      CLSID_WinsSnapinExtension;      // In-Proc server GUID
extern const CLSID      CLSID_WinsSnapinAbout;          // In-Proc server GUID
extern const GUID       GUID_WinsRootNodeType;          // Main NodeType GUID on numeric format
extern const GUID       GUID_WinsGenericNodeType;          // Generic-non extendible NodeType GUID

// defines used in the display of owner info
enum _COLUMNS
{
    COLUMN_IP,
    COLUMN_NAME,
    COLUMN_VERSION,
    COLUMN_MAX
};

// #defines for time intervals
#define SEC_PER_DAY		(24	*60	* 60)
#define SEC_PER_HOUR	(60 * 60)
#define SEC_PER_MINUTE	60

// for verifying the WINS servers
#define NB_NAME_MAX_LENGTH      16          // Max length for NetBIOS names
#define LM_NAME_MAX_LENGTH      15          // Maximum length for Lanman-compatible 
											// NetBIOS Name.

#define DOMAINNAME_LENGTH       255
#define HOSTNAME_LENGTH         16

// for monitoring
#define SERVER_DELETED		    0x00000001
#define SERVER_ADDED		    0x00000002

// deleted owner gets this vers no
#define OWNER_DELETED           0x7FFFFFFFFFFFFFFF

// flags that get stored in the .msc file
enum _SERVERFLAGS
{
    FLAG_LANMAN_COMPATIBLE = 0x00000001,
    FLAG_VALIDATE_CACHE    = 0x00000002,
    FLAG_STATUS_BAR        = 0x00000004,
    FLAG_AUTO_REFRESH      = 0x00000008,
    FLAG_EXTENSION         = 0x00000010,    // we are an extension
    FLAG_SHOW_FQDN         = 0x00000020,
    FLAG_SERVER_ORDER_IP   = 0x00000040,
    FLAG_SHOW_TASKPADS     = 0x00000080,
};

#define WIN32_FROM_HRESULT(hr)		(0x0000FFFF & (hr))

extern UINT aColumns[WINSSNAP_NODETYPE_MAX][MAX_COLUMNS];
extern int aColumnWidths[WINSSNAP_NODETYPE_MAX][MAX_COLUMNS];

// Clipboard format that has the Type and Cookie
extern const wchar_t*   SNAPIN_INTERNAL;

DWORD   SendTrigger(handle_t hWins, LONG ipTarget, BOOL fPush, BOOL fPropagate);

//often used functions
DWORD   ControlWINSService(LPCTSTR pszName, BOOL bStop = TRUE);
void    GetNameIP(const CString &strDisplay, CString &strName, CString &strIP);
void    MakeIPAddress(DWORD dwIPAdd, CString &strIP);
DWORD   GetHostName(DWORD dwIpAddr, CString & strHostName);
DWORD   GetHostAddress(LPCTSTR pszHostName, DWORD * pdwIp);

DWORD   WideToMBCS(CString & strIn, LPSTR szOut, UINT uCodePage = CP_ACP, DWORD dwFlags = 0, BOOL * pfDefaultUsed = NULL);
DWORD   MBCSToWide(LPSTR szOut, CString & strIn, UINT uCodePage = CP_ACP, DWORD dwFlags = 0);

// formatted messagebox for the snap-in
BOOL LoadMessage(UINT nIdPrompt, TCHAR * chMsg, int nMsgSize);
LONG GetSystemMessageA(UINT	nId, CHAR *	chBuffer, int cbBuffSize);
LONG GetSystemMessage (UINT	nId, TCHAR * chBuffer, int cbBuffSize);
int WinsMessageBox(UINT nIdPrompt, 
 				   UINT nType = MB_OK, 
				   const TCHAR * pszSuffixString = NULL,
				   UINT nHelpContext = -1);

int WinsMessageBoxEx(UINT    nIdPrompt, 
 				     LPCTSTR pszPrefixMessage,
                     UINT    nType = MB_OK, 
  				     UINT    nHelpContext = -1);

// for the validation of server names
BOOL IsValidNetBIOSName(CString & strAddress,BOOL fLanmanCompatible,BOOL fWackwack);
DWORD VerifyWinsServer(CString& strAddress, CString &strServerName, DWORD &dwIP);
BOOL IsValidAddress(CString& strAddress,BOOL * fIpAddress,BOOL fLanmanCompatible,BOOL fWackwack );

typedef enum _NAME_TYPE_MAPPING_
{
	NAME_TYPE_WORKSTATION           = 0x00000000,
	NAME_TYPE_MESSENGER             = 0x00000003,
	NAME_TYPE_RAS_SERVER            = 0x00000006,
	NAME_TYPE_DMB                   = 0x0000001B,
	NAME_TYPE_DC                    = 0x0000001C,		
	NAME_TYPE_NORM_GRP_NAME         = 0x0000001E,
	NAME_TYPE_NETDDE                = 0x0000001F, 
	NAME_TYPE_FILE_SERVER           = 0x00000020,	
	NAME_TYPE_WORK_NW_MON_AGENT     = 0x000000BE,
	NAME_TYPE_WORK_NW_MON_NAME      = 0x000000BF,
	NAME_TYPE_OTHER		            = 0x0000FFFF,
} NAME_TYPE_MAPPING;

#define NUM_DEFAULT_NAME_TYPES      13

extern const UINT s_NameTypeMappingDefault[NUM_DEFAULT_NAME_TYPES][3];

/*---------------------------------------------------------------------------
	Protocol name formatting functions/classes

	This is provided separately from the usual function mechanism.  The
	reason is that we will read in additional data from the registry of
	the router.  This allows users to add their own protocols.
 ---------------------------------------------------------------------------*/

 
 /*---------------------------------------------------------------------------
	Class:	CStringMapEntry
 ---------------------------------------------------------------------------*/
class CStringMapEntry
{
public:
    CStringMapEntry() 
	{
		dwNameType = 0;
		dwWinsType = -1;
		ulStringId = 0;
	}

    CStringMapEntry(CStringMapEntry & stringMapEntry)
    {
        *this = stringMapEntry;
    }

    CStringMapEntry & operator = (const CStringMapEntry & stringMapEntry)
    {
        if (this != &stringMapEntry)
        {
			dwNameType = stringMapEntry.dwNameType;
			dwWinsType = stringMapEntry.dwWinsType;
			st = stringMapEntry.st;
			ulStringId = stringMapEntry.ulStringId;
		}
        
        return *this;
    }

public:    
	DWORD		dwNameType;			// 16th byte of name, -1 is a sentinel value
	DWORD		dwWinsType;		// type of record--Unique, group, etc; -1 for don't care
	CString	    st;
	ULONG		ulStringId;
};

typedef CArray<CStringMapEntry, CStringMapEntry&> CStringMapArray;

void MapDWORDToCString(DWORD dwNameType, DWORD dwWinsType, const CStringMapEntry *pMap, CString & strName);

/*---------------------------------------------------------------------------
	Class:	NameTypeMapping
 ---------------------------------------------------------------------------*/
class NameTypeMapping : public CStringMapArray
{
public:
	NameTypeMapping();
	~NameTypeMapping();
	
	HRESULT		Load();
	void		Unload();
    HRESULT     AddEntry(DWORD dwProtocolId, LPCTSTR pszName);
    HRESULT     ModifyEntry(DWORD dwProtocolId, LPCTSTR pszName);
    HRESULT     RemoveEntry(DWORD dwProtocolId);
    BOOL        EntryExists(DWORD dwProtocolId);

    void        SetMachineName(LPCTSTR pszMachineName);

	void        TypeToCString(DWORD dwNameType, DWORD dwWinsType, CString & strName);

private:
	typedef CString REGKEYNAME;

    CString     m_strMachineName;
public:
	static const REGKEYNAME c_szNameTypeMapKey;
	static const REGKEYNAME c_szDefault;
};

/*---------------------------------------------------------------------------
	Class:	CServerInfo
 ---------------------------------------------------------------------------*/
class CServerInfo 
{
public:
    CServerInfo() {};
    CServerInfo(DWORD dwIp, CString & strName, LARGE_INTEGER liVersion)
        : m_dwIp(dwIp),
          m_strName(strName)
    {
        m_liVersion.QuadPart = liVersion.QuadPart;
    }

    CServerInfo(CServerInfo & ServerInfo)
    {
        *this = ServerInfo;
    }

    CServerInfo & operator = (const CServerInfo & ServerInfo)
    {
        if (this != &ServerInfo)
        {
            m_dwIp = ServerInfo.m_dwIp;
            m_strName = ServerInfo.m_strName;
            m_liVersion.QuadPart = ServerInfo.m_liVersion.QuadPart;
        }
        
        return *this;
    }

public:
    DWORD           m_dwIp;
    CString         m_strName;
    LARGE_INTEGER   m_liVersion;
};

typedef CArray<CServerInfo, CServerInfo&> CServerInfoArrayBase;

/*---------------------------------------------------------------------------
	Class:	CWinsThread
 ---------------------------------------------------------------------------*/
class CServerInfoArray : public CServerInfoArrayBase
{
public:
    const CServerInfo GetAt(int nIndex)
    {
        CSingleLock sl(&m_lock);

        sl.Lock();

        return CServerInfoArrayBase::GetAt(nIndex);
    }

    CServerInfo & ElementAt(int nIndex)
    {
        CSingleLock sl(&m_lock);

        sl.Lock();

        return CServerInfoArrayBase::ElementAt(nIndex);
    }

    void SetAt(int nIndex, CServerInfo & serverInfo)
    {
        CSingleLock sl(&m_lock);

        sl.Lock();

        CServerInfoArrayBase::SetAt(nIndex, serverInfo);
    }
public:
    CSemaphore  m_lock;
};


typedef CArray<WINSINTF_ADD_VERS_MAP_T, WINSINTF_ADD_VERS_MAP_T> CAddVersMap;

/*---------------------------------------------------------------------------
	Class:	CWinsResults
	    Abstraction of the WINS_RESULTS and WINS_RESULTS_NEW structs
 ---------------------------------------------------------------------------*/
class CWinsResults
{
public:
    CWinsResults();
    CWinsResults(WINSINTF_RESULTS_T * pwrResults);
    CWinsResults(WINSINTF_RESULTS_NEW_T * pwrResults);

    CWinsResults(CServerInfo & ServerInfo)
    {
        *this = ServerInfo;
    }

    CWinsResults & operator = (const CWinsResults & CWinsResults)
    {
        if (this != &CWinsResults)
        {
            NoOfOwners = CWinsResults.NoOfOwners;
            AddVersMaps.Copy(CWinsResults.AddVersMaps);
            MyMaxVersNo.QuadPart = CWinsResults.MyMaxVersNo.QuadPart;
            RefreshInterval = CWinsResults.RefreshInterval;
            TombstoneInterval = CWinsResults.TombstoneInterval;
            TombstoneTimeout = CWinsResults.TombstoneTimeout;
            VerifyInterval = CWinsResults.VerifyInterval;
            WinsPriorityClass = CWinsResults.WinsPriorityClass;
            NoOfWorkerThds = CWinsResults.NoOfWorkerThds;
            WinsStat = CWinsResults.WinsStat;
        }
        
        return *this;
    }

    DWORD   Update(handle_t binding);
    void    Set(WINSINTF_RESULTS_T * pwrResults);
    void    Set(WINSINTF_RESULTS_NEW_T * pwrResults);
    void    Clear();

protected:
    DWORD   GetConfig(handle_t binding);
    DWORD   GetNewConfig(handle_t binding);

public:
	DWORD			NoOfOwners;
    CAddVersMap     AddVersMaps;
	LARGE_INTEGER	MyMaxVersNo;
	DWORD			RefreshInterval;
	DWORD			TombstoneInterval;
	DWORD			TombstoneTimeout;
	DWORD			VerifyInterval;
	DWORD			WinsPriorityClass;
	DWORD			NoOfWorkerThds;
	WINSINTF_STAT_T	WinsStat;
};

/*---------------------------------------------------------------------------
	Class:	CWinsName
 ---------------------------------------------------------------------------*/
class CWinsName
{
public:
	CWinsName()
	{
		dwType = 0;
	}

    CWinsName(CWinsName & winsName)
    {
        *this = winsName;
    }

    CWinsName & operator = (const CWinsName & winsName)
    {
        if (this != &winsName)
        {
			strName = winsName.strName;
			dwType = winsName.dwType;
		}
        
        return *this;
    }

	BOOL operator == (const CWinsName & winsName)
	{
		if ( (strName.Compare(winsName.strName) == 0) &&
			 (dwType == winsName.dwType) )
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

public:
	CString	strName;
	DWORD	dwType;
};

typedef CArray<CWinsName, CWinsName&> CWinsNameArray;

/*---------------------------------------------------------------------------
	Class:	CTypeFilterInfo
 ---------------------------------------------------------------------------*/
class CTypeFilterInfo
{
public:
	CTypeFilterInfo()
	{
		dwType = 0;
		fShow = TRUE;
	}

    CTypeFilterInfo(CTypeFilterInfo & typeFilterInfo)
    {
        *this = typeFilterInfo;
    }

    CTypeFilterInfo & operator = (const CTypeFilterInfo & typeFilterInfo)
    {
        if (this != &typeFilterInfo)
        {
			dwType = typeFilterInfo.dwType;
			fShow = typeFilterInfo.fShow;
		}
        
        return *this;
    }

	BOOL operator == (const CTypeFilterInfo & typeFilterInfo)
	{
		if ( (fShow == typeFilterInfo.fShow) &&
			 (dwType == typeFilterInfo.dwType) )
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

public:
	DWORD	dwType;
	BOOL	fShow;
};

typedef CArray<CTypeFilterInfo, CTypeFilterInfo&> CTypeFilterInfoArray;

#endif //#define _WINSSUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\mmc\wins\winssnap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winssnap.cpp
		WINS snapin entry points/registration functions
		
		Note: Proxy/Stub Information
			To build a separate proxy/stub DLL, 
			run nmake -f Snapinps.mak in the project directory.

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "initguid.h"
#include "winscomp.h"
#include "winssnap.h"
#include "ncglobal.h"   // network console global defines
#include "cmptrmgr.h"   // computer management snapin node types
#include "locale.h"     // for setlocale

#include <lmerr.h> // for NERR stuff

#ifdef _DEBUG
void DbgVerifyInstanceCounts();
#define DEBUG_VERIFY_INSTANCE_COUNTS DbgVerifyInstanceCounts()
#else
#define DEBUG_VERIFY_INSTANCE_COUNTS
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_WinsSnapin, CWinsComponentDataPrimary)
	OBJECT_ENTRY(CLSID_WinsSnapinExtension, CWinsComponentDataExtension)
	OBJECT_ENTRY(CLSID_WinsSnapinAbout, CWinsAbout)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWinsSnapinApp theApp;

BOOL CWinsSnapinApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);

    //
    //  Initialize the CWndIpAddress control window class IPADDRESS
    //
    CWndIpAddress::CreateWindowClass( m_hInstance ) ;

    // set the default locale to the system locale
    setlocale(LC_ALL, "");

	//
    //  Initialize use of the WinSock routines
    //
    WSADATA wsaData ;
    
    if ( ::WSAStartup( MAKEWORD( 1, 1 ), & wsaData ) != 0 )
    {
        m_bWinsockInited = TRUE;
		Trace0("InitInstance: Winsock initialized!\n");
    }
	else
	{
		m_bWinsockInited = FALSE;
	}

	::IPAddrInit(m_hInstance);
	return CWinApp::InitInstance();
}

int CWinsSnapinApp::ExitInstance()
{
	_Module.Term();

	DEBUG_VERIFY_INSTANCE_COUNTS;

	//
    // Terminate use of the WinSock routines.
    //
    if ( m_bWinsockInited )
    {
        WSACleanup() ;
    }

	return CWinApp::ExitInstance();
}

/***
 *
 *  CWinsadmnApp::GetSystemMessage
 *
 *  Purpose:
 *
 *      Given a message ID, determine where the message resides,
 *      and load it into the buffer.
 *
 *  Arguments:
 *
 *      UINT    nId         Message ID number
 *      char *  chBuffer    Character buffer to load into.
 *      int     cbBuffSize  Size of buffer in characters
 *
 *  Returns:
 *
 *      API error return code, or ERROR_SUCCESS
 *
 */
DWORD
CWinsSnapinApp::GetSystemMessage(
    UINT nId,
    TCHAR * chBuffer,
    int cbBuffSize
    )
{
    TCHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
                | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges.
    //
    if( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = ::LoadLibrary( _T("netmsg.dll") );
    }
    else if( nId >= 0x40000000L )
    {
        hdll = ::LoadLibrary( _T("ntdll.dll") );
    }

    if( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    DWORD dwResult = ::FormatMessage( flags,
                                      (LPVOID) hdll,
                                      nId,
                                      0,
                                      chBuffer,
                                      cbBuffSize,
                                      NULL );

    if( hdll != NULL )
    {
        LONG err = ::GetLastError();
        ::FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? ERROR_SUCCESS : ::GetLastError();
}

/***
 *
 *  CWinsadmnApp::MessageBox
 *
 *  Purpose:
 *
 *      Replacement for AfxMessageBox().  This function will call up the
 *      appropriate message from wherever before displaying it
 *
 *  Arguments:
 *
 *      UINT    nIdPrompt    Message ID
 *      UINT    nType        AfxMessageBox type (YESNO, OKCANCEL, etc)
 *      UINT    nHelpContext Help context ID for AfxMessageBox();
 *
 *  Notes:
 *
 *      If an error occurs, a standard message (hard-coded in english) will
 *      be shown that gives the error number.
 *
 */
int
CWinsSnapinApp::MessageBox (
    UINT nIdPrompt,
    UINT nType,
    UINT nHelpContext
    )
{
    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
    if (nIdPrompt == EPT_S_NOT_REGISTERED ||
        nIdPrompt == RPC_S_SERVER_UNAVAILABLE)
    {
        nIdPrompt = IDS_ERR_WINS_DOWN;
    }

    //
    //  If it's our error, the text is in our resource segment.
    //  Otherwise, use FormatMessage() and the appropriate DLL>
    //
    if ((nIdPrompt >= IDS_ERR_INVALID_IP) && (nIdPrompt <= IDS_MSG_LAST))
    {
         return ::AfxMessageBox(nIdPrompt, nType, nHelpContext);
    }

    TCHAR szMesg [1024] ;
    int nResult;

    if ((nResult = GetSystemMessage(nIdPrompt, szMesg, sizeof(szMesg)/sizeof(TCHAR)))
            == ERROR_SUCCESS)
    {
        return ::AfxMessageBox(szMesg, nType, nHelpContext);
    }

    Trace1("Message number %d not found",  nIdPrompt);
    ASSERT(0 && "Error Message ID not handled");
    
    //
    //  Do something for the retail version
    //
    ::wsprintf ( szMesg, _T("Error: %lu"), nIdPrompt);
    ::AfxMessageBox(szMesg, nType, nHelpContext);

    return nResult;
}

int
CWinsSnapinApp::MessageBox (
    LPCTSTR pPrefixText,
    UINT nIdPrompt,
    UINT nType,
    UINT nHelpContext
    )
{
    CString strText = pPrefixText;
    CString strAppend;

    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
    if (nIdPrompt == EPT_S_NOT_REGISTERED ||
        nIdPrompt == RPC_S_SERVER_UNAVAILABLE)
    {
        nIdPrompt = IDS_ERR_WINS_DOWN;
    }

    //
    //  If it's our error, the text is in our resource segment.
    //  Otherwise, use FormatMessage() and the appropriate DLL>
    //
    if ((nIdPrompt >= IDS_ERR_BASE) && (nIdPrompt <= IDS_MSG_LAST))
    {
        strAppend.LoadString(nIdPrompt);
        strText += strAppend;
        
        return ::AfxMessageBox(strText, nType, nHelpContext);
    }

    TCHAR szMesg [1024] ;
    int nResult;

    if ((nResult = GetSystemMessage(nIdPrompt, szMesg, sizeof(szMesg)/sizeof(TCHAR)))
            == ERROR_SUCCESS)
    {
        strText += szMesg;
        return ::AfxMessageBox(strText, nType, nHelpContext);
    }

    Trace1("Message number %d not found",  nIdPrompt);
    ASSERT(0 && "Error Message ID not handled");
    
    //
    //  Do something for the retail version
    //
    ::wsprintf ( szMesg, _T("Error: %lu"), nIdPrompt);
    strText += szMesg;
    ::AfxMessageBox(strText, nType, nHelpContext);

    return nResult;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
	// registers object, typelib and all interfaces in typelib
	//
	HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

    CString strDesc, strExtDesc, strRootDesc, strVersion;

    strDesc.LoadString(IDS_SNAPIN_DESC);
    strExtDesc.LoadString(IDS_SNAPIN_EXTENSION_DESC);
    strRootDesc.LoadString(IDS_ROOT_DESC);
    strVersion.LoadString(IDS_ABOUT_VERSION);
    
    //
	// register the snapin into the console snapin list
	//
	hr = RegisterSnapinGUID(&CLSID_WinsSnapin, 
						&GUID_WinsRootNodeType, 
						&CLSID_WinsSnapinAbout,
						strDesc, 
						strVersion, 
						TRUE);
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

	hr = RegisterSnapinGUID(&CLSID_WinsSnapinExtension, 
						    NULL, 
						    &CLSID_WinsSnapinAbout,
						    strExtDesc, 
						    strVersion, 
						    FALSE);
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

    //
	// register the snapin nodes into the console node list
	//
	hr = RegisterNodeTypeGUID(&CLSID_WinsSnapin,
							  &GUID_WinsRootNodeType, 
							  strRootDesc);
	ASSERT(SUCCEEDED(hr));

#ifdef  __NETWORK_CONSOLE__

	hr = RegisterAsRequiredExtensionGUID(&GUID_NetConsRootNodeType, 
                                         &CLSID_WinsSnapinExtension,
    							         strExtDesc,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &CLSID_WinsSnapinExtension);   // the value doesn't matter,
                                                                        // just needs to be non-null
	ASSERT(SUCCEEDED(hr));
#endif

	hr = RegisterAsRequiredExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                         &CLSID_WinsSnapinExtension,
    							         strExtDesc,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS);   // NULL : not dynamic
	ASSERT(SUCCEEDED(hr));
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	HRESULT hr  = _Module.UnregisterServer();
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;
	
	// un register the snapin 
	//
	hr = UnregisterSnapinGUID(&CLSID_WinsSnapin);
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

	hr = UnregisterSnapinGUID(&CLSID_WinsSnapinExtension);
    if (FAILED(hr))
		return hr;

    // unregister the snapin nodes 
	//
	hr = UnregisterNodeTypeGUID(&GUID_WinsRootNodeType);
	ASSERT(SUCCEEDED(hr));

    if (FAILED(hr))
		return hr;
	
#ifdef  __NETWORK_CONSOLE__

	hr = UnregisterAsRequiredExtensionGUID(&GUID_NetConsRootNodeType, 
                                           &CLSID_WinsSnapinExtension,
                                           EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                           &CLSID_WinsSnapinExtension);  
	ASSERT(SUCCEEDED(hr));

#endif
    // computer management snapin extension
	hr = UnregisterAsRequiredExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                           &CLSID_WinsSnapinExtension,
                                           EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                           &CLSID_WinsSnapinExtension);  
	ASSERT(SUCCEEDED(hr));

    if (FAILED(hr))
		return hr;

    return hr;
}

#ifdef _DEBUG
void DbgVerifyInstanceCounts()
{
    DEBUG_VERIFY_INSTANCE_COUNT(CHandler);
    DEBUG_VERIFY_INSTANCE_COUNT(CMTHandler);
}



#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\lib\nthlpr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	ndisapi.c

Abstract:

	Since we cannot include windows.h and ntos.h in the same C file. Sigh !!!

Author:

	JameelH

Environment:

	Kernel mode, FSD

Revision History:

	Aug 1997	 JameelH 	Initial version

--*/

#include <ntosp.h>

extern
VOID
XSetLastError(
	IN	ULONG		Error
	);

VOID
InitUnicodeString(
	IN	PUNICODE_STRING		DestinationString,
	IN	PCWSTR				SourceString
    )
{
	RtlInitUnicodeString(DestinationString, SourceString);
}

NTSTATUS
AppendUnicodeStringToString(
	IN	PUNICODE_STRING		Destination,
	IN	PUNICODE_STRING		Source
    )
{
	return (RtlAppendUnicodeStringToString(Destination, Source));
}

HANDLE
OpenDevice(
	IN	PUNICODE_STRING		DeviceName
	)
{
	OBJECT_ATTRIBUTES	ObjAttr;
	NTSTATUS			Status;
	IO_STATUS_BLOCK		IoStsBlk;
	HANDLE				Handle;

	InitializeObjectAttributes(&ObjAttr,
							   DeviceName,
							   OBJ_CASE_INSENSITIVE,
							   NULL,
							   NULL);

	Status = NtOpenFile(&Handle,
						FILE_GENERIC_READ | FILE_GENERIC_WRITE,
						&ObjAttr,
						&IoStsBlk,
						FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
						FILE_SYNCHRONOUS_IO_NONALERT);
	if (Status != STATUS_SUCCESS)
	{
		XSetLastError(RtlNtStatusToDosError(Status));
	}
	return(Handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\lib\ndisapi.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ndisapi.c

Abstract:

    NDIS User-Mode apis to support PnP from the network UI

Author:

    JameelH

Environment:

    Kernel mode, FSD

Revision History:

    Aug 1997     JameelH    Initial version

--*/

#include <windows.h>
#include <wtypes.h>
#include <ntddndis.h>
#include <ndisprv.h>
#include <devioctl.h>

#ifndef UNICODE_STRING

typedef struct _UNICODE_STRING
{
    USHORT  Length;
    USHORT  MaximumLength;
    PWSTR   Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

#endif

#include <ndispnp.h>
#include <ndisprv.h>
#define MAC_ADDRESS_SIZE    6
#define VENDOR_ID_SIZE      3

extern
VOID
InitUnicodeString(
    IN  PUNICODE_STRING     DestinationString,
    IN  PCWSTR              SourceString
    );

extern
LONG
AppendUnicodeStringToString(
    IN  PUNICODE_STRING     Destination,
    IN  PUNICODE_STRING     Source
    );

extern
HANDLE
OpenDevice(
    IN  PUNICODE_STRING     DeviceName
    );

//
// UNICODE_STRING_SIZE calculates the size of the buffer needed to
// store a given UNICODE_STRING including an appended null-terminator.
//
// ULONG
// UNICODE_STRING_SIZE(
//     PUNICODE_STRING String
// );
//

#define UNICODE_STRING_SIZE(x) \
    ((((x) == NULL) ? 0 : (x)->Length) + sizeof(WCHAR))

VOID
NdispUnicodeStringToVar(
    IN     PVOID Base,
    IN     PUNICODE_STRING String,
    IN OUT PNDIS_VAR_DATA_DESC NdisVar
    )

/*++

Routine Description:

    This function copies the contents of a UNICODE_STRING to an
    NDIS_VAR_DATA structure.  NdisVar->Offset is treated as an input parameter
    and represents the offset into Base that the string characters should be
    copied to.

Arguments:

    Base - Specifies the base address of the IOCTL buffer.

    String - Supplies a pointer to the UNICODE_STRING that should be copied.

    NdisVar - Supplies a pointer to the target NDIS_VAR_DATA_DESC.  Its Offset
              field is taken as input, and its Length and MaximumLength fields
              are treated as output.

Return Value:

    None.

--*/

{
    PWCHAR destination;

    //
    // NdisVar->Offset is assumed to be filled in and is treated
    // as an input parameter.
    // 

    destination = (PWCHAR)(((PCHAR)Base) + NdisVar->Offset);

    //
    // Copy over the UNICODE_STRING, if any, and set NdisVar->Length
    //

    if ((String != NULL) && (String->Length > 0)) {
        NdisVar->Length = String->Length;
        memcpy(destination, String->Buffer, NdisVar->Length );
    } else {
        NdisVar->Length = 0;
    }

    //
    // Null-terminate, fill in MaxiumLength and we're done.
    //

    *(destination + NdisVar->Length / sizeof(WCHAR)) = L'\0';
    NdisVar->MaximumLength = NdisVar->Length + sizeof(WCHAR);
}

UINT
NdisHandlePnPEvent(
    IN  UINT            Layer,
    IN  UINT            Operation,
    IN  PUNICODE_STRING LowerComponent      OPTIONAL,
    IN  PUNICODE_STRING UpperComponent      OPTIONAL,
    IN  PUNICODE_STRING BindList            OPTIONAL,
    IN  PVOID           ReConfigBuffer      OPTIONAL,
    IN  UINT            ReConfigBufferSize  OPTIONAL
    )
{
    PNDIS_PNP_OPERATION Op;
    NDIS_PNP_OPERATION  tempOp;
    HANDLE              hDevice;
    BOOL                fResult = FALSE;
    UINT                cb, Size;
    DWORD               Error;
    ULONG               padding;

    do
    {
        //
        // Validate Layer & Operation
        //
        if (((Layer != NDIS) && (Layer != TDI)) ||
            ((Operation != BIND) && (Operation != UNBIND) && (Operation != RECONFIGURE) &&
             (Operation != UNLOAD) && (Operation != REMOVE_DEVICE) &&
             (Operation != ADD_IGNORE_BINDING) &&
             (Operation != DEL_IGNORE_BINDING) &&
             (Operation != BIND_LIST)))
        {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Allocate and initialize memory for the block to be passed down.  The buffer
        // will look like this:
        //
        //
        //         +=================================+
        //         | NDIS_PNP_OPERATION              |
        //         |     ReConfigBufferOff           | ----+
        //    +--- |     LowerComponent.Offset       |     |
        //    |    |     UpperComponent.Offset       | --+ |
        //  +-|--- |     BindList.Offset             |   | |
        //  | +--> +---------------------------------+   | |
        //  |      | LowerComponentStringBuffer      |   | |
        //  |      +---------------------------------+ <-+ |
        //  |      | UpperComponentStringBuffer      |     |
        //  +----> +---------------------------------+     |
        //         | BindListStringBuffer            |     |
        //         +---------------------------------+     |
        //         | Padding to ensure ULONG_PTR     |     |
        //         |     alignment of ReConfigBuffer |     |
        //         +---------------------------------+ <---+
        //         | ReConfigBuffer                  | 
        //         +=================================+
        //
        // tempOp is a temporary structure into which we will store offsets as
        // they are calculated.  This temporary structure will be moved to
        // the head of the real buffer once its size is known and it is
        // allocated.
        //

        Size = sizeof(NDIS_PNP_OPERATION);
        tempOp.LowerComponent.Offset = Size;

        Size += UNICODE_STRING_SIZE(LowerComponent);
        tempOp.UpperComponent.Offset = Size;

        Size += UNICODE_STRING_SIZE(UpperComponent);
        tempOp.BindList.Offset = Size;

        Size += UNICODE_STRING_SIZE(BindList);

        padding = (sizeof(ULONG_PTR) - (Size & (sizeof(ULONG_PTR) - 1))) &
                    (sizeof(ULONG_PTR) - 1);

        Size += padding;
        tempOp.ReConfigBufferOff = Size;

        Size += ReConfigBufferSize + 1;

        Op = (PNDIS_PNP_OPERATION)LocalAlloc(LPTR, Size);
        if (Op == NULL)
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // We have a buffer of the necessary size.  Copy in the partially-
        // filled in tempOp, then fill in the remaining fields and copy the
        // data into the buffer.
        // 

        *Op = tempOp;

        Op->Layer = Layer;
        Op->Operation = Operation;

        //
        // Copy over the three unicode strings
        //

        NdispUnicodeStringToVar( Op, LowerComponent, &Op->LowerComponent );
        NdispUnicodeStringToVar( Op, UpperComponent, &Op->UpperComponent );
        NdispUnicodeStringToVar( Op, BindList, &Op->BindList );

        //
        // Finally, copy over the ReConfigBuffer
        //

        Op->ReConfigBufferSize = ReConfigBufferSize;
        if (ReConfigBufferSize > 0)
        {
            memcpy((PUCHAR)Op + Op->ReConfigBufferOff,
                   ReConfigBuffer,
                   ReConfigBufferSize);
        }
        *((PUCHAR)Op + Op->ReConfigBufferOff + ReConfigBufferSize) = 0;

        hDevice = CreateFile(L"\\\\.\\NDIS",
                             GENERIC_READ | GENERIC_WRITE,
                             0,                 // sharing mode - not significant
                             NULL,              // security attributes
                             OPEN_EXISTING,
                             0,                 // file attributes and flags
                             NULL);             // handle to template file

        if (hDevice != INVALID_HANDLE_VALUE)
        {
            fResult = DeviceIoControl(hDevice,
                                      IOCTL_NDIS_DO_PNP_OPERATION,
                                      Op,                                   // input buffer
                                      Size,                                 // input buffer size
                                      NULL,                                 // output buffer
                                      0,                                    // output buffer size
                                      &cb,                                  // bytes returned
                                      NULL);                                // OVERLAPPED structure
            Error = GetLastError();
            CloseHandle(hDevice);
        }
        else
        {
            Error = GetLastError();
        }

        LocalFree(Op);

    } while (FALSE);

    SetLastError(Error);

    return(fResult);
}


NDIS_OID    StatsOidList[] =
    {
        OID_GEN_LINK_SPEED,
        OID_GEN_MEDIA_IN_USE | NDIS_OID_PRIVATE,
        OID_GEN_MEDIA_CONNECT_STATUS | NDIS_OID_PRIVATE,
        OID_GEN_XMIT_OK,
        OID_GEN_RCV_OK,
        OID_GEN_XMIT_ERROR,
        OID_GEN_RCV_ERROR,
        OID_GEN_DIRECTED_FRAMES_RCV | NDIS_OID_PRIVATE,
        OID_GEN_DIRECTED_BYTES_XMIT | NDIS_OID_PRIVATE,
        OID_GEN_DIRECTED_BYTES_RCV | NDIS_OID_PRIVATE,
        OID_GEN_ELAPSED_TIME | NDIS_OID_PRIVATE,
        OID_GEN_INIT_TIME_MS | NDIS_OID_PRIVATE,
        OID_GEN_RESET_COUNTS | NDIS_OID_PRIVATE,
        OID_GEN_MEDIA_SENSE_COUNTS | NDIS_OID_PRIVATE,
        OID_GEN_PHYSICAL_MEDIUM | NDIS_OID_PRIVATE
    };
UINT    NumOidsInList = sizeof(StatsOidList)/sizeof(NDIS_OID);

UINT
NdisQueryStatistics(
    IN  PUNICODE_STRING     Device,
    OUT PNIC_STATISTICS     Statistics
    )
{
    NDIS_STATISTICS_VALUE   StatsBuf[4*sizeof(StatsOidList)/sizeof(NDIS_OID)];
    PNDIS_STATISTICS_VALUE  pStatsBuf;
    HANDLE                  hDevice;
    BOOL                    fResult = FALSE;
    UINT                    cb, Size, Index;
    DWORD                   Error;

    if (Statistics->Size != sizeof(NIC_STATISTICS))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    }

    memset(Statistics, 0, sizeof(NIC_STATISTICS));
    Statistics->DeviceState = DEVICE_STATE_DISCONNECTED;
    Statistics->MediaState  = MEDIA_STATE_UNKNOWN;
    hDevice = OpenDevice(Device);

    if (hDevice != NULL)
    {
        Statistics->MediaState  = MEDIA_STATE_CONNECTED;                // default, if the device does not support
        Statistics->DeviceState = DEVICE_STATE_CONNECTED;
        fResult = DeviceIoControl(hDevice,
                                  IOCTL_NDIS_QUERY_SELECTED_STATS,
                                  StatsOidList,                         // input buffer
                                  sizeof(StatsOidList),                 // input buffer size
                                  StatsBuf,                             // output buffer
                                  sizeof(StatsBuf),                     // output buffer size
                                  &cb,                                  // bytes returned
                                  NULL);                                // OVERLAPPED structure
        Error = GetLastError();
        CloseHandle(hDevice);

        if (fResult)
        {
            Error = NO_ERROR;

            for (Index = Size = 0, pStatsBuf = StatsBuf; Size < cb; Index++)
            {
                LARGE_INTEGER   Value;
                NDIS_OID        Oid;

                Value.QuadPart = 0;
                if (pStatsBuf->DataLength == sizeof(LARGE_INTEGER))
                {
                    // Use memcpy rather than assignment to avoid unalignment
                    // faults on ia64.
                    //
                    memcpy(&Value.QuadPart, &pStatsBuf->Data[0], pStatsBuf->DataLength);
                }
                else
                {
                    Value.LowPart = *(PULONG)(&pStatsBuf->Data[0]);
                }
                Size += (pStatsBuf->DataLength + FIELD_OFFSET(NDIS_STATISTICS_VALUE, Data));
                Oid = pStatsBuf->Oid;
                pStatsBuf = (PNDIS_STATISTICS_VALUE)((PUCHAR)pStatsBuf +
                                                     FIELD_OFFSET(NDIS_STATISTICS_VALUE, Data) +
                                                     pStatsBuf->DataLength);

                switch (Oid & ~NDIS_OID_PRIVATE)
                {
                  case OID_GEN_LINK_SPEED:
                    Statistics->LinkSpeed = Value.LowPart;
                    break;

                  case OID_GEN_MEDIA_CONNECT_STATUS:
                    Statistics->MediaState = (Value.LowPart == NdisMediaStateConnected) ?
                                                MEDIA_STATE_CONNECTED : MEDIA_STATE_DISCONNECTED;
                    break;

                  case OID_GEN_MEDIA_IN_USE:
                    Statistics->MediaType = Value.LowPart;
                    break;

                  case OID_GEN_XMIT_OK:
                    Statistics->PacketsSent = Value.QuadPart;
                    break;

                  case OID_GEN_RCV_OK:
                    Statistics->PacketsReceived = Value.QuadPart;
                    break;

                  case OID_GEN_XMIT_ERROR:
                    Statistics->PacketsSendErrors = Value.LowPart;
                    break;

                  case OID_GEN_RCV_ERROR:
                    Statistics->PacketsReceiveErrors = Value.LowPart;
                    break;

                  case OID_GEN_DIRECTED_BYTES_XMIT:
                    Statistics->BytesSent += Value.QuadPart;
                    break;

                  case OID_GEN_MULTICAST_BYTES_XMIT:
                    Statistics->BytesSent += Value.QuadPart;
                    break;

                  case OID_GEN_BROADCAST_BYTES_XMIT:
                    Statistics->BytesSent += Value.QuadPart;
                    break;

                  case OID_GEN_DIRECTED_BYTES_RCV:
                    Statistics->BytesReceived += Value.QuadPart;
                    Statistics->DirectedBytesReceived = Value.QuadPart;
                    break;

                  case OID_GEN_DIRECTED_FRAMES_RCV:
                    Statistics->DirectedPacketsReceived = Value.QuadPart;
                    break;

                  case OID_GEN_MULTICAST_BYTES_RCV:
                    Statistics->BytesReceived += Value.QuadPart;
                    break;

                  case OID_GEN_BROADCAST_BYTES_RCV:
                    Statistics->BytesReceived += Value.QuadPart;
                    break;

                  case OID_GEN_ELAPSED_TIME:
                    Statistics->ConnectTime = Value.LowPart;
                    break;

                  case OID_GEN_INIT_TIME_MS:
                    Statistics->InitTime = Value.LowPart;
                    break;

                  case OID_GEN_RESET_COUNTS:
                    Statistics->ResetCount = Value.LowPart;
                    break;

                  case OID_GEN_MEDIA_SENSE_COUNTS:
                    Statistics->MediaSenseConnectCount = Value.LowPart >> 16;
                    Statistics->MediaSenseDisconnectCount = Value.LowPart & 0xFFFF;
                    break;

                  case OID_GEN_PHYSICAL_MEDIUM:
                    Statistics->PhysicalMediaType = Value.LowPart;
                    break;

                  default:
                    // ASSERT(0);
                    break;
                }
            }
        }
        else
        {
            Error = GetLastError();
        }
    }
    else
    {
        Error = GetLastError();
    }

    SetLastError(Error);

    return(fResult);
}


UINT
NdisEnumerateInterfaces(
    IN  PNDIS_ENUM_INTF Interfaces,
    IN  UINT            Size
    )
{
    HANDLE              hDevice;
    BOOL                fResult = FALSE;
    UINT                cb;
    DWORD               Error = NO_ERROR;

    do
    {
        hDevice = CreateFile(L"\\\\.\\NDIS",
                             GENERIC_READ | GENERIC_WRITE,
                             0,                 // sharing mode - not significant
                             NULL,              // security attributes
                             OPEN_EXISTING,
                             0,                 // file attributes and flags
                             NULL);             // handle to template file

        if (hDevice != INVALID_HANDLE_VALUE)
        {
            fResult = DeviceIoControl(hDevice,
                                      IOCTL_NDIS_ENUMERATE_INTERFACES,
                                      NULL,                                 // input buffer
                                      0,                                    // input buffer size
                                      Interfaces,                           // output buffer
                                      Size,                                 // output buffer size
                                      &cb,                                  // bytes returned
                                      NULL);                                // OVERLAPPED structure
            Error = GetLastError();
            CloseHandle(hDevice);

            if (Error == NO_ERROR)
            {
                UINT    i;

                //
                // Fix-up pointers
                //
                for (i = 0; i < Interfaces->TotalInterfaces; i++)
                {
                    OFFSET_TO_POINTER(Interfaces->Interface[i].DeviceName.Buffer, Interfaces);
                    OFFSET_TO_POINTER(Interfaces->Interface[i].DeviceDescription.Buffer, Interfaces);
                }
            }
        }
        else
        {
            Error = GetLastError();
        }
    } while (FALSE);

    SetLastError(Error);

    return(fResult);
}

#if 0
UINT
NdisQueryDeviceBundle(
    IN  PUNICODE_STRING Device,
    OUT PDEVICE_BUNDLE  BundleBuffer,
    IN  UINT            BufferSize
    )
{
    HANDLE              hDevice;
    BOOL                fResult = FALSE;
    UINT                cb;
    DWORD               Error = NO_ERROR;

    do
    {
        if (BufferSize < (sizeof(DEVICE_BUNDLE) + Device->MaximumLength))
        {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        hDevice = OpenDevice(Device);
        if (hDevice != NULL)
        {
            fResult = DeviceIoControl(hDevice,
                                      IOCTL_NDIS_GET_DEVICE_BUNDLE,
                                      NULL,                                 // input buffer
                                      0,                                    // input buffer size
                                      BundleBuffer,                         // output buffer
                                      BufferSize,                           // output buffer size
                                      &cb,                                  // bytes returned
                                      NULL);                                // OVERLAPPED structure
            Error = GetLastError();
            CloseHandle(hDevice);

            if (Error == NO_ERROR)
            {
                UINT    i;

                //
                // Fix-up pointers
                //
                for (i = 0; i < BundleBuffer->TotalEntries; i++)
                {
                    OFFSET_TO_POINTER(BundleBuffer->Entries[i].Name.Buffer, BundleBuffer);
                }
            }
        }
        else
        {
            Error = ERROR_FILE_NOT_FOUND;
        }
    } while (FALSE);

    SetLastError(Error);

    return(fResult);
}

#endif

UINT
NdisQueryHwAddress(
    IN  PUNICODE_STRING Device,
    OUT PUCHAR          CurrentAddress,
    OUT PUCHAR          PermanentAddress,
    OUT PUCHAR          VendorId
    )
{
    UCHAR                   Buf[3*sizeof(NDIS_STATISTICS_VALUE) + 48];
    PNDIS_STATISTICS_VALUE  pBuf;
    NDIS_OID                Oids[] = { OID_802_3_CURRENT_ADDRESS, OID_802_3_PERMANENT_ADDRESS, OID_GEN_VENDOR_ID };
    HANDLE                  hDevice;
    BOOL                    fResult = FALSE;
    UINT                    cb;
    DWORD                   Error;

    memset(CurrentAddress, 0, MAC_ADDRESS_SIZE);
    memset(PermanentAddress, 0, MAC_ADDRESS_SIZE);
    memset(VendorId, 0, VENDOR_ID_SIZE);
    hDevice = OpenDevice(Device);

    if (hDevice != NULL)
    {
        fResult = DeviceIoControl(hDevice,
                                  IOCTL_NDIS_QUERY_SELECTED_STATS,
                                  &Oids,                                // input buffer
                                  sizeof(Oids),                         // input buffer size
                                  Buf,                                  // output buffer
                                  sizeof(Buf),                          // output buffer size
                                  &cb,                                  // bytes returned
                                  NULL);                                // OVERLAPPED structure
        Error = GetLastError();
        CloseHandle(hDevice);

        if (fResult)
        {
            UINT        Size, tmp;

            Error = NO_ERROR;

            pBuf = (PNDIS_STATISTICS_VALUE)Buf;
            for (Size = 0; Size < cb; )
            {
                tmp = (pBuf->DataLength + FIELD_OFFSET(NDIS_STATISTICS_VALUE, Data));
                Size += tmp;

                switch (pBuf->Oid)
                {
                    case OID_802_3_CURRENT_ADDRESS:
                        memcpy(CurrentAddress, pBuf->Data, MAC_ADDRESS_SIZE);
                        break;

                    case OID_802_3_PERMANENT_ADDRESS:
                        memcpy(PermanentAddress, pBuf->Data, MAC_ADDRESS_SIZE);
                        break;

                    case OID_GEN_VENDOR_ID:
                        memcpy(VendorId, pBuf->Data, VENDOR_ID_SIZE);
                }
                pBuf = (PNDIS_STATISTICS_VALUE)((PUCHAR)pBuf + tmp);
            }
        }
        else
        {
            Error = GetLastError();
        }
    }
    else
    {
        Error = ERROR_FILE_NOT_FOUND;
    }

    SetLastError(Error);

    return(fResult);
}

VOID
XSetLastError(
    IN  ULONG       Error
    )
{
    SetLastError(Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\loopback\debug.h ===
#ifndef _DEBUG_
#define _DEBUG_

#if DBG
  #define DEBUG DBG
#endif
//
// Debug Levels used with DBGPRINT

#define DBG_LEVEL_INFO  0
#define DBG_LEVEL_WARN  1
#define DBG_LEVEL_ERR   2
#define DBG_LEVEL_FATAL 3

// Component Types

#define DBG_COMP_INIT     0x00000001
#define DBG_COMP_DPC      0x00000002
#define DBG_COMP_REGISTRY 0x00000004
#define DBG_COMP_MEMORY   0x00000008
#define DBG_COMP_SEND     0x00000010
#define DBG_COMP_REQUEST  0x00000020
#define DBG_COMP_MISC     0x00000040
#define DBG_COMP_ALL      0xffffffff

extern LONG LoopDebugLevel;
extern LONG LoopDebugComponent;

#ifdef DEBUG

    #define DBGPRINT(Component, Level, Fmt) \
        if ((LoopDebugComponent & Component) && (Level >= LoopDebugLevel)) { \
            DbgPrint("    *** Loop - "); \
            DbgPrint Fmt; \
        }

    #define DBGBREAK(Level) \
        if (Level >= LoopDebugLevel) { \
            DbgBreakPoint(); \
        }

#else
    #define DBGPRINT(Component, Level, Fmt)
    #define DBGBREAK(Level)
#endif

#endif // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\pnptst\winstuff.c ===
#include <stdio.h>
#include <windows.h>

LONG
xxGetLastError(
	void
	)
{
	return(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\loopback\precomp.h ===
#include <ndis.h>
#include "debug.h"
#include "lbmini.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\adapter.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Adapter Adapter_h

@module Adapter.h |

    This module defines the interface to the <t MINIPORT_ADAPTER_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Adapter_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 4.1 Adapter Overview |

    This section describes the interfaces defined in <f Adapter\.h>.

    This module isolates most the NDIS specific, logical adapter interfaces.
    It should require very little change if you follow this same overall
    architecture.  You should try to isolate your changes to the <t CARD_OBJECT>
    that is contained within the logical adapter <t MINIPORT_ADAPTER_OBJECT>.

    The driver assumes one <t MINIPORT_ADAPTER_OBJECT> per physical ISDN card.
    Each adapter contains a single logical D-Channel, and an aribitrary number
    of logical B-Channels.  It is up to you to map these logical interfaces to
    the physical interfaces on your card.  I have been pretty successful at
    using this model on a variety of ISDN hardware including BRI, PRI, T1, and
    E1.  By maintaining the logical abstraction, you can configure your cards
    and lines any way you choose, and then let Windows think they are B Channels.
    Even though they may be configured as bonded DS-0's on a T1 using robbed
    bit signalling.  Just hide those details in your Card, Port, and BChannel
    objects.

@end
*/

#ifndef _ADAPTER_H
#define _ADAPTER_H

#define MINIPORT_ADAPTER_OBJECT_TYPE    ((ULONG)'A')+\
                                        ((ULONG)'D'<<8)+\
                                        ((ULONG)'A'<<16)+\
                                        ((ULONG)'P'<<24)


/* @doc INTERNAL Adapter Adapter_h MINIPORT_ADAPTER_OBJECT


@struct MINIPORT_ADAPTER_OBJECT |

    This structure contains the data associated with a single Miniport
    adapter instance.  Here, Adapter is defined as the manager of specific
    Network Interface Card (NIC) installed under the NDIS wrapper.  This
    adapter is responsible for managing all interactions between the NIC and
    the host operating system using the NDIS library.

@comm

    This structure must contain a reference to all other objects being managed
    by this adapter object.  The adapter object is the only reference passed
    between NDIS and the Miniport.  This is the <t MiniportAdapterContext> we
    pass into <f NdisMSetAttributes> from <f MiniportInitialize>.  This value
    is passed as a parameter to the Miniport entry points called by the NDIS
    wrapper.

    One of these objects is created each time that our <f MiniportInitialize>
    routine is called.  The NDIS wrapper calls this routine once for each of
    our devices installed and enabled in the system.  In the case of a hot
    swappable NIC (e.g. PCMCIA) the adapter might come and go several times
    during a single Windows session.

*/

typedef struct MINIPORT_ADAPTER_OBJECT
{
#if DBG
    ULONG                       DbgFlags;                   // @field
    // Debug flags control how much debug is displayed in the checked version.
    // Put it at the front so we can set it easily with debugger.

    UCHAR                       DbgID[12];                  // @field
    // This field is initialized to an ASCII decimal string containing the
    // adapter instance number 1..N.  It is only used to output debug messages.
#endif
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'ADAP'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    NDIS_HANDLE                 MiniportAdapterHandle;      // @field
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    NDIS_HANDLE                 WrapperConfigurationContext;// @field
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.

    PCARD_OBJECT                pCard;                      // @field
    // Pointer to the hardware specific <t CARD_OBJECT>.  Created by
    // <f CardCreate>.

    PDCHANNEL_OBJECT            pDChannel;                  // @field
    // Pointer to the <t DCHANNEL_OBJECT> created by <f DChannelCreate>.
    // One for the entire NIC.

    ULONG                       NumBChannels;               // @field
    // The number of <t BCHANNEL_OBJECT>'s supported by the NIC.

    PBCHANNEL_OBJECT *          pBChannelArray;             // @field
    // An array of <t BCHANNEL_OBJECT>'s created by <f BChannelCreate>.
    // One entry for each logical BChannel on NIC.

    LIST_ENTRY                  BChannelAvailableList;      // @field
    // Linked list of available BChannels.
    // Keep listening BChannel's at the end of the available list,
    // so they can be easily allocated to incoming calls.
    // By using those on the front of the list for outgoing calls,
    // we can help insure that there will be a BChannel available for
    // an incoming call.  But still, we may end up using a listening
    // BChannel for an outgoing call, and that's okay; we're just trying
    // to be prudent with the allocation scheme.

    ULONG                       NumLineOpens;               // @field
    // The number of line open calls currently on this adapter.

    NDIS_SPIN_LOCK              TransmitLock;               // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the transmit queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  TransmitPendingList;        // @field
    // Packets waiting to be sent when the controller is available.
    // See <t NDIS_PACKET>.

    LIST_ENTRY                  TransmitCompleteList;       // @field
    // Packets waiting for completion processing.  After the packet is
    // transmitted, the protocol stack is given an indication.
    // See <t NDIS_PACKET>.

    NDIS_SPIN_LOCK              ReceiveLock;                // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the receive queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  ReceiveCompleteList;        // @field
    // Buffers waiting to be processed by the

    NDIS_SPIN_LOCK              EventLock;                  // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the event queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  EventList;                  // @field
    // driver callback events waiting to be processed.
    // See <t BCHANNEL_EVENT_OBJECT>.

    NDIS_MINIPORT_TIMER         EventTimer;                 // @field
    // This timer is used to schedule the event processing routine to run
    // when the system reaches a quiescent state.

    ULONG                       NextEvent;                  // @field
    // Where do we store the next event.

    long                        NestedEventHandler;         // @field
    // Keeps track of entry to and exit from the event handler.

    long                        NestedDataHandler;          // @field
    // Keeps track of entry to and exit from the Tx/Rx handlers.

    NDIS_HANDLE                 NdisAfHandle;               // @field
    // Used to store the NDIS address family handle passed into
    // <f ProtocolCmOpenAf>.

    ULONG                       Flags;
#   define ADAP_PENDING_SAP_CLOSE   0x00000002

    NDIS_WAN_CO_INFO            WanInfo;                    // @field
    // A copy of our <t NDIS_WAN_CO_INFO> structure is setup at init
    // time and doesn't change.

    BOOLEAN                     NeedStatusCompleteIndication;   // @field
    // This flag indicates whether or not <f NdisMIndicateStatusComplete>
    // needs to be called after the completion of requests or event processing.
    // This is set TRUE if <f NdisMIndicateStatus> is called while
    // processing a request or event.

    ULONG                       TotalRxBytes;               // @field
    // Total bytes read by driver during this session.

    ULONG                       TotalTxBytes;               // @field
    // Total bytes written by driver during this session.

    ULONG                       TotalRxPackets;             // @field
    // Total packets read by driver during this session.

    ULONG                       TotalTxPackets;             // @field
    // Total packets written by driver during this session.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} MINIPORT_ADAPTER_OBJECT;

extern PMINIPORT_ADAPTER_OBJECT g_Adapters[MAX_ADAPTERS];

/*


    Function prototypes.

*/

NDIS_STATUS AdapterCreate(
    OUT PMINIPORT_ADAPTER_OBJECT *ppAdapter,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              WrapperConfigurationContext
    );

void AdapterDestroy(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

NDIS_STATUS AdapterInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

#endif // _ADAPTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\adapter.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Adapter Adapter_c

@module Adapter.c |

    This module implements the interface to the <t MINIPORT_ADAPTER_OBJECT>.
    Supports the high-level adapter control functions used by the NDIS WAN
    Minport driver.

@comm

    This module isolates most the NDIS specific, logical adapter interfaces.
    It should require very little change if you follow this same overall
    architecture.  You should try to isolate your changes to the <t CARD_OBJECT>
    that is contained within the logical adapter <t MINIPORT_ADAPTER_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Adapter_c

@end

*/

#define  __FILEID__             MINIPORT_ADAPTER_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


PMINIPORT_ADAPTER_OBJECT        g_Adapters[MAX_ADAPTERS]    // @globalv
// Keeps track of all the <t MINIPORT_ADAPTER_OBJECT>s created by the driver.
                                = { 0 };

DBG_STATIC ULONG                g_AdapterInstanceCounter    // @globalv
// Keeps track of how many <t MINIPORT_ADAPTER_OBJECT>s are created and
// stored in the <p g_Adapters> array.
                                = 0;

DBG_STATIC UCHAR                g_AnsiDriverName[]          // @globalv
// ANSI string used to identify the driver to the system; usually defined
// as VER_PRODUCT_STR.
                                = VER_PRODUCT_STR;

DBG_STATIC UCHAR                g_AnsiVendorDescription[]   // @globalv
// ANSI string used to identify the vendor's device to the system; usually
// defined as VER_DEVICE_STR " Adapter".
                                = VER_DEVICE_STR " Adapter";


/* @doc INTERNAL EXTERNAL Adapter Adapter_c g_AdapterParameters


@topic 5.1 Adapter Parameters |

    This section describes the registry parameters read into the
    <t MINIPORT_ADAPTER_OBJECT>.

@globalv DBG_STATIC <t PARAM_TABLE> | g_AdapterParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t MINIPORT_ADAPTER_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t MINIPORT_ADAPTER_OBJECT>
    you will need to modify <f AdapterReadParameters> and add the parameter
    definitions to the <f g_AdapterParameters> table.

@flag <f DebugFlags> (OPTIONAL) (DEBUG VERSION ONLY) |

    This DWORD parameter allows you to control how much debug information is
    displayed to the debug monitor.  This is a bit OR'd flag using the values
    defined in <t DBG_FLAGS>.  This value is not used by the released version
    of the driver.<nl>

*/

DBG_STATIC PARAM_TABLE  g_AdapterParameters[] =
{
#if DBG
    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                DbgFlags, PARAM_DebugFlags,
                FALSE, NdisParameterHexInteger, 0,
                DBG_DEFAULTS | DBG_TAPICALL_ON, 0, 0xffffffff),
                // TODO: Change the debug flags to meet your needs.
#endif
    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL Adapter Adapter_c AdapterReadParameters


@func

    <f AdapterReadParameters> reads the adapter parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f AdapterCreate>.

    <f Note>:
    If you add any registry based data members to <t MINIPORT_ADAPTER_OBJECT>
    you will need to modify <f AdapterReadParameters> and add the parameter
    definitions to the <f g_AdapterParameters> table.

@rdesc

    <f AdapterReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS AdapterReadParameters(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("AdapterReadParameters")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Parse the registry parameters.
    */
    Result = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pAdapter,
                    g_AdapterParameters
                    );

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pAdapter->TODO)
        {
            DBG_ERROR(DbgInfo,("Invalid value 'TODO'\n",
                        pAdapter->TODO));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pAdapter->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Result = NDIS_STATUS_FAILURE;
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterCreateObjects


@func

    <f AdapterCreateObjects> calls the create routines for all the objects
    contained in <t MINIPORT_ADAPTER_OBJECT>.  This should only be called
    by <f AdapterCreate>.

    <f Note>:
    If you add any new objects to <t MINIPORT_ADAPTER_OBJECT> you will need
    to modify <f AdapterCreateObjects> and <f AdapterDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f AdapterCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS AdapterCreateObjects(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("AdapterCreateObjects")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    ULONG                       Index;
    // Loop counter.

    ULONG                       NumBChannels;
    // The number of BChannels supported by the NIC.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Create the Card object.
    */
    Result = CardCreate(&pAdapter->pCard, pAdapter);

    /*
    // Create the DChannel object.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        Result = DChannelCreate(&pAdapter->pDChannel, pAdapter);
    }

    /*
    // Allocate space for the BChannels.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        NumBChannels = CardNumChannels(pAdapter->pCard);

        Result = ALLOCATE_MEMORY(pAdapter->pBChannelArray,
                                 sizeof(PVOID) * NumBChannels,
                                 pAdapter->MiniportAdapterHandle);
    }

    /*
    // Create the BChannel objects.
    */
    InitializeListHead(&pAdapter->BChannelAvailableList);
    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < NumBChannels; Index++)
    {
        Result = BChannelCreate(&pAdapter->pBChannelArray[Index],
                                Index,
                                pAdapter);

        /*
        // Put entry on available list.
        */
        InsertTailList(&pAdapter->BChannelAvailableList,
                       &pAdapter->pBChannelArray[Index]->LinkList);

        /*
        // Keep track of how many are created.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            pAdapter->NumBChannels++;
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterCreate


@func

    <f AdapterCreate> allocates memory for a <t MINIPORT_ADAPTER_OBJECT> and
    then initializes the data members to their starting state.
    If successful, <p ppAdapter> will be set to point to the newly created
    <t MINIPORT_ADAPTER_OBJECT>.  Otherwise, <p ppAdapter> will be set to
    NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f AdapterDestroy> must be called to
    release the <t MINIPORT_ADAPTER_OBJECT> created by this function.

@rdesc

    <f AdapterCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS AdapterCreate(
    OUT PMINIPORT_ADAPTER_OBJECT *ppAdapter,                // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t MINIPORT_ADAPTER_OBJECT>.

    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    IN NDIS_HANDLE              WrapperConfigurationContext // @parm
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.
    )
{
    DBG_FUNC("AdapterCreate")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // Pointer to our newly allocated object.

    DBG_ENTER(DbgInfo);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppAdapter = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pAdapter, MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pAdapter->ObjectType = MINIPORT_ADAPTER_OBJECT_TYPE;
        pAdapter->ObjectID = ++g_AdapterInstanceCounter;
        ASSERT(g_AdapterInstanceCounter <= MAX_ADAPTERS);
        if (g_AdapterInstanceCounter <= MAX_ADAPTERS)
        {
            g_Adapters[g_AdapterInstanceCounter-1] = pAdapter;
        }

        /*
        // We use the instance number in debug messages to help when debugging
        // with multiple adapters.
        */
#if DBG
        pAdapter->DbgID[0] = (UCHAR) ((pAdapter->ObjectID & 0x0F) + '0');
        pAdapter->DbgID[1] = ':';
        if (sizeof(VER_TARGET_STR) < sizeof(pAdapter->DbgID)-3)
        {
            memcpy(&pAdapter->DbgID[2], VER_TARGET_STR, sizeof(VER_TARGET_STR));
        }
        else
        {
            memcpy(&pAdapter->DbgID[2], VER_TARGET_STR, sizeof(pAdapter->DbgID)-3);
            pAdapter->DbgID[sizeof(pAdapter->DbgID)-1] = 0;
        }
#endif
        /*
        // Initialize the member variables to their default settings.
        */
        pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;
        pAdapter->WrapperConfigurationContext = WrapperConfigurationContext;

        /*
        // Allocate spin locks to use for MUTEX queue protection.
        */
        NdisAllocateSpinLock(&pAdapter->EventLock);
        NdisAllocateSpinLock(&pAdapter->TransmitLock);
        NdisAllocateSpinLock(&pAdapter->ReceiveLock);

        /*
        // Parse the registry parameters.
        */
        Result = AdapterReadParameters(pAdapter);
#if DBG
        // DbgInfo->DbgFlags = pAdapter->DbgFlags;
#endif // DBG
        DBG_DISPLAY(("NOTICE: Adapter#%d=0x%X DbgFlags=0x%X\n",
                    pAdapter->ObjectID, pAdapter, pAdapter->DbgFlags));

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = AdapterCreateObjects(pAdapter);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppAdapter = pAdapter;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            AdapterDestroy(pAdapter);
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterDestroyObjects


@func

    <f AdapterDestroyObjects> calls the destroy routines for all the objects
    contained in <t MINIPORT_ADAPTER_OBJECT>.  This should only be called
    by <f AdapterDestroy>.

    <f Note>:
    If you add any new objects to <t MINIPORT_ADAPTER_OBJECT> you will need
    to modify <f AdapterCreateObjects> and <f AdapterDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void AdapterDestroyObjects(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("AdapterDestroyObjects")

    UINT                        NumBChannels;
    // The number of BChannels supported by the NIC.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Destroy the BChannel objects.
    */
    NumBChannels = pAdapter->NumBChannels;
    while (NumBChannels--)
    {
        BChannelDestroy(pAdapter->pBChannelArray[NumBChannels]);
    }
    pAdapter->NumBChannels = 0;

    /*
    // Free space for the BChannels.
    */
    if (pAdapter->pBChannelArray)
    {
        NumBChannels = CardNumChannels(pAdapter->pCard);
        FREE_MEMORY(pAdapter->pBChannelArray, sizeof(PVOID) * NumBChannels);
    }

    /*
    // Destroy the DChannel object.
    */
    DChannelDestroy(pAdapter->pDChannel);

    /*
    // Destroy the Card object.
    */
    CardDestroy(pAdapter->pCard);

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL Adapter Adapter_c AdapterDestroy


@func

    <f AdapterDestroy> frees the memory for this <t MINIPORT_ADAPTER_OBJECT>.
    All memory allocated by <f AdapterCreate> will be released back to the OS.

*/

void AdapterDestroy(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("AdapterDestroy")

    DBG_ENTER(DbgInfo);

    if (pAdapter)
    {
        ASSERT(pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

        /*
        // Release all objects allocated within this object.
        */
        AdapterDestroyObjects(pAdapter);

        if (pAdapter->EventLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->EventLock);
        }

        if (pAdapter->TransmitLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->TransmitLock);
        }

        if (pAdapter->ReceiveLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->ReceiveLock);
        }

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        if (pAdapter->ObjectType <= MAX_ADAPTERS)
        {
            g_Adapters[pAdapter->ObjectType-1] = NULL;
        }
        pAdapter->ObjectType = 0;
        FREE_OBJECT(pAdapter);
    }

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL Adapter Adapter_c AdapterInitialize


@func

    <f AdapterInitialize> prepares the <t MINIPORT_ADAPTER_OBJECT> and all
    its sub-components for use by the NDIS wrapper.  Upon successful
    completion of this routine, the NIC will be ready to accept requests
    from the NDIS wrapper.

@rdesc

    <f AdapterInitialize> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS AdapterInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("AdapterInitialize")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    ULONG                       Index;
    // Loop counter.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(pAdapter);

    /*
    // Initialize the WAN information structure to match the capabilities of
    // the adapter.
    */
    pAdapter->WanInfo.MaxFrameSize   = pAdapter->pCard->BufferSize - NDISWAN_EXTRA_SIZE;
    pAdapter->WanInfo.MaxSendWindow  = pAdapter->pCard->TransmitBuffersPerLink;

    /*
    // We only support PPP, and multi-link PPP framing.
    */
    pAdapter->WanInfo.FramingBits    = PPP_FRAMING |
                                       PPP_MULTILINK_FRAMING;

    /*
    // This value is ignored by this driver, but its default behavior is such
    // that all these control bytes would appear to be handled transparently.
    */
    pAdapter->WanInfo.DesiredACCM    = 0;

    /*
    // Initialize the packet management queues to empty.
    */
    InitializeListHead(&pAdapter->EventList);
    InitializeListHead(&pAdapter->TransmitPendingList);
    InitializeListHead(&pAdapter->TransmitCompleteList);
    InitializeListHead(&pAdapter->ReceiveCompleteList);

    /*
    // Setup the timer event handler.
    */
    NdisMInitializeTimer(&pAdapter->EventTimer,
                         pAdapter->MiniportAdapterHandle,
                         MiniportTimer,
                         pAdapter);

    /*
    // Initialize the DChannel object.
    */
    DChannelInitialize(pAdapter->pDChannel);

    /*
    // Initialize all the BChannel objects.
    */
    for (Index = 0; Index < pAdapter->NumBChannels; ++Index)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, Index);
        BChannelInitialize(pBChannel);
    }

    /*
    // Now, we can initialize the Card object.
    */
    Result = CardInitialize(pAdapter->pCard);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\loopback\lbmini.h ===
/*++
Copyright (c) 1992  Microsoft Corporation

Module Name:

	lbmini.h

Abstract:

	NDIS loopback miniport prototypes

Author:

	Jameel Hyder

Environment:

	Kernel mode, FSD

Revision History:

--*/

#define	NDIS_MAJOR_VERSION				0x3
#define	NDIS_MINOR_VERSION				0x0

#define	LOOP_MAJOR_VERSION				0x5
#define	LOOP_MINOR_VERSION				0x0

#define	ETH_CARD_ADDRESS				"\02\0LOOP"
#define	ETH_MAX_MULTICAST_ADDRESS		16
#define	TR_CARD_ADDRESS					"\100\0LOOP"
#define	FDDI_CARD_ADDRESS				"\02\0LOOP"
#define	FDDI_MAX_MULTICAST_LONG			16
#define	FDDI_MAX_MULTICAST_SHORT		16
#define	LTALK_CARD_ADDRESS				0xAB
#define	ARC_CARD_ADDRESS				'L'

//
// arbitrary maximums...
//
#define	MAX_LOOKAHEAD					256
#define	INDICATE_MAXIMUM				256

#define	OID_TYPE_MASK					0xFFFF0000
#define	OID_TYPE						0xFF000000
#define	OID_TYPE_GENERAL				0x00000000
#define	OID_TYPE_GENERAL_OPERATIONAL	0x00010000
#define	OID_TYPE_GENERAL_STATISTICS		0x00020000
#define	OID_TYPE_802_3					0x01000000
#define	OID_TYPE_802_3_OPERATIONAL		0x01010000
#define	OID_TYPE_802_3_STATISTICS		0x01020000
#define	OID_TYPE_802_5					0x02000000
#define	OID_TYPE_802_5_OPERATIONAL		0x02010000
#define	OID_TYPE_802_5_STATISTICS		0x02020000
#define	OID_TYPE_FDDI					0x03000000
#define	OID_TYPE_FDDI_OPERATIONAL		0x03010000
#define	OID_TYPE_LTALK					0x05000000
#define	OID_TYPE_LTALK_OPERATIONAL		0x05010000
#define	OID_TYPE_ARCNET					0x06000000
#define	OID_TYPE_ARCNET_OPERATIONAL		0x06010000

#define	OID_REQUIRED_MASK				0x0000FF00
#define	OID_REQUIRED_MANDATORY			0x00000100
#define	OID_REQUIRED_OPTIONAL			0x00000200

#define	OID_INDEX_MASK					0x000000FF

#define	GM_TRANSMIT_GOOD				0x00
#define	GM_RECEIVE_GOOD					0x01
#define	GM_TRANSMIT_BAD					0x02
#define	GM_RECEIVE_BAD					0x03
#define	GM_RECEIVE_NO_BUFFER			0x04
#define	GM_ARRAY_SIZE					0x05

#define PACKET_FILTER_802_3				0xF07F
#define PACKET_FILTER_802_5				0xF07F
#define PACKET_FILTER_DIX				0xF07F
#define PACKET_FILTER_FDDI  			0xF07F
#define PACKET_FILTER_LTALK				0x8009
#define PACKET_FILTER_ARCNET			0x8009

#define	LT_IS_BROADCAST(Address)	(BOOLEAN)(Address == 0xFF)

#define	ARC_IS_BROADCAST(Address)	(BOOLEAN)(!(Address))

typedef struct _MEDIA_INFO
{
	ULONG			MaxFrameLen;
	UINT			MacHeaderLen;
	ULONG			PacketFilters;
	ULONG			LinkSpeed;
} MEDIA_INFO, *PMEDIA_INFO;

typedef struct _ADAPTER
{
	NDIS_MEDIUM		Medium;

	//
	// NDIS Context for this interface
	NDIS_HANDLE		MiniportHandle;
	UINT			MaxLookAhead;
	UINT			AddressLength;
	ULONG			PacketFilter;

	//
	// Constants for the adapter
	//
	ULONG                   MediumLinkSpeed;
	ULONG			MediumMinPacketLen;
	ULONG			MediumMaxPacketLen;
	UINT			MediumMacHeaderLen;
	ULONG			MediumMaxFrameLen;
	ULONG			MediumPacketFilters;

	//
	// media specific info
	//
	UCHAR			PermanentAddress[ETH_LENGTH_OF_ADDRESS];
	UCHAR			CurrentAddress[ETH_LENGTH_OF_ADDRESS];

	// statistics
	ULONG			GeneralMandatory[GM_ARRAY_SIZE];

	UCHAR			LoopBuffer[MAX_LOOKAHEAD];

	ULONG			SendPackets;

} ADAPTER, *PADAPTER;

//
// This macro returns a pointer to the LOOP reserved portion of the packet
//
#define	PRESERVED_FROM_PACKET(Packet)	 ((PPACKET_RESERVED)((PVOID)((Packet)->MacReserved)))

#define	PPACKET_FROM_RESERVED(Reserved) ((PNDIS_PACKET)((PVOID)((Reserved)->Packet)))

typedef struct _PACKET_RESERVED
{
	PNDIS_PACKET	Next;
	USHORT			PacketLength;
	UCHAR			HeaderLength;
} PACKET_RESERVED, *PPACKET_RESERVED;

//
// Miniport proto-types
//
NDIS_STATUS
LBInitialize(
	OUT PNDIS_STATUS			OpenErrorStatus,
	OUT PUINT					SelectedMediumIndex,
	IN	PNDIS_MEDIUM			MediumArray,
	IN	UINT					MediumArraySize,
	IN	NDIS_HANDLE				MiniportAdapterHandle,
	IN	NDIS_HANDLE				ConfigurationContext
	);

NDIS_STATUS
LBSend(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet,
	IN	UINT					Flags
	);

NDIS_STATUS
LBQueryInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesWritten,
	OUT PULONG					BytesNeeded
	);

NDIS_STATUS
LBSetInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesRead,
	OUT PULONG					BytesNeeded
	);

VOID
LBHalt(
	IN	NDIS_HANDLE				MiniportAdapterContext
	);

NDIS_STATUS
LBReset(
	OUT PBOOLEAN				AddressingReset,
	IN	NDIS_HANDLE				MiniportAdapterContext
	);

BOOLEAN
LBCheckForHang(
	IN	NDIS_HANDLE				MiniportAdapterContext
	);

NDIS_STATUS
LBTransferData(
	OUT PNDIS_PACKET			Packet,
	OUT PUINT					BytesTransferred,
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_HANDLE				MiniportReceiveContext,
	IN	UINT					ByteOffset,
	IN	UINT					BytesToTransfer
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\loopback\lbmini.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	lpmini.c

Abstract:

	Loopback miniport

Author:

	Jameel Hyder	jameelh@microsoft.com

Environment:


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

NDIS_OID LBSupportedOidArray[] =
{
	OID_GEN_SUPPORTED_LIST,
	OID_GEN_HARDWARE_STATUS,
	OID_GEN_MEDIA_SUPPORTED,
	OID_GEN_MEDIA_IN_USE,
	OID_GEN_MAXIMUM_LOOKAHEAD,
	OID_GEN_MAXIMUM_FRAME_SIZE,
	OID_GEN_MAC_OPTIONS,
	OID_GEN_PROTOCOL_OPTIONS,
	OID_GEN_LINK_SPEED,
	OID_GEN_TRANSMIT_BUFFER_SPACE,
	OID_GEN_RECEIVE_BUFFER_SPACE,
	OID_GEN_TRANSMIT_BLOCK_SIZE,
	OID_GEN_RECEIVE_BLOCK_SIZE,
	OID_GEN_VENDOR_ID,
	OID_GEN_VENDOR_DESCRIPTION,
	OID_GEN_CURRENT_PACKET_FILTER,
	OID_GEN_CURRENT_LOOKAHEAD,
	OID_GEN_DRIVER_VERSION,
	OID_GEN_MAXIMUM_TOTAL_SIZE,

	OID_GEN_XMIT_OK,
	OID_GEN_RCV_OK,
	OID_GEN_XMIT_ERROR,
	OID_GEN_RCV_ERROR,
	OID_GEN_RCV_NO_BUFFER,

	OID_802_3_PERMANENT_ADDRESS,
	OID_802_3_CURRENT_ADDRESS,
	OID_802_3_MULTICAST_LIST,
	OID_802_3_MAXIMUM_LIST_SIZE,

	OID_802_3_RCV_ERROR_ALIGNMENT,
	OID_802_3_XMIT_ONE_COLLISION,
	OID_802_3_XMIT_MORE_COLLISIONS,

	OID_802_5_PERMANENT_ADDRESS,
	OID_802_5_CURRENT_ADDRESS,
	OID_802_5_CURRENT_FUNCTIONAL,
	OID_802_5_CURRENT_GROUP,
	OID_802_5_LAST_OPEN_STATUS,
	OID_802_5_CURRENT_RING_STATUS,
	OID_802_5_CURRENT_RING_STATE,

	OID_802_5_LINE_ERRORS,
	OID_802_5_LOST_FRAMES,

	OID_FDDI_LONG_PERMANENT_ADDR,
	OID_FDDI_LONG_CURRENT_ADDR,
	OID_FDDI_LONG_MULTICAST_LIST,
	OID_FDDI_LONG_MAX_LIST_SIZE,
	OID_FDDI_SHORT_PERMANENT_ADDR,
	OID_FDDI_SHORT_CURRENT_ADDR,
	OID_FDDI_SHORT_MULTICAST_LIST,
	OID_FDDI_SHORT_MAX_LIST_SIZE,

	OID_LTALK_CURRENT_NODE_ID,

	OID_ARCNET_PERMANENT_ADDRESS,
	OID_ARCNET_CURRENT_ADDRESS
};

UINT	LBSupportedOids = sizeof(LBSupportedOidArray)/sizeof(NDIS_OID);
UCHAR	LBVendorDescription[] = "MS LoopBack Driver";
UCHAR	LBVendorId[3] = {0xFF, 0xFF, 0xFF};
const	NDIS_PHYSICAL_ADDRESS physicalConst = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);
LONG	LoopDebugLevel = DBG_LEVEL_ERR;
LONG	LoopDebugComponent = DBG_COMP_ALL;

const MEDIA_INFO MediaParams[] =
	{
		/* NdisMedium802_3     */   { 1500, 14, PACKET_FILTER_802_3, 100000},
		/* NdisMedium802_5     */   { 4082, 14, PACKET_FILTER_802_5,  40000},
		/* NdisMediumFddi      */   { 4486, 13, PACKET_FILTER_FDDI, 1000000},
		/* NdisMediumWan       */   { 0, 0, 0, 0},
		/* NdisMediumLocalTalk */   {  600,  3, PACKET_FILTER_LTALK, 2300},
		/* NdisMediumDix       */   { 1500, 14, PACKET_FILTER_DIX, 100000},
		/* NdisMediumArcnetRaw */   { 1512,  3, PACKET_FILTER_ARCNET, 25000},
		/* NdisMediumArcnet878_2 */ {1512, 3, PACKET_FILTER_ARCNET, 25000}
	};

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT		DriverObject,
	IN	PUNICODE_STRING		RegistryPath
	)
/*++

Routine Description:


Arguments:

Return Value:


--*/
{
	NDIS_STATUS						Status;
	NDIS_MINIPORT_CHARACTERISTICS	MChars;
	NDIS_STRING						Name;
	NDIS_HANDLE						WrapperHandle;

	//
	// Register the miniport with NDIS.
	//
    NdisMInitializeWrapper(&WrapperHandle, DriverObject, RegistryPath, NULL);

	NdisZeroMemory(&MChars, sizeof(NDIS_MINIPORT_CHARACTERISTICS));

	MChars.MajorNdisVersion = NDIS_MAJOR_VERSION;
	MChars.MinorNdisVersion = NDIS_MINOR_VERSION;

	MChars.InitializeHandler = LBInitialize;
	MChars.QueryInformationHandler = LBQueryInformation;
	MChars.SetInformationHandler = LBSetInformation;
	MChars.ResetHandler = LBReset;
	MChars.TransferDataHandler = LBTransferData;
	MChars.SendHandler = LBSend;
	MChars.HaltHandler = LBHalt;
	MChars.CheckForHangHandler = LBCheckForHang;

	Status = NdisMRegisterMiniport(WrapperHandle,
								   &MChars,
								   sizeof(MChars));
	if (Status != NDIS_STATUS_SUCCESS)
	{
		NdisTerminateWrapper(WrapperHandle, NULL);
	}

	return(Status);
}


NDIS_STATUS
LBInitialize(
	OUT PNDIS_STATUS			OpenErrorStatus,
	OUT PUINT					SelectedMediumIndex,
	IN	PNDIS_MEDIUM			MediumArray,
	IN	UINT					MediumArraySize,
	IN	NDIS_HANDLE				MiniportAdapterHandle,
	IN	NDIS_HANDLE				ConfigurationContext
	)
/*++

Routine Description:

	This is the initialize handler.

Arguments:

	OpenErrorStatus			Not used by us.
	SelectedMediumIndex		Place-holder for what media we are using
	MediumArray				Array of ndis media passed down to us to pick from
	MediumArraySize			Size of the array
	MiniportAdapterHandle	The handle NDIS uses to refer to us
	WrapperConfigurationContext	For use by NdisOpenConfiguration

Return Value:

	NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
	UINT							i, Length;
	PADAPTER						pAdapt;
	NDIS_MEDIUM						AdapterMedium;
	NDIS_HANDLE 					ConfigHandle = NULL;
	PNDIS_CONFIGURATION_PARAMETER	Parameter;
	PUCHAR							NetworkAddress;
	NDIS_STRING						MediumKey = NDIS_STRING_CONST("Medium");
	NDIS_STATUS						Status;

	do
	{
		//
		// Start off by allocating the adapter block
		//
		NdisAllocateMemory(&pAdapt,
						   sizeof(ADAPTER),
						   0,
						   physicalConst);
		if (pAdapt == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
	
		NdisZeroMemory(pAdapt, sizeof(ADAPTER));
		pAdapt->MiniportHandle = MiniportAdapterHandle;
	
		NdisOpenConfiguration(&Status,
							  &ConfigHandle,
							  ConfigurationContext);
	
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGPRINT(DBG_COMP_REGISTRY, DBG_LEVEL_FATAL,
					("Unable to open configuration database!\n"));
			break;
		}
	
		NdisReadConfiguration(&Status,
							  &Parameter,
							  ConfigHandle,
							  &MediumKey,
							  NdisParameterInteger);
	
		AdapterMedium = NdisMedium802_3;	// Default
		if (Status == NDIS_STATUS_SUCCESS)
		{
			AdapterMedium = (NDIS_MEDIUM)Parameter->ParameterData.IntegerData;
			if ((AdapterMedium != NdisMedium802_3)		&&
				(AdapterMedium != NdisMedium802_5)		&&
				(AdapterMedium != NdisMediumFddi)		&&
				(AdapterMedium != NdisMediumLocalTalk)	&&
				(AdapterMedium != NdisMediumArcnet878_2))
			{
				DBGPRINT(DBG_COMP_REGISTRY, DBG_LEVEL_FATAL,
						("Unable to find 'Medium' keyword or invalid value!\n"));
				Status = NDIS_STATUS_NOT_SUPPORTED;
				break;
			}

		}

		switch (AdapterMedium)
		{
		  case NdisMedium802_3:
			NdisMoveMemory(pAdapt->PermanentAddress,
						   ETH_CARD_ADDRESS,
						   ETH_LENGTH_OF_ADDRESS);
	
			NdisMoveMemory(pAdapt->CurrentAddress,
						   ETH_CARD_ADDRESS,
						   ETH_LENGTH_OF_ADDRESS);
			break;
		  case NdisMedium802_5:
			NdisMoveMemory(pAdapt->PermanentAddress,
						   TR_CARD_ADDRESS,
						   TR_LENGTH_OF_ADDRESS);
	
			NdisMoveMemory(pAdapt->CurrentAddress,
						   TR_CARD_ADDRESS,
						   TR_LENGTH_OF_ADDRESS);
			break;
		  case NdisMediumFddi:
			NdisMoveMemory(pAdapt->PermanentAddress,
						   FDDI_CARD_ADDRESS,
						   FDDI_LENGTH_OF_LONG_ADDRESS);
	
			NdisMoveMemory(pAdapt->CurrentAddress,
						   FDDI_CARD_ADDRESS,
						   FDDI_LENGTH_OF_LONG_ADDRESS);
			break;
		  case NdisMediumLocalTalk:
			pAdapt->PermanentAddress[0] = LTALK_CARD_ADDRESS;
	
			pAdapt->CurrentAddress[0] = LTALK_CARD_ADDRESS;
			break;
		  case NdisMediumArcnet878_2:
			pAdapt->PermanentAddress[0] = ARC_CARD_ADDRESS;
			pAdapt->CurrentAddress[0] = ARC_CARD_ADDRESS;
			break;
		}
	
		pAdapt->Medium = AdapterMedium;
		pAdapt->MediumLinkSpeed = MediaParams[(UINT)AdapterMedium].LinkSpeed;
		pAdapt->MediumMinPacketLen = MediaParams[(UINT)AdapterMedium].MacHeaderLen;
		pAdapt->MediumMaxPacketLen = MediaParams[(UINT)AdapterMedium].MacHeaderLen+
									 MediaParams[(UINT)AdapterMedium].MaxFrameLen;
		pAdapt->MediumMacHeaderLen = MediaParams[(UINT)AdapterMedium].MacHeaderLen;
		pAdapt->MediumMaxFrameLen  = MediaParams[(UINT)AdapterMedium].MaxFrameLen;
		pAdapt->MediumPacketFilters = MediaParams[(UINT)AdapterMedium].PacketFilters;

		NdisReadNetworkAddress(&Status,
							   &NetworkAddress,
							   &Length,
							   ConfigHandle);
	
		if (Status == NDIS_STATUS_SUCCESS)
		{
			//
			// verify the address is appropriate for the specific media and
			// ensure that the locally administered address bit is set
			//
			switch (AdapterMedium)
			{
			  case NdisMedium802_3:
			  case NdisMediumFddi:
				if ((Length != ETH_LENGTH_OF_ADDRESS) ||
					ETH_IS_MULTICAST(NetworkAddress) ||
					((NetworkAddress[0] & 0x02) == 0))
				{
					Length = 0;
				}
				break;
	
			  case NdisMedium802_5:
				if ((Length != TR_LENGTH_OF_ADDRESS) ||
					(NetworkAddress[0] & 0x80) ||
					((NetworkAddress[0] & 0x40) == 0))
				{
					Length = 0;
				}
				break;
	
			  case NdisMediumLocalTalk:
				if ((Length != 1) || LT_IS_BROADCAST(NetworkAddress[0]))
				{
					Length = 0;
				}
				break;
	
			  case NdisMediumArcnet878_2:
				if ((Length != 1) || ARC_IS_BROADCAST(NetworkAddress[0]))
				{
					Length = 0;
				}
				break;
			}
	
			if (Length == 0)
			{
				DBGPRINT(DBG_COMP_REGISTRY, DBG_LEVEL_FATAL,
						("Invalid NetAddress in registry!\n"));
			}
			else
			{
				NdisMoveMemory(pAdapt->CurrentAddress,
							   NetworkAddress,
							   Length);
			}
		}
	
		//
		// Make sure the medium saved is one of the ones being offered
		//
		for (i = 0; i < MediumArraySize; i++)
		{
			if (MediumArray[i] == AdapterMedium)
			{
				*SelectedMediumIndex = i;
				break;
			}
		}
	
		if (i == MediumArraySize)
		{
			Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
			break;
		}
	
		//
		// Set the attributes now.
		//
		NdisMSetAttributesEx(MiniportAdapterHandle,
							 pAdapt,
							 0,										// CheckForHangTimeInSeconds
							 NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT|NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT,
							 0);
		Status = NDIS_STATUS_SUCCESS;
	} while (FALSE);

	if (ConfigHandle != NULL)
	{
		NdisCloseConfiguration(ConfigHandle);
	}

	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pAdapt != NULL)
		{
			NdisFreeMemory(pAdapt, sizeof(ADAPTER), 0);
		}
	}

	return Status;
}


VOID
LBHalt(
	IN	NDIS_HANDLE				MiniportAdapterContext
	)
/*++

Routine Description:

	Halt handler.

Arguments:

	MiniportAdapterContext	Pointer to the Adapter

Return Value:

	None.

--*/
{
	PADAPTER	pAdapt = (PADAPTER)MiniportAdapterContext;

	//
	// Free the resources now
	//
	NdisFreeMemory(pAdapt, sizeof(ADAPTER), 0);
}


NDIS_STATUS
LBReset(
	OUT PBOOLEAN				AddressingReset,
	IN	NDIS_HANDLE				MiniportAdapterContext
	)
/*++

Routine Description:

	Reset Handler. We just don't do anything.

Arguments:

	AddressingReset			To let NDIS know whether we need help from it with our reset
	MiniportAdapterContext	Pointer to our adapter

Return Value:

	
--*/
{
	PADAPTER	pAdapt = (PADAPTER)MiniportAdapterContext;

	*AddressingReset = FALSE;

	return(NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
LBSend(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet,
	IN	UINT					Flags
	)
/*++

Routine Description:

	Send handler. Just re-wrap the packet and send it below. Re-wrapping is necessary since
	NDIS uses the WrapperReserved for its own use.

Arguments:

	MiniportAdapterContext	Pointer to the adapter
	Packet					Packet to send
	Flags					Unused, passed down below

Return Value:

	Return code from NdisSend

--*/
{
    
        PADAPTER	pAdapt = (PADAPTER)MiniportAdapterContext;
    
        pAdapt->SendPackets++;
	
        return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
LBQueryInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesWritten,
	OUT PULONG					BytesNeeded
	)
/*++

Routine Description:

	Miniport QueryInfo handler.

Arguments:

	MiniportAdapterContext	Pointer to the adapter structure
	Oid						Oid for this query
	InformationBuffer		Buffer for information
	InformationBufferLength	Size of this buffer
	BytesWritten			Specifies how much info is written
	BytesNeeded				In case the buffer is smaller than what we need, tell them how much is needed

Return Value:

	Return code from the NdisRequest below.

--*/
{
	PADAPTER	pAdapt = (PADAPTER)MiniportAdapterContext;
	NDIS_STATUS	Status = NDIS_STATUS_SUCCESS;
	UINT		i;
	NDIS_OID	MaskOid;
	PVOID		SourceBuffer;
	UINT		SourceBufferLength;
	ULONG		GenericUlong = 0;
	USHORT		GenericUshort;

    *BytesWritten = 0;
    *BytesNeeded = 0;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
			("OID = %lx\n", Oid));


	for (i = 0;i < LBSupportedOids; i++)
	{
		if (Oid == LBSupportedOidArray[i])
			break;
	}

	if ((i == LBSupportedOids) ||
		(((Oid & OID_TYPE) != OID_TYPE_GENERAL)		 &&
		 (((pAdapt->Medium == NdisMedium802_3)		 && ((Oid & OID_TYPE) != OID_TYPE_802_3)) ||
		  ((pAdapt->Medium == NdisMedium802_5)		 && ((Oid & OID_TYPE) != OID_TYPE_802_5)) ||
		  ((pAdapt->Medium == NdisMediumFddi)		 && ((Oid & OID_TYPE) != OID_TYPE_FDDI))  ||
		  ((pAdapt->Medium == NdisMediumLocalTalk)   && ((Oid & OID_TYPE) != OID_TYPE_LTALK)) ||
		  ((pAdapt->Medium == NdisMediumArcnet878_2) && ((Oid & OID_TYPE) != OID_TYPE_ARCNET)))))
	{
		return NDIS_STATUS_INVALID_OID;
	}

	//
	// Initialize these once, since this is the majority of cases.
	//

	SourceBuffer = (PVOID)&GenericUlong;
	SourceBufferLength = sizeof(ULONG);

	switch (Oid & OID_TYPE_MASK)
	{
	  case OID_TYPE_GENERAL_OPERATIONAL:
                switch (Oid)
		{
		  case OID_GEN_MAC_OPTIONS:
			GenericUlong = (ULONG)(NDIS_MAC_OPTION_NO_LOOPBACK);
			break;

		  case OID_GEN_SUPPORTED_LIST:
			SourceBuffer = LBSupportedOidArray;
			SourceBufferLength = LBSupportedOids * sizeof(ULONG);
			break;

		  case OID_GEN_HARDWARE_STATUS:
			GenericUlong = NdisHardwareStatusReady;
			break;

		  case OID_GEN_MEDIA_SUPPORTED:
		  case OID_GEN_MEDIA_IN_USE:
			GenericUlong = pAdapt->Medium;
			break;

		  case OID_GEN_MAXIMUM_LOOKAHEAD:
			GenericUlong = MAX_LOOKAHEAD;
			break;

		  case OID_GEN_MAXIMUM_FRAME_SIZE:
			GenericUlong = pAdapt->MediumMaxFrameLen;
			break;

		  case OID_GEN_LINK_SPEED:
			GenericUlong = pAdapt->MediumLinkSpeed;
			break;

		  case OID_GEN_TRANSMIT_BUFFER_SPACE:
			GenericUlong = pAdapt->MediumMaxPacketLen;
			break;

		  case OID_GEN_RECEIVE_BUFFER_SPACE:
			GenericUlong = pAdapt->MediumMaxPacketLen;
			break;

		  case OID_GEN_TRANSMIT_BLOCK_SIZE:
			GenericUlong = 1;
			break;

		  case OID_GEN_RECEIVE_BLOCK_SIZE:
			GenericUlong = 1;
			break;

		  case OID_GEN_VENDOR_ID:
			SourceBuffer = LBVendorId;
			SourceBufferLength = sizeof(LBVendorId);
			break;

		  case OID_GEN_VENDOR_DESCRIPTION:
			SourceBuffer = LBVendorDescription;
			SourceBufferLength = sizeof(LBVendorDescription);
			break;

		  case OID_GEN_CURRENT_PACKET_FILTER:
			GenericUlong = pAdapt->PacketFilter;
			break;

		  case OID_GEN_CURRENT_LOOKAHEAD:
			GenericUlong = pAdapt->MaxLookAhead;
			break;

		  case OID_GEN_DRIVER_VERSION:
			GenericUshort = (LOOP_MAJOR_VERSION << 8) + LOOP_MINOR_VERSION;
			SourceBuffer = &GenericUshort;
			SourceBufferLength = sizeof(USHORT);
			break;

		  case OID_GEN_MAXIMUM_TOTAL_SIZE:
			GenericUlong = pAdapt->MediumMaxPacketLen;
			break;

		  default:
			ASSERT(FALSE);
			break;
		}
		break;

          case OID_TYPE_GENERAL_STATISTICS:
                MaskOid = (Oid & OID_INDEX_MASK) - 1;
                switch (Oid & OID_REQUIRED_MASK)
                {
                  case OID_REQUIRED_MANDATORY:
                        switch(Oid)
                        {
                   
                          case OID_GEN_XMIT_OK:
                                SourceBuffer = &(pAdapt->SendPackets);
                                SourceBufferLength = sizeof(ULONG);
                                break;
                      
                          default: 
                                ASSERT (MaskOid < GM_ARRAY_SIZE);
                                GenericUlong = pAdapt->GeneralMandatory[MaskOid];
                                break;
                        }
              
                        break;

                  default:
                        ASSERT(FALSE);
                        break;
                }
                break;

	  case OID_TYPE_802_3_OPERATIONAL:

		switch (Oid)
		{
		  case OID_802_3_PERMANENT_ADDRESS:
			SourceBuffer = pAdapt->PermanentAddress;
			SourceBufferLength = ETH_LENGTH_OF_ADDRESS;
			break;
		  case OID_802_3_CURRENT_ADDRESS:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = ETH_LENGTH_OF_ADDRESS;
			break;

		  case OID_802_3_MAXIMUM_LIST_SIZE:
			GenericUlong = ETH_MAX_MULTICAST_ADDRESS;
			break;

		  default:
			ASSERT(FALSE);
			break;
		}
		break;

	  case OID_TYPE_802_3_STATISTICS:

		switch (Oid)
		{
		  case OID_802_3_RCV_ERROR_ALIGNMENT:
		  case OID_802_3_XMIT_ONE_COLLISION:
		  case OID_802_3_XMIT_MORE_COLLISIONS:
			GenericUlong = 0;
			break;

		  default:
			ASSERT(FALSE);
			break;
		}
		break;

	  case OID_TYPE_802_5_OPERATIONAL:

		switch (Oid)
		{
		  case OID_802_5_PERMANENT_ADDRESS:
			SourceBuffer = pAdapt->PermanentAddress;
			SourceBufferLength = TR_LENGTH_OF_ADDRESS;
			break;

		  case OID_802_5_CURRENT_ADDRESS:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = TR_LENGTH_OF_ADDRESS;
			break;

		  case OID_802_5_LAST_OPEN_STATUS:
			GenericUlong = 0;
			break;

		  case OID_802_5_CURRENT_RING_STATUS:
			GenericUlong = NDIS_RING_SINGLE_STATION;
			break;

		  case OID_802_5_CURRENT_RING_STATE:
			GenericUlong = NdisRingStateOpened;
			break;

		  default:
			ASSERT(FALSE);
			break;

		}
		break;

	  case OID_TYPE_802_5_STATISTICS:

		switch (Oid)
		{
		  case OID_802_5_LINE_ERRORS:
		  case OID_802_5_LOST_FRAMES:
			GenericUlong = 0;
			break;

		  default:
			ASSERT(FALSE);
			break;
		}
		break;

	  case OID_TYPE_FDDI_OPERATIONAL:

		switch (Oid)
		{
		  case OID_FDDI_LONG_PERMANENT_ADDR:
			SourceBuffer = pAdapt->PermanentAddress;
			SourceBufferLength = FDDI_LENGTH_OF_LONG_ADDRESS;
			break;

		  case OID_FDDI_LONG_CURRENT_ADDR:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = FDDI_LENGTH_OF_LONG_ADDRESS;
			break;

		  case OID_FDDI_LONG_MAX_LIST_SIZE:
			GenericUlong = FDDI_MAX_MULTICAST_LONG;
			break;

		  case OID_FDDI_SHORT_PERMANENT_ADDR:
			SourceBuffer = pAdapt->PermanentAddress;
			SourceBufferLength = FDDI_LENGTH_OF_SHORT_ADDRESS;
			break;

		  case OID_FDDI_SHORT_CURRENT_ADDR:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = FDDI_LENGTH_OF_SHORT_ADDRESS;
			break;

		  case OID_FDDI_SHORT_MAX_LIST_SIZE:
			GenericUlong = FDDI_MAX_MULTICAST_SHORT;
			break;

		default:
			ASSERT(FALSE);
			break;
		}
		break;

  case OID_TYPE_LTALK_OPERATIONAL:

		switch(Oid)
		{
		  case OID_LTALK_CURRENT_NODE_ID:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = 1;
			break;

		default:
			ASSERT(FALSE);
			break;
		}
		break;

    case OID_TYPE_ARCNET_OPERATIONAL:
		switch(Oid)
		{
		  case OID_ARCNET_PERMANENT_ADDRESS:
			SourceBuffer = pAdapt->PermanentAddress;
			SourceBufferLength = 1;
			break;

		  case OID_ARCNET_CURRENT_ADDRESS:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = 1;
			break;

		  default:
			ASSERT(FALSE);
			break;

		}
		break;

	  default:
		ASSERT(FALSE);
		break;
	}

	if (SourceBufferLength > InformationBufferLength)
	{
		*BytesNeeded = SourceBufferLength;
		return NDIS_STATUS_BUFFER_TOO_SHORT;
	}

	NdisMoveMemory(InformationBuffer, SourceBuffer, SourceBufferLength);
	*BytesWritten = SourceBufferLength;
	
    return(Status);
}


NDIS_STATUS
LBSetInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesRead,
	OUT PULONG					BytesNeeded
	)
/*++

Routine Description:

	Miniport SetInfo handler.

Arguments:

	MiniportAdapterContext	Pointer to the adapter structure
	Oid						Oid for this query
	InformationBuffer		Buffer for information
	InformationBufferLength	Size of this buffer
	BytesRead				Specifies how much info is read
	BytesNeeded				In case the buffer is smaller than what we need, tell them how much is needed

Return Value:

	Return code from the NdisRequest below.

--*/
{
	PADAPTER	pAdapt = (PADAPTER)MiniportAdapterContext;
	NDIS_STATUS	Status = NDIS_STATUS_SUCCESS;

    *BytesRead = 0;
    *BytesNeeded = 0;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
			("SetInformation: OID = %lx\n", Oid));

    switch (Oid)
	{
	  case OID_GEN_CURRENT_PACKET_FILTER:
        if (InformationBufferLength != sizeof(ULONG))
		{
            Status = NDIS_STATUS_INVALID_DATA;
        }
		else
		{
			ULONG	PacketFilter;

			PacketFilter = *(UNALIGNED ULONG *)InformationBuffer;

			if (PacketFilter != (PacketFilter & pAdapt->MediumPacketFilters))
			{
				Status = NDIS_STATUS_NOT_SUPPORTED;
			}
			else
			{
				pAdapt->PacketFilter = PacketFilter;
				*BytesRead = InformationBufferLength;
			}
		}
        break;

	  case OID_GEN_CURRENT_LOOKAHEAD:
        if (InformationBufferLength != sizeof(ULONG))
		{
			Status = NDIS_STATUS_INVALID_DATA;
		}
		else
		{
			ULONG	CurrentLookahead;

			CurrentLookahead = *(UNALIGNED ULONG *)InformationBuffer;
	
			if (CurrentLookahead > MAX_LOOKAHEAD)
			{
				Status = NDIS_STATUS_INVALID_LENGTH;
			}
			else if (CurrentLookahead >= pAdapt->MaxLookAhead)
			{
				pAdapt->MaxLookAhead = CurrentLookahead;
				*BytesRead = sizeof(ULONG);
				Status = NDIS_STATUS_SUCCESS;
			}
		}
		break;

	  case OID_802_3_MULTICAST_LIST:
		if (pAdapt->Medium != NdisMedium802_3)
		{
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}

		if ((InformationBufferLength % ETH_LENGTH_OF_ADDRESS) != 0)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}
		break;

	  case OID_802_5_CURRENT_FUNCTIONAL:
		if (pAdapt->Medium != NdisMedium802_5)
		{
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}

		if (InformationBufferLength != TR_LENGTH_OF_FUNCTIONAL)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}
		break;

	  case OID_802_5_CURRENT_GROUP:
		if (pAdapt->Medium != NdisMedium802_5)
		{
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}

		if (InformationBufferLength != TR_LENGTH_OF_FUNCTIONAL)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}
		break;

	  case OID_FDDI_LONG_MULTICAST_LIST:
		if (pAdapt->Medium != NdisMediumFddi)
		{
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}

		if ((InformationBufferLength % FDDI_LENGTH_OF_LONG_ADDRESS) != 0)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}
		break;

	  case OID_FDDI_SHORT_MULTICAST_LIST:
		if (pAdapt->Medium != NdisMediumFddi)
		{
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}

		if ((InformationBufferLength % FDDI_LENGTH_OF_SHORT_ADDRESS) != 0)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}
		break;

	  case OID_GEN_PROTOCOL_OPTIONS:
		Status = NDIS_STATUS_SUCCESS;
		break;

	  default:
		Status = NDIS_STATUS_INVALID_OID;
		break;
    }

	return(Status);
}

BOOLEAN
LBCheckForHang(
	IN	NDIS_HANDLE				MiniportAdapterContext
	)
{
	return FALSE;
}


NDIS_STATUS
LBTransferData(
	OUT PNDIS_PACKET			Packet,
	OUT PUINT					BytesTransferred,
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_HANDLE				MiniportReceiveContext,
	IN	UINT					ByteOffset,
	IN	UINT					BytesToTransfer
	)
{
	ASSERT (0);

	return NDIS_STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\pnptst\netpnp.c ===
typedef	unsigned int	UINT;

#include <ntosp.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>
#include <ndispnp.h>

WCHAR				LCBuf[256];
WCHAR				UCBuf[256];
WCHAR				BLBuf[4096];
CHAR				ASBuf[128];
NIC_STATISTICS	    Stats;
UNICODE_STRING		LC = {0, sizeof(LCBuf), LCBuf};
UNICODE_STRING		UC = {0, sizeof(UCBuf), UCBuf};
UNICODE_STRING		BL = {0, sizeof(BLBuf), BLBuf};
ANSI_STRING			AS = {0, sizeof(ASBuf), ASBuf};
PNDIS_ENUM_INTF		Interfaces = (PNDIS_ENUM_INTF)BLBuf;
int					Layer = -1, Operation = -1;
extern	LONG		xxGetLastError();
char *				Ops[9] = { "", "BIND", "UNBIND", "RECONFIGURE", "", "", "", "STATS", "ENUM"};
char *				Intf[3] = { "", "NDIS", "TDI" };
#define	STATS		0x7
#define	ENUM		0x8
#define	MACADDR		0x9

void
help(
	void
	)
{
	fprintf(stderr, "netpnp -u<UpperComponent> -l<LowerComponent> -i<Interface> -a<Action> [-b<BindList>]\n");
	fprintf(stderr, "       where Interface is either NDIS or TDI\n");
	fprintf(stderr, "       where Action is BIND, UNBIND, ENUM, STATS, MACADDR or RECONFIGURE\n");
	fprintf(stderr, "  e.g. netpnp -uTCPIP -l\\Device\\{GUID} -iNDIS -aUNBIND\n");
	fprintf(stderr, "  e.g. netpnp -uSRV -l\\Device\\NETBT_{GUID} -iTDI -aBIND -b\"\\Device\\NETBT_{GUID} \\Device\\NETBT_{GUID}\n");
	fprintf(stderr, "  e.g. netpnp -l\\Device\\{GUID} -iNDIS -aSTATS\n");
}

BOOLEAN
icmp(
	char	*s1,
	char	*s2
	)
{
	char c1, c2;

	while (((c1 = *s1) != 0) && ((c2 = *s2) != 0))
	{
		c1 |= 0x20; c2 |= 0x20;
		if (c1 != c2)
		{
			break;
		}
		s1 ++; s2++;
	}

	return((*s1 == 0) && (*s2 == 0));
}


BOOLEAN
GetOptions(
    int     argc,
    char ** argv
	)
{
	int		i;
	char	c;

	if (argc < 2)
	{
		help();
		return(FALSE);
	}

	//
	// Default upper and lower component to NONE
	//
	UC.Length = 0;
	LC.Length = 0;

	for (i = 1; i < argc; i++)
	{
		c = argv[i][0];
		if (c == '-' || c == '/')
		{
			c = argv[i][1];
			switch (c)
			{
				case 'u':
				case 'U':
					RtlInitAnsiString(&AS, &argv[i][2]);
					RtlAnsiStringToUnicodeString(&UC, &AS, FALSE);
					break;
	
				case 'l':
				case 'L':
					RtlInitAnsiString(&AS, &argv[i][2]);
					RtlAnsiStringToUnicodeString(&LC, &AS, FALSE);
					break;
	
				case 'i':
				case 'I':
					if (icmp(&argv[i][2], "ndis"))
					{
						Layer = NDIS;
					}
					else if (icmp(&argv[i][2], "tdi"))
					{
						Layer = TDI;
					}
					break;
	
				case 'a':
				case 'A':
					if (icmp(&argv[i][2], "bind"))
					{
						Operation = BIND;
					}
					else if (icmp(&argv[i][2], "unbind"))
					{
						Operation = UNBIND;
					}
					else if (icmp(&argv[i][2], "reconfigure"))
					{
						Operation = RECONFIGURE;
					}
					else if (icmp(&argv[i][2], "stats"))
					{
						Operation = STATS;
					}
					else if (icmp(&argv[i][2], "enum"))
					{
						Operation = ENUM;
					}
					else if (icmp(&argv[i][2], "macaddr"))
					{
						Operation = MACADDR;
					}
					break;
	
				case 'b':
				case 'B':
					RtlInitAnsiString(&AS, &argv[i][2]);
					RtlAnsiStringToUnicodeString(&BL, &AS, FALSE);
					//
					// Convert the space separated strings to MULTI_SZ format.
					//
					for (i = 0; i < BL.Length; i++)
					{
						if (BL.Buffer[i] == L' ')
							BL.Buffer[i] = 0;
					}
					break;
	
				case '?':
				default:
					help();
					break;
			}
		}
	}

	if ((Operation <= 0) ||
		(Operation < STATS) && ((Layer <= 0) || (LC.Length == 0)))
	{
		help();
		fprintf(stderr, "Current parameters:\n");
		fprintf(stderr, "UpperComp %Z\n", &UC);
		fprintf(stderr, "LowerComp %Z\n", &LC);
		fprintf(stderr, "BindList %Z\n", &BL);
		fprintf(stderr, "Action %s\n", (Operation <= 0) ? "INVALID" : Ops[Operation]);
		fprintf(stderr, "Interface %s\n", (Layer <= 0) ? "INVALID" : Intf[Layer]);
		return(FALSE);
	}

	return(TRUE);
}

VOID
UTOA(
	IN	PUNICODE_STRING	U,
	OUT	PANSI_STRING	A
	)
{
	A->Length = 0;
	RtlUnicodeStringToAnsiString(A, U, FALSE);
}

#define	SECS_PER_DAY	(24*60*60)
#define	SECS_PER_HOUR	(60*60)
#define	SECS_PER_MIN	60

VOID _cdecl
main(
    int     argc,
    char ** argv
	)
{
	NTSTATUS		Status;
	UINT			i;

	if (!GetOptions(argc, argv))
		return;
	
	if (Operation == ENUM)
	{
		if (NdisEnumerateInterfaces(Interfaces, sizeof(BLBuf)))
		{
			ANSI_STRING	A;
			UCHAR		Buf[256];

			A.MaximumLength = sizeof(Buf);
			A.Buffer = Buf;

			for (i = 0; i < Interfaces->TotalInterfaces; i++)
			{
				UTOA(&Interfaces->Interface[i].DeviceName, &A),
				fprintf(stderr, "Device: %s\n\t",
						A.Buffer);
				UTOA(&Interfaces->Interface[i].DeviceDescription, &A);
				fprintf(stderr, "Description: %s\n",
						A.Buffer);
			}
		}
		else
		{
			Status = xxGetLastError();
			fprintf(stderr, "Enumerate failed %lx\n", Status);
		}
	}
	else if (Operation == MACADDR)
	{
		UCHAR	MacAddr[6];
		UCHAR	PMacAddr[6];
		UCHAR	VendorId[3];
		UINT	i;

		if (NdisQueryHwAddress(&LC, MacAddr, PMacAddr, VendorId))
		{
			fprintf(stderr, "HW Address:");
			for (i = 0; i < 5; i++)
			{
				fprintf(stderr, "%02x-", MacAddr[i]);
			}
			fprintf(stderr, "%02x\n", MacAddr[i]);

			fprintf(stderr, "Vendor Id:");
			for (i = 0; i < 2; i++)
			{
				fprintf(stderr, "%02x-", VendorId[i]);
			}
			fprintf(stderr, "%02x\n", VendorId[i]);
		}
		else
		{
			Status = xxGetLastError();
			fprintf(stderr, "Operation failed %lx\n", Status);
		}
	}
	else if (Operation == STATS)
	{
		Stats.Size = sizeof(NIC_STATISTICS);
		if (NdisQueryStatistics(&LC, &Stats))
		{
			fprintf(stderr, "Device Status:      %s\n",
					(Stats.DeviceState == DEVICE_STATE_CONNECTED) ? "On" : "Off");
			fprintf(stderr, "Link Status:        %s\n",
					(Stats.MediaState == MEDIA_STATE_CONNECTED) ? "On" : "Off");

			fprintf(stderr, "Init Time   :       %d ms\n", Stats.InitTime);
			fprintf(stderr, "Connect Time:       ");
			if (Stats.ConnectTime > SECS_PER_DAY)
			{
				fprintf(stderr, "%d days, ", Stats.ConnectTime / SECS_PER_DAY);
				Stats.ConnectTime %= SECS_PER_DAY;
			}
			fprintf(stderr, "%02d:", Stats.ConnectTime / SECS_PER_HOUR);
			Stats.ConnectTime %= SECS_PER_HOUR;
			fprintf(stderr, "%02d:", Stats.ConnectTime / SECS_PER_MIN);
			Stats.ConnectTime %= SECS_PER_MIN;
			fprintf(stderr, "%02d\n", Stats.ConnectTime);

            Stats.LinkSpeed *= 100;
			if (Stats.LinkSpeed >= 1000000000)
			  fprintf(stderr, "Media Speed:        %d Gbps\n", Stats.LinkSpeed / 1000000);
			else if (Stats.LinkSpeed >= 1000000)
			  fprintf(stderr, "Media Speed:        %d Mbps\n", Stats.LinkSpeed / 1000000);
			else if (Stats.LinkSpeed >= 1000)
			  fprintf(stderr, "Media Speed:        %d Kbps\n", Stats.LinkSpeed / 1000);
			else
			  fprintf(stderr, "Media Speed:        %d bps\n", Stats.LinkSpeed);

			fprintf(stderr, "\n");

			fprintf(stderr, "Packets Sent:       %I64d\n", Stats.PacketsSent);
			fprintf(stderr, "Bytes Sent:         %I64d\n", Stats.BytesSent);

			fprintf(stderr, "\n");

			fprintf(stderr, "Packets Received:   %I64d\n", Stats.PacketsReceived);
			fprintf(stderr, "Directed Pkts Recd: %I64d\n", Stats.DirectedPacketsReceived);
			fprintf(stderr, "Bytes Received:     %I64d\n", Stats.BytesReceived);
			fprintf(stderr, "Directed Bytes Recd:%I64d\n", Stats.DirectedBytesReceived);

			fprintf(stderr, "\n");

			if (Stats.PacketsSendErrors != 0)
				fprintf(stderr, "Packets SendError:  %d\n", Stats.PacketsSendErrors);
			if (Stats.PacketsReceiveErrors != 0)
				fprintf(stderr, "Packets RecvError:  %d\n", Stats.PacketsReceiveErrors);
			if (Stats.ResetCount != 0)
				fprintf(stderr, "Reset Count      :  %d\n", Stats.ResetCount);
			if (Stats.MediaSenseConnectCount != 0)
				fprintf(stderr, "Media Connects   :  %d\n", Stats.MediaSenseConnectCount);
			if (Stats.MediaSenseDisconnectCount != 0)
				fprintf(stderr, "Media Disconnects:  %d\n", Stats.MediaSenseDisconnectCount);
		}
		else
		{
			Status = xxGetLastError();
			fprintf(stderr, "GetStats failed %lx\n", Status);
		}
	}
	else if (!NdisHandlePnPEvent(Layer, Operation, &LC, &UC, &BL, NULL, 0))
	{
		Status = xxGetLastError();
		fprintf(stderr, "NdisHandlePnPEvent failed %lx\n", Status);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\bchannel.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL BChannel BChannel_h

@module BChannel.h |

    This module defines the interface to the <t BCHANNEL_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | BChannel_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 4.4 BChannel Overview |

    This section describes the interfaces defined in <f BChannel\.h>.

    This module isolates most the channel specific interfaces.  It will require
    some changes to accomodate your hardware device's channel access methods.
    
    There should be one <t BCHANNEL_OBJECT> for each logical channel your card
    supports.  For instance, if your PRI card has two ports with 24 channels
    each, you would publish up 48 BChannels to NDIS.
    
    The driver uses the <t BCHANNEL_OBJECT> as a synonym for CO-NDIS VC.  The
    VC handle we pass up to NDIS, is actually a pointer to a <t BCHANNEL_OBJECT>.
    
    The driver is written to assume a homogenous BChannel configuration.  If
    your card supports multiple ISDN ports that are provisioned differrently,
    you will have to make some serious changes throughout the driver.
*/

#ifndef _BCHANNEL_H
#define _BCHANNEL_H

#define BCHANNEL_OBJECT_TYPE    ((ULONG)'B')+\
                                ((ULONG)'C'<<8)+\
                                ((ULONG)'H'<<16)+\
                                ((ULONG)'N'<<24)


/* @doc INTERNAL BChannel BChannel_h BCHANNEL_OBJECT


@struct BCHANNEL_OBJECT |

    This structure contains the data associated with an ISDN BChannel.
    Here, BChannel is defined as any channel or collection of channels
    capable of carrying "user" data over and existing connection.  This
    channel is responsible for making sure the data payload is sent to or
    received from the remote end-point exactly as it is appeared at the
    originating station.

@comm

    This logical BChannel does not necessarily map to a physical BChannel
    on the NIC.  The NIC may in fact be bonding multiple BChannels into this
    logical BChannel.  The NIC may in fact not have BChannels at all, as
    may be the case with channelized T-1.  The BChannel is just a convenient
    abstraction for a point-to-point, bi-directional communication link.

    There will be one BChannel created for each communication channel on the
    NIC.  The number of channels depends on how many ports the NIC has, and
    how they are provisioned and configured.  The number of BChannels can be
    configured at install time or changed using the control panel.  The driver
    does not allow the configuration to change at run-time, so the computer
    or the adapter must be restarted to enable the configuration changes.

*/

typedef struct BCHANNEL_OBJECT
{
    LIST_ENTRY                  LinkList;
    // Used to maintain the linked list of available BChannels for each 
    // adapter.

    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'BCHN'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    BOOLEAN                     IsOpen;                     // @field
    // Set TRUE if this BChannel is open, otherwise set FALSE.

//
//  NDIS data members

    ULONG                       BChannelIndex;              // @field
    // This is a zero based index associated with this BChannel.
                                                            
    NDIS_HANDLE                 NdisVcHandle;               // @field
    // This is the WAN Wrapper's VC context which is associated with this
    // link in response to the Miniport calling <f NdisMIndicateStatus>
    // to indicate a <t NDIS_MAC_LINE_UP> condition.  This value is passed
    // back to the WAN Wrapper to indicate activity associated with this link,
    // such as <f NdisMWanIndicateReceive> and <f NdisMIndicateStatus>.
    // See <F MiniportCoActivateVc>.

    NDIS_HANDLE                 NdisSapHandle;              // @field
    // Used to store the NDIS SAP handle passed into 
    // <f ProtocolCmRegisterSap>.
    
    CO_AF_TAPI_SAP              NdisTapiSap;                // @field
    // A copy of the SAP registered by NDIS TAPI Proxy.

    ULONG                       LinkSpeed;                  // @field
    // The speed provided by the link in bits per second.  This value is
    // passed up by the Miniport during the LINE_UP indication.

    LIST_ENTRY                  ReceivePendingList;         // @field
    // Buffers currently submitted to the controller waiting for receive.

    LIST_ENTRY                  TransmitBusyList;           // @field
    // Packets currently submitted to the controller waiting for completion.
    // See <t NDIS_PACKET>.

    BOOLEAN                     NeedReceiveCompleteIndication;  // @field
    // This flag indicates whether or not <f NdisMWanIndicateReceiveComplete>
    // needs to be called after the completion of the event processing loop.
    // This is set TRUE if <f NdisMWanReceiveComplete> is called while
    // processing the event queues.

    NDIS_WAN_CO_SET_LINK_INFO   WanLinkInfo;                // @field
    // The current settings associated with this link as passed in via
    // the OID_WAN_SET_LINK_INFO request.

    ULONG                       TotalRxPackets;             // @field
    // Total packets read by driver during this session.

//
//  TAPI data members.

    BOOLEAN                     CallClosing;                // @field
    // Set TRUE if call is being closed.

    ULONG                       CallState;                  // @field
    // The current TAPI LINECALLSTATE of the associated with the link.

    ULONG                       CallStatesCaps;             // @field
    // Events currently supported

    ULONG                       AddressStatesCaps;          // @field
    // Events currently supported

    ULONG                       DevStatesCaps;              // @field
    // Events currently supported

    ULONG                       MediaMode;                  // @field
    // The current TAPI media mode(s) supported by the card.

    ULONG                       MediaModesCaps;             // @field
    // Events currently supported

    ULONG                       BearerMode;                 // @field
    // The current TAPI bearer mode in use.

    ULONG                       BearerModesCaps;            // @field
    // TAPI bearer mode(s) supported by the card.

    ULONG                       CallParmsSize;              // @field
    // Size of <p pInCallParms> memory area in bytes.
    
    PCO_CALL_PARAMETERS         pInCallParms;               // @field
    // Incoming call parameters.  Allocated as needed.

    PCO_CALL_PARAMETERS         pOutCallParms;              // @field
    // Pointer to the client's call parameters passed into
    // <f ProtocolCmMakeCall>.

    ULONG                       Flags;                      // @field
    // Bit flags used to keep track of VC state.
#   define  VCF_INCOMING_CALL   0x00000001
#   define  VCF_OUTGOING_CALL   0x00000002
#   define  VCF_VC_ACTIVE       0x00000004

//
//  CARD data members.

    ULONG                       TODO;                       // @field
    // Add your data members here.

#if defined(SAMPLE_DRIVER)
    PBCHANNEL_OBJECT            pPeerBChannel;              // @field
    // Peer BChannel of caller or callee depending on who orginated the
    // call.

#endif // SAMPLE_DRIVER

} BCHANNEL_OBJECT;

#define GET_ADAPTER_FROM_BCHANNEL(pBChannel)    (pBChannel->pAdapter)


/* @doc INTERNAL BChannel BChannel_h IS_VALID_BCHANNEL


@func ULONG | IS_VALID_BCHANNEL |
    Use this macro to determine if a <t BCHANNEL_OBJECT> is really valid.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm <t PBCHANNEL_OBJECT> | pBChannel |
    A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

@rdesc Returns TRUE if the BChannel is valid, otherwise FALSE is returned.

*/
#define IS_VALID_BCHANNEL(pAdapter, pBChannel) \
        (pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE)


/* @doc INTERNAL BChannel BChannel_h GET_BCHANNEL_FROM_INDEX


@func <t PBCHANNEL_OBJECT> | GET_BCHANNEL_FROM_INDEX |
    Use this macro to get a pointer to the <t BCHANNEL_OBJECT> associated
    with a zero-based Index.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm ULONG | BChannelIndex |
    Miniport BChannelIndex associated with a specific link.

@rdesc Returns a pointer to the associated <t BCHANNEL_OBJECT>.

*/
#define GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex) \
        (pAdapter->pBChannelArray[BChannelIndex]); \
        ASSERT(BChannelIndex < pAdapter->NumBChannels)

/*


    Function prototypes.

*/

NDIS_STATUS BChannelCreate(
    OUT PBCHANNEL_OBJECT *      pBChannel,
    IN ULONG                    BChannelIndex,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void BChannelDestroy(
    IN PBCHANNEL_OBJECT         pBChannel
    );

void BChannelInitialize(
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS BChannelOpen(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN NDIS_HANDLE              NdisVcHandle
    );

void BChannelClose(
    IN PBCHANNEL_OBJECT         pBChannel
    );

#endif // _BCHANNEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\bchannel.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL BChannel BChannel_c

@module BChannel.c |

    This module implements the interface to the <t BCHANNEL_OBJECT>.
    Supports the high-level channel control functions used by the CONDIS WAN
    Miniport driver.

@comm

    This module isolates most the channel specific interfaces.  It will require
    some changes to accomodate your hardware device's channel access methods.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | BChannel_c

@end

*/

#define  __FILEID__             BCHANNEL_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                g_BChannelInstanceCounter   // @globalv
// Keeps track of how many <t BCHANNEL_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL BChannel BChannel_c g_BChannelParameters


@topic 5.3 BChannel Parameters |

    This section describes the registry parameters read into the
    <t BCHANNEL_OBJECT>.

@globalv PARAM_TABLE | g_BChannelParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t BCHANNEL_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t BCHANNEL_OBJECT>
    you will need to modify <f BChannelReadParameters> and add the parameter
    definitions to the <f g_BChannelParameters> table.

*/

DBG_STATIC PARAM_TABLE          g_BChannelParameters[] =
{
    PARAM_ENTRY(BCHANNEL_OBJECT,
                TODO, PARAM_TODO,
                FALSE, NdisParameterInteger, 0,
                0, 0, 0),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL BChannel BChannel_c BChannelReadParameters


@func

    <f BChannelReadParameters> reads the BChannel parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f BChannelCreate>.

@rdesc

    <f BChannelReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

    <f Note>:
    If you add any registry based data members to <t BCHANNEL_OBJECT>
    you will need to modify <f BChannelReadParameters> and add the parameter
    definitions to the <f g_BChannelParameters> table.

*/

DBG_STATIC NDIS_STATUS BChannelReadParameters(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pBChannel,
                    g_BChannelParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pBChannel->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pBChannel->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL BChannel BChannel_c BChannelCreateObjects


@func

    <f BChannelCreateObjects> calls the create routines for all the objects
    contained in <t BCHANNEL_OBJECT>.  This should only be called
    by <f BChannelCreate>.

    <f Note>:
    If you add any new objects to <t BCHANNEL_OBJECT> you will need
    to modify <f BChannelCreateObjects> and <f BChannelDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f BChannelCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS BChannelCreateObjects(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelCreate


@func

    <f BChannelCreate> allocates memory for a <t BCHANNEL_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppBChannel> will be set to point to the newly created
    <t BCHANNEL_OBJECT>.  Otherwise, <p ppBChannel> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f BChannelDestroy> must be called to
    release the <t BCHANNEL_OBJECT> created by this function.

@rdesc

    <f BChannelCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelCreate(
    OUT PBCHANNEL_OBJECT *      ppBChannel,                 // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t BCHANNEL_OBJECT>.

    IN ULONG                    BChannelIndex,              // @parm
    // Index into the pBChannelArray.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("BChannelCreate")

    PBCHANNEL_OBJECT            pBChannel;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppBChannel = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pBChannel, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pBChannel->ObjectType = BCHANNEL_OBJECT_TYPE;
        pBChannel->ObjectID = ++g_BChannelInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pBChannel->pAdapter = pAdapter;
        pBChannel->BChannelIndex = BChannelIndex;

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = BChannelReadParameters(pBChannel);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = BChannelCreateObjects(pBChannel);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            InitializeListHead(&pBChannel->LinkList);
            *ppBChannel = pBChannel;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            BChannelDestroy(pBChannel);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelDestroyObjects


@func

    <f BChannelDestroyObjects> calls the destroy routines for all the objects
    contained in <t BCHANNEL_OBJECT>.  This should only be called by
    <f BChannelDestroy>.

    <f Note>:
    If you add any new objects to <t PBCHANNEL_OBJECT> you will need to
    modify <f BChannelCreateObjects> and <f BChannelDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void BChannelDestroyObjects(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here
    if (pBChannel->pInCallParms != NULL)
    {
        FREE_MEMORY(pBChannel->pInCallParms, pBChannel->CallParmsSize);
        pBChannel->pInCallParms = NULL;
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL BChannel BChannel_c BChannelDestroy


@func

    <f BChannelDestroy> frees the memory for this <t BCHANNEL_OBJECT>.
    All memory allocated by <f BChannelCreate> will be released back to the
    OS.

*/

void BChannelDestroy(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pBChannel)
    {
        ASSERT(pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        BChannelDestroyObjects(pBChannel);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pBChannel->ObjectType = 0;
        FREE_OBJECT(pBChannel);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL BChannel BChannel_c BChannelInitialize


@func

    <f BChannelInitialize> resets all the internal data members contained
    in <t BCHANNEL_OBJECT> back to their initial state.

    <f Note>:
    If you add any new members to <t BCHANNEL_OBJECT> you will need to
    modify <f BChannelInitialize> to initialize your new data mamebers.

*/

void BChannelInitialize(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelInitialize")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    /*
    // Initially, the BChannel is not allocated to anyone and these fields
    // must be reset.
    */
    ASSERT(pBChannel->NdisVcHandle == NULL);

    /*
    // Setup the static features of the link.
    */
    pBChannel->LinkSpeed         = _64KBPS;
    pBChannel->BearerModesCaps   = LINEBEARERMODE_DATA
                                 // | LINEBEARERMODE_VOICE
                                 ;
    pBChannel->MediaModesCaps    = LINEMEDIAMODE_DIGITALDATA
                                 | LINEMEDIAMODE_UNKNOWN
                                 // | LINEMEDIAMODE_DATAMODEM
                                 ;

    /*
    // Initialize the TAPI event capabilities supported by the link.
    */
    pBChannel->DevStatesCaps     = LINEDEVSTATE_RINGING
                                 | LINEDEVSTATE_CONNECTED
                                 | LINEDEVSTATE_DISCONNECTED
                                 | LINEDEVSTATE_INSERVICE
                                 | LINEDEVSTATE_OUTOFSERVICE
                                 | LINEDEVSTATE_OPEN
                                 | LINEDEVSTATE_CLOSE
                                 | LINEDEVSTATE_REINIT
                                 ;
    pBChannel->AddressStatesCaps = 0;
    pBChannel->CallStatesCaps    = LINECALLSTATE_IDLE
                                 | LINECALLSTATE_DIALING
                                 | LINECALLSTATE_OFFERING
                                 | LINECALLSTATE_CONNECTED
                                 | LINECALLSTATE_DISCONNECTED
                                 ;

    /*
    // Set the TransmitBusyList and ReceivePendingList to empty.
    */
    InitializeListHead(&pBChannel->TransmitBusyList);
    InitializeListHead(&pBChannel->ReceivePendingList);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL BChannel BChannel_c BChannelOpen


@func

    <f BChannelOpen> makes the BChannel connection ready to transmit and
    receive data.

@rdesc

    <f BChannelOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelOpen(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_HANDLE              NdisVcHandle                // @parm
    // Handle by which NDIS wrapper will refer to this BChannel.
    )
{
    DBG_FUNC("BChannelOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    if (!pBChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Opening BChannel #%d\n",
                   pBChannel->ObjectID));

        /*
        // The NdisVcHandle field is used to associate this BChannel with
        // the CoNdis Wrapper.  Reset all the state information for
        // this BChannel.
        */
        pBChannel->NdisVcHandle      = NdisVcHandle;
        pBChannel->CallClosing       = FALSE;
        pBChannel->CallState         = 0;
        pBChannel->MediaMode         = 0;
        pBChannel->TotalRxPackets    = 0;

        /*
        // Initialize the default BChannel information structure.  It may be
        // changed later by MiniportCoRequest.
        */
        pBChannel->WanLinkInfo.MaxSendFrameSize    = pAdapter->WanInfo.MaxFrameSize;
        pBChannel->WanLinkInfo.MaxRecvFrameSize    = pAdapter->WanInfo.MaxFrameSize;
        pBChannel->WanLinkInfo.SendFramingBits     = pAdapter->WanInfo.FramingBits;
        pBChannel->WanLinkInfo.RecvFramingBits     = pAdapter->WanInfo.FramingBits;
        pBChannel->WanLinkInfo.SendCompressionBits = 0;
        pBChannel->WanLinkInfo.RecvCompressionBits = 0;
        pBChannel->WanLinkInfo.SendACCM            = pAdapter->WanInfo.DesiredACCM;
        pBChannel->WanLinkInfo.RecvACCM            = pAdapter->WanInfo.DesiredACCM;

#if defined(SAMPLE_DRIVER)
        // Sample just tells tapi that the line is connected and in service.
#else  // SAMPLE_DRIVER
        // TODO - Add code here
#endif // SAMPLE_DRIVER

        pBChannel->IsOpen = TRUE;
    }
    else
    {
        Result = NDIS_STATUS_FAILURE;
        DBG_ERROR(pAdapter,("BChannel #%d already opened\n",
                  pBChannel->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelClose


@func

    <f BChannelClose> closes the given B-channel.

*/

void BChannelClose(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    if (pBChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Closing BChannel #%d\n",
                   pBChannel->ObjectID));

        /*
        // Make sure call is cleared and B channel is disabled.
        */
        DChannelCloseCall(pAdapter->pDChannel, pBChannel);

        // TODO - Add code here

        pBChannel->Flags        = 0;
        pBChannel->CallState    = 0;
        pBChannel->NdisVcHandle = NULL;
        pBChannel->IsOpen       = FALSE;
    }
    else
    {
        DBG_ERROR(pAdapter,("BChannel #%d already closed\n",
                  pBChannel->ObjectID));
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\card.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Card Card_h

@module Card.h |

    This module defines the hardware specific structures and values used to
    control the network interface card.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Card_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 4.2 Card Overview |

    This section describes the interfaces defined in <f Card\.h>.

    This module isolates most the vendor specific hardware access interfaces.
    It will require signficant changes to accomodate your hardware device.
    You should try to isolate your changes to the <t CARD_OBJECT> rather then
    the <t MINIPORT_ADAPTER_OBJECT>.  This will make it eaiser to reuse the
    upper portions of the driver should your hardware change in the future.

    The driver assumes one <t CARD_OBJECT> per physical ISDN card.  The card
    object is always available via the <t MINIPORT_ADAPTER_OBJECT> which is
    available in nearly every interface the driver supports.  Each
    <t CARD_OBJECT> contains one or more <t PORT_OBJECT>s depending on how
    many physical ISDN lines your card supports.

    You should add all your physical card related data to the <t CARD_OBJECT>.
    You can also add any card related registry parameters to this structure,
    and the <f g_CardParameters> table.
*/

#ifndef _CARD_H
#define _CARD_H

#define CARD_OBJECT_TYPE                ((ULONG)'C')+\
                                        ((ULONG)'A'<<8)+\
                                        ((ULONG)'R'<<16)+\
                                        ((ULONG)'D'<<24)

/*
// TODO - These values will normally come from the NIC or the installer.
*/
#define MAX_ADAPTERS                    8
#define CARD_NUM_PORTS                  1

//#define CARD_MIN_IOPORT_SIZE            256
// TODO - How many I/O ports does the card have?  (undefined if none)

//#define CARD_MIN_MEMORY_SIZE            256
// TODO - How much memory does the card have?  (undefined if none)

#define CARD_IS_BUS_MASTER              FALSE
// TODO - Is the card a bus master device?  (TRUE or FALSE)
#if (CARD_IS_BUS_MASTER)
#   define CARD_MAP_REGISTERS_NEEDED    NUM_DEV_PER_ADAP
// TODO - How many map registers needed to transmit data to card.
#endif

//#define CARD_REQUEST_ISR                TRUE
// TODO - How do you want to handle interrupts from the card?
// TRUE if you want to always use MiniportISR().
// FALSE if you want to use MiniportDisable() and MiniportEnable().
// Undefined if your card does not generate interrupts.

#if defined(CARD_REQUEST_ISR)

#define CARD_INTERRUPT_SHARED           TRUE
// TODO - Is your interrupt shared? (TRUE or FALSE).

#define CARD_INTERRUPT_MODE             NdisInterruptLevelSensitive
// TODO - Is your interrupt latched or level sensitve?

#endif // defined(CARD_REQUEST_ISR)

/*
// Maximum packet size allowed by the adapter -- must be restricted to
// 1500 bytes at this point, and must also allow for frames at least 32
// bytes longer.
*/
#define NDISWAN_EXTRA_SIZE              32
#define CARD_MIN_PACKET_SIZE            ( 480 + NDISWAN_EXTRA_SIZE)
#define CARD_MAX_PACKET_SIZE            (2016 + NDISWAN_EXTRA_SIZE)
#define CARD_DEFAULT_PACKET_SIZE        (1504 + NDISWAN_EXTRA_SIZE)

/*
// The WAN miniport must indicate the entire packet when it is received.
*/
#define CARD_MAX_LOOKAHEAD              (pAdapter->pCard->BufferSize)

/*
// Number of digits allowed in a phone number (not including spaces).
*/
#define CARD_MAX_DIAL_DIGITS            32

#define NULL_BUFFER_POOL                ((NDIS_HANDLE) -1)

/* @doc INTERNAL Card Card_h CARD_RESOURCES


@struct CARD_RESOURCES |

    This structure contains the data associated with the hardware resources
    required to configure the NIC.  These values are isolated from the rest
    of the <t CARD_OBJECT> because they depend on the underlying hardware.

@comm

    The contents of this structure depends on compile time flags and should
    only include information about the resource actually used by the NIC.

    This structure is filled in by <f CardFindNIC> and is used to configure
    and allocate resources from NDIS when <f CardInitialize> is called.

*/

typedef struct CARD_RESOURCES
{
    NDIS_INTERFACE_TYPE         BusInterfaceType;           // @field
    // This value is used to tell NDIS what type of adapter this is.
    // This is usually the same as the registry parameter BusType, but
    // may be different in the case of a bridged adapter.

    BOOLEAN                     Master;                     // @field
    // This is TRUE if the adapter is capable of bus master transfers.
    // Use the <t CARD_IS_BUS_MASTER> defininition to set this value
    // so the other bus master values will be included if needed.
    // See <f NdisMAllocateMapRegisters> for more details on the bus
    // master parameters.

#if (CARD_IS_BUS_MASTER)
    BOOLEAN                     Dma32BitAddresses;          // @field
    // This is TRUE if the bus master device uses 32-bit addresses.
    // Almost always TRUE for today's devices.

    ULONG                       PhysicalMapRegistersNeeded; // @field
    // This should be set to the maximum number of outstanding DMA
    // transfers that can be active at one time.  One for each physical
    // buffer segment.

    ULONG                       MaximumPhysicalMapping;     // @field
    // This should be set to the maximum number of contigous bytes that
    // can make up a single DMA transfer.

    ULONG                       DmaChannel;                 // @field
    // This should only be set if your adapter is an ISA bus master and
    // requires the use of one of the host DMA channels.

#endif // (CARD_IS_BUS_MASTER)

#if defined(CARD_MIN_MEMORY_SIZE)
    ULONG                       MemoryLength;               // @field
    // The number of bytes of memory the NIC has on board.
    // Use the <t CARD_MIN_MEMORY_SIZE> defininition to set the minimum value
    // so the other NIC based memory values will be included if needed.

    NDIS_PHYSICAL_ADDRESS       MemoryPhysicalAddress;      // @field
    // System physical address assigned to the NIC's on board memory.

#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    ULONG                       IoPortLength;               // @field
    // The number of bytes of I/O ports the NIC has on board.
    // Use the <t CARD_MIN_IOPORT_SIZE> defininition to set the minimum value
    // so the other NIC based memory values will be included if needed.

    NDIS_PHYSICAL_ADDRESS       IoPortPhysicalAddress;      // @field
    // System physical address assigned to the NIC's on board I/O ports.

#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_REQUEST_ISR)
    ULONG                       InterruptVector;            // @field
    // System interrupt vector assigned to the NIC's interrupt request line.

    ULONG                       InterruptLevel;             // @field
    // System interrupt level assigned to the NIC's interrupt request line.

    ULONG                       InterruptMode;              // @field
    // Set this value to NdisInterruptLevelSensitive or NdisInterruptLatched.
    // Use the <t CARD_INTERRUPT_MODE> defininition to set this value.

    BOOLEAN                     InterruptShared;            // @field
    // Set TRUE if you want to allow the NIC's <f InterruptVector> to be
    // shared with other drivers in the system.
    // Use the <t CARD_INTERRUPT_SHARED> defininition to set this value.

#endif // defined(CARD_REQUEST_ISR)

} CARD_RESOURCES;


#if !defined(CARD_REQUEST_ISR)


/* @doc INTERNAL Card Card_h CARD_EVENT_CODE


@enum CARD_EVENT_CODE |

    This enumeration defines the events generated by the card.

*/

typedef enum CARD_EVENT_CODE
{
    CARD_EVENT_NULL,                                        // @emem
    // Not used for anything.

    CARD_EVENT_RING,                                        // @emem
    // Indicates that a call is incoming on the given BChannel.

    CARD_EVENT_CONNECT,                                     // @emem
    // Indicates that a call is connected on the given BChannel.

    CARD_EVENT_DISCONNECT,                                  // @emem
    // Indicates that a call is disconnected on the given BChannel.

    CARD_EVENT_RECEIVE,                                     // @emem
    // Indicates that a packet is incoming on the given BChannel.

    CARD_EVENT_TRANSMIT_COMPLETE                            // @emem
    // Indicates that the transmit is complete on the given BChannel.

} CARD_EVENT_CODE;

/* @doc INTERNAL Card Card_h CARD_EVENT_OBJECT


@struct CARD_EVENT_OBJECT |

    This structure is used to keep track of events passed between the
    callee and caller.  Each <t CARD_OBJECT> keeps a list of these events.
*/

typedef struct CARD_EVENT_OBJECT
{
    LIST_ENTRY                  Queue;                      // @field
    // Used to place the buffer on one of the receive lists.

    CARD_EVENT_CODE             ulEventCode;                // @field
    // Reason for event notification.

    PVOID                       pSendingObject;             // @field
    // Interface object that is notifying.  See <t BCHANNEL_OBJECT> or
    // <t DCHANNEL_OBJECT>,

    PVOID                       pReceivingObject;           // @field
    // Interface object that is notifying.  See <t BCHANNEL_OBJECT> or
    // <t DCHANNEL_OBJECT>,

    PNDIS_PACKET                pNdisPacket;                // @field
    // A pointer to the associated NDIS packet structure <t NDIS_PACKET>.

} CARD_EVENT_OBJECT, *PCARD_EVENT_OBJECT;

#endif // !defined(CARD_REQUEST_ISR)


/* @doc INTERNAL Card Card_h CARD_OBJECT


@struct CARD_OBJECT |

    This structure contains the data associated with the Network Interface
    Card (NIC).  This object is responsible for managing all the hardware
    specific components of the NIC.

@comm

    The <t MINIPORT_ADAPTER_OBJECT> manages the interface between NDIS and
    the driver, and then passes off the hardware specific interface to this
    object.  There is one <t CARD_OBJECT> for each <t MINIPORT_ADAPTER_OBJECT>.

    One of these objects is created each time that our <f MiniportInitialize>
    routine is called.  The NDIS wrapper calls this routine once for each of
    NIC installed and enabled in the system.  In the case of a hot swappable
    NIC (e.g. PCMCIA) the adapter might come and go several times during a
    single Windows session.

*/

typedef struct CARD_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'CARD'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    CARD_RESOURCES              ResourceInformation;        // @field
    // Contains adapter specific resource requirements and settings.
    // See <t CARD_RESOURCES>.

    ULONG                       InterruptStatus;            // @field
    // Bits indicating which interrupts need to be processed.

    NDIS_MINIPORT_INTERRUPT     Interrupt;                  // @field
    // Miniport interrupt object used by NDIS.

    USHORT                      ReceiveBuffersPerLink;      // @field
    // Maximum number of receive buffers per channel, registry parameter.

    USHORT                      TransmitBuffersPerLink;     // @field
    // Maximum number of transmit buffers per channel, registry parameter.

    USHORT                      BufferSize;                 // @field
    // The maxmimum packet size.  The NDISWAN spec says this must be 1500+32,
    // but everything seems to work okay if it is set smaller.

    ULONG                       NumChannels;                // @field
    // Number of communication channels configured on the NIC.

    ULONG                       NumPorts;                   // @field
    // Number of <t PORT_OBJECT>'s allocated in <p pPortArray>.

    PPORT_OBJECT *              pPortArray;                 // @field
    // An array of <t PORT_OBJECT>'s created by <f PortCreate>.
    // One entry for each port on NIC.

#if defined(PCI_BUS)
    ULONG                       PciSlotNumber;              // @field
    // PCI slot number for this adapter (FunctionNumber * 32) + DeviceNumber.

#endif // PCI_BUS

#if defined(CARD_MIN_MEMORY_SIZE)
    PCHAR                       pMemoryVirtualAddress;      // @field
    // Virtual adress of NIC memory area.

#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    PCHAR                       pIoPortVirtualAddress;      // @field
    // Virtual adress of NIC I/O port area.

#endif // CARD_MIN_IOPORT_SIZE

#if (CARD_IS_BUS_MASTER)
    ULONG                       MapRegisterIndex;           // @field
    // Next map register index to be used for DMA transfer.

    long                        MapRegistersInUse;          // @field
    // Number of map registers currently in use.

#endif // (CARD_IS_BUS_MASTER)

    NDIS_HANDLE                 PacketPoolHandle;           // @field
    // Internal message packet pool.

    NDIS_HANDLE                 BufferPoolHandle;           // @field
    // Internal message buffer pool.

    PUCHAR                      MessagesVirtualAddress;     // @field
    // Pointer to the message buffer area used for incoming packets.

    LIST_ENTRY                  MessageBufferList;          // @field
    // List of available message buffers.

    NDIS_SPIN_LOCK              MessageBufferLock;          // @field
    // Spin lock used to protect <p MessageBufferList>.

    ULONG                       NumMessageBuffers;          // @field
    // Number of message buffers to allocate for <p MessageBufferList>.

    ULONG                       TODO;                       // @field
    // Add your data members here.

    ULONG                       NumDChannels;               // @field
    // The sample driver uses this registry value to determine the number
    // of ports to simulate.

#if defined(SAMPLE_DRIVER)

    LIST_ENTRY                  EventList;                  // @field
    // Events waiting to be processed.  See <t CARD_EVENT_OBJECT>.

#   define MAX_EVENTS 32
    CARD_EVENT_OBJECT           EventArray[MAX_EVENTS];     // @field
    // Card event allocation array.

    ULONG                       NextEvent;                  // @field
    // Index into EventArray.

#endif // SAMPLE_DRIVER

} CARD_OBJECT;

#define GET_ADAPTER_FROM_CARD(pCard)        (pCard->pAdapter)

#define GET_QUEUE_FROM_PACKET(pNdisPacket)\
                ((PLIST_ENTRY) pNdisPacket->MiniportReservedEx)
#define GET_PACKET_FROM_QUEUE(pList)\
                CONTAINING_RECORD(pList, NDIS_PACKET, MiniportReservedEx)

/*

    Object Interface Prototypes
*/

NDIS_STATUS CardCreate(
    OUT PCARD_OBJECT *          ppCard,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void CardDestroy(
    IN PCARD_OBJECT             pCard
    );

NDIS_STATUS CardInitialize(
    IN PCARD_OBJECT             pCard
    );

ULONG CardNumChannels(
    IN PCARD_OBJECT             pCard
    );

ULONG CardNumPorts(
    IN PCARD_OBJECT             pCard
    );

void CardInterruptHandler(
    IN PCARD_OBJECT             pCard
    );

BOOLEAN CardTransmitPacket(
    IN PCARD_OBJECT             pCard,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PNDIS_PACKET             pNdisPacket
    );

USHORT CardCleanPhoneNumber(
    OUT PUCHAR                  Dst,
    IN  PUSHORT                 Src,
    IN  USHORT                  Length
    );

NDIS_STATUS CardReset(
    IN PCARD_OBJECT             pCard
    );

#if defined(SAMPLE_DRIVER)

PBCHANNEL_OBJECT GET_BCHANNEL_FROM_PHONE_NUMBER(
    IN  PUCHAR                  pDialString
    );

VOID CardNotifyEvent(
    IN PCARD_OBJECT             pCard,
    IN PCARD_EVENT_OBJECT       pEvent
    );

PCARD_EVENT_OBJECT CardEventAllocate(
    IN PCARD_OBJECT             pCard
    );

VOID CardEventRelease(
    IN PCARD_OBJECT             pCard,
    IN PCARD_EVENT_OBJECT       pEvent
    );

#endif // SAMPLE_DRIVER

#endif // _CARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\callmgr.h ===
/*

                                                                             
    (C) Copyright 1998 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL CallMgr CallMgr_h

@module CallMgr.h |

    This module defines the interface to the <t CALL_MANAGER_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | CallMgr_h

@end

*/

#ifndef _CALLMGR_H
#define _CALLMGR_H

#define CALL_MANAGER_OBJECT_TYPE    ((ULONG)'C')+\
                                    ((ULONG)'M'<<8)+\
                                    ((ULONG)'G'<<16)+\
                                    ((ULONG)'R'<<24)

VOID CompleteCmOpenAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmOpenAf(
    IN NDIS_HANDLE              CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY       AddressFamily,
    IN NDIS_HANDLE              NdisAfHandle,
    OUT PNDIS_HANDLE            CallMgrAfContext 
    );

VOID CompleteCmCloseAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmCloseAf(
    IN NDIS_HANDLE              CallMgrAfContext 
    );

VOID CompleteCmRegisterSap(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmRegisterSap(
    IN NDIS_HANDLE              CallMgrAfContext ,
    IN PCO_SAP                  Sap,
    IN NDIS_HANDLE              NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    );

VOID CompleteCmDeregisterSap(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmDeregisterSap(
    IN NDIS_HANDLE              CallMgrSapContext
    );

NDIS_STATUS ProtocolCoCreateVc(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_HANDLE              NdisVcHandle,
    OUT PNDIS_HANDLE            ppBChannel
    );

NDIS_STATUS ProtocolCoDeleteVc(
    OUT PBCHANNEL_OBJECT        pBChannel
    );

VOID CompleteCmMakeCall(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmMakeCall(
    IN NDIS_HANDLE              CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN NDIS_HANDLE              NdisPartyHandle,
    OUT PNDIS_HANDLE            CallMgrPartyContext
    );

VOID CompleteCmCloseCall(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmCloseCall(
    IN NDIS_HANDLE              CallMgrVcContext,
    IN NDIS_HANDLE              CallMgrPartyContext,
    IN PVOID                    CloseData,
    IN UINT                     Size
    );

VOID ProtocolCmIncomingCallComplete(
    IN NDIS_STATUS              Status,
    IN NDIS_HANDLE              CallMgrVcContext,
    IN PCO_CALL_PARAMETERS      CallParameters
    );

VOID ProtocolCmActivateVcComplete(
    IN NDIS_STATUS              Status,
    IN NDIS_HANDLE              CallMgrVcContext,
    IN PCO_CALL_PARAMETERS      CallParameters
    );

VOID ProtocolCmDeactivateVcComplete(
    IN NDIS_STATUS              Status,
    IN NDIS_HANDLE              CallMgrVcContext
    );

NDIS_STATUS MiniportCoActivateVc(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN OUT PCO_CALL_PARAMETERS  pCallParameters
    );

NDIS_STATUS MiniportCoDeactivateVc(
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS ProtocolCmModifyCallQoS(
    IN NDIS_HANDLE              CallMgrVcContext,
    IN PCO_CALL_PARAMETERS      CallParameters
    );

NDIS_STATUS ProtocolCoRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

VOID ProtocolCoRequestComplete(
    IN NDIS_STATUS              Status,
    IN NDIS_HANDLE              ProtocolAfContext,
    IN NDIS_HANDLE              ProtocolVcContext       OPTIONAL,
    IN NDIS_HANDLE              ProtocolPartyContext    OPTIONAL,
    IN PNDIS_REQUEST            NdisRequest
    );

PCO_CALL_PARAMETERS AllocateIncomingCallParameters(
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS SetupIncomingCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT *       ppBChannel
    );

VOID InitiateCallTeardown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel
    );

VOID CallMgrTimerHandler(
    IN PVOID                    SystemSpecific1,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PVOID                    SystemSpecific2,
    IN PVOID                    SystemSpecific3
    );

#endif // _CALLMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\card.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Card Card_c

@module Card.c |

    This module implements the interface to the <t CARD_OBJECT>.
    Supports the low-level hardware control functions used by the NDIS WAN
    Minport driver.

@comm

    This module isolates most the vendor specific hardware access interfaces.
    It will require signficant changes to accomodate your hardware device.
    You should try to isolate your changes to the <t CARD_OBJECT> rather then
    the <t MINIPORT_ADAPTER_OBJECT>.  This will make it eaiser to reuse the
    upper portions of the driver should your hardware change in the future.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Card_c

@end

*/

#define  __FILEID__             CARD_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                g_CardInstanceCounter       // @globalv
// Keeps track of how many <t CARD_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL Card Card_c g_CardParameters


@topic 5.2 Card Parameters |

    This section describes the registry parameters read into the
    <t CARD_OBJECT>.

@globalv PARAM_TABLE | g_CardParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t CARD_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t CARD_OBJECT>
    you will need to modify <f CardReadParameters> and add the parameter
    definitions to the <f g_CardParameters> table.

@flag <f BufferSize> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum buffer size used
    to transmit and receive packets over the IDSN line.  Typically, this is
    defined to be 1500 bytes for most Point to Point (PPP) connections.<nl>

    <tab><f Default Value:><tab><tab>1532<nl>
    <tab><f Valid Range N:><tab><tab>532 <lt>= N <lt>= 4032<nl>

    <f Note>: You must add 32 bytes to the maximum packet size you
    expect to send or receive.  Therefore, if you have a maximum packet size
    of 1500 bytes, excluding media headers, you should set the <f BufferSize>
    value to 1532.<nl>

@flag <f ReceiveBuffersPerLink> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of incoming
    packets that can in progress at any one time.  The Miniport will allocate
    this number of packets per BChannel and set them up for incoming packets.
    Typically, three or four should be sufficient to handle a few short bursts
    that may occur with small packets.  If the Miniport is not able to service
    the incoming packets fast enough, new packets will be dropped and it is up
    to the NDIS WAN Wrapper to resynchronize with the remote station.<nl>

    <tab><f Default Value:><tab><tab>3<nl>
    <tab><f Valid Range N:><tab><tab>2 <lt>= N <lt>= 16<nl>

@flag <f TransmitBuffersPerLink> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of outgoing
    packets that can in progress at any one time.  The Miniport will allow
    this number of packets per BChannel to be outstanding (i.e. in progress).
    Typically, two or three should be sufficient to keep the channel busy for
    normal sized packets.  If there are alot of small packets being sent, the
    BChannel may become idle for brief periods while new packets are being
    queued.  Windows does not normally work this way if it has large amounts
    of data to transfer, so the default value should be sufficient. <nl>

    <tab><f Default Value:><tab><tab>2<nl>
    <tab><f Valid Range N:><tab><tab>1 <lt>= N <lt>= 16<nl>

@flag <f IsdnNumDChannels> (OPTIONAL) |

    This DWORD parameter allows you to control the number of ISDN D Channels
    allocated for the adapter.  The driver assumes only one logical
    <t DCHANNEL_OBJECT>, but the card can have multiple physical D channels
    managed by the <t PORT_OBJECT>.

    <tab><f Default Value:><tab><tab>1<nl>
    <tab><f Valid Range N:><tab><tab>1 <lt>= N <lt>= 16<nl>

*/

DBG_STATIC PARAM_TABLE          g_CardParameters[] =
{
#if defined(PCI_BUS)
    PARAM_ENTRY(CARD_OBJECT,
                PciSlotNumber, PARAM_PciSlotNumber,
                TRUE, NdisParameterInteger, 0,
                0, 0, 31),
#endif // PCI_BUS

    PARAM_ENTRY(CARD_OBJECT,
                BufferSize, PARAM_BufferSize,
                FALSE, NdisParameterInteger, 0,
                CARD_DEFAULT_PACKET_SIZE, CARD_MIN_PACKET_SIZE, CARD_MAX_PACKET_SIZE),

    PARAM_ENTRY(CARD_OBJECT,
                ReceiveBuffersPerLink, PARAM_ReceiveBuffersPerLink,
                FALSE, NdisParameterInteger, 0,
                2, 2, 16),

    PARAM_ENTRY(CARD_OBJECT,
                TransmitBuffersPerLink, PARAM_TransmitBuffersPerLink,
                FALSE, NdisParameterInteger, 0,
                2, 1, 16),

    PARAM_ENTRY(CARD_OBJECT,
                NumDChannels, PARAM_NumDChannels,
                FALSE, NdisParameterInteger, 0,
                1, 1, 4),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL Card Card_c CardReadParameters


@func

    <f CardReadParameters> reads the Card parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f CardCreate>.

    <f Note>:
    If you add any registry based data members to <t CARD_OBJECT>
    you will need to modify <f CardReadParameters> and add the parameter
    definitions to the <f g_CardParameters> table.

@rdesc

    <f CardReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardReadParameters(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pCard,
                    g_CardParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pCard->BufferSize & 0x1F)
        {
            DBG_ERROR(pAdapter,("Invalid value 'BufferSize'=0x0x%X must be multiple of 32\n",
                        pCard->BufferSize));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pCard->BufferSize,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Card Card_c CardFindNIC


@func

    <f CardFindNIC> locates the NIC associated with this NDIS device.

@rdesc

    <f CardFindNIC> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardFindNIC(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardFindNIC")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

#if defined(PCI_BUS)
    ULONG                       Index;
    // Loop counter.

    PNDIS_RESOURCE_LIST         pPciResourceList;

    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPciResource;

#endif // PCI_BUS

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

#if defined(PCI_BUS)
    /*
    // Read the PCI data and initialize the driver data structure
    // with the data returned.
    */
    pPciResourceList = NULL;

    Result = NdisMPciAssignResources(pAdapter->MiniportAdapterHandle,
                                     pCard->PciSlotNumber,
                                     &pPciResourceList);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(pAdapter,("NdisMPciAssignResources Result=0x%X\n",
                  Result));
        NdisWriteErrorLogEntry(
                pAdapter->MiniportAdapterHandle,
                NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                4,
                pCard->PciSlotNumber,
                Result,
                __FILEID__,
                __LINE__
                );
    }

    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < pPciResourceList->Count; ++Index)
    {
        ASSERT(pPciResourceList);
        pPciResource = &pPciResourceList->PartialDescriptors[Index];
        ASSERT(pPciResource);

        switch (pPciResource->Type)
        {
        case CmResourceTypePort:
#if defined(CARD_MIN_IOPORT_SIZE)
            if (pPciResource->u.Port.Start.LowPart &&
                pPciResource->u.Port.Length >= CARD_MIN_IOPORT_SIZE)
            {
                DBG_NOTICE(pAdapter,("Port: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Port.Start.LowPart,
                          pPciResource->u.Port.Length,
                          CARD_MIN_IOPORT_SIZE));
                pCard->ResourceInformation.IoPortPhysicalAddress =
                        pPciResource->u.Port.Start;
                pCard->ResourceInformation.IoPortLength =
                        pPciResource->u.Port.Length;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Port: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Port.Start,
                          pPciResource->u.Port.Length,
                          CARD_MIN_IOPORT_SIZE));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Port.Length,
                        CARD_MIN_IOPORT_SIZE,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
#endif // CARD_MIN_IOPORT_SIZE
            break;

        case CmResourceTypeInterrupt:
#if defined(CARD_REQUEST_ISR)
            if (pPciResource->u.Interrupt.Level)
            {
                DBG_NOTICE(pAdapter,("Interrupt: Lev=%d,Vec=%d\n",
                           pPciResource->u.Interrupt.Level,
                           pPciResource->u.Interrupt.Vector));
                pCard->ResourceInformation.InterruptLevel =
                        pPciResource->u.Interrupt.Level;
                pCard->ResourceInformation.InterruptVector =
                        pPciResource->u.Interrupt.Vector;

                pCard->ResourceInformation.InterruptShared = CARD_INTERRUPT_SHARED;
                pCard->ResourceInformation.InterruptMode = CARD_INTERRUPT_MODE;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Interrupt: Lev=%d,Vec=%d\n",
                          pPciResource->u.Interrupt.Level,
                          pPciResource->u.Interrupt.Vector));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Interrupt.Level,
                        pPciResource->u.Interrupt.Vector,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
#endif // defined(CARD_REQUEST_ISR)
            break;

        case CmResourceTypeMemory:
#if defined(CARD_MIN_MEMORY_SIZE)
            if (pPciResource->u.Memory.Start.LowPart &&
                pPciResource->u.Memory.Length >= CARD_MIN_MEMORY_SIZE)
            {
                DBG_NOTICE(pAdapter,("Memory: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Memory.Start.LowPart,
                          pPciResource->u.Memory.Length,
                          CARD_MIN_MEMORY_SIZE));
                pCard->ResourceInformation.MemoryPhysicalAddress =
                        pPciResource->u.Memory.Start;
                pCard->ResourceInformation.MemoryLength =
                        pPciResource->u.Memory.Length;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Memory: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Memory.Start.LowPart,
                          pPciResource->u.Memory.Length,
                          CARD_MIN_MEMORY_SIZE));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Memory.Length,
                        CARD_MIN_MEMORY_SIZE,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
            break;
#endif // CARD_MIN_MEMORY_SIZE

        default:
            DBG_ERROR(pAdapter,("Unknown resource type=%d\n",
                      pPciResource->Type));
            break;
        }
    }
    pCard->ResourceInformation.BusInterfaceType = NdisInterfacePci;

#endif // PCI_BUS

    pCard->ResourceInformation.Master = CARD_IS_BUS_MASTER;
#if (CARD_IS_BUS_MASTER)
    pCard->ResourceInformation.DmaChannel = 0;
    pCard->ResourceInformation.Dma32BitAddresses = TRUE,
    pCard->ResourceInformation.MaximumPhysicalMapping = pCard->BufferSize;
    pCard->ResourceInformation.PhysicalMapRegistersNeeded = CARD_MAP_REGISTERS_NEEDED;
#endif // (CARD_IS_BUS_MASTER)

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreateInterface


@func

    <f CardCreateInterface> allocates a shared memory pool and uses it to
    establish the message interface between the Miniport and the NIC.

@rdesc

    <f CardCreateInterface> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardCreateInterface(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreateObjects


@func

    <f CardCreateObjects> calls the create routines for all the objects
    contained in <t CARD_OBJECT>.  This should only be called
    by <f CardCreate>.

    <f Note>:
    If you add any new objects to <t CARD_OBJECT> you will need
    to modify <f CardCreateObjects> and <f CardDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f CardCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardCreateObjects(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ULONG                       Index;
    // Loop counter.

    ULONG                       NumPorts;
    // The number of Ports supported by the NIC.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Try to locate the NIC on the PCI bus.
    */
    Result = CardFindNIC(pCard);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        goto ExceptionExit;
    }

    /*
    // Create the message interface to the NIC.
    */
    Result = CardCreateInterface(pCard);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        goto ExceptionExit;
    }

    /*
    // Create the Port objects.
    */
    NumPorts = CardNumPorts(pCard);
    Result = ALLOCATE_MEMORY(pCard->pPortArray,
                             sizeof(PVOID) * NumPorts,
                             pAdapter->MiniportAdapterHandle);
    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < NumPorts; Index++)
    {
        Result = PortCreate(&pCard->pPortArray[Index], pCard);

        /*
        // Keep track of how many are created.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            pCard->NumPorts++;
        }
    }

    /*
    // We allocate (ReceiveBuffersPerLink * NumBChannels) buffers
    // to be used to receive incoming messages from the card.
    */
    pCard->NumMessageBuffers = (CardNumChannels(pCard) *
                                pCard->ReceiveBuffersPerLink);

    Result = ALLOCATE_MEMORY(pCard->MessagesVirtualAddress,
                             pCard->NumMessageBuffers * pCard->BufferSize,
                             pAdapter->MiniportAdapterHandle);
    if (Result == NDIS_STATUS_SUCCESS)
    {
        PUCHAR  MessageBuffer = pCard->MessagesVirtualAddress;
        ULONG   Index;

        ASSERT(pCard->MessagesVirtualAddress);

        /*
        // Allocate the buffer list spin lock to use as a MUTEX.
        */
        NdisAllocateSpinLock(&pCard->MessageBufferLock);

        InitializeListHead(&pCard->MessageBufferList);

        for (Index = 0; Index < pCard->NumMessageBuffers; Index++)
        {
            InsertTailList(&pCard->MessageBufferList,
                           (PLIST_ENTRY)MessageBuffer);
            MessageBuffer += pCard->BufferSize;
        }
    }

    /*
    // Allocate the message buffer pool.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        NdisAllocateBufferPool(&Result,
                               &pCard->BufferPoolHandle,
                               pCard->NumMessageBuffers
                               );
        if (Result != NDIS_STATUS_SUCCESS)
        {
            pCard->BufferPoolHandle = NULL_BUFFER_POOL;
            DBG_ERROR(pAdapter,("NdisAllocateBufferPool: Result=0x%X\n",
                      Result));
            NdisWriteErrorLogEntry(
                    pCard->pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                    3,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            ASSERT(pCard->BufferPoolHandle != NULL_BUFFER_POOL);
            DBG_FILTER(pAdapter, DBG_BUFFER_ON,
                      ("BufferPoolSize=%d\n",
                       pCard->NumMessageBuffers
                       ));
        }
    }

    /*
    // Allocate the message packet pool.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        NdisAllocatePacketPool(&Result,
                               &pCard->PacketPoolHandle,
                               pCard->NumMessageBuffers,
                               0
                               );
        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisAllocatePacketPool: Result=0x%X\n",
                      Result));
            NdisWriteErrorLogEntry(
                    pCard->pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                    3,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            ASSERT(pCard->PacketPoolHandle);
            DBG_FILTER(pAdapter, DBG_PACKET_ON,
                      ("PacketPoolSize=%d\n",
                       pCard->NumMessageBuffers
                       ));
        }
    }

ExceptionExit:

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreate


@func

    <f CardCreate> allocates memory for a <t CARD_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppCard> will be set to point to the newly created
    <t CARD_OBJECT>.  Otherwise, <p ppCard> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f CardDestroy> must be called to
    release the <t CARD_OBJECT> created by this function.

@rdesc

    <f CardCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardCreate(
    OUT PCARD_OBJECT *          ppCard,                     // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t CARD_OBJECT>.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("CardCreate")

    PCARD_OBJECT                pCard;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppCard = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pCard, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pCard->ObjectType = CARD_OBJECT_TYPE;
        pCard->ObjectID = ++g_CardInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pCard->pAdapter = pAdapter;

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = CardReadParameters(pCard);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = CardCreateObjects(pCard);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppCard = pCard;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            CardDestroy(pCard);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardDestroyObjects


@func

    <f CardDestroyObjects> calls the destroy routines for all the objects
    contained in <t CARD_OBJECT>.  This should only be called by
    <f CardDestroy>.

    <f Note>:
    If you add any new objects to <t PCARD_OBJECT> you will need to
    modify <f CardCreateObjects> and <f CardDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void CardDestroyObjects(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardDestroyObjects")

    ULONG                       NumPorts;
    // The number of Ports supported by the NIC.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    // TODO - Add code here
    /*
    // Release the packet, buffer, and message memory back to NDIS.
    */
    if (pCard->PacketPoolHandle)
    {
        NdisFreePacketPool(pCard->PacketPoolHandle);
    }

    if (pCard->BufferPoolHandle != NULL_BUFFER_POOL)
    {
        NdisFreeBufferPool(pCard->BufferPoolHandle);
    }

    if (pCard->MessagesVirtualAddress)
    {
        FREE_MEMORY(pCard->MessagesVirtualAddress,
                    pCard->NumMessageBuffers * pCard->BufferSize);
    }

    if (pCard->MessageBufferLock.SpinLock)
    {
        NdisFreeSpinLock(&pCard->MessageBufferLock);
    }

    /*
    // Destory the Port objects.
    */
    NumPorts = pCard->NumPorts;
    while (NumPorts--)
    {
        PortDestroy(pCard->pPortArray[NumPorts]);
    }
    pCard->NumPorts = 0;

    /*
    // Free space for the Ports.
    */
    if (pCard->pPortArray)
    {
        NumPorts = CardNumPorts(pCard);
        FREE_MEMORY(pCard->pPortArray, sizeof(PVOID) * NumPorts);
    }

    /*
    // Release the system resources back to NDIS.
    */
#if defined(CARD_REQUEST_ISR)
    if (pCard->Interrupt.InterruptObject)
    {
        NdisMDeregisterInterrupt(&pCard->Interrupt);
        pCard->Interrupt.InterruptObject = NULL;
    }
#endif // defined(CARD_REQUEST_ISR)

#if defined(CARD_MIN_IOPORT_SIZE)
    if (pCard->pIoPortVirtualAddress)
    {
        NdisMDeregisterIoPortRange(
                pAdapter->MiniportAdapterHandle,
                pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                pCard->ResourceInformation.IoPortLength,
                pCard->pIoPortVirtualAddress);
        pCard->pIoPortVirtualAddress = NULL;
    }
#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_MIN_MEMORY_SIZE)
    if (pCard->pMemoryVirtualAddress)
    {
        NdisMUnmapIoSpace(
                pAdapter->MiniportAdapterHandle,
                pCard->pMemoryVirtualAddress,
                pCard->ResourceInformation.MemoryLength
                );
        pCard->pMemoryVirtualAddress = NULL;
    }
#endif // CARD_MIN_MEMORY_SIZE

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardDestroy


@func

    <f CardDestroy> frees the memory for this <t CARD_OBJECT>.  All memory
    allocated by <f CardCreate> will be released back to the OS.

*/

void CardDestroy(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pCard)
    {
        ASSERT(pCard->ObjectType == CARD_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_CARD(pCard);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        CardDestroyObjects(pCard);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pCard->ObjectType = 0;
        FREE_OBJECT(pCard);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Card Card_c CardNumPorts


@func

    <f CardNumPorts> will return the total number of ports available on the
    NIC.

@rdesc

    <f CardNumPorts> returns the total number of ports available.

*/

ULONG CardNumPorts(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardNumPorts")

    // TODO - Get the actual number of ports from the card.
    return (pCard->NumDChannels);
}


/* @doc INTERNAL Card Card_c CardNumChannels


@func

    <f CardNumChannels> will return the total number of channels capable
    of supporting data connections to a remote end-point.

@rdesc

    <f CardNumChannels> returns the total number of data channels supported
    on all the NIC ports.

*/

ULONG CardNumChannels(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardNumChannels")

    UINT                        PortIndex;
    // Loop index.

    if (pCard->NumChannels == 0)
    {
        // NumPorts should already be known.
        ASSERT(pCard->NumPorts);

        // Get the actual number of channels configured on all ports.
        for (PortIndex = 0; PortIndex < pCard->NumPorts; PortIndex++)
        {
            pCard->NumChannels += pCard->pPortArray[PortIndex]->NumChannels;
        }
        ASSERT(pCard->NumChannels);
    }

    return (pCard->NumChannels);
}


/* @doc INTERNAL Card Card_c CardInitialize


@func

    <f CardInitialize> will attempt to initialize the NIC, but will not
    enable transmits or receives.

@rdesc

    <f CardInitialize> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardInitialize(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardInitialize")

    int                         num_dial_chan = 0;
    int                         num_sync_chan = 0;
    // The number of channels supported by card is based on InterfaceType.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Inform the wrapper of the physical attributes of this adapter.
    // This must be called before any NdisMRegister functions!
    // This call also associates the MiniportAdapterHandle with this pAdapter.
    */
    NdisMSetAttributes(pAdapter->MiniportAdapterHandle,
                       (NDIS_HANDLE) pAdapter,
                       pCard->ResourceInformation.Master,
                       pCard->ResourceInformation.BusInterfaceType
                       );
#if (CARD_IS_BUS_MASTER)
    if (pCard->ResourceInformation.Master)
    {
        ASSERT(pCard->ResourceInformation.DmaChannel == 0 ||
               pCard->ResourceInformation.BusInterfaceType == NdisInterfaceIsa);
        Result = NdisMAllocateMapRegisters(
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.DmaChannel,
                        pCard->ResourceInformation.Dma32BitAddresses,
                        pCard->ResourceInformation.PhysicalMapRegistersNeeded + 1,
                        pCard->ResourceInformation.MaximumPhysicalMapping
                        );

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMAllocateMapRegisters(%d,%d) Result=0x%X\n",
                      pCard->ResourceInformation.PhysicalMapRegistersNeeded,
                      pCard->ResourceInformation.MaximumPhysicalMapping,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.PhysicalMapRegistersNeeded,
                    pCard->ResourceInformation.MaximumPhysicalMapping,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
    }
#endif // (CARD_IS_BUS_MASTER)

#if defined(CARD_MIN_MEMORY_SIZE)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.MemoryLength)
    {
        Result = NdisMMapIoSpace(
                        &pCard->pMemoryVirtualAddress,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.MemoryPhysicalAddress,
                        pCard->ResourceInformation.MemoryLength);

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMMapIoSpace(0x%X,0x%X) Result=0x%X\n",
                      pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                      pCard->ResourceInformation.MemoryLength,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                    pCard->ResourceInformation.MemoryLength,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            DBG_NOTICE(pAdapter,("NdisMMapIoSpace(0x%X,0x%X) VirtualAddress=0x%X\n",
                      pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                      pCard->ResourceInformation.MemoryLength,
                      pCard->pMemoryVirtualAddress));
        }
    }
#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.IoPortLength)
    {
        Result = NdisMRegisterIoPortRange(
                        &pCard->pIoPortVirtualAddress,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                        pCard->ResourceInformation.IoPortLength);

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMRegisterIoPortRange(0x%X,0x%X) Result=0x%X\n",
                      pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                      pCard->ResourceInformation.IoPortLength,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                    pCard->ResourceInformation.IoPortLength,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            DBG_NOTICE(pAdapter,("NdisMRegisterIoPortRange(0x%X,0x%X) VirtualAddress=0x%X\n",
                      pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                      pCard->ResourceInformation.IoPortLength,
                      pCard->pIoPortVirtualAddress));
        }
    }
#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_REQUEST_ISR)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.InterruptVector)
    {
        ASSERT(pCard->ResourceInformation.InterruptShared == FALSE ||
               (pCard->ResourceInformation.InterruptMode == NdisInterruptLevelSensitive &&
                CARD_REQUEST_ISR == TRUE));
        Result = NdisMRegisterInterrupt(
                        &pCard->Interrupt,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.InterruptVector,
                        pCard->ResourceInformation.InterruptLevel,
                        CARD_REQUEST_ISR,
                        pCard->ResourceInformation.InterruptShared,
                        pCard->ResourceInformation.InterruptMode
                        );
        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMRegisterInterrupt failed: Vec=%d, Lev=%d\n",
                     (UINT)pCard->ResourceInformation.InterruptVector,
                     (UINT)pCard->ResourceInformation.InterruptLevel));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.InterruptVector,
                    pCard->ResourceInformation.InterruptLevel,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
    }
#endif // defined(CARD_REQUEST_ISR)

    // TODO - Add your card initialization here.

    if (Result == NDIS_STATUS_SUCCESS)
    {

    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardTransmitPacket


@func

    <f CardTransmitPacket> will start sending the current packet out.

@rdesc

    <f CardTransmitPacket> returns TRUE if the packet is being transmitted,
    otherwise FALSE is returned.

*/

BOOLEAN CardTransmitPacket(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PNDIS_PACKET             pNdisPacket                  // @parm
    // A pointer to the associated NDIS packet structure <t NDIS_PACKET>.
    )
{
    DBG_FUNC("CardTransmitPacket")

    BOOLEAN                     bResult = FALSE;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

#if defined(SAMPLE_DRIVER)
{
    PBCHANNEL_OBJECT            pPeerBChannel;
    // A pointer to the peer <t BCHANNEL_OBJECT>.

    PCARD_EVENT_OBJECT          pEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    // If you can transmit the packet on pBChannel, do it now.
    pPeerBChannel = pBChannel->pPeerBChannel;
    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            /*
            // Append the packet onto TransmitBusyList while it is being sent.
            // Then move it to the TransmitCompleteList in CardInterruptHandler
            // after the card is done with it.
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
            InsertTailList(&pBChannel->TransmitBusyList,
                           GET_QUEUE_FROM_PACKET(pNdisPacket));
            NdisReleaseSpinLock(&pAdapter->TransmitLock);
            pEvent->ulEventCode      = CARD_EVENT_RECEIVE;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            pEvent->pNdisPacket      = pNdisPacket;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            bResult = TRUE;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("pPeerBChannel == NULL\n"));
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to transmit the packet.
    DBG_TX(pAdapter, pBChannel->ObjectID,
           BytesToSend, pNdisPacket->CurrentBuffer);
#endif // SAMPLE_DRIVER

    DBG_RETURN(pAdapter, bResult);
    return (bResult);
}


/* @doc EXTERNAL Card Card_c TpiCopyFromPacketToBuffer


@func

    <f TpiCopyFromPacketToBuffer> copies from an NDIS packet into a memory
    buffer.

*/

DBG_STATIC VOID TpiCopyFromPacketToBuffer(
    IN PNDIS_PACKET            Packet,                      // @parm
    // The packet to copy from.

    IN UINT                    Offset,                      // @parm
    // The offset from which to start the copy.

    IN UINT                    BytesToCopy,                 // @parm
    // The number of bytes to copy from the packet.

    IN PUCHAR                   Buffer,                     // @parm
    // The destination of the copy.

    OUT PUINT                   BytesCopied                 // @parm
    // The number of bytes actually copied.  Can be less then
    // BytesToCopy if the packet is shorter than BytesToCopy.
    )
{
    UINT                        NdisBufferCount;
    PNDIS_BUFFER                CurrentBuffer;
    PVOID                       VirtualAddress;
    UINT                        CurrentLength;
    UINT                        LocalBytesCopied = 0;
    UINT                        AmountToMove;

    *BytesCopied = 0;
    if (!BytesToCopy)
    {
        return;
    }

    //
    // Get the first buffer.
    //
    NdisQueryPacket(
        Packet,
        NULL,
        &NdisBufferCount,
        &CurrentBuffer,
        NULL
        );

    //
    // Could have a null packet.
    //
    if (!NdisBufferCount)
    {
        return;
    }

    NdisQueryBuffer(
        CurrentBuffer,
        &VirtualAddress,
        &CurrentLength
        );

    while (LocalBytesCopied < BytesToCopy)
    {
        if (!CurrentLength)
        {
            NdisGetNextBuffer(
                CurrentBuffer,
                &CurrentBuffer
                );

            //
            // We've reached the end of the packet.  We return
            // with what we've done so far. (Which must be shorter
            // than requested.
            //
            if (!CurrentBuffer)
            {
                break;
            }

            NdisQueryBuffer(
                CurrentBuffer,
                &VirtualAddress,
                &CurrentLength
                );
            continue;

        }

        //
        // Try to get us up to the point to start the copy.
        //
        if (Offset)
        {
            if (Offset > CurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //
                Offset -= CurrentLength;
                CurrentLength = 0;
                continue;

            }
            else
            {
                VirtualAddress = (PCHAR)VirtualAddress + Offset;
                CurrentLength -= Offset;
                Offset = 0;
            }
        }

        //
        // Copy the data.
        //
        AmountToMove =
                   ((CurrentLength <= (BytesToCopy - LocalBytesCopied)) ?
                    (CurrentLength):(BytesToCopy - LocalBytesCopied));

        NdisMoveMemory(Buffer,VirtualAddress,AmountToMove);

        Buffer = (PUCHAR)Buffer + AmountToMove;
        VirtualAddress = (PCHAR)VirtualAddress + AmountToMove;

        LocalBytesCopied += AmountToMove;
        CurrentLength -= AmountToMove;
    }

    *BytesCopied = LocalBytesCopied;
}


/* @doc INTERNAL Card Card_c CardInterruptHandler


@func

    <f CardInterruptHandler> dequeues an event from the asynchronous event
    callback queue <t CARD_EVENT_OBJECT>, and processes it according to
    whether it is a BChannel event, Card event, or B-Advise event.
    The associated callback routines are responsible for processing the
    event.

@comm

    <f NdisAcquireSpinLock> and <f NdisReleaseSpinLock> are used to provide
    protection around the dequeueing code and keep it from being re-entered
    as a result of another asynchronous callback event.

*/

VOID CardInterruptHandler(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardInterruptHandler")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    // DBG_ENTER(pAdapter);

#if defined(SAMPLE_DRIVER)
{
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;

    PNDIS_BUFFER                pDstNdisBuffer;
    // A pointer to the NDIS buffer we use to indicate the receive.

    PUCHAR                      pMemory;
    // A pointer to a memory area we use to create a copy of the incoming
    // packet.

    ULONG                       ByteCount = 0;
    ULONG                       BytesCopied = 0;
    PLIST_ENTRY                 pList;

    PCARD_EVENT_OBJECT          pEvent;
    PCARD_EVENT_OBJECT          pNewEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    PBCHANNEL_OBJECT            pBChannel;
    PBCHANNEL_OBJECT            pPeerBChannel;
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    /*
    // Clear out all packets in the receive buffer.
    */
    NdisDprAcquireSpinLock(&pAdapter->EventLock);
    while (!IsListEmpty(&pAdapter->EventList))
    {
        pEvent = (PCARD_EVENT_OBJECT)RemoveHeadList(&pAdapter->EventList);
        NdisDprReleaseSpinLock(&pAdapter->EventLock);

        ASSERT(pEvent->pReceivingObject);

        switch (pEvent->ulEventCode)
        {
        case CARD_EVENT_RING:
            // The caller has already removed the BChannel from the available
            // list, so we just pass it up to SetupIncomingCall so it can
            // get the same one from ProtocolCoCreateVc.
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            pPeerBChannel = pEvent->pSendingObject;
            ASSERT(pPeerBChannel && pPeerBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

            pBChannel->pPeerBChannel = pPeerBChannel;
            DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                       ("#%d CallState=0x%X CARD_EVENT_RING from #%d\n",
                       pBChannel->ObjectID, pBChannel->CallState,
                        (pBChannel->pPeerBChannel == NULL) ? -1 :
                             pBChannel->pPeerBChannel->ObjectID));

            Status = SetupIncomingCall(pAdapter, &pBChannel);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                ASSERT(pBChannel == pEvent->pReceivingObject);
            }
            else if (Status != NDIS_STATUS_PENDING)
            {
                DChannelRejectCall(pAdapter->pDChannel, pBChannel);
            }
            else
            {
                ASSERT(pBChannel == pEvent->pReceivingObject);
            }
            break;

        case CARD_EVENT_CONNECT:
            // The other side answered the call.
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            pBChannel->pPeerBChannel = pEvent->pSendingObject;

            DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                       ("#%d CallState=0x%X CARD_EVENT_CONNECT from #%d\n",
                       pBChannel->ObjectID, pBChannel->CallState,
                        (pBChannel->pPeerBChannel == NULL) ? -1 :
                             pBChannel->pPeerBChannel->ObjectID));
            if (pBChannel->Flags & VCF_OUTGOING_CALL)
            {
                // The other side answered the call.
                CompleteCmMakeCall(pBChannel, NDIS_STATUS_SUCCESS);
            }
            break;

        case CARD_EVENT_DISCONNECT:
            // The other side has closed the call.
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

            DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                       ("#%d CallState=0x%X CARD_EVENT_DISCONNECT from #%d\n",
                       pBChannel->ObjectID, pBChannel->CallState,
                       (pBChannel->pPeerBChannel == NULL) ? -1 :
                            pBChannel->pPeerBChannel->ObjectID));
            pBChannel->pPeerBChannel = NULL;
            if (pBChannel->Flags & VCF_OUTGOING_CALL)
            {
                if (pBChannel->CallState != LINECALLSTATE_CONNECTED)
                {
                    // Call never made it to the connected state.
                    CompleteCmMakeCall(pBChannel, NDIS_STATUS_FAILURE);
                }
                else
                {
                    // Call was disconnected by remote endpoint.
                    InitiateCallTeardown(pAdapter, pBChannel);
                }
            }
            else if (pBChannel->Flags & VCF_INCOMING_CALL)
            {
                InitiateCallTeardown(pAdapter, pBChannel);
            }
            break;

        case CARD_EVENT_RECEIVE:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

            DBG_FILTER(pAdapter,DBG_TXRX_VERBOSE_ON,
                       ("#%d CallState=0x%X CARD_EVENT_RECEIVE from #%d\n",
                       pBChannel->ObjectID, pBChannel->CallState,
                       (pBChannel->pPeerBChannel == NULL) ? -1 :
                            pBChannel->pPeerBChannel->ObjectID));

            if (pBChannel->CallState == LINECALLSTATE_CONNECTED)
            {
                // Find out how big the packet is.
                NdisQueryPacket(pEvent->pNdisPacket, NULL, NULL, NULL,
                                &ByteCount);

                // Allocate memory for a copy of the data.
                Status = ALLOCATE_MEMORY(pMemory, ByteCount,
                                         pAdapter->MiniportAdapterHandle);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    NdisAllocateBuffer(&Status, &pDstNdisBuffer,
                                       pAdapter->pCard->BufferPoolHandle,
                                       pMemory, ByteCount);

                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                        TpiCopyFromPacketToBuffer(pEvent->pNdisPacket, 0,
                                                  ByteCount, pMemory,
                                                  &BytesCopied);
                        ASSERT(BytesCopied == ByteCount);
                        ReceivePacketHandler(pBChannel, pDstNdisBuffer,
                                             ByteCount);
                    }
                    else
                    {
                       FREE_MEMORY(pMemory, ByteCount);
                       DBG_ERROR(pAdapter,("NdisAllocateBuffer Error=0x%X\n",
                                 Status));
                    }
                }
            }

            pPeerBChannel = pBChannel->pPeerBChannel;
            if (pPeerBChannel)
            {
                pNewEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
                if (pNewEvent)
                {
                    pNewEvent->ulEventCode      = CARD_EVENT_TRANSMIT_COMPLETE;
                    pNewEvent->pSendingObject   = pBChannel;
                    pNewEvent->pReceivingObject = pPeerBChannel;
                    CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pNewEvent);
                }
            }
            else
            {
                DBG_WARNING(pAdapter,("pPeerBChannel == NULL\n"));
            }
            break;

        case CARD_EVENT_TRANSMIT_COMPLETE:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

            DBG_FILTER(pAdapter,DBG_TXRX_VERBOSE_ON,
                       ("#%d CallState=0x%X CARD_EVENT_TRANSMIT_COMPLETE from #%d\n",
                       pBChannel->ObjectID, pBChannel->CallState,
                       (pBChannel->pPeerBChannel == NULL) ? -1 :
                            pBChannel->pPeerBChannel->ObjectID));
            /*
            // Remove the packet from the BChannel's TransmitBusyList and
            // place it on the adapter's TransmitCompleteList now that the
            // card has completed the transmit.
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
            if (!IsListEmpty(&pBChannel->TransmitBusyList))
            {
                pList = RemoveHeadList(&pBChannel->TransmitBusyList);
                InsertTailList(&pBChannel->pAdapter->TransmitCompleteList, pList);
            }
            NdisReleaseSpinLock(&pAdapter->TransmitLock);
            TransmitCompleteHandler(pAdapter);
            break;

        default:
            DBG_ERROR(pAdapter,("Unknown event code=%d\n",
                      pEvent->ulEventCode));
            break;
        }
        CardEventRelease(pCard, pEvent);
        NdisDprAcquireSpinLock(&pAdapter->EventLock);
    }
    NdisDprReleaseSpinLock(&pAdapter->EventLock);
}
#else  // SAMPLE_DRIVER
    // TODO - Add interrupt handler code here
#endif // SAMPLE_DRIVER

    // DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardCleanPhoneNumber


@func

    <f CardCleanPhoneNumber> copies the phone number from the input string
    to the output string, deleting any non-phone number characters (i.e.
    dashes, parens, modem keywords, etc.).

@rdesc

    <f CardCleanPhoneNumber> returns the length of the output string in bytes.

*/

USHORT CardCleanPhoneNumber(
    OUT PUCHAR                  Dst,                        // @parm
    // A pointer to the output string.

    IN  PUSHORT                 Src,                        // @parm
    // A pointer to the input string.

    IN  USHORT                  Length                      // @parm
    // The length of the input string in bytes.
    )
{
    DBG_FUNC("CardCleanPhoneNumber")

    USHORT                  NumDigits;

    /*
    // Strip out any character which are not digits or # or *.
    */
    for (NumDigits = 0; Length > 0; --Length)
    {
        if ((*Src >= '0' && *Src <= '9') ||
            (*Src == '#' || *Src == '*'))
        {
            /*
            // Make sure dial string is within the limit of the adapter.
            */
            if (NumDigits < CARD_MAX_DIAL_DIGITS)
            {
                ++NumDigits;
                *Dst++ = (UCHAR) *Src;
            }
            else
            {
                break;
            }
        }
        Src++;
    }
    *Dst++ = 0;
    return (NumDigits);
}


/* @doc INTERNAL Card Card_c CardReset


@func

    <f CardReset> issues a hard reset to the NIC.  Same as power up.

@rdesc

    <f CardReset> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardReset(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardReset")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    DBG_BREAK(pAdapter);

    // TODO - Add code here to reset your hardware to its initial state.

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


#if defined(SAMPLE_DRIVER)

/* @doc INTERNAL Card Card_c GET_BCHANNEL_FROM_PHONE_NUMBER


@func

    <f GET_BCHANNEL_FROM_PHONE_NUMBER> assumes the phone number is a BChannel
    index, and uses it to lookup the associated BChannel on one of our
    adapters.  Zero means use the first availble BChannel on another adapter.

@rdesc

    <f GET_BCHANNEL_FROM_PHONE_NUMBER> returns a pointer to the associated
    <t BCHANNEL_OBJECT> if successful.  Otherwise, NULL is returned.

*/

PBCHANNEL_OBJECT GET_BCHANNEL_FROM_PHONE_NUMBER(
    IN  PUCHAR                 pDialString                      // @parm
    // A pointer to the dial string.
    )
{
    DBG_FUNC("GET_BCHANNEL_FROM_PHONE_NUMBER")

    ULONG                       ulCalledID = 0;
    // Phone number converted to BChannel ObjectID (spans all adapters).

    ULONG                       ulAdapterIndex;
    // Loop index.

    /*
    // Strip out any character which are not digits or # or *.
    */
    while (*pDialString)
    {
        if (*pDialString >= '0' && *pDialString <= '9')
        {
            ulCalledID *= 10;
            ulCalledID += *pDialString - '0';
        }
        else
        {
            break;
        }
        pDialString++;
    }
    if (*pDialString)
    {
        DBG_ERROR(DbgInfo,("Invalid dial string '%s'\n", pDialString));
    }
    else
    {
        PMINIPORT_ADAPTER_OBJECT    pAdapter;

        for (ulAdapterIndex = 0; ulAdapterIndex < MAX_ADAPTERS; ++ulAdapterIndex)
        {
            // Does call want to look on specific adapter, or any?
            if (ulCalledID == 0 || ulCalledID == ulAdapterIndex+1)
            {
                pAdapter = g_Adapters[ulAdapterIndex];
                if (pAdapter)
                {
                    // Find first available channel.
                    NdisAcquireSpinLock(&pAdapter->EventLock);
                    if (!IsListEmpty(&pAdapter->BChannelAvailableList))
                    {
                        PBCHANNEL_OBJECT    pBChannel;
                        pBChannel = (PBCHANNEL_OBJECT) pAdapter->BChannelAvailableList.Blink;
                        if (pBChannel->NdisSapHandle &&
                            pBChannel->NdisVcHandle == NULL)
                        {
                            // Find first available listening channel.
                            pBChannel = (PBCHANNEL_OBJECT) RemoveTailList(
                                            &pAdapter->BChannelAvailableList);
                            // Reset the link info so we can tell that it's 
                            // not on the list.
                            InitializeListHead(&pBChannel->LinkList);
                            NdisReleaseSpinLock(&pAdapter->EventLock);
                            return (pBChannel);
                        }
                    }
                    NdisReleaseSpinLock(&pAdapter->EventLock);
                }
            }
        }
    }
    return (NULL);
}


/* @doc INTERNAL Card Card_c CardNotifyEvent


@func

    <f CardNotifyEvent> queues an IMS event to be processed by the DPC
    handler when things quiet down.

@comm

    We have to queue the event to be processed in DPC context.  We have
    to make sure that the queue is protected by a mutual exclusion
    primative which cannot be violated by the callback.

*/

VOID CardNotifyEvent(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PCARD_EVENT_OBJECT       pEvent                      // @parm
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.
    )
{
    DBG_FUNC("CardNotifyEvent")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    // DBG_ENTER(pAdapter);

    /*
    // Schedule the event handler to run as soon as possible.
    // We must schedule the event to go through the NDIS wrapper
    // so the proper spin locks will be held.
    // Don't schedule another event if processing is already in progress.
    */
    NdisAcquireSpinLock(&pAdapter->EventLock);
    InsertTailList(&pAdapter->EventList, &pEvent->Queue);
    NdisReleaseSpinLock(&pAdapter->EventLock);
    if (pEvent->ulEventCode == CARD_EVENT_RING ||
        pEvent->ulEventCode == CARD_EVENT_CONNECT ||
        pEvent->ulEventCode == CARD_EVENT_DISCONNECT)
    {
        NdisMSetTimer(&pAdapter->EventTimer, 100);
    }
    else
    {
        NdisMSetTimer(&pAdapter->EventTimer, 0);
    }

    // DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardEventAllocate


@func

    <f CardEventAllocate> allocates an <t CARD_EVENT_OBJECT> from the
    <p pCard>'s EventList.

@rdesc

    <f CardEventAllocate> returns a pointer to a <t CARD_EVENT_OBJECT>
    if it is successful.<nl>
    Otherwise, a NULL return value indicates an error condition.

*/

PCARD_EVENT_OBJECT CardEventAllocate(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    PCARD_EVENT_OBJECT          pEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    pEvent = &pCard->EventArray[pCard->NextEvent++];
    ASSERT(pEvent->pReceivingObject == NULL);
    if (pCard->NextEvent >= MAX_EVENTS)
    {
        pCard->NextEvent = 0;
    }
    return (pEvent);
}


/* @doc INTERNAL Card Card_c CardEventRelease


@func

    <f CardEventRelease> returns a previously allocate <t CARD_EVENT_OBJECT>
    to the <p pCard>'s EventList.

*/

VOID CardEventRelease(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PCARD_EVENT_OBJECT       pEvent                      // @parm
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.
    )
{
    pEvent->pReceivingObject = NULL;
}

#endif // SAMPLE_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\dchannel.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL DChannel DChannel_h

@module DChannel.h |

    This module defines the interface to the <t DCHANNEL_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | DChannel_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 4.3 DChannel Overview |

    This section describes the interfaces defined in <f DChannel\.h>.

    This module isolates most the vendor specific Call Control interfaces.
    It will require some changes to accomodate your hardware device's call
    control mechanism.  
    
    The driver is written to assume a single logical <t DCHANNEL_OBJECT> for 
    each adapter.  If your card supports more than one ISDN line, you will 
    need to use the given BChannel object to identify which <t PORT_OBJECT> 
    the real DChannel is located on.  You can then manage the physical call
    control using that interface, and the logicial call control using the
    DChannel interface.
*/

#ifndef _DCHANNEL_H
#define _DCHANNEL_H

#define DCHANNEL_OBJECT_TYPE    ((ULONG)'D')+\
                                ((ULONG)'C'<<8)+\
                                ((ULONG)'H'<<16)+\
                                ((ULONG)'N'<<24)

/* @doc INTERNAL DChannel DChannel_h DCHANNEL_OBJECT


@struct DCHANNEL_OBJECT |

    This structure contains the data associated with an ISDN DChannel.  Here,
    DChannel is defined as an interface by which to setup and teardown a
    BChannel connection between two end-points.  This channel is responsible
    for establishing a point-to-point connection over one of the available
    BChannels.

@comm

    This logical DChannel does not necessarily map to a physical DChannel
    on the NIC.  The NIC may in fact have multiple DChannels depending on
    how many ports and whether it is BRI, PRI, T-1, or E-1.  The NIC may in
    fact not have DChannels at all, as may be the case with channelized T-1.
    The DChannel is just a convenient abstraction for announcing and
    answering incoming calls, and for placing outgoing calls.


    There will be one DChannel created for each NIC.  The number of physical
    D-channels depends on how many ports the NIC has, and how the ports are
    provisioned and configured.  The provisioning can be configured at install
    time or changed using the control panel.  The driver does not allow the
    configuration to change at run-time, so the computer or the adapter must
    be restarted to enable the configuration changes.

*/

typedef struct DCHANNEL_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'DCHN'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    UINT                        IsOpen;                     // @field
    // Set non-zero if this DChannel is open, otherwise set zero.

    ULONG                       TotalMakeCalls;             // @field
    // Total number of <f DChannelMakeCall> requests.

    ULONG                       TotalAnswers;               // @field
    // Total number of <f DChannelAnswerCall> requests.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} DCHANNEL_OBJECT;

#define GET_ADAPTER_FROM_DCHANNEL(pDChannel)    (pDChannel->pAdapter)


/*


    Function prototypes.

*/

NDIS_STATUS DChannelCreate(
    OUT PDCHANNEL_OBJECT *      ppDChannel,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void DChannelDestroy(
    IN PDCHANNEL_OBJECT         pDChannel
    );

void DChannelInitialize(
    IN PDCHANNEL_OBJECT         pDChannel
    );

NDIS_STATUS DChannelOpen(
    IN PDCHANNEL_OBJECT         pDChannel
    );

void DChannelClose(
    IN PDCHANNEL_OBJECT         pDChannel
    );

NDIS_STATUS DChannelMakeCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PUCHAR                   DialString,
    IN USHORT                   DialStringLength,
    IN PLINE_CALL_PARAMS        pLineCallParams
    );

NDIS_STATUS DChannelAnswerCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS DChannelCloseCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

VOID DChannelRejectCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

#endif // _DCHANNEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\dchannel.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL DChannel DChannel_c

@module DChannel.c |

    This module implements the interface to the <t DCHANNEL_OBJECT>.
    Supports the high-level channel control functions used by the CONDIS WAN
    Minport driver.

@comm

    This module isolates most the vendor specific Call Control interfaces.
    It will require some changes to accomodate your hardware device's call
    control mechanism.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | DChannel_c

@end

*/

#define  __FILEID__             DCHANNEL_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                g_DChannelInstanceCounter   // @globalv
// Keeps track of how many <t DCHANNEL_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL DChannel DChannel_c g_DChannelParameters


@topic 5.4 DChannel Parameters |

    This section describes the registry parameters read into the
    <t DCHANNEL_OBJECT>.

@globalv PARAM_TABLE | g_DChannelParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t DCHANNEL_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t DCHANNEL_OBJECT>
    you will need to modify <f DChannelReadParameters> and add the parameter
    definitions to the <f g_DChannelParameters> table.

*/

DBG_STATIC PARAM_TABLE          g_DChannelParameters[] =
{
    PARAM_ENTRY(DCHANNEL_OBJECT,
                TODO, PARAM_TODO,
                FALSE, NdisParameterInteger, 0,
                0, 0, 0),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL DChannel DChannel_c DChannelReadParameters


@func

    <f DChannelReadParameters> reads the DChannel parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f DChannelCreate>.

    <f Note>:
    If you add any registry based data members to <t DCHANNEL_OBJECT>
    you will need to modify <f DChannelReadParameters> and add the parameter
    definitions to the <f g_DChannelParameters> table.

@rdesc

    <f DChannelReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS DChannelReadParameters(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pDChannel,
                    g_DChannelParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pDChannel->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pDChannel->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCreateObjects


@func

    <f DChannelCreateObjects> calls the create routines for all the objects
    contained in <t DCHANNEL_OBJECT>.  This should only be called
    by <f DChannelCreate>.

    <f Note>:
    If you add any new objects to <t DCHANNEL_OBJECT> you will need
    to modify <f DChannelCreateObjects> and <f DChannelDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f DChannelCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS DChannelCreateObjects(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to allocate any sub-objects needed to support
    // your physical DChannels.

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCreate


@func

    <f DChannelCreate> allocates memory for a <t DCHANNEL_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppDChannel> will be set to point to the newly created
    <t DCHANNEL_OBJECT>.  Otherwise, <p ppDChannel> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f DChannelDestroy> must be called to
    release the <t DCHANNEL_OBJECT> created by this function.

@rdesc

    <f DChannelCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelCreate(
    OUT PDCHANNEL_OBJECT *      ppDChannel,                 // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t DCHANNEL_OBJECT>.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("DChannelCreate")

    PDCHANNEL_OBJECT            pDChannel;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppDChannel = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pDChannel, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pDChannel->ObjectType = DCHANNEL_OBJECT_TYPE;
        pDChannel->ObjectID = ++g_DChannelInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pDChannel->pAdapter = pAdapter;

        // TODO - Add code here to allocate any resources needed to support
        // your physical DChannels.

        /*
        // Parse the registry parameters.
        */
        Result = DChannelReadParameters(pDChannel);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = DChannelCreateObjects(pDChannel);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppDChannel = pDChannel;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            DChannelDestroy(pDChannel);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelDestroyObjects


@func

    <f DChannelDestroyObjects> calls the destroy routines for all the objects
    contained in <t DCHANNEL_OBJECT>.  This should only be called by
    <f DChannelDestroy>.

    <f Note>: If you add any new objects to <t PDCHANNEL_OBJECT> you will need to
    modify <f DChannelCreateObjects> and <f DChannelDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void DChannelDestroyObjects(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to release any sub-objects allocated by
    // DChannelCreateObjects.

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelDestroy


@func

    <f DChannelDestroy> frees the memory for this <t DCHANNEL_OBJECT>.
    All memory allocated by <f DChannelCreate> will be released back to the
    OS.

*/

void DChannelDestroy(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pDChannel)
    {
        ASSERT(pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

        DBG_ENTER(pAdapter);

        // TODO - Add code here to release any resources allocated by
        // DChannelCreate.

        /*
        // Release all objects allocated within this object.
        */
        DChannelDestroyObjects(pDChannel);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pDChannel->ObjectType = 0;
        FREE_OBJECT(pDChannel);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL DChannel DChannel_c DChannelInitialize


@func

    <f DChannelInitialize> resets all the internal data members contained
    in <t BCHANNEL_OBJECT> back to their initial state.

    <f Note>:
    If you add any new members to <t DCHANNEL_OBJECT> you will need to
    modify <f DChannelInitialize> to initialize your new data mamebers.

*/

void DChannelInitialize(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelInitialize")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to initialize all the physical D-Channels on
    // your adapter.

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelOpen


@func

    <f DChannelOpen> establishes a communications path between the miniport
    and the DChannel.

@rdesc

    <f DChannelOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelOpen(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    if (++pDChannel->IsOpen == 1)
    {
        DBG_NOTICE(pAdapter,("Opening DChannel #%d\n",
                   pDChannel->ObjectID));

        // TODO - Add code here to open all the physical D-Channels on
        // your adapter.
    }
    else
    {
        DBG_NOTICE(pAdapter,("DChannel #%d already opened\n",
                   pDChannel->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelClose


@func

    <f DChannelClose> tears down the communications path between the miniport
    and the DChannel.

*/

void DChannelClose(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    if (pDChannel->IsOpen == 1)
    {
        DBG_NOTICE(pAdapter,("Closing DChannel #%d\n",
                   pDChannel->ObjectID));

        // TODO - Add code here to close all the physical D-Channels on
        // your adapter.
        pDChannel->IsOpen = 0;
    }
    else if (pDChannel->IsOpen == 0)
    {
        DBG_WARNING(pAdapter,("DChannel #%d already closed\n",
                    pDChannel->ObjectID));
    }
    else
    {
        pDChannel->IsOpen--;
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelMakeCall


@func

    <f DChannelMakeCall> places a call over the selected line device.

@rdesc

    <f DChannelMakeCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelMakeCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PUCHAR                   DialString,                 // @parm
    // A pointer to an ASCII null-terminated string of digits.

    IN USHORT                   DialStringLength,           // @parm
    // Number of bytes in dial string.

    IN PLINE_CALL_PARAMS        pLineCallParams             // @parm
    // A pointer to the TAPI <t LINE_CALL_PARAMS> to be used for this call.
    )
{
    DBG_FUNC("DChannelMakeCall")

    NDIS_STATUS                 Result = NDIS_STATUS_RESOURCES;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    pDChannel->TotalMakeCalls++;
    pBChannel->Flags |= VCF_OUTGOING_CALL;
    pBChannel->CallState = LINECALLSTATE_DIALING;

#if defined(SAMPLE_DRIVER)
    // This sample code uses the phone number to select one of the other
    // BChannels on which to complete the connection.
{
    PBCHANNEL_OBJECT            pPeerBChannel;
    PCARD_EVENT_OBJECT          pEvent;

    pPeerBChannel = GET_BCHANNEL_FROM_PHONE_NUMBER(DialString);
    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            pEvent->ulEventCode      = CARD_EVENT_RING;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            pBChannel->pPeerBChannel = pPeerBChannel;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            Result = NDIS_STATUS_PENDING;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("Cannot map phone number '%s' to BChannel\n",
                  DialString));
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to place a call.
#endif // SAMPLE_DRIVER

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelAnswerCall


@func

    <f DChannelAnswerCall> answers the incoming call so it can be connected.

@rdesc

    <f DChannelAnswerCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelAnswerCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelAnswerCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    pDChannel->TotalAnswers++;

#if defined(SAMPLE_DRIVER)
    // This sample code sends a connect over to the calling BChannel.
{
    PCARD_EVENT_OBJECT          pEvent;
    PBCHANNEL_OBJECT            pPeerBChannel = pBChannel->pPeerBChannel;

    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            pEvent->ulEventCode      = CARD_EVENT_CONNECT;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
        }
        else
        {
            Result = NDIS_STATUS_RESOURCES;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("pPeerBChannel == NULL\n"));
        Result = NDIS_STATUS_RESOURCES;
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to answer a call.

    // If you return NDIS_STATUS_PENDING from here, you must perform the
    // following actions when the call is finally answered.
    //      pBChannel->CallState = LINECALLSTATE_CONNECTED;
    //      NdisMCmDispatchCallConnected(pBChannel->NdisVcHandle);
    // If you fail to answer for some reason you must call:
    //      InitiateCallTeardown(pAdapter, pBChannel);

#endif // SAMPLE_DRIVER

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCloseCall


@func

    <f DChannelCloseCall> closes a previously opened call instance as
    initiated from <f DChannelMakeCall> or <f DChannelAnswerCall>.  After
    the call is closed, no one else should reference it.

@rdesc

    <f DChannelCloseCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelCloseCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelCloseCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    // This routine may be called several times during line/call cleanup.
    // If the call is already closed, just return success.
    if (pBChannel->CallState != 0 &&
        pBChannel->CallState != LINECALLSTATE_IDLE)
    {
#if defined(SAMPLE_DRIVER)
        // This sample code sends a disconnect over to the connected BChannel.
        PCARD_EVENT_OBJECT      pEvent;
        PBCHANNEL_OBJECT        pPeerBChannel = pBChannel->pPeerBChannel;

        if (pPeerBChannel)
        {
            pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
            if (pEvent)
            {
                // Indicate call disconnect to the other channel.
                pEvent->ulEventCode      = CARD_EVENT_DISCONNECT;
                pEvent->pSendingObject   = pBChannel;
                pEvent->pReceivingObject = pPeerBChannel;
                CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            }
            pBChannel->pPeerBChannel = NULL;
        }
        else
        {
            DBG_WARNING(pAdapter,("#%d NO PEER CHANNEL - CALLSTATE=%X\n",
                        pBChannel->ObjectID, pBChannel->CallState));
        }
        // Return any pending packets to the protocol stack.
        pBChannel->CallState = LINECALLSTATE_IDLE;
#else  // SAMPLE_DRIVER
        // TODO - Add code here to drop a call.
#endif // SAMPLE_DRIVER

        // Make sure there are no packets left on this channel before it closes.
        FlushSendPackets(pAdapter, pBChannel);
    }
    else
    {
        DBG_NOTICE(pAdapter,("#%d ALREADY IDLE - CALLSTATE=%X\n",
                   pBChannel->ObjectID, pBChannel->CallState));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelRejectCall


@func

    <f DChannelRejectCall> rejects an incoming call on the specified
    channel.

*/

VOID DChannelRejectCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelRejectCall")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    if (pBChannel->CallState != 0 &&
        pBChannel->CallState != LINECALLSTATE_IDLE)
    {
#if defined(SAMPLE_DRIVER)
        // This sample code sends a disconnect over to the connected BChannel.
        PCARD_EVENT_OBJECT      pEvent;
        PBCHANNEL_OBJECT        pPeerBChannel = pBChannel->pPeerBChannel;

        if (pPeerBChannel)
        {
            pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
            if (pEvent)
            {
                // Indicate call disconnect to the other channel.
                pEvent->ulEventCode      = CARD_EVENT_DISCONNECT;
                pEvent->pSendingObject   = pBChannel;
                pEvent->pReceivingObject = pPeerBChannel;
                CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            }
            pBChannel->pPeerBChannel = NULL;
        }
        else
        {
            DBG_WARNING(pAdapter,("#%d NO PEER CHANNEL - CALLSTATE=%X\n",
                        pBChannel->ObjectID, pBChannel->CallState));
        }
        // Return any pending packets to the protocol stack.
        pBChannel->CallState = LINECALLSTATE_IDLE;
#else  // SAMPLE_DRIVER
        // TODO - Add code here to reject an incoming call.
#endif // SAMPLE_DRIVER
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\keywords.h ===
/*

                                                                             
    (C) Copyright 1999 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Keywords Keywords_h

@module Keywords.h |

    This file defines the driver parameter keywords used in the registry.
    This file should be #include'd into the driver module defining the
    configuration parameter table <t PARAM_TABLE>.

@comm

    The configuration parmaeters should be parsed early in the initialization
    process so they can be used to configure software and hardware settings.

    You can easily add new parameters using the following procuedure:<nl>
    1) #define a new keyword string here in <f Keywords\.h>.<nl>
    2) Add a corresponding <f PARAM_ENTRY> into your parameter table <t PARAM_TABLE>.<nl>
    3) Add a variable to the associated data structure (e.g. <t MINIPORT_ADAPTER_OBJECT>).

    These values can then be parsed by calling <f ParamParseRegistry> with a 
    pointer to your configuration parameter table <t PARAM_TABLE>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Keywords_h

@end

*/


/* @doc EXTERNAL INTERNAL


@topic 5.0 Registry Parameters |

    This section describes the registry parameters used by the driver.
    These parameters are stored in the following registry path.<nl>
    
    Windows registry path:<nl>
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\"Net"\0001><nl>

    On Windows 2000 "Net" is defined as GUID: {4D36E972-xxxx}

    On Windows 98 "Net" is just a sub key.

    The final path key "\0001" depends on the adapter instance number assigned
    by NDIS during installation.<nl>

    <f Note>: Windows 98 DWORD registry parameters are stored as strings.  
    The NDIS wrapper converts them to integers when they are read.  The string 
    can be decimal or hexadecimal as long as you read it with the appropriate 
    NDIS parameter type NdisParameterInteger or NdisParameterHexInteger.

    These values are declared as entries in the <t PARAM_TABLE> and are parsed 
    from the registry using the <f ParamParseRegistry> routine.  Each object
    in the driver has its own parameter table.
	
*/

#ifndef _KEYWORDS_H
#define _KEYWORDS_H

#define PARAM_MAX_KEYWORD_LEN               128

/*
// These parameters are placed in the registry during installation.
*/
#define PARAM_NumDChannels                  "IsdnNumDChannels"
#define PARAM_NumBChannels                  "IsdnNumBChannels"

/*
// These parameters are not placed in the registry by default, but they
// will be used if present.
*/
#define PARAM_BufferSize                    "BufferSize"
#define PARAM_ReceiveBuffersPerLink         "ReceiveBuffersPerLink"
#define PARAM_TransmitBuffersPerLink        "TransmitBuffersPerLink"
#define PARAM_DebugFlags                    "DebugFlags"

#define PARAM_TODO                          "TODO"
// Add your keywords here, and place them in the proper parameter table.

// Port based parameters
#define PARAM_PORT_PREFIX                   "Line" // Line0 .. Line9
#define PARAM_SwitchType                    "IsdnSwitchType"

#endif // _KEYWORDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\interupt.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Interrupt Interrupt_c

@module Interrupt.c |

    This module implements the Miniport interrupt processing routines and
    asynchronous processing routines.  
    
    The sample driver does not support physical hardware, so there is no need
    for the typical interrupt handler routines.  However, the driver does
    have an asynchronous event handler which is contained in this module.

@comm

    This module is very dependent on the hardware/firmware interface and should 
    be looked at whenever changes to these interfaces occur.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Interupt_c

@end

*/

#define  __FILEID__             INTERRUPT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportCheckForHang


@func

    <f MiniportCheckForHang> reports the state of the network interface card.

@comm

    The NDIS library calls <f MiniportCheckForHang> once every two seconds to
    check the state of the network interface card.  If this function returns
    TRUE, the NDIS library then attempts to reset the NIC by calling
    <f MiniportReset>.  <f MiniportCheckForHang> should do nothing more than
    check the internal state of the NIC and return TRUE if it detects that
    the NIC is not operating correctly.

    Interrupts can be in any state when MiniportCheckForHang is called.

    <f Note>:
    If your hardware/firmware is flakey you can request that the NDIS
    wrapper call your MiniportReset routine by returning TRUE from this
    routine.  For well behaved hardware/firmware you should always return
    FALSE from this routine.

@rdesc

    <f MiniportCheckForHang> returns FALSE if the NIC is working properly.<nl>
    Otherwise, a TRUE return value indicates that the NIC needs to be reset.

*/

BOOLEAN MiniportCheckForHang(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportCheckForHang")
    // If your hardware can lockup, then you can return TRUE here.
    // If you return TRUE, your MiniportReset routine will be called.
    return (FALSE);
}


#if defined(CARD_REQUEST_ISR)
#if (CARD_REQUEST_ISR == FALSE)

/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportDisableInterrupt


@func

    <f MiniportDisableInterrupt> disables the NIC from generating interrupts.

@comm

    Typically, this function disables interrupts by writing a mask value
    specific to the network interface card.

    If the NIC does not support enabling and disabling interrupts, the
    miniport driver must register a miniport interrupt service routine with
    the NDIS library.  Within the interrupt service routine, the miniport
    driver must acknowledge and save the interrupt information.

    In some cases, the NIC must be in a certain state for
    <f MiniportDisableInterrupt> to execute correctly. In these cases, the
    miniport driver must encapsulate within a function all portions of the
    driver which violate the required state and which can be called when
    interrupts are enabled.  Then the miniport driver must call the
    encapsulated code through the NdisMSynchronizeWithInterrupt function.
    For example, on some network interface cards, the I/O ports are paged
    and must be set to page 0 for the deferred processing routine to run
    correctly.  With this kind of NIC, the DPC must be synchronized with
    interrupts.

    Interrupts can be in any state when <f MiniportDisableInterrupt> is
    called.

*/

void MiniportDisableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportDisableInterrupt")
    DBG_ERROR(pAdapter,("This should not be called!\n"));
}


/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportEnableInterrupt


@func

    <f MiniportEnableInterrupt> enables the NIC to generate interrupts.

@comm

    Typically, this function enables interrupts by writing a mask value
    specific to the network interface card.

    If the NIC does not support enabling and disabling interrupts, the
    miniport driver must register a miniport interrupt service routine with
    the NDIS library. Within the interrupt service routine, the miniport
    driver must acknowledge and save the interrupt information.

    Interrupts can be in any state when <f MiniportEnableInterrupt> is called.

*/

void MiniportEnableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportEnableInterrupt")
    DBG_ERROR(pAdapter,("This should not be called!\n"));
}

#else // !(CARD_REQUEST_ISR == FALSE)

/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportISR


@func

    <f MiniportISR> is the miniport driver's interrupt service routine. This
    function runs at a high priority in response to an interrupt. The driver
    should do as little work as possible in this function. It should set
    <p InterruptRecognized> to TRUE if it recognizes the interrupt as
    belonging to its network interface card, or FALSE otherwise. It should
    return FALSE as soon as possible if the interrupt is not generated by
    its NIC. It should set <f QueueMiniportHandleInterrupt> to TRUE if a
    call to <f MiniportHandleInterrupt> at a lower priority is required to
    complete the handling of the interrupt.

    <f Note>: <f MiniportISR> must not call any support functions in the NDIS
    interface library or the transport driver.

@comm

    <f MiniportISR> is called in the following cases:<nl>

    o   The NIC generates an interrupt when there is an outstanding call to
        <f MiniportInitialize>.

    o   The miniport driver supports sharing its interrupt line with another
        NIC.

    o   The miniport driver specifies that this function must be called for
        every interrupt.

    <f Note>: A deferred processing routine is not queued if the miniport
    driver is currently executing <f MiniportHalt> or <f MiniportInitialize>.

*/

void MiniportISR(
    OUT PBOOLEAN                InterruptRecognized,        // @parm
    // If the miniport driver is sharing an interrupt line and it detects
    // that the interrupt came from its NIC, <f MiniportISR> should set
    // this parameter to TRUE.

    OUT PBOOLEAN                QueueMiniportHandleInterrupt, // @parm
    // If the miniport driver is sharing an interrupt line and if
    // <f MiniportHandleInterrupt> must be called to complete handling of
    // the interrupt, <f MiniportISR> should set this parameter to TRUE.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportISR")

    ULONG                       InterruptStatus;

    // TODO: Get the interrupt status from your card.
    if ((InterruptStatus = pAdapter->TODO) == 0)
    {
        *InterruptRecognized =
        *QueueMiniportHandleInterrupt = FALSE;
    }
    else
    {
        pAdapter->pCard->InterruptStatus = InterruptStatus;
        *InterruptRecognized =
        *QueueMiniportHandleInterrupt = TRUE;
    }
}

#endif // (CARD_REQUEST_ISR == FALSE)
#endif // defined(CARD_REQUEST_ISR)

/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportHandleInterrupt


@func

    <f MiniportHandleInterrupt> is called by the deferred processing routine
    in the NDIS library to process an interrupt.

@comm

    During a call to <f MiniportHandleInterrupt>, the miniport driver should
    handle all outstanding interrupts and start any new operations.

    Interrupts are disabled during a call to <f MiniportHandleInterrupt>.

*/

void MiniportHandleInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportHandleInterrupt")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    ULONG                       BChannelIndex;
    // Index into the pBChannelArray.

    /*
    // Process NIC interrupt.
    */
    CardInterruptHandler(pAdapter->pCard);

    /*
    // Walk through all the links to see if there is any post-proccessing
    // that needs to be done.
    */
    for (BChannelIndex = 0; BChannelIndex < pAdapter->NumBChannels; ++BChannelIndex)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex);

        if (pBChannel->IsOpen)
        {
            /*
            // Indicate a receive complete if it's needed.
            */
            if (pBChannel->NeedReceiveCompleteIndication)
            {
                pBChannel->NeedReceiveCompleteIndication = FALSE;

                /*
                // Indicate receive complete to the NDIS wrapper.
                */
                DBG_RXC(pAdapter, pBChannel->ObjectID);
                NdisMCoReceiveComplete(pAdapter->MiniportAdapterHandle);
            }
        }
    }

    /*
    // Indicate a status complete if it's needed.
    */
    if (pAdapter->NeedStatusCompleteIndication)
    {
        pAdapter->NeedStatusCompleteIndication = FALSE;
        NdisMIndicateStatusComplete(pAdapter->MiniportAdapterHandle);
    }
}


/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportTimer


@func

    <f MiniportTimer> is a required function if a Minipor's NIC does not
    generate interrupts.  Otherwise, one or more <f MiniportTimer> functions
    are optional.

    The driver of a NIC that does not generate interrupts must have a <f
    MiniportTimer> function to poll the state of the NIC. After such a
    Miniport's MiniportInitialize function sets up the driver-allocated timer
    object with NdisMInitializeTimer, a call to NdisMSetPeriodicTimer causes
    the <f MiniportTimer> function associated with the timer object to be run
    repeatedly and automatically at the interval specified by
    MillisecondsPeriod. Such a polling <f MiniportTimer> function monitors the
    state of the NIC to determine when to make indications, when to complete
    pending sends, and so forth. In effect, such a polling <f MiniportTimer>
    function has the same functionality as the MiniportHandleInterrupt
    function in the driver of a NIC that does generate interrupts.

    By contrast, calling NdisMSetTimer causes the <f MiniportTimer> function
    associated with the timer object to be run once when the given
    MillisecondsToDelay expires.  Such a <f MiniportTimer> function usually
    performs some driver-determined action if a particular operation times
    out.

    If either type of <f MiniportTimer> function shares resources with other
    driver functions, the driver should synchronize access to those resources
    with a spin lock.

    A Miniport can have more than one <f MiniportTimer> function at the
    discretion of the driver writer. Each such <f MiniportTimer> function must
    be associated with a driver-allocated and initialized timer object.

    A call to NdisMCancelTimer cancels execution of a nonpolling
    <f MiniportTimer> function, provided that the interval passed in the
    immediately preceding call to NdisMSetTimer has not yet expired. After a
    call to NdisMSetPeriodicTimer, a call to NdisMSetTimer or NdisMCancelTimer
    with the same timer object disables a polling <f MiniportTimer> function:
    either the <f MiniportTimer> function runs once, or it is canceled.

    The MiniportHalt function of any driver with a <f MiniportTimer> function
    should call NdisMCancelTimer to ensure that the <f MiniportTimer> function
    does not attempt to access resources that MiniportHalt has already
    released.

    By default, <f MiniportTimer> runs at IRQL DISPATCH_LEVEL.

*/

void MiniportTimer(
    IN PVOID                    SystemSpecific1,            // @parm
    // UNREFERENCED_PARAMETER

    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PVOID                    SystemSpecific2,            // @parm
    // UNREFERENCED_PARAMETER

    IN PVOID                    SystemSpecific3             // @parm
    // UNREFERENCED_PARAMETER
    )
{
    DBG_FUNC("MiniportTimer")

    // DBG_ENTER(pAdapter);

    /*
    // If this is a nested callback, just return, and we'll loop back to
    // the DoItAgain before leaving the outermost callback.
    */
    if (++(pAdapter->NestedEventHandler) > 1)
    {
        DBG_WARNING(pAdapter,("NestedEventHandler=%d > 1\n",
                  pAdapter->NestedEventHandler));
        return;
    }

DoItAgain:
#if defined(SAMPLE_DRIVER)
    /*
    // This sample driver uses timer to simulate interrupts.
    */
    MiniportHandleInterrupt(pAdapter);
#else  // SAMPLE_DRIVER
    // TODO - Add code here to handle timer interrupt events.
#endif // SAMPLE_DRIVER

    /*
    // If we got a nested callback, we have to loop back around.
    */
    if (--(pAdapter->NestedEventHandler) > 0)
    {
        goto DoItAgain;
    }
    else if (pAdapter->NestedEventHandler < 0)
    {
        DBG_ERROR(pAdapter,("NestedEventHandler=%d < 0\n",
                  pAdapter->NestedEventHandler));
    }

    // DBG_LEAVE(pAdapter);

    UNREFERENCED_PARAMETER(SystemSpecific1);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    UNREFERENCED_PARAMETER(SystemSpecific3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\miniport.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Miniport Miniport_c

@module Miniport.c |

    This module implements the <f DriverEntry> routine, which is the first
    routine called when the driver is loaded into memory.  The Miniport
    initialization and termination routines are also implemented here.

@comm

    This module should not require any changes.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Miniport_c

@end

*/

#define  __FILEID__             MINIPORT_DRIVER_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "TpiParam.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC NDIS_HANDLE          g_NdisWrapperHandle = NULL;     // @globalv
// Receives the context value representing the Miniport wrapper
// as returned from NdisMInitializeWrapper.

NDIS_PHYSICAL_ADDRESS           g_HighestAcceptableAddress =    // @globalv
// This constant is used for places where NdisAllocateMemory needs to be
// called and the g_HighestAcceptableAddress does not matter.
                                NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);


/* @doc EXTERNAL INTERNAL Miniport Miniport_c DriverEntry


@func

    <f DriverEntry> is called by the operating system when a driver is loaded.
    This function creates an association between the miniport NIC driver and
    the NDIS library and registers the miniport's characteristics with NDIS.

    DriverEntry calls NdisMInitializeWrapper and then NdisMRegisterMiniport.
    DriverEntry passes both pointers it received to NdisMInitializeWrapper,
    which returns a wrapper handle.  DriverEntry passes the wrapper handle to
    NdisMRegisterMiniport.

    The registry contains data that is persistent across system boots, as well
    as configuration information generated anew at each system boot.  During
    driver installation, data describing the driver and the NIC is stored in
    the registry. The registry contains adapter characteristics that are read
    by the NIC driver to initialize itself and the NIC. See the Kernel-Mode
    Driver Design Guide for more about the registry and the Programmer's Guide
    for more information about the .inf files that install the driver and
    write to the registry.

@comm

    Every miniport driver must provide a function called DriverEntry.  By
    convention, DriverEntry is the entry point address for a driver.  If a
    driver does not use the name DriverEntry, the driver developer must define
    the name of its entry function to the linker so that the entry point
    address can be known into the OS loader.

    It is interesting to note, that at the time DriverEntry is called, the OS
    doesn't know that the driver is an NDIS driver.  The OS thinks it is just
    another driver being loaded.  So it is possible to do anything any driver
    might do at this point.  Since NDIS is the one who requested this driver
    to be loaded, it would be polite to register with the NDIS wrapper.  But
    you can also hook into other OS functions to use and provide interfaces
    outside the NDIS wrapper.  (Not recommended for the faint of heart).

@comm

    The parameters passed to DriverEntry are OS specific! NT passes in valid
    values, but Windows 3.1 and Windows 95 just pass in zeros.  We don't
    care, because we just pass them to the NDIS wrapper anyway.

@rdesc

    <f DriverEntry> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT           DriverObject,               // @parm
    // A pointer to the driver object, which was created by the I/O system.

    IN PUNICODE_STRING          RegistryPath                // @parm
    // A pointer to the registry path, which specifies where driver-specific
    // parameters are stored.
    )
{
    DBG_FUNC("DriverEntry")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    NTSTATUS                    Result;
    // Result code returned by this function.

    NDIS_MINIPORT_CHARACTERISTICS NdisCharacteristics;
    // Characteristics table passed to NdisMWanRegisterMiniport.

    /*
    // Setup default debug flags then breakpoint so we can tweak them
    // when this module is first loaded.  It is also useful to see the
    // build date and time to be sure it's the one you think it is.
    */
#if DBG
    DbgInfo->DbgFlags = DBG_DEFAULTS;
    DbgInfo->DbgID[0] = '0';
    DbgInfo->DbgID[1] = ':';
    if (sizeof(VER_TARGET_STR) < sizeof(DbgInfo->DbgID)-3)
    {
        memcpy(&DbgInfo->DbgID[2], VER_TARGET_STR, sizeof(VER_TARGET_STR));
    }
    else
    {
        memcpy(&DbgInfo->DbgID[2], VER_TARGET_STR, sizeof(DbgInfo->DbgID)-3);
        DbgInfo->DbgID[sizeof(DbgInfo->DbgID)-1] = 0;
    }
#endif // DBG
    DBG_PRINT((VER_TARGET_STR": Build Date:"__DATE__" Time:"__TIME__"\n"));
    DBG_PRINT((VER_TARGET_STR": DbgInfo=0x%X DbgFlags=0x%X\n",
               DbgInfo, DbgInfo->DbgFlags));
    DBG_BREAK(DbgInfo);

    DBG_ENTER(DbgInfo);
    DBG_PARAMS(DbgInfo,
              ("\n"
               "\t|DriverObject=0x%X\n"
               "\t|RegistryPath=0x%X\n",
               DriverObject,
               RegistryPath
              ));

    /*
    // Initialize the Miniport wrapper - THIS MUST BE THE FIRST NDIS CALL.
    */
    NdisMInitializeWrapper(
            &g_NdisWrapperHandle,
            DriverObject,
            RegistryPath,
            NULL
            );
    ASSERT(g_NdisWrapperHandle);

    /*
    // Initialize the characteristics table, exporting the Miniport's entry
    // points to the Miniport wrapper.
    */
    NdisZeroMemory((PVOID)&NdisCharacteristics, sizeof(NdisCharacteristics));
    NdisCharacteristics.MajorNdisVersion        = NDIS_MAJOR_VERSION;
    NdisCharacteristics.MinorNdisVersion        = NDIS_MINOR_VERSION;
    NdisCharacteristics.Reserved                = NDIS_USE_WAN_WRAPPER;

    NdisCharacteristics.InitializeHandler       = MiniportInitialize;
    NdisCharacteristics.CheckForHangHandler     = MiniportCheckForHang;
    NdisCharacteristics.HaltHandler             = MiniportHalt;
    NdisCharacteristics.ResetHandler            = MiniportReset;
    NdisCharacteristics.ReturnPacketHandler     = MiniportReturnPacket;

    NdisCharacteristics.CoActivateVcHandler     = MiniportCoActivateVc;
    NdisCharacteristics.CoDeactivateVcHandler   = MiniportCoDeactivateVc;
    NdisCharacteristics.CoRequestHandler        = MiniportCoRequest;
    NdisCharacteristics.CoSendPacketsHandler    = MiniportCoSendPackets;

    // These two routines are not needed because we are an MCM.
    // NdisCharacteristics.CoCreateVcHandler       = MiniportCoCreateVc;
    // NdisCharacteristics.CoDeleteVcHandler       = MiniportCoDeleteVc;

    /*
    // If the adapter does not generate an interrupt, these entry points
    // are not required.  Otherwise, you can use the have the ISR routine
    // called each time an interupt is generated, or you can use the
    // enable/disable routines.
    */
#if defined(CARD_REQUEST_ISR)
# if (CARD_REQUEST_ISR == FALSE)
    NdisCharacteristics.DisableInterruptHandler = MiniportDisableInterrupt;
    NdisCharacteristics.EnableInterruptHandler  = MiniportEnableInterrupt;
# endif // CARD_REQUEST_ISR == FALSE
    NdisCharacteristics.HandleInterruptHandler  = MiniportHandleInterrupt;
    NdisCharacteristics.ISRHandler              = MiniportISR;
#endif // defined(CARD_REQUEST_ISR)

    /*
    // Register the driver with the Miniport wrapper.
    */
    Status = NdisMRegisterMiniport(
                    g_NdisWrapperHandle,
                    (PNDIS_MINIPORT_CHARACTERISTICS) &NdisCharacteristics,
                    sizeof(NdisCharacteristics)
                    );

    /*
    // The driver will not load if this call fails.
    // The system will log the error for us.
    */
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(DbgInfo,("Status=0x%X\n",Status));
        Result = STATUS_UNSUCCESSFUL;
    }
    else
    {
        DBG_NOTICE(DbgInfo,("Status=0x%X\n",Status));
        Result = STATUS_SUCCESS;
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL Miniport Miniport_c MiniportInitialize


@func

    <f MiniportInitialize> is a required function that sets up a NIC (or
    virtual NIC) for network I/O operations, claims all hardware resources
    necessary to the NIC in the registry, and allocates resources the driver
    needs to carry out network I/O operations.

@comm

    No other outstanding requests to the miniport driver are possible when
    MiniportInitialize is called. No other request is submitted to the
    miniport driver until initialization is completed.

    The NDIS library supplies an array of supported media types. The miniport
    driver reads this array and provides the index of the media type that the
    NDIS library should use with this miniport driver. If the miniport driver
    is emulating a media type, its emulation must be transparent to the NDIS
    library.

    MiniportInitialize must call NdisMSetAttributes in order to return
    MiniportAdapterContext.

    If the miniport driver cannot find a common media type supported by both
    itself and the NDIS library, it should return
    NDIS_STATUS_UNSUPPORTED_MEDIA.

    If NDIS_STATUS_OPEN_ERROR is returned, the NDIS wrapper can examine the
    output parameter OpenErrorStatus to obtain more information about the
    error.

    MiniportInitialize is called with interrupts enabled. MiniportISR is
    called if the NIC generates any interrupts. The NDIS library will not call
    MiniportDisableInterrupt and MiniportEnableInterrupt during the
    MiniportInitialize function, so it is the responsibility of the miniport
    driver to acknowledge and clear any interrupts generated.

@rdesc

    <f MiniportInitialize> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS MiniportInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,            // @parm
    // Points to a variable that MiniportInitialize sets to an
    // NDIS_STATUS_XXX code specifying additional information about the
    // error if MiniportInitialize will return NDIS_STATUS_OPEN_ERROR.

    OUT PUINT                   SelectedMediumIndex,        // @parm
    // Points to a variable in which MiniportInitialize sets the index of
    // the MediumArray element that specifies the medium type the driver
    // or its NIC uses.

    IN PNDIS_MEDIUM             MediumArray,                // @parm
    // Specifies an array of NdisMediumXxx values from which
    // MiniportInitialize selects one that its NIC supports or that the
    // driver supports as an interface to higher-level drivers.

    IN UINT                     MediumArraySize,            // @parm
    // Specifies the number of elements at MediumArray.

    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    IN NDIS_HANDLE              WrapperConfigurationContext // @parm
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.
    )
{
    DBG_FUNC("MiniportInitialize")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // Pointer to our newly allocated object.

    UINT                        Index;
    // Loop counter.

    NDIS_CALL_MANAGER_CHARACTERISTICS   McmCharacteristics;
    // Characteristics table passed to NdisMCmRegisterAddressFamily.

    CO_ADDRESS_FAMILY                   McmAddressFamily;
    // Address family passed to NdisMCmRegisterAddressFamily.

    DBG_ENTER(DbgInfo);
    DBG_PARAMS(DbgInfo,
              ("\n"
               "\t|OpenErrorStatus=0x%X\n"
               "\t|SelectedMediumIndex=0x%X\n"
               "\t|MediumArray=0x%X\n"
               "\t|MediumArraySize=0x%X\n"
               "\t|MiniportAdapterHandle=0x%X\n"
               "\t|WrapperConfigurationContext=0x%X\n",
               OpenErrorStatus,
               SelectedMediumIndex,
               MediumArray,
               MediumArraySize,
               MiniportAdapterHandle,
               WrapperConfigurationContext
              ));

    /*
    // Search the MediumArray for the NdisMediumCoWan media type.
    */
    for (Index = 0; Index < MediumArraySize; Index++)
    {
        if (MediumArray[Index] == NdisMediumCoWan)
        {
            break;
        }
    }

    /*
    // Make sure the protocol has requested the proper media type.
    */
    if (Index < MediumArraySize)
    {
        /*
        // Allocate memory for the adapter information structure.
        */
        Status = AdapterCreate(
                        &pAdapter,
                        MiniportAdapterHandle,
                        WrapperConfigurationContext
                        );

        if (Status == NDIS_STATUS_SUCCESS)
        {
            /*
            // Now it's time to initialize the hardware resources.
            */
            Status = AdapterInitialize(pAdapter);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                /*
                // Initialize the address family so NDIS know's what we support.
                */
                NdisZeroMemory(&McmAddressFamily, sizeof(McmAddressFamily));
                McmAddressFamily.MajorVersion   = NDIS_MAJOR_VERSION;
                McmAddressFamily.MinorVersion   = NDIS_MINOR_VERSION;
                McmAddressFamily.AddressFamily  = CO_ADDRESS_FAMILY_TAPI_PROXY;

                /*
                // Initialize the characteristics table, exporting the Miniport's entry
                // points to the Miniport wrapper.
                */
                NdisZeroMemory((PVOID)&McmCharacteristics, sizeof(McmCharacteristics));
                McmCharacteristics.MajorVersion                  = NDIS_MAJOR_VERSION;
                McmCharacteristics.MinorVersion                  = NDIS_MINOR_VERSION;
                McmCharacteristics.CmCreateVcHandler             = ProtocolCoCreateVc;
                McmCharacteristics.CmDeleteVcHandler             = ProtocolCoDeleteVc;
                McmCharacteristics.CmOpenAfHandler               = ProtocolCmOpenAf;
                McmCharacteristics.CmCloseAfHandler              = ProtocolCmCloseAf;
                McmCharacteristics.CmRegisterSapHandler          = ProtocolCmRegisterSap;
                McmCharacteristics.CmDeregisterSapHandler        = ProtocolCmDeregisterSap;
                McmCharacteristics.CmMakeCallHandler             = ProtocolCmMakeCall;
                McmCharacteristics.CmCloseCallHandler            = ProtocolCmCloseCall;
                McmCharacteristics.CmIncomingCallCompleteHandler = ProtocolCmIncomingCallComplete;
                McmCharacteristics.CmActivateVcCompleteHandler   = ProtocolCmActivateVcComplete;
                McmCharacteristics.CmDeactivateVcCompleteHandler = ProtocolCmDeactivateVcComplete;
                McmCharacteristics.CmModifyCallQoSHandler        = ProtocolCmModifyCallQoS;
                McmCharacteristics.CmRequestHandler              = ProtocolCoRequest;
                McmCharacteristics.CmRequestCompleteHandler      = ProtocolCoRequestComplete;

                DBG_NOTICE(pAdapter,("Calling NdisMCmRegisterAddressFamily\n"));
                Status = NdisMCmRegisterAddressFamily(
                                MiniportAdapterHandle,
                                &McmAddressFamily,
                                &McmCharacteristics,
                                sizeof(McmCharacteristics)
                                );

                if (Status != NDIS_STATUS_SUCCESS)
                {
                    DBG_ERROR(DbgInfo,("NdisMCmRegisterAddressFamily Status=0x%X\n",
                              Status));
                    /*
                    // Log error message and return.
                    */
                    NdisWriteErrorLogEntry(
                            MiniportAdapterHandle,
                            NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                            3,
                            Status,
                            __FILEID__,
                            __LINE__
                            );
                }
            }

            if (Status == NDIS_STATUS_SUCCESS)
            {
                /*
                // Save the selected media type.
                */
                *SelectedMediumIndex = Index;
            }
            else
            {
                /*
                // Something went wrong, so let's make sure everything is
                // cleaned up.
                */
                MiniportHalt(pAdapter);
            }
        }
    }
    else
    {
        DBG_ERROR(DbgInfo,("No NdisMediumCoWan found (Array=0x%X, ArraySize=%d)\n",
                  MediumArray, MediumArraySize));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                3,
                Index,
                __FILEID__,
                __LINE__
                );

        Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    /*
    // If all goes well, register a shutdown handler for this adapter.
    */
    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisMRegisterAdapterShutdownHandler(MiniportAdapterHandle,
                                            pAdapter, MiniportShutdown);
    }

    DBG_NOTICE(DbgInfo,("Status=0x%X\n",Status));

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc EXTERNAL INTERNAL Miniport Miniport_c MiniportHalt


@func

    <f MiniportHalt> request is used to halt the adapter such that it is
    no longer functioning.

@comm

    The Miniport should stop the adapter and deregister all of its resources
    before returning from this routine.

    It is not necessary for the Miniport to complete all outstanding
    requests and no other requests will be submitted to the Miniport
    until the operation is completed.

    Interrupts are enabled during the call to this routine.

*/

VOID MiniportHalt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportHalt")

    DBG_ENTER(DbgInfo);

    /*
    // Remove our shutdown handler from the system.
    */
    NdisMDeregisterAdapterShutdownHandler(pAdapter->MiniportAdapterHandle);

    /*
    // Free adapter instance.
    */
    AdapterDestroy(pAdapter);

    DBG_LEAVE(DbgInfo);
}


/* @doc EXTERNAL INTERNAL Miniport Miniport_c MiniportShutdown


@func

    <f MiniportShutdown> is an optional function that restores a NIC to its
    initial state when the system is shut down, whether by the user or because
    an unrecoverable system error occurred.

@comm

    Every NIC driver should have a <f MiniportShutdown> function.
    <f MiniportShutdown> does nothing more than restore the NIC to its initial
    state (before the miniport's DriverEntry function runs). However, this
    ensures that the NIC is in a known state and ready to be reinitialized
    when the machine is rebooted after a system shutdown occurs for any
    reason, including a crash dump.

    A NIC driver's MiniportInitialize function must call
    NdisMRegisterAdapterShutdownHandler to set up a <f MiniportShutdown>
    function. The driver's MiniportHalt function must make a reciprocal call
    to NdisMDeregisterAdapterShutdownHandler.

    If <f MiniportShutdown> is called due to a user-initiated system shutdown,
    it runs at IRQL PASSIVE_LEVEL in a system-thread context. If it is called
    due to an unrecoverable error, <f MiniportShutdown> runs at an arbitrary
    IRQL and in the context of whatever component raised the error. For
    example, <f MiniportShutdown> might be run at high DIRQL in the context of
    an ISR for a device essential to continued execution of the system.

    <f MiniportShutdown> should call no NdisXxx functions.

*/

VOID MiniportShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportShutdown")

    DBG_ENTER(pAdapter);

    /*
    // Reset the hardware and bial out - don't release any resources!
    */
    CardReset(pAdapter->pCard);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL Miniport Miniport_c MiniportReset


@func

    <f MiniportReset> request instructs the Miniport to issue a hardware
    reset to the network adapter.  The Miniport also resets its software
    state.

    The <F MiniportReset> request may also reset the parameters of the adapter.
    If a hardware reset of the adapter resets the current station address
    to a value other than what it is currently configured to, the Miniport
    driver automatically restores the current station address following the
    reset.  Any multicast or functional addressing masks reset by the
    hardware do not have to be reprogrammed by the Miniport.

    <f Note>: This is change from the NDIS 3.0 driver specification.  If the
    multicast or functional addressing information, the packet filter, the
    lookahead size, and so on, needs to be restored, the Miniport indicates
    this with setting the flag AddressingReset to TRUE.

    It is not necessary for the Miniport to complete all outstanding requests
    and no other requests will be submitted to the Miniport until the
    operation is completed.  Also, the Miniport does not have to signal
    the beginning and ending of the reset with NdisMIndicateStatus.

    <f Note>: These are different than the NDIS 3.0 driver specification.

    The Miniport must complete the original request, if the orginal
    call to <F MiniportReset> return NDIS_STATUS_PENDING, by calling
    NdisMResetComplete.

    If the underlying hardware does not provide a reset function under
    software control, then this request completes abnormally with
    NDIS_STATUS_NOT_RESETTABLE.  If the underlying hardware attempts a
    reset and finds recoverable errors, the request completes successfully
    with NDIS_STATUS_SOFT_ERRORS.  If the underlying hardware resets and,
    in the process, finds nonrecoverable errors, the request completes
    successfully with the status NDIS_STATUS_HARD_ERRORS.  If the
    underlying  hardware reset is accomplished without any errors,
    the request completes successfully with the status NDIS_STATUS_SUCCESS.

    Interrupts are in any state during this call.

@comm

    I have only seen MiniportReset called when the driver is not working
    properly.  If this gets called, your code is probably broken, so fix
    it.  Don't try to recover here unless there is some hardware/firmware
    problem you must work around.

@rdesc

    <f MiniportReset> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS MiniportReset(
    OUT PBOOLEAN                AddressingReset,            // @parm
    // The Miniport indicates if the wrapper needs to call
    // <f MiniportCoRequest> to restore the addressing information
    // to the current values by setting this value to TRUE.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportReset")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Result code returned by this function.

    DBG_ENTER(pAdapter);

    DBG_ERROR(pAdapter,("##### !!! THIS SHOULD NEVER BE CALLED !!! #####\n"));

    /*
    // If anything goes wrong here, it's very likely an unrecoverable
    // hardware failure.  So we'll just shut this thing down for good.
    */
    Result = NDIS_STATUS_HARD_ERRORS;
    *AddressingReset = TRUE;

    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\callmgr.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL CallMgr CallMgr_c

@module CallMgr.c |

    This module defines the interface to the <t CALL_MANAGER_OBJECT>.
    Supports the interface between NDISPROXY and the Miniport.  All the
    Address Family, SAP, VC, and call related events pass through these
    interface on their way to and from NDPROXY.

@comm

    This module will require some changes depending on how your hardware
    works.  But in general, you should try to isolate your changes down in
    <f DChannel\.c> and <f Card\.c>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | CallMgr_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.1 Call Manager Interface |

    The NDPROXY driver is a provider for the Windows Telephony service.
    Applications make TAPI requests and the Windows Telephony service routes
    these requests to NDPROXY. NDPROXY implements the Telephony Service Provider
    Interface (TSPI) for the Windows Telephony service. NDPROXY then
    communicates through NDIS with the NDISWAN driver and CoNDIS WAN miniport
    drivers. These CoNDIS WAN miniport drivers must provide TAPI capability.

    The NDPROXY driver passes TAPI requests by encapsulating TAPI parameters in
    NDIS structures. NDPROXY presents a client interface to CoNDIS WAN miniport
    drivers and a call manager interface to NDISWAN. NDISWAN presents a client
    interface to NDPROXY. CoNDIS WAN miniport drivers present a call manager
    interface to NDPROXY and a CoNDIS miniport interface to NDISWAN.

    A TAPI-capable CoNDIS WAN miniport driver registers and initializes itself
    as a user of both WAN and TAPI services. After registration and
    initialization are complete, a user-level application can make telephonic
    requests to the Windows Telephony service module, which converts TAPI
    requests to TSPI requests. The Windows Telephony service module passes these
    requests to the NDPROXY driver. NDPROXY encapsulates parameters for TAPI
    requests in NDIS structures and routes the requests to the appropriate
    CoNDIS WAN miniport driver. These requests are routed in order to set up,
    monitor, and tear down lines, and calls.

    A TAPI-capable CoNDIS WAN miniport driver can also communicate changes in
    the states of lines and calls, for instance the arrival of an incoming call
    or a remote disconnection.

@ex Registering and opening the TAPI address family between NDPROXY and MCM |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    |                                  | NdisMCmRegisterAddressFamily     |
    | ProtocolCoAfRegisterNotify       |---------------------------------|
    |---------------------------------|                                  |
    | NdisClOpenAddressFamily          |                                  |
    |---------------------------------| ProtocolCmOpenAf                 |
    |                                  |---------------------------------|
    |                                  |                 CompleteCmOpenAf |
    |                                  | NdisCmOpenAddressFamilyComplete  |
    | ProtocolOpenAfComplete           |---------------------------------|
    |---------------------------------|                                  |
    |----------------------------------|----------------------------------|

@ex Closing the TAPI address family between NDPROXY and MCM |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisClCloseAddressFamily         |                                  |
    |---------------------------------| ProtocolCmCloseAf                |
    |                                  |---------------------------------|
    |                                  |                CompleteCmCloseAf |
    |                                  | NdisMCmCloseAddressFamilyComplete|
    | ProtocolClCloseAfComplete        |---------------------------------|
    |---------------------------------|                                  |
    |----------------------------------|----------------------------------|

@ex Registering a SAP between NDPROXY and MCM |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisClRegisterSap                |                                  |
    |---------------------------------| ProtocolCmRegisterSap            |
    |                                  |---------------------------------|
    |                                  |            CompleteCmRegisterSap |
    |                                  | NdisMCmRegisterSapComplete       |
    | ProtocolClRegisterSapComplete    |---------------------------------|
    |---------------------------------|                                  |
    |----------------------------------|----------------------------------|

@ex Deregistering a SAP between NDPROXY and MCM |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisClDeregisterSap              |                                  |
    |---------------------------------| ProtocolCmDeregisterSap          |
    |                                  |---------------------------------|
    |                                  |          CompleteCmDeregisterSap |
    |                                  | NdisMCmDeregisterSapComplete     |
    | ProtocolClDeregisterSapComplete  |---------------------------------|
    |---------------------------------|                                  |
    |----------------------------------|----------------------------------|

@ex Seting up an outgoing call from NDPROXY to MCM |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisCoCreateVc                   | ProtocolCoCreateVC               |
    |---------------------------------|--------------------------------|
    | NdisClMakeCall                   | ProtocolCmMakeCall               |
    |---------------------------------|---------------------------------|
    |               .                  |                .                 |
    |               .                  |                .                 |
    |               .                  |                .                 |
    |                                  | NdisMCmActivateVC                |
    |                                  |---------------------------------|
    |                                  | ProtocolCmActivateVcComplete     |
    |                                  |---------------------------------|
    | ProtocolClMakeCallComplete       | NdisMCmMakeCallComplete          |
    |--------------------------------|---------------------------------|
    |               .                  |                .                 |
    |               .    "Tranmit & receive packets"    .                 |
    |               .                  |                .                 |
    |              "Client/MCM initiated call termination"                |
    | NdisCoDeleteVc                   | ProtocolCoDeleteVc               |
    |---------------------------------|--------------------------------|
    |----------------------------------|----------------------------------|

@ex Setting up an incoming call from MCM to NDPROXY |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisCoCreateVc                   | NdisMCmCreateVC                  |
    |--------------------------------|---------------------------------|
    |                                  | NdisMCmActivateVC                |
    |                                  |---------------------------------|
    |                                  | ProtocolCmActivateVcComplete     |
    |                                  |---------------------------------|
    | ProtocolClIncomingCall           | NdisMCmDispatchIncomingCall      |
    |---------------------------------|---------------------------------|
    |                                  |                                  |
    | NdisClIncomingCallComplete       | ProtocolCmIncomingCallComplete   |
    |---------------------------------|--------------------------------|
    | ProtocolClCallConnected          | NdisMCmDispatchCallConnected     |
    |--------------------------------|---------------------------------|
    |               .                  |                .                 |
    |               .    "Tranmit & receive packets"    .                 |
    |               .                  |                .                 |
    |              "Client/MCM initiated call termination"                |
    | ProtocolCoDeleteVc               | NdisMCmDeleteVc                  |
    |--------------------------------|---------------------------------|
    |----------------------------------|----------------------------------|

@ex NDPROXY initiated call termination |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisClCloseCall                  | ProtocolCmCloseCall              |
    |---------------------------------|---------------------------------|
    |                                  | NdisMCmDeactivateVc              |
    |                                  |---------------------------------|
    |                                  | ProtocolCmDeactivateVcComplete   |
    |                                  |---------------------------------|
    | ProtocolClCloseCallComplete      | NdisCmCloseCallComplete          |
    |--------------------------------|---------------------------------|
    |----------------------------------|----------------------------------|

@ex MCM initiated call termination |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | ProtocolClIncomingCloseCall      | NdisMCmDispatchIncomingCloseCall |
    |---------------------------------|---------------------------------|
    | NdisClCloseCall                  | ProtocolCmCloseCall              |
    |---------------------------------|---------------------------------|
    |                                  | NdisMCmDeactivateVc              |
    |                                  |---------------------------------|
    |                                  | ProtocolCmDeactivateVcComplete   |
    |                                  |---------------------------------|
    | ProtocolClCloseCallComplete      | NdisCmCloseCallComplete          |
    |--------------------------------|---------------------------------|
    |----------------------------------|----------------------------------|

@end
*/

#define  __FILEID__             CALL_MANAGER_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL CallMgr CallMgr_c CompleteCmOpenAf


@func

    <f CompleteCmOpenAf> is called when the miniport is done processing the
    <f ProtocolCmOpenAf> request.

@comm

    If you return NDIS_STATUS_PENDING from <f ProtocolCmOpenAf>, you must
    call <f CompleteCmOpenAf> so that <f NdisMCmOpenAddressFamilyComplete>
    can be called to complete the request.

*/

VOID CompleteCmOpenAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.

    IN NDIS_STATUS              Status                      // @parm
    // The NDIS status code to be passed to NdisMCmOpenAddressFamilyComplete.
    )
{
    DBG_FUNC("CompleteCmOpenAf")

    DBG_ENTER(pAdapter);

    /*
    // Try to connect to the DChannel.
    */
    DChannelOpen(pAdapter->pDChannel);

    NdisMCmOpenAddressFamilyComplete(Status, pAdapter->NdisAfHandle, pAdapter);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmOpenAf


@func

    <f ProtocolCmOpenAf> is a required function that allocates per-open
    resources for a call manager to interact with a connection-oriented NDIS
    client that is opening the address family.

@comm

    ProtocolCmOpenAf performs any required allocations of dynamic resources
    and structures that the call manager writer deems necessary to perform
    operations on behalf of the client that is opening an instance of this
    address family. Such resources include, but are not limited to, memory
    buffers, data structures, events, and other such similar resources. A call
    manager should also initialize any relevant per-open data before returning
    control to NDIS.

    When a call manager has allocated its per-open state area, the address of
    the state area should be set in the CallMgrAfContext handle before returning
    control to NDIS. To do this, dereference CallMgrAfContext and store a
    pointer to the data area as the value of the handle. For example:

    *CallMgrAfContext = SomeBuffer;     // We use <t MINIPORT_ADAPTER_OBJECT>.

    If ProtocolCmOpenAf cannot allocate the per-open resources it needs to
    carry out subsequent requests on behalf of the client opening this address
    family, it should free all resources that it allocated for the open and
    return control to the NDIS with NDIS_STATUS_RESOURCES.

    If ProtocolCmOpenAf has completed its required operations and the CM is
    ready to accept requests from the client, ProtocolCmOpenAf should return
    control as quickly as possible with a status of NDIS_STATUS_SUCCESS.

    ProtocolCmOpenAf must be written so that it can run at IRQL DISPATCH_LEVEL.

@rdesc

    ProtocolCmOpenAf returns the status of its operation(s) as one of the
    following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager has successfully allocated and initialized
    any resources necessary to accept requests from the client to this address
    family.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the requested operation is being handled asynchronously. The
    call manager must call NdisCmOpenAddressFamilyComplete when it has completed
    all its open-AF operations to indicate to NDIS (and the client) that the
    operation(s) has been completed.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the call manager could not complete its necessary
    operation(s) because of a lack of available system resources, such as
    memory.

@rvalue NDIS_STATUS_XXX |

    Indicates that the call manager could not set itself into a state where it
    can accept requests from the client to operate on this address family. This
    could be an error status propagated from another NDIS library function or
    any error status determined appropriate by the driver writer.

@xref

    NdisClOpenAddressFamily, NdisCmOpenAddressFamilyComplete,
    NdisCmRegisterAddressFamily, NdisOpenAdapter, <f ProtocolCmCloseAf>
*/

NDIS_STATUS ProtocolCmOpenAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.  AKA CallMgrBindingContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call managers maintains its per-binding state information. The call
    // manager supplied this handle when it called NdisOpenAdapter.

    IN PCO_ADDRESS_FAMILY       AddressFamily,              // @parm
    // Specifies the address family that a client is opening. This address
    // family was registered by the call manager when it called
    // NdisCmRegisterAddressFamily.

    IN NDIS_HANDLE              NdisAfHandle,               // @parm
    // Specifies a handle, supplied by NDIS, that uniquely identifies this
    // address family instance. This handle is opaque to the call manager and
    // reserved for system use.

    OUT PNDIS_HANDLE            CallMgrAfContext            // @parm
    // Specifies the handle to a call manager-supplied context area in which
    // the call manager maintains state about this open of an address family it
    // provides.
    )
{
    DBG_FUNC("ProtocolCmOpenAf")

    NDIS_STATUS                 Status;

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    if (pAdapter->NdisAfHandle != NULL)
    {
        // Our AF has already been opened and it doesn't make any sense to
        // accept another since there is no way to distinguish which should
        // receive incoming calls.
        DBG_ERROR(pAdapter, ("Attempting to open AF again!\n"));
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        pAdapter->NdisAfHandle = NdisAfHandle;

        DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                   ("TAPI AF=0x%X AddressFamily=0x%X MajorVersion=0x%X MinorVersion=0x%X\n",
                   NdisAfHandle,
                   AddressFamily->AddressFamily,
                   AddressFamily->MajorVersion,
                   AddressFamily->MinorVersion
                   ));

        // Since we return NDIS_STATUS_PENDING here, we must call
        // NdisMCmOpenAddressFamilyComplete to complete this request.
        // If necessary, you can do the completion asynchronously.
        *CallMgrAfContext = pAdapter;
        CompleteCmOpenAf(pAdapter, NDIS_STATUS_SUCCESS);
        Status = NDIS_STATUS_PENDING;
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL CallMgr CallMgr_c CompleteCmCloseAf


@func

    <f CompleteCmCloseAf> is called when the miniport is done processing the
    <f ProtocolCmCloseAf> request.

@comm

    If you return NDIS_STATUS_PENDING from <f ProtocolCmCloseAf>, you must
    call <f CompleteCmCloseAf> so that <f NdisMCmCloseAddressFamilyComplete>
    can be called to complete the request.
*/

VOID CompleteCmCloseAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.

    IN NDIS_STATUS              Status                      // @parm
    // The NDIS status code to be passed to NdisMCmCloseAddressFamilyComplete.
    )
{
    DBG_FUNC("CompleteCmCloseAf")

    NDIS_HANDLE                 NdisAfHandle;

    DBG_ENTER(pAdapter);

    NdisAfHandle = pAdapter->NdisAfHandle;
    pAdapter->NdisAfHandle = NULL;

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                ("TAPI AF=0x%X\n",
                NdisAfHandle));

    NdisMCmCloseAddressFamilyComplete(Status, NdisAfHandle);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmCloseAf


@func

    <f ProtocolCmCloseAf> is a required function that releases per-open
    resources for an address family that a call manager supports.

@comm

    ProtocolCmCloseAf releases and/or deactivates any resources that were
    allocated by the call manager in its ProtocolCmOpenAf function. The call
    manager also should undo any other actions it took on behalf of the
    connection-oriented client when the address family was opened by that
    client.

    If there are any outstanding requests or connections still open on an
    address family stored in the CallMgrAfContext, a call manager can respond to
    a client's request to close the address family in either of the following
    ways:

    The call manager can fail the request with NDIS_STATUS_NOT_ACCEPTED.

    The call manager can return NDIS_STATUS_PENDING. After the client has closed
    all calls and deregistered all SAPs, the call manager can then close the
    address family and call Ndis(M)CmCloseAddressFamilyComplete to notify the
    client. This is the preferred response.

    ProtocolCmCloseAf must be written so that it can run at IRQL DISPATCH_LEVEL.

@rdesc

    ProtocolCmCloseAf returns the status of its operation(s) as one of the
    following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager has successfully released or deactivated any
    resources that is allocated on behalf of the connection-oriented client that
    opened this instance of the address family.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the request to close the open instance of the address family
    will be completed asynchronously. The call manager must call
    NdisCmCloseAddressFamilyComplete when all such operations have been
    completed.

@xref

    NdisCmCloseAddressFamilyComplete, <f ProtocolCmOpenAf>
*/

NDIS_STATUS ProtocolCmCloseAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f ProtocolCmOpenAf>.  AKA CallMgrAfContext.<nl>
    // Specifies the handle to the call manager's per-AF context area,
    // originally supplied to NDIS by the call manager's ProtocolCmOpenAf
    // function.
    )
{
    DBG_FUNC("ProtocolCmCloseAf")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    // Since we return NDIS_STATUS_PENDING here, we must call
    // NdisMCmCloseAddressFamilyComplete to complete this request.
    // TODO: If necessary, you can do the completion asynchronously.
    DChannelClose(pAdapter->pDChannel);
    CompleteCmCloseAf(pAdapter, NDIS_STATUS_SUCCESS);
    Result = NDIS_STATUS_PENDING;

    DBG_RETURN(pAdapter, Result);
    return (Result);
}

VOID CompleteCmRegisterSap(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_STATUS              Status                      // @parm
    // The NDIS status code to be passed to NdisMCmRegisterSapComplete.
    )
{
    DBG_FUNC("CompleteCmRegisterSap")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // TODO: What statistics do you want to collect and report?
    */
    pAdapter->TotalRxBytes            = 0;
    pAdapter->TotalTxBytes            = 0;
    pAdapter->TotalRxPackets          = 0;
    pAdapter->TotalTxPackets          = 0;

    // If you return NDIS_STATUS_PENDING from ProtocolCmRegisterSap, you
    // must call NdisMCmRegisterSapComplete to complete the request.
    NdisMCmRegisterSapComplete(Status, pBChannel->NdisSapHandle, pBChannel);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmRegisterSap


@func

    <f ProtocolCmRegisterSap> is a required function that is called by NDIS to
    request that a call manager register a SAP (service access point) on behalf
    of a connection-oriented client.

@comm

    ProtocolCmRegisterSap communicates with network control devices or other
    media-specific agents, as necessary, to register the SAP, as specified at
    Sap, on the network for a connection-oriented client. Such actions could
    include, but are not limited to communicating with switching hardware,
    communicating with a network control station, or other actions that are
    appropriate to the network medium.

    If a call manager is required to communicate with networking control agents
    (e.g. a network switch) it should use a virtual connection to the network
    control agent that it established in its ProtocolBindAdapter function.
    Standalone call managers communicate through the underlying NIC miniport by
    calling NdisCoSendPackets. NIC miniports with integrated call-management
    support never call NdisCoSendPackets. Instead, they transmit the data
    directly across the network.

    In addition, ProtocolCmRegisterSap should perform any necessary allocations
    of dynamic resources and structures that the call manager needs to maintain
    state information about the SAP on behalf of the connection-oriented client.
    Such resources include, but are not limited to, memory buffers, data
    structures, events, and other such similar resources. A call manager must
    also initialize any resources it allocates before returning control to NDIS.
    Call managers must store the NDIS-supplied handle identifying the SAP,
    provided at NdisSapHandle, in their context area for future use.

    If ProtocolCmRegisterSap will return NDIS_STATUS_SUCCESS, it should, after
    allocating the per-SAP state area, set the address of this state area in
    CallMgrSapContext before returning control to NDIS. To do this, dereference
    CallMgrSapContext and store a pointer to the data area as the value of the
    handle. For example:

    *CallMgrSapContext = SomeBuffer;    // We use <t BCHANNEL_OBJECT>.

    If the given SAP that is already registered by another connection-oriented
    client, the call manager must fail the request and return
    NDIS_STATUS_INVALID_DATA.

    After a call manager has registered a SAP on behalf of a connection-oriented
    client, it notifies that client of an incoming call offer directed to that
    SAP by calling NdisCmDispatchIncomingCall.

    ProtocolCmRegisterSap must be written so that it can run at IRQL DISPATCH_LEVEL.

@rdesc

    ProtocolCmRegisterSap returns the status of its operation(s) as one of the
    following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager successfully allocated and/or initialized
    any necessary resources to register and maintain the SAP. In addition, it
    also indicates that the SAP was registered successfully as required by the
    network media that the call manager supports.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the call manager will complete the processing of this request
    asynchronously. Call managers must call NdisCmRegisterSapComplete when all
    processing has been completed to signal NDIS that the registration is
    finished.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the call manager was unable to allocated and/or initialize
    its resources required to register the SAP on behalf of the
    connection-oriented client.

@rvalue NDIS_STATUS_INVALID_DATA |

    Indicates that the specification provided at Sap is invalid or cannot be
    supported.

@rvalue NDIS_STATUS_XXX |

    Indicates that the call manager encountered an error in attempting to
    register the SAP for the connection-oriented client. The return code is
    appropriate to the error and could be a return code propagated from another
    NDIS library function.

@xref

    NdisCmDispatchIncomingCall, NdisCmRegisterSapComplete, NdisCoSendPackets,
    <f ProtocolCmDeregisterSap>, <f ProtocolCmOpenAf>
*/

NDIS_STATUS ProtocolCmRegisterSap(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f ProtocolCmOpenAf>.  AKA CallMgrAfContext.<nl>
    // Specifies the handle to a call-manager allocated context area in which
    // the call manager maintains its per-open AF state. The call manager
    // supplied this handle to NDIS from its ProtocolCmOpenAf function.

    IN PCO_SAP                  Sap,                        // @parm
    // Points to a media-specific CO_SAP structure that contains the specific
    // SAP that a connection-oriented client is registering.

    IN NDIS_HANDLE              NdisSapHandle,              // @parm
    // Specifies a handle, supplied by NDIS, that uniquely identifies this SAP.
    // This handle is opaque to the call manager and reserved for NDIS library
    // use.

    OUT PNDIS_HANDLE            CallMgrSapContext           // @parm
    // On return, specifies the handle to a call manager-supplied context area
    // in which the call manager maintains state about this SAP.  We will
    // return a pointer to the <t BCHANNEL_OBJECT> instance identified by this
    // SAP's lineID.
    )
{
    DBG_FUNC("ProtocolCmRegisterSap")

    PCO_AF_TAPI_SAP             pTapiSap = (PCO_AF_TAPI_SAP) Sap->Sap;

    PBCHANNEL_OBJECT            pBChannel;
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    if (pTapiSap->ulLineID < pAdapter->NumBChannels)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, pTapiSap->ulLineID);

        if (pBChannel->NdisSapHandle != NULL)
        {
            // A SAP has already been registered and it doesn't make any sense to
            // accept another since there are no SAP parameters to distinguish
            // them.
            DBG_ERROR(pAdapter, ("#%d Attempting to register SAP again!\n",
                      pBChannel->ObjectID));
            Result = NDIS_STATUS_SAP_IN_USE;
        }
        else
        {
            pBChannel->NdisSapHandle = NdisSapHandle;

            ASSERT(Sap->SapType == AF_TAPI_SAP_TYPE);
            ASSERT(Sap->SapLength == sizeof(CO_AF_TAPI_SAP));
            pBChannel->NdisTapiSap = *pTapiSap;

            DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                       ("#%d SAP=0x%X ulLineID=0x%X ulAddressID=0x%X ulMediaModes=0x%X\n",
                       pBChannel->ObjectID,
                       NdisSapHandle,
                       pBChannel->NdisTapiSap.ulLineID,
                       pBChannel->NdisTapiSap.ulAddressID,
                       pBChannel->NdisTapiSap.ulMediaModes
                       ));

            // If this BChannel is currently on the available list, move it
            // to the end of the list, so listening BChannels can be easily
            // allocated to incoming calls from the end of the list.
            NdisAcquireSpinLock(&pAdapter->EventLock);
            if (!IsListEmpty(&pBChannel->LinkList))
            {
                RemoveEntryList(&pBChannel->LinkList);
                InsertTailList(&pAdapter->BChannelAvailableList,
                               &pBChannel->LinkList);
            }
            NdisReleaseSpinLock(&pAdapter->EventLock);

            // Since we return NDIS_STATUS_PENDING here, we must call
            // NdisMCmRegisterSapComplete to complete this request.
            // TODO: If necessary, you can do the completion asynchronously.
            *CallMgrSapContext = pBChannel;
            CompleteCmRegisterSap(pBChannel, NDIS_STATUS_SUCCESS);
            Result = NDIS_STATUS_PENDING;
        }
    }
    else
    {
        DBG_ERROR(pAdapter, ("Attempting to register invalid SAP=%d\n",
                  pTapiSap->ulLineID));
        Result = NDIS_STATUS_INVALID_DATA;
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL CallMgr CallMgr_c CompleteCmDeregisterSap


@func

    <f CompleteCmDeregisterSap> is called when the miniport is done processing
    the <f ProtocolCmDeregisterSap> request.

@comm

    If you return NDIS_STATUS_PENDING from <f ProtocolCmDeregisterSap>, you
    must call <f CompleteCmDeregisterSap> so that
    <f NdisMCmDeregisterSapComplete> can be called to complete the request.
*/

VOID CompleteCmDeregisterSap(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_STATUS              Status                      // @parm
    // The NDIS status code to be passed to NdisMCmRegisterSapComplete.
    )
{
    DBG_FUNC("CompleteCmDeregisterSap")

    NDIS_HANDLE                 NdisSapHandle;

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    NdisSapHandle = pBChannel->NdisSapHandle;
    pBChannel->NdisSapHandle = NULL;

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
               ("#%d SAP=0x%X\n",
               pBChannel->ObjectID,
               NdisSapHandle
               ));

    NdisMCmDeregisterSapComplete(Status, NdisSapHandle);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmDeregisterSap


@func

    <f ProtocolCmDeregisterSap> is a required function that is called by NDIS
    to request that a call manager deregister a SAP on behalf of a
    connection-oriented client.

@comm

    ProtocolCmDeregisterSap communicates with network control devices or other
    media-specific agents, as necessary, to deregister the SAP on the network.
    Such actions could include, but are not limited to:

    Communicating with a switching hardware
    Communicating with a network control station
    Communicating with other media-specific network agents

    If a call manager is required to communicate with networking control agents,
    such as a network switch, it should use a virtual connection to the network
    control agent that it established in its ProtocolBindAdapter function.
    Standalone call managers communicate through the underlying NIC miniport by
    calling NdisCoSendPackets. NIC miniports that provide integrated
    call-management support never call NdisCoSendPackets. Instead, they transmit
    the data directly across the network.

    In addition, ProtocolCmDeregisterSap must free any dynamically-allocated
    resources in its per-SAP area, provided at CallMgrSapContext, as well as
    freeing the state area itself before returning control to NDIS.

    ProtocolCmDeregisterSap must be written such that it can be run at IRQL
    DISPATCH_LEVEL.

@rdesc

    ProtocolCmDeregisterSap returns the status of its operation(s) as one of the
    following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager successfully removed the SAP registration
    and freed any resources allocated to maintain per-SAP information.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the call manager will complete the request to deregister the
    SAP asynchronously. The call manager must call NdisCmDeregisterSapComplete
    to signal NDIS when the operation is complete.

@xref

    NdisCmDeregisterSapComplete, NdisCoSendPackets, ProtocolBindAdapter,
    <f ProtocolCmRegisterSap>
*/

NDIS_STATUS ProtocolCmDeregisterSap(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmRegisterSap>.  AKA CallMgrSapContext.<nl>
    // Specifies the handle to a call-manager allocated context area in which
    // the call manager maintains its per-SAP state information. The call
    // manager supplied this handle to NDIS from its ProtocolCmRegisterSap
    // function.
    )
{
    DBG_FUNC("ProtocolCmDeregisterSap")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    // Since we return NDIS_STATUS_PENDING here, we must call
    // NdisMCmDeregisterSapComplete to complete this request.
    // TODO: If necessary, you can do the completion asynchronously.
    CompleteCmDeregisterSap(pBChannel, NDIS_STATUS_SUCCESS);
    Result = NDIS_STATUS_PENDING;

    // If you return NDIS_STATUS_PENDING here, you must call
    // NdisMCmDeregisterSapComplete to complete this request.
    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL BChannel BChannel_c ProtocolCoCreateVc


@func

    <f ProtocolCoCreateVc> is a required function for connection-oriented
    miniports.  <f ProtocolCoCreateVc> is called by NDIS to indicate to
    the miniport that a new VC is being created.

@comm

    ProtocolCoCreateVc must be written as a synchronous function and cannot,
    under any circumstances, return NDIS_STATUS_PENDING without causing a
    system-wide failure.

    ProtocolCoCreateVc allocates any necessary resources that the miniport
    requires to maintain state information about the VC. The resources could
    include, but are not limited to memory buffers, events, data structures,
    and other such similar resources.

    After allocating all required resources the miniport should initialize the
    resources into a usable state and return a pointer to the state area in
    MiniportVcContext. The handle is set by dereferencing the handle and
    storing a pointer to the state buffer as the value of the handle. For
    example:

    *MiniportVcContext = SomeBuffer;    // We use <t BCHANNEL_OBJECT>.

    Miniport drivers must store the handle to the VC, NdisVcHandle, in their
    state area as it is a required parameter to other NDIS library routines
    that are subsequently called by the miniport.

    ProtocolCoCreateVc must be written such that it can be run at IRQL
    DISPATCH_LEVEL.

@rdesc

    Call managers or clients cannot return NDIS_STATUS_PENDING from their
    ProtocolCoCreateVc functions. Returning pending will render this virtual
    connection unusable and the NDIS library will call the client or call
    manager to delete it.

    ProtocolCoCreateVc returns the status of its operation(s) as one of the
    following values:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager or client successfully allocated and/or
    initialized any necessary resources that were needed to establish and
    maintain a virtual connection.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the call manager or client was unable to allocate and/or
    initialize its resources for establishing and maintaining a virtual
    connection.

@rvalue NDIS_STATUS_XXX |

    Indicates that the call manager or client could not set itself into a state
    where it could establish a virtual connection. This can could be an error
    return value propagated from another NDIS library routine.

@xref

    <f MiniportInitialize>, NdisMSetAttributes, NdisMSetAttributesEx,
    <f ProtocolCoDeleteVc>, <f MiniportCoActivateVc>, <f MiniportCoDeactivateVc>
*/

NDIS_STATUS ProtocolCoCreateVc(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.  AKA ProtocolAfContext.<nl>

    IN NDIS_HANDLE              NdisVcHandle,               // @parm
    // Specifies a handle, supplied by NDIS, that uniquely identifies
    // the VC being created.  This handle is opaque to the miniport
    // and reserved for NDIS library use.

    OUT PBCHANNEL_OBJECT *      ppBChannel                  // @parm
    // Specifies, on output, a handle to a miniport-supplied context
    // area in which the miniport maintains state about the VC.
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("ProtocolCoCreateVc")

    NDIS_STATUS                 Result = NDIS_STATUS_VC_NOT_AVAILABLE;
    // Holds the result code returned by this function.

    PBCHANNEL_OBJECT            pBChannel = NULL;
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    ASSERT(ppBChannel);

    DBG_ENTER(pAdapter);

    // Allocate BChannel for VC based on whether it's incoming or outgoing.
#if defined(SAMPLE_DRIVER)
    if (NdisVcHandle == NULL)
    {
        // The calling side has already removed the BChannel from the available
        // list, so we just need to use it.
        ASSERT(ppBChannel && *ppBChannel && (*ppBChannel)->ObjectType == BCHANNEL_OBJECT_TYPE);
        pBChannel = *ppBChannel;
    }
    else
    {
#endif // SAMPLE_DRIVER

    NdisAcquireSpinLock(&pAdapter->EventLock);
    if (!IsListEmpty(&pAdapter->BChannelAvailableList))
    {
        if (NdisVcHandle)
        {
            // Pull from the head of the available list, so we can avoid
            // using the BChannels that are setup with listening SAPs at
            // the end of the list.
            pBChannel = (PBCHANNEL_OBJECT) RemoveHeadList(
                                            &pAdapter->BChannelAvailableList);
            // Reset the link info so we can tell that it's not on the list.
            InitializeListHead(&pBChannel->LinkList);
        }
        else
        {
            // Pull from the tail of the available list, to see if there
            // are any listening SAPs that can accept this call.
            pBChannel = (PBCHANNEL_OBJECT) RemoveTailList(
                                            &pAdapter->BChannelAvailableList);
            // Reset the link info so we can tell that it's not on the list.
            InitializeListHead(&pBChannel->LinkList);
            if (pBChannel->NdisSapHandle)
            {
                // TODO: You should look to make sure the incoming call matches
                // the SAP of the listener.  The sample driver just assumes it.
            }
            else
            {
                // Sorry, no one up there wants to hear about it.
                InsertTailList(&pAdapter->BChannelAvailableList,
                               &pBChannel->LinkList);
                pBChannel = NULL;
            }
        }
    }
    NdisReleaseSpinLock(&pAdapter->EventLock);

#if defined(SAMPLE_DRIVER)
    }
#endif // SAMPLE_DRIVER

    if (pBChannel == NULL)
    {
        DBG_ERROR(pAdapter, ("BChannelAvailableList is empty\n"));
    }
    else if (BChannelOpen(pBChannel, NdisVcHandle) == NDIS_STATUS_SUCCESS)
    {
        Result = NDIS_STATUS_SUCCESS;
        DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                  ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
                   pBChannel->ObjectID,
                   pBChannel->NdisVcHandle, pBChannel->CallState,
                   Result
                  ));
    }
    else
    {
        // BChannel was already open - this should never happen...
        DBG_ERROR(pAdapter,("BChannelOpen failed, but it should be availble\n"));
        NdisAcquireSpinLock(&pAdapter->EventLock);
        if (NdisVcHandle)
        {
            // Put it back on the head of the available list.
            InsertHeadList(&pAdapter->BChannelAvailableList,
                           &pBChannel->LinkList);
        }
        else
        {
            // Put it back on the tail of the available list.
            InsertTailList(&pAdapter->BChannelAvailableList,
                           &pBChannel->LinkList);
        }
        NdisReleaseSpinLock(&pAdapter->EventLock);
        pBChannel = NULL;
    }
    *ppBChannel = pBChannel;

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL BChannel BChannel_c ProtocolCoDeleteVc


@func

    <f ProtocolCoDeleteVc> is a required function for connection-oriented
    miniports.  <f ProtocolCoDeleteVc> indicates that a VC is being torn
    down and deleted by NDIS.

@comm

    ProtocolCoDeleteVc must be written as a synchronous function and cannot,
    under any circumstances, return NDIS_STATUS_PENDING without causing a
    system-wide failure.

    ProtocolCoDeleteVc frees any resources allocated on a per-VC basis and
    stored in the context area MiniportVcContext. The miniport must also free
    the MiniportVcContext that is allocated in its ProtocolCoCreateVc
    function.

    <f ProtocolCoDeleteVc> must be written such that it can be run from IRQL
    DISPATCH_LEVEL.

@rdesc

    ProtocolCoDeleteVc can return one of the following:

@rvalue NDIS_STATUS_SUCCESS |

    The protocol has released or prepared for reuse all the resources that it
    originally allocated for the VC.

@rvalue NDIS_STATUS_NOT_ACCEPTED |

    The VC is still active and the protocol has outstanding operations pending
    on the VC so it could not be destroyed.

@rvalue NDIS_STATUS_XXX |

    The protocol failed the VC deletion for a driver-determined reason.

@xref

    NdisClCloseCall, NdisCmDispatchIncomingCloseCall, NdisCoCreateVc,
    NdisCoDeleteVc, <f ProtocolCoCreateVc>, <f MiniportCoActivateVc>,
    <f MiniportCoDeactivateVc>
*/

NDIS_STATUS ProtocolCoDeleteVc(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.  AKA ProtocolVcContext.<nl>
    // Specifies the handle to the client's or call manager's per-VC context
    // area. The protocol originally supplied this handle from its
    // <f ProtocolCoCreateVc> function.
    )
{
    DBG_FUNC("ProtocolCoDeleteVc")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState,
               Result
              ));

    BChannelClose(pBChannel);
    NdisAcquireSpinLock(&pAdapter->EventLock);
    if (pBChannel->NdisSapHandle)
    {
        // Listening BChannels are kept at the end of the list.
        InsertTailList(&pAdapter->BChannelAvailableList, &pBChannel->LinkList);
    }
    else
    {
        // Non-listening BChannels are kept at the end of the list.
        InsertHeadList(&pAdapter->BChannelAvailableList, &pBChannel->LinkList);
    }
    NdisReleaseSpinLock(&pAdapter->EventLock);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL Link Link_c MiniportCoActivateVc


@func

    <f MiniportCoActivateVc> is a required function for connection-oriented
    miniports.  <f MiniportCoActivateVc> is called by NDIS to indicate to the
    miniport that a virtual connection is being activated.

@comm

    The miniport driver must validate the call parameters for this VC, as
    specified in CallParameters, to verify that the adapter can support the
    requested call. If the requested call parameters cannot be satisfied, the
    miniport should fail the request with NDIS_STATUS_INVALID_DATA.

    MiniportCoActivateVc can be called many times for a single VC in order to
    change the call parameters for an already active call. At every call, the
    miniport should validate the parameters and perform any processing as
    required by its adapter in order to satisfy the request. However, if it
    cannot set the given call parameters, MiniportCoActivateVc must leave the
    VC in a usable state, because the connection-oriented client or a call
    manager can continue to send or receive data using the older call
    parameters.

    If the ROUND_UP_FLOW or ROUND_DOWN_FLOW flags are set in the call
    parameters structure at CallParameters-\>MediaParameters-\>Flags, the
    miniport has been requested to return the actual flow rate of the VC after
    the flow rate has been rounded according to the appropriate flag that has
    been set. If the miniport does change any of the call parameters because
    these flags have been set, it must return the actual call parameters in
    use for the VC at CallParameters.

    If the call parameters are acceptable, MiniportCoActivateVc communicates
    with its adapter as necessary to prepare the adapter to receive or
    transmit data across the virtual connection (e.g. programming receive
    buffers).

    MiniportCoActivateVc must be written so that it can be run from IRQL
    DISPATCH_LEVEL.

@rdesc

    MiniportCoActivateVc can return one of the following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the VC was activated successfully.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the miniport will complete the request to activate a VC
    asynchronously. When the miniport has finished with its operations, it must
    call NdisMCoActivateVcComplete.

@rvalue NDIS_STATUS_INVALID_DATA |

    Indicates that the call parameters specified at CallParameters are invalid
    or illegal for the media type that this miniport supports.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the miniport could not activate the VC because it could not
    allocate all of the required resources that the miniport needs to maintain
    state information about the active VC.

@xref

    <f ProtocolCoCreateVc>, <f MiniportCoDeactivateVc>, NdisMCoActivateVcComplete
*/

NDIS_STATUS MiniportCoActivateVc(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.  AKA MiniportVcContext.<nl>
    // Specifies the handle to a miniport-allocated context area in which the
    // miniport maintains its per-VC state. The miniport supplied this handle
    // to NDIS from its <f ProtocolCoCreateVc> function.

    IN OUT PCO_CALL_PARAMETERS  pCallParameters             // @parm
    // A pointer to the <t CO_CALL_PARAMETERS>
    // Specifies the call parameters, as specified by the call manager, to be
    // established for this VC. On output, the miniport returns altered call
    // parameters if certain flags are set in the CO_CALL_PARAMETERS structure.
    )
{
    DBG_FUNC("MiniportCoActivateVc")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO: Add code here if needed

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL Link Link_c MiniportCoDeactivateVc


@func

    <f MiniportCoDeactivateVc> is a required function for connection-oriented
    miniports.  <f MiniportCoDeactivateVc> is called by NDIS to indicate that
    a VC is being marked as unusable.

@comm

    MiniportCoDeactivateVc communicates with its network adapter to terminate
    all communication across this VC (e.g. deprogramming receive or send buffers
    on the adapter). The miniport should also mark the VC, it its context area,
    as being inactive to prevent any further communication across the VC.

    There is not a one-to-one relationship between calls to MiniportCoActivateVc
    and MiniportCoDeactivateVc. While NDIS may call MiniportCoActivateVc
    multiple times on a single VC, only one call to MiniportCoDeactivateVc is
    made to shut down a virtual connection. For example, a VC can be reused for
    different calls possibly causing multiple calls to MiniportCoActivateVc.

@rdesc

    MiniportCoDeactivateVc can return one of the following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the miniport successfully halted any communication across the
    VC and marked it as unusable.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the miniport will complete the request to halt the VC
    asynchronously. When the miniport has completed halting the VC, it must then
    call NdisMCoDeactivateVcComplete to signal NDIS that this operation has been
    completed.

@xref

    <f MiniportCoActivateVc>, NdisMCoDeactivateVcComplete
*/

NDIS_STATUS MiniportCoDeactivateVc(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.  AKA MiniportVcContext.<nl>
    // Specified the handle to a miniport-allocated context area in which the
    // miniport maintains state information per-VC. The miniport supplied this
    // handle to NDIS from its <f ProtocolCoCreateVc> function.

    )
{
    DBG_FUNC("MiniportCoDeactivateVc")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO: Add code here if needed

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL CallMgr CallMgr_c CompleteCmMakeCall


@func

    <f CompleteCmMakeCall> is called when the miniport is done processing the
    <f ProtocolCmMakeCall> request.

@comm

    If you return NDIS_STATUS_PENDING from <f ProtocolCmMakeCall>, you must
    call <f CompleteCmMakeCall> so that <f NdisMCmMakeCallComplete>
    can be called to complete the request.

    This routine also activates the VC and marks the call state as connected.
*/

VOID CompleteCmMakeCall(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_STATUS              Status                      // @parm
    // Status to return to <f NdisMCmMakeCallComplete>.  If status does not
    // equal NDIS_STATUS_SUCCESS, the call is closed and the BChannel is
    // released.
    )
{
    DBG_FUNC("CompleteCmMakeCall")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState,
               Status
              ));

    if (Status == NDIS_STATUS_SUCCESS)
    {
        pBChannel->pOutCallParms->CallMgrParameters->Receive.PeakBandwidth =
        pBChannel->pOutCallParms->CallMgrParameters->Transmit.PeakBandwidth =
                                                    pBChannel->LinkSpeed/8;

        Status = NdisMCmActivateVc(pBChannel->NdisVcHandle,
                                   pBChannel->pOutCallParms);
        if (Status == NDIS_STATUS_SUCCESS)
        {
            pBChannel->Flags |= VCF_VC_ACTIVE;
            pBChannel->CallState = LINECALLSTATE_CONNECTED;
        }
        else
        {
            DBG_ERROR(pAdapter,("NdisMCmActivateVc Error=0x%X\n",Status));
        }
    }
    NdisMCmMakeCallComplete(Status, pBChannel->NdisVcHandle,
                            NULL, NULL,
                            pBChannel->pOutCallParms);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        // The call failed, so cleanup and bail out.
        pBChannel->Flags &= ~VCF_OUTGOING_CALL;
    }

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmMakeCall


@func

    <f ProtocolCmMakeCall> is a required function that sets up media specific
    parameters for a virtual connection (VC) and activates the virtual
    connection.

@comm

    If ProtocolCmMakeCall is given an explicit NdisPartyHandle, this VC was
    created by the client for a multipoint call. The call manager must allocate
    and initialize any necessary resources required to maintain state
    information and control a multipoint call. Such resources include, but are
    not limited to, memory buffers, data structures, events, and other similar
    resources. If the call manager cannot allocate or initialize the needed
    resources for its state area(s), it should return control to NDIS with
    NDIS_STATUS_RESOURCES.

    ProtocolCmMakeCall communicates with network control devices or other
    media-specific actors, as necessary, to make a connection between the local
    node and a remote node based on the call parameters specified at
    CallParameters. Such actions could include, but are not limited to,
    communication with switching hardware, communications with a network control
    station, or other actions as appropriate to the network medium.

    If a call manager is required to communication with networking hardware
    (e.g. a networking switch) it should use a virtual connection to the network
    control device that it established in its ProtocolBindAdapter function. Call
    managers communicate with their network hardware through the miniport driver
    by calling NdisCoSendPackets. NIC miniports with integrated call-management
    support will not call NdisCoSendPackets, but rather will transmit the data
    themselves.

    After a call manager has done all necessary communication with its
    networking hardware as required by its medium, call managers must call
    NdisCmActivateVc.

    If this call was a multipoint call, after the call manager has communicated
    with the networking hardware, verified call parameters, and allocated and
    initialized its per-party state data, the address of its state block should
    be set in the handle CallMgrPartyContext before returning control to NDIS.
    The handle is set by dereferencing the handle and storing a pointer to the
    state block as the value of the handle. For example:

    *CallMgrPartyContext = SomeBuffer;  // We use NULL

    If ProtocolCmMakeCall has completed the required operations for its network
    and the VC has been successfully activated through NdisCmActivateVc,
    ProtocolCmMakeCall should return control as quickly as possible with a
    status of NDIS_STATUS_SUCCESS.

    After ProtocolCmMakeCall returns control to NDIS, the call manager should
    expect to take no further actions on this call to set it up.
    ProtocolCmMakeCall is responsible for establishing the connection so that
    the client can make data transfers over the network on this VC. However, the
    call manager can be called subsequently to modify the call's quality of
    service, to add or drop parties if this is a multipoint VC, and eventually
    to terminate this call.

    ProtocolCmMakeCall must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@rdesc

    <f ProtocolCmMakeCall> returns the status of its operation(s) as one of
    the following values:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager successfully allocated the necessary
    resources to make the call and was able to activate the virtual connection
    with the miniport driver.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the call manager will complete the request to make a call
    asynchronously. When the call manager has completed all operations for
    making a call, it must call NdisCmMakeCallComplete to signal NDIS that this
    call has been completed.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the call manager was unable to allocate and/or initialize its
    resources for activating the virtual connection as requested by the client.

@rvalue NDIS_STATUS_NOT_SUPPORTED |

    Indicates that the call manager was unable to activate a virtual connection
    because the caller requested invalid or unavailable features in the call
    parameters specified at CallParameters.

@xref

    NdisClMakeCall, NdisCmActivateVc, NdisCmMakeCallComplete,
    <f ProtocolCoCreateVc>
*/

NDIS_STATUS ProtocolCmMakeCall(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call managers maintains its per-VC state. The call manager supplied
    // this handle to NDIS from its ProtocolCoCreateVc function.

    IN OUT PCO_CALL_PARAMETERS  pCallParameters,            // @parm
    // Points to a CO_CALL_PARAMETERS structure that contains the parameters,
    // specified by a connection-oriented client, for this outgoing call.

    IN NDIS_HANDLE              NdisPartyHandle,            // @parm
    // Specifies a handle, supplied by NDIS, that uniquely identifies the
    // initial party on the multipoint virtual connection. This handle is
    // opaque to the call manager and reserved for NDIS library use. This
    // handle is NULL if the client is not setting up an outgoing multipoint
    // call.

    OUT PNDIS_HANDLE            CallMgrPartyContext         // @parm
    // On return, specifies a handle to a call manager-supplied context area in
    // which the call manager maintains state about the initial party on the
    // multipoint call. If NdisPartyHandle is NULL, this handle must be set to
    // NULL.
    )
{
    DBG_FUNC("ProtocolCmMakeCall")

    PCO_AF_TAPI_MAKE_CALL_PARAMETERS    pTapiCallParameters;
    // Points to the TAPI call parameters contained in pCallParameters.

    PLINE_CALL_PARAMS           pLineCallParams;
    // Points to the LINE call parameters contained in pTapiCallParameters.

    USHORT                      DialStringLength;
    // Length of the dial string in bytes.

    PUSHORT                     pDialString;
    // Points to the dial string contained in pTapiCallParameters.

    UCHAR                       DialString[CARD_MAX_DIAL_DIGITS+1];
    // Temporary copy of dial string.  One extra for NULL terminator.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    // Check a few preconditions ;)  Maybe the NDPROXY will change the rules
    // someday, and we'll have to change our assumptions...
    ASSERT(NdisPartyHandle == NULL);
    ASSERT(pCallParameters->Flags == 0);
    ASSERT(pCallParameters->CallMgrParameters);
    ASSERT(pCallParameters->CallMgrParameters->Transmit.TokenRate ==
           pBChannel->LinkSpeed/8);
    ASSERT(pCallParameters->CallMgrParameters->Receive.TokenRate ==
           pBChannel->LinkSpeed/8);
    ASSERT(pCallParameters->CallMgrParameters->CallMgrSpecific.ParamType == 0);
    ASSERT(pCallParameters->CallMgrParameters->CallMgrSpecific.Length == 0);
    ASSERT(pCallParameters->MediaParameters);
    ASSERT(pCallParameters->MediaParameters->Flags & TRANSMIT_VC);
    ASSERT(pCallParameters->MediaParameters->Flags & RECEIVE_VC);
    ASSERT(pCallParameters->MediaParameters->ReceiveSizeHint >=
           pAdapter->pCard->BufferSize);
    ASSERT(pCallParameters->MediaParameters->MediaSpecific.ParamType == 0);
    ASSERT(pCallParameters->MediaParameters->MediaSpecific.Length >=
           sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS));
    pTapiCallParameters = (PCO_AF_TAPI_MAKE_CALL_PARAMETERS)
                    pCallParameters->MediaParameters->MediaSpecific.Parameters;
    ASSERT(pTapiCallParameters->ulLineID < pAdapter->NumBChannels);
    ASSERT(pTapiCallParameters->ulAddressID == TSPI_ADDRESS_ID);
    ASSERT(pTapiCallParameters->ulFlags & CO_TAPI_FLAG_OUTGOING_CALL);
    ASSERT(pTapiCallParameters->DestAddress.Length > sizeof(USHORT));
    ASSERT(pTapiCallParameters->DestAddress.MaximumLength >=
           pTapiCallParameters->DestAddress.Length);
    ASSERT(pTapiCallParameters->DestAddress.Offset >=
           sizeof(NDIS_VAR_DATA_DESC));
    DialStringLength = pTapiCallParameters->DestAddress.Length;
    pDialString = (PUSHORT)
                        ((PUCHAR)&pTapiCallParameters->DestAddress +
                                  pTapiCallParameters->DestAddress.Offset);
    ASSERT(pTapiCallParameters->LineCallParams.Length >= sizeof(LINE_CALL_PARAMS));
    ASSERT(pTapiCallParameters->LineCallParams.MaximumLength >=
           pTapiCallParameters->LineCallParams.Length);
    ASSERT(pTapiCallParameters->LineCallParams.Offset >=
           sizeof(NDIS_VAR_DATA_DESC));

    pLineCallParams = (PLINE_CALL_PARAMS)
                        ((PUCHAR)&pTapiCallParameters->LineCallParams +
                                  pTapiCallParameters->LineCallParams.Offset);

    // This was useful for debugging the nested call parameter structures.
    DBG_NOTICE(pAdapter,(
                "\t\tsizeof(CO_CALL_PARAMETERS)                 =%03d\n"
                "\t\tsizeof(CO_CALL_MANAGER_PARAMETERS)         =%03d\n"
                "\t\tsizeof(CO_MEDIA_PARAMETERS)                =%03d\n"
                "\t\tsizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS)    =%03d\n"
                "\t\tsizeof(LINE_CALL_PARAMS)                   =%03d\n",
                "\t\tMaximumLength                              =%03d\n",
                sizeof(CO_CALL_PARAMETERS),
                sizeof(CO_CALL_MANAGER_PARAMETERS),
                sizeof(CO_MEDIA_PARAMETERS),
                sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS),
                sizeof(LINE_CALL_PARAMS),
                pTapiCallParameters->LineCallParams.MaximumLength
                ));

    /*
    // TODO: The sample driver doesn't support multi-party calls.
    */
    *CallMgrPartyContext = NULL;

    /*
    // Make sure the call parameters are valid for us.
    */
    if (pLineCallParams->ulBearerMode & ~pBChannel->BearerModesCaps)
    {
        DBG_WARNING(pAdapter, ("TAPI_INVALBEARERMODE=0x%X\n",
                    pLineCallParams->ulBearerMode));
        Result = NDIS_STATUS_NOT_SUPPORTED;
    }
    else if (pLineCallParams->ulMediaMode & ~pBChannel->MediaModesCaps)
    {
        DBG_WARNING(pAdapter, ("TAPI_INVALMEDIAMODE=0x%X\n",
                    pLineCallParams->ulMediaMode));
        Result = NDIS_STATUS_NOT_SUPPORTED;
    }
    else if (pLineCallParams->ulMinRate > _64KBPS ||
        pLineCallParams->ulMinRate > pLineCallParams->ulMaxRate)
    {
        DBG_WARNING(pAdapter, ("TAPI_INVALRATE=%d:%d\n",
                    pLineCallParams->ulMinRate,pLineCallParams->ulMaxRate));
        Result = NDIS_STATUS_NOT_SUPPORTED;
    }
    else if (pLineCallParams->ulMaxRate && pLineCallParams->ulMaxRate < _56KBPS)
    {
        DBG_WARNING(pAdapter, ("TAPI_INVALRATE=%d:%d\n",
                    pLineCallParams->ulMinRate,pLineCallParams->ulMaxRate));
        Result = NDIS_STATUS_NOT_SUPPORTED;
    }
    else if (DialStringLength == 0)
    {
        DBG_WARNING(pAdapter, ("TAPI_INVALPARAM=No dial string\n"));
        Result = NDIS_STATUS_NOT_SUPPORTED;
    }
    else
    {
        /*
        // Dial the number, but don't include the null terminator.
        */
        DialStringLength = CardCleanPhoneNumber(DialString,
                                                pDialString,
                                                DialStringLength);

        if (DialStringLength > 0)
        {
            /*
            // Save the call parameters.
            */
            pBChannel->MediaMode  = pLineCallParams->ulMediaMode;
            pBChannel->BearerMode = pLineCallParams->ulBearerMode;
            pBChannel->LinkSpeed  = pLineCallParams->ulMaxRate == 0 ?
                                    _64KBPS : pLineCallParams->ulMaxRate;
            pBChannel->pOutCallParms  = pCallParameters;

            DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                        ("#%d VC=0x%X CallState=0x%X DIALING: '%s'\n"
                         "\tLineID=%d - AddressID=%d - "
                         "Rate=%d-%d - MediaMode=0x%X - BearerMode=0x%X\n",
                        pBChannel->ObjectID,
                        pBChannel->NdisVcHandle, pBChannel->CallState,
                        DialString,
                        pTapiCallParameters->ulLineID,
                        pTapiCallParameters->ulAddressID,
                        pLineCallParams->ulMinRate,
                        pLineCallParams->ulMaxRate,
                        pLineCallParams->ulMediaMode,
                        pLineCallParams->ulBearerMode
                        ));

            // Now we're ready to tell the network about the call.
            Result = DChannelMakeCall(pAdapter->pDChannel,
                                      pBChannel,
                                      DialString,
                                      DialStringLength,
                                      pLineCallParams);

            if (Result != NDIS_STATUS_PENDING)
            {
                CompleteCmMakeCall(pBChannel, Result);
                Result = NDIS_STATUS_PENDING;
            }
        }
        else
        {
            DBG_WARNING(pAdapter, ("TAPI_INVALPARAM=Invalid dial string=%s\n",
                        pDialString));
            Result = NDIS_STATUS_NOT_SUPPORTED;
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL CallMgr CallMgr_c CompleteCmCloseCall


@func

    <f CompleteCmCloseCall> is called when the miniport is done processing the
    <f ProtocolCmCloseCall> request.

@comm

    If you return NDIS_STATUS_PENDING from <f ProtocolCmCloseCall>, you must
    call <f CompleteCmCloseCall> so that <f NdisMCmCloseCallComplete>
    can be called to complete the request.

    Upon return from this routine, you can no longer access the BChannel/VC
    as it has been deactivated and returned to the available pool.
*/

VOID CompleteCmCloseCall(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.

    IN NDIS_STATUS              Status                      // @parm
    // Status to return to <f NdisMCmCloseCallComplete>.  Regardless of the
    // status, the VC is deactivated and deleted.
    )
{
    DBG_FUNC("CompleteCmCloseCall")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState, Status
              ));

    // Deactivate the VC if needed.
    if (pBChannel->Flags & VCF_VC_ACTIVE)
    {
        pBChannel->Flags &= ~VCF_VC_ACTIVE;
        NdisMCmDeactivateVc(pBChannel->NdisVcHandle);
    }

    // Tell NDPROXY we're done.
    NdisMCmCloseCallComplete(Status, pBChannel->NdisVcHandle, NULL);

    // If it was an incoming call, it's up to us to delete the VC.
    if (pBChannel->Flags & VCF_INCOMING_CALL)
    {
        pBChannel->Flags &= ~VCF_INCOMING_CALL;
        if (pBChannel->NdisVcHandle)
        {
            NdisMCmDeleteVc(pBChannel->NdisVcHandle);
            pBChannel->NdisVcHandle = NULL;
            ProtocolCoDeleteVc((NDIS_HANDLE) pBChannel);
        }
    }
    else if (pBChannel->Flags & VCF_OUTGOING_CALL)
    {
        pBChannel->Flags &= ~VCF_OUTGOING_CALL;
    }

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmCloseCall


@func

    <f ProtocolCmCloseCall> is a required function that terminates an existing
    call and releases any resources that the call manager allocated for the
    call.

@comm

    ProtocolCmCloseCall communicated with network control devices or other
    media-specific actors, as necessitated by its media, to terminate a
    connection between the local node and a remote node. If the call manager is
    required to communicate with network control devices (e.g. a networking
    switch) it should use a virtual connection to the network control device
    that it established in its ProtocolBindAdapter function. Standalone call
    managers communicate to such network devices by calling NdisCoSendPackets.
    NIC miniports with integrated call-management support never call
    NdisCoSendPackets. Instead, they transmit the data directly across the
    network.

    If CloseData is nonNULL and sending data at connection termination is
    supported by the media that this call manager handles, the call manager
    should transmit the data specified at CloseData to the remote node before
    completing the call termination. If sending data concurrent with a
    connection being terminated is not supported, call managers should return
    NDIS_STATUS_INVALID_DATA.

    If ProtocolCmCloseCall is passed an explicit CallMgrPartyContext, then the
    call being terminated is a multipoint VC, and the call manager must perform
    any necessary network communication with its networking hardware, as
    appropriate to its media type, to terminate the call as a multipoint call.
    The call manager must also free the memory that it allocated earlier, in
    ProtocolCmMakeCall, for its per-party state that is pointed to by
    CallMgrPartyContext. Failure to properly release, de-allocate, or otherwise
    deactivate those resources causes a memory leak.

    After the call has been terminated with the network, any close data has been
    sent, and any resources at CallMgrPartyContext have been freed, the call
    manager must call NdisCmDeactivateVc. This notifies NDIS and the underlying
    NIC miniport, if any, to expect no further transfers on the given VC.

    ProtocolCmCloseCall must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@rdesc

    ProtocolCmCloseCall returns the status of its operation(s) as one of the
    following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager successfully terminated the call.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the call manager will complete the request to terminate the
    call asynchronously. When the call manager has completed all operations
    required to terminate the connection, it must then call
    NdisCmCloseCallComplete to signal NDIS that the call has been closed.

@rvalue NDIS_STATUS_INVALID_DATA |

    Indicates that CloseData was specified, but the underlying network medium
    does not support sending data concurrent with terminating a call.

@rvalue NDIS_STATUS_XXX |

    Indicates that the call manager could not terminate the call. The actual
    error returned can be a status propagated from another NDIS library routine.

@xref

    NdisClMakeCall, NdisCmDeactivateVc, NdisCoSendPackets,
    <f ProtocolCmMakeCall>
*/

NDIS_STATUS ProtocolCmCloseCall(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmMakeCall>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call manager maintains its per-VC state. This handle was provided to
    // NDIS from the call managers <f ProtocolCmMakeCall> function.

    IN NDIS_HANDLE              CallMgrPartyContext,        // @parm
    // Specifies the handle, if any, to a call manager-allocated context area
    // in which the call manager maintain information about a party on a
    // multipoint VC. This handle is NULL if the call being closed is not a
    // multipoint call.

    IN PVOID                    CloseData,                  // @parm
    // Points to a buffer containing connection-oriented client-specified data
    // that should be sent across the connection before the call is terminated.
    // This parameter is NULL if the underlying network medium does not support
    // transfers of data when closing a connection.

    IN UINT                     Size                        // @parm
    // Specifies the length, in bytes, of the buffer at CloseData, zero if
    // CloseData is NULL.
    )
{
    DBG_FUNC("ProtocolCmCloseCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState
              ));

    Result = DChannelCloseCall(pAdapter->pDChannel, pBChannel);
    if (Result != NDIS_STATUS_PENDING)
    {
        CompleteCmCloseCall(pBChannel, Result);
        Result = NDIS_STATUS_PENDING;
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmIncomingCallComplete


@func

    <f ProtocolCmIncomingCallComplete> is a required function that, when called
    by NDIS, indicates to the call manager that the connection-oriented client
    has finished processing of an incoming call offer that the call manager
    previously dispatched through NdisCmDispatchIncomingCall.

@comm

    When the connection-oriented client has completed processing of an incoming
    connection offer that the call manager dispatched to it, this routine will
    be called if NdisCmDispatchIncomingCall returned NDIS_STATUS_PENDING. The
    final status of the incoming call is found in Status. Possible values for
    Status include, but are not limited to:

@flag NDIS_STATUS_SUCCESS |

    Indicates that the call manager has accepted the incoming call.

@flag NDIS_STATUS_FAILURE |

    Indicates that either the address family or the SAP that the call dispatched
    for is currently in the process of closing.

@flag NDIS_STATUS_RESOURCES |

    Indicates that the incoming call was not accepted because the
    connection-oriented client was unable to dynamically allocate resources
    required for it to process the call.

@flag NDIS_STATUS_INVALID_DATA |

    Indicates that the connection-oriented client rejected the call because the
    call parameters specified were invalid.

@normal

    If the client accepts the incoming call, the call manager should send
    signaling message(s) to indicate to the calling entity that the call has
    been accepted. If the client does not accept the call, the call manager
    should send signaling message(s) to indicate that the call has been
    rejected.

    ProtocolCmIncomingCallComplete must be written so that is can be run at IRQL
    DISPATCH_LEVEL.

@xref

    NdisCmDispatchIncomingCall, ProtocolClIncomingCall, <f ProtocolCmRegisterSap>
*/

VOID ProtocolCmIncomingCallComplete(
    IN NDIS_STATUS              Status,                     // @parm
    // Indicates the final status of the operation to dispatch an incoming call
    // to a connection-oriented client.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmMakeCall>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call manager maintains its per-VC state. The call manager supplied
    // this handle from its <f ProtocolCoCreateVc> function.

    IN PCO_CALL_PARAMETERS      pCallParameters             // @parm
    // Points to the call parameters as specified by the call manager in the
    // call to NdisCmDispatchIncomingCall. The signaling protocol determines
    // which call parameters, if any, the call manager can change.
    )
{
    DBG_FUNC("ProtocolCmIncomingCallComplete")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState, Status
              ));

    if (Status != NDIS_STATUS_SUCCESS)
    {
        // We're not going to answer this call.
        DChannelRejectCall(pAdapter->pDChannel, pBChannel);

        if (pBChannel->Flags & VCF_VC_ACTIVE)
        {
            pBChannel->Flags &= ~VCF_VC_ACTIVE;
            NdisMCmDeactivateVc(pBChannel->NdisVcHandle);
        }

        if (pBChannel->NdisVcHandle)
        {
            NdisMCmDeleteVc(pBChannel->NdisVcHandle);
            pBChannel->NdisVcHandle = NULL;
            ProtocolCoDeleteVc((NDIS_HANDLE) pBChannel);
        }
    }
    else
    {
        Status = DChannelAnswerCall(pAdapter->pDChannel, pBChannel);
        if (Status == NDIS_STATUS_SUCCESS)
        {
            pBChannel->CallState = LINECALLSTATE_CONNECTED;
            NdisMCmDispatchCallConnected(pBChannel->NdisVcHandle);
        }
        else if (Status != NDIS_STATUS_PENDING)
        {
            InitiateCallTeardown(pAdapter, pBChannel);
        }
    }

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmActivateVcComplete


@func

    <f ProtocolCmActivateVcComplete> is a required function that indicates to
    the call manager that a previous call to NdisCoActivateVc has been completed
    by the miniport.

@comm

    When other network components have completed their operations for activating
    a virtual connection, initiated when the call manager called
    NdisCmActivateVc, NDIS notifies the call manager that the VC has been
    activated by calling its ProtocolCmActivateVcComplete function. The status
    of the activation is found in Status. Possible values for Status include,
    but are not limited to:

@flag NDIS_STATUS_SUCCESS |

    Indicates that the VC completed successfully and the call manager can
    continue operations on this VC as required by its media.

@flag NDIS_STATUS_RESOURCES |

    Indicates that another component in the activation has failed to activate
    the virtual connection because of a lack of memory or an inability allocate
    another type of resource.

@flag NDIS_STATUS_NOT_ACCEPTED |

    Indicates that an activation is currently pending on the virtual connection.
    Only one activation can be processed at a time for a virtual connection. The
    request to activate the VC should be tried again at a later time.

@flag NDIS_STATUS_CLOSING |

    Indicates that a deactivation is pending on the VC and the VC is no longer
    available for network communication until the deactivation has been
    completed and a successful activation has taken place.

@flag NDIS_STATUS_INVALID_DATA |

    Indicates that the miniport has rejected the call parameters at
    CallParamters as invalid for the adapter.

@normal

    ProtocolCmActivateVcComplete must check the status returned in Status to
    ensure that the virtual connection has been activated successfully. The call
    manager must not attempt to communicate over the virtual connection if
    Status is not NDIS_STATUS_SUCCESS.

    Call managers must complete any processing required by their network media
    to ensure that the virtual connection is ready for data transmission before
    returning control to NDIS.

    If the call manager specified either ROUND_UP_FLOW or ROUND_DOWN_FLOW in the
    CallParameters->MediaParamters->Flags, the call parameters returned in
    CallParamters can have been changed by the miniport. Call managers should
    examine the call parameters that were returned to ensure proper operation.
    If the new call parameters are unsatisfactory, the call manager should
    either call NdisCmActivateVc again with new call parameters or deactivate
    the VC with NdisCmDeactivateVc.

    ProtocolCmActivateVcComplete must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@xref

    NdisCmActivateVc, NdisCmDeactivateVc, <f ProtocolCmMakeCall>
*/

VOID ProtocolCmActivateVcComplete(
    IN NDIS_STATUS              Status,                     // @parm
    // Specifies the final status, as indicated by the miniport, of the request
    // by the call manager to activate a VC.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmMakeCall>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call manager maintains its per-VC state. The call manager supplied
    // this handle from its <f ProtocolCoCreateVc> function.

    IN PCO_CALL_PARAMETERS      pCallParameters             // @parm
    // Points the call parameters as specified by the call manager in a call to
    // NdisCmActivateVc.
    )
{
    DBG_FUNC("ProtocolCmActivateVcComplete")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState, Status
              ));

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmDeactivateVcComplete


@func

    <f ProtocolCmDeactivateVcComplete> is a required function that completes the
    processing of a call-manager initiated request that the underlying miniport
    (and NDIS) deactivate a VC for which NdisCmDeactivateVc previously returned
    NDIS_STATUS_PENDING.

@comm

    NDIS usually calls ProtocolCmDeactivateVcComplete in the context of the call
    manager's closing down a call on behalf of a connection-oriented client. The
    call manager typically calls NdisCmDeactivateVc from its ProtocolCmCloseCall
    function. Whenever NdisCmDeactivateVc returns NDIS_STATUS_PENDING, NDIS
    subsequently calls its ProtocolCmDeactivateVcComplete function.

    That is, when the underlying connection-oriented miniport has deactivated
    the VC, NDIS calls ProtocolCmDeactivateVcComplete. The final status of the
    deactivation is found in Status. Possible values for the final status
    include, but are not limited to:

@flag NDIS_STATUS_SUCCESS |

    Indicates that the VC was deactivated successfully.

@flag NDIS_STATUS_NOT_ACCEPTED |

    Indicates that an activation is pending on this VC. The call manager should
    attempt to deactivate the VC at a later time.

@flag NDIS_STATUS_CLOSING |

    Indicates that a deactivation is currently pending on this VC. The call
    manager need not call NdisCmDeactivateVc again as only one call to
    NdisCmDeactivateVc is required to deactivate a VC.

@normal

    ProtocolCmDeactivateVcComplete performs whatever postprocessing is necessary
    to complete the deactivation of a virtual connection, such as setting flags
    in its state area to indicate that the connection is inactive or releasing
    dynamically allocated resources used while the VC is active.

    Completion of the deactivation means that all call parameters for the VC
    used on activation are no longer valid. Any further use of the VC is
    prohibited except to reactivate it with a new set of call parameters.

    Call managers should release any resources that were allocated for the VC
    activation and return control as quickly as possible. If the call manager
    previously returned NDIS_STATUS_PENDING from its ProtocolCmCloseCall
    function and all operations to close the call have been completed,
    ProtocolCmDeactivateVcComplete should now call NdisCmCloseCallComplete.

    ProtocolCmDeactivateVcComplete must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@xref

    <f MiniportCoDeactivateVc>, NdisCmCloseCallComplete, NdisCmDeactivateVc,
    <f ProtocolCmCloseCall>
*/

VOID ProtocolCmDeactivateVcComplete(
    IN NDIS_STATUS              Status,                     // @parm
    // Specifies the final status of the deactivation.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmMakeCall>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call manager maintains its per-VC state. The call manager supplied
    // this handle from its <f ProtocolCoCreateVc> function.
    )
{
    DBG_FUNC("ProtocolCmDeactivateVcComplete")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState, Status
              ));

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmModifyCallQoS


@func

    <f ProtocolCmModifyCallQoS> is a required function that is called by NDIS
    when a connection-oriented client requests that the call parameters be
    changed for an existing virtual connection (VC). If the underlying network
    medium does not support QoS, ProtocolCmModifyQoS should simply return
    NDIS_STATUS_NOT_SUPPORTED.

@comm

    ProtocolCmModifyQoS communicates with network control devices or other
    media-specific agents, as necessitated by its media, to modify the
    media-specific call parameters for an established virtual connection. If the
    call manager is required to communicate with network control agents (e.g. a
    networking switch) it should use a virtual connection to the network control
    agents that it established in its ProtocolBindAdapter function. Standalone
    call managers communicated to the network agents by calling
    NdisCoSendPackets. NIC miniports with integrated call-management support
    never call NdisCoSendPackets. Instead, such a driver simply transfers the
    data over the network to the target network agent.

    After communicating with the network and if the changes were successful, the
    call manager must then call NdisCmActivateVc with the new call parameters.
    This notifies NDIS and/or the connection-oriented miniport that the call
    parameters have changed and provides the miniport with an opportunity to
    validate those parameters.

    If either the network cannot accept the new call parameters or the
    underlying miniport cannot accept the parameters, the call manager must
    restore the virtual connection to the state that existed before any
    modifications were attempted, and return NDIS_STATUS_FAILURE.

    ProtocolCmModifyQoSComplete must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@rdesc

    ProtocolCmModifyQoS returns the status of its operation(s) as one of the
    following values:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager successfully changed the parameters of the
    call with the network to the call parameters specified at CallParameters.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the call manager will complete the request to modify the call
    parameters asynchronously. When the call manager has completed all
    operations necessary to modify the call parameters, it must call
    NdisCmModifyCallQoSComplete.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the call manager could not change the call parameters of the
    VC because dynamically allocated resources were not available.

@rvalue NDIS_STATUS_INVALID_DATA |

    Indicates that the call manager was unable to change the call parameters of
    the VC because the call parameters provided at CallParameters were illegal
    or invalid.

@rvalue NDIS_STATUS_FAILURE |

    Indicates that the call parameters could not be set to the call parameters
    provided because of a failure in the network or in another
    connection-oriented network component.


@xref

    NdisCmActivateVc, NdisCmModifyCallQoSComplete, NdisCoSendPackets,
    <f ProtocolCoCreateVc>
*/

NDIS_STATUS ProtocolCmModifyCallQoS(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmMakeCall>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call manager maintains its per-VC state. The call manager supplied
    // this handle from its <f ProtocolCoCreateVc> function.

    IN PCO_CALL_PARAMETERS      pCallParameters             // @parm
    // Points to a CO_CALL_PARAMETERS structure that contains the new call
    // parameters, as specified by a connection-oriented client, for the VC.
    )
{
    DBG_FUNC("ProtocolCmModifyCallQoS")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState
              ));

    // What do you want to do with this request?
    DBG_ERROR(pAdapter, ("pCallParameters=0x%X\n", pCallParameters));

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCoRequest


@func

    <f ProtocolCoRequest> is a required function that handles OID_CO_XXX
    requests initiated by calls to NdisCoRequest from the corresponding
    client(s) or stand-alone call manager or initiated by an MCM driver's calls
    to NdisMCmRequest.

@comm

    Connection-oriented clients and stand-alone call managers communicate
    information to each other by specifying an explicit NdisAfHandle when they
    call NdisCoRequest. Similarly, a connection-oriented miniport with
    integrated call-management support calls NdisMCmRequest with explicit
    NdisAfHandles to communicate information to its individual clients. Such a
    call to NdisCoRequest or NdisMCmRequest with an explicit NdisAfHandle causes
    NDIS to call the ProtocolCoRequest function of the client, stand-alone call
    manager, or MCM driver that shares the given NdisAfHandle.

    If the input NdisVcHandle and NdisPartyHandle are NULL, ProtocolCoRequest
    can consider the request global in nature. For example, ProtocolCoRequest
    satisfies any OID_GEN_CO_XXX query for which it is passed only an explicit
    NdisAfHandle by returning information about all currently active VCs,
    including any active multipoint VCs, on the given address family.

    An explicit NdisVcHandle or NdisPartyHandle indicates that ProtocolCoRequest
    should satisfy the given request on a per-VC or per-party basis,
    respectively.

    ProtocolCoRequest can assume that the buffer at NdisRequest was allocated
    from nonpaged pool and is, therefore, accessible at raised IRQL. The caller
    of NdisCoRequest (or NdisMCmRequest) is responsible for releasing this
    buffer and the internal buffer at InformationBuffer that it allocated when
    its request has been completed.

    If ProtocolCoRequest returns NDIS_STATUS_PENDING, the driver must make a
    subsequent call to NdisCoRequestComplete or, for an MCM driver, to
    NdisMCmRequestComplete when the driver completes its operations to satisfy
    the given request.

    For more information about the sets of OIDs defined for use with
    NdisCoRequest, NdisMCmRequest, and NdisRequest, see Part 2 of this manual.

    ProtocolCoRequest must be written so that it can run at IRQL DISPATCH_LEVEL.

@rdesc

    ProtocolCoRequest can return one of the following:

@rvalue NDIS_STATUS_SUCCESS |

    The client or call manager carried out the requested operation.

@rvalue NDIS_STATUS_PENDING |

    The client or call manager is handling this request asynchronously, and it
    will call NdisCoRequestComplete (or, from a NIC miniport with integrated
    call-management support, NdisMCmRequestComplete) when the requested
    operation is done.

@rvalue NDIS_STATUS_INVALID_LENGTH or NDIS_STATUS_BUFFER_TOO_SHORT |

    The driver is failing this request because the caller of NdisCoRequest or
    NdisMCmRequest did not supply an adequate InformationBuffer for the given
    request. The driver set the BytesNeeded member in the buffer at NdisRequest
    to the Oid-specific value of the InformationBufferLength required to carry
    out the requested operation.

@rvalue NDIS_STATUS_XXX |

    The client or call manager failed the request for some driver-determined
    reason, such as invalid input data specified for a set.

@rvalue NDIS_STATUS_NOT_SUPPORTED |

    The client or call manager failed this request because it did not recognize
    the OID_GEN_CO_XXX code in the Oid member in the buffer at NdisRequest.

@xref

    NdisClOpenAddressFamily, NdisCoRequest, NdisCoRequestComplete,
    NdisMCmRequest, NdisMCmRequestComplete, NdisRequest, NDIS_REQUEST,
    ProtocolCmOpenAf, ProtocolCoRequestComplete

*/

NDIS_STATUS ProtocolCoRequest(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.  AKA ProtocolAfContext.<nl>
    // Specifies the handle to the driver's per-AF context area. The client
    // supplied this handle when it called NdisClOpenAddressFamily to connect
    // itself to the call manager. The call manager supplied this handle from
    // its <f ProtocolCmOpenAf> function, so this handle effectively identifies
    // the particular client that issued this request.

    IN PBCHANNEL_OBJECT         pBChannel OPTIONAL,         // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f BChannelCreate>.  AKA ProtocolVcContext.<nl>
    // Specifies the handle identifying the active VC for which the client or
    // call manager is requesting or setting information if the request is
    // VC-specific. Otherwise, this parameter is NULL.

    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL, // @parm
    // Specifies the handle identifying the party on a multipoint VC for which
    // the client or call manager is requesting or setting information if the
    // request is party-specific. Otherwise, this parameter is NULL.

    IN OUT PNDIS_REQUEST        NdisRequest
    // Points to a buffer, formatted as an NDIS_REQUEST structure specifying
    // the operation to be carried out by ProtocolCoRequest. The Oid member of
    // the NDIS_REQUEST structure contains the system-defined OID_GEN_CO_XXX
    // code specifying the requested query or set operation, together with a
    // buffer in which the protocol returns the requested information for a
    // query or from which it transfers the given information for a set.
    )
{
    DBG_FUNC("ProtocolCmRequest")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    // ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    Result = MiniportCoRequest(pAdapter, pBChannel, NdisRequest);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCoRequestComplete


@func

    <f ProtocolCoRequestComplete> is a required function that postprocesses the
    results of a connection-oriented client's or stand-alone call manager's call
    to NdisCoRequest or of an MCM driver's call to NdisMCmRequest.

@comm

    ProtocolCoRequestComplete can use the input Status as follows:

    If this argument is NDIS_STATUS_SUCCESS, the BytesRead or BytesWritten
    member of the NDIS_REQUEST structure has been set to specify how much data
    was transferred into or from the buffer at InformationBuffer.

    If the given OID_GEN_CO_XXX was a query, ProtocolCoRequestComplete can use
    the data returned at InformationBuffer in any driver-determined way,
    depending on the value of the Oid member.

    ProtocolCoRequestComplete is responsible for releasing the driver-allocated
    buffers at NdisRequest and InformationBuffer when the driver completes its
    postprocessing of this request.

    If this argument is NDIS_STATUS_INVALID_LENGTH or
    NDIS_STATUS_BUFFER_TOO_SHORT, the BytesNeeded member specifies the
    Oid-specific value of the InformationBufferLength required to carry out the
    requested operation.

    In these circumstances, ProtocolCoRequestComplete can allocate sufficient
    buffer space for the request, set up another NDIS_REQUEST structure with the
    required InformationBufferLength and the same Oid value, and retry the
    driver's call to NdisCoRequest or NdisMCmRequest.

    If this argument is an NDIS_STATUS_XXX that indicates an unrecoverable
    error, ProtocolCoRequestComplete should release the buffer at NdisRequest
    and carry out any driver-determined operations that are necessary. For
    example, ProtocolCoRequestComplete might tear down the driver-created VC if
    a returned error status indicates that the driver cannot continue to make
    transfers on the virtual connection.

    Even if a driver's call to NdisCoRequest or NdisMCmRequest returns something
    other than NDIS_STATUS_PENDING, that driver should use its
    ProtocolCoRequestComplete function to postprocess completed requests. Making
    an internal call to the driver's own ProtocolCoRequestComplete function on
    return from NdisCoRequest or NdisMCmRequest has almost no adverse effect on
    the driver's performance, makes the driver's image smaller, and makes the
    driver easier to maintain from one OS release to the next since such a
    driver has no duplicate code doing status-return checking on
    driver-initiated requests.

    For more information about the sets of OIDs defined for use with
    NdisCoRequest and NdisMCmRequest, see Part 2 of this manual.

    ProtocolCoRequestComplete must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@xref

    NdisCoRequest, NdisCoRequestComplete, NdisMCmRequest,
    NdisMCmRequestComplete, NDIS_REQUEST, <f ProtocolCoRequest>

*/

VOID ProtocolCoRequestComplete(
    IN NDIS_STATUS              Status,                     // @parm
    // Specifies the final status of the driver-initiated request, either
    // NDIS_STATUS_SUCCESS or a failure NDIS_STATUS_XXX that was set by the
    // corresponding client or call manager that handled this request. This
    // parameter is never NDIS_STATUS_PENDING.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.  AKA ProtocolAfContext.<nl>
    // Specifies the handle to the driver's per-AF context area. The client
    // supplied this handle when it called NdisClOpenAddressFamily to connect
    // itself to the call manager. The call manager supplied this handle from
    // its ProtocolCmOpenAf function, so this handle effectively identifies the
    // particular client to which this request was directed.

    IN PBCHANNEL_OBJECT         pBChannel OPTIONAL,         // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f BChannelCreate>.  AKA ProtocolVcContext.<nl>
    // Specifies the handle identifying the active VC for which the client or
    // call manager was requesting or setting information if the request was
    // VC-specific. Otherwise, this parameter is NULL.

    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL, // @parm
    // Specifies the handle identifying the party on a multipoint VC for which
    // the client or call manager was requesting or setting information if the
    // request is party-specific. Otherwise, this parameter is NULL.

    IN PNDIS_REQUEST            NdisRequest                 // @parm
    // Points to the driver-allocated buffer, formatted as an NDIS_REQUEST
    // structure that the driver passed in a preceding call to NdisCoRequest or
    // NdisMCmRequest. The Oid member of the NDIS_REQUEST structure contains
    // the system-defined OID_GEN_CO_XXX code specifying the requested query or
    // set operation, together with a buffer in which the corresponding client
    // or call manager returned the requested information for a query or from
    // which it transferred the given information for a set if Status is
    // NDIS_STATUS_SUCCESS.
    )
{
    DBG_FUNC("ProtocolCmRequestComplete")

    // ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState, Status
              ));

    // MCM's don't typically need this, since there's nothing below...

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL CallMgr CallMgr_c AllocateIncomingCallParameters


@func

    <f AllocateIncomingCallParameters> is called by <f SetupIncomingCall>
    when getting ready to indicate an incoming call up to NDPROXY.

@comm

    AllocateIncomingCallParameters allocates memory for the incoming call
    parameters <t PCO_CALL_PARAMETERS>.  The memory is only allocated the
    first time a call comes in on a particular BChannel.  After that, the
    same structure is reused for each incoming call on that BChannel.

    The structure is defined by NDPROXY, CONDIS, and TAPI so it includes
    all the necessary media specific parameters.  The data structures are
    allocated and laid out end to end in the following format:

    <tab> sizeof(CO_CALL_PARAMETERS)<nl>
    <tab> sizeof(CO_CALL_MANAGER_PARAMETERS)<nl>
    <tab> sizeof(CO_MEDIA_PARAMETERS)<nl>
    <tab> sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)<nl>
    <tab> sizeof(LINE_CALL_INFO)<nl>

    The call parameters for the sample driver are hard coded, but you should
    fill in the correct information from incoming call request.

*/

PCO_CALL_PARAMETERS AllocateIncomingCallParameters(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.
    )
{
    DBG_FUNC("AllocateIncomingCallParameters")

    PCO_CALL_PARAMETERS         pCp;
    PCO_CALL_MANAGER_PARAMETERS pCmp;
    PCO_MEDIA_PARAMETERS        pMp;
    PCO_AF_TAPI_INCOMING_CALL_PARAMETERS pTcp;
    PLINE_CALL_INFO             pLci;

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pBChannel->NdisTapiSap.ulMediaModes & LINEMEDIAMODE_DIGITALDATA);
    pBChannel->MediaMode  = LINEMEDIAMODE_DIGITALDATA;
    pBChannel->BearerMode = LINEBEARERMODE_DATA;
    pBChannel->LinkSpeed  = _64KBPS;

    if (pBChannel->pInCallParms != NULL)
    {
        // Already allocated call parameters for this channel.
        return (pBChannel->pInCallParms);
    }

    pBChannel->CallParmsSize = sizeof(CO_CALL_PARAMETERS)
                             + sizeof(CO_CALL_MANAGER_PARAMETERS)
                             + sizeof(CO_MEDIA_PARAMETERS)
                             + sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)
                             + sizeof(LINE_CALL_INFO);

    ALLOCATE_MEMORY(pBChannel->pInCallParms,
                    pBChannel->CallParmsSize,
                    pAdapter->MiniportAdapterHandle);

    if (pBChannel->pInCallParms == NULL)
    {
        return (pBChannel->pInCallParms);
    }

    NdisZeroMemory(pBChannel->pInCallParms, pBChannel->CallParmsSize);

    DBG_NOTICE(pAdapter,(
                "\n"
                "\t\tsizeof(CO_CALL_PARAMETERS)                 =%03d\n"
                "\t\tsizeof(CO_CALL_MANAGER_PARAMETERS)         =%03d\n"
                "\t\tsizeof(CO_MEDIA_PARAMETERS)                =%03d\n"
                "\t\tsizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)=%03d\n"
                "\t\tsizeof(LINE_CALL_INFO)                     =%03d\n"
                "\t\tTotal                                      =%03d\n",
                sizeof(CO_CALL_PARAMETERS),
                sizeof(CO_CALL_MANAGER_PARAMETERS),
                sizeof(CO_MEDIA_PARAMETERS),
                sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS),
                sizeof(LINE_CALL_INFO),
                pBChannel->CallParmsSize
                ));
    pCp  = (PCO_CALL_PARAMETERS)        pBChannel->pInCallParms;
    pCmp = (PCO_CALL_MANAGER_PARAMETERS)(pCp + 1);
    pMp  = (PCO_MEDIA_PARAMETERS)       (pCmp + 1);
    pTcp = (PCO_AF_TAPI_INCOMING_CALL_PARAMETERS)
                                        pMp->MediaSpecific.Parameters;
    pLci = (PLINE_CALL_INFO)            (pTcp + 1);

    // TODO: Fill in the call parameters as needed.

    pCp->Flags                          = PERMANENT_VC;
    pCp->CallMgrParameters              = pCmp;
    pCp->MediaParameters                = pMp;

    pCmp->Transmit.TokenRate            = pBChannel->LinkSpeed / 8;
    pCmp->Transmit.TokenBucketSize      = pAdapter->pCard->BufferSize;
    pCmp->Transmit.PeakBandwidth        = pBChannel->LinkSpeed / 8;
    pCmp->Transmit.Latency              = 0;
    pCmp->Transmit.DelayVariation       = 0;
    pCmp->Transmit.ServiceType          = SERVICETYPE_BESTEFFORT;
    pCmp->Transmit.MaxSduSize           = pAdapter->pCard->BufferSize;
    pCmp->Transmit.MinimumPolicedSize   = 0;
    pCmp->Receive                       = pCmp->Transmit;
    pCmp->CallMgrSpecific.ParamType     = 0;
    pCmp->CallMgrSpecific.Length        = 0;

    pMp->Flags                          = TRANSMIT_VC | RECEIVE_VC;
    pMp->ReceiveSizeHint                = pAdapter->pCard->BufferSize;
    pMp->MediaSpecific.ParamType        = 0;
    pMp->MediaSpecific.Length           = sizeof(*pTcp) + sizeof(*pLci);

    pTcp->ulLineID                      = pBChannel->NdisTapiSap.ulLineID;
    pTcp->ulAddressID                   = TSPI_ADDRESS_ID;
    pTcp->ulFlags                       = CO_TAPI_FLAG_INCOMING_CALL;
    pTcp->LineCallInfo.Length           = sizeof(*pLci);
    pTcp->LineCallInfo.MaximumLength    = sizeof(*pLci);
    pTcp->LineCallInfo.Offset           = sizeof(NDIS_VAR_DATA_DESC);

    pLci->ulTotalSize =
    pLci->ulNeededSize =
    pLci->ulUsedSize = sizeof(*pLci);

    /*
    // The link has all the call information we need to return.
    */
    pLci->hLine = (ULONG) (ULONG_PTR) pBChannel;
    pLci->ulLineDeviceID = pTcp->ulLineID;
    pLci->ulAddressID = pTcp->ulAddressID;

    pLci->ulBearerMode = pBChannel->BearerMode;
    pLci->ulRate = pBChannel->LinkSpeed;
    pLci->ulMediaMode = pBChannel->MediaMode;

    pLci->ulCallParamFlags = LINECALLPARAMFLAGS_IDLE;
    pLci->ulCallStates = pBChannel->CallStatesCaps;

    /*
    // We don't support any of the callerid functions.
    */
    pLci->ulCallerIDFlags =
    pLci->ulCalledIDFlags =
    pLci->ulConnectedIDFlags =
    pLci->ulRedirectionIDFlags =
    pLci->ulRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;

    DBG_RETURN(pAdapter, pBChannel->pInCallParms);
    return (pBChannel->pInCallParms);
}


/* @doc INTERNAL CallMgr CallMgr_c SetupIncomingCall


@func

    <f SetupIncomingCall> is called by the card level DPC routine when it
    detects an incoming call from the network.

@comm

    Before calling this routine, the caller should save information about
    the call so it can be used by <f AllocateIncomingCallParameters> to
    setup the incoming call parameters for NDPROXY.

@rdesc

    <f SetupIncomingCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS SetupIncomingCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.

    OUT PBCHANNEL_OBJECT *      ppBChannel                  // @parm
    // Specifies, on output, a pointer to the <t BCHANNEL_OBJECT> instance
    // returned by <f ProtocolCoCreateVc> that is to be associated with this
    // incoming call.
    )
{
    DBG_FUNC("SetupIncomingCall")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    PCO_CALL_PARAMETERS         pCallParams;
    // Pointer to the incoming call parameters.

    PBCHANNEL_OBJECT            pBChannel;

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    // See if there's a VC availble for this call.
    Result = ProtocolCoCreateVc(pAdapter, NULL, ppBChannel);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        goto exit;
    }

    // Save the VC info and allocate the call parameters.
    pBChannel = *ppBChannel;
    pBChannel->Flags |= VCF_INCOMING_CALL;
    pCallParams = AllocateIncomingCallParameters(pBChannel);

    // Make sure we have the parameters
    if (pCallParams == NULL)
    {
        Result = NDIS_STATUS_RESOURCES;
        goto error2;
    }

    // Tell NDPROXY to create a VC for this call.
    Result = NdisMCmCreateVc(pAdapter->MiniportAdapterHandle,
                             pAdapter->NdisAfHandle,
                             pBChannel,
                             &pBChannel->NdisVcHandle);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(pAdapter, ("NdisMCmCreateVc Status=0x%X\n", Result));
        goto error2;
    }

    // Tell NDPROXY to activate the VC.
    Result = NdisMCmActivateVc(pBChannel->NdisVcHandle, pCallParams);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(pAdapter, ("NdisMCmActivateVc Status=0x%X\n", Result));
        goto error3;
    }

    // Mark the VC as active and update the call state.
    pBChannel->Flags |= VCF_VC_ACTIVE;
    pBChannel->CallState = LINECALLSTATE_OFFERING;

    DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
              ("#%d VC=0x%X AF=0x%X SAP=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle,
               pAdapter->NdisAfHandle, pBChannel->NdisSapHandle
              ));

    // Tell NDPROXY to dispatch the call to the TAPI clients.
    Result = NdisMCmDispatchIncomingCall(pBChannel->NdisSapHandle,
                                         pBChannel->NdisVcHandle,
                                         pCallParams);
    switch (Result)
    {
        case NDIS_STATUS_SUCCESS:
            DBG_NOTICE(pAdapter,("NdisMCmDispatchIncomingCall completed synchronously\n"));
            ProtocolCmIncomingCallComplete(Result, pBChannel, NULL);
            goto exit;

        case NDIS_STATUS_PENDING:
            DBG_NOTICE(pAdapter,("NdisMCmDispatchIncomingCall returned pending\n"));
            // Let ProtocolCmIncomingCallComplete deal with it now.
            goto exit;
    }

    // BUMMER - There must be a problem with NDPRROXY...
    DBG_ERROR(pAdapter, ("NdisMCmDispatchIncomingCall Status=0x%X\n", Result));

    pBChannel->CallState = LINECALLSTATE_IDLE;
    if (pBChannel->Flags & VCF_VC_ACTIVE)
    {
        pBChannel->Flags &= ~VCF_VC_ACTIVE;
        NdisMCmDeactivateVc(pBChannel->NdisVcHandle);
    }

error3:
    if (pBChannel->NdisVcHandle)
    {
        NdisMCmDeleteVc(pBChannel->NdisVcHandle);
        pBChannel->NdisVcHandle = NULL;
    }

error2:
    ProtocolCoDeleteVc((NDIS_HANDLE) pBChannel);

exit:

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL CallMgr CallMgr_c InitiateCallTeardown


@func

    <f InitiateCallTeardown> is called by the card level DPC routine when it
    detects a call disconnect from the network.

@comm

    The disconnect here is coming from the telephone network rather than from
    NDIS.  This can be called on either an incoming call or an outgoing call
    when the miniport has determined that the link has been lost to the remote
    endpoint.

*/

VOID InitiateCallTeardown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.
    )
{
    DBG_FUNC("InitiateCallTeardown")

    NDIS_STATUS                 Status;

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    if (pBChannel->Flags & VCF_VC_ACTIVE)
    {
        // Normal teardown.
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        // Call never fully established.
        Status = NDIS_STATUS_FAILURE;
    }
    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState,
               Status
              ));

    pBChannel->CallState = LINECALLSTATE_DISCONNECTED;

    // Make sure there are no packets left on this channel before it closes.
    FlushSendPackets(pAdapter, pBChannel);

    // Notify NDPROXY that the call's connection has been lost.
    NdisMCmDispatchIncomingCloseCall(Status,
                                     pBChannel->NdisVcHandle,
                                     NULL, 0);

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\port.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Port Port_h

@module Port.h |

    This module defines the interface to the <t PORT_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Port_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 4.5 Port Overview |

    This section describes the interfaces defined in <f Port\.h>.

    The sample does not use this interface, but it is anticipated that it would
    be used to maintain information associated with each physical ISDN line.
    Assuming that each card may have multiple ISDN lines plugged into it.
    
*/

#ifndef _PORT_H
#define _PORT_H

#define PORT_OBJECT_TYPE        ((ULONG)'P')+\
                                ((ULONG)'O'<<8)+\
                                ((ULONG)'R'<<16)+\
                                ((ULONG)'T'<<24)

#define MAX_PORTS               10
// The most I've ever seen is 4 - If you have more than 10, the code will
// have to change to handle more than a single digit "PortX" parameter.

/* @doc INTERNAL Port Port_h PORT_OBJECT


@struct PORT_OBJECT |

    This structure contains the data associated with an ISDN port.  Here,
    a port is defined as a single BRI, PRI, T-1, or E-1 physical interface.

*/

typedef struct PORT_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'PORT'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PCARD_OBJECT                pCard;                      // @field
    // Pointer to the <t CARD_OBJECT> owning this port.

    BOOLEAN                     IsOpen;                     // @field
    // Set TRUE if this BChannel is open, otherwise set FALSE.

    ULONG                       NumChannels;                // @field
    // Number of communications channels configured on this port.

    ULONG                       PortIndex;                  // @field
    // Port Index (0 .. MAX_PORTS-1).

    ULONG                       SwitchType;                 // @field
    // ISDN switch type.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} PORT_OBJECT, *PPORT_OBJECT;

#define GET_ADAPTER_FROM_PORT(pPort)            (pPort->pCard->pAdapter)


/*


    Function prototypes.

*/

NDIS_STATUS PortCreate(
    OUT PPORT_OBJECT *          ppPort,
    IN PCARD_OBJECT             pCard
    );

void PortInitialize(
    PPORT_OBJECT                pPort
    );

void PortDestroy(
    PPORT_OBJECT                pPort
    );

#endif // _PORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\receive.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Receive Receive_c

@module Receive.c |

    This module implements the Miniport packet receive routines.  Basically,
    the asynchronous receive processing routine.  This module is very
    dependent on the hardware/firmware interface and should be looked at
    whenever changes to these interfaces occur.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Receive_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.4 Receiving Packets |

    A connection-oriented miniport or MCM calls NdisMCoIndicateReceivePacket to
    indicate one or more received packets up to a connection-oriented client or
    call manager. If the miniport or MCM handles interrupts, it calls
    NdisMCoIndicateReceivePacket from its MiniportHandleInterrupt function.

@ex Receiving packets through an MCM |

    Miniport                          NDIS                         NdisWan
    |----------------------------------|----------------------------------|
    |  NdisMCoIndicateReceivePacket    |                                  |
    |---------------------------------|                                  |
    |                                  |  ProtocolCoReceivePacket         |
    |                                  |---------------------------------|
    |  NdisMCoIndicateReceivePacket    |                                  |
    |---------------------------------|                                  |
    |              .                   |  ProtocolCoReceivePacket         |
    |              .                   |---------------------------------|
    |              .                   |            .                     |
    |                                  |            .                     |
    |  NdisMCoReceiveComplete          |            .                     |
    |---------------------------------|                                  |
    |                                  |  ProtocolReceiveComplete         |
    |                                  |---------------------------------|
    |                                  |                                  |
    |                                  |  NdisReturnPackets               |
    |                                  |---------------------------------|
    |  MiniportReturnPacket            |            .                     |
    |---------------------------------|            .                     |
    |  MiniportReturnPacket            |            .                     |
    |---------------------------------|                                  |
    |              .                   |                                  |
    |              .                   |                                  |
    |              .                   |                                  |
    |----------------------------------|----------------------------------|

@normal

    In the call to NdisMCoIndicateReceivePacket, the miniport or MCM passes a
    pointer to an array of packet descriptor pointers. The miniport or MCM also
    passes an NdisVcHandle that identifies the VC on which the packets were
    received. Before calling NdisMCoIndicateReceivePacket, the miniport or MCM
    must set up a packet array (see Part 2, Section 4.6). 

    The call to NdisMCoIndicateReceivePacket causes NDIS to call the
    ProtocolCoReceivePacket function of the protocol driver (connection-oriented
    client or call manager) that shares the indicated VC with the miniport. The
    ProtocolCoReceivePacket function processes the receive indication.

    After some miniport-determined number of calls to
    NdisMCoIndicateReceivePacket, the miniport must call NdisMCoReceiveComplete
    to indicate the completion of the previous receive indications made with one
    or more calls to NdisMCoIndicateReceivePacket. The call to
    NdisMCoReceiveComplete causes NDIS to call the ProtocolReceiveComplete
    function of the connection-oriented client or call manager.

    If a protocol does not return the miniport-allocated resources for a receive
    indication promptly enough, the miniport or MCM can call
    NdisMCoIndicateStatus with NDIS_STATUS_RESOURCES to alert the offending
    protocol that the miniport or MCM is running low on available packet or
    buffer descriptors (or even on NIC receive buffer space) for subsequent
    receive indications.

@end
*/

#define  __FILEID__             RECEIVE_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Receive Receive_c ReceivePacketHandler


@func

    <f ReceivePacketHandler> is called from <f MiniportTimer> to handle
    a packet receive event.  We enter here with interrupts enabled on
    the adapter and the processor, but the NDIS Wrapper holds a spin lock
    since we are executing on an NDIS timer thread.

@comm

    We loop in here until all the available incoming packets have been passed
    up to the protocol stack.  As we find each good packet, it is passed up
    to the protocol stack using <f NdisMWanIndicateReceive>.  When NDIS
    returns control from this call, we resubmit the packet to the adapter
    so it can be used to receive another incoming packet.  The link flag
    <p NeedReceiveCompleteIndication> is set TRUE if any packets are received
    on a particular link.  This is used later, before returning from the
    async event handler, to notify NDIS of any ReceiveCompleteIndications.

*/

void ReceivePacketHandler(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    IN PNDIS_BUFFER             pNdisBuffer,                // @parm
    // A pointer to the NDIS buffer we use to indicate the receive.

    IN ULONG                    BytesReceived               // @parm
    // Number of bytes received.
    )
{
    DBG_FUNC("ReceivePacketHandler")

    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;

    PUCHAR                      ReceiveBuffer;
    // Pointer to first byte received.

    ULONG                       BufferLength;
    // Length of first buffer.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    PNDIS_PACKET                pNdisPacket;
    // A pointer to the NDIS packet we use to indicate the receive.


    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);
    ASSERT(pNdisBuffer);

    DBG_ENTER(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (++(pAdapter->NestedDataHandler) > 1)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d > 1\n",
                  pAdapter->NestedDataHandler));
    }

    NdisQueryBufferSafe(pNdisBuffer, &ReceiveBuffer, &BufferLength,
                        NormalPagePriority);
    ASSERT(ReceiveBuffer && BufferLength);

    /*
    // Is there someone up there who cares?
    */
    if (pBChannel->NdisVcHandle == NULL)
    {
        DBG_WARNING(pAdapter, ("Packet recvd on disconnected channel #%d\n",pBChannel->ObjectID));

        FREE_MEMORY(ReceiveBuffer, BufferLength);
        NdisFreeBuffer(pNdisBuffer);
    }
    else
    {
        pAdapter->TotalRxBytes += BytesReceived;
        pAdapter->TotalRxPackets++;

        /*
        // We have to accept the frame if possible, I just want to know
        // if somebody has lied to us...
        */
        if (BytesReceived > pBChannel->WanLinkInfo.MaxRecvFrameSize)
        {
            DBG_NOTICE(pAdapter,("Packet size=%d > %d\n",
                       BytesReceived, pBChannel->WanLinkInfo.MaxRecvFrameSize));
        }

        DBG_RX(pAdapter, pBChannel->ObjectID, BufferLength, ReceiveBuffer);

        /*
        // Indiciate the packet up to the protocol stack.
        */
        NdisAllocatePacket(&Status, &pNdisPacket, 
                           pAdapter->pCard->PacketPoolHandle);
        if (Status == NDIS_STATUS_SUCCESS)
        {
            NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
            NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_SUCCESS);
            NDIS_SET_PACKET_HEADER_SIZE(pNdisPacket, 0);
            NdisMCoIndicateReceivePacket(
                    pBChannel->NdisVcHandle,
                    &pNdisPacket,   // PacketArray
                    1               // NumberOfPackets
                    );
            pBChannel->NeedReceiveCompleteIndication = TRUE;
        }
        else
        {
            DBG_ERROR(pAdapter,("NdisAllocatePacket Error=0x%X\n",Status));
        }
    }

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (--(pAdapter->NestedDataHandler) < 0)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d < 0\n",
                  pAdapter->NestedDataHandler));
    }

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL Receive Receive_c MiniportReturnPacket


@func

    <f MiniportReturnPacket> is a required function in drivers that
    indicate receives with NdisMIndicateReceivePacket.

@comm

    A miniport driver of a busmaster DMA NIC that supports multipacket
    receives and a miniport driver that supplies media-specific information,
    such as packet priorities, with its receive indications must have a
    MiniportReturnPacket function. An NDIS intermediate driver that binds
    itself to such a miniport driver also must have a MiniportReturnPacket
    function.

    Any packet with associated NDIS_PACKET_OOB_DATA in which the Status is set
    to NDIS_STATUS_PENDING on return from NdisMIndicateReceivePacket will be
    returned to MiniportReturnPacket. When all bound protocols have called
    NdisReturnPackets as many times as necessary to release their references
    to the originally indicated packet array, NDIS returns pended packets from
    the array to the MiniportReturnPacket function of the driver that
    originally allocated the packet array.

    Usually, MiniportReturnPacket prepares such a returned packet to be used
    in a subsequent receive indication. Although MiniportReturnPacket could
    return the buffer descriptors chained to the packet to buffer pool and the
    packet descriptor itself to packet pool, it is far more efficient to reuse
    returned descriptors.

    MiniportReturnPacket must call NdisUnchainBufferAtXxx as many times as
    necessary to save the pointers to all chained buffer descriptors before it
    calls NdisReinitializePacket. Otherwise, MiniportReturnPacket cannot
    recover the buffer descriptors the driver originally chained to the packet
    for the indication.

    MiniportReturnPacket also can call NdisZeroMemory with the pointer
    returned by NDIS_OOB_DATA_FROM_PACKET to prepare the packet's associated
    out-of-band block for reuse.

    If a particular buffer descriptor was shortened to match the size of an
    indicated range of data, MiniportReturnPacket should call
    NdisAdjustBufferLength with that buffer descriptor to restore its mapping
    of the NIC's receive buffer range.

    By default, MiniportReturnPacket runs at IRQL DISPATCH_LEVEL.

@rdesc

    <f MiniportReturnPacket> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

@xref

    <f NdisAdjustBufferLength>, <f NdisAllocateBuffer>, <f NdisAllocatePacket>,
    <f NdisMIndicateReceivePacket>, <t NDIS_OOB_DATA_FROM_PACKET>,
    <t NDIS_PACKET>, <t NDIS_PACKET_OOB_DATA>, <f NdisReinitializePacket>,
    <f NdisReturnPackets>, <f NdisUnchainBufferAtBack>,
    <f NdisUnchainBufferAtFront>, <f NdisZeroMemory>

*/

VOID MiniportReturnPacket(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PNDIS_PACKET             pNdisPacket                 // @parm
    // A pointer to a <t NDIS_PACKET> that was passed up thru the NDIS
    // wrapper by an earlier call to <f NdisMIndicateReceivePacket>.
    )
{
    DBG_FUNC("MiniportReturnPacket")

    PNDIS_BUFFER                pNdisBuffer;

    ULONG                       ByteCount = 0;
    
    PUCHAR                      pMemory = NULL;

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    ASSERT(pNdisPacket);

    DBG_ENTER(pAdapter);

    NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
    ASSERT(pNdisBuffer);

    NdisQueryBuffer(pNdisBuffer, &pMemory, &ByteCount);
    ASSERT(pMemory && ByteCount);

    FREE_MEMORY(pMemory, ByteCount);

    NdisFreeBuffer(pNdisBuffer);

    NdisFreePacket(pNdisPacket);

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\miniport.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Miniport Miniport_h

@module Miniport.h |

    This module defines the interface to the <t MINIPORT_DRIVER_OBJECT_TYPE>.

@comm

    This module defines the software structures and values used to support
    the NDIS WAN/TAPI Minport.  It's a good place to look when your trying
    to figure out how the driver structures are related to each other.

    Include this file at the top of each module in the Miniport.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Miniport_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 1.0 Miniport Call Manager Overview |

    The NDIS wrapper provides services to both the Transport drivers, and the
    Miniport drivers.  The NDIS wrapper provides an abstraction layer between
    the two which allows them to interoperate with each other as long as they
    both adhere to the NDIS interfaces defined for Transports and Miniports.

    The NDIS wrapper also provides a set of services which isolates NDIS
    drivers from the specifics of the Operating System (Windows 98 vs
    Windows 2000), as well as the platform specifics (Processor, Bus,
    Interrupts).  The advantage of using the NDIS wrapper is that the Miniport
    can be easily ported to other Windows environments with little or no
    re-coding.

    An MCM consists of two, cooperating, drivers contained the the same binary.
    The DATA portion of the driver handles packet transmits and receives.  The
    CONNECTION portion handles call setup and tear down.

    The DATA side of the Miniport is very similar to an NDIS LAN style Miniport,
    except that some of the NDIS interfaces have been modified to support the
    WAN media type.  The primary difference from the Miniport's point of view is
    that we use a different set of NDIS requests, and more importantly the line
    can go up and down.

    The CONNECTION portion of the Miniport adds significant complexity to the
    Miniport.  The MCM Miniport must provide a pseudo Telephony Service Provider
    Interface (TSPI) which lives under NDPROXY.  The NDPROXY TSPI loads under
    TAPI as the 'real' service provider, and then routes all TAPI events to the
    MCM.

    NDPROXY can have multiple MCM's living under its TSPI interface.  And since
    Remote Access Services (RAS) usess the TAPI interface to place and accept
    all calls, any Dial Up Networking (DUN) requests associated with the MCM,
    will end up at the MCM via CONDIS requests from NDPROXY.

@topic 1.1 Reference Documents |

    The most reliable source of information is provided on the Microsoft
    Developer Network CD.  These documents will provide you with the complete
    NDIS interface requirements and architectural overviews.  In addition,
    there are many addendums and developer notes in the Microsoft Knowledge
    Base.  The most important references are:

@iex
    Product Documentation\DDKs\Windows 2000 DDK\Network Drivers\
        Design Guide\Part 2: Miniport NIC Drivers
            Chapters 1-7 discuss all the NDIS interface routines.
            Chapters 8 provide details on WAN/TAPI extensions.
            Section 8.7 discuss CoNdis extensions to support TAPI.

    Product Documentation\SDKs\Platform SDK\Networking and Directory Services\
        Telephone Application Programming Interfaces\TAPI Service Providers
        This section defines the Windows TSPI implementation.

@normal

@end
*/

/* @doc EXTERNAL INTERNAL


@topic 2.0 Installing and Configuring the Sample Driver |

    The sample driver implements a fully functional ISDN style CO-NDIS WAN
    driver.  It layers in under NDPROXY which translates the RAS/WAN/TAPI
    interfaces into a more generic CO-NDIS interface.  The driver supports
    multiple adapter instances, so you can install it more than once to
    create multiple adapters.

    Each adapter can emulate multiple ISDN B channels.  By default, each
    adapter is setup with 2 channels, but you can modify the "IsdnBChannels"
    and "WanEndPoints" registry entries to creates as many as you'd like.
    Alternatively, you can just modify these values in the INF file before
    you install the adapter.  Either way works fine.

@topic 2.1 Installation |

    The driver can be installed as a non-plug-n-play device using the Windows
    device manager interface as follows:

    1) Right-click the "My Computer" icon on the desktop and select the
    Properties item from the context menu.

    2) Select the "Hardware" tab on the "System Properties" dialog.

    3) Click the "Hardware Wizard" button, then click "Next" when the welcome
    dialog appears.

    4) Click "Next" again to "Add/Troubleshoot a device".

    5) Select "Add a new device" from the list presented, then click "Next".

    6) Select "No, I want to select the hardware from a list" radio button,
    then click "Next".

    7) Select "Network adapters" from the list presented, then click "Next".

    8) Click the "Have Disk" button, then browse to the location of the driver
    and INF file, then click OK."

    9) You should now see "TriplePoint COISDN Adapter" on the screen.  Click
    "Next" and then "Next" again to install the driver.  If Windows warns you
    about an unsigned driver, just click yes to install.  If you don't have
    permission to install such drivers, you'll have to exit and logon with the
    proper permissions.  You will have to disable the driver signing check on
    your system if it doesn't allow unsigned drivers to be installed.

    10) Now click "Finish" to load the driver.

@topic 2.2 Dial-In Setup |

    You must install and enable Dial-Up networking before you can accept an
    incoming call with the driver.  This can be done using the following
    procedure:

    1) Right-click the "My Network Places" icon on the desktop and select the
    Properties item from the context menu.

    2) Double-click the "Make New Connction" icon from the list.

    3) Select the "Accept incoming connections" radio button, then click "Next".

    4) Click the check box next to the "TriplePoint COISDN Adapter"(s) to allow
    incoming calls on the adapter.  All channels on that adapter are enabled
    for incoming calls.  Once you select the adapter(s), click "Next".

    5) Select "Do not allow virtual private connections", then click "Next".

    6) Select the users you want to have dial-in access, then click "Next".

    7) Select the protocols and services you want to support, then click "Next".

    8) Now click "Finish" to enable the dial-in connections.

@topic 2.3 Dial-Out Setup |

    The sample driver implements the following simple dialing method.

    A) "0" can be used to connect to any available more on any available
    adapter.  This is generally good enough for most testing.

    B) "N" specifies that the connection should be directed to a specific
    adapter instance.  Where N must match the ObjectID assigned to a particular
    adapter when the <f MiniportInitialize> routine is called.  Numbers are
    assigned from 1-M based on the adapter initialization order.  The call is
    then directed to any available listening channel on the selected adapter.

    You must create a dial-out connection before you can place call with the
    driver.  This can be done using the following procedure:

    1) Right-click the "My Network Places" icon on the desktop and select the
    Properties item from the context menu.

    2) Double-click the "Make New Connction" icon from the list.

    3) Select the "Dial-up to private network" radio button, then click "Next".

    4) Click the check box next to one or more "TriplePoint COISDN Adapter"
    ISDN Channels to allow outgoing calls on the channel.  Make sure you leave
    enough channels available to answer the call when it comes in...  You have
    no way to know which driver BChannel is actually going to be used, but that
    doesn't generally matter anyway. Once you select the channel(s), click "Next".

    5) Walk your way through the rest of the Wizard dialogs to setup the
    connection as you like.

    6) When you're done click "Finish" to enable the dial-out connection.

    Now you can double-click the dial-out connection to see how it all works.

    I suggest you also turn some debug flags in the driver to see how the call
    setup and teardown winds its way through the driver.  This can be quite
    useful before starting to modify the driver for your hardware.

@end
*/


/* @doc EXTERNAL INTERNAL


@topic 4.0 Functional Overview |

    This section describes the major functional objects defined by the driver.

    This driver is designed as a generic ISDN device driver.  It does not
    support any specific hardware, but does have the basic elements of an ISDN
    device.  The network interface is emulated by placing calls between one or
    more of the driver's BChannels.  This is accomplished using a set of
    software events that simulate typical network events (i.e MakeCall,
    AnnounceCall, Tranmit, Receive, Hangup, etc).

    By using this design approach you can compile and test the driver without
    having to purchase specific hardware.  The downside is that you cannot
    easily test the data flow because the networking infrastructure does not
    support terminating the endpoint on the local host.  However, the data flow
    is not usually very difficult to test once the call manager interfaces are
    reliable.  RAS does support connecting to the local host, but the NDIS
    protocols won't normally route traffic through the interface because they
    just loop back before it reaches the driver.  The PPP negotiation packets
    are routed through the interface, so this does give some data flow excersise,
    but nothing worth writing home about.  The NDISWAN tester has been modified
    to allow it to run over locally terminated connections, so this is the only
    real way to test the data pump.

    Because this driver does not support real hardware, all the hardware
    resource code has been ifdef'd out.  This code has been used in working
    drivers, so I'm pretty sure it will work if you add the corresponding
    compiler options.  However, it has not been verified and may require some
    modifications for your environment.

    There are several other good samples included on the DDK that can be useful
    for using other NDIS features.  This sample focuses primarily on the
    CO-NDIS call manager interfaces.

@end
*/

#ifndef _MPDMAIN_H
#define _MPDMAIN_H

#define MINIPORT_DRIVER_OBJECT_TYPE     ((ULONG)'D')+\
                                        ((ULONG)'R'<<8)+\
                                        ((ULONG)'V'<<16)+\
                                        ((ULONG)'R'<<24)

#define INTERRUPT_OBJECT_TYPE           ((ULONG)'I')+\
                                        ((ULONG)'N'<<8)+\
                                        ((ULONG)'T'<<16)+\
                                        ((ULONG)'R'<<24)

#define RECEIVE_OBJECT_TYPE             ((ULONG)'R')+\
                                        ((ULONG)'E'<<8)+\
                                        ((ULONG)'C'<<16)+\
                                        ((ULONG)'V'<<24)

#define TRANSMIT_OBJECT_TYPE            ((ULONG)'T')+\
                                        ((ULONG)'R'<<8)+\
                                        ((ULONG)'A'<<16)+\
                                        ((ULONG)'N'<<24)

#define REQUEST_OBJECT_TYPE             ((ULONG)'R')+\
                                        ((ULONG)'Q'<<8)+\
                                        ((ULONG)'S'<<16)+\
                                        ((ULONG)'T'<<24)

/*
// NDIS_MINIPORT_DRIVER and BINARY_COMPATIBLE must be defined before the
// NDIS include files.  Normally, it is defined on the command line by
// setting the C_DEFINES variable in the SOURCES build file.
*/
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include "vTarget.h"
#include "TpiDebug.h"

#if !defined(IRP_MN_KERNEL_CALL) && !defined(PCI_SUBCLASS_DASP_OTHER)
// This should be defined in the NTDDK 5.0 ndis.h, but it's not.
// So I copied this here from ntddk.h to use with NdisQueryBufferSafe().
typedef enum _MM_PAGE_PRIORITY {
    LowPagePriority,
    NormalPagePriority = 16,
    HighPagePriority = 32
} MM_PAGE_PRIORITY;
#endif

// Figure out which DDK we're building with.
#if defined(NDIS_LCODE)
#  if defined(NDIS_DOS)
#    define USING_WFW_DDK
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#  elif defined(OID_WAN_GET_INFO)
#    define USING_WIN98_DDK
#  elif defined(NDIS_WIN)
#    define USING_WIN95_DDK
#  else
#    error "BUILDING WITH UNKNOWN 9X DDK"
#  endif
#elif defined(NDIS_NT)
#  if defined(OID_GEN_MACHINE_NAME)
#    define USING_NT51_DDK
#  elif defined(OID_GEN_SUPPORTED_GUIDS)
#    define USING_NT50_DDK
#  elif defined(OID_GEN_MEDIA_CONNECT_STATUS)
#    define USING_NT40_DDK
#  elif defined(OID_WAN_GET_INFO)
#    define USING_NT351_DDK
#  else
#    define USING_NT31_DDK
#  endif
#else
#  error "BUILDING WITH UNKNOWN DDK"
#endif

// Figure out which DDK we should be building with.
#if defined(NDIS51) || defined(NDIS51_MINIPORT)
#  if defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x05
#    define NDIS_MINOR_VERSION          0x01
#  else
#    error "YOU MUST BUILD WITH THE NT 5.1 DDK"
#  endif
#elif defined(NDIS50) || defined(NDIS50_MINIPORT)
#  if defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x05
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 5.0 DDK"
#  endif
#elif defined(NDIS40) || defined(NDIS40_MINIPORT)
#  if defined(USING_NT40_DDK) || defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x04
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 4.0 or 5.0 DDK"
#  endif
#elif defined(NDIS_MINIPORT_DRIVER)
#  if defined(USING_NT351_DDK) || defined(USING_NT40_DDK) || defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 3.51, 4.0, or 5.0 DDK"
#  endif
#elif !defined(NDIS_MAJOR_VERSION) || !defined(NDIS_MINOR_VERSION)
//   Must be FULL MAC
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#endif

// Gotta nest NDIS_STRING_CONST or compiler/preprocessor won't be able to
// handle L##DEFINED_STRING.
#define INIT_STRING_CONST(name)     NDIS_STRING_CONST(name)
#define DECLARE_WIDE_STRING(name)   L##name
#define INIT_WIDE_STRING(name)      DECLARE_WIDE_STRING(name)

typedef struct MINIPORT_ADAPTER_OBJECT  *PMINIPORT_ADAPTER_OBJECT;
typedef struct BCHANNEL_OBJECT          *PBCHANNEL_OBJECT;
typedef struct DCHANNEL_OBJECT          *PDCHANNEL_OBJECT;
typedef struct CARD_OBJECT              *PCARD_OBJECT;
typedef struct PORT_OBJECT              *PPORT_OBJECT;

/*
// The <t NDIS_MAC_LINE_UP> structure is confusing, so I redefine the
// field name to be what makes sense.
*/
#define MiniportLinkContext                 NdisLinkHandle

#if defined(_VXD_) && !defined(NDIS_LCODE)
#  define NDIS_LCODE code_seg("_LTEXT", "LCODE")
#  define NDIS_LDATA data_seg("_LDATA", "LCODE")
#endif

/*
// The link speeds we support.
*/
#define _64KBPS                     64000
#define _56KBPS                     56000

#define MICROSECONDS                (1)
#define MILLISECONDS                (1000*MICROSECONDS)
#define SECONDS                     (1000*MILLISECONDS)

#define TSPI_ADDRESS_ID             0

/*
// Include everything here so the driver modules can just include this
// file and get all they need.
*/
#include "Keywords.h"
#include "Card.h"
#include "Adapter.h"
#include "BChannel.h"
#include "CallMgr.h"
#include "DChannel.h"
#include "Port.h"
#include "TpiParam.h"
#include "TpiMem.h"

/***************************************************************************
// These routines are defined in Miniport.c
*/

NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath
    );

NDIS_STATUS MiniportInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PUINT                   SelectedMediumIndex,
    IN PNDIS_MEDIUM             MediumArray,
    IN UINT                     MediumArraySize,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              WrapperConfigurationContext
    );

void MiniportHalt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

NDIS_STATUS MiniportReset(
    OUT PBOOLEAN                AddressingReset,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

/***************************************************************************
// These routines are defined in interrup.c
*/
BOOLEAN MiniportCheckForHang(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportDisableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportEnableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportHandleInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportISR(
    OUT PBOOLEAN                InterruptRecognized,
    OUT PBOOLEAN                QueueMiniportHandleInterrupt,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportTimer(
    IN PVOID                    SystemSpecific1,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PVOID                    SystemSpecific2,
    IN PVOID                    SystemSpecific3
    );

/***************************************************************************
// These routines are defined in receive.c
*/
void ReceivePacketHandler(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PNDIS_BUFFER             pNdisBuffer,
    IN ULONG                    BytesReceived
    );

VOID MiniportReturnPacket(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_PACKET             pNdisPacket
    );

/***************************************************************************
// These routines are defined in request.c
*/
NDIS_STATUS MiniportCoRequest(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

/***************************************************************************
// These routines are defined in transmit.c
*/
VOID MiniportCoSendPackets(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PPNDIS_PACKET            PacketArray,
    IN UINT                     NumberOfPackets
    );

void TransmitCompleteHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void FlushSendPackets(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel
    );

#endif // _MPDMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\port.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Port Port_c

@module Port.c |

    This module implements the interface to the <t PORT_OBJECT>.

@comm

    The sample does not use this interface, but it is anticipated that it would
    be used to maintain information associated with each physical ISDN line.
    Assuming that each card may have multiple ISDN lines plugged into it.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Port_c

@end

*/

#define  __FILEID__             PORT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                g_PortInstanceCounter = 0;
// Keeps track of how many <t PORT_OBJECT>s are created.


/* @doc EXTERNAL INTERNAL Port Port_c g_PortParameters


@topic 5.5 Port Parameters |

    This section describes the registry parameters read into the
    <t PORT_OBJECT>.

@globalv PARAM_TABLE | g_PortParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t PORT_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t PORT_OBJECT>
    you will need to modify <f PortReadParameters> and add the parameter
    definitions to the <f g_PortParameters> table.

@flag <f IsdnSwitchType> (OPTIONAL) |
    
    This DWORD parameter allows you to identify the switch type a particular
    Port is connected to.  The ISDN installation wizard should set this up
    during installation.<nl>

    <tab><f Default Value:><tab><tab>0x0001<nl>
    <tab><f Valid Range N:><tab><tab>0x0001 <lt>= N <lt>= 0x8000 (bit field)<nl>

@flag <f IsdnNumBChannels> (OPTIONAL) |
    
    This DWORD parameter allows you to control how many <t BCHANNEL_OBJECT>s
    will be allocated for the card.  This should include all the channels on
    all the ports of this adapter.<nl>

    <tab><f Default Value:><tab><tab>2<nl>
    <tab><f Valid Range N:><tab><tab>2 <lt>= N <lt>= 32<nl>

*/

DBG_STATIC PARAM_TABLE          g_PortParameters[] =
{
    PARAM_ENTRY(PORT_OBJECT,
                SwitchType, PARAM_SwitchType,
                FALSE, NdisParameterInteger, 0,
                0x0001, 0x0001, 0x8000),

    PARAM_ENTRY(PORT_OBJECT,
                NumChannels, PARAM_NumBChannels,
                FALSE, NdisParameterInteger, 0,
                2, 2, 32),

    /* The last entry must be an empty string! */
    { { 0 } }
};


DBG_STATIC NDIS_STRING          g_PortPrefix
                                = INIT_STRING_CONST(PARAM_PORT_PREFIX);


/* @doc INTERNAL Port Port_c PortReadParameters


@func

    <f PortReadParameters> reads the Port parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f PortCreate>.

    <f Note>:
    If you add any registry based data members to <t PORT_OBJECT>
    you will need to modify <f PortReadParameters> and add the parameter
    definitions to the <f g_PortParameters> table.

@rdesc

    <f PortReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS PortReadParameters(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pPort,
                    g_PortParameters
                    );

    DBG_NOTICE(pAdapter,("PortPrefixLen=%d:%d:%ls\n",
                g_PortPrefix.Length, g_PortPrefix.MaximumLength, g_PortPrefix.Buffer));

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pPort->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pPort->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Port Port_c PortCreateObjects


@func

    <f PortCreateObjects> calls the create routines for all the objects
    contained in <t PORT_OBJECT>.  This should only be called
    by <f PortCreate>.

    <f Note>:
    If you add any new objects to <t PORT_OBJECT> you will need
    to modify <f PortCreateObjects> and <f PortDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f PortCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS PortCreateObjects(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortCreate


@func

    <f PortCreate> allocates memory for a <t PORT_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppPort> will be set to point to the newly created
    <t PORT_OBJECT>.  Otherwise, <p ppPort> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f PortDestroy> must be called to
    release the <t PORT_OBJECT> created by this function.

@rdesc

    <f PortCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS PortCreate(
    OUT PPORT_OBJECT *          ppPort,                     // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t PORT_OBJECT>.

    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("PortCreate")

    PPORT_OBJECT                pPort;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppPort = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pPort, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pPort->ObjectType = PORT_OBJECT_TYPE;
        pPort->ObjectID = ++g_PortInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pPort->pCard = pCard;

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = PortReadParameters(pPort);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = PortCreateObjects(pPort);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppPort = pPort;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            PortDestroy(pPort);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortDestroyObjects


@func

    <f PortDestroyObjects> calls the destroy routines for all the objects
    contained in <t PORT_OBJECT>.  This should only be called by
    <f PortDestroy>.

    <f Note>:
    If you add any new objects to <t PPORT_OBJECT> you will need to
    modify <f PortCreateObjects> and <f PortDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void PortDestroyObjects(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> instance.
    )
{
    DBG_FUNC("PortDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Port Port_c PortDestroy


@func

    <f PortDestroy> frees the memory for this <t PORT_OBJECT>.
    All memory allocated by <f PortCreate> will be released back to the
    OS.

*/

void PortDestroy(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pPort)
    {
        ASSERT(pPort->ObjectType == PORT_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_PORT(pPort);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        PortDestroyObjects(pPort);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pPort->ObjectType = 0;
        FREE_OBJECT(pPort);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Port Port_c PortOpen


@func

    <f PortOpen> makes the Port connection ready to transmit and
    receive data.

@rdesc

    <f PortOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS PortOpen(
    IN PPORT_OBJECT             pPort,                      // @parm
    // A pointer to the <t PORT_OBJECT> associated with this request.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> to be associated with this
    // Port.
    )
{
    DBG_FUNC("PortOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel);
    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    if (!pPort->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Opening Port #%d\n",
                   pPort->ObjectID));

        // TODO - Add code here

        pPort->IsOpen = TRUE;
    }
    else
    {
        DBG_ERROR(pAdapter,("Port #%d already opened\n",
                  pPort->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortClose


@func

    <f PortClose> closes the given B-channel.

*/

void PortClose(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> associated with this request.
    )
{
    DBG_FUNC("PortClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    if (pPort->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Closing Port #%d\n",
                   pPort->ObjectID));

        // TODO - Add code here

        pPort->IsOpen = FALSE;
    }
    else
    {
        DBG_ERROR(pAdapter,("Port #%d already closed\n",
                  pPort->ObjectID));
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\request.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Request Request_c

@module Request.c |

    This module implements the NDIS request routines for the Miniport.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Request_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.2 NDIS Request Processing |

    A connection-oriented client or call manager calls NdisCoRequest to query or
    set information maintained by another protocol driver on a binding or by the
    underlying miniport.

    Before it calls NdisCoRequest, a client or call manager allocates a buffer
    for its request and initializes an NDIS_REQUEST structure. This structure
    specifies the type of request (query or set), identifies the information
    (OID) being queried or set, and points to buffers used for passing OID data.

    If the connection-oriented client or call manager passes a valid
    NdisAfHandle (see Section 1.2.1), NDIS calls the <f ProtocolCoRequest>
    function of each protocol driver on the binding.

    If the connection-oriented client or call manager passes a NULL address
    family handle, NDIS calls the <f MiniportCoRequest> function of the 
    underlying miniport or MCM.

    The caller of NdisCoRequest or NdisMCmRequest can narrow the scope of the
    request by specifying a VC handle that identifies a VC, or a party handle
    that identifies a party on a multipoint VC. Passing a NULL NdisVcHandle
    makes such a request global in nature, whether the request is directed to
    the client, call manager, miniport, or MCM.

    <f ProtocolCoRequest> or <f MiniportCoRequest> can complete synchronously,
    or these functions can complete asynchronously with NdisCoRequestComplete.
    The call to NdisCoRequestComplete causes NDIS to call the
    <f ProtocolCoRequestComplete> function of the driver that called 
    NdisCoRequest.

@comm

    Since only one NDIS request can be outstanding at a time, this mechanism
    should not be used for requests that need to be pended indefintely.  For
    such long term requests, you should use a system event mechanism such as 
    NdisSetEvent to trigger the request.

@end
*/

#define  __FILEID__             REQUEST_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif

/*
// The following is a list of all the possible NDIS QuereyInformation requests
// that might be directed to the miniport.
// Comment out any that are not supported by this driver.
*/
DBG_STATIC const NDIS_OID       g_SupportedOidArray[] =
{
    OID_GEN_CO_SUPPORTED_LIST,
    OID_GEN_CO_HARDWARE_STATUS,
    OID_GEN_CO_MEDIA_SUPPORTED,
    OID_GEN_CO_MEDIA_IN_USE,
    OID_GEN_CO_LINK_SPEED,
    OID_GEN_CO_VENDOR_ID,
    OID_GEN_CO_VENDOR_DESCRIPTION,
    OID_GEN_CO_DRIVER_VERSION,
    OID_GEN_CO_PROTOCOL_OPTIONS,
    OID_GEN_CO_MAC_OPTIONS,
    OID_GEN_CO_MEDIA_CONNECT_STATUS,
    OID_GEN_CO_VENDOR_DRIVER_VERSION,
    OID_GEN_CO_SUPPORTED_GUIDS,

    OID_CO_TAPI_CM_CAPS,
    OID_CO_TAPI_LINE_CAPS,
    OID_CO_TAPI_ADDRESS_CAPS,

    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,

    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_MEDIUM_SUBTYPE,

    OID_WAN_CO_GET_INFO,
    OID_WAN_CO_SET_LINK_INFO,
    OID_WAN_CO_GET_LINK_INFO,

    OID_WAN_LINE_COUNT,

    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,

    0
};

DBG_STATIC const NDIS_GUID      g_SupportedGuidArray[] =
{
    0
};

#if DBG

/*
// Make sure the following list is in the same order as the list above!
*/
DBG_STATIC char *               g_SupportedOidNames[] =
{
    "OID_GEN_CO_SUPPORTED_LIST",
    "OID_GEN_CO_HARDWARE_STATUS",
    "OID_GEN_CO_MEDIA_SUPPORTED",
    "OID_GEN_CO_MEDIA_IN_USE",
    "OID_GEN_CO_LINK_SPEED",
    "OID_GEN_CO_VENDOR_ID",
    "OID_GEN_CO_VENDOR_DESCRIPTION",
    "OID_GEN_CO_DRIVER_VERSION",
    "OID_GEN_CO_PROTOCOL_OPTIONS",
    "OID_GEN_CO_MAC_OPTIONS",
    "OID_GEN_CO_MEDIA_CONNECT_STATUS",
    "OID_GEN_CO_VENDOR_DRIVER_VERSION",
    "OID_GEN_CO_SUPPORTED_GUIDS",

    "OID_CO_TAPI_CM_CAPS",
    "OID_CO_TAPI_LINE_CAPS",
    "OID_CO_TAPI_ADDRESS_CAPS",

    "OID_802_3_PERMANENT_ADDRESS",
    "OID_802_3_CURRENT_ADDRESS",

    "OID_WAN_PERMANENT_ADDRESS",
    "OID_WAN_CURRENT_ADDRESS",
    "OID_WAN_MEDIUM_SUBTYPE",

    "OID_WAN_CO_GET_INFO",
    "OID_WAN_CO_SET_LINK_INFO",
    "OID_WAN_CO_GET_LINK_INFO",

    "OID_WAN_LINE_COUNT",

    "OID_PNP_CAPABILITIES",
    "OID_PNP_SET_POWER",
    "OID_PNP_QUERY_POWER",

    "OID_UNKNOWN"
};

#define NUM_OID_ENTRIES (sizeof(g_SupportedOidArray) / sizeof(g_SupportedOidArray[0]))

/*
// This debug routine will lookup the printable name for the selected OID.
*/
DBG_STATIC char * DbgGetOidString(
    IN NDIS_OID                 Oid
    )
{
    UINT i;

    for (i = 0; i < NUM_OID_ENTRIES-1; i++)
    {
        if (g_SupportedOidArray[i] == Oid)
        {
            break;
        }
    }
    return(g_SupportedOidNames[i]);
}

#endif // DBG

DBG_STATIC UCHAR        g_PermanentWanAddress[6]            // @globalv
// Returned from an OID_WAN_PERMANENT_ADDRESS MiniportCoQueryInformation
// request. The WAN wrapper wants the miniport to return a unique address 
// for this adapter.  This is used as an ethernet address presented to the 
// protocols.  The least significant bit of the first byte must not be a 1, 
// or it could be interpreted as an ethernet multicast address.  If the 
// vendor has an assigned ethernet vendor code (the first 3 bytes), they 
// should be used to assure that the address does not conflict with another 
// vendor's address.  The last digit is replaced during the call with the 
// adapter instance number.  Usually defined as VER_VENDOR_ID.  
// See also <f g_Vendor3ByteID>.
                        = VER_VENDOR_ID;

DBG_STATIC UCHAR        g_Vendor3ByteID[4]                  // @globalv
// Returned from an OID_GEN_CO_VENDOR_ID MiniportCoQueryInformation request.
// Again, the vendor's assigned ethernet vendor code should be used if possible.
// Usually defined as VER_VENDOR_ID.  See also <f g_PermanentWanAddress>.
                        = VER_VENDOR_ID;

DBG_STATIC NDIS_STRING  g_VendorDescriptionString           // @globalv
// Returned from an OID_GEN_CO_VENDOR_DESCRIPTION MiniportCoQueryInformation 
// request.  This is an arbitrary string which may be used by upper layers to 
// present a user friendly description of the adapter.
// Usually defined as VER_PRODUCT_NAME_STR.
                        = INIT_STRING_CONST(VER_PRODUCT_NAME_STR);

/* @doc INTERNAL Request Request_c MiniportCoQueryInformation


@func

    <f MiniportCoQueryInformation> allows the inspection of the Miniport's
    capabilities and current status.

    If the Miniport does not complete the call immediately (by returning
    NDIS_STATUS_PENDING), it must call NdisMQueryInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesWritten, and BytesNeeded until the request
    completes.

    No other requests will be submitted to the Miniport until this request 
    has been completed.

    <f Note>: that the wrapper will intercept all queries of the following OIDs:
        OID_GEN_CURRENT_PACKET_FILTER,
        OID_GEN_PROTOCOL_OPTIONS,
        OID_802_5_CURRENT_FUNCTIONAL,
        OID_802_3_MULTICAST_LIST,
        OID_FDDI_LONG_MULTICAST_LIST,
        OID_FDDI_SHORT_MULTICAST_LIST.

    <f Note>: Interrupts will be in any state when called.

@rdesc

    <f MiniportCoQueryInformation> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS MiniportCoQueryInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_OID                 Oid,                        // @parm
    // The OID.  (See section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs.)

    IN PVOID                    InformationBuffer,          // @parm
    // The buffer that will receive the information. (See section 7.4 of the
    // NDIS 3.0 specification for a description of the length required for
    // each OID.)

    IN ULONG                    InformationBufferLength,    // @parm
    // The length in bytes of InformationBuffer.

    OUT PULONG                  BytesWritten,               // @parm
    // Returns the number of bytes written into InformationBuffer.

    OUT PULONG                  BytesNeeded                 // @parm
    // Returns the number of additional bytes needed to satisfy the OID.
    )
{
    DBG_FUNC("MiniportCoQueryInformation")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the status result returned by this function.

    PVOID                       SourceBuffer;
    // Pointer to driver data to be copied back to caller's InformationBuffer

    ULONG                       SourceBufferLength;
    // Number of bytes to be copied from driver.

    ULONG                       GenericULong = 0;
    // Most return values are long integers, so this is used to hold the
    // return value of a constant or computed result.

    UCHAR                       VendorId[4];
    // Used to store vendor ID string.

    NDIS_PNP_CAPABILITIES       PnpCapabilities;
    // Used to return our PNP capabilities.

    NDIS_CO_LINK_SPEED          LinkSpeed;
    // Used to return our link speed.

    UINT                        InfoOffset;
    // Offset from the start of the buffer to the various information
    // fields we fill in and return to the caller.

    UINT                        InfoLength;
    // Length of the information being copied.

    DBG_STATIC WCHAR            LineSwitchName[]  = 
        INIT_WIDE_STRING(VER_DEVICE_STR) DECLARE_WIDE_STRING(" Switch");
    // TODO: Replace with unicode string to identify the ISDN switch.

    DBG_STATIC WCHAR            LineAddressName[] = 
        INIT_WIDE_STRING(VER_DEVICE_STR) DECLARE_WIDE_STRING(" Address 00");
    // TODO: The SAMPLE_DRIVER only handles 1 address per line.  You may want 
    // to modify the driver to present multiple addresses per line.

    DBG_ENTER(pAdapter);
    DBG_REQUEST(pAdapter,
              ("(OID=0x%08X %s)\n\t\tInfoLength=%d InfoBuffer=0x%X\n",
               Oid, DbgGetOidString(Oid),
               InformationBufferLength,
               InformationBuffer
              ));

    /*
    // Initialize these once, since this is the majority of cases.
    */
    SourceBuffer = &GenericULong;
    SourceBufferLength = sizeof(ULONG);
    *BytesWritten = 0;

    /*
    // Determine which OID is being requested and do the right thing.
    // Refer to section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs and their return values.
    */
    switch (Oid)
    {
    case OID_GEN_CO_SUPPORTED_LIST:
        /*
        // NDIS wants to know which OID's to pass down to us.
        // So we report back these new IOCTL's in addition to any NDIS OID's.
        */
        SourceBuffer =  (PVOID)g_SupportedOidArray;
        SourceBufferLength = sizeof(g_SupportedOidArray);
        break;

    case OID_GEN_CO_SUPPORTED_GUIDS:
        SourceBuffer =  (PVOID)g_SupportedGuidArray;
        SourceBufferLength = sizeof(g_SupportedGuidArray);
        break;

    case OID_GEN_CO_HARDWARE_STATUS:
        GenericULong = NdisHardwareStatusReady;
        break;

    case OID_GEN_CO_MEDIA_SUPPORTED:
        GenericULong = NdisMediumCoWan;
        break;

    case OID_GEN_CO_MEDIA_IN_USE:
        GenericULong = NdisMediumCoWan;
        break;

    case OID_GEN_CO_LINK_SPEED:
        LinkSpeed.Outbound = pBChannel->LinkSpeed / 100;
        LinkSpeed.Inbound  = pBChannel->LinkSpeed / 100;
        SourceBuffer = &LinkSpeed;
        SourceBufferLength = sizeof(LinkSpeed);
        break;

    case OID_GEN_CO_VENDOR_ID:
        NdisMoveMemory((PVOID)VendorId, (PVOID)g_PermanentWanAddress, 3);
        VendorId[3] = 0x0;
        SourceBuffer = &VendorId[0];
        SourceBufferLength = sizeof(VendorId);
        break;

    case OID_GEN_CO_VENDOR_DESCRIPTION:
        SourceBuffer = (PUCHAR) g_VendorDescriptionString.Buffer;
        SourceBufferLength = g_VendorDescriptionString.MaximumLength;
        break;

    case OID_GEN_CO_DRIVER_VERSION:
        GenericULong = (NDIS_MAJOR_VERSION << 8) + NDIS_MINOR_VERSION;
        break;

    case OID_GEN_CO_MAC_OPTIONS:
        GenericULong = 0;   // Reserved - leave it set to zero.
        break;

    case OID_GEN_CO_MEDIA_CONNECT_STATUS:
        GenericULong = NdisMediaStateConnected;
        break;

    case OID_GEN_CO_VENDOR_DRIVER_VERSION:
        GenericULong = (VER_FILE_MAJOR_NUM << 8) + VER_FILE_MINOR_NUM;
        break;

    case OID_CO_TAPI_CM_CAPS:
        {
            PCO_TAPI_CM_CAPS        pCallManagerCaps = InformationBuffer;
            
            SourceBufferLength = sizeof(*pCallManagerCaps);
            if (InformationBufferLength >= SourceBufferLength)
            {
                pCallManagerCaps->ulCoTapiVersion = CO_TAPI_VERSION;
                pCallManagerCaps->ulNumLines = pAdapter->NumBChannels;
                pCallManagerCaps->ulFlags = 0;

                // No need to copy, it's filled in already.
                SourceBuffer = InformationBuffer;
            }
            else
            {
                DBG_ERROR(pAdapter,("OID_CO_TAPI_CM_CAPS: Invalid size=%d expected=%d\n",
                          InformationBufferLength, SourceBufferLength));
            }
        }
        break;

    case OID_CO_TAPI_LINE_CAPS:
        {
            PCO_TAPI_LINE_CAPS      pLineCaps = InformationBuffer;
            
            SourceBufferLength = sizeof(*pLineCaps);
            if (InformationBufferLength >= SourceBufferLength)
            {
                pLineCaps->ulFlags = 0;

                pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, 
                                                    pLineCaps->ulLineID);

                // We're gonna write at least this much, maybe more.
                *BytesWritten = SourceBufferLength;

                DBG_NOTICE(pAdapter,("OID_CO_TAPI_LINE_CAPS: Line=0x%X\n",
                           pLineCaps->ulLineID));

                pLineCaps->LineDevCaps.ulNeededSize =
                pLineCaps->LineDevCaps.ulUsedSize = sizeof(pLineCaps->LineDevCaps);
            
                /*
                // The driver numbers lines sequentially from 1, so this will 
                // always be the same number.
                */
                pLineCaps->LineDevCaps.ulPermanentLineID = pBChannel->ObjectID;
            
                /*
                // All the strings are ASCII format rather than UNICODE.
                */
                pLineCaps->LineDevCaps.ulStringFormat = STRINGFORMAT_UNICODE;
            
                /*
                // Report the capabilities of this device.
                */
                pLineCaps->LineDevCaps.ulAddressModes = LINEADDRESSMODE_ADDRESSID;
                pLineCaps->LineDevCaps.ulNumAddresses = 1;
                pLineCaps->LineDevCaps.ulBearerModes  = pBChannel->BearerModesCaps;
                pLineCaps->LineDevCaps.ulMaxRate      = pBChannel->LinkSpeed;
                pLineCaps->LineDevCaps.ulMediaModes   = pBChannel->MediaModesCaps;
            
                /*
                // Each line on the PRI only supports a single call.
                */
                pLineCaps->LineDevCaps.ulDevCapFlags = LINEDEVCAPFLAGS_CLOSEDROP;
                pLineCaps->LineDevCaps.ulMaxNumActiveCalls = 1;
                pLineCaps->LineDevCaps.ulAnswerMode = LINEANSWERMODE_DROP;
                pLineCaps->LineDevCaps.ulRingModes  = 1;
                pLineCaps->LineDevCaps.ulLineStates = pBChannel->DevStatesCaps;

                /*
                // RASTAPI requires TSPI provider name to be placed in the
                // ProviderInfo field at the end of this structure.
                */
                InfoOffset = sizeof(pLineCaps->LineDevCaps);
                InfoLength = g_VendorDescriptionString.MaximumLength;
                pLineCaps->LineDevCaps.ulNeededSize += InfoLength;
                SourceBufferLength += InfoLength;
                if (pLineCaps->LineDevCaps.ulNeededSize <= 
                    pLineCaps->LineDevCaps.ulTotalSize)
                {
                    pLineCaps->LineDevCaps.ulProviderInfoSize   = InfoLength;
                    pLineCaps->LineDevCaps.ulProviderInfoOffset = InfoOffset;
                    NdisMoveMemory((PUCHAR) &pLineCaps->LineDevCaps + InfoOffset,
                            g_VendorDescriptionString.Buffer,
                            InfoLength
                            );
                    pLineCaps->LineDevCaps.ulUsedSize += InfoLength;
                    InfoOffset += InfoLength;
                }
            
                /*
                // SwitchName is not yet displayed by the Dialup Networking App,
                // but we'll return something reasonable just in case.
                */
                InfoLength = sizeof(LineSwitchName);
                pLineCaps->LineDevCaps.ulNeededSize += InfoLength;
                SourceBufferLength += InfoLength;
                if (pLineCaps->LineDevCaps.ulNeededSize <= 
                    pLineCaps->LineDevCaps.ulTotalSize)
                {
                    pLineCaps->LineDevCaps.ulSwitchInfoSize   = InfoLength;
                    pLineCaps->LineDevCaps.ulSwitchInfoOffset = InfoOffset;
                    NdisMoveMemory((PUCHAR) &pLineCaps->LineDevCaps + InfoOffset,
                            LineSwitchName,
                            InfoLength
                            );
                    pLineCaps->LineDevCaps.ulUsedSize += InfoLength;
                    InfoOffset += InfoLength;
                }
                else
                {
                    DBG_PARAMS(pAdapter,
                               ("STRUCTURETOOSMALL %d<%d\n",
                               pLineCaps->LineDevCaps.ulTotalSize,
                               pLineCaps->LineDevCaps.ulNeededSize));
                }

                // No need to copy, it's filled in already.
                SourceBuffer = InformationBuffer;
            }
            else
            {
                DBG_ERROR(pAdapter,("OID_CO_TAPI_LINE_CAPS: Invalid size=%d expected=%d\n",
                          InformationBufferLength, SourceBufferLength));
            }
        }
        break;

    case OID_CO_TAPI_ADDRESS_CAPS:
        {
            PCO_TAPI_ADDRESS_CAPS   pAddressCaps = InformationBuffer;

            SourceBufferLength = sizeof(*pAddressCaps);
            if (InformationBufferLength >= SourceBufferLength)
            {
                pAddressCaps->ulFlags = 0;

                pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, 
                                                    pAddressCaps->ulLineID);

                // We're gonna write at least this much, maybe more.
                *BytesWritten = SourceBufferLength;

                DBG_NOTICE(pAdapter,("OID_CO_TAPI_ADDRESS_CAPS: Line=0x%X Addr=0x%X\n",
                           pAddressCaps->ulLineID, pAddressCaps->ulAddressID));

                pAddressCaps->LineAddressCaps.ulNeededSize =
                pAddressCaps->LineAddressCaps.ulUsedSize = 
                                        sizeof(pAddressCaps->LineAddressCaps);
            
                pAddressCaps->LineAddressCaps.ulLineDeviceID = 
                                        pBChannel->ObjectID;
            
                /*
                // Return the various address capabilites for the adapter.
                */
                pAddressCaps->LineAddressCaps.ulAddressSharing = 
                                        LINEADDRESSSHARING_PRIVATE;
                pAddressCaps->LineAddressCaps.ulAddressStates = 
                                        pBChannel->AddressStatesCaps;
                pAddressCaps->LineAddressCaps.ulCallStates = 
                                        pBChannel->CallStatesCaps;
                pAddressCaps->LineAddressCaps.ulDialToneModes = 
                                        LINEDIALTONEMODE_NORMAL;
                pAddressCaps->LineAddressCaps.ulDisconnectModes =
                                        LINEDISCONNECTMODE_NORMAL |
                                        LINEDISCONNECTMODE_UNKNOWN |
                                        LINEDISCONNECTMODE_BUSY |
                                        LINEDISCONNECTMODE_NOANSWER;
                /*
                // This driver does not support conference calls, transfers, 
                // or holds.
                */
                pAddressCaps->LineAddressCaps.ulMaxNumActiveCalls = 1;
                pAddressCaps->LineAddressCaps.ulAddrCapFlags = 
                                        LINEADDRCAPFLAGS_DIALED;
                pAddressCaps->LineAddressCaps.ulCallFeatures = 
                                        LINECALLFEATURE_ACCEPT |
                                        LINECALLFEATURE_ANSWER |
                                        LINECALLFEATURE_DROP;
            
                /*
                // AddressName is displayed by the Dialup Networking App.
                */
                InfoOffset = sizeof(pAddressCaps->LineAddressCaps);
                InfoLength = sizeof(LineAddressName);
                pAddressCaps->LineAddressCaps.ulNeededSize += InfoLength;
                SourceBufferLength += InfoLength;
                if (pAddressCaps->LineAddressCaps.ulNeededSize <= 
                    pAddressCaps->LineAddressCaps.ulTotalSize)
                {
                    pAddressCaps->LineAddressCaps.ulAddressSize = InfoLength;
                    pAddressCaps->LineAddressCaps.ulAddressOffset = InfoOffset;
                    NdisMoveMemory(
                            (PUCHAR) &pAddressCaps->LineAddressCaps + InfoOffset,
                            LineAddressName,
                            InfoLength);
                    pAddressCaps->LineAddressCaps.ulUsedSize += InfoLength;
                    InfoOffset += InfoLength;
                }
                else
                {
                    DBG_PARAMS(pAdapter,
                               ("STRUCTURETOOSMALL %d<%d\n",
                               pAddressCaps->LineAddressCaps.ulTotalSize,
                               pAddressCaps->LineAddressCaps.ulNeededSize));
                }

                // No need to copy, it's filled in already.
                SourceBuffer = InformationBuffer;
            }
            else
            {
                DBG_ERROR(pAdapter,("OID_CO_TAPI_ADDRESS_CAPS: Invalid size=%d expected=%d\n",
                          InformationBufferLength, SourceBufferLength));
            }
        }
        break;

    case OID_802_3_PERMANENT_ADDRESS:
    case OID_802_3_CURRENT_ADDRESS:
    case OID_WAN_PERMANENT_ADDRESS:
    case OID_WAN_CURRENT_ADDRESS:
        g_PermanentWanAddress[5] = (UCHAR) ((pAdapter->ObjectID & 0xFF) + '0');
        SourceBuffer = g_PermanentWanAddress;
        SourceBufferLength = sizeof(g_PermanentWanAddress);
        break;

    case OID_WAN_MEDIUM_SUBTYPE:
        GenericULong = NdisWanMediumIsdn;
        break;

    case OID_WAN_CO_GET_INFO:
        SourceBuffer = &pAdapter->WanInfo;
        SourceBufferLength = sizeof(NDIS_WAN_CO_INFO);
        break;

    case OID_WAN_CO_GET_LINK_INFO:
        {
            /*
            // Make sure what I just said is true.
            */
            if (!IS_VALID_BCHANNEL(pAdapter, pBChannel))
            {
                SourceBufferLength = 0;
                Result = NDIS_STATUS_INVALID_DATA;
                break;
            }

            DBG_PARAMS(pAdapter,
                        ("Returning:\n"
                        "MaxSendFrameSize    = %08lX\n"
                        "MaxRecvFrameSize    = %08lX\n"
                        "SendFramingBits     = %08lX\n"
                        "RecvFramingBits     = %08lX\n"
                        "SendCompressionBits = %08lX\n"
                        "RecvCompressionBits = %08lX\n"
                        "SendACCM            = %08lX\n"
                        "RecvACCM            = %08lX\n",
                        pBChannel->WanLinkInfo.MaxSendFrameSize   ,
                        pBChannel->WanLinkInfo.MaxRecvFrameSize   ,
                        pBChannel->WanLinkInfo.SendFramingBits    ,
                        pBChannel->WanLinkInfo.RecvFramingBits    ,
                        pBChannel->WanLinkInfo.SendCompressionBits,
                        pBChannel->WanLinkInfo.RecvCompressionBits,
                        pBChannel->WanLinkInfo.SendACCM           ,
                        pBChannel->WanLinkInfo.RecvACCM         ));

            SourceBuffer = &(pBChannel->WanLinkInfo);
            SourceBufferLength = sizeof(NDIS_WAN_CO_GET_LINK_INFO);
        }
        break;

    case OID_WAN_LINE_COUNT:
        GenericULong = pAdapter->NumBChannels;
        break;

    case OID_PNP_CAPABILITIES:
        // The sample just returns success for all PM events even though we
        // don't really do anything with them.
        PnpCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp =
                                               NdisDeviceStateUnspecified;
        PnpCapabilities.WakeUpCapabilities.MinPatternWakeUp =
                                               NdisDeviceStateUnspecified;
        PnpCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp =
                                                NdisDeviceStateUnspecified;
        SourceBuffer = &PnpCapabilities;
        SourceBufferLength = sizeof(PnpCapabilities);
        break;

    case OID_PNP_QUERY_POWER:
        // The sample just returns success for all PM events even though we
        // don't really do anything with them.
        break;

    default:
        /*
        // Unknown OID
        */
        Result = NDIS_STATUS_INVALID_OID;
        SourceBufferLength = 0;
        DBG_WARNING(pAdapter,("UNSUPPORTED Oid=0x%08x\n", Oid));
        break;
    }

    /*
    // Now we copy the data into the caller's buffer if there's enough room,
    // otherwise, we report the error and tell em how much we need.
    */
    if (SourceBufferLength > InformationBufferLength)
    {
        *BytesNeeded = SourceBufferLength;
        Result = NDIS_STATUS_INVALID_LENGTH;
    }
    else if (SourceBufferLength)
    {
        // Don't copy if it's already there.
        if (InformationBuffer != SourceBuffer)
        {
            NdisMoveMemory(InformationBuffer,
                           SourceBuffer,
                           SourceBufferLength
                          );
        }
        *BytesNeeded = *BytesWritten = SourceBufferLength;
    }
    else
    {
        *BytesNeeded = *BytesWritten = 0;
    }
    DBG_REQUEST(pAdapter,
              ("RETURN: Status=0x%X Needed=%d Written=%d\n",
               Result, *BytesNeeded, *BytesWritten));

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Request Request_c MiniportCoSetInformation


@func

    <f MiniportCoSetInformation> allows for control of the Miniport by
    changing information maintained by the Miniport.

    Any of the settable NDIS Global Oids may be used. (see section 7.4 of
    the NDIS 3.0 specification for a complete description of the NDIS Oids.)

    If the Miniport does not complete the call immediately (by returning
    NDIS_STATUS_PENDING), it must call NdisMSetInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesRead, and BytesNeeded until the request completes.

    <f Note>: Interrupts are in any state during the call, and no other
    requests will be submitted to the Miniport until this request is
    completed.

@rdesc

    <f MiniportCoSetInformation> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS MiniportCoSetInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_OID                 Oid,                        // @parm
    // The OID.  (See section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs.)

    IN PVOID                    InformationBuffer,          // @parm
    // Points to a buffer containing the OID-specific data used by 
    // <f MiniportCoSetInformation> for the set.
    // See section 7.4 of the
    // NDIS 3.0 specification for a description of the length required for
    // each OID.)

    IN ULONG                    InformationBufferLength,    // @parm
    // Specifies the number of bytes at <p InformationBuffer>.

    OUT PULONG                  BytesRead,                  // @parm
    // Points to a variable that <f MiniportCoSetInformation> sets to the
    // number of bytes it read from the buffer at InformationBuffer. 

    OUT PULONG                  BytesNeeded                 // @parm
    // Points to a variable that <f MiniportCoSetInformation> sets to the
    // number of additional bytes it needs to satisfy the request if
    // <p InformationBufferLength> is less than Oid requires. 
        
    )
{
    DBG_FUNC("MiniportCoSetInformation")

    NDIS_STATUS                 Result;
    // Holds the status result returned by this function.

    DBG_ENTER(pAdapter);
    DBG_REQUEST(pAdapter,
              ("(OID=0x%08X %s)\n\t\tInfoLength=%d InfoBuffer=0x%X\n",
               Oid, DbgGetOidString(Oid),
               InformationBufferLength,
               InformationBuffer
              ));

    /*
    // Assume no extra bytes are needed.
    */
    ASSERT(BytesRead && BytesNeeded);
    *BytesRead = 0;
    *BytesNeeded = 0;

    /*
    // Determine which OID is being requested and do the right thing.
    */
    switch (Oid)
    {
    case OID_GEN_CURRENT_LOOKAHEAD:
        /*
        // WAN drivers always indicate the entire packet regardless of the
        // lookahead size.  So this request should be politely ignored.
        */
        DBG_NOTICE(pAdapter,("OID_GEN_CURRENT_LOOKAHEAD: set=%d expected=%d\n",
                    *(PULONG) InformationBuffer, CARD_MAX_LOOKAHEAD));
        ASSERT(InformationBufferLength == sizeof(ULONG));
        *BytesNeeded = *BytesRead = sizeof(ULONG);
        Result = NDIS_STATUS_SUCCESS;
        break;

    case OID_WAN_CO_SET_LINK_INFO:

        if (InformationBufferLength == sizeof(NDIS_WAN_CO_SET_LINK_INFO))
        {
            /*
            // Make sure what I just said is true.
            */
            if (!IS_VALID_BCHANNEL(pAdapter, pBChannel))
            {
                Result = NDIS_STATUS_INVALID_DATA;
                break;
            }

            ASSERT(!(pBChannel->WanLinkInfo.SendFramingBits & 
                     ~pAdapter->WanInfo.FramingBits));
            ASSERT(!(pBChannel->WanLinkInfo.RecvFramingBits & 
                     ~pAdapter->WanInfo.FramingBits));

            /*
            // Copy the data into our WanLinkInfo sturcture.
            */
            NdisMoveMemory(&(pBChannel->WanLinkInfo),
                           InformationBuffer,
                           InformationBufferLength
                          );
            *BytesRead = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
            Result = NDIS_STATUS_SUCCESS;

            if (pBChannel->WanLinkInfo.MaxSendFrameSize != 
                    pAdapter->WanInfo.MaxFrameSize ||
                pBChannel->WanLinkInfo.MaxRecvFrameSize != 
                    pAdapter->WanInfo.MaxFrameSize)
            {
                DBG_NOTICE(pAdapter,("Line=%d - "
                            "SendFrameSize=%08lX - "
                            "RecvFrameSize=%08lX\n",
                            pBChannel->ObjectID,
                            pBChannel->WanLinkInfo.MaxSendFrameSize,
                            pBChannel->WanLinkInfo.MaxRecvFrameSize));
            }

            DBG_PARAMS(pAdapter,
                       ("\n                   setting    expected\n"
                        "MaxSendFrameSize = %08lX=?=%08lX\n"
                        "MaxRecvFrameSize = %08lX=?=%08lX\n"
                        "SendFramingBits  = %08lX=?=%08lX\n"
                        "RecvFramingBits  = %08lX=?=%08lX\n"
                        "SendACCM         = %08lX=?=%08lX\n"
                        "RecvACCM         = %08lX=?=%08lX\n",
                        pBChannel->WanLinkInfo.MaxSendFrameSize, 
                            pAdapter->WanInfo.MaxFrameSize,
                        pBChannel->WanLinkInfo.MaxRecvFrameSize, 
                            pAdapter->WanInfo.MaxFrameSize,
                        pBChannel->WanLinkInfo.SendFramingBits, 
                            pAdapter->WanInfo.FramingBits,
                        pBChannel->WanLinkInfo.RecvFramingBits, 
                            pAdapter->WanInfo.FramingBits,
                        pBChannel->WanLinkInfo.SendCompressionBits, 
                            0,
                        pBChannel->WanLinkInfo.RecvCompressionBits, 
                            0,
                        pBChannel->WanLinkInfo.SendACCM, 
                            pAdapter->WanInfo.DesiredACCM,
                        pBChannel->WanLinkInfo.RecvACCM, 
                            pAdapter->WanInfo.DesiredACCM));
        }
        else
        {
            DBG_WARNING(pAdapter, ("OID_WAN_CO_SET_LINK_INFO: Invalid size:%d expected:%d\n",
                        InformationBufferLength, 
                        sizeof(NDIS_WAN_CO_SET_LINK_INFO)));
            Result = NDIS_STATUS_INVALID_LENGTH;
        }
        *BytesNeeded = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
        break;

    case OID_PNP_SET_POWER:
        // TODO: The sample just returns success for all PM events even though we
        // don't really do anything with them.
        break;

    case OID_GEN_CO_PROTOCOL_OPTIONS:
        // TODO: If an intermediate driver slips in below us, we may want to
        // handle this OID.  Although, it's probably safe to ignore it...
        break;

    default:
        /*
        // Unknown OID
        */
        Result = NDIS_STATUS_INVALID_OID;
        DBG_WARNING(pAdapter,("UNSUPPORTED Oid=0x%08x\n", Oid));
        break;
    }
    DBG_REQUEST(pAdapter,
              ("RETURN: Status=0x%X Needed=%d Read=%d\n",
               Result, *BytesNeeded, *BytesRead));

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL Request Request_c MiniportCoRequest


@func

    <f MiniportCoRequest> is a required function for connection-oriented
    miniports.  <f MiniportCoRequest> handles a protocol-initiated request 
    to get or set information from the miniport.

@comm

    NDIS calls the <f MiniportCoRequest> function either on its own behalf
    or on behalf of a bound protocol driver that called <f NdisCoRequest>.
    Miniport drivers should examine the request supplied at <f NdisRequest>
    and take the action requested.  For more information about the required
    and optional OID_GEN_CO_XXX that connection-oriented miniport drivers 
    must handle, see Part 2. 

    <f MiniportCoRequest> must be written such that it can be run from IRQL
    DISPATCH_LEVEL.

@rdesc

    <f MiniportCoRequest> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS MiniportCoRequest(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    // Specifies the handle to a miniport-allocated context area in which
    // the miniport maintains state information about this instance of the
    // adapter. The miniport provided this handle to NDIS by calling
    // <f NdisMSetAttributes> or <f NdisMSetAttributesEx> from its 
    // <f MiniportInitialize> function. 

    IN PBCHANNEL_OBJECT         pBChannel OPTIONAL,         // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    // Specifies the handle to a miniport-allocated context area in which the
    // miniport maintains its per-VC state.  The miniport supplied this handle
    // to NDIS from its <f MiniportCoCreateVc> function. 

    IN OUT PNDIS_REQUEST        NdisRequest                 // @parm
    // Points to a <t NDIS_REQUEST> structure that contains both the buffer 
    // and the request packet for the miniport to handle.  Depending on the 
    // request, the miniport returns requested information in the structure 
    // provided. 
    )
{
    DBG_FUNC("MiniportCoRequest")

    NDIS_STATUS                 Result;
    // Holds the status result returned by this function.
        
    // ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    ASSERT(NdisRequest);

    switch (NdisRequest->RequestType)
    {
    case NdisRequestQueryStatistics:

    case NdisRequestQueryInformation:
        Result = MiniportCoQueryInformation(
                        pAdapter,
                        pBChannel,
                        NdisRequest->DATA.QUERY_INFORMATION.Oid,
                        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                        &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                        &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded
                        );
        break;

    case NdisRequestSetInformation:
        Result = MiniportCoSetInformation(
                        pAdapter,
                        pBChannel,
                        NdisRequest->DATA.SET_INFORMATION.Oid,
                        NdisRequest->DATA.SET_INFORMATION.InformationBuffer,
                        NdisRequest->DATA.SET_INFORMATION.InformationBufferLength,
                        &NdisRequest->DATA.SET_INFORMATION.BytesRead,
                        &NdisRequest->DATA.SET_INFORMATION.BytesNeeded
                        );
        break;

    default:
        DBG_ERROR(pAdapter,("UNKNOWN RequestType=%d\n",
                  NdisRequest->RequestType));
        Result = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\tpimem.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiMem TpiMem_c

@module TpiMem.c |

    This module implements the interface to the memory allocation wrappers.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiMem_c

@end

*/

#define  __FILEID__             TPIMEMORY_OBJECT_TYPE
// Unique file ID for error logging

#include "TpiMem.h"
#include "TpiDebug.h"

DBG_STATIC ULONG                g_MemoryAllocated = 0;
DBG_STATIC ULONG                g_MemoryFreed = 0;
DBG_STATIC ULONG                g_SharedMemoryAllocated = 0;
DBG_STATIC ULONG                g_SharedMemoryFreed = 0;


/* @doc INTERNAL TpiMem TpiMem_c TpiAllocateMemory


@func

    <f TpiAllocateMemory> provides a wrapper interface for standard memory
    allocation via <f NdisAllocateMemory>.  This interface is used to help
    debug memory allocation problems.  It can be used to keep track of how
    much memory has been allocated and freed by the Miniport, and can report
    the usage counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisAllocateMemory> (i.e. non-paged system memory).  Do not use this
    routine to allocate continuous or non-cached memory.

@rdesc

    <f TpiAllocateMemory> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS TpiAllocateMemory(
    OUT PVOID *                 ppObject,                   // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber,               // @parm
    // Line number of the file where called from.

    IN NDIS_HANDLE              MiniportAdapterHandle       // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.
    )
{
    DBG_FUNC("TpiAllocateMemory")

    NDIS_STATUS                 Status;
    // Holds the status result returned from an NDIS function call.

    ASSERT(ppObject);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|ppObject=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               ppObject,
               dwSize,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    /*
    // Allocate memory from NDIS.
    */
#if !defined(NDIS50_MINIPORT)
    Status = NdisAllocateMemory(ppObject, dwSize, 0, g_HighestAcceptableAddress);
#else  // NDIS50_MINIPORT
    Status = NdisAllocateMemoryWithTag(ppObject, dwSize, dwFileID);
#endif // NDIS50_MINIPORT

    if (Status == NDIS_STATUS_SUCCESS)
    {
        ASSERT(*ppObject);
        NdisZeroMemory(*ppObject, dwSize);
        g_MemoryAllocated += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("Memory Allocated=%d Freed=%d -- Ptr=0x%X\n",
                   g_MemoryAllocated, g_MemoryFreed, *ppObject));
    }
    else
    {
        DBG_ERROR(DbgInfo,("NdisAllocateMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                  dwSize, szFileName, dwLineNumber, Status));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                3,
                Status,
                dwFileID,
                dwLineNumber
                );

        *ppObject = NULL;
    }

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiFreeMemory


@func

    <f TpiFreeMemory> provides a wrapper interface for <f NdisFreeMemory>.
    This interface is used to help debug memory allocation problems.  It can
    be used to keep track of how much memory has been allocated and freed by
    the Miniport, and can report the usage counters via the debugger.

    <f TpiFreeMemory> provides a wrapper interface for standard memory free
    via <f NdisFreeMemory>.  This interface is used to help debug memory
    allocation problems.  It can be used to keep track of how much memory
    has been allocated and freed by the Miniport, and can report the usage
    counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisFreeMemory> (i.e. non-paged system memory).  Do no use this
    routine to free continuous or non-cached memory.

*/

void TpiFreeMemory(
    IN OUT PVOID *              ppObject,                   // @parm
    // Points to a caller-defined memory location which this function
    // passes to <f NdisFreeMemory> and then writes NULL to.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiFreeMemory")

    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|ppObject=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               ppObject,
               dwSize,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    if (ppObject && *ppObject)
    {
        /*
        // Release memory to NDIS.
        */
        NdisFreeMemory(*ppObject, dwSize, 0);
        g_MemoryFreed += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("Memory Allocated=%d Freed=%d -- Ptr=0x%X\n",
                   g_MemoryAllocated, g_MemoryFreed, *ppObject));

        *ppObject = NULL;
    }
    else
    {
        DBG_ERROR(DbgInfo,("NULL POINTER (Size=%d, File=%s, Line=%d)\n",
                  dwSize, szFileName, dwLineNumber));
    }

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiAllocateSharedMemory


@func

    <f TpiAllocateSharedMemory> provides a wrapper interface for shared memory
    allocation via <f NdisMAllocateSharedMemory>.  This interface is used to help
    debug memory allocation problems.  It can be used to keep track of how
    much memory has been allocated and freed by the Miniport, and can report
    the usage counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisMAllocateSharedMemory> (i.e. non-paged system memory).  Do not
    use this routine to allocate continuous or non-cached memory.

@rdesc

    <f TpiAllocateSharedMemory> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS TpiAllocateSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN BOOLEAN                  bCached,                    // @parm
    // Specifies whether the requested memory is cached or not.

    OUT PVOID *                 pVirtualAddress,            // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,           // @parm
    // Points to a caller-defined memory location to which this function
    // writes the physical address of the allocated memory.  If memory of
    // the specified type is not available, the physical address is zero.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiAllocateSharedMemory")

    NDIS_STATUS                 Status;
    // Holds the status result returned from an NDIS function call.

    ASSERT(pVirtualAddress);
    ASSERT(pPhysicalAddress);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|pVirtualAddress=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|bCached=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               pVirtualAddress,
               dwSize,
               bCached,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    /*
    // Allocate memory from NDIS.
    */
    NdisMAllocateSharedMemory(MiniportAdapterHandle,
                              dwSize,
                              bCached,
                              pVirtualAddress,
                              pPhysicalAddress
                              );


    if (*pVirtualAddress)
    {
        Status = NDIS_STATUS_SUCCESS;

        NdisZeroMemory(*pVirtualAddress, dwSize);
        g_SharedMemoryAllocated += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("SharedMemory Allocated=%d Freed=%d -- Ptr=0x%X @0x%X\n",
                   g_SharedMemoryAllocated, g_SharedMemoryFreed,
                   *pVirtualAddress, pPhysicalAddress->LowPart));
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;

        DBG_ERROR(DbgInfo,("NdisAllocateSharedMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                  dwSize, szFileName, dwLineNumber, Status));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                3,
                Status,
                dwFileID,
                dwLineNumber
                );

        *pVirtualAddress = NULL;
        pPhysicalAddress->LowPart = 0;
        pPhysicalAddress->HighPart = 0;
    }

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiFreeSharedMemory


@func

    <f TpiFreeSharedMemory> provides a wrapper interface for <f NdisFreeSharedMemory>.
    This interface is used to help debug memory allocation problems.  It can
    be used to keep track of how much memory has been allocated and freed by
    the Miniport, and can report the usage counters via the debugger.

    <f TpiFreeSharedMemory> provides a wrapper interface for standard memory free
    via <f NdisFreeSharedMemory>.  This interface is used to help debug memory
    allocation problems.  It can be used to keep track of how much memory
    has been allocated and freed by the Miniport, and can report the usage
    counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisFreeSharedMemory> (i.e. non-paged system memory).  Do no use this
    routine to free continuous or non-cached memory.

*/

void TpiFreeSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN BOOLEAN                  bCached,                    // @parm
    // Specifies whether the requested memory is cached or not.

    IN PVOID *                  pVirtualAddress,            // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    IN NDIS_PHYSICAL_ADDRESS *  pPhysicalAddress,           // @parm
    // Points to a caller-defined memory location to which this function
    // writes the physical address of the allocated memory.  If memory of
    // the specified type is not available, the physical address is zero.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiFreeSharedMemory")

    ASSERT(pVirtualAddress);
    ASSERT(pPhysicalAddress);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|pVirtualAddress=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|bCached=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               pVirtualAddress,
               dwSize,
               bCached,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    if (pVirtualAddress && *pVirtualAddress)
    {
        /*
        // Release memory to NDIS.
        */
        NdisMFreeSharedMemory(MiniportAdapterHandle,
                              dwSize,
                              bCached,
                              *pVirtualAddress,
                              *pPhysicalAddress
                              );
        g_SharedMemoryFreed += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("SharedMemory Allocated=%d Freed=%d -- Ptr=0x%X @0x%X\n",
                   g_SharedMemoryAllocated, g_SharedMemoryFreed,
                   *pVirtualAddress, pPhysicalAddress->LowPart));

        *pVirtualAddress = NULL;
        pPhysicalAddress->LowPart = 0;
        pPhysicalAddress->HighPart = 0;
    }
    else
    {
        DBG_ERROR(DbgInfo,("NULL POINTER (Size=%d, File=%s, Line=%d)\n",
                  dwSize, szFileName, dwLineNumber));
    }

    DBG_LEAVE(DbgInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\tpidebug.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiDebug TpiDebug_c

@module TpiDebug.c |

    This module, along with <f TpiDebug\.h>, implements code and macros to
    support NDIS driver debugging.  This file must be linked with the driver
    to support debug dumps and logging.

@comm

    The code and macros defined by these modules is only generated during
    development debugging when the C pre-processor macro flag (DBG == 1).
    If (DBG == 0) no code will be generated, and all debug strings will be
    removed from the image.

    This is a device independent module which can be re-used, without
    change, by any driver or application.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiDebug_c

@end

*/

#if defined(_EXE_) || defined(_DLL_)
typedef char CHAR, *PCHAR;
typedef unsigned char  UCHAR,  *PUCHAR;
typedef unsigned short USHORT, *PUSHORT;
typedef unsigned long  ULONG,  *PULONG;
typedef unsigned int  *PUINT;

# include <windows.h>
#elif defined(_VXD_)
# include <basedef.h>
# include <vmm.h>
# pragma VxD_LOCKED_CODE_SEG
# pragma VxD_LOCKED_DATA_SEG
#else
# include <windef.h>
#endif

#include "TpiDebug.h"

#if DBG

/*
// Sometimes the debug output seriously impacts the run-time performance,
// so it is necessary to turn off the debug output.  In this case, you can
// capture some debug trace information into the DbgLogBuffer, and it can
// be examined later without impacting the run-time performance.
*/
#define DBG_LOG_ENTRIES     100     // Maximum number of FIFO log entries.
#define DBG_LOG_SIZE        128     // Maximum number of bytes per entry.

#if defined(_VXD_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'V','X','D',0 } };
#elif defined(_EXE_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'E','X','E',0 } };
#elif defined(_DLL_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'D','L','L',0 } };
#elif defined(_SYS_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'S','Y','S',0 } };
#else
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'T','P','I',0 } };
#endif

PDBG_SETTINGS   DbgInfo = &DbgSettings;
UINT            DbgLogIndex = 0;
UCHAR           DbgLogBuffer[DBG_LOG_ENTRIES][DBG_LOG_SIZE] = { { 0 } };


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrintData


@func

    <f DbgPrintData> outputs data to the debug display formatted in HEX and
    ASCII for easy viewing.

    <f Note>: This routine is used for debug output only.
    It is not compiled into the retail version.

@ex <tab> |
    DbgPrintData(ReceiveBuffer, 14, 0);                     // Packet header
    DbgPrintData(ReceiveBuffer+14, BytesReceived-14, 14);   // Packet data

0000: ff ff ff ff ff ff 0a 22 23 01 02 03 00 10        ......."#.....
000E: 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 40  ABCDEFGHIJKMNOPQ

*/

VOID DbgPrintData(
    IN PUCHAR                   Data,                       // @parm
    // Pointer to first byte of data to be displayed.

    IN UINT                     NumBytes,                   // @parm
    // Number of bytes to be displayed.

    IN ULONG                    Offset                      // @parm
    // Value to be added to the offset counter displayed at the start of each
    // line.  This is useful for viewing data whose base offset is relative to
    // another, non-zero starting address.

    )
{
    UINT                        LineStart;
    UINT                        LineIndex;

    /*
    // Display the caller's buffer with up to 16 bytes per line.
    */
    for (LineStart = 0; LineStart < NumBytes; LineStart += 16)
    {
        /*
        // Display the starting offset of the line.
        */
        DbgPrint("%04lx: ", LineStart + Offset);

        /*
        // Display a line of HEX byte values.
        */
        for (LineIndex = LineStart; LineIndex < (LineStart+16); LineIndex++)
        {
            if (LineIndex < NumBytes)
            {
                DbgPrint("%02x ",(UINT)((UCHAR)*(Data+LineIndex)));
            }
            else
            {
                DbgPrint("   ");
            }
        }
        DbgPrint("  ");     // A little white space between HEX and ASCII.

        /*
        // Display the corresponding ASCII byte values if they are printable.
        // (i.e. 0x20 <= N <= 0x7F).
        */
        for (LineIndex = LineStart; LineIndex < (LineStart+16); LineIndex++)
        {
            if (LineIndex < NumBytes)
            {
                char c = *(Data+LineIndex);

                if (c < ' ' || c > 'z')
                {
                    c = '.';
                }
                DbgPrint("%c", (UINT)c);
            }
            else
            {
                DbgPrint(" ");
            }
        }
        DbgPrint("\n");     // End of line.
    }
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgQueueData


@func

    <f DbgQueueData> saves data to the DbgLogBuffer so it can be viewed later
    with the debugger.

    <f Note>: This routine is used for debug output only.
    It is not compiled into the retail version.

*/

VOID DbgQueueData(
    IN PUCHAR                   Data,                       // @parm
    // Pointer to first byte of data to be displayed.

    IN UINT                     NumBytes,                   // @parm
    // Number of bytes to be displayed.

    IN UINT                     Flags                       // @parm
    // A flag descriptor to help identify the log entry.
    )
{
    /*
    // Point to the next available entry in the DbgLogBuffer.
    */
    PUCHAR LogEntry = &DbgLogBuffer[DbgLogIndex++][0];

    /*
    // Wrap around on the next entry if needed.
    */
    if (DbgLogIndex >= DBG_LOG_ENTRIES)
    {
        DbgLogIndex = 0;
    }

    /*
    // Save the flags parameter in the first WORD of the log buffer.
    */
    *((PUSHORT) LogEntry) = (USHORT) Flags;
    LogEntry += sizeof(PUSHORT);

    /*
    // Save the NumBytes parameter in the second WORD of the log buffer.
    */
    *((PUSHORT) LogEntry) = (USHORT) NumBytes;
    LogEntry += sizeof(NumBytes);

    /*
    // Don't try to save more than we have room for.
    */
    if (NumBytes > DBG_LOG_SIZE - sizeof(USHORT) * 2)
    {
        NumBytes = DBG_LOG_SIZE - sizeof(USHORT) * 2;
    }

    /*
    // Save the rest of the data in the remaining portion of the log buffer.
    */
    while (NumBytes--)
    {
        *LogEntry++ = *Data++;
    }
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgBreakPoint


@func VOID | DbgBreakPoint |

    <f DbgBreakPoint> is defined in the NT kernel for SYS drivers, but we
    override it here so we can support for SYS's, EXE's, VXD's, and DLL's.

*/
#if defined(_MSC_VER) && (_MSC_VER <= 800)
// Must be building with 16-bit compiler
VOID __cdecl DbgBreakPoint(VOID)
#else
// Must be building with 32-bit compiler
VOID __stdcall DbgBreakPoint(VOID)
#endif
{
#if !defined(_WIN64)
    __asm int 3;
#endif
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrint


@func ULONG __cdecl | DbgPrint |

    <f DbgPrint> is defined in the kernel for SYS drivers, otherwise it is
    supported here for EXE's, VXD's, and DLL's.

@parm PCHAR | Format |
    printf style format string.

@parm OPTIONAL | Params |
    Zero or more optional parameters as needed by the format string.

*/

#if defined(_VXD_)

#if !defined(NDIS_DOS)
ULONG __cdecl DbgPrint(PCHAR Format, ...)
{
    ULONG   result = 0;

    __asm lea  eax, (Format + 4)
    __asm push eax
    __asm push Format
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 4*2
    __asm mov result, eax

    return (result);
}
#endif

#elif defined(_EXE_) || defined(_DLL_)

UCHAR   DbgString[1024];

ULONG __cdecl DbgPrint(PCHAR Format, ...)
{
    ULONG   result;

    result = wvsprintf(DbgString, Format, ((PCHAR) &Format) + sizeof(PCHAR));

    OutputDebugString(DbgString);

    if (result >= sizeof(DbgString))
    {
        // We just blew the stack!
        // Since we can't return, we have to generate a stack-fault interrupt
        __asm int 1;
        __asm int 3;
        __asm int 12;
    }
    return (result);
}
#endif // DbgPrint

/*
 * If DBG_SILENT is set, all TERSE debug goes here. An assertion
 * will dump the block.
 */
#define DBG_QUEUE_LEN       4096
UINT    DbgIndex=0;
UINT    DbgLen=0;
UCHAR   DbgQueue[DBG_QUEUE_LEN] =  {0};
UCHAR   DbgLock=0;


/* @doc INTERNAL TpiDebug TpiDebug_c DbgDumpSilentQueue


@func

    <f DbgDumpSilentQueue> dumps the contents of the silent debug queue to
    the monitor.

*/

void DbgDumpSilentQueue(
    void
    )
{
    if (DbgLen >= DBG_QUEUE_LEN)
    {
        DbgPrintData(
            &DbgQueue[DbgIndex],
            DBG_QUEUE_LEN-DbgIndex,
            0);
        if (DbgIndex)
        {
            DbgPrint("\n");
            DbgPrintData(
                DbgQueue,
                DbgIndex-1,
                0);
        }
        DbgPrint("\n");
    }
    else if (DbgLen)
    {
        DbgPrintData(
                DbgQueue,
                DbgIndex-1,
                0);
        DbgPrint("\n");
    }
}

#if NDIS_NT

/* @doc INTERNAL TpiDebug TpiDebug_c _assert


@func

    <f _assert> overrides the assertion function provided by the operating
    system. Dumps the contents of debug queue, prints the assertion, and
    then traps to the debugger.  Used for debugging only.

*/

void _CRTAPI1 _assert(
    void *                      exp,                        // @parm
    // ASCIIZ pointer to the expression causing the fault.

    void *                      file,                       // @parm
    // ASCIIZ pointer to the name of the file.

    unsigned                    line                        // @parm
    // Line offset within the file where the assertion is defined.
    )
{
    DbgDumpSilentQueue();
    DbgPrint("Assertion Failed: %s at %s:%d\n",exp,file,line);
    DbgBreakPoint();
}
#endif


/* @doc INTERNAL TpiDebug TpiDebug_c DbgSilentQueue


@func

    <f DbgSilentQueue> logs a string to the debug queue which can be
    displayed later using <f DbgDumpSilentQueue>.  Used for debugging only.

*/

void DbgSilentQueue(
    PUCHAR                      str                         // @parm
    // Pointer to string to be placed in DbgQueue.
    )
{
    /*
    // If the debug queue is busy, just
    // bail out.
    */
    if ((++DbgLock) > 1)
    {
        goto exit;
    }

    while (str && *str)
    {
        DbgQueue[DbgIndex] = *str++;
        DbgLen++;
        if ((++DbgIndex) >= DBG_QUEUE_LEN)
        {
            DbgIndex = 0;
        }
    }
exit:
    DbgLock--;
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrintFieldTable


@func

    <f DbgPrintFieldTable> displays the contents of a C data structure in
    a formatted output to the debugger.  This can be used when symbolic
    debugging is not available on the target platform.

*/

void DbgPrintFieldTable(
    IN PDBG_FIELD_TABLE         pFields,                    // @parm
    // A pointer to an array of field records <t DBG_FIELD_TABLE>.

    IN PUCHAR                   pBaseContext,               // @parm
    // References the base of the structure where the values will be displayed
    // from.  This should be a pointer to the first byte of the structure.

    IN PUCHAR                   pBaseName                   // @parm
    // Pointer to C string containing the name of the structure being displayed.
    )
{
    DbgPrint("STRUCTURE: @0x%08X %s\n", pBaseContext, pBaseName);

    while (pFields->FieldName)
    {
        switch (pFields->FieldType)
        {
        case sizeof(ULONG):
            DbgPrint("\t%04X: %-32s=0x%08X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PULONG)(pBaseContext+pFields->FieldOffset));
            break;

        case sizeof(USHORT):
            DbgPrint("\t%04X: %-32s=0x%04X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PUSHORT)(pBaseContext+pFields->FieldOffset));
            break;

        case sizeof(UCHAR):
            DbgPrint("\t%04X: %-32s=0x%02X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PUCHAR)(pBaseContext+pFields->FieldOffset));
            break;

        default:
            ASSERT(0);
            break;
        }
        pFields++;
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\tpidebug.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiDebug TpiDebug_h

@module TpiDebug.h |

    This module, along with <f TpiDebug\.c>, implements code and macros to
    support NDIS driver debugging.  This file should be #include'd in all
    the driver source code modules.

@comm

    The code and macros defined by these modules is only generated during
    development debugging when the C pre-processor macro flag (DBG == 1).
    If (DBG == 0) no code will be generated, and all debug strings will be
    removed from the image.

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiDebug_h

@end

*/

#ifndef _TPIDEBUG_H
#define _TPIDEBUG_H

/* @doc INTERNAL TpiDebug TpiDebug_h


@topic Debug Globals |

    Debug macros are used to display error conditions, warnings, interesting
    events, and general flow through the components.  Setting one or more bits
    in the <f DbgInfo> global variable will enable the output from these
    macros.  See <t DEBUG_FLAGS> for details of the bits.  Only the debug
    version of the driver will contain code for this purpose.  All these
    macros will be compiled out in the release version.

    Each component has a separate <f DbgInfo> variable, so you can control
    debug output for each module separately.  By default, all the modules
    breakpoint at their entry point to display the current value and memory
    location of the module's <f DbgInfo> variable.  This way you can use
    the debugger to change the flags when the module is started.  The default
    flag for each module is set at compile time, but can be overridden at
    run time using the debugger.

@globalv DBG_SETTINGS | DbgInfo |

    DbgInfo is a global variable which points to the <t DBG_SETTINGS> for
    the module linked with <f TpiDebug\.c>.  It is passed to most of
    the debug output macros to control which output is to be displayed.  
    See <t DBG_FLAGS> to determine which bits to set.

*/

/*
// Module ID numbers to use for error logging
*/
#define TPI_MODULE_PARAMS               ((unsigned long)'P')+\
                                        ((unsigned long)'A'<<8)+\
                                        ((unsigned long)'R'<<16)+\
                                        ((unsigned long)'M'<<24)
#define TPI_MODULE_DEBUG                ((unsigned long)'D')+\
                                        ((unsigned long)'B'<<8)+\
                                        ((unsigned long)'U'<<16)+\
                                        ((unsigned long)'G'<<24)
#define TPI_MODULE_PERF                 ((unsigned long)'P')+\
                                        ((unsigned long)'E'<<8)+\
                                        ((unsigned long)'R'<<16)+\
                                        ((unsigned long)'F'<<24)
#define TPI_MODULE_WRAPS                ((unsigned long)'W')+\
                                        ((unsigned long)'R'<<8)+\
                                        ((unsigned long)'A'<<16)+\
                                        ((unsigned long)'P'<<24)

// In case these aren't defined in the current environment.
#if !defined(IN)
# define    IN
# define    OUT
#endif

/* @doc INTERNAL TpiDebug TpiDebug_h DBG_FLAGS


@enum DBG_FLAGS |

    The registry parameter <f DebugFlags> is read by the driver at
    initialization time and saved in the <f DbgFlags> field of the
    debug settings structure (See <t DBG_SETTINGS>).  This value
    controls the output of debug information according to the
    following bit OR'd flags.  The most significant 16 bits of the
    DbgFlags is available to use as you please, and can be used
    with the <f DBG_FILTER> macro.

*/

#define DBG_ERROR_ON        0x0001L
        // @emem DBG_ERROR_ON | (0x0001) Display <f DBG_ERROR> messages.

#define DBG_WARNING_ON      0x0002L
        // @emem DBG_WARNING_ON | (0x0002) Display <f DBG_WARNING> messages.

#define DBG_NOTICE_ON       0x0004L
        // @emem DBG_NOTICE_ON | (0x0004) Display <f DBG_NOTICE> messages.

#define DBG_TRACE_ON        0x0008L
        // @emem DBG_TRACE_ON | (0x0008) Display <f DBG_ENTER>, <f DBG_LEAVE>,
        // and <f DBG_TRACE> messages.

#define DBG_REQUEST_ON      0x0010L
        // @emem DBG_REQUEST_ON | (0x0010) Display NDIS Set/Query request
        // parameters using <f DBG_REQUEST>.

#define DBG_INDICATE_ON     0x0020L
        // @emem DBG_INDICATE_ON | (0x0020) Display NDIS status indications.

#define DBG_TAPICALL_ON     0x0040L
        // @emem DBG_TAPICALL_ON | (0x0040) Display TAPI call state messages
        // using <f DBG_FILTER>.

#define DBG_PARAMS_ON       0x0080L
        // @emem DBG_PARAMS_ON | (0x0080) Display function parameters and
        // return values using <f DBG_PARAMS>.

#define DBG_TXRX_LOG_ON     0x0100L
        // @emem DBG_TXRX_LOG_ON | (0x0100) Enable Tx/Rx data logging.

#define DBG_TXRX_ON         0x0200L
        // @emem DBG_TXRX_ON | (0x0200) Display Tx/Rx terse packet info.
        // This flag will just display the link index and packet length Rx#:#.

#define DBG_TXRX_HEADERS_ON 0x0400L
        // @emem DBG_TXRX_HEADERS_ON | (0x0400) Display Tx/Rx packet headers.

#define DBG_HEADERS_ON      DBG_TXRX_HEADERS_ON

#define DBG_TXRX_VERBOSE_ON 0x0800L
        // @emem DBG_TXRX_VERBOSE_ON | (0x0800) Display Tx/Rx packet data.

#define DBG_PACKETS_ON      DBG_TXRX_VERBOSE_ON

#define DBG_MEMORY_ON       0x1000L
        // @emem DBG_MEMORY_ON | (0x1000) Display memory allocate and
        // free usage information.

#define DBG_BUFFER_ON       0x2000L
        // @emem DBG_BUFFER_ON | (0x2000) Display buffer allocate and
        // free usage information.

#define DBG_PACKET_ON       0x4000L
        // @emem DBG_PACKET_ON | (0x4000) Display packet allocate and
        // free usage information.

#define DBG_BREAK_ON        0x8000L
        // @emem DBG_BREAK_ON | (0x8000) Enable <f DBG_BREAK> breakpoints.

#define DbgFlags            DebugFlags      // For compatability
#define DbgID               AnsiDeviceName  // For compatability

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/* @doc INTERNAL TpiDebug TpiDebug_h DBG_SETTINGS


@struct DBG_SETTINGS |

    This structure is used to control debug output for a given module.
    You can set and clear bits in the DbgFlags field to enabled and
    disable various debug macros.  See <t DBG_FLAGS> to determine which 
    bits to set.

*/

typedef struct DBG_SETTINGS
{
    unsigned long DbgFlags;                                 // @field
    // Debug flags control how much debug is displayed in the checked build.
    // Put this field at the front so you can set it easily with debugger.
    // See <t DBG_FLAGS> to determine which bits to set in this field.

    unsigned char DbgID[12];                                // @field
    // This field is initialized to an ASCII string containing a unique
    // module identifier.  It is used to prefix debug messages.  If you
    // have more than one module based on this code, you may want to
    // change the default value to a unqiue string for each module.
    // This string is used a C string, so the last byte must be a zero.

} DBG_SETTINGS, *PDBG_SETTINGS;

extern PDBG_SETTINGS DbgInfo;


/* @doc INTERNAL TpiDebug TpiDebug_h DBG_FIELD_TABLE


@struct DBG_FIELD_TABLE |

    This structure contains the data associated with a C data structure.
    You can use the <f DBG_FIELD_ENTRY> macro to add entries into a
    <t DBG_FIELD_TABLE>.  At run-time you can pass this table pointer to
    the <f DbgPrintFieldTable> routine, and it will display the current
    contents of that data structure.  This is useful for debugging drivers
    or code where no symbolic debugger is available, or if you have want to
    dump structure contents when certain run-time events are encountered.

@comm

    If you have nested structures, you must display them separately.  The
    <f DBG_FIELD_ENTRY> macro can only be used to declare integer type
    fields, and pointers.  Pointers will be displayed as a long integer.<nl>

    The last entry in the table must be all zeros {0}.

*/

typedef struct DBG_FIELD_TABLE
{
    unsigned int    FieldOffset;                            // @parm
    // This value indicates the offset, in bytes, from the <f pBaseContext>
    // pointer passed into <f DbgPrintFieldTable>.  The value for the field
    // will be displayed from this offset from <f pBaseContext>.
    // <nl>*(PUINT)((PUCHAR)BaseContext+Offset) = (UINT) Value;

    unsigned int    FieldType;                              // @parm
    // This value determines how the value will be displayed.
    // <f FieldType> can be one of the following values:
    // <nl>1=UCHAR  - unsigned char integer (8 bits).
    // <nl>2=USHORT - unsigned short integer (16 bits).
    // <nl>4=ULONG  - unsigned long integer (32 bits).

    unsigned char * FieldName;                              // @parm
    // This value points to a C String which is the name of the field within
    // the structure.

} DBG_FIELD_TABLE, *PDBG_FIELD_TABLE;

#define DBG_FIELD_BUFF      0
#define DBG_FIELD_CHAR      1
#define DBG_FIELD_SHORT     2
#define DBG_FIELD_LONG      4

#define DBG_FIELD_OFFSET(Strct, Field) ((unsigned int)((unsigned char *) &((Strct *) 0)->Field))
#define DBG_FIELD_SIZEOF(Strct, Field) sizeof(((Strct *) 0)->Field)
#define DBG_FIELD_ENTRY(Strct, Field) \
    { DBG_FIELD_OFFSET(Strct, Field), \
      DBG_FIELD_SIZEOF(Strct, Field), \
      #Field )

extern VOID DbgPrintFieldTable(
    IN PDBG_FIELD_TABLE     pFields,
    IN unsigned char *               pBaseContext,
    IN unsigned char *               pBaseName
    );

extern VOID DbgPrintData(
    IN unsigned char *               Data,
    IN unsigned int                 NumBytes,
    IN unsigned long                Offset
    );

extern VOID DbgQueueData(
    IN unsigned char *               Data,
    IN unsigned int                 NumBytes,
    IN unsigned int                 Flags
    );

#if !defined(NDIS_WIN) || !defined(DEBUG)
extern unsigned long __cdecl DbgPrint(char * Format, ...);
#endif

// DbgBreakPoint is ugly because it is defined by NTDDK as _stdcall,
// and 95DDK #defines it, and we must define our own for non-DDK builds.
// So all these ifdefs are used to figure out how to handle it.
#ifdef DbgBreakPoint
#   undef DbgBreakPoint
#endif // DbgBreakPoint

#if defined(_MSC_VER) && (_MSC_VER <= 800)
    // Must be building with 16-bit compiler
    extern VOID __cdecl DbgBreakPoint(VOID);
#else
    // Must be building with 32-bit compiler
    extern VOID __stdcall DbgBreakPoint(VOID);
#endif

extern VOID DbgSilentQueue(unsigned char * str);

#ifdef __cplusplus
};
#endif // __cplusplus

// NDIS builds define DBG=0 or DBG=1
#if defined(DEBUG) || defined(_DEBUG)
# ifndef DBG
#  define DBG 1
# endif
#else
# ifndef DBG
#  define DBG 0
# endif
#endif

//###############################################################################
#if DBG
//###############################################################################

#ifndef ASSERTS_ENABLED
#   define ASSERTS_ENABLED  1
#endif

#ifndef DBG_DEFAULTS
#   define DBG_DEFAULTS (DBG_ERROR_ON | DBG_WARNING_ON | DBG_BREAK_ON)
#endif

/* @doc INTERNAL TpiDebug TpiDebug_h


*/

#   define STATIC
#   define DBG_STATIC
    // Make all variables and functions global, so debugger can see them.

#   define TRAPFAULT        DbgBreakPoint()
    // Use this macro to insert an unconditional INT-1 breakpoint.  This
    // is used to distinguish between normal debugger breakpoints (INT-3)
    // and any special cases, such as ASSERT.

#   define BREAKPOINT       DbgBreakPoint()
    // Use this macro to insert an unconditional INT-3 breakpoint.

#   define DBG_FUNC(F)      static const char __FUNC__[] = F;
    // @func const char [] | DBG_FUNC |
    //
    // Use this macro to define the __FUNC__ string used by the rest of the
    // debugger macros to report the name of the function calling the macro.
    //
    // @parm const char * | FunctionName | Name of the function being defined.
    //
    // @ex <tab> | DBG_FUNC("MyFunctionName");

#   define DBG_BREAK(A)     {if ((A) && ((A)->DbgFlags & DBG_BREAK_ON) || !(A)) \
                                BREAKPOINT;}
    // @func VOID | DBG_BREAK |
    //
    // Use this macro to insert a conditional INT-3 breakpoint.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_BREAK(DbgInfo);

#   define DBG_ENTER(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON)) \
                                {DbgPrint("%s:>>>:%s\n",(A)->DbgID,__FUNC__);}}
    // @func VOID | DBG_ENTER |
    //
    // Use this macro to report entry to a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_ENTER(DbgInfo);

#   define DBG_TRACE(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON)) \
                                {DbgPrint("%s:%d:%s\n",(A)->DbgID,__LINE__,\
                                 __FUNC__);}}
    // @func VOID | DBG_TRACE |
    //
    // Use this macro to report a trace location within a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_TRACE(DbgInfo);

#   define DBG_LEAVE(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON))  \
                                {DbgPrint("%s:<<<:%s\n",(A)->DbgID,__FUNC__);}}
    // @func VOID | DBG_LEAVE |
    //
    // Use this macro to report exit from a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_LEAVE(DbgInfo);

#   define DBG_RETURN(A,S)  {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON))  \
                                {DbgPrint("%s:<<<:%s Return(0x%lX)\n",(A)->DbgID,__FUNC__,S);}}
    // @func VOID | DBG_RETURN |
    //
    // Use this macro to report exit from a function with a result.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_RETURN(DbgInfo, Result);

#   define DBG_ERROR(A,S)   {if ((A) && ((A)->DbgFlags & DBG_ERROR_ON))   \
                                {DbgPrint("%s:ERROR:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S; \
                                 if ((A)->DbgFlags & DBG_BREAK_ON) \
                                    {TRAPFAULT;}}}
    // @func VOID | DBG_ERROR |
    //
    // Use this macro to report any unexpected error conditions.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_ERROR(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_WARNING(A,S) {if ((A) && ((A)->DbgFlags & DBG_WARNING_ON)) \
                                {DbgPrint("%s:WARNING:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_WARNING |
    //
    // Use this macro to report any unusual run-time conditions.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_WARNING(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_NOTICE(A,S)  {if ((A) && ((A)->DbgFlags & DBG_NOTICE_ON))  \
                                {DbgPrint("%s:NOTICE:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_NOTICE |
    //
    // Use this macro to report any verbose debug information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_NOTICE(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_REQUEST(A,S)  {if ((A) && ((A)->DbgFlags & DBG_REQUEST_ON))  \
                                {DbgPrint("%s:REQUEST:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_REQUEST |
    //
    // Use this macro to report NDIS Set/Query request information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_REQUEST(DbgInfo, ("Oid #0x%08X - %s\n", Oid, DbgGetOidString(Oid)));

#   define DBG_PARAMS(A,S)  {if ((A) && ((A)->DbgFlags & DBG_PARAMS_ON))  \
                                {DbgPrint("%s:PARAMS:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_PARAMS |
    //
    // Use this macro to report NDIS Set/Query request information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_PARAMS(DbgInfo, ("\n\tNum=0x%X\n\tStr='%s'\n", Num, Str));

#   define DBG_TX(A,I,N,B)  {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Tx%d:%03X:\n",(A)->DbgID,I,N); \
                                if (((A)->DbgFlags & DBG_TXRX_VERBOSE_ON))  \
                                    DbgPrintData((unsigned char *)B, (unsigned int)N, 0); \
                                else if (((A)->DbgFlags & DBG_TXRX_HEADERS_ON))  \
                                    DbgPrintData((unsigned char *)B, 0x10, 0); \
                                }\
                             if ((A) && ((A)->DbgFlags & DBG_TXRX_LOG_ON)) \
                                DbgQueueData((unsigned char *)B, (unsigned int)N, \
                                              (USHORT)((I<< 8) + 0x4000)); \
                            }
    // @func VOID | DBG_TX |
    //
    // Use this macro to report outgoing packet information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @parm IN UINT | NumBytes | Number of bytes being transmitted.
    //
    // @parm IN PUCHAR | Buffer | Pointer to data buffer being transmitted.
    //
    // @ex <tab> | DBG_TX(DbgInfo, BChannelIndex, BytesToSend, CurrentBuffer);

#   define DBG_TXC(A,I)     {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Tc%d\n",(A)->DbgID,I); \
                                }}
    // @func VOID | DBG_TXC |
    //
    // Use this macro to report outgoing packet completion.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @ex <tab> | DBG_TXC(DbgInfo, BChannelIndex);

#   define DBG_RX(A,I,N,B)  {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Rx%d:%03X:\n",(A)->DbgID,I,N); \
                                if (((A)->DbgFlags & DBG_TXRX_VERBOSE_ON))  \
                                    DbgPrintData((unsigned char *)B, (unsigned int)N, 0); \
                                else if (((A)->DbgFlags & DBG_TXRX_HEADERS_ON))  \
                                    DbgPrintData((unsigned char *)B, 0x10, 0); \
                                }\
                             if ((A) && ((A)->DbgFlags & DBG_TXRX_LOG_ON)) \
                                DbgQueueData((unsigned char *)B, (unsigned int)N, \
                                              (USHORT)((I<< 8) + 0x8000)); \
                            }
    // @func VOID | DBG_RX |
    //
    // Use this macro to report incoming packet information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @parm IN UINT | NumBytes | Number of bytes being received.
    //
    // @parm IN PUCHAR | Buffer | Pointer to data buffer being received.
    //
    // @ex <tab> | DBG_RX(DbgInfo, BChannelIndex, BytesReceived, ReceiveBuffer);

#   define DBG_RXC(A,I)     {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Rc%d\n",(A)->DbgID,I); \
                                }}
    // @func VOID | DBG_RXC |
    //
    // Use this macro to report incoming packet completion.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @ex <tab> | DBG_RXC(DbgInfo, BChannelIndex);

#   define DBG_FILTER(A,M,S){if ((A) && ((A)->DbgFlags & (M)))            \
                                {DbgPrint("%s:%s: ",(A)->DbgID,__FUNC__); \
                                 DbgPrint S;}}
    // @func VOID | DBG_FILTER |
    //
    // Use this macro to filter for specific DbgFlag combinations.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN DBG_FLAGS | DbgMask | OR'd mask of <t DBG_FLAGS>.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_FILTER(DbgInfo, DBG_FILTER1_ON | DBG_REQUEST_ON,
    //                 ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_DISPLAY(S)   {DbgPrint("%s: ",__FUNC__); DbgPrint S;}
    // @func VOID | DBG_DISPLAY |
    //
    // Use this macro to unconditionally report a message.  This macro does
    // not take a pointer to the DBG_SETTINGS structure, so it can be used in
    // any module or function of the driver.  There is no way to disable the
    // display of these messages.  The funcion name precedes the output string.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_DISPLAY(("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_PRINT(S)     {DbgPrint S;}
    // @func VOID | DBG_PRINT |
    //
    // Use this macro to unconditionally report a message.  This macro does
    // not take a pointer to the DBG_SETTINGS structure, so it can be used in
    // any module or function of the driver.  There is no way to disable the
    // display of these messages.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_PRINT(("What happened at line %d!\n",__LINE__));

//###############################################################################
#else // !DBG
//###############################################################################

#ifndef ASSERTS_ENABLED
#   define ASSERTS_ENABLED  0
#endif

#   define DBG_DEFAULTS (0)

/*
// When (DBG == 0) we disable all the debug macros.
*/

#   define STATIC           static
#   define DBG_STATIC       static
#   define TRAPFAULT        DbgBreakPoint()
#   define BREAKPOINT
#   define DBG_FUNC(F)
#   define DBG_BREAK
#   define DBG_ENTER(A)
#   define DBG_TRACE(A)
#   define DBG_LEAVE(A)
#   define DBG_RETURN(A,S)
#   define DBG_ERROR(A,S)
#   define DBG_WARNING(A,S)
#   define DBG_NOTICE(A,S)
#   define DBG_REQUEST(A,S)
#   define DBG_PARAMS(A,S)
#   define DBG_TX(A,I,N,P)
#   define DBG_TXC(A,I)
#   define DBG_RX(A,I,N,P)
#   define DBG_RXC(A,I)
#   define DBG_FILTER(A,M,S)
#   define DBG_DISPLAY(S)
#   define DBG_PRINT(S)

//###############################################################################
#endif // DBG
//###############################################################################

#ifdef ASSERT
#   undef ASSERT
#endif
#ifdef assert
#   undef  assert
#endif

#if ASSERTS_ENABLED
#define ASSERT(C)   if (!(C)) { \
                        DbgPrint("ASSERT(%s) -- FILE:%s LINE:%d\n", \
                                 #C, __FILE__, __LINE__); \
                        TRAPFAULT; \
                    }
    // @func VOID | ASSERT |
    //
    // Use this macro to conditionally report a fatal error if the condition
    // specified is NOT true.
    //
    // @parm BOOLEAN_EXPRESSION | Expression | Any valid if (Expression).
    //
    // @ex <tab> | ASSERT(Actual == Expected);

#   define assert(C) ASSERT(C)
#else // !ASSERTS_ENABLED
#   define ASSERT(C)
#   define assert(C)
#endif // ASSERTS_ENABLED


#endif // _TPIDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\tpimem.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiMem TpiMem_h

@module TpiMem.h |

    This module defines the interface to the memory allocation wrappers.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiMem_h

@end

*/

#ifndef _TPIMEM_H
#define _TPIMEM_H

#include <ndis.h>

#define TPIMEMORY_OBJECT_TYPE           ((ULONG)'T')+\
                                        ((ULONG)'M'<<8)+\
                                        ((ULONG)'E'<<16)+\
                                        ((ULONG)'M'<<24)

#define ALLOCATE_MEMORY(pObject, dwSize, MiniportAdapterHandle)\
            TpiAllocateMemory((PVOID *)&(pObject), dwSize,\
                              __FILEID__, __FILE__, __LINE__,\
                              MiniportAdapterHandle)

#define FREE_MEMORY(pObject, dwSize)\
            TpiFreeMemory((PVOID *)&(pObject), dwSize,\
                          __FILEID__, __FILE__, __LINE__)

#define ALLOCATE_OBJECT(pObject, MiniportAdapterHandle)\
            ALLOCATE_MEMORY(pObject, sizeof(*(pObject)), MiniportAdapterHandle)

#define FREE_OBJECT(pObject)\
            FREE_MEMORY(pObject, sizeof(*(pObject)))

#define FREE_NDISSTRING(ndisString)\
            FREE_MEMORY(ndisString.Buffer, ndisString.MaximumLength)

NDIS_STATUS TpiAllocateMemory(
    OUT PVOID *                 ppObject,
    IN ULONG                    dwSize,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber,
    IN NDIS_HANDLE              MiniportAdapterHandle
    );

void TpiFreeMemory(
    IN OUT PVOID *              ppObject,
    IN ULONG                    dwSize,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

NDIS_STATUS TpiAllocateSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN ULONG                    dwSize,
    IN BOOLEAN                  bCached,
    OUT PVOID *                 pVirtualAddress,
    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

void TpiFreeSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN ULONG                    dwSize,
    IN BOOLEAN                  bCached,
    OUT PVOID *                 pVirtualAddress,
    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

extern NDIS_PHYSICAL_ADDRESS g_HighestAcceptableAddress;

#endif // _TPIMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\tpiparam.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiParam TpiParam_c

@module TpiParam.c |

    This module, along with <f TpiParam\.h>, implements a table driven parser
    for the NDIS registry parameters.

@comm

    See <f Keywords\.h> for details of how to add new parameters.<nl>

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiParam_c

@end

*/

#define  __FILEID__     TPI_MODULE_PARAMS   // Unique file ID for error logging

#include <ndis.h>
#include "TpiDebug.h"
#include "TpiParam.h"

#if defined(_VXD_) && !defined(NDIS_LCODE)
#  define NDIS_LCODE code_seg("_LTEXT", "LCODE")
#  define NDIS_LDATA data_seg("_LDATA", "LCODE")
#endif

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif

static NDIS_PHYSICAL_ADDRESS    g_HighestAcceptableAddress =
                                    NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);

static NDIS_STRING              g_NullString =
                                    NDIS_STRING_CONST("\0");


/* @doc INTERNAL TpiParam TpiParam_c ustrlen


@func

    <f ustrlen> counts the number of characters in
    a UNICODE (wide) string.

@comm

@rdesc

    <f ustrlen> returns the length of the UNICODE string
    pointed to by <p string>.  The terminating NULL character is not
    counted.

*/
USHORT ustrlen(
    IN PUSHORT                  string                      // @parm
    // Pointer to the beginning of a UNICODE string ending
    // with a 0x0000 value.
    )
{
    USHORT                      ct;

    for (ct = 0; *string != 0x0000; string++, ct++)
        ;

    return(ct);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamUnicodeStringToAnsiString


@func

    <f ParamUnicodeStringToAnsiString> converts a double byte string to a
    single byte string.

@comm

    The original release of the NDIS Wrapper for Windows 95 and 3.1 does not
    return UNICODE strings from the NdisReadConfiguration routine.  So this
    routine attempts to auto detect this situation by examining the first
    character of the string.  If the second byte of the first character is
    a zero, the string is assumed to be UNICODE, and it is converted to an
    ANSI string; otherwise the ANSI string is just copied.
    <nl>
    <f Note>: This also assumes that the first character of any UNICODE
    string will not use the second byte (i.e. not an extended character).
    This routine will only successfully convert non-extended character
    strings anyway.

@xref
    <f ParamParseRegistry>
*/

VOID ParamUnicodeStringToAnsiString(
    OUT PANSI_STRING            out,                        // @parm
    // A pointer to where the converted ANSI string is to be stored.

    IN PUNICODE_STRING          in                          // @parm
    // A pointer to the UNICODE string to be converted.
    )
{
    DBG_FUNC("ParamUnicodeStringToAnsiString")

    UINT Index;

    /* CAVEAT - NDIS_BUG
    // NDIS driver for Windows 95 does not return UNICODE from
    // registry parser, so we need to kludge it up here.
    */
    if (in->Length > 1)
    {
        if (((PUCHAR)(in->Buffer))[1] == 0)
        {
            /*
            // Probably a UNICODE string since all our parameters are ASCII
            // strings.
            */
            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("UNICODE STRING IN @%x#%d='%ls'\n",
                       in->Buffer, in->Length, in->Buffer));
            for (Index = 0; Index < (in->Length / sizeof(WCHAR)) &&
                 Index < out->MaximumLength; Index++)
            {
                out->Buffer[Index] = (UCHAR) in->Buffer[Index];
            }
        }
        else
        {
            /*
            // Probably an ANSI string since all our parameters are more
            // than 1 byte long and should not be zero in the second byte.
            */
            PANSI_STRING in2 = (PANSI_STRING) in;

            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("ANSI STRING IN @%x#%d='%s'\n",
                       in2->Buffer, in2->Length, in2->Buffer));

            for (Index = 0; Index < in2->Length &&
                 Index < out->MaximumLength; Index++)
            {
                out->Buffer[Index] = in2->Buffer[Index];
            }
        }
    }
    else
    {
        DBG_WARNING(DbgInfo,("1 BYTE STRING IN @%x=%04x\n",
                    in->Buffer, in->Buffer[0]));
        out->Buffer[0] = (UCHAR) in->Buffer[0];
        Index = 1;
    }
    out->Length = (USHORT) Index; // * sizeof(UCHAR);

    // NULL terminate the string if there's room.
    if (out->Length <= (out->MaximumLength - sizeof(UCHAR)))
    {
        out->Buffer[Index] = 0;
    }
    ASSERT(out->Length <= out->MaximumLength);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamUnicodeCopyString


@func

    <f ParamUnicodeCopyString> copies a double byte string to a double byte
    string.

@comm

    The original release of the NDIS Wrapper for Windows 95 and 3.1 does not
    return UNICODE strings from the NdisReadConfiguration routine.  So this
    routine attempts to auto detect this situation by examining the first
    character of the string.  If the second byte of the first character is
    a zero, the string is assumed to be UNICODE, and it just copied;
    otherwise the ANSI string is converted to UNICODE.
    <nl>
    <f Note>: This also assumes that the first character of any UNICODE
    string will not use the second byte (i.e. not an extended character).
    This routine will only successfully convert non-extended character
    strings anyway.

@xref
    <f ParamParseRegistry>

*/

VOID ParamUnicodeCopyString(
    OUT PUNICODE_STRING         out,                        // @parm
    // A pointer to where the new UNICODE string is to be stored.

    IN PUNICODE_STRING          in                          // @parm
    // A pointer to the UNICODE string to be copied.
    )
{
    DBG_FUNC("ParamUnicodeCopyString")

    UINT Index;

    /* CAVEAT - NDIS_BUG
    // NDIS driver for Windows 95 does not return UNICODE from
    // registry parser, so we need to kludge it up here.
    */
    if (in->Length > 1)
    {
        if (((PUCHAR)(in->Buffer))[1] == 0)
        {
            /*
            // Probably a UNICODE string since all our parameters are ASCII
            // strings.
            */
            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("UNICODE STRING IN @%x#%d='%ls'\n",
                       in->Buffer, in->Length, in->Buffer));
            for (Index = 0; Index < (in->Length / sizeof(WCHAR)) &&
                 Index < (out->MaximumLength / sizeof(WCHAR)); Index++)
            {
                out->Buffer[Index] = in->Buffer[Index];
            }
        }
        else
        {
            /*
            // Probably an ANSI string since all our parameters are more
            // than 1 byte long and should not be zero in the second byte.
            */
            PANSI_STRING in2 = (PANSI_STRING) in;

            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("ANSI STRING IN @%x#%d='%s'\n",
                       in2->Buffer, in2->Length, in2->Buffer));
            for (Index = 0; Index < in2->Length &&
                 Index < (out->MaximumLength / sizeof(WCHAR)); Index++)
            {
                out->Buffer[Index] = (WCHAR) in2->Buffer[Index];
            }
        }
    }
    else
    {
        DBG_WARNING(DbgInfo,("1 BYTE STRING IN @%x=%04x\n",
                    in->Buffer, in->Buffer[0]));
        out->Buffer[0] = (WCHAR) in->Buffer[0];
        Index = 1;
    }
    out->Length = Index * sizeof(WCHAR);

    // NULL terminate the string if there's room.
    if (out->Length <= (out->MaximumLength - sizeof(WCHAR)))
    {
        out->Buffer[Index] = 0;
    }
    ASSERT(out->Length <= out->MaximumLength);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamGetNumEntries


@func

    <f ParamGetNumEntries> counts the number of records in the registry
    parameter table.

@rdesc

    <f ParamGetNumEntries> returns the number of entries in the parameter
    table.

@xref
    <f ParamParseRegistry>

*/

DBG_STATIC UINT ParamGetNumEntries(
    IN PPARAM_TABLE             Parameters                  // @parm
    // A pointer to an array of registry parameter records.
    )
{
    UINT NumRecs = 0;

    /*
    // Scan the parameter array until we find an entry with zero length name.
    */
    if (Parameters)
    {
        while (Parameters->RegVarName.Length)
        {
            NumRecs++;
            Parameters++;
        }
    }
    return(NumRecs);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamParseRegistry


@func

    <f ParamParseRegistry> parses the registry parameter table and attempts
    to read a value from the registry for each parameter record.

@rdesc

    <f ParamParseRegistry> returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE

@xref
    <f MiniportInitialize>
    <f ParamGetNumEntries>
    <f NdisOpenConfiguration>
    <f NdisWriteErrorLogEntry>
    <f NdisReadConfiguration>
    <f NdisCloseConfiguration>
    <f NdisAllocateMemory>
    <f NdisZeroMemory>
    <f ParamUnicodeStringToAnsiString>
    <f ParamUnicodeCopyString>
*/

NDIS_STATUS ParamParseRegistry(
    IN NDIS_HANDLE              AdapterHandle,              // @parm
    // Handle to pass to NdisWriteErrorLogEntry if any errors are encountered.

    IN NDIS_HANDLE              WrapperConfigurationContext,// @parm
    // Handle to pass to NdisOpenConfiguration.

    IN PUCHAR                   BaseContext,                // @parm
    // References the base of the structure where the values read from the
    // registry are written.  Typically, this will be a pointer to the first
    // byte of the adapter information structure.

    IN PPARAM_TABLE             Parameters                  // @parm
    // A pointer to an array of registry parameter records <t PARAM_TABLE>.
    )
{
    DBG_FUNC("ParamParseRegistry")

    PNDIS_CONFIGURATION_PARAMETER   pReturnedValue;
    NDIS_CONFIGURATION_PARAMETER    ReturnedValue;
    NDIS_PARAMETER_TYPE             ParamType;

    /*
    // The handle for reading from the registry.
    */
    NDIS_HANDLE     ConfigHandle;

    UINT            NumRecs = ParamGetNumEntries(Parameters);
    UINT            i;
    PPARAM_TABLE    pParameter;
    NDIS_STATUS     Status;
    UINT            Value;
    PANSI_STRING    pAnsi;
    UINT            Length;

    /*
    // Open the configuration registry so we can get our config values.
    */
    NdisOpenConfiguration(
            &Status,
            &ConfigHandle,
            WrapperConfigurationContext
            );

    if (Status != NDIS_STATUS_SUCCESS)
    {
        /*
        // Log error message and exit.
        */
        DBG_ERROR(DbgInfo,("NdisOpenConfiguration failed (Status=%X)\n",Status));

        NdisWriteErrorLogEntry(
                AdapterHandle,
                NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                3,
                Status,
                __FILEID__,
                __LINE__
                );
        return NDIS_STATUS_FAILURE;
    }

    /*
    // Walk through all the parameters in the table.
    */
    for (i = 0, pParameter = Parameters; i < NumRecs; i++, pParameter++)
    {
#if DBG
        ANSI_STRING ansiRegString;
        char        ansiRegName[64];

        /*
        // Get a printable parameter name.
        */
        ansiRegString.Length = 0;
        ansiRegString.MaximumLength = sizeof(ansiRegName);
        ansiRegString.Buffer = (PCHAR)ansiRegName;
        NdisZeroMemory(ansiRegName, sizeof(ansiRegName));
        ParamUnicodeStringToAnsiString(
                &ansiRegString,
                (PUNICODE_STRING)&pParameter->RegVarName
                );
#endif // DBG

        ASSERT(pParameter->Type <= (UINT) NdisParameterMultiString);

        /*
        // Attempt to read the parameter value from the registry.
        */
        ParamType = (NDIS_PARAMETER_TYPE) pParameter->Type;
        NdisReadConfiguration(&Status,
                              &pReturnedValue,
                              ConfigHandle,
                              &pParameter->RegVarName,
                              ParamType
                             );
        /*
        // If value is not present, and it is mandatory, return failure code.
        */
        if (Status != NDIS_STATUS_SUCCESS && pParameter->Mandantory)
        {
            /*
            // Log error message and exit.
            */
            DBG_ERROR(DbgInfo,("%s: NOT IN REGISTRY!\n",
                      ansiRegName));

            NdisWriteErrorLogEntry(
                    AdapterHandle,
                    NDIS_ERROR_CODE_MISSING_CONFIGURATION_PARAMETER,
                    4,
                    i,
                    Status,
                    __FILEID__,
                    __LINE__
                    );

            NdisCloseConfiguration(ConfigHandle);
            return NDIS_STATUS_FAILURE;
        }

        /*
        // Determine how the caller wants to interpret this parameter.
        */
        if (ParamType == NdisParameterInteger ||
            ParamType == NdisParameterHexInteger)
        {
            ASSERT(pParameter->Size <= sizeof(ULONG));

            /*
            // If value read, use it, otherwise use default.
            */
            if (Status == NDIS_STATUS_SUCCESS)
            {
                Value = pReturnedValue->ParameterData.IntegerData;
            }
            else
            {
                Value = (UINT) (LONG_PTR)(pParameter->Default);
            }

            /*
            // If there are min/max boundaries, verify that value is in range.
            */
            if (pParameter->Min || pParameter->Max)
            {
                if (Value < pParameter->Min)
                {
                    DBG_ERROR(DbgInfo,("%s: Value=%X < Min=%X\n",
                              ansiRegName, Value, pParameter->Min));
                    Value = pParameter->Min;
                }
                else if (Value > pParameter->Max)
                {
                    DBG_ERROR(DbgInfo,("%s: Value=%X > Max=%X\n",
                              ansiRegName, Value, pParameter->Max));
                    Value = pParameter->Max;
                }
            }

            /*
            // Size of destination in bytes 1, 2, or 4 (default==INT).
            */
            switch (pParameter->Size)
            {
            case 0:
                *(PUINT)(BaseContext+pParameter->Offset)   = (UINT) Value;
                break;

            case 1:
                if (Value & 0xFFFFFF00)
                {
                    DBG_WARNING(DbgInfo,("%s: OVERFLOWS UCHAR\n",
                                ansiRegName));
                }
                *(PUCHAR)(BaseContext+pParameter->Offset)  = (UCHAR) Value;
                break;

            case 2:
                if (Value & 0xFFFF0000)
                {
                    DBG_WARNING(DbgInfo,("%s: OVERFLOWS USHORT\n",
                                ansiRegName));
                }
                *(PUSHORT)(BaseContext+pParameter->Offset) = (USHORT) Value;
                break;

            case 4:
                *(PULONG)(BaseContext+pParameter->Offset)  = (ULONG) Value;
                break;

            default:
                DBG_ERROR(DbgInfo,("%s: Invalid ParamSize=%d\n",
                          ansiRegName, pParameter->Size));
                NdisCloseConfiguration(ConfigHandle);
                return NDIS_STATUS_FAILURE;
                break;
            }

            if (ParamType == NdisParameterInteger)
            {
                DBG_PARAMS(DbgInfo,("%s: Value=%d Size=%d (%s)\n",
                           ansiRegName, Value, pParameter->Size,
                           (Status == NDIS_STATUS_SUCCESS) ?
                           "Registry" : "Default"));
            }
            else
            {
                DBG_PARAMS(DbgInfo,("%s: Value=0x%X Size=%d (%s)\n",
                           ansiRegName, Value, pParameter->Size,
                           (Status == NDIS_STATUS_SUCCESS) ?
                           "Registry" : "Default"));
            }
        }
        else if (ParamType == NdisParameterString ||
                 ParamType == NdisParameterMultiString)
        {
            ASSERT(pParameter->Size == sizeof(ANSI_STRING));

            /*
            // If value not read from registry.
            */
            if (Status != NDIS_STATUS_SUCCESS)
            {
                /*
                // Use our own temporary ReturnedValue.
                */
                pReturnedValue = &ReturnedValue;
                pReturnedValue->ParameterType = ParamType;

                /*
                // If default non-zero, use default value.
                */
                if (pParameter->Default != 0)
                {
                    NdisMoveMemory(&pReturnedValue->ParameterData.StringData,
                                   (PANSI_STRING) pParameter->Default,
                                   sizeof(ANSI_STRING));
                }
                else
                {
                    /*
                    // Otherwise, use null string value.
                    */
                    NdisMoveMemory(&pReturnedValue->ParameterData.StringData,
                                   &g_NullString,
                                   sizeof(g_NullString));
                }
            }

            /*
            // Assume the string is ANSI and points to the string data
            // structure.  We can get away with this because ANSI and
            // UNICODE strings have a common structure header.  An extra
            // character is allocated to make room for a null terminator.
            */
            pAnsi = (PANSI_STRING) (BaseContext+pParameter->Offset);
            Length = pReturnedValue->ParameterData.StringData.Length+1;

            /*
            // The caller wants a UNICODE string returned, we have to
            // allocated twice as many bytes to hold the result.
            // NOTE:
            // This wouldn't be necessary if NDIS would always return
            // a UNICODE string, but some Win95 versions of NDIS return
            // an ANSI string, so Length will be too small for UNICODE.
            // The down-side is that we may allocate twice as much as
            // we need to hold the string.  (oh well)
            */
            if (pParameter->Flags == PARAM_FLAGS_UNICODESTRING)
            {
                Length *= sizeof(WCHAR);
            }

            /*
            // Allocate memory for the string.
            */
#if !defined(NDIS50_MINIPORT)
            Status = NdisAllocateMemory(
                            (PVOID *) &(pAnsi->Buffer),
                            Length,
                            0,
                            g_HighestAcceptableAddress
                            );
#else  // NDIS50_MINIPORT
            Status = NdisAllocateMemoryWithTag(
                            (PVOID *) &(pAnsi->Buffer),
                            Length,
                            __FILEID__
                            );
#endif // NDIS50_MINIPORT

            if (Status != NDIS_STATUS_SUCCESS)
            {
                /*
                // Log error message and exit.
                */
                DBG_ERROR(DbgInfo,("NdisAllocateMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                          Length, __FILE__, __LINE__, Status));

                NdisWriteErrorLogEntry(
                        AdapterHandle,
                        NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                        4,
                        Status,
                        Length,
                        __FILEID__,
                        __LINE__
                        );
                NdisCloseConfiguration(ConfigHandle);
                return NDIS_STATUS_FAILURE;
            }
            else
            {
                DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                           ("NdisAllocateMemory(Size=%d, Ptr=0x%x)\n",
                            Length, pAnsi->Buffer));
            }
            /*
            // Zero the string buffer to start with.
            */
            ASSERT(pAnsi->Buffer);
            NdisZeroMemory(pAnsi->Buffer, Length);
            pAnsi->MaximumLength = (USHORT) Length;

            if (pParameter->Flags == PARAM_FLAGS_ANSISTRING)
            {
                /*
                // The caller wants an ANSI string returned, so we convert
                // it from UNICODE to ANSI.
                */
                ParamUnicodeStringToAnsiString(
                        pAnsi,
                        (PUNICODE_STRING) &(pReturnedValue->ParameterData.StringData)
                        );
#if DBG
                if (ParamType == NdisParameterMultiString)
                    {
                    USHORT        ct = 0;

                    while (ct < pAnsi->Length)
                        {
                        DBG_PARAMS(DbgInfo,("%s: ANSI='%s' Len=%d of %d\n",
                            ansiRegName,
                            &(pAnsi->Buffer[ct]),
                            (strlen(&(pAnsi->Buffer[ct]))),
                            pAnsi->Length));

                        ct = ct + (strlen(&(pAnsi->Buffer[ct])) + 1);
                        }
                    }
                else
                    {
                    DBG_PARAMS(DbgInfo,("%s: ANSI='%s' Len=%d\n",
                           ansiRegName, pAnsi->Buffer, pAnsi->Length));
                    }
#endif
            }
            else // PARAM_FLAGS_UNICODESTRING
            {
                /*
                // The caller wants a UNICODE string returned, so we can
                // just copy it.  The pAnsi buffer was allocated large
                // enough to hold the UNICODE string.
                */
                ParamUnicodeCopyString(
                        (PUNICODE_STRING) pAnsi,
                        (PUNICODE_STRING) &(pReturnedValue->ParameterData.StringData)
                        );
#if DBG
                if (ParamType == NdisParameterMultiString)
                    {
                    USHORT        ct = 0;

                    BREAKPOINT;

                    while (ct < (pAnsi->Length / 2))
                        {
                        DBG_PARAMS(DbgInfo,("%s: UNICODE='%ls' Len=%d of %d\n",
                           ansiRegName,
                           &((PUSHORT)pAnsi->Buffer)[ct],
                           (ustrlen(&((PUSHORT)pAnsi->Buffer)[ct]) * 2),
                           pAnsi->Length));

                        ct = ct + (ustrlen(&((PUSHORT)pAnsi->Buffer)[ct]) + 1);
                        }
                    }
                else
                    {
                    DBG_PARAMS(DbgInfo,("%s: UNICODE='%ls' Len=%d\n",
                               ansiRegName, pAnsi->Buffer, pAnsi->Length));
                    }
#endif

            }
        }
        else
        {
            /*
            // Report a bogus parameter type in the caller's table.
            */
            DBG_ERROR(DbgInfo,("Invalid ParamType=%d '%s'\n",
                      ParamType, ansiRegName));

            NdisCloseConfiguration(ConfigHandle);
            return NDIS_STATUS_FAILURE;
        }
    }
    NdisCloseConfiguration(ConfigHandle);
    return(NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\tpiparam.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiParam TpiParam_h

@module TpiParam.h |

    This module, along with <f TpiParam\.c>, implements a table driven parser
    for the NDIS registry parameters.  This file defines the parameter
    parsing structures and values used by the routine <f ParamParseRegistry>.
    You should #include this file into the driver module defining the
    configuration parameter table <t PARAM_TABLE>.

@comm

    See <f Keywords\.h> for details of how to add new parameters.

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiParam_h

@end

*/

#ifndef _TPIPARAM_H
#define _TPIPARAM_H

#if !defined(NDIS_NT) && !defined(UNICODE_NULL)

/*
// These types were culled from the NT ndis.h file
// We should be compiling with the NT DDK's ndis.h to get these,
// but sometimes we need to compile with the 95 DDK ndis.h.
*/

#undef PUNICODE_STRING
typedef USHORT  WCHAR;
typedef WCHAR   *PWSTR;

typedef STRING  ANSI_STRING;
typedef PSTRING PANSI_STRING;

/*
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
*/

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;

typedef UNICODE_STRING *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

#endif // NDIS_NT

/* @doc INTERNAL TpiParam TpiParam_h PARAM_ENTRY


@func <t PARAM_TABLE> | PARAM_ENTRY |

    This macro is used to define an entry in the registry parameter table,
    one entry per parameter.  See <t PARAM_TABLE> for more details on the
    expected input values.

@parm struct | Strct | The structure type associated with <f Field>.

@parm type | Field | The name of the field within the structure <f Strct>.

@parm const char * | Name | The name of the registry parameter key.

@parm BOOL | Required | True if parameter is required.

@parm NDIS_PARAMETER_TYPE | Type | The kind of parameter value.

@parm UCHAR | Flags | How to return a string parameter value (ANSI, UNICODE).

@parm UINT | Default | The default value for an undefined integer parameter.

@parm UINT | Min | The minimum value for an integer parameter.

@parm UINT | Max | The minimum value for an integer parameter.

@comm
    Parameters that need to be stored in different data structures, need to
    be declared in separate parameter tables, and then parsed separately
    using mulitple calls to <f ParamParseRegistry>.

@iex
    PARAM_TABLE ParameterTable[] =
    {
        PARAM_ENTRY(MINIPORT_CONTEXT, DbgFlags, PARAM_DEBUGFLAGS_STRING,
                    FALSE, NdisParameterHexInteger, 0,
                    DBG_ERROR_ON|DBG_WARNING_ON, 0, 0xffffffff),
        // The last entry must be an empty string!
        { { 0 } }
    };

@normal
*/
#if defined(_IA64_)
# define PARAM_OFFSET(Strct, Field) ((LONG)(LONG_PTR)&(((Strct *)0)->Field))
#else
# define PARAM_OFFSET(Strct, Field) ((UINT)((PUCHAR) &((Strct *) 0)->Field))
#endif
#define PARAM_SIZEOF(Strct, Field) sizeof(((Strct *) 0)->Field)
#define PARAM_ENTRY(Strct, Field, Name, \
                    Required, Type, Flags, \
                    Default, Min, Max) \
    { NDIS_STRING_CONST(Name), \
      Required, \
      Type, \
      Flags, \
      PARAM_SIZEOF(Strct, Field), \
      PARAM_OFFSET(Strct, Field), \
      (PVOID) (Default), \
      Min, \
      Max }


/* @doc INTERNAL TpiParam TpiParam_h PARAM_TABLE


@struct PARAM_TABLE |
    This structure defines how a parameter is to be parsed from the Windows
    registry.  The driver declares an array of these parameter records and
    passes it to <f ParamParseRegistry> during initialization.  The values
    for each parameter are then read from the registry and can be used to
    configure the driver.
    <nl>
    <f Note>: Multiple parameter tables can be used to parse parameters that
    must be stored in different memory locations.
*/
typedef struct PARAM_TABLE
{
    NDIS_STRING     RegVarName; // @field
    // Parameter name string declared as an <t NDIS_STRING>.  The registry
    // parameter key must match this string.

    UCHAR           Mandantory; // @field
    // Set to FALSE, zero, if parameter value is optional; otherwise set to
    // TRUE, non-zero, if the parameter is required to exist in the registry.
    // If FALSE, and the parameter does not exist, the <y Default> value will
    // be returned.  If TRUE, and the parameter does not exist, an error code
    // is returned and no further parsing is done.

    UCHAR           Type;       // @field
    // This value determines how the parameter will be parsed from the
    // registry.  The value can be one of the following values defined
    // by <t NDIS_PARAMETER_TYPE>.
    // <nl>0=NdisParameterInteger - Decimal integer value.
    // <nl>1=NdisParameterHexInteger - Hexadecimal integer value.
    // <nl>2=NdisParameterString - Single UNICODE string value.
    // <nl>3=NdisParameterMultiString - Multiple UNICODE string values.
    // These are returned as a list of N strings, separated by NULL
    // terminators, the last string is followed by two NULL terminators.

    UCHAR           Flags;      // @field
    // This value determines how a string parameter will be translated before
    // it is returned to the caller.  <f Flags> can be one of the following
    // values:
    // <nl>0=PARAM_FLAGS_ANSISTRING - Return string value as an ANSI string.
    // <nl>0=PARAM_FLAGS_ANSISTRING - Return string value as a UNICODE string.
#   define          PARAM_FLAGS_ANSISTRING      0
#   define          PARAM_FLAGS_UNICODESTRING   1

    UCHAR           Size;       // @field
    // This value determines how an integer parameter will be translated
    // before it is returned to the caller.  <f Size> can be one of the
    // following values:
    // <nl>0=UINT   - unsigned integer (16 or 32 bits).
    // <nl>1=UCHAR  - unsigned char integer (8 bits).
    // <nl>2=USHORT - unsigned short integer (16 bits).
    // <nl>4=ULONG  - unsigned long integer (32 bits).
    // <f Note>: The most-significant bits will be truncated in the conversion.

    UINT            Offset;     // @field
    // This value indicates the offset, in bytes, from the <f BaseContext>
    // pointer passed into <f ParamParseRegistry>.  The return value for
    // the parameter will be saved at this offset from <f BaseContext>.
    // <nl>*(PUINT)((PUCHAR)BaseContext+Offset) = (UINT) Value;

    PVOID           Default;    // @field
    // This value is used as the default value for the parameter if it is
    // not found in the registry, and it is not mandatory.  This only applys
    // to integer parameters.  String parameters must provide support for
    // their own default values.

    UINT            Min;        // @field
    // If this value is non-zero, and the parameter is an integer type, the
    // registry value will be compared to make sure it is \>= <f Min>.
    // If the registry value is less, the returned value will be set to
    // <f Min> and no error is returned.

    UINT            Max;        // @field
    // If this value is non-zero, and the parameter is an integer type, the
    // registry value will be compared to make sure it is \<= <f Max>.
    // If the registry value is greater, the returned value will be set to
    // <f Max> and no error is returned.

    UINT            Reserved;   // @field
    // This field is not currently used, and it must be zero for future
    // compatability.

} PARAM_TABLE, *PPARAM_TABLE;

extern USHORT ustrlen(
    IN PUSHORT          string
    );

extern NDIS_STATUS ParamParseRegistry(
    IN NDIS_HANDLE      AdapterHandle,
    IN NDIS_HANDLE      RegistryConfigHandle,
    IN PUCHAR           BaseContext,
    IN PPARAM_TABLE     Parameters
    );

extern VOID ParamUnicodeStringToAnsiString(
    OUT PANSI_STRING out,
    IN PUNICODE_STRING in
    );

extern VOID ParamUnicodeCopyString(
    OUT PUNICODE_STRING out,
    IN PUNICODE_STRING in
    );

#endif // _TPIPARAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\vlang.h ===
// Define the language and sublanguge supported by your program.
#define VER_LANGUAGE_NUM                0x0409
#define VER_SUBLANGUAGE_NUM             0x04B0
// Concatenate the two, 4 digit hex numbers above.
#define VER_LANGUAGE_STRING             "040904B0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\vproduct.h ===
/*

                                                                             
    (C) Copyright 1999 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiBuild vProduct vProduct_h

@module vProduct.h |

    This module defines the product version information.  It is included by 
    all the target components of the project by including <f vTarget\.h>.

    <f Note>:
    This file should not be changed.  The definitions used by this file 
    are defined in <f vVendor\.h>, <f vTarget\.h>, <f vProdNum\.h>, and 
    <f vTargNum\.h>

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vProduct_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic Versioning Overview |

    This section describes the interfaces defined in <f vProduct\.h>,
    <f vVendor\.h>, <f vTarget\.h>, <f vProdNum\.h>, and <f vTargNum\.h>

    A module is usually just one component of an entire product, so we've
    defined the versioning information for the module so that it can be
    easily included into a complete product package.
    
@flag <f vTarget\.rc> |
    Included this into your module specific rc file.  Do not change.
    You must remove any existing versioning information from your rc file.
    Place this file in a common include directory for the product.

@flag <f vTarget\.h> |
    Defines the module specific version information such as file name, type, etc.
    One of these files would exist for each component included in your product.

@flag <f vTargNum\.h> |
    Is meant to be updated whenever you make a change to a specific module.
    One of these files would exist for each component included in your product.
    This is separated from the rest of the versioning files so it can be easily 
    updated with a tool or script.
    
@flag <f vVendor\.h> |
    Defines the vendor specific version information such as company name,
    copyright. etc.  It is separate to allow easier OEM customization.
    Place this file in a common include directory for the product.
    
@flag <f vProdNum\.h> |
    Is meant to be updated whenever you release a new product version.
    This is separated from the rest of the versioning files so it can be easily 
    updated with a tool or script.
    Place this file in a common include directory for the product.
    
@flag <f vLang\.h> |
    Defines the language to be used to record the version information.
    If this file is modified for another language, you will generally have 
    to create localized versions of the vVendor.h and vTarget.h files as well.
    Place this file in a common include directory for the product.
    
@flag <f vProduct\.rc> |
    Is included by <f vTarget\.rc>.  Do not change.
    Place this file in a common include directory for the product.

@flag <f vProduct\.h> |
    Is included by <f vTarget\.h>.  You should not change this file unless you
    want to change the way version numbers are represented for all modules in
    your product.
    Place this file in a common include directory for the product.

*/

#ifndef _VPRODUCT_H_
#define _VPRODUCT_H_

#if !defined(_VTARGET_H_)
#  error You should not include vProduct.h directly, include vTarget.h instead.
#endif

// Only include winver.h if RC_INVOKED.  Otherwise we don't need it.
#if defined(RC_INVOKED)
# if defined(WIN32)
#  include <winver.h>
# else
#  include <ver.h>
# endif
#endif

#include "vVendor.h"    // Edit this file to change vendor specific information
#include "vLang.h"      // Edit this file to change language specific information

// The following file should be included from the target's include directory
#include "vTargNum.h"   // Target version information

#if !defined(VER_FILE_MAJOR_NUM) || !defined(VER_FILE_MINOR_NUM) || \
    !defined(VER_FILE_SUB_MINOR_NUM)
#  error Your vTargNum.h file is corrupt or missing required VER_xxx_NUM fields.
#endif
#if !defined(VER_FILE_MAJOR_STR) || !defined(VER_FILE_MINOR_STR) || \
    !defined(VER_FILE_SUB_MINOR_STR)
#  error Your vTargNum.h file is corrupt or missing required VER_xxx_STR fields.
#endif

// The following file should be included from the project's include directory
#include "vProdNum.h"   // Product version and build information

#if !defined(VER_PRODUCT_MAJOR_NUM) || !defined(VER_PRODUCT_MINOR_NUM) || \
    !defined(VER_PRODUCT_SUB_MINOR_NUM) || !defined(VER_PRODUCT_BUILD_NUM)
#  error Your vProdNum.h file is corrupt or missing required VER_xxx_NUM fields.
#endif
#if !defined(VER_PRODUCT_MAJOR_STR) || !defined(VER_PRODUCT_MINOR_STR) || \
    !defined(VER_PRODUCT_SUB_MINOR_STR) || !defined(VER_PRODUCT_BUILD_STR)
#  error Your vProdNum.h file is corrupt or missing required VER_xxx_STR fields.
#endif

// Macro used to force C preprocessor to concatenate string defines
#define DEFINE_STRING(STR)              STR

// Macro to make this stuff easier to read.
#define VER_STR_CAT(sep,maj,min,sub,bld) maj sep min sep sub sep bld

// PRODUCT version information is displayed in the About box of each
// component and is stored in the registry during installation.
// The About box code must get the value from the registry instead of
// using these macros in order to get the currently installed version.
// Therefore, these macros should only be used by the installer.
#define VER_PRODUCT_VERSION_NUM         ((VER_PRODUCT_MAJOR_NUM << 24) | \
                                            (VER_PRODUCT_MINOR_NUM << 16) | \
                                            (VER_PRODUCT_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_PRODUCT_VERSION_NUM_RC      VER_PRODUCT_MAJOR_NUM,\
                                            VER_PRODUCT_MINOR_NUM,\
                                            VER_PRODUCT_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_PRODUCT_VERSION_STR         VER_STR_CAT(".",\
                                            VER_PRODUCT_MAJOR_STR,\
                                            VER_PRODUCT_MINOR_STR,\
                                            VER_PRODUCT_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_PRODUCT_VERSION_STR_RC      VER_STR_CAT(".",\
                                            VER_PRODUCT_MAJOR_STR,\
                                            VER_PRODUCT_MINOR_STR,\
                                            VER_PRODUCT_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

// COMPONENT version information is displayed in the ProductVersion 
// field of a file's Windows property sheet.  It is the same as the
// FILE version info with the addition of the build number.
#define VER_COMPONENT_VERSION_NUM       ((VER_FILE_MAJOR_NUM << 24) | \
                                            (VER_FILE_MINOR_NUM << 16) | \
                                            (VER_FILE_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_COMPONENT_VERSION_NUM_RC    VER_FILE_MAJOR_NUM,\
                                            VER_FILE_MINOR_NUM,\
                                            VER_FILE_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_COMPONENT_VERSION_STR       VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_COMPONENT_VERSION_STR_RC    VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

// FILE version information is an abbreviated component version info
// and is displayed at the top of a file's Windows property sheet.
#define VER_FILE_VERSION_NUM            ((VER_FILE_MAJOR_NUM << 24) | \
                                            (VER_FILE_MINOR_NUM << 16) | \
                                            (VER_FILE_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_FILE_VERSION_NUM_RC         VER_FILE_MAJOR_NUM,\
                                            VER_FILE_MINOR_NUM,\
                                            VER_FILE_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_FILE_VERSION_STR            VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_FILE_VERSION_STR_RC         VER_FILE_MAJOR_STR "."\
                                            VER_FILE_MINOR_STR "."\
                                            VER_FILE_SUB_MINOR_STR

#endif /* _VPRODUCT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\vprodnum.h ===
// WARNING --- DO NOT CHANGE THIS FILE --- WARNING
// It is updated automatically by the TpiBuild procedure using VerInc.exe.
#define VER_PRODUCT_MAJOR_NUM      0
#define VER_PRODUCT_MINOR_NUM      7
#define VER_PRODUCT_SUB_MINOR_NUM  0
#define VER_PRODUCT_BUILD_NUM      30
#define VER_PRODUCT_MAJOR_STR      "0"
#define VER_PRODUCT_MINOR_STR      "07"
#define VER_PRODUCT_SUB_MINOR_STR  "00"
#define VER_PRODUCT_BUILD_STR      "0030"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\vtarget.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiBuild vTarget vTarget_h

@module vTarget.h |

    This module defines the version information as displayed in the Windows
    file property sheet.  You must change the fields below as appropriate
    for your target.  This file is then included by <f vTarget\.rc> to
    define the necessary elements of the target file's version resource.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vTarget_h

@end

*/

#ifndef _VTARGET_H_
#define _VTARGET_H_

// The following file should be included from the project's include directory
#include <vProduct.h>   // Product specific information

// Base name of this target.
#define VER_TARGET_STR                  VER_PRODUCT_STR
// File name this target is distributed under.
#define VER_ORIGINAL_FILE_NAME_STR      DEFINE_STRING(VER_TARGET_STR ".sys")
// Description displayed in the Windows file property sheet - limit to 40 characters.
#define VER_FILE_DESCRIPTION_STR        DEFINE_STRING(VER_PRODUCT_STR \
                                        " NDIS WAN/TAPI Miniport for Windows.")
// Take credit for a job well done...
#define VER_INTERNAL_NAME_STR           "larryh@tpi.com"
// Look in winver.h for the proper settings of these values.
#define VER_FILE_OS                     VOS__WINDOWS32      // dwFileOS
#define VER_FILE_TYPE                   VFT_DRV             // dwFileType
#define VER_FILE_SUB_TYPE               VFT2_DRV_NETWORK    // dwFileSubtype

#endif // _VTARGET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\vtargnum.h ===
// WARNING --- DO NOT CHANGE THIS FILE --- WARNING
// It is updated automatically by the TpiBuild procedure using VerInc.exe.
#define VER_FILE_MAJOR_NUM      0
#define VER_FILE_MINOR_NUM      7
#define VER_FILE_SUB_MINOR_NUM  0
#define VER_FILE_MAJOR_STR      "0"
#define VER_FILE_MINOR_STR      "07"
#define VER_FILE_SUB_MINOR_STR  "00"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\transmit.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Transmit Transmit_c

@module Transmit.c |

    This module implements the Miniport packet Transmit routines. This module is
    very dependent on the hardware/firmware interface and should be looked at
    whenever changes to these interfaces occur.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Transmit_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.3 Sending Packets |

    To send packets over the network, a connection-oriented client or call
    manger calls NdisCoSendPackets. A connection-oriented client associated with
    an MCM also calls NdisCoSendPackets. An MCM, however, never calls
    NdisCoSendPackets; instead, since the interface between the call manager and
    MCM is internal to the MCM, the MCM passes packets directly to the NIC
    without notifying NDIS.

@ex Sending packets through an MCM |

    NdisWan                           NDIS                        Miniport
    |----------------------------------|----------------------------------|
    |  NdisCoSendPackets               |                                  |
    |---------------------------------|                                  |
    |                                  |  MiniportCoSendPackets           |
    |                                  |---------------------------------|
    |                                  |            .                     |
    |                                  |            .                     |
    |                                  |            .                     |
    |                                  |  NdisMCoSendComplete             |
    |                                  |---------------------------------|
    |  ProtocolCoSendComplete          |                                  |
    |---------------------------------|                                  |
    |----------------------------------|----------------------------------|

@normal

    MiniportCoSendPackets should transmit each packet in the array sequentially,
    preserving the order of packets in the array. MiniportCoSendPackets can call
    NdisQueryPacket to extract information, such as the number of buffer
    descriptors chained to the packet and the total size in bytes of the
    requested transfer.

    MiniportCoSendPackets can call NdisGetFirstBufferFromPacket,
    NdisQueryBuffer, or NdisQueryBufferOffset to extract information about
    individual buffers containing the data to be transmitted.
    MiniportCoSendPackets can retrieve protocol-supplied OOB information
    associated with each packet by using the appropriate NDIS_GET_PACKET_XXX
    macros. The MiniportCoSendPackets function usually ignores the Status member
    of the NDIS_PACKET_OOB_DATA block, but it can set this member to the same
    status that it subsequently passes to NdisMCoSendComplete.

    Rather than relying on NDIS to queue and resubmit send packets whenever
    MiniportCoSendPackets has insufficient resources to transmit the given
    packets, a connection-oriented miniport manages its own internal packet
    queueing. The miniport must hold incoming send packets in its internal queue
    until they can be transmitted over the network. This queue preserves the
    protocol-determined ordering of packet descriptors incoming to the
    miniport's MiniportCoSendPackets function.

    A connection-oriented miniport must complete each incoming send packet with
    NdisMCoSendComplete. It cannot call NdisMSendResourcesAvailable. A
    connection-oriented miniport should never pass STATUS_INSUFFICIENT_RESOURCES
    to NdisMCoSendComplete with a protocol-allocated packet descriptor that was
    originally submitted to its MiniportCoSendPackets function.

    The call to NdisMCoSendComplete causes NDIS to call the
    ProtocolCoSendComplete function of the client that initiated the send
    operation. ProtocolCoSendComplete performs any postprocessing necessary for
    a completed transmit operation, such as notifying the client that originally
    requested the protocol to send data over the network on the VC.

    Completion of a send operation usually implies that the underlying NIC
    driver actually has transmitted the given packet over the network. However,
    the driver of an "intelligent" NIC can consider a send complete as soon as
    it downloads the net packet to its NIC.

    Although NDIS always submits protocol-supplied packet arrays to the
    underlying miniport in the protocol-determined order passed in calls to
    NdisCoSendPackets, the underlying driver can complete the given packets in
    random order. That is, every bound protocol can rely on NDIS to submit the
    packets the protocol passes to NdisCoSendPackets in FIFO order to the
    underlying driver, but no protocol can rely on that underlying driver to
    call NdisMCoSendComplete with those packets in the same order.

@end
*/

#define  __FILEID__             TRANSMIT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Transmit Transmit_c TransmitAddToQueue


@func

    <f TransmitAddToQueue> places the packet on the transmit queue.  If the
    queue was empty to begin with, TRUE is returned so the caller can kick
    start the transmiter.

@rdesc

    <f TransmitAddToQueue> returns TRUE if this is the only entry in the
    list, FALSE otherwise.

*/

DBG_STATIC BOOLEAN TransmitAddToQueue(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PNDIS_PACKET             pNdisPacket                 // @parm
    // A pointer to the associated NDIS packet structure <t NDIS_PACKET>.
    )
{
    DBG_FUNC("TransmitAddToQueue")

    BOOLEAN                     ListWasEmpty;
    // Note if the list is empty to begin with.

    DBG_ENTER(pAdapter);

    /*
    // Place the packet on the TransmitPendingList.
    */
    NdisAcquireSpinLock(&pAdapter->TransmitLock);
    *((PBCHANNEL_OBJECT *) &pNdisPacket->MiniportReservedEx[8]) = pBChannel;
    ListWasEmpty = IsListEmpty(&pAdapter->TransmitPendingList);
    InsertTailList(&pAdapter->TransmitPendingList,
                   GET_QUEUE_FROM_PACKET(pNdisPacket));
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    DBG_RETURN(pAdapter, ListWasEmpty);
    return (ListWasEmpty);
}


/* @doc INTERNAL Transmit Transmit_c TransmitPacketHandler


@func

    <f TransmitPacketHandler> removes an entry from the TransmitPendingList
    and places the packet on the appropriate B-channel and starts the
    transmission.  The packet is then placed on the <t TransmitBusyList> to
    await a transmit complete event processed by <f TransmitCompleteHandler>.

@comm

    The packets go out in a FIFO order for the entire driver, independent of
    the channel on which it goes out.  This means that a slow link, or one
    that is backed up can hold up all other channels.  There is no good way
    to get around this because we must to deliver packets in the order they
    are given to the Miniport, regardless of the link they are on.

*/

DBG_STATIC VOID TransmitPacketHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("TransmitPacketHandler")

    PNDIS_PACKET                pNdisPacket;
    // Holds the packet being transmitted.

    UINT                        BytesToSend;
    // Tells us how many bytes are to be transmitted.

    PBCHANNEL_OBJECT            pBChannel;
    // A pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);

    /*
    // MUTEX to protect against async EventHandler access at the same time.
    */
    NdisAcquireSpinLock(&pAdapter->TransmitLock);

#if DBG
    {   // Sanity check!
        PLIST_ENTRY pList = &pAdapter->TransmitPendingList;
        ASSERT(pList->Flink && pList->Flink->Blink == pList);
        ASSERT(pList->Blink && pList->Blink->Flink == pList);
    }
#endif // DBG

    /*
    // This might be called when no packets are queued!
    */
    while (!IsListEmpty(&pAdapter->TransmitPendingList))
    {
        PLIST_ENTRY                 pList;
        /*
        // Remove the packet from the TransmitPendingList.
        */
        pList = RemoveHeadList(&pAdapter->TransmitPendingList);
        pNdisPacket = GET_PACKET_FROM_QUEUE(pList);

        /*
        // Release MUTEX
        */
        NdisReleaseSpinLock(&pAdapter->TransmitLock);

        /*
        // Retrieve the information we saved in the packet reserved fields.
        */
        pBChannel = *((PBCHANNEL_OBJECT *) &pNdisPacket->MiniportReservedEx[8]);
        ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

        /*
        // Make sure the link is still up and can accept transmits.
        */
        if (pBChannel->CallState != LINECALLSTATE_CONNECTED)
        {
            /*
            // Indicate send complete failure to the NDIS wrapper.
            */
            DBG_WARNING(pAdapter,("Flushing send on channel #%d (Packet=0x%X)\n",
                        pBChannel->ObjectID, pNdisPacket));
            if (pBChannel->NdisVcHandle)
            {
                NdisMCoSendComplete(NDIS_STATUS_FAILURE,
                                    pBChannel->NdisVcHandle,
                                    pNdisPacket
                                    );
            }

            /*
            // Reacquire MUTEX
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
        }
        else
        {
            NdisQueryPacket(pNdisPacket,
                            NULL,
                            NULL,
                            NULL,
                            &BytesToSend);
            pAdapter->TotalTxBytes += BytesToSend;
            pAdapter->TotalTxPackets++;

            /*
            // Attempt to place the packet on the NIC for transmission.
            */
            if (!CardTransmitPacket(pAdapter->pCard, pBChannel, pNdisPacket))
            {
                /*
                // ReQueue the packet on the TransmitPendingList and leave.
                // Reacquire MUTEX
                */
                NdisAcquireSpinLock(&pAdapter->TransmitLock);
                InsertTailList(&pAdapter->TransmitPendingList,
                               GET_QUEUE_FROM_PACKET(pNdisPacket));
                break;
            }

            /*
            // Reacquire MUTEX
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
        }
    }
    /*
    // Release MUTEX
    */
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Transmit Transmit_c TransmitCompleteHandler


@func

    <f TransmitCompleteHandler> is called by <f MiniportTimer> to handle a
    transmit complete event.  We walk the <t TransmitCompleteList> to find
    all the packets that have been sent out on the wire, and then tell the
    protocol stack that we're done with the packet, and it can be re-used.

*/

VOID TransmitCompleteHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("TransmitCompleteHandler")

    PNDIS_PACKET                pNdisPacket;
    // Holds the packet that's just been transmitted.

    PBCHANNEL_OBJECT            pBChannel;
    // A pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (++(pAdapter->NestedDataHandler) > 1)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d > 1\n",
                  pAdapter->NestedDataHandler));
    }

    /*
    // MUTEX to protect against async EventHandler access at the same time.
    */
    NdisAcquireSpinLock(&pAdapter->TransmitLock);

#if DBG
    {   // Sanity check!
        PLIST_ENTRY pList = &pAdapter->TransmitCompleteList;
        ASSERT(pList->Flink && pList->Flink->Blink == pList);
        ASSERT(pList->Blink && pList->Blink->Flink == pList);
    }
#endif // DBG

    while (!IsListEmpty(&pAdapter->TransmitCompleteList))
    {
        PLIST_ENTRY                 pList;
        /*
        // Remove the packet from the TransmitCompleteList.
        */
        pList = RemoveHeadList(&pAdapter->TransmitCompleteList);
        pNdisPacket = GET_PACKET_FROM_QUEUE(pList);

        /*
        // Release MUTEX
        */
        NdisReleaseSpinLock(&pAdapter->TransmitLock);

        /*
        // Retrieve the information we saved in the packet reserved fields.
        */
        pBChannel = *((PBCHANNEL_OBJECT *) &pNdisPacket->MiniportReservedEx[8]);
        *((PBCHANNEL_OBJECT *) &pNdisPacket->MiniportReservedEx[8]) = NULL;
        ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

        /*
        // Indicate send complete to the NDIS wrapper.
        */
        DBG_TXC(pAdapter, pBChannel->ObjectID);
        NdisMCoSendComplete(NDIS_STATUS_SUCCESS,
                            pBChannel->NdisVcHandle,
                            pNdisPacket
                            );

        /*
        // Reacquire MUTEX
        */
        NdisAcquireSpinLock(&pAdapter->TransmitLock);
    }
    /*
    // Release MUTEX
    */
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    /*
    // Start any other pending transmits.
    */
    TransmitPacketHandler(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (--(pAdapter->NestedDataHandler) < 0)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d < 0\n",
                  pAdapter->NestedDataHandler));
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Transmit Transmit_c FlushSendPackets


@func

    <f FlushSendPackets> is called by <f MiniportTimer> to handle a
    transmit complete event.  We walk the <t TransmitCompleteList> to find
    all the packets that have been sent out on the wire, and then tell the
    protocol stack that we're done with the packet, and it can be re-used.

*/

VOID FlushSendPackets(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    PBCHANNEL_OBJECT            pBChannel                   // @parm
    // A pointer to one of our <t BCHANNEL_OBJECT>'s.
    )
{
    DBG_FUNC("FlushSendPackets")

    PLIST_ENTRY                 pList;

    DBG_ENTER(pAdapter);

    // Move all outstanding packets to the complete list.
    NdisAcquireSpinLock(&pAdapter->TransmitLock);
    while (!IsListEmpty(&pBChannel->TransmitBusyList))
    {
        pList = RemoveHeadList(&pBChannel->TransmitBusyList);
        InsertTailList(&pBChannel->pAdapter->TransmitCompleteList, pList);
    }
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    // This will complete all the packets now on the TransmitCompleteList,
    // and will fail any remaining packets left on the TransmitPendingList.
    TransmitCompleteHandler(pAdapter);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL Transmit Transmit_c MiniportCoSendPackets


@func

    <f MiniportCoSendPackets> is a required function for connection-oriented
    miniports. MiniportCoSendPackets is called to transfer some number of
    packets, specified as an array of pointers, over the network.

@comm

    MiniportCoSendPackets is called by NDIS in response to a request by a bound
    protocol driver to send a ordered list of data packets across the network.

    MiniportCoSendPackets should transmit each packet in any given array
    sequentially. MiniportCoSendPackets can call NdisQueryPacket to extract
    information, such as the number of buffer descriptors chained to the packet
    and the total size in bytes of the requested transfer. It can call
    NdisGetFirstBufferFromPacket, NdisQueryBuffer, or NdisQueryBufferOffset to
    extract information about individual buffers containing the data to be
    transmitted.

    MiniportCoSendPackets can retrieve protocol-supplied out-of-band information
    associated with each packet by using the appropriate NDIS_GET_PACKET_XXX
    macros.

    MiniportCoSendPackets can use only the eight-byte area at MiniportReserved
    within the NDIS_PACKET structure for its own purposes.

    The NDIS library ignores the OOB block in all packet descriptors it submits
    to MiniportCoSendPackets and assumes that every connection-oriented miniport
    is a deserialized driver that will complete each input packet descriptor
    asynchronously with NdisMCoSendComplete. Consequently, such a deserialized
    driver's MiniportCoSendPackets function usually ignores the Status member of
    the NDIS_PACKET_OOB_DATA block, but it can set this member to the same
    status as it subsequently passes to NdisMCoSendComplete.

    Rather than relying on NDIS to queue and resubmit send packets whenever
    MiniportCoSendPackets has insufficient resources to transmit the given
    packets, a deserialized miniport manages its own internal packet queueing.
    Such a driver is responsible for holding incoming send packets in its
    internal queue until they can be transmitted over the network and for
    preserving the protocol-determined ordering of packet descriptors incoming
    to its MiniportCoSendPackets function. A deserialized miniport must complete
    each incoming send packet with NdisMCoSendComplete, and it cannot call
    NdisMSendResourcesAvailable.

    A deserialized miniport should never pass STATUS_INSUFFICIENT_RESOURCES to
    NdisMCoSendComplete with a protocol-allocated packet descriptor that was
    originally submitted to its MiniportCoSendPackets function. Such a returned
    status effectively fails the send operation requested by the protocol, and
    NDIS would return the packet descriptor and all associated resources to the
    protocol that originally allocated it.

    MiniportCoSendPackets can be called at any IRQL \<= DISPATCH_LEVEL.
    Consequently, MiniportCoSendPackets function is responsible for
    synchronizing access to its internal queue(s) of packet descriptors with the
    driver's other MiniportXxx functions that also access the same queue(s).

@xref

    <f ProtocolCoCreateVc>, <f MiniportCoRequest>, <f MiniportInitialize>,
    NdisAllocatePacket, NdisCoSendPackets, NdisGetBufferPhysicalArraySize,
    NdisGetFirstBufferFromPacket, NdisGetNextBuffer,
    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO, NDIS_GET_PACKET_TIME_TO_SEND,
    NdisMCoSendComplete, NdisMoveMemory, NdisMoveToMappedMemory,
    NdisMSendResourcesAvailable, NdisMSetupDmaTransfer,
    NdisMStartBufferPhysicalMapping, NDIS_OOB_DATA_FROM_PACKET, NDIS_PACKET,
    NDIS_PACKET_OOB_DATA, NdisQueryBuffer, NdisQueryBufferOffset,
    NdisQueryPacket, NdisZeroMemory
*/

VOID MiniportCoSendPackets(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreate>.  AKA MiniportVcContext.<nl>
    // Specifies the handle to a miniport-allocated context area in which the
    // miniport maintains its per-VC state. The miniport supplied this handle
    // to NDIS from its <f ProtocolCoCreateVc> function.

    IN PPNDIS_PACKET            PacketArray,                // @parm
    // Points to the initial element in a packet array, with each element
    // specifying the address of a packet descriptor for a packet to be
    // transmitted, along with an associated out-of-band data block containing
    // information such as the packet priority, an optional timestamp, and the
    // per-packet status to be set by MiniportCoSendPackets.

    IN UINT                     NumberOfPackets             // @parm
    // Specifies the number of pointers to packet descriptors at PacketArray.
    )
{
    DBG_FUNC("MiniportCoSendPackets")

    UINT                        BytesToSend;
    // Tells us how many bytes are to be transmitted.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    UINT                        Index;

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    if (pBChannel->CallClosing)
    {
        DBG_ERROR(pAdapter,("BChannel Closed\n"));
    }

    for (Index = 0; Index < NumberOfPackets; Index++)
    {
        /*
        // Return if call has been closed.
        */
        if (pBChannel->CallClosing)
        {
            NDIS_SET_PACKET_STATUS(PacketArray[Index], NDIS_STATUS_CLOSED);
            continue;
        }

        NdisQueryPacket(PacketArray[Index], NULL, NULL, NULL, &BytesToSend);

        /*
        // Make sure the packet size is something we can deal with.
        */
        if ((BytesToSend == 0) || (BytesToSend > pAdapter->pCard->BufferSize))
        {
            DBG_ERROR(pAdapter,("Bad packet size = %d\n",BytesToSend));
            NdisMCoSendComplete(NDIS_STATUS_INVALID_PACKET,
                                pBChannel->NdisVcHandle,
                                PacketArray[Index]
                                );
        }
        else
        {
            /*
            // We have to accept the frame if possible, I just want to know
            // if somebody has lied to us...
            */
            if (BytesToSend > pBChannel->WanLinkInfo.MaxSendFrameSize)
            {
                DBG_NOTICE(pAdapter,("Channel #%d  Packet size=%d > %d\n",
                           pBChannel->ObjectID, BytesToSend,
                           pBChannel->WanLinkInfo.MaxSendFrameSize));
            }

            /*
            // Place the packet in the transmit list.
            */
            if (TransmitAddToQueue(pAdapter, pBChannel, PacketArray[Index]) &&
                pAdapter->NestedDataHandler < 1)
            {
                /*
                // The queue was empty so we've gotta kick start it.
                // Once it's going, it runs off the DPC.
                //
                // No kick start is necessary if we're already running the the
                // TransmitCompleteHandler -- In fact, it will screw things up if
                // we call TransmitPacketHandler while TransmitCompleteHandler is
                // running.
                */
                TransmitPacketHandler(pAdapter);
            }
        }
        NDIS_SET_PACKET_STATUS(PacketArray[Index], NDIS_STATUS_PENDING);
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\im\miniport.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

	miniport.c

Abstract:

	Ndis Intermediate Miniport driver sample. This is a passthru driver.

Author:

Environment:


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop



NDIS_STATUS
MPInitialize(
	OUT PNDIS_STATUS			OpenErrorStatus,
	OUT PUINT					SelectedMediumIndex,
	IN	PNDIS_MEDIUM			MediumArray,
	IN	UINT					MediumArraySize,
	IN	NDIS_HANDLE				MiniportAdapterHandle,
	IN	NDIS_HANDLE				WrapperConfigurationContext
	)
/*++

Routine Description:

	This is the initialize handler which gets called as a result of
	the BindAdapter handler calling NdisIMInitializeDeviceInstanceEx.
	The context parameter which we pass there is the adapter structure
	which we retrieve here.

	Arguments:

	OpenErrorStatus			Not used by us.
	SelectedMediumIndex		Place-holder for what media we are using
	MediumArray				Array of ndis media passed down to us to pick from
	MediumArraySize			Size of the array
	MiniportAdapterHandle	The handle NDIS uses to refer to us
	WrapperConfigurationContext	For use by NdisOpenConfiguration

Return Value:

	NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
	UINT			i;
	PADAPT			pAdapt;
	NDIS_STATUS		Status = NDIS_STATUS_FAILURE;
	NDIS_MEDIUM     Medium;

	do
	{
		//
		// Start off by retrieving our adapter context and storing
		// the Miniport handle in it.
		//
		pAdapt = NdisIMGetDeviceContext(MiniportAdapterHandle);
		pAdapt->MiniportHandle = MiniportAdapterHandle;

		DBGPRINT(("==> Miniport Initialize: Adapt %p\n", pAdapt));

		//
		// Usually we export the medium type of the adapter below as our
		// virtual miniport's medium type. However if the adapter below us
		// is a WAN device, then we claim to be of medium type 802.3.
		//
		Medium = pAdapt->Medium;

		if (Medium == NdisMediumWan)
		{
			Medium = NdisMedium802_3;
		}

		for (i = 0; i < MediumArraySize; i++)
		{
			if (MediumArray[i] == Medium)
			{
				*SelectedMediumIndex = i;
				break;
			}
		}

		if (i == MediumArraySize)
		{
			Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
			break;
		}


		//
		// Set the attributes now. NDIS_ATTRIBUTE_DESERIALIZE enables us
		// to make up-calls to NDIS without having to call NdisIMSwitchToMiniport
		// or NdisIMQueueCallBack. This also forces us to protect our data using
		// spinlocks where appropriate. Also in this case NDIS does not queue
		// packets on our behalf. Since this is a very simple pass-thru
		// miniport, we do not have a need to protect anything. However in
		// a general case there will be a need to use per-adapter spin-locks
		// for the packet queues at the very least.
		//
		NdisMSetAttributesEx(MiniportAdapterHandle,
 							pAdapt,
 							0,										// CheckForHangTimeInSeconds
 							NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT	|
								NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT|
								NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |
								NDIS_ATTRIBUTE_DESERIALIZE |
								NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
 							0);

		//
        // Initialize LastIndicatedStatus to be NDIS_STATUS_MEDIA_CONNECT
        //
        pAdapt->LastIndicatedStatus = NDIS_STATUS_MEDIA_CONNECT;
        
        //
		// Initialize the power states for both the lower binding (PTDeviceState)
		// and our miniport edge to Powered On.
		//
		pAdapt->MPDeviceState = NdisDeviceStateD0;
		pAdapt->PTDeviceState = NdisDeviceStateD0;

		//
		// Add this adapter to the global pAdapt List
		//
		NdisAcquireSpinLock(&GlobalLock);

		pAdapt->Next = pAdaptList;
		pAdaptList = pAdapt;

		NdisReleaseSpinLock(&GlobalLock);
		
		//
		// Create an ioctl interface
		//
		(VOID)PtRegisterDevice();

		Status = NDIS_STATUS_SUCCESS;
	}
	while (FALSE);

	//
	// If we had received an UnbindAdapter notification on the underlying
	// adapter, we would have blocked that thread waiting for the IM Init
	// process to complete. Wake up any such thread.
	//
	ASSERT(pAdapt->MiniportInitPending == TRUE);
	pAdapt->MiniportInitPending = FALSE;
	NdisSetEvent(&pAdapt->MiniportInitEvent);

	DBGPRINT(("<== Miniport Initialize: Adapt %p, Status %x\n", pAdapt, Status));

	return Status;
}


NDIS_STATUS
MPSend(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet,
	IN	UINT					Flags
	)
/*++

Routine Description:

	Send Packet handler. Either this or our SendPackets (array) handler is called
	based on which one is enabled in our Miniport Characteristics.

Arguments:

	MiniportAdapterContext	Pointer to the adapter
	Packet					Packet to send
	Flags					Unused, passed down below

Return Value:

	Return code from NdisSend

--*/
{
	PADAPT				pAdapt = (PADAPT)MiniportAdapterContext;
	NDIS_STATUS			Status;
	PNDIS_PACKET		MyPacket;
	PVOID				MediaSpecificInfo = NULL;
	ULONG				MediaSpecificInfoSize = 0;

#ifdef NDIS51
	//
	// Use NDIS 5.1 packet stacking:
	//
	{
		PNDIS_PACKET_STACK		pStack;
		BOOLEAN					Remaining;

		//
		// Packet stacks: Check if we can use the same packet for sending down.
		//

		pStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);
		if (Remaining)
		{
			//
			// We can reuse "Packet".
			//
			// NOTE: if we needed to keep per-packet information in packets
			// sent down, we can use pStack->IMReserved[].
			//
			ASSERT(pStack);

			NdisSend(&Status,
 					 pAdapt->BindingHandle,
 					 Packet);

			return(Status);
		}
	}
#endif // NDIS51

	//
	// We are either not using packet stacks, or there isn't stack space
	// in the original packet passed down to us. Allocate a new packet
	// to wrap the data with.
	//
	NdisAllocatePacket(&Status,
					   &MyPacket,
					   pAdapt->SendPacketPoolHandle);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		PSEND_RSVD			SendRsvd;

		//
		// Save a pointer to the original packet in our reserved
		// area in the new packet. This is needed so that we can
		// get back to the original packet when the new packet's send
		// is completed.
		//
		SendRsvd = (PSEND_RSVD)(MyPacket->ProtocolReserved);
		SendRsvd->OriginalPkt = Packet;

		MyPacket->Private.Flags = Flags;

		//
		// Set up the new packet so that it describes the same
		// data as the original packet.
		//
		MyPacket->Private.Head = Packet->Private.Head;
		MyPacket->Private.Tail = Packet->Private.Tail;
#ifdef WIN9X
		//
		// Work around the fact that NDIS does not initialize this
		// to FALSE on Win9x.
		//
		MyPacket->Private.ValidCounts = FALSE;
#endif

		//
		// Copy the OOB Offset from the original packet to the new
		// packet.
		//
		NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(MyPacket),
					   NDIS_OOB_DATA_FROM_PACKET(Packet),
					   sizeof(NDIS_PACKET_OOB_DATA));

#ifndef WIN9X
		//
		// Copy the right parts of per packet info into the new packet.
		// This API is not available on Win9x since task offload is
		// not supported on that platform.
		//
		NdisIMCopySendPerPacketInfo(MyPacket, Packet);
#endif
		
		//
		// Copy the Media specific information
		//
		NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(Packet,
											&MediaSpecificInfo,
											&MediaSpecificInfoSize);

		if (MediaSpecificInfo || MediaSpecificInfoSize)
		{
			NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(MyPacket,
												MediaSpecificInfo,
												MediaSpecificInfoSize);
		}

		NdisSend(&Status,
				 pAdapt->BindingHandle,
				 MyPacket);


		if (Status != NDIS_STATUS_PENDING)
		{
#ifndef WIN9X
			NdisIMCopySendCompletePerPacketInfo (Packet, MyPacket);
#endif
			NdisFreePacket(MyPacket);
		}
	}
	else
	{
		//
		// We are out of packets. Silently drop it. Alternatively we can deal with it:
		//	- By keeping separate send and receive pools
		//	- Dynamically allocate more pools as needed and free them when not needed
		//
	}

	return(Status);
}


VOID
MPSendPackets(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PPNDIS_PACKET			PacketArray,
	IN	UINT					NumberOfPackets
	)
/*++

Routine Description:

	Send Packet Array handler. Either this or our SendPacket handler is called
	based on which one is enabled in our Miniport Characteristics.

Arguments:

	MiniportAdapterContext	Pointer to our adapter
	PacketArray				Set of packets to send
	NumberOfPackets			Self-explanatory

Return Value:

	None

--*/
{
	PADAPT				pAdapt = (PADAPT)MiniportAdapterContext;
	NDIS_STATUS			Status;
	UINT				i;
	PVOID				MediaSpecificInfo = NULL;
	UINT				MediaSpecificInfoSize = 0;

	for (i = 0; i < NumberOfPackets; i++)
	{
		PNDIS_PACKET	Packet, MyPacket;

		Packet = PacketArray[i];

#ifdef NDIS51

		//
		// Use NDIS 5.1 packet stacking:
		//
		{
			PNDIS_PACKET_STACK		pStack;
			BOOLEAN					Remaining;

			//
			// Packet stacks: Check if we can use the same packet for sending down.
			//
			pStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);
			if (Remaining)
			{
				//
				// We can reuse "Packet".
				//
				// NOTE: if we needed to keep per-packet information in packets
				// sent down, we can use pStack->IMReserved[].
				//
				ASSERT(pStack);

				NdisSend(&Status,
 						 pAdapt->BindingHandle,
 						 Packet);
		
				if (Status != NDIS_STATUS_PENDING)
				{
					NdisMSendComplete(ADAPT_MINIPORT_HANDLE(pAdapt),
  									  Packet,
  									  Status);
				}

				continue;
			}
		}
#endif

		NdisAllocatePacket(&Status,
						   &MyPacket,
						   pAdapt->SendPacketPoolHandle);

		if (Status == NDIS_STATUS_SUCCESS)
		{
			PSEND_RSVD		SendRsvd;

			SendRsvd = (PSEND_RSVD)(MyPacket->ProtocolReserved);
			SendRsvd->OriginalPkt = Packet;

			MyPacket->Private.Flags = NdisGetPacketFlags(Packet);

			MyPacket->Private.Head = Packet->Private.Head;
			MyPacket->Private.Tail = Packet->Private.Tail;
#ifdef WIN9X
			//
			// Work around the fact that NDIS does not initialize this
			// to FALSE on Win9x.
			//
			MyPacket->Private.ValidCounts = FALSE;
#endif // WIN9X

			//
			// Copy the OOB data from the original packet to the new
			// packet.
			//
			NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(MyPacket),
						   NDIS_OOB_DATA_FROM_PACKET(Packet),
						   sizeof(NDIS_PACKET_OOB_DATA));
			//
			// Copy relevant parts of the per packet info into the new packet
			//
#ifndef WIN9X
			NdisIMCopySendPerPacketInfo(MyPacket, Packet);
#endif

			//
			// Copy the Media specific information
			//
			NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(Packet,
												&MediaSpecificInfo,
												&MediaSpecificInfoSize);

			if (MediaSpecificInfo || MediaSpecificInfoSize)
			{
				NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(MyPacket,
													MediaSpecificInfo,
													MediaSpecificInfoSize);
			}

			NdisSend(&Status,
					 pAdapt->BindingHandle,
					 MyPacket);

			if (Status != NDIS_STATUS_PENDING)
			{
#ifndef WIN9X
				NdisIMCopySendCompletePerPacketInfo (Packet, MyPacket);
#endif
				NdisFreePacket(MyPacket);
			}
		}

		if (Status != NDIS_STATUS_PENDING)
		{
			NdisMSendComplete(ADAPT_MINIPORT_HANDLE(pAdapt),
							  Packet,
							  Status);
		}
	}
}


NDIS_STATUS
MPQueryInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesWritten,
	OUT PULONG					BytesNeeded
	)
/*++

Routine Description:

	Entry point called by NDIS to query for the value of the specified OID.
	Typical processing is to forward the query down to the underlying miniport.

	The following OIDs are filtered here:

	OID_PNP_QUERY_POWER - return success right here

	OID_GEN_SUPPORTED_GUIDS - do not forward, otherwise we will show up
	multiple instances of private GUIDs supported by the underlying miniport.

	OID_PNP_CAPABILITIES - we do send this down to the lower miniport, but
	the values returned are postprocessed before we complete this request;
	see PtRequestComplete.

	NOTE on OID_TCP_TASK_OFFLOAD - if this IM driver modifies the contents
	of data it passes through such that a lower miniport may not be able
	to perform TCP task offload, then it should not forward this OID down,
	but fail it here with the status NDIS_STATUS_NOT_SUPPORTED. This is to
	avoid performing incorrect transformations on data.

	If our miniport edge (upper edge) is at a low-power state, fail the request.

	If our protocol edge (lower edge) has been notified of a low-power state,
	we pend this request until the miniport below has been set to D0. Since
	requests to miniports are serialized always, at most a single request will
	be pended.

Arguments:

	MiniportAdapterContext	Pointer to the adapter structure
	Oid						Oid for this query
	InformationBuffer		Buffer for information
	InformationBufferLength	Size of this buffer
	BytesWritten			Specifies how much info is written
	BytesNeeded				In case the buffer is smaller than what we need, tell them how much is needed


Return Value:

	Return code from the NdisRequest below.

--*/
{
	PADAPT		pAdapt = (PADAPT)MiniportAdapterContext;
	NDIS_STATUS	Status = NDIS_STATUS_FAILURE;

	do
	{
		if (Oid == OID_PNP_QUERY_POWER)
		{
			//
			//  Do not forward this.
			//
			Status = NDIS_STATUS_SUCCESS;
			break;
		}

		if (Oid == OID_GEN_SUPPORTED_GUIDS)
		{
			//
			//  Do not forward this, otherwise we will end up with multiple
			//  instances of private GUIDs that the underlying miniport
			//  supports.
			//
			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
		}

		if (Oid == OID_TCP_TASK_OFFLOAD)
		{
			//
			// Fail this -if- this driver performs data transformations
			// that can interfere with a lower driver's ability to offload
			// TCP tasks.
			//
			// Status = NDIS_STATUS_NOT_SUPPORTED;
			// break;
			//
		}

		//
		// All other queries are failed, if the miniport is not at D0
		//
		if (pAdapt->MPDeviceState > NdisDeviceStateD0 || pAdapt->StandingBy == TRUE)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		pAdapt->Request.RequestType = NdisRequestQueryInformation;
		pAdapt->Request.DATA.QUERY_INFORMATION.Oid = Oid;
		pAdapt->Request.DATA.QUERY_INFORMATION.InformationBuffer = InformationBuffer;
		pAdapt->Request.DATA.QUERY_INFORMATION.InformationBufferLength = InformationBufferLength;
		pAdapt->BytesNeeded = BytesNeeded;
		pAdapt->BytesReadOrWritten = BytesWritten;
		pAdapt->OutstandingRequests = TRUE;

		//
		// If the Protocol device state is OFF, mark this request as being
		// pended. We queue this until the device state is back to D0.
		//
		if (pAdapt->PTDeviceState > NdisDeviceStateD0)
		{
			pAdapt->QueuedRequest = TRUE;
			Status = NDIS_STATUS_PENDING;
			break;
		}

		//
		// default case, most requests will be passed to the miniport below
		//
		NdisRequest(&Status,
					pAdapt->BindingHandle,
					&pAdapt->Request);


		if (Status != NDIS_STATUS_PENDING)
		{
			PtRequestComplete(pAdapt, &pAdapt->Request, Status);
			Status = NDIS_STATUS_PENDING;
		}

	} while (FALSE);

	return(Status);

}


VOID
MPQueryPNPCapabilities(
	IN OUT	PADAPT			pAdapt,
	OUT		PNDIS_STATUS	pStatus
	)
/*++

Routine Description:

	Postprocess a request for OID_PNP_CAPABILITIES that was forwarded
	down to the underlying miniport, and has been completed by it.

Arguments:

	pAdapt - Pointer to the adapter structure
	pStatus - Place to return final status

Return Value:

	None.

--*/

{
	PNDIS_PNP_CAPABILITIES			pPNPCapabilities;
	PNDIS_PM_WAKE_UP_CAPABILITIES	pPMstruct;

	if (pAdapt->Request.DATA.QUERY_INFORMATION.InformationBufferLength >= sizeof(NDIS_PNP_CAPABILITIES))
	{
		pPNPCapabilities = (PNDIS_PNP_CAPABILITIES)(pAdapt->Request.DATA.QUERY_INFORMATION.InformationBuffer);

		//
		// The following fields must be overwritten by an IM driver.
		//
		pPMstruct= & pPNPCapabilities->WakeUpCapabilities;
		pPMstruct->MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
		pPMstruct->MinPatternWakeUp = NdisDeviceStateUnspecified;
		pPMstruct->MinLinkChangeWakeUp = NdisDeviceStateUnspecified;
		*pAdapt->BytesReadOrWritten = sizeof(NDIS_PNP_CAPABILITIES);
		*pAdapt->BytesNeeded = 0;


		//
		// Setting our internal flags
		// Default, device is ON
		//
		pAdapt->MPDeviceState = NdisDeviceStateD0;
		pAdapt->PTDeviceState = NdisDeviceStateD0;

		*pStatus = NDIS_STATUS_SUCCESS;
	}
	else
	{
		*pAdapt->BytesNeeded= sizeof(NDIS_PNP_CAPABILITIES);
		*pStatus = NDIS_STATUS_RESOURCES;
	}
}


NDIS_STATUS
MPSetInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesRead,
	OUT PULONG					BytesNeeded
	)
/*++

Routine Description:

	Miniport SetInfo handler.

	In the case of OID_PNP_SET_POWER, record the power state and return the OID.	
	Do not pass below
	If the device is suspended, do not block the SET_POWER_OID 
	as it is used to reactivate the Passthru miniport

	
	PM- If the MP is not ON (DeviceState > D0) return immediately  (except for 'query power' and 'set power')
		 If MP is ON, but the PT is not at D0, then queue the queue the request for later processing

	Requests to miniports are always serialized


Arguments:

	MiniportAdapterContext	Pointer to the adapter structure
	Oid						Oid for this query
	InformationBuffer		Buffer for information
	InformationBufferLength	Size of this buffer
	BytesRead				Specifies how much info is read
	BytesNeeded				In case the buffer is smaller than what we need, tell them how much is needed

Return Value:

	Return code from the NdisRequest below.

--*/
{
	PADAPT		pAdapt = (PADAPT)MiniportAdapterContext;
	NDIS_STATUS	Status;

	Status = NDIS_STATUS_FAILURE;

	do
	{
		//
		// The Set Power should not be sent to the miniport below the Passthru, but is handled internally
		//
		if (Oid == OID_PNP_SET_POWER)
		{
			MPProcessSetPowerOid(&Status, 
								 pAdapt, 
								 InformationBuffer, 
								 InformationBufferLength, 
								 BytesRead, 
								 BytesNeeded);
			break;

		}

		//
		// All other Set Information requests are failed, if the miniport is
        // not at D0 or is transitioning to a device state greater than D0.
		//
		if (pAdapt->MPDeviceState > NdisDeviceStateD0 || pAdapt->StandingBy == TRUE)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		// Set up the Request and return the result
		pAdapt->Request.RequestType = NdisRequestSetInformation;
		pAdapt->Request.DATA.SET_INFORMATION.Oid = Oid;
		pAdapt->Request.DATA.SET_INFORMATION.InformationBuffer = InformationBuffer;
		pAdapt->Request.DATA.SET_INFORMATION.InformationBufferLength = InformationBufferLength;
		pAdapt->BytesNeeded = BytesNeeded;
		pAdapt->BytesReadOrWritten = BytesRead;
		pAdapt->OutstandingRequests = TRUE;


		//
		// If the device below is at a low power state, we cannot send it the
		// request now, and must pend it.
		//
		if (pAdapt->PTDeviceState > NdisDeviceStateD0)
		{
			pAdapt->QueuedRequest = TRUE;
			Status = NDIS_STATUS_PENDING;
			break;
		}

		//
		// Forward the request to the device below.
		//
		NdisRequest(&Status,
					pAdapt->BindingHandle,
					&pAdapt->Request);

		if (Status == NDIS_STATUS_SUCCESS)
		{
			*BytesRead = pAdapt->Request.DATA.SET_INFORMATION.BytesRead;
			*BytesNeeded = pAdapt->Request.DATA.SET_INFORMATION.BytesNeeded;
		}


		if (Status != NDIS_STATUS_PENDING)
		{
			pAdapt->OutstandingRequests = FALSE;
		}

	} while (FALSE);

	return(Status);
}


VOID
MPProcessSetPowerOid(
	IN OUT PNDIS_STATUS			pNdisStatus,
	IN  PADAPT					pAdapt,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesRead,
	OUT PULONG					BytesNeeded
	)
/*++

Routine Description:
	This routine does all the procssing for a request with a SetPower Oid
	The miniport shoud accept  the Set Power and transition to the new state

	The Set Power should not be passed to the miniport below

	If the IM miniport is going into a low power state, then there is no guarantee if it will ever
	be asked go back to D0, before getting halted. No requests should be pended or queued.

	
Arguments:
	pNdisStatus			- Status of the operation
	pAdapt				- The Adapter structure
	InformationBuffer	- The New DeviceState
	InformationBufferLength
	BytesRead			- No of bytes read
	BytesNeeded			-  No of bytes needed


Return Value:
	Status  - NDIS_STATUS_SUCCESS if all the wait events succeed.

--*/
{

	
	NDIS_DEVICE_POWER_STATE NewDeviceState;

	DBGPRINT(("==>MPProcessSetPowerOid: Adapt %p\n", pAdapt)); 

	ASSERT (InformationBuffer != NULL);

	*pNdisStatus = NDIS_STATUS_FAILURE;

	do 
	{
		//
		// Check for invalid length
		//
		if (InformationBufferLength < sizeof(NDIS_DEVICE_POWER_STATE))
		{
			*pNdisStatus = NDIS_STATUS_INVALID_LENGTH;
			break;
		}

		NewDeviceState = (*(PNDIS_DEVICE_POWER_STATE)InformationBuffer);

		//
		// Check for invalid device state
		//
		if ((pAdapt->MPDeviceState > NdisDeviceStateD0) && (NewDeviceState != NdisDeviceStateD0))
		{
			//
			// If the miniport is in a non-D0 state, the miniport can only receive a Set Power to D0
			//
			ASSERT (!(pAdapt->MPDeviceState > NdisDeviceStateD0) && (NewDeviceState != NdisDeviceStateD0));

			*pNdisStatus = NDIS_STATUS_FAILURE;
			break;
		}	

		//
		// Is the miniport transitioning from an On (D0) state to an Low Power State (>D0)
		// If so, then set the StandingBy Flag - (Block all incoming requests)
		//
		if (pAdapt->MPDeviceState == NdisDeviceStateD0 && NewDeviceState > NdisDeviceStateD0)
		{
			pAdapt->StandingBy = TRUE;
		}

		//
		// If the miniport is transitioning from a low power state to ON (D0), then clear the StandingBy flag
		// All incoming requests will be pended until the physical miniport turns ON.
		//
		if (pAdapt->MPDeviceState > NdisDeviceStateD0 &&  NewDeviceState == NdisDeviceStateD0)
		{
			pAdapt->StandingBy = FALSE;
		}
		
		//
		// Now update the state in the pAdapt structure;
		//
		pAdapt->MPDeviceState = NewDeviceState;
		
		*pNdisStatus = NDIS_STATUS_SUCCESS;
	

	} while (FALSE);	
		
	if (*pNdisStatus == NDIS_STATUS_SUCCESS)
	{
        //
        // The miniport resume from low power state
        // 
        if (pAdapt->StandingBy == FALSE)
        {
            //
            // If we need to indicate the media connect state
            // 
            if (pAdapt->LastIndicatedStatus != pAdapt->LatestUnIndicateStatus)
            {
               NdisMIndicateStatus(pAdapt->MiniportHandle,
                                        pAdapt->LatestUnIndicateStatus,
                                        (PVOID)NULL,
                                        0);
               NdisMIndicateStatusComplete(pAdapt->MiniportHandle);
               pAdapt->LastIndicatedStatus = pAdapt->LatestUnIndicateStatus;
            }
        }
        else
        {
            //
            // Initialize LatestUnIndicatedStatus
            //
            pAdapt->LatestUnIndicateStatus = pAdapt->LastIndicatedStatus;
        }
		*BytesRead = sizeof(NDIS_DEVICE_POWER_STATE);
		*BytesNeeded = 0;
	}
	else
	{
		*BytesRead = 0;
		*BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE);
	}

	DBGPRINT(("<==MPProcessSetPowerOid: Adapt %p\n", pAdapt)); 
}


VOID
MPReturnPacket(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	NDIS Miniport entry point called whenever protocols are done with
	a packet that we had indicated up and they had queued up for returning
	later.

Arguments:

	MiniportAdapterContext	- pointer to ADAPT structure
	Packet	- packet being returned.

Return Value:

	None.

--*/
{
	PADAPT			pAdapt = (PADAPT)MiniportAdapterContext;

#ifdef NDIS51
	//
	// Packet stacking: Check if this packet belongs to us.
	//
	if (NdisGetPoolFromPacket(Packet) != pAdapt->RecvPacketPoolHandle)
	{
		//
		// We reused the original packet in a receive indication.
		// Simply return it to the miniport below us.
		//
		NdisReturnPackets(&Packet, 1);
	}
	else
#endif // NDIS51
	{
		//
		// This is a packet allocated from this IM's receive packet pool.
		// Reclaim our packet, and return the original to the driver below.
		//

		PNDIS_PACKET	MyPacket;
		PRECV_RSVD		RecvRsvd;
	
		RecvRsvd = (PRECV_RSVD)(Packet->MiniportReserved);
		MyPacket = RecvRsvd->OriginalPkt;
	
		NdisFreePacket(Packet);
		NdisReturnPackets(&MyPacket, 1);
	}
}


NDIS_STATUS
MPTransferData(
	OUT PNDIS_PACKET			Packet,
	OUT PUINT					BytesTransferred,
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_HANDLE				MiniportReceiveContext,
	IN	UINT					ByteOffset,
	IN	UINT					BytesToTransfer
	)
/*++

Routine Description:

	Miniport's transfer data handler.

Arguments:

	Packet					Destination packet
	BytesTransferred		Place-holder for how much data was copied
	MiniportAdapterContext	Pointer to the adapter structure
	MiniportReceiveContext	Context
	ByteOffset				Offset into the packet for copying data
	BytesToTransfer			How much to copy.

Return Value:

	Status of transfer

--*/
{
	PADAPT		pAdapt = (PADAPT)MiniportAdapterContext;
	NDIS_STATUS	Status;

	//
	// Return, if the device is OFF
	//

	if (IsIMDeviceStateOn(pAdapt) == FALSE)
	{
		return NDIS_STATUS_FAILURE;
	}

	NdisTransferData(&Status,
					 pAdapt->BindingHandle,
					 MiniportReceiveContext,
					 ByteOffset,
					 BytesToTransfer,
					 Packet,
					 BytesTransferred);

	return(Status);
}

VOID
MPHalt(
	IN	NDIS_HANDLE				MiniportAdapterContext
	)
/*++

Routine Description:

	Halt handler. All the hard-work for clean-up is done here.

Arguments:

	MiniportAdapterContext	Pointer to the Adapter

Return Value:

	None.

--*/
{
	PADAPT			pAdapt = (PADAPT)MiniportAdapterContext;
	NDIS_STATUS		Status;
	PADAPT			pCursor, *ppCursor;
	PADAPT			pPromoteAdapt = NULL;

	DBGPRINT(("==>MiniportHalt: Adapt %p\n", pAdapt));

	//
	// Remove this adapter from the global list
	//
	NdisAcquireSpinLock(&GlobalLock);

	for (ppCursor = &pAdaptList; *ppCursor != NULL; ppCursor = &(*ppCursor)->Next)
	{
		if (*ppCursor == pAdapt)
		{
			*ppCursor = pAdapt->Next;
			break;
		}
	}

	NdisReleaseSpinLock(&GlobalLock);

	//
	// Delete the ioctl interface that was created when the miniport
	// was created.
	//
	(VOID)PtDeregisterDevice();

	//
	// If we have a valid bind, close the miniport below the protocol
	//
	if (pAdapt->BindingHandle != NULL)
	{
		//
		// Close the binding below. and wait for it to complete
		//
		NdisResetEvent(&pAdapt->Event);

		NdisCloseAdapter(&Status, pAdapt->BindingHandle);

		if (Status == NDIS_STATUS_PENDING)
		{
			NdisWaitEvent(&pAdapt->Event, 0);
			Status = pAdapt->Status;
		}

		ASSERT (Status == NDIS_STATUS_SUCCESS);

		pAdapt->BindingHandle = NULL;
	}

	//
	//  Free all resources on this adapter structure.
	//

	MPFreeAllPacketPools (pAdapt);

	NdisFreeMemory(pAdapt, sizeof(ADAPT), 0);

	DBGPRINT(("<== MiniportHalt: pAdapt %p\n", pAdapt));
}


NDIS_STATUS
MPReset(
	OUT PBOOLEAN				AddressingReset,
	IN	NDIS_HANDLE				MiniportAdapterContext
	)
/*++

Routine Description:

	Reset Handler. We just don't do anything.

Arguments:

	AddressingReset			To let NDIS know whether we need help from it with our reset
	MiniportAdapterContext	Pointer to our adapter

Return Value:


--*/
{
	PADAPT	pAdapt = (PADAPT)MiniportAdapterContext;

	*AddressingReset = FALSE;

	return(NDIS_STATUS_SUCCESS);
}


#ifdef NDIS51_MINIPORT

VOID
MPCancelSendPackets(
	IN	NDIS_HANDLE			MiniportAdapterContext,
	IN	PVOID				CancelId
	)
/*++

Routine Description:

	The miniport entry point to handle cancellation of all send packets
	that match the given CancelId. If we have queued any packets that match
	this, then we should dequeue them and call NdisMSendComplete for all
	such packets, with a status of NDIS_STATUS_REQUEST_ABORTED.

	We should also call NdisCancelSendPackets in turn, on each lower binding
	that this adapter corresponds to. This is to let miniports below cancel
	any matching packets.

Arguments:

	MiniportAdapterContext	- pointer to ADAPT structure
	CancelId	- ID of packets to be cancelled.

Return Value:

	None

--*/
{
	PADAPT	pAdapt = (PADAPT)MiniportAdapterContext;

	//
	// If we queue packets on our adapter structure, this would be 
	// the place to acquire a spinlock to it, unlink any packets whose
	// Id matches CancelId, release the spinlock and call NdisMSendComplete
	// with NDIS_STATUS_REQUEST_ABORTED for all unlinked packets.
	//

	//
	// Next, pass this down so that we let the miniport(s) below cancel
	// any packets that they might have queued.
	//
	NdisCancelSendPackets(pAdapt->BindingHandle, CancelId);

	return;
}

VOID
MPDevicePnPEvent(
	IN NDIS_HANDLE				MiniportAdapterContext,
	IN NDIS_DEVICE_PNP_EVENT	DevicePnPEvent,
	IN PVOID					InformationBuffer,
	IN ULONG					InformationBufferLength
	)
/*++

Routine Description:

	This handler is called to notify us of PnP events directed to
	our miniport device object.

Arguments:

	MiniportAdapterContext	- pointer to ADAPT structure
	DevicePnPEvent - the event
	InformationBuffer - Points to additional event-specific information
	InformationBufferLength - length of above

Return Value:

	None
--*/
{
	// TBD - add code/comments about processing this.

	return;
}

VOID
MPAdapterShutdown(
	IN NDIS_HANDLE				MiniportAdapterContext
	)
/*++

Routine Description:

	This handler is called to notify us of an impending system shutdown.

Arguments:

	MiniportAdapterContext	- pointer to ADAPT structure

Return Value:

	None
--*/
{
	return;
}

#endif


VOID
MPFreeAllPacketPools(
	PADAPT					pAdapt
	)
/*++

Routine Description:

	Free all packet pools on the specified adapter.
	
Arguments:

	pAdapt	- pointer to ADAPT structure

Return Value:

	None

--*/
{
	if (pAdapt->RecvPacketPoolHandle != NULL)
	{
		//
		// Free the packet pool that is used to indicate receives
		//
		NdisFreePacketPool(pAdapt->RecvPacketPoolHandle);

		pAdapt->RecvPacketPoolHandle = NULL;
	}

	if (pAdapt->SendPacketPoolHandle != NULL)
	{

		//
		//  Free the packet pool that is used to send packets below
		//

		NdisFreePacketPool(pAdapt->SendPacketPoolHandle);

		pAdapt->SendPacketPoolHandle = NULL;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\adapter.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Adapter Adapter_h

@module Adapter.h |

    This module defines the interface to the <t MINIPORT_ADAPTER_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Adapter_h

@end

*/

#ifndef _ADAPTER_H
#define _ADAPTER_H

#define MINIPORT_ADAPTER_OBJECT_TYPE    ((ULONG)'A')+\
                                        ((ULONG)'D'<<8)+\
                                        ((ULONG)'A'<<16)+\
                                        ((ULONG)'P'<<24)


/* @doc INTERNAL Adapter Adapter_h MINIPORT_ADAPTER_OBJECT


@struct MINIPORT_ADAPTER_OBJECT |

    This structure contains the data associated with a single Miniport
    adapter instance.  Here, Adapter is defined as the manager of specific
    Network Interface Card (NIC) installed under the NDIS wrapper.  This
    adapter is responsible for managing all interactions between the NIC and
    the host operating system using the NDIS library.

@comm

    This structure must contain a reference to all other objects being managed
    by this adapter object.  The adapter object is the only reference passed
    between NDIS and the Miniport.  This is the <t MiniportAdapterContext> we
    pass into <f NdisMSetAttributes> from <f MiniportInitialize>.  This value
    is passed as a parameter to the Miniport entry points called by the NDIS
    wrapper.

    One of these objects is created each time that our <f MiniportInitialize>
    routine is called.  The NDIS wrapper calls this routine once for each of
    our devices installed and enabled in the system.  In the case of a hot
    swappable NIC (e.g. PCMCIA) the adapter might come and go several times
    during a single Windows session.

*/

typedef struct MINIPORT_ADAPTER_OBJECT
{
#if DBG
    ULONG                       DbgFlags;                   // @field
    // Debug flags control how much debug is displayed in the checked version.
    // Put it at the front so we can set it easily with debugger.

    UCHAR                       DbgID[12];                  // @field
    // This field is initialized to an ASCII decimal string containing the
    // adapter instance number 1..N.  It is only used to output debug messages.
#endif // DBG
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'ADAP'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    NDIS_HANDLE                 MiniportAdapterHandle;      // @field
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    NDIS_HANDLE                 WrapperConfigurationContext;// @field
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.

    PCARD_OBJECT                pCard;                      // @field
    // Pointer to the hardware specific <t CARD_OBJECT>.  Created by
    // <f CardCreate>.

    PDCHANNEL_OBJECT            pDChannel;                  // @field
    // Pointer to the <t DCHANNEL_OBJECT> created by <f DChannelCreate>.
    // One for the entire NIC.

    ULONG                       NumBChannels;               // @field
    // The number of <t BCHANNEL_OBJECT>'s supported by the NIC.

    PBCHANNEL_OBJECT *          pBChannelArray;             // @field
    // An array of <t BCHANNEL_OBJECT>'s created by <f BChannelCreate>.
    // One entry for each logical BChannel on NIC.

#if !defined(NDIS50_MINIPORT)
    ULONG                       BusNumber;                  // @field
    // Identifies which system bus this adapter is plugged in to.

    ULONG                       BusType;                    // @field
    // Identifies the bus type this adapter is plugged in to.

#endif // NDIS50_MINIPORT

    ULONG                       RunningWin95;               // @field
    // Set TRUE only if running on Windows 95 or Windows98.

    ULONG                       NumLineOpens;               // @field
    // The number of line open calls currently on this adapter.

    NDIS_SPIN_LOCK              TransmitLock;               // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the transmit queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  TransmitPendingList;        // @field
    // Packets waiting to be sent when the controller is available.
    // See <t NDIS_WAN_PACKET>.

    LIST_ENTRY                  TransmitCompleteList;       // @field
    // Packets waiting for completion processing.  After the packet is
    // transmitted, the protocol stack is given an indication.
    // See <t NDIS_WAN_PACKET>.

    NDIS_SPIN_LOCK              ReceiveLock;                // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the receive queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  ReceiveCompleteList;        // @field
    // Buffers waiting to be processed by the

    NDIS_SPIN_LOCK              EventLock;                  // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the event queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  EventList;                  // @field
    // driver callback events waiting to be processed.
    // See <t BCHANNEL_EVENT_OBJECT>.

    NDIS_MINIPORT_TIMER         EventTimer;                 // @field
    // This timer is used to schedule the event processing routine to run
    // when the system reaches a quiescent state.

    ULONG                       NextEvent;                  // @field
    // Where do we store the next event.

    long                        NestedEventHandler;         // @field
    // Keeps track of entry to and exit from the event handler.

    long                        NestedDataHandler;          // @field
    // Keeps track of entry to and exit from the Tx/Rx handlers.

    ULONG                       DeviceIdBase;               // @field
    // The ulDeviceIDBase field passed in the PROVIDER_INIT request
    // informs a miniport of the zero-based starting index that the
    // Connection Wrapper will use when referring to a single adapters
    // line devices by index.  For example, if a ulDeviceIDBase of two is
    // specified and the adapter supports three line devices, then the
    // Connection Wrapper will use the identifiers two, three, and four
    // to refer to the adapters three devices.

    NDIS_WAN_INFO               WanInfo;                    // @field
    // A copy of our <t NDIS_WAN_INFO> structure is setup at init time
    // and doesn't change.

    CHAR                        ProviderInfo[48];           // @field
    // This holds the TAPI ProviderInfo string returned from TspiGetDevCaps
    // This is two null terminated strings packed end to end.
    // This size is the max allowed by RAS.

    ULONG                       ProviderInfoSize;           // @field
    // Size in bytes of both strings.

    ULONG                       NoAnswerTimeOut;            // @field
    // How many ms to wait for ALERTING

    ULONG                       NoAcceptTimeOut;            // @field
    // How many ms to wait for ACCEPT

    ANSI_STRING                 MediaType;                  // @field
    // The MediaType configuration parameter is read from the registry
    // at init time.

    ANSI_STRING                 DeviceName;                 // @field
    // The DeviceName configuration parameter is read from the registry
    // at init time.

    ANSI_STRING                 TapiAddressList;            // @field
    // The TAPI AddressList configuration parameter is read from the
    // registry at init time.

    LINE_CALL_PARAMS            DefaultLineCallParams;      // @field
    // The default call parameters used by TspiMakeCall

    BOOLEAN                     NeedStatusCompleteIndication;   // @field
    // This flag indicates whether or not <f NdisMIndicateStatusComplete>
    // needs to be called after the completion of requests or event processing.
    // This is set TRUE if <f NdisMIndicateStatus> is called while
    // processing a request or event.

    ULONG                       TotalRxBytes;               // @field
    // Total bytes read by driver during this session.

    ULONG                       TotalTxBytes;               // @field
    // Total bytes written by driver during this session.

    ULONG                       TotalRxPackets;             // @field
    // Total packets read by driver during this session.

    ULONG                       TotalTxPackets;             // @field
    // Total packets written by driver during this session.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} MINIPORT_ADAPTER_OBJECT;

extern PMINIPORT_ADAPTER_OBJECT g_Adapters[MAX_ADAPTERS];

/*


    Function prototypes.

*/

NDIS_STATUS AdapterCreate(
    OUT PMINIPORT_ADAPTER_OBJECT *ppAdapter,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              WrapperConfigurationContext
    );

void AdapterDestroy(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

NDIS_STATUS AdapterInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

#endif // _ADAPTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\im\passthru.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

	passthru.h

Abstract:

	Ndis Intermediate Miniport driver sample. This is a passthru driver.

Author:

Environment:


Revision History:

 
--*/

#ifdef NDIS51_MINIPORT
#define PASSTHRU_MAJOR_NDIS_VERSION			5
#define PASSTHRU_MINOR_NDIS_VERSION			1
#else
#define PASSTHRU_MAJOR_NDIS_VERSION			4
#define PASSTHRU_MINOR_NDIS_VERSION			0
#endif

#ifdef NDIS51
#define PASSTHRU_PROT_MAJOR_NDIS_VERSION	5
#define PASSTHRU_PROT_MINOR_NDIS_VERSION	0
#else
#define PASSTHRU_PROT_MAJOR_NDIS_VERSION	4
#define PASSTHRU_PROT_MINOR_NDIS_VERSION	0
#endif

#define MAX_BUNDLEID_LENGTH 50

#define TAG 'ImPa'
#define WAIT_INFINITE 0



//advance declaration
typedef struct _ADAPT ADAPT, *PADAPT;

extern
NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT			DriverObject,
	IN	PUNICODE_STRING			RegistryPath
	);

NTSTATUS
PtDispatch(
	IN PDEVICE_OBJECT			DeviceObject,
	IN PIRP						Irp
	);

NDIS_STATUS
PtRegisterDevice(
	VOID
	);

NDIS_STATUS
PtDeregisterDevice(
	VOID
   );

VOID
PtUnloadProtocol(
    VOID
    );

//
// Protocol proto-types
//
extern
VOID
PtOpenAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status,
	IN	NDIS_STATUS				OpenErrorStatus
	);

extern
VOID
PtCloseAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status
	);

extern
VOID
PtResetComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status
	);

extern
VOID
PtRequestComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_REQUEST			NdisRequest,
	IN	NDIS_STATUS				Status
	);

extern
VOID
PtStatus(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	);

extern
VOID
PtStatusComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	);

extern
VOID
PtSendComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_PACKET			Packet,
	IN	NDIS_STATUS				Status
	);

extern
VOID
PtTransferDataComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_PACKET			Packet,
	IN	NDIS_STATUS				Status,
	IN	UINT					BytesTransferred
	);

extern
NDIS_STATUS
PtReceive(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				MacReceiveContext,
	IN	PVOID					HeaderBuffer,
	IN	UINT					HeaderBufferSize,
	IN	PVOID					LookAheadBuffer,
	IN	UINT					LookaheadBufferSize,
	IN	UINT					PacketSize
	);

extern
VOID
PtReceiveComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	);

extern
INT
PtReceivePacket(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_PACKET			Packet
	);

extern
VOID
PtBindAdapter(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				BindContext,
	IN	PNDIS_STRING			DeviceName,
	IN	PVOID					SystemSpecific1,
	IN	PVOID					SystemSpecific2
	);

extern
VOID
PtUnbindAdapter(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				UnbindContext
	);
	
VOID
PtUnload(
	IN	PDRIVER_OBJECT			DriverObject
	);



extern 
NDIS_STATUS
PtPNPHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNET_PNP_EVENT			pNetPnPEvent
	);




NDIS_STATUS
PtPnPNetEventReconfigure(
	IN	PADAPT			pAdapt,
	IN	PNET_PNP_EVENT	pNetPnPEvent
	);	

NDIS_STATUS 
PtPnPNetEventSetPower (
	IN PADAPT					pAdapt,
	IN	PNET_PNP_EVENT			pNetPnPEvent
	);
	

//
// Miniport proto-types
//
NDIS_STATUS
MPInitialize(
	OUT PNDIS_STATUS			OpenErrorStatus,
	OUT PUINT					SelectedMediumIndex,
	IN	PNDIS_MEDIUM			MediumArray,
	IN	UINT					MediumArraySize,
	IN	NDIS_HANDLE				MiniportAdapterHandle,
	IN	NDIS_HANDLE				WrapperConfigurationContext
	);

VOID
MPSendPackets(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PPNDIS_PACKET			PacketArray,
	IN	UINT					NumberOfPackets
	);

NDIS_STATUS
MPSend(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet,
	IN	UINT					Flags
	);

NDIS_STATUS
MPQueryInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesWritten,
	OUT PULONG					BytesNeeded
	);

NDIS_STATUS
MPSetInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesRead,
	OUT PULONG					BytesNeeded
	);

VOID
MPReturnPacket(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet
	);

NDIS_STATUS
MPTransferData(
	OUT PNDIS_PACKET			Packet,
	OUT PUINT					BytesTransferred,
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_HANDLE				MiniportReceiveContext,
	IN	UINT					ByteOffset,
	IN	UINT					BytesToTransfer
	);

VOID
MPHalt(
	IN	NDIS_HANDLE				MiniportAdapterContext
	);

NDIS_STATUS
MPReset(
	OUT PBOOLEAN				AddressingReset,
	IN	NDIS_HANDLE				MiniportAdapterContext
	);

VOID
MPQueryPNPCapabilities(  
	OUT	PADAPT					MiniportProtocolContext, 
	OUT	PNDIS_STATUS			Status
	);


NDIS_STATUS
MPSetMiniportSecondary ( 
	IN	PADAPT					Secondary, 
	IN	PADAPT					Primary
	);

#ifdef NDIS51_MINIPORT

VOID
MPCancelSendPackets(
	IN	NDIS_HANDLE			MiniportAdapterContext,
	IN	PVOID				CancelId
	);

VOID
MPAdapterShutdown(
	IN NDIS_HANDLE				MiniportAdapterContext
	);

VOID
MPDevicePnPEvent(
	IN NDIS_HANDLE				MiniportAdapterContext,
	IN NDIS_DEVICE_PNP_EVENT	DevicePnPEvent,
	IN PVOID					InformationBuffer,
	IN ULONG					InformationBufferLength
	);

#endif // NDIS51_MINIPORT

VOID
MPFreeAllPacketPools(
	PADAPT					pAdapt
	);

NDIS_STATUS 
MPPromoteSecondary ( 
	IN	PADAPT					pAdapt 
	);


NDIS_STATUS 
MPBundleSearchAndSetSecondary (
	IN	PADAPT					pAdapt 
	);

VOID
MPProcessSetPowerOid(
	IN OUT PNDIS_STATUS      pNdisStatus,
	IN  PADAPT					pAdapt,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesRead,
	OUT PULONG					BytesNeeded
    );


//
// There should be no DbgPrint's in the Free version of the driver
//
#if DBG

#define DBGPRINT(Fmt)										\
	{														\
		DbgPrint("Passthru: ");								\
		DbgPrint Fmt;										\
	}

#else // if DBG

#define DBGPRINT(Fmt)											

#endif // if DBG 

#define	NUM_PKTS_IN_POOL	256


//
// Protocol reserved part of a sent packet that is allocated by us.
//
typedef struct _SEND_RSVD
{
	PNDIS_PACKET	OriginalPkt;
} SEND_RSVD, *PSEND_RSVD;

//
// Miniport reserved part of a received packet that is allocated by
// us. Note that this should fit into the MiniportReserved space
// in an NDIS_PACKET.
//
typedef struct _RECV_RSVD
{
	PNDIS_PACKET	OriginalPkt;
} RECV_RSVD, *PRECV_RSVD;

C_ASSERT(sizeof(RECV_RSVD) <= sizeof(((PNDIS_PACKET)0)->MiniportReserved));

//
// Event Codes related to the PassthruEvent Structure
//

typedef enum 
{
	Passthru_Invalid,
	Passthru_SetPower,
	Passthru_Unbind

} PASSSTHRU_EVENT_CODE, *PPASTHRU_EVENT_CODE; 

//
// Passthru Event with  a code to state why they have been state
//

typedef struct _PASSTHRU_EVENT
{
	NDIS_EVENT Event;
	PASSSTHRU_EVENT_CODE Code;

} PASSTHRU_EVENT, *PPASSTHRU_EVENT;


//
// Structure used by both the miniport as well as the protocol part of the intermediate driver
// to represent an adapter and its corres. lower bindings
//
typedef struct _ADAPT
{
	struct _ADAPT *				Next;
	
	NDIS_HANDLE					BindingHandle;	// To the lower miniport
	NDIS_HANDLE					MiniportHandle;	// NDIS Handle to for miniport up-calls
	NDIS_HANDLE					SendPacketPoolHandle;
	NDIS_HANDLE					RecvPacketPoolHandle;
	NDIS_STATUS					Status;			// Open Status
	NDIS_EVENT					Event;			// Used by bind/halt for Open/Close Adapter synch.
	NDIS_MEDIUM					Medium;
	NDIS_REQUEST				Request;		// This is used to wrap a request coming down
												// to us. This exploits the fact that requests
												// are serialized down to us.
	PULONG						BytesNeeded;
	PULONG						BytesReadOrWritten;
	BOOLEAN						IndicateRcvComplete;
	
	BOOLEAN						OutstandingRequests;  	// TRUE iff a request is pending
														// at the miniport below
	BOOLEAN						QueuedRequest;		    // TRUE iff a request is queued at
														// this IM miniport

	BOOLEAN						StandingBy;				// True - When the miniport or protocol is transitioning from a D0 to Standby (>D0) State
														// False - At all other times, - Flag is cleared after a transition to D0

	NDIS_DEVICE_POWER_STATE 	MPDeviceState;			// Miniport's Device State 
	NDIS_DEVICE_POWER_STATE 	PTDeviceState;			// Protocol's Device State 
	NDIS_STRING					DeviceName;				// For initializing the miniport edge
	NDIS_EVENT					MiniportInitEvent;		// For blocking UnbindAdapter while
														// an IM Init is in progress.
	BOOLEAN						MiniportInitPending;	// TRUE iff IMInit in progress
    NDIS_STATUS                 LastIndicatedStatus;    // The last indicated media status
    NDIS_STATUS                 LatestUnIndicateStatus; // The latest suppressed media status

} ADAPT, *PADAPT;

extern	NDIS_HANDLE						ProtHandle, DriverHandle;
extern	NDIS_MEDIUM						MediumArray[4];
extern	PADAPT							pAdaptList;
extern	NDIS_SPIN_LOCK					GlobalLock;


#define ADAPT_MINIPORT_HANDLE(_pAdapt)	((_pAdapt)->MiniportHandle)

//
// Custom Macros to be used by the passthru driver 
//
/*
BOOLEAN
IsIMDeviceStateOn(
   PADAPT 
   )

*/
#define IsIMDeviceStateOn(_pP)		((_pP)->MPDeviceState == NdisDeviceStateD0 && (_pP)->PTDeviceState == NdisDeviceStateD0 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\coisdn\vvendor.h ===
/*

                                                                             
    (C) Copyright 1999 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiBuild vVendor vVendor_h

@module vVendor.h |

    This module defines the version information as displayed in the Windows 
    file property sheet.  You must change the fields below as appropriate 
    for your product.  This file is then included by <f vTarget\.rc> to 
    defined the necessary elements of the target file's version resource.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vVendor_h

@end

*/

#ifndef _VVENDOR_H_
#define _VVENDOR_H_

// Short vendor name - no spaces - limit to 32 characters if possible.
#define VER_VENDOR_STR                  "TriplePoint"
// Long vendor name - legal name of the company.
#define VER_VENDOR_NAME_STR             "TriplePoint, Inc."
// Legal copyright notice - limit to to 40 characters for appearance.
#define VER_COPYRIGHT_STR               "Copyright \251 1999"
// Short product name - no spaces - limit to 32 characters if possible.
#define VER_PRODUCT_STR                 "CoIsdn"
// Long product name - usually the same as put on the product packaging.
#define VER_PRODUCT_NAME_STR            "TriplePoint COISDN Miniport for Windows."
// Vendor and product name - typically used as a registry key.
#define VER_VENDOR_PRODUCT_STR          VER_VENDOR_STR "\\" VER_PRODUCT_STR
// Device description used to identify the device in the NDIS/TAPI user interface.
#define VER_DEVICE_STR                  "TriplePoint COISDN"
// IEEE Organization Unique Identifier assigned to your company.
#define VER_VENDOR_ID                   "TPI"

#endif // _VVENDOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\im\protocol.c ===
/*++

Copyright(c) 1992-2000  Microsoft Corporation

Module Name:

	protocol.c

Abstract:

	Ndis Intermediate Miniport driver sample. This is a passthru driver.

Author:

Environment:


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define MAX_PACKET_POOL_SIZE 0x0000FFFF
#define MIN_PACKET_POOL_SIZE 0x000000FF

VOID
PtBindAdapter(
	OUT PNDIS_STATUS			Status,
	IN  NDIS_HANDLE				BindContext,
	IN  PNDIS_STRING			DeviceName,
	IN  PVOID					SystemSpecific1,
	IN  PVOID					SystemSpecific2
	)
/*++

Routine Description:

	Called by NDIS to bind to a miniport below.

Arguments:

	Status			- Return status of bind here.
	BindContext		- Can be passed to NdisCompleteBindAdapter if this call is pended.
	DeviceName 		- Device name to bind to. This is passed to NdisOpenAdapter.
	SystemSpecific1	- Can be passed to NdisOpenProtocolConfiguration to read per-binding information
	SystemSpecific2	- Unused

Return Value:

	NDIS_STATUS_PENDING	if this call is pended. In this case call NdisCompleteBindAdapter
	to complete.
	Anything else		Completes this call synchronously

--*/
{
	NDIS_HANDLE						ConfigHandle = NULL;
	PNDIS_CONFIGURATION_PARAMETER	Param;
	NDIS_STRING						DeviceStr = NDIS_STRING_CONST("UpperBindings");
	PADAPT							pAdapt = NULL;
	NDIS_STATUS						Sts;
	UINT							MediumIndex;
	ULONG							TotalSize;

	PNDIS_CONFIGURATION_PARAMETER	BundleParam;
	NDIS_STRING						BundleStr = NDIS_STRING_CONST("BundleId");
	NDIS_STATUS						BundleStatus;
	
	DBGPRINT(("==> Protocol BindAdapter\n"));

	do
	{
		//
		// Access the configuration section for our binding-specific
		// parameters.
		//
		NdisOpenProtocolConfiguration(Status,
		  							 &ConfigHandle,
		  							 SystemSpecific1);

		if (*Status != NDIS_STATUS_SUCCESS)
		{
		  	break;
		}

		//
		// Read the "UpperBindings" reserved key that contains a list
		// of device names representing our miniport instances corresponding
		// to this lower binding. Since this is a 1:1 IM driver, this key
		// contains exactly one name.
		//
		// If we want to implement a N:1 mux driver (N adapter instances
		// over a single lower binding), then UpperBindings will be a
		// MULTI_SZ containing a list of device names - we would loop through
		// this list, calling NdisIMInitializeDeviceInstanceEx once for
		// each name in it.
		//
		NdisReadConfiguration(Status,
							  &Param,
		  					  ConfigHandle,
		  					  &DeviceStr,
		  					  NdisParameterString);
		if (*Status != NDIS_STATUS_SUCCESS)
		{
		  	break;
		}

		//
		// Allocate memory for the Adapter structure. This represents both the
		// protocol context as well as the adapter structure when the miniport
		// is initialized.
		//
		// In addition to the base structure, allocate space for the device
		// instance string.
		//
		TotalSize = sizeof(ADAPT) + Param->ParameterData.StringData.MaximumLength;
		NdisAllocateMemoryWithTag(&pAdapt, TotalSize, TAG);

		if (pAdapt == NULL)
		{
			*Status = NDIS_STATUS_RESOURCES;
		  	break;
		}

		//
		// Initialize the adapter structure. We copy in the IM device
		// name as well, because we may need to use it in a call to
		// NdisIMCancelInitializeDeviceInstance. The string returned
		// by NdisReadConfiguration is active (i.e. available) only
		// for the duration of this call to our BindAdapter handler.
		//
		NdisZeroMemory(pAdapt, TotalSize);
		pAdapt->DeviceName.MaximumLength = Param->ParameterData.StringData.MaximumLength;
		pAdapt->DeviceName.Length = Param->ParameterData.StringData.Length;
		pAdapt->DeviceName.Buffer = (PWCHAR)((ULONG_PTR)pAdapt + sizeof(ADAPT));
		NdisMoveMemory(pAdapt->DeviceName.Buffer,
					   Param->ParameterData.StringData.Buffer,
					   Param->ParameterData.StringData.MaximumLength);

		NdisInitializeEvent(&pAdapt->Event);

		//
		// Allocate a packet pool for sends. We need this to pass sends down.
		// We cannot use the same packet descriptor that came down to our send
		// handler (see also NDIS 5.1 packet stacking).
		//
		NdisAllocatePacketPoolEx(Status,
		  						 &pAdapt->SendPacketPoolHandle,
		  						 MIN_PACKET_POOL_SIZE,
		  						 MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
		  						 sizeof(SEND_RSVD));

		if (*Status != NDIS_STATUS_SUCCESS)
		{
		  	break;
		}

		//
		// Allocate a packet pool for receives. We need this to indicate receives.
		// Same consideration as sends (see also NDIS 5.1 packet stacking).
		//
		NdisAllocatePacketPoolEx(Status,
		  						 &pAdapt->RecvPacketPoolHandle,
		  						 MIN_PACKET_POOL_SIZE,
		  						 MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
		  						 PROTOCOL_RESERVED_SIZE_IN_PACKET);

		if (*Status != NDIS_STATUS_SUCCESS)
		{
		  	break;
		}

		//
		// Now open the adapter below and complete the initialization
		//
		NdisOpenAdapter(Status,
		  				&Sts,
		  				&pAdapt->BindingHandle,
		  				&MediumIndex,
		  				MediumArray,
		  				sizeof(MediumArray)/sizeof(NDIS_MEDIUM),
		  				ProtHandle,
		  				pAdapt,
		  				DeviceName,
		  				0,
		  				NULL);

		if (*Status == NDIS_STATUS_PENDING)
		{
		  	NdisWaitEvent(&pAdapt->Event, 0);
		  	*Status = pAdapt->Status;
		}

		if (*Status != NDIS_STATUS_SUCCESS)
		{
		  	break;
		}

		pAdapt->Medium = MediumArray[MediumIndex];

		//
		// Now ask NDIS to initialize our miniport (upper) edge.
		// Set the flag below to synchronize with a possible call
		// to our protocol Unbind handler that may come in before
		// our miniport initialization happens.
		//
		pAdapt->MiniportInitPending = TRUE;
		NdisInitializeEvent(&pAdapt->MiniportInitEvent);

		*Status = NdisIMInitializeDeviceInstanceEx(DriverHandle,
  										 &pAdapt->DeviceName,
  										 pAdapt);

		if (*Status != NDIS_STATUS_SUCCESS)
		{
			DBGPRINT(("BindAdapter: Adapt %p, IMInitializeDeviceInstance error %x\n",
				pAdapt, *Status));
			break;
		}

	} while(FALSE);

	//
	// Close the configuration handle now - see comments above with
	// the call to NdisIMInitializeDeviceInstanceEx.
	//
	if (ConfigHandle != NULL)
	{
		NdisCloseConfiguration(ConfigHandle);
	}

	if (*Status != NDIS_STATUS_SUCCESS)
	{
		if (pAdapt != NULL)
		{
			if (pAdapt->BindingHandle != NULL)
			{
				NDIS_STATUS	LocalStatus;

				//
				// Close the binding we opened above.
				//
				NdisCloseAdapter(&LocalStatus, pAdapt->BindingHandle);
				pAdapt->BindingHandle = NULL;

				if (LocalStatus == NDIS_STATUS_PENDING)
				{
 					NdisWaitEvent(&pAdapt->Event, 0);
 					LocalStatus = pAdapt->Status;
				}
			}

			if (pAdapt->SendPacketPoolHandle != NULL)
			{
				 NdisFreePacketPool(pAdapt->SendPacketPoolHandle);
			}

			if (pAdapt->RecvPacketPoolHandle != NULL)
			{
				 NdisFreePacketPool(pAdapt->RecvPacketPoolHandle);
			}

			NdisFreeMemory(pAdapt, sizeof(ADAPT), 0);
			pAdapt = NULL;
		}
	}


	DBGPRINT(("<== Protocol BindAdapter: pAdapt %p, Status %x\n", pAdapt, *Status));
}


VOID
PtOpenAdapterComplete(
	IN  NDIS_HANDLE			 ProtocolBindingContext,
	IN  NDIS_STATUS			 Status,
	IN  NDIS_STATUS			 OpenErrorStatus
	)
/*++

Routine Description:

	Completion routine for NdisOpenAdapter issued from within the PtBindAdapter. Simply
	unblock the caller.

Arguments:

	ProtocolBindingContext	Pointer to the adapter
	Status					Status of the NdisOpenAdapter call
	OpenErrorStatus			Secondary status(ignored by us).

Return Value:

	None

--*/
{
	PADAPT	  pAdapt =(PADAPT)ProtocolBindingContext;

	DBGPRINT(("==> PtOpenAdapterComplete: Adapt %p, Status %x\n", pAdapt, Status));
	pAdapt->Status = Status;
	NdisSetEvent(&pAdapt->Event);
}


VOID
PtUnbindAdapter(
	OUT PNDIS_STATUS		Status,
	IN  NDIS_HANDLE			ProtocolBindingContext,
	IN  NDIS_HANDLE			UnbindContext
	)
/*++

Routine Description:

	Called by NDIS when we are required to unbind to the adapter below.
	This functions shares functionality with the miniport's HaltHandler.
	The code should ensure that NdisCloseAdapter and NdisFreeMemory is called
	only once between the two functions

Arguments:

	Status					Placeholder for return status
	ProtocolBindingContext	Pointer to the adapter structure
	UnbindContext			Context for NdisUnbindComplete() if this pends

Return Value:

	Status for NdisIMDeinitializeDeviceContext

--*/
{
	PADAPT		 pAdapt =(PADAPT)ProtocolBindingContext;
	NDIS_HANDLE BindingHandle = pAdapt->BindingHandle;
	NDIS_STATUS	LocalStatus;

	DBGPRINT(("==> PtUnbindAdapter: Adapt %p\n", pAdapt));

	if (pAdapt->QueuedRequest == TRUE)
	{
		pAdapt->QueuedRequest = FALSE;

		PtRequestComplete (pAdapt,
		                 &pAdapt->Request,
		                 NDIS_STATUS_FAILURE );

	}

#ifndef WIN9X
	//
	// Check if we had called NdisIMInitializeDeviceInstanceEx and
	// we are awaiting a call to MiniportInitialize.
	//
	if (pAdapt->MiniportInitPending == TRUE)
	{
		//
		// Try to cancel the pending IMInit process.
		//
		LocalStatus = NdisIMCancelInitializeDeviceInstance(
						DriverHandle,
						&pAdapt->DeviceName);

		if (LocalStatus == NDIS_STATUS_SUCCESS)
		{
			//
			// Successfully cancelled IM Initialization; our
			// Miniport Initialize routine will not be called
			// for this device.
			//
			pAdapt->MiniportInitPending = FALSE;
			ASSERT(pAdapt->MiniportHandle == NULL);
		}
		else
		{
			//
			// Our Miniport Initialize routine will be called
			// (may be running on another thread at this time).
			// Wait for it to finish.
			//
			NdisWaitEvent(&pAdapt->MiniportInitEvent, 0);
			ASSERT(pAdapt->MiniportInitPending == FALSE);
		}

	}
#endif // !WIN9X

	//
	// Call NDIS to remove our device-instance. We do most of the work
	// inside the HaltHandler.
	//
	// The Handle will be NULL if our miniport Halt Handler has been called or
	// if the IM device was never initialized
	//
	
	if (pAdapt->MiniportHandle != NULL)
	{
		*Status = NdisIMDeInitializeDeviceInstance(pAdapt->MiniportHandle);

		if (*Status != NDIS_STATUS_SUCCESS)
		{
			*Status = NDIS_STATUS_FAILURE;
		}
	}
	else
	{
		//
		// We need to do some work here. 
		// Close the binding below us 
		// and release the memory allocated.
		//
		if(pAdapt->BindingHandle != NULL)
		{
			NdisResetEvent(&pAdapt->Event);

			NdisCloseAdapter(Status, pAdapt->BindingHandle);

			//
			// Wait for it to complete
			//
			if(*Status == NDIS_STATUS_PENDING)
			{
				 NdisWaitEvent(&pAdapt->Event, 0);
				 *Status = pAdapt->Status;
			}
		}
		else
		{
			//
			// Both Our MiniportHandle and Binding Handle  should not be NULL.
			//
			*Status = NDIS_STATUS_FAILURE;
			ASSERT(0);
		}

		//
		//	Free the memory here, if was not released earlier(by calling the HaltHandler)
		//
		NdisFreeMemory(pAdapt, sizeof(ADAPT), 0);
	}

	DBGPRINT(("<== PtUnbindAdapter: Adapt %p\n", pAdapt));
}


VOID
PtUnload(
	IN	PDRIVER_OBJECT		DriverObject
	)
{
	DBGPRINT(("PtUnload: entered\n"));
	PtUnloadProtocol();
	DBGPRINT(("PtUnload: done!\n"));
}


VOID
PtCloseAdapterComplete(
	IN	NDIS_HANDLE			ProtocolBindingContext,
	IN	NDIS_STATUS			Status
	)
/*++

Routine Description:

	Completion for the CloseAdapter call.

Arguments:

	ProtocolBindingContext	Pointer to the adapter structure
	Status					Completion status

Return Value:

	None.

--*/
{
	PADAPT	  pAdapt =(PADAPT)ProtocolBindingContext;

	DBGPRINT(("CloseAdapterComplete: Adapt %p, Status %x\n", pAdapt, Status));
	pAdapt->Status = Status;
	NdisSetEvent(&pAdapt->Event);
}


VOID
PtResetComplete(
	IN  NDIS_HANDLE			ProtocolBindingContext,
	IN  NDIS_STATUS			Status
	)
/*++

Routine Description:

	Completion for the reset.

Arguments:

	ProtocolBindingContext	Pointer to the adapter structure
	Status					Completion status

Return Value:

	None.

--*/
{
	PADAPT	pAdapt =(PADAPT)ProtocolBindingContext;

	//
	// We never issue a reset, so we should not be here.
	//
	ASSERT(0);
}


VOID
PtRequestComplete(
	IN  NDIS_HANDLE			ProtocolBindingContext,
	IN  PNDIS_REQUEST		NdisRequest,
	IN  NDIS_STATUS			Status
	)
/*++

Routine Description:

	Completion handler for the previously posted request. All OIDS
    are completed by and sent to the same miniport that they were requested for.
	If Oid == OID_PNP_QUERY_POWER then the data structure needs to returned with all entries =
	NdisDeviceStateUnspecified

Arguments:

	ProtocolBindingContext	Pointer to the adapter structure
	NdisRequest				The posted request
	Status					Completion status

Return Value:

	None

--*/
{
	PADAPT		pAdapt =(PADAPT)ProtocolBindingContext;
	NDIS_OID	Oid =	pAdapt->Request.DATA.SET_INFORMATION.Oid ;

	//
	// Since our request is not outstanding anymore
	//
	pAdapt->OutstandingRequests = FALSE;

	//
	// Complete the Set or Query, and fill in the buffer for OID_PNP_CAPABILITIES, if need be.
	//
	switch (NdisRequest->RequestType)
	{
	  case NdisRequestQueryInformation:

		//
		// We never pass OID_PNP_QUERY_POWER down.
		//
		ASSERT(Oid != OID_PNP_QUERY_POWER);

		if ((Oid == OID_PNP_CAPABILITIES) && (Status == NDIS_STATUS_SUCCESS))
		{
			MPQueryPNPCapabilities(pAdapt, &Status);
		}

		*pAdapt->BytesReadOrWritten = NdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
		*pAdapt->BytesNeeded = NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;

		if ((Oid == OID_GEN_MAC_OPTIONS) && (Status == NDIS_STATUS_SUCCESS))
		{
			//
			// Remove the no-loopback bit from mac-options. In essence we are
			// telling NDIS that we can handle loopback. We don't, but the
			// interface below us does. If we do not do this, then loopback
			// processing happens both below us and above us. This is wasteful
			// at best and if Netmon is running, it will see multiple copies
			// of loopback packets when sniffing above us.
			//
			// Only the lowest miniport is a stack of layered miniports should
			// ever report this bit set to NDIS.
			//
			*(PULONG)NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer &= ~NDIS_MAC_OPTION_NO_LOOPBACK;
		}

		NdisMQueryInformationComplete(pAdapt->MiniportHandle,
									  Status);
		break;

	  case NdisRequestSetInformation:

		ASSERT( Oid != OID_PNP_SET_POWER);

		*pAdapt->BytesReadOrWritten = NdisRequest->DATA.SET_INFORMATION.BytesRead;
		*pAdapt->BytesNeeded = NdisRequest->DATA.SET_INFORMATION.BytesNeeded;
		NdisMSetInformationComplete(pAdapt->MiniportHandle,
									Status);
		break;

	  default:
		ASSERT(0);
		break;
	}
	
}


VOID
PtStatus(
	IN  NDIS_HANDLE			ProtocolBindingContext,
	IN  NDIS_STATUS			GeneralStatus,
	IN  PVOID				StatusBuffer,
	IN  UINT				StatusBufferSize
	)
/*++

Routine Description:

	Status handler for the lower-edge(protocol).

Arguments:

	ProtocolBindingContext	Pointer to the adapter structure
	GeneralStatus			Status code
	StatusBuffer			Status buffer
	StatusBufferSize		Size of the status buffer

Return Value:

	None

--*/
{
	PADAPT	  pAdapt = (PADAPT)ProtocolBindingContext;

	//
	// Pass up this indication only if the upper edge miniport is initialized
	// and powered on. Also ignore indications that might be sent by the lower
	// miniport when it isn't at D0.
	//
	if ((pAdapt->MiniportHandle != NULL)  &&
		(pAdapt->MPDeviceState == NdisDeviceStateD0) &&
		(pAdapt->PTDeviceState == NdisDeviceStateD0))	
	{
        if ((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || 
            (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT))
        {
            
            pAdapt->LastIndicatedStatus = GeneralStatus;
        }
		NdisMIndicateStatus(pAdapt->MiniportHandle,
							GeneralStatus,
							StatusBuffer,
							StatusBufferSize);
	}
    //
    // Save the last indicated media status 
    //
    else
    {
        if ((pAdapt->MiniportHandle != NULL) && 
        ((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || 
            (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT)))
        {
            pAdapt->LatestUnIndicateStatus = GeneralStatus;
        }
    }
    
}


VOID
PtStatusComplete(
	IN	NDIS_HANDLE			ProtocolBindingContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADAPT	  pAdapt = (PADAPT)ProtocolBindingContext;

	//
	// Pass up this indication only if the upper edge miniport is initialized
	// and powered on. Also ignore indications that might be sent by the lower
	// miniport when it isn't at D0.
	//
	if ((pAdapt->MiniportHandle != NULL)  &&
		(pAdapt->MPDeviceState == NdisDeviceStateD0) &&
		(pAdapt->PTDeviceState == NdisDeviceStateD0))	
	{
		NdisMIndicateStatusComplete(pAdapt->MiniportHandle);
	}
}


VOID
PtSendComplete(
	IN	NDIS_HANDLE			ProtocolBindingContext,
	IN  PNDIS_PACKET		Packet,
	IN  NDIS_STATUS			Status
	)
/*++

Routine Description:

	Called by NDIS when the miniport below had completed a send. We should
	complete the corresponding upper-edge send this represents.

Arguments:

	ProtocolBindingContext	- Points to ADAPT structure
	Packet - Low level packet being completed
	Status - status of send

Return Value:

	None

--*/
{
	PADAPT			pAdapt =(PADAPT)ProtocolBindingContext;
	PNDIS_PACKET	Pkt;
	NDIS_HANDLE		PoolHandle;

#ifdef NDIS51
	//
	// Packet stacking:
	//
	// Determine if the packet we are completing is the one we allocated. If so, then
	// get the original packet from the reserved area and completed it and free the
	// allocated packet. If this is the packet that was sent down to us, then just
	// complete it
	//
	PoolHandle = NdisGetPoolFromPacket(Packet);
	if (PoolHandle != pAdapt->SendPacketPoolHandle)
	{
		//
		// We had passed down a packet belonging to the protocol above us.
		//
		// DBGPRINT(("PtSendComp: Adapt %p, Stacked Packet %p\n", pAdapt, Packet));

		NdisMSendComplete(pAdapt->MiniportHandle,
						  Packet,
						  Status);
	}
	else
#endif // NDIS51
	{
		PSEND_RSVD		SendRsvd;

		SendRsvd = (PSEND_RSVD)(Packet->ProtocolReserved);
		Pkt = SendRsvd->OriginalPkt;
	
#ifndef WIN9X
		NdisIMCopySendCompletePerPacketInfo (Pkt, Packet);
#endif
	
		NdisDprFreePacket(Packet);

		NdisMSendComplete(pAdapt->MiniportHandle,
								 Pkt,
								 Status);
	}
}   	


VOID
PtTransferDataComplete(
	IN  NDIS_HANDLE			ProtocolBindingContext,
	IN  PNDIS_PACKET		Packet,
	IN  NDIS_STATUS			Status,
	IN  UINT				BytesTransferred
	)
/*++

Routine Description:

	Entry point called by NDIS to indicate completion of a call by us
	to NdisTransferData.

	See notes under SendComplete.

Arguments:

Return Value:

--*/
{
	PADAPT	  pAdapt =(PADAPT)ProtocolBindingContext;

	if(pAdapt->MiniportHandle)
	{
		NdisMTransferDataComplete(pAdapt->MiniportHandle,
								  Packet,
								  Status,
								  BytesTransferred);
	}
}


NDIS_STATUS
PtReceive(
	IN  NDIS_HANDLE			ProtocolBindingContext,
	IN  NDIS_HANDLE			MacReceiveContext,
	IN  PVOID				HeaderBuffer,
	IN  UINT				HeaderBufferSize,
	IN  PVOID				LookAheadBuffer,
	IN  UINT				LookAheadBufferSize,
	IN  UINT				PacketSize
	)
/*++

Routine Description:

	Handle receive data indicated up by the miniport below. We pass
	it along to the protocol above us.

	If the miniport below indicates packets, NDIS would more
	likely call us at our ReceivePacket handler. However we
	might be called here in certain situations even though
	the miniport below has indicated a receive packet, e.g.
	if the miniport had set packet status to NDIS_STATUS_RESOURCES.
		
Arguments:

	<see DDK ref page for ProtocolReceive>

Return Value:

	NDIS_STATUS_SUCCESS if we processed the receive successfully,
	NDIS_STATUS_XXX error code if we discarded it.

--*/
{
	PADAPT			pAdapt =(PADAPT)ProtocolBindingContext;
	PNDIS_PACKET	MyPacket, Packet;
	NDIS_STATUS		Status = NDIS_STATUS_SUCCESS;

	if (!pAdapt->MiniportHandle)
	{
		Status = NDIS_STATUS_FAILURE;
	}
	else do
	{
		//
		// Get at the packet, if any, indicated up by the miniport below.
		//
		Packet = NdisGetReceivedPacket(pAdapt->BindingHandle, MacReceiveContext);
		if (Packet != NULL)
		{
		    //
		    // The miniport below did indicate up a packet. Use information
		    // from that packet to construct a new packet to indicate up.
		    //

#ifdef NDIS51
			//
			// NDIS 5.1 NOTE: Do not reuse the original packet in indicating
			// up a receive, even if there is sufficient packet stack space.
			// If we had to do so, we would have had to overwrite the
			// status field in the original packet to NDIS_STATUS_RESOURCES,
			// and it is not allowed for protocols to overwrite this field
			// in received packets.
			//
#endif // NDIS51

			//
			// Get a packet off the pool and indicate that up
			//
			NdisDprAllocatePacket(&Status,
			   						  &MyPacket,
			   						  pAdapt->RecvPacketPoolHandle);

			if (Status == NDIS_STATUS_SUCCESS)
			{
				//
				// Make our packet point to data from the original
				// packet. NOTE: this works only because we are
				// indicating a receive directly from the context of
				// our receive indication. If we need to queue this
				// packet and indicate it from another thread context,
				// we will also have to allocate a new buffer and copy
				// over the packet contents, OOB data and per-packet
				// information. This is because the packet data
				// is available only for the duration of this
				// receive indication call.
				//
				MyPacket->Private.Head = Packet->Private.Head;
				MyPacket->Private.Tail = Packet->Private.Tail;

				//
				// Get the original packet (it could be the same packet as the
				// one received or a different one based on the number of layered
				// miniports below) and set it on the indicated packet so the OOB
				// data is visible correctly at protocols above.
				//
				NDIS_SET_ORIGINAL_PACKET(MyPacket, NDIS_GET_ORIGINAL_PACKET(Packet));
				NDIS_SET_PACKET_HEADER_SIZE(MyPacket, HeaderBufferSize);

				//
				// Copy packet flags.
				//
				NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);

				//
				// Force protocols above to make a copy if they want to hang
				// on to data in this packet. This is because we are in our
				// Receive handler (not ReceivePacket) and we can't return a
				// ref count from here.
				//
				NDIS_SET_PACKET_STATUS(MyPacket, NDIS_STATUS_RESOURCES);

				//
				// By setting NDIS_STATUS_RESOURCES, we also know that we can reclaim
				// this packet as soon as the call to NdisMIndicateReceivePacket
				// returns.
				//

				NdisMIndicateReceivePacket(pAdapt->MiniportHandle, &MyPacket, 1);

				//
				// Reclaim the indicated packet. Since we had set its status
				// to NDIS_STATUS_RESOURCES, we are guaranteed that protocols
				// above are done with it.
				//
				NdisDprFreePacket(MyPacket);

				break;
			}
		}
		else
		{
			//
			// The miniport below us uses the old-style (not packet)
			// receive indication. Fall through.
			//
		}

		//
		// Fall through if the miniport below us has either not
		// indicated a packet or we could not allocate one
		//
		pAdapt->IndicateRcvComplete = TRUE;
		switch (pAdapt->Medium)
		{
		  case NdisMedium802_3:
		  case NdisMediumWan:
			 NdisMEthIndicateReceive(pAdapt->MiniportHandle,
											 MacReceiveContext,
											 HeaderBuffer,
											 HeaderBufferSize,
											 LookAheadBuffer,
											 LookAheadBufferSize,
											 PacketSize);
			 break;

		  case NdisMedium802_5:
			 NdisMTrIndicateReceive(pAdapt->MiniportHandle,
											MacReceiveContext,
											HeaderBuffer,
											HeaderBufferSize,
											LookAheadBuffer,
											LookAheadBufferSize,
											PacketSize);
			 break;

		  case NdisMediumFddi:
			 NdisMFddiIndicateReceive(pAdapt->MiniportHandle,
											  MacReceiveContext,
											  HeaderBuffer,
											  HeaderBufferSize,
											  LookAheadBuffer,
											  LookAheadBufferSize,
											  PacketSize);
			 break;

		  default:
			 ASSERT(FALSE);
			 break;
		}

	} while(FALSE);

	return Status;
}


VOID
PtReceiveComplete(
	IN	NDIS_HANDLE		ProtocolBindingContext
	)
/*++

Routine Description:

	Called by the adapter below us when it is done indicating a batch of
	received packets.

Arguments:

	ProtocolBindingContext	Pointer to our adapter structure.

Return Value:

	None

--*/
{
	PADAPT		pAdapt =(PADAPT)ProtocolBindingContext;

	if ((pAdapt->MiniportHandle != NULL) && pAdapt->IndicateRcvComplete)
	{
		switch (pAdapt->Medium)
		{
		  case NdisMedium802_3:
		  case NdisMediumWan:
			NdisMEthIndicateReceiveComplete(pAdapt->MiniportHandle);
			break;

		  case NdisMedium802_5:
			NdisMTrIndicateReceiveComplete(pAdapt->MiniportHandle);
			break;

		  case NdisMediumFddi:
			NdisMFddiIndicateReceiveComplete(pAdapt->MiniportHandle);
			break;

		  default:
			ASSERT(FALSE);
			break;
		}
	}

	pAdapt->IndicateRcvComplete = FALSE;
}


INT
PtReceivePacket(
	IN	NDIS_HANDLE			ProtocolBindingContext,
	IN	PNDIS_PACKET		Packet
	)
/*++

Routine Description:

	ReceivePacket handler. Called by NDIS if the miniport below supports
	NDIS 4.0 style receives. Re-package the buffer chain in a new packet
	and indicate the new packet to protocols above us. Any context for
	packets indicated up must be kept in the MiniportReserved field.

	NDIS 5.1 - packet stacking - if there is sufficient "stack space" in
	the packet passed to us, we can use the same packet in a receive
	indication.

Arguments:

	ProtocolBindingContext - Pointer to our adapter structure.
	Packet - Pointer to the packet

Return Value:

	== 0 -> We are done with the packet
	!= 0 -> We will keep the packet and call NdisReturnPackets() this
			many times when done.
--*/
{
	PADAPT				pAdapt =(PADAPT)ProtocolBindingContext;
	NDIS_STATUS			Status;
	PNDIS_PACKET		MyPacket;
	BOOLEAN				Remaining;

	//
	// Drop the packet silently if the upper miniport edge isn't initialized
	//
	if (!pAdapt->MiniportHandle)
	{
		  return 0;
	}

#ifdef NDIS51
	//
	// Check if we can reuse the same packet for indicating up.
	// See also: PtReceive(). 
	//
	(VOID)NdisIMGetCurrentPacketStack(Packet, &Remaining);
	if (Remaining)
	{
		//
		// We can reuse "Packet". Indicate it up and be done with it.
		//
		Status = NDIS_GET_PACKET_STATUS(Packet);
		NdisMIndicateReceivePacket(pAdapt->MiniportHandle, &Packet, 1);
		return((Status != NDIS_STATUS_RESOURCES) ? 1 : 0);
	}
#endif // NDIS51

	//
	// Get a packet off the pool and indicate that up
	//
	NdisDprAllocatePacket(&Status,
						   &MyPacket,
						   pAdapt->RecvPacketPoolHandle);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		PRECV_RSVD			RecvRsvd;

		RecvRsvd = (PRECV_RSVD)(MyPacket->MiniportReserved);
		RecvRsvd->OriginalPkt = Packet;

		MyPacket->Private.Head = Packet->Private.Head;
		MyPacket->Private.Tail = Packet->Private.Tail;

		//
		// Get the original packet (it could be the same packet as the one
		// received or a different one based on the number of layered miniports
		// below) and set it on the indicated packet so the OOB data is visible
		// correctly to protocols above us.
		//
		NDIS_SET_ORIGINAL_PACKET(MyPacket, NDIS_GET_ORIGINAL_PACKET(Packet));

		//
		// Set Packet Flags
		//
		NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);

		Status = NDIS_GET_PACKET_STATUS(Packet);

		NDIS_SET_PACKET_STATUS(MyPacket, Status);
		NDIS_SET_PACKET_HEADER_SIZE(MyPacket, NDIS_GET_PACKET_HEADER_SIZE(Packet));

		NdisMIndicateReceivePacket(pAdapt->MiniportHandle, &MyPacket, 1);

		//
		// Check if we had indicated up the packet with NDIS_STATUS_RESOURCES
		// NOTE -- do not use NDIS_GET_PACKET_STATUS(MyPacket) for this since
		// it might have changed! Use the value saved in the local variable.
		//
		if (Status == NDIS_STATUS_RESOURCES)
		{
			//
			// Our ReturnPackets handler will not be called for this packet.
			// We should reclaim it right here.
			//
			NdisDprFreePacket(MyPacket);
		}

		return((Status != NDIS_STATUS_RESOURCES) ? 1 : 0);
	}
	else
	{
		//
		// We are out of packets. Silently drop it.
		//
		return(0);
	}
}




NDIS_STATUS
PtPNPHandler(
	IN	NDIS_HANDLE		ProtocolBindingContext,
	IN	PNET_PNP_EVENT	pNetPnPEvent
	)

/*++
Routine Description:

	This is called by NDIS to notify us of a PNP event related to a lower
	binding. Based on the event, this dispatches to other helper routines.

	NDIS 5.1: forward this event to the upper protocol(s) by calling
	NdisIMNotifyPnPEvent.

Arguments:

	ProtocolBindingContext - Pointer to our adapter structure. Can be NULL
				for "global" notifications

	pNetPnPEvent - Pointer to the PNP event to be processed.

Return Value:

	NDIS_STATUS code indicating status of event processing.

--*/
{
	PADAPT			pAdapt  =(PADAPT)ProtocolBindingContext;
	NDIS_STATUS		Status  = NDIS_STATUS_SUCCESS;

	DBGPRINT(("PtPnPHandler: Adapt %p, Event %d\n", pAdapt, pNetPnPEvent->NetEvent));

	switch (pNetPnPEvent->NetEvent)
	{
		case NetEventSetPower:
			Status = PtPnPNetEventSetPower(pAdapt, pNetPnPEvent);
			break;

 		case NetEventReconfigure:
			Status = PtPnPNetEventReconfigure(pAdapt, pNetPnPEvent);
			break;

 		default:
#ifdef NDIS51
			//
			// Pass on this notification to protocol(s) above, before
			// doing anything else with it.
			//
			if (pAdapt && pAdapt->MiniportHandle)
			{
				Status = NdisIMNotifyPnPEvent(pAdapt->MiniportHandle, pNetPnPEvent);
			}
#else
			Status = NDIS_STATUS_SUCCESS;

#endif // NDIS51

			break;
	}

	return Status;
}


NDIS_STATUS
PtPnPNetEventReconfigure(
	IN	PADAPT			pAdapt,
	IN	PNET_PNP_EVENT	pNetPnPEvent
	)
/*++
Routine Description:

	This routine is called from NDIS to notify our protocol edge of a
	reconfiguration of parameters for either a specific binding (pAdapt
	is not NULL), or global parameters if any (pAdapt is NULL).

Arguments:

	pAdapt - Pointer to our adapter structure.
	pNetPnPEvent - the reconfigure event

Return Value:

	NDIS_STATUS_SUCCESS

--*/
{
	NDIS_STATUS	ReconfigStatus = NDIS_STATUS_SUCCESS;
	NDIS_STATUS	ReturnStatus = NDIS_STATUS_SUCCESS;

	do
	{
		//
		// Is this is a global reconfiguration notification ?
		//
		if (pAdapt == NULL)
		{
			//
			// An important event that causes this notification to us is if
			// one of our upper-edge miniport instances was enabled after being
			// disabled earlier, e.g. from Device Manager in Win2000. Note that
			// NDIS calls this because we had set up an association between our
			// miniport and protocol entities by calling NdisIMAssociateMiniport.
			//
			// Since we would have torn down the lower binding for that miniport,
			// we need NDIS' assistance to re-bind to the lower miniport. The
			// call to NdisReEnumerateProtocolBindings does exactly that.
			//
			NdisReEnumerateProtocolBindings (ProtHandle);		
			break;
		}

#ifdef NDIS51
		//
		// Pass on this notification to protocol(s) above before doing anything
		// with it.
		//
		if (pAdapt->MiniportHandle)
		{
			ReturnStatus = NdisIMNotifyPnPEvent(pAdapt->MiniportHandle, pNetPnPEvent);
		}
#endif // NDIS51

		ReconfigStatus = NDIS_STATUS_SUCCESS;

	} while(FALSE);

	DBGPRINT(("<==PtPNPNetEventReconfigure: pAdapt %p\n", pAdapt));

#ifdef NDIS51
	//
	// Overwrite status with what upper-layer protocol(s) returned.
	//
	ReconfigStatus = ReturnStatus;
#endif

	return ReconfigStatus;
}


NDIS_STATUS
PtPnPNetEventSetPower(
	IN	PADAPT			pAdapt,
	IN  PNET_PNP_EVENT	pNetPnPEvent
	)
/*++
Routine Description:

	This is a notification to our protocol edge of the power state
	of the lower miniport. If it is going to a low-power state, we must
	wait here for all outstanding sends and requests to complete.

	NDIS 5.1:  Since we use packet stacking, it is not sufficient to
	check usage of our local send packet pool to detect whether or not
	all outstanding sends have completed. For this, use the new API
	NdisQueryPendingIOCount.

	NDIS 5.1: Use the 5.1 API NdisIMNotifyPnPEvent to pass on PnP
	notifications to upper protocol(s).

Arguments:

	pAdapt			-	Pointer to the adpater structure
	pNetPnPEvent	-	The Net Pnp Event. this contains the new device state

Return Value:

	NDIS_STATUS_SUCCESS or the status returned by upper-layer protocols.

--*/
{
	PNDIS_DEVICE_POWER_STATE	pDeviceState  =(PNDIS_DEVICE_POWER_STATE)(pNetPnPEvent->Buffer);
	NDIS_DEVICE_POWER_STATE		PrevDeviceState = pAdapt->PTDeviceState;  
	NDIS_STATUS					Status;
	NDIS_STATUS					ReturnStatus;
#ifdef NDIS51
	ULONG						PendingIoCount = 0;
#endif // NDIS51

	ReturnStatus = NDIS_STATUS_SUCCESS;

	//
	// Set the Internal Device State, this blocks all new sends or receives
	//
	pAdapt->PTDeviceState = *pDeviceState;

	//
	// Check if the miniport below is going to a low power state.
	//
	if (*pDeviceState > NdisDeviceStateD0)
	{

#ifdef NDIS51
		//
		// Notify upper layer protocol(s) first.
		//
		if (pAdapt->MiniportHandle != NULL)
		{
			ReturnStatus = NdisIMNotifyPnPEvent(pAdapt->MiniportHandle, pNetPnPEvent);
		}
#endif // NDIS51

		//
		// If the miniport below is going to standby, fail all incoming requests
		//
		if (PrevDeviceState == NdisDeviceStateD0)
		{
			pAdapt->StandingBy = TRUE;
		}

		//
		// Wait for outstanding sends and requests to complete.
		//
#ifdef NDIS51
		do
		{
			Status = NdisQueryPendingIOCount(pAdapt->BindingHandle, &PendingIoCount);

			if ((Status != NDIS_STATUS_SUCCESS) ||
				(PendingIoCount == 0))
			{
				break;
			}
			NdisMSleep(2);
		}
		while (TRUE);
#else
		while (NdisPacketPoolUsage(pAdapt->SendPacketPoolHandle) != 0)
		{
			NdisMSleep(2);
		}

		while (pAdapt->OutstandingRequests == TRUE)
		{
			//
			// sleep till outstanding requests complete
			//
			NdisMSleep(2);
		}

#endif // NDIS51

		ASSERT(NdisPacketPoolUsage(pAdapt->SendPacketPoolHandle) == 0);
		ASSERT(pAdapt->OutstandingRequests == FALSE);
	}
	else
	{
		//
		// The device below is being turned on. If we had a request
		// pending, send it down now.
		//
		if (pAdapt->QueuedRequest == TRUE)
		{
			pAdapt->QueuedRequest = FALSE;

			NdisRequest(&Status,
			            pAdapt->BindingHandle,
			            &pAdapt->Request);

			if (Status != NDIS_STATUS_PENDING)
			{
				PtRequestComplete(pAdapt,
			    	              &pAdapt->Request,
			        	          Status);
			}
		}

		//
		// If the physical miniport is powering up (from Low power state to D0), 
		// clear the flag
		//
		if (PrevDeviceState > NdisDeviceStateD0)
		{
			pAdapt->StandingBy = FALSE;
		}

#ifdef NDIS51
		//
		// Pass on this notification to protocol(s) above
		//
		if (pAdapt->MiniportHandle)
		{
			ReturnStatus = NdisIMNotifyPnPEvent(pAdapt->MiniportHandle, pNetPnPEvent);
		}
#endif // NDIS51

	}

	return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\im\precomp.h ===
#include <ndis.h>
#include "passthru.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\im\passthru.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation
 
Module Name:
 
	passthru.c

Abstract:

	Ndis Intermediate Miniport driver sample. This is a passthru driver.

Author:

Environment:


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#pragma NDIS_INIT_FUNCTION(DriverEntry)

NDIS_HANDLE						ProtHandle = NULL;
NDIS_HANDLE						DriverHandle = NULL;
NDIS_MEDIUM						MediumArray[4] =
									{
										NdisMedium802_3,	// Ethernet
										NdisMedium802_5,	// Token-ring
										NdisMediumFddi,		// Fddi
										NdisMediumWan       // NDISWAN
									};

NDIS_SPIN_LOCK	GlobalLock;

PADAPT			pAdaptList = NULL;
LONG            MiniportCount = 0;

NDIS_HANDLE		NdisWrapperHandle;

//
// To support ioctls from user-mode:
//

#define LINKNAME_STRING     L"\\DosDevices\\Passthru"
#define NTDEVICE_STRING     L"\\Device\\Passthru"

NDIS_HANDLE     NdisDeviceHandle = NULL;
PDEVICE_OBJECT  ControlDeviceObject = NULL;

enum _DEVICE_STATE
{
	PS_DEVICE_STATE_READY = 0,	// ready for create/delete
	PS_DEVICE_STATE_CREATING,	// create operation in progress
	PS_DEVICE_STATE_DELETING	// delete operation in progress
}				ControlDeviceState = PS_DEVICE_STATE_READY;



NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT		DriverObject,
	IN	PUNICODE_STRING		RegistryPath
	)
/*++

Routine Description:

	First entry point to be called, when this driver is loaded.
	Register with NDIS as an intermediate driver.

Arguments:

	DriverObject - pointer to the system's driver object structure
		for this driver
	
	RegistryPath - system's registry path for this driver
	
Return Value:

	STATUS_SUCCESS if all initialization is successful, STATUS_XXX
	error code if not.

--*/
{
	NDIS_STATUS						Status;
	NDIS_PROTOCOL_CHARACTERISTICS	PChars;
	NDIS_MINIPORT_CHARACTERISTICS	MChars;
	PNDIS_CONFIGURATION_PARAMETER	Param;
	NDIS_STRING						Name;

	Status = NDIS_STATUS_SUCCESS;
	NdisAllocateSpinLock(&GlobalLock);

	NdisMInitializeWrapper(&NdisWrapperHandle, DriverObject, RegistryPath, NULL);

	do
	{
		//
		// Register the miniport with NDIS. Note that it is the miniport
		// which was started as a driver and not the protocol. Also the miniport
		// must be registered prior to the protocol since the protocol's BindAdapter
		// handler can be initiated anytime and when it is, it must be ready to
		// start driver instances.
		//

		NdisZeroMemory(&MChars, sizeof(NDIS_MINIPORT_CHARACTERISTICS));

		MChars.MajorNdisVersion = PASSTHRU_MAJOR_NDIS_VERSION;
		MChars.MinorNdisVersion = PASSTHRU_MINOR_NDIS_VERSION;

		MChars.InitializeHandler = MPInitialize;
		MChars.QueryInformationHandler = MPQueryInformation;
		MChars.SetInformationHandler = MPSetInformation;
		MChars.ResetHandler = MPReset;
		MChars.TransferDataHandler = MPTransferData;
		MChars.HaltHandler = MPHalt;
#ifdef NDIS51_MINIPORT
		MChars.CancelSendPacketsHandler = MPCancelSendPackets;
		MChars.PnPEventNotifyHandler = MPDevicePnPEvent;
		MChars.AdapterShutdownHandler = MPAdapterShutdown;
#endif // NDIS51_MINIPORT

		//
		// We will disable the check for hang timeout so we do not
		// need a check for hang handler!
		//
		MChars.CheckForHangHandler = NULL;
		MChars.ReturnPacketHandler = MPReturnPacket;

		//
		// Either the Send or the SendPackets handler should be specified.
		// If SendPackets handler is specified, SendHandler is ignored
		//
		MChars.SendHandler = NULL;	// MPSend;
		MChars.SendPacketsHandler = MPSendPackets;

		Status = NdisIMRegisterLayeredMiniport(NdisWrapperHandle,
   											   &MChars,
   											   sizeof(MChars),
										   	   &DriverHandle);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

#ifndef WIN9X
		NdisMRegisterUnloadHandler(NdisWrapperHandle, PtUnload);
#endif

		//
		// Now register the protocol.
		//
		NdisZeroMemory(&PChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
		PChars.MajorNdisVersion = PASSTHRU_PROT_MAJOR_NDIS_VERSION;
		PChars.MinorNdisVersion = PASSTHRU_PROT_MINOR_NDIS_VERSION;

		//
		// Make sure the protocol-name matches the service-name
		// (from the INF) under which this protocol is installed.
		// This is needed to ensure that NDIS can correctly determine
		// the binding and call us to bind to miniports below.
		//
		NdisInitUnicodeString(&Name, L"Passthru");	// Protocol name
		PChars.Name = Name;
		PChars.OpenAdapterCompleteHandler = PtOpenAdapterComplete;
		PChars.CloseAdapterCompleteHandler = PtCloseAdapterComplete;
		PChars.SendCompleteHandler = PtSendComplete;
		PChars.TransferDataCompleteHandler = PtTransferDataComplete;
	
		PChars.ResetCompleteHandler = PtResetComplete;
		PChars.RequestCompleteHandler = PtRequestComplete;
		PChars.ReceiveHandler = PtReceive;
		PChars.ReceiveCompleteHandler = PtReceiveComplete;
		PChars.StatusHandler = PtStatus;
		PChars.StatusCompleteHandler = PtStatusComplete;
		PChars.BindAdapterHandler = PtBindAdapter;
		PChars.UnbindAdapterHandler = PtUnbindAdapter;
		PChars.UnloadHandler = PtUnloadProtocol;

		PChars.ReceivePacketHandler = PtReceivePacket;
		PChars.PnPEventHandler= PtPNPHandler;

		NdisRegisterProtocol(&Status,
 							&ProtHandle,
 							&PChars,
 							sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

		if (Status != NDIS_STATUS_SUCCESS)
		{
			NdisIMDeregisterLayeredMiniport(DriverHandle);
			break;
		}

		NdisIMAssociateMiniport(DriverHandle, ProtHandle);
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		NdisTerminateWrapper(NdisWrapperHandle, NULL);
	}

	return(Status);
}


NDIS_STATUS
PtRegisterDevice(
	VOID
	)
/*++

Routine Description:

	Register an ioctl interface - a device object to be used for this
	purpose is created by NDIS when we call NdisMRegisterDevice.

	This routine is called whenever a new miniport instance is
	initialized. However, we only create one global device object,
	when the first miniport instance is initialized. This routine
	handles potential race conditions with PtDeregisterDevice via
	the ControlDeviceState and MiniportCount variables.

	NOTE: do not call this from DriverEntry; it will prevent the driver
	from being unloaded (e.g. on uninstall).

Arguments:

	None

Return Value:

	NDIS_STATUS_SUCCESS if we successfully register a device object.

--*/
{
	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;
	UNICODE_STRING		DeviceName;
	UNICODE_STRING		DeviceLinkUnicodeString;
	PDRIVER_DISPATCH	DispatchTable[IRP_MJ_MAXIMUM_FUNCTION];
	UINT				i;

	DBGPRINT(("==>PtRegisterDevice\n"));

	NdisAcquireSpinLock(&GlobalLock);

	++MiniportCount;
	
	if (1 == MiniportCount)
    {
		ASSERT(ControlDeviceState != PS_DEVICE_STATE_CREATING);

		//
		// Another thread could be running PtDeregisterDevice on
		// behalf of another miniport instance. If so, wait for
		// it to exit.
		//
		while (ControlDeviceState != PS_DEVICE_STATE_READY)
		{
			NdisReleaseSpinLock(&GlobalLock);
			NdisMSleep(1);
			NdisAcquireSpinLock(&GlobalLock);
		}

		ControlDeviceState = PS_DEVICE_STATE_CREATING;

		NdisReleaseSpinLock(&GlobalLock);

		for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
		{
		    DispatchTable[i] = PtDispatch;
		}

		NdisInitUnicodeString(&DeviceName, NTDEVICE_STRING);
		NdisInitUnicodeString(&DeviceLinkUnicodeString, LINKNAME_STRING);

		//
		// Create a device object and register our dispatch handlers
		//
		
		Status = NdisMRegisterDevice(
                    NdisWrapperHandle, 
                    &DeviceName,
                    &DeviceLinkUnicodeString,
                    &DispatchTable[0],
                    &ControlDeviceObject,
                    &NdisDeviceHandle
                    );

		NdisAcquireSpinLock(&GlobalLock);

		ControlDeviceState = PS_DEVICE_STATE_READY;
	}

	NdisReleaseSpinLock(&GlobalLock);

	DBGPRINT(("<==PtRegisterDevice: %x\n", Status));

	return (Status);
}


NTSTATUS
PtDispatch(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	)
/*++
Routine Description:

	Process IRPs sent to this device.

Arguments:

	DeviceObject - pointer to a device object
	Irp	  - pointer to an I/O Request Packet

Return Value:

	NTSTATUS - STATUS_SUCCESS always - change this when adding
	real code to handle ioctls.

--*/
{
	PIO_STACK_LOCATION  irpStack;
	NTSTATUS	        status = STATUS_SUCCESS;

	DBGPRINT(("==>Pt Dispatch\n"));
	irpStack = IoGetCurrentIrpStackLocation(Irp);
	  
	switch (irpStack->MajorFunction)
	{
		case IRP_MJ_CREATE:
			break;
		case IRP_MJ_CLOSE:
			break;        
		case IRP_MJ_DEVICE_CONTROL:
			//
			// Add code here to handle ioctl commands sent to passthru.
			//
			break;        
		default:
			break;
	}

	Irp->IoStatus.Status = status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	DBGPRINT(("<== Pt Dispatch\n"));

	return status;

} 


NDIS_STATUS
PtDeregisterDevice(
	VOID
	)
/*++

Routine Description:

	Deregister the ioctl interface. This is called whenever a miniport
	instance is halted. When the last miniport instance is halted, we
	request NDIS to delete the device object

Arguments:

	NdisDeviceHandle - Handle returned by NdisMRegisterDevice

Return Value:

	NDIS_STATUS_SUCCESS if everything worked ok

--*/
{
	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

	DBGPRINT(("==>PassthruDeregisterDevice\n"));

	NdisAcquireSpinLock(&GlobalLock);

	ASSERT(MiniportCount > 0);

	--MiniportCount;
	
	if (0 == MiniportCount)
	{
		//
		// All miniport instances have been halted. Deregister
		// the control device.
		//

		ASSERT(ControlDeviceState == PS_DEVICE_STATE_READY);

		//
		// Block PtRegisterDevice() while we release the control
		// device lock and deregister the device.
		// 
		ControlDeviceState = PS_DEVICE_STATE_DELETING;

		NdisReleaseSpinLock(&GlobalLock);

		if (NdisDeviceHandle != NULL)
		{
			Status = NdisMDeregisterDevice(NdisDeviceHandle);
			NdisDeviceHandle = NULL;
		}

		NdisAcquireSpinLock(&GlobalLock);
		ControlDeviceState = PS_DEVICE_STATE_READY;
	}

	NdisReleaseSpinLock(&GlobalLock);

	DBGPRINT(("<== PassthruDeregisterDevice: %x\n", Status));
	return Status;
	
}


VOID
PtUnloadProtocol(
    VOID
)
{
	NDIS_STATUS Status;

	if (ProtHandle != NULL)
	{
		NdisDeregisterProtocol(&Status, ProtHandle);
		ProtHandle = NULL;
	}

	DBGPRINT(("PtUnloadProtocol: done!\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\adapter.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Adapter Adapter_c

@module Adapter.c |

    This module implements the interface to the <t MINIPORT_ADAPTER_OBJECT>.
    Supports the high-level adapter control functions used by the NDIS WAN
    Minport driver.  This module isolates most the NDIS specific logical
    adapter interfaces.  It should require very little change if you follow
    this same overall architecture.  You should try to isolate your changes
    to the <t CARD_OBJECT> that is contained within the logical adapter
    <t MINIPORT_ADAPTER_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Adapter_c

@end

*/

#define  __FILEID__             MINIPORT_ADAPTER_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


PMINIPORT_ADAPTER_OBJECT        g_Adapters[MAX_ADAPTERS]    // @globalv
// Keeps track of all the <t MINIPORT_ADAPTER_OBJECT>s created by the driver.
                                = { 0 };

DBG_STATIC ULONG                g_AdapterInstanceCounter    // @globalv
// Keeps track of how many <t MINIPORT_ADAPTER_OBJECT>s are created and
// stored in the <p g_Adapters> array.
                                = 0;

DBG_STATIC UCHAR                g_AnsiDriverName[]          // @globalv
// ANSI string used to identify the driver to the system; usually defined
// as VER_PRODUCT_STR.
                                = VER_PRODUCT_STR;

DBG_STATIC UCHAR                g_AnsiVendorDescription[]   // @globalv
// ANSI string used to identify the vendor's device to the system; usually
// defined as VER_DEVICE_STR " Adapter".
                                = VER_DEVICE_STR " Adapter";


/* @doc INTERNAL EXTERNAL Adapter Adapter_c g_AdapterParameters


@topic 5.1 Adapter Parameters |

    This section describes the registry parameters read into the
    <t MINIPORT_ADAPTER_OBJECT>.

@globalv DBG_STATIC <t PARAM_TABLE> | g_AdapterParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t MINIPORT_ADAPTER_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t MINIPORT_ADAPTER_OBJECT>
    you will need to modify <f AdapterReadParameters> and add the parameter
    definitions to the <f g_AdapterParameters> table.

*/

DBG_STATIC NDIS_STRING      g_DefaultAddressList                // @globalv
// Default value to be used for AddressList if it's not in the registry.
                        = INIT_STRING_CONST(VER_DEFAULT_ADDRESSLIST);

DBG_STATIC NDIS_STRING      g_DefaultDeviceName                 // @globalv
// Default value to be used for DeviceName if it's not in the registry.
                        = INIT_STRING_CONST(VER_PRODUCT_STR);

DBG_STATIC NDIS_STRING      g_DefaultMediaType                  // @globalv
// Default value to be used for MediaType if it's not in the registry.
                        = INIT_STRING_CONST(VER_DEFAULT_MEDIATYPE);

DBG_STATIC PARAM_TABLE      g_AdapterParameters[] =
{
#if !defined(NDIS50_MINIPORT)
    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                BusNumber, PARAM_BusNumber,
                TRUE, NdisParameterInteger, 0,
                0, 0, 15),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                BusType, PARAM_BusType,
                TRUE, NdisParameterInteger, 0,
                0, Internal, MaximumInterfaceType),
#endif // NDIS50_MINIPORT

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                TapiAddressList, PARAM_AddressList,
                FALSE, NdisParameterMultiString, 0,
                &g_DefaultAddressList, 0, 0),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                DeviceName, PARAM_DeviceName,
                FALSE, NdisParameterString, 0,
                &g_DefaultDeviceName, 0, 0),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                MediaType, PARAM_MediaType,
                FALSE, NdisParameterString, 0,
                &g_DefaultMediaType, 0, 0),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                NoAnswerTimeOut, PARAM_NoAnswerTimeOut,
                FALSE, NdisParameterHexInteger, 0,
                CARD_NO_ANSWER_TIMEOUT, 5000, 120000),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                NoAcceptTimeOut, PARAM_NoAcceptTimeOut,
                FALSE, NdisParameterHexInteger, 0,
                CARD_NO_ACCEPT_TIMEOUT, 1000, 60000),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                RunningWin95, PARAM_RunningWin95,
                FALSE, NdisParameterInteger, 0,
                0, 0, 1),

#if DBG
    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                DbgFlags, PARAM_DebugFlags,
                FALSE, NdisParameterHexInteger, 0,
                DBG_DEFAULTS | DBG_TAPICALL_ON, 0, 0xffffffff),
                // TODO: Change the debug flags to meet your needs.
#endif
    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL Adapter Adapter_c AdapterReadParameters


@func

    <f AdapterReadParameters> reads the adapter parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f AdapterCreate>.

    <f Note>:
    If you add any registry based data members to <t MINIPORT_ADAPTER_OBJECT>
    you will need to modify <f AdapterReadParameters> and add the parameter
    definitions to the <f g_AdapterParameters> table.

@rdesc

    <f AdapterReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS AdapterReadParameters(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("AdapterReadParameters")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Parse the registry parameters.
    */
    Result = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pAdapter,
                    g_AdapterParameters
                    );

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pAdapter->TODO)
        {
            DBG_ERROR(DbgInfo,("Invalid value 'TODO'\n",
                        pAdapter->TODO));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pAdapter->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Result = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Construct the "MediaType\0DeviceName" string for use by TAPI
            // on Windows NT.
            */
            strcpy(pAdapter->ProviderInfo, pAdapter->MediaType.Buffer);
            strcpy(pAdapter->ProviderInfo + pAdapter->MediaType.Length + 1,
                    pAdapter->DeviceName.Buffer);
            pAdapter->ProviderInfoSize = pAdapter->MediaType.Length + 1 +
                    pAdapter->DeviceName.Length + 1;

            DBG_NOTICE(DbgInfo,("ProviderInfoMedia='%s\\0%s'\n",
                       &pAdapter->ProviderInfo[0],
                       &pAdapter->ProviderInfo[pAdapter->MediaType.Length + 1]
                       ));
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterCreateObjects


@func

    <f AdapterCreateObjects> calls the create routines for all the objects
    contained in <t MINIPORT_ADAPTER_OBJECT>.  This should only be called
    by <f AdapterCreate>.

    <f Note>:
    If you add any new objects to <t MINIPORT_ADAPTER_OBJECT> you will need
    to modify <f AdapterCreateObjects> and <f AdapterDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f AdapterCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS AdapterCreateObjects(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("AdapterCreateObjects")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    ULONG                       Index;
    // Loop counter.

    ULONG                       NumBChannels;
    // The number of BChannels supported by the NIC.

    PANSI_STRING                pTapiAddressList;
    // MultiString of RAS address strings.

    PUCHAR                      pTapiLineAddress;
    // A pointer to the RAS/TAPI line address assigned to each RAS line.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Create the Card object.
    */
    Result = CardCreate(&pAdapter->pCard, pAdapter);

    /*
    // Create the DChannel object.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        Result = DChannelCreate(&pAdapter->pDChannel, pAdapter);
    }

    /*
    // Allocate space for the BChannels.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        NumBChannels = CardNumChannels(pAdapter->pCard);

        Result = ALLOCATE_MEMORY(pAdapter->pBChannelArray,
                                 sizeof(PVOID) * NumBChannels,
                                 pAdapter->MiniportAdapterHandle);
    }

    /*
    // Create the BChannel objects.
    */
    pTapiAddressList = &pAdapter->TapiAddressList;
    pTapiLineAddress = pTapiAddressList->Buffer;

    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < NumBChannels; Index++)
    {
        Result = BChannelCreate(&pAdapter->pBChannelArray[Index],
                                Index,
                                pTapiLineAddress,
                                pAdapter);

        /*
        // If we run off the end of the address list, we just point at the
        // null terminator for the other addresses.  This might happen if
        // some of the lines were not configured for use with RAS/TAPI.
        */
        pTapiLineAddress += strlen(pTapiLineAddress) + 1;
        if ((pTapiLineAddress - pTapiAddressList->Buffer) >=
             pTapiAddressList->Length)
        {
            --pTapiLineAddress;
        }

        /*
        // Keep track of how many are created.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            pAdapter->NumBChannels++;
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterCreate


@func

    <f AdapterCreate> allocates memory for a <t MINIPORT_ADAPTER_OBJECT> and
    then initializes the data members to their starting state.
    If successful, <p ppAdapter> will be set to point to the newly created
    <t MINIPORT_ADAPTER_OBJECT>.  Otherwise, <p ppAdapter> will be set to
    NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f AdapterDestroy> must be called to
    release the <t MINIPORT_ADAPTER_OBJECT> created by this function.

@rdesc

    <f AdapterCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS AdapterCreate(
    OUT PMINIPORT_ADAPTER_OBJECT *ppAdapter,                // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t MINIPORT_ADAPTER_OBJECT>.

    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    IN NDIS_HANDLE              WrapperConfigurationContext // @parm
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.
    )
{
    DBG_FUNC("AdapterCreate")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // Pointer to our newly allocated object.

    DBG_ENTER(DbgInfo);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppAdapter = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pAdapter, MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pAdapter->ObjectType = MINIPORT_ADAPTER_OBJECT_TYPE;
        pAdapter->ObjectID = ++g_AdapterInstanceCounter;
        ASSERT(g_AdapterInstanceCounter <= MAX_ADAPTERS);
        if (g_AdapterInstanceCounter <= MAX_ADAPTERS)
        {
            g_Adapters[g_AdapterInstanceCounter-1] = pAdapter;
        }

        /*
        // We use the instance number in debug messages to help when debugging
        // with multiple adapters.
        */
#if DBG
        pAdapter->DbgID[0] = (UCHAR) ((pAdapter->ObjectID & 0x0F) + '0');
        pAdapter->DbgID[1] = ':';
        if (sizeof(VER_TARGET_STR) < sizeof(pAdapter->DbgID)-3)
        {
            memcpy(&pAdapter->DbgID[2], VER_TARGET_STR, sizeof(VER_TARGET_STR));
        }
        else
        {
            memcpy(&pAdapter->DbgID[2], VER_TARGET_STR, sizeof(pAdapter->DbgID)-3);
            pAdapter->DbgID[sizeof(pAdapter->DbgID)-1] = 0;
        }
#endif
        /*
        // Initialize the member variables to their default settings.
        */
        pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;
        pAdapter->WrapperConfigurationContext = WrapperConfigurationContext;

        /*
        // Allocate spin locks to use for MUTEX queue protection.
        */
        NdisAllocateSpinLock(&pAdapter->EventLock);
        NdisAllocateSpinLock(&pAdapter->TransmitLock);
        NdisAllocateSpinLock(&pAdapter->ReceiveLock);

        /*
        // Parse the registry parameters.
        */
        Result = AdapterReadParameters(pAdapter);
#if DBG
        DbgInfo->DbgFlags = pAdapter->DbgFlags;
#endif // DBG
        DBG_DISPLAY(("NOTICE: Adapter#%d=0x%X DbgFlags=0x%X\n",
                    pAdapter->ObjectID, pAdapter, pAdapter->DbgFlags));

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = AdapterCreateObjects(pAdapter);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppAdapter = pAdapter;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            AdapterDestroy(pAdapter);
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterDestroyObjects


@func

    <f AdapterDestroyObjects> calls the destroy routines for all the objects
    contained in <t MINIPORT_ADAPTER_OBJECT>.  This should only be called
    by <f AdapterDestroy>.

    <f Note>:
    If you add any new objects to <t MINIPORT_ADAPTER_OBJECT> you will need
    to modify <f AdapterCreateObjects> and <f AdapterDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void AdapterDestroyObjects(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("AdapterDestroyObjects")

    UINT                        NumBChannels;
    // The number of BChannels supported by the NIC.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Destroy the BChannel objects.
    */
    NumBChannels = pAdapter->NumBChannels;
    while (NumBChannels--)
    {
        BChannelDestroy(pAdapter->pBChannelArray[NumBChannels]);
    }
    pAdapter->NumBChannels = 0;

    /*
    // Free space for the BChannels.
    */
    if (pAdapter->pBChannelArray)
    {
        NumBChannels = CardNumChannels(pAdapter->pCard);
        FREE_MEMORY(pAdapter->pBChannelArray, sizeof(PVOID) * NumBChannels);
    }

    /*
    // Destroy the DChannel object.
    */
    DChannelDestroy(pAdapter->pDChannel);

    /*
    // Destroy the Card object.
    */
    CardDestroy(pAdapter->pCard);

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL Adapter Adapter_c AdapterDestroy


@func

    <f AdapterDestroy> frees the memory for this <t MINIPORT_ADAPTER_OBJECT>.
    All memory allocated by <f AdapterCreate> will be released back to the OS.

*/

void AdapterDestroy(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("AdapterDestroy")

    DBG_ENTER(DbgInfo);

    if (pAdapter)
    {
        ASSERT(pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

        /*
        // Release all objects allocated within this object.
        */
        AdapterDestroyObjects(pAdapter);

        /*
        // Destroy any string parameter buffers created by ParamParseRegistry.
        */
        if (pAdapter->MediaType.Length)
        {
            FREE_NDISSTRING(pAdapter->MediaType);
        }
        if (pAdapter->DeviceName.Length)
        {
            FREE_NDISSTRING(pAdapter->DeviceName);
        }
        if (pAdapter->TapiAddressList.Length)
        {
            FREE_NDISSTRING(pAdapter->TapiAddressList);
        }

        if (pAdapter->EventLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->EventLock);
        }

        if (pAdapter->TransmitLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->TransmitLock);
        }

        if (pAdapter->ReceiveLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->ReceiveLock);
        }

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        if (pAdapter->ObjectType <= MAX_ADAPTERS)
        {
            g_Adapters[pAdapter->ObjectType-1] = NULL;
        }
        pAdapter->ObjectType = 0;
        FREE_OBJECT(pAdapter);
    }

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL Adapter Adapter_c AdapterInitialize


@func

    <f AdapterInitialize> prepares the <t MINIPORT_ADAPTER_OBJECT> and all
    its sub-components for use by the NDIS wrapper.  Upon successful
    completion of this routine, the NIC will be ready to accept requests
    from the NDIS wrapper.

@rdesc

    <f AdapterInitialize> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS AdapterInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("AdapterInitialize")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    ULONG                       Index;
    // Loop counter.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(pAdapter);

    /*
    // Initialize the WAN information structure to match the capabilities of
    // the adapter.
    */
    pAdapter->WanInfo.MaxFrameSize   = pAdapter->pCard->BufferSize - NDISWAN_EXTRA_SIZE;
    pAdapter->WanInfo.MaxTransmit    = pAdapter->pCard->TransmitBuffersPerLink;

    /*
    // Since we copy the packets to/from adapter RAM, no padding information is
    // needed in the WAN packets we get.  We can just use adapter RAM as needed.
    */
    pAdapter->WanInfo.HeaderPadding  = 0;
    pAdapter->WanInfo.TailPadding    = 0;

    /*
    // Transmits and received are copied to/from adapter RAM so cached memory
    // can be used for packet allocation and we don't really care if it's
    // physically contiguous or not, as long as it's virtually contiguous.
    */
    pAdapter->WanInfo.MemoryFlags    = 0;
    pAdapter->WanInfo.HighestAcceptableAddress = g_HighestAcceptableAddress;

    /*
    // We only support point to point framing, and we don't need to see the
    // address or control fields.  The TAPI_PROVIDER bit is set to indicate
    // that we can accept the TAPI OID requests.
    */
    pAdapter->WanInfo.FramingBits    = PPP_FRAMING | TAPI_PROVIDER |
                                       PPP_MULTILINK_FRAMING;

    /*
    // This value is ignored by this driver, but its default behavior is such
    // that all these control bytes would appear to be handled transparently.
    */
    pAdapter->WanInfo.DesiredACCM    = 0;

    /*
    // This value indicates how many point to point connections are allowed
    // per adapter.  Currently, the WAN wrapper only supports 1 connection
    // per NDIS link.
    */
    pAdapter->WanInfo.Endpoints = pAdapter->NumBChannels;

    /*
    // Setyup the default call parameters.
    */
    pAdapter->DefaultLineCallParams.ulTotalSize      = sizeof(pAdapter->DefaultLineCallParams);
    pAdapter->DefaultLineCallParams.ulBearerMode     = LINEBEARERMODE_DATA;
    pAdapter->DefaultLineCallParams.ulMinRate        = _56KBPS;
    pAdapter->DefaultLineCallParams.ulMaxRate        = _64KBPS;
    pAdapter->DefaultLineCallParams.ulMediaMode      = LINEMEDIAMODE_DIGITALDATA;
    pAdapter->DefaultLineCallParams.ulCallParamFlags = 0;
    pAdapter->DefaultLineCallParams.ulAddressMode    = LINEADDRESSMODE_ADDRESSID;
    pAdapter->DefaultLineCallParams.ulAddressID      = TSPI_ADDRESS_ID;

    /*
    // Initialize the packet management queues to empty.
    */
    InitializeListHead(&pAdapter->EventList);
    InitializeListHead(&pAdapter->TransmitPendingList);
    InitializeListHead(&pAdapter->TransmitCompleteList);
    InitializeListHead(&pAdapter->ReceiveCompleteList);

    /*
    // Setup the timer event handler.
    */
    NdisMInitializeTimer(&pAdapter->EventTimer,
                         pAdapter->MiniportAdapterHandle,
                         MiniportTimer,
                         pAdapter);

    /*
    // Initialize the DChannel object.
    */
    DChannelInitialize(pAdapter->pDChannel);

    /*
    // Initialize all the BChannel objects.
    */
    for (Index = 0; Index < pAdapter->NumBChannels; ++Index)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, Index);
        BChannelInitialize(pBChannel);
    }

    /*
    // Now, we can initialize the Card object.
    */
    Result = CardInitialize(pAdapter->pCard);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\bchannel.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL BChannel BChannel_h

@module BChannel.h |

    This module defines the interface to the <t BCHANNEL_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | BChannel_h

@end

*/

#ifndef _BCHANNEL_H
#define _BCHANNEL_H

#define BCHANNEL_OBJECT_TYPE    ((ULONG)'B')+\
                                ((ULONG)'C'<<8)+\
                                ((ULONG)'H'<<16)+\
                                ((ULONG)'N'<<24)


/* @doc INTERNAL BChannel BChannel_h BCHANNEL_OBJECT


@struct BCHANNEL_OBJECT |

    This structure contains the data associated with an ISDN BChannel.
    Here, BChannel is defined as any channel or collection of channels
    capable of carrying "user" data over and existing connection.  This
    channel is responsible for making sure the data payload is sent to or
    received from the remote end-point exactly as it is appeared at the
    originating station.

@comm

    This logical BChannel does not necessarily map to a physical BChannel
    on the NIC.  The NIC may in fact be bonding multiple BChannels into this
    logical BChannel.  The NIC may in fact not have BChannels at all, as
    may be the case with channelized T-1.  The BChannel is just a convenient
    abstraction for a point-to-point, bi-directional communication link.

    There will be one BChannel created for each communication channel on the
    NIC.  The number of channels depends on how many ports the NIC has, and
    how they are provisioned and configured.  The number of BChannels can be
    configured at install time or changed using the control panel.  The driver
    does not allow the configuration to change at run-time, so the computer
    or the adapter must be restarted to enable the configuration changes.

*/

typedef struct BCHANNEL_OBJECT
{
    struct BCHANNEL_OBJECT *    next;   /* Linked list pointer */

    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'BCHN'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    BOOLEAN                     IsOpen;                     // @field
    // Set TRUE if this BChannel is open, otherwise set FALSE.

//
//  NDIS data members

    ULONG                       BChannelIndex;                  // @field
    // This is a zero based index associated with this BChannel.  It is used
    // to associate a TAPI <p DeviceID> with this link based on the value
    // TAPI provides for <p  DeviceIdBase>  (i.e. <p  DeviceID> = <p  DeviceIdBase>
    // + BChannelIndex).  See <f GET_DEVICEID_FROM_BCHANNEL>.

    NDIS_HANDLE                 NdisLinkContext;           // @field
    // This is the WAN Wrapper's link context which is associated with this
    // link in response to the Miniport calling <f NdisMIndicateStatus>
    // to indicate a <t NDIS_MAC_LINE_UP> condition.  This value is passed
    // back to the WAN Wrapper to indicate activity associated with this link,
    // such as <f NdisMWanIndicateReceive> and <f NdisMIndicateStatus>.
    // See <F LinkLineUp>.

    ULONG                       LinkSpeed;                  // @field
    // The speed provided by the link in bits per second.  This value is
    // passed up by the Miniport during the LINE_UP indication.

    LIST_ENTRY                  ReceivePendingList;         // @field
    // Buffers currently submitted to the controller waiting for receive.

    LIST_ENTRY                  TransmitBusyList;           // @field
    // Packets currently submitted to the controller waiting for completion.
    // See <t NDIS_WAN_PACKET>.

    BOOLEAN                     NeedReceiveCompleteIndication;  // @field
    // This flag indicates whether or not <f NdisMWanIndicateReceiveComplete>
    // needs to be called after the completion of the event processing loop.
    // This is set TRUE if <f NdisMWanReceiveComplete> is called while
    // processing the event queues.

    NDIS_WAN_SET_LINK_INFO      WanLinkInfo;                // @field
    // The current settings associated with this link as passed in via
    // the OID_WAN_SET_LINK_INFO request.

    ULONG                       TotalRxPackets;             // @field
    // Total packets read by driver during this session.

//
//  TAPI data members.

    HTAPI_LINE                  htLine;                     // @field
    // This is the Connection Wrapper's line context associated with this
    // link when <f TspiOpen> is called.  This handle is used when calling
    // <f NdisMIndicateStatus> with <t NDIS_STATUS_TAPI_INDICATION>.

    HTAPI_CALL                  htCall;                     // @field
    // This is the Connection Wrapper's call context associated with this
    // link during <f TspiMakeCall> or a call to <f NdisMIndicateStatus>
    // with a <t LINE_NEWCALL> event.  This handle is used as the
    // <f ConnectionWrapperID> in the <t NDIS_MAC_LINE_UP> structure used
    // by <f LinkLineUp>.

    BOOLEAN                     CallClosing;                // @field
    // Set TRUE if call is being closed.

    ULONG                       CallState;                  // @field
    // The current TAPI LINECALLSTATE of the associated with the link.

    ULONG                       CallStateMode;              // @field
    // Remember what mode the call was set to.

    ULONG                       CallStatesCaps;             // @field
    // Events currently supported

    ULONG                       CallStatesMask;             // @field
    // Events currently enabled

    ULONG                       AddressState;               // @field
    // The current TAPI LINEADDRESSSTATE of the associated with the link.

    ULONG                       AddressStatesCaps;          // @field
    // Events currently supported

    ULONG                       AddressStatesMask;          // @field
    // Events currently enabled

    ULONG                       DevState;                   // @field
    // The current TAPI LINEDEVSTATE of the associated with the link.

    ULONG                       DevStatesCaps;              // @field
    // Events currently supported

    ULONG                       DevStatesMask;              // @field
    // Events currently enabled

    ULONG                       MediaMode;                  // @field
    // The current TAPI media mode(s) supported by the card.

    ULONG                       MediaModesCaps;             // @field
    // Events currently supported

    ULONG                       BearerMode;                 // @field
    // The current TAPI bearer mode in use.

    ULONG                       BearerModesCaps;            // @field
    // TAPI bearer mode(s) supported by the card.

    ULONG                       MediaModesMask;             // @field
    // Events currently enabled

    ULONG                       AppSpecificCallInfo;        // @field
    // This value is set by OID_TAPI_SET_APP_SPECIFIC and queried by
    // OID_TAPI_GET_CALL_INFO.

    CHAR                        pTapiLineAddress[0x14];     // @field
    // TAPI line address is assigned during installation and saved in the
    // registry.  It is read from the registry and saved here at init time.

    NDIS_MINIPORT_TIMER         CallTimer;                  // @field
    // This timer is used to keep track of the call state when a call is
    // coming in or going out.

//
//  CARD data members.

    ULONG                       TODO;                       // @field
    // Add your data members here.

#if defined(SAMPLE_DRIVER)
    PBCHANNEL_OBJECT            pPeerBChannel;              // @field
    // Peer BChannel of caller or callee depending on who orginated the
    // call.

#endif // SAMPLE_DRIVER

} BCHANNEL_OBJECT;

#define GET_ADAPTER_FROM_BCHANNEL(pBChannel)    (pBChannel->pAdapter)
#define GET_NDIS_LINK_FROM_BCHANNEL(pBChannel)  (pBChannel)
#define GET_TAPI_LINE_FROM_BCHANNEL(pBChannel)  (pBChannel)


/* @doc INTERNAL BChannel BChannel_h IS_VALID_BCHANNEL


@func ULONG | IS_VALID_BCHANNEL |
    Use this macro to determine if a <t BCHANNEL_OBJECT> is really valid.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm <t PBCHANNEL_OBJECT> | pBChannel |
    A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

@rdesc Returns TRUE if the BChannel is valid, otherwise FALSE is returned.

*/
#define IS_VALID_BCHANNEL(pAdapter, pBChannel) \
        (pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE)


/* @doc INTERNAL BChannel BChannel_h GET_BCHANNEL_FROM_INDEX


@func <t PBCHANNEL_OBJECT> | GET_BCHANNEL_FROM_INDEX |
    Use this macro to get a pointer to the <t BCHANNEL_OBJECT> associated
    with a zero-based Index.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm ULONG | BChannelIndex |
    Miniport BChannelIndex associated with a specific link.

@rdesc Returns a pointer to the associated <t BCHANNEL_OBJECT>.

*/
#define GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex) \
        (pAdapter->pBChannelArray[BChannelIndex]); \
        ASSERT(BChannelIndex < pAdapter->NumBChannels)


/* @doc INTERNAL BChannel BChannel_h GET_BCHANNEL_FROM_DEVICEID


@func <t PBCHANNEL_OBJECT> | GET_BCHANNEL_FROM_DEVICEID |
    Use this macro to get a pointer to the <t BCHANNEL_OBJECT> associated
    with a specific TAPI DeviceID.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm ULONG | ulDeviceID | TAPI DeviceID associated with a specific link.

@rdesc Returns a pointer to the associated <t BCHANNEL_OBJECT>.

*/
#define GET_BCHANNEL_FROM_DEVICEID(pAdapter, ulDeviceID) \
        (pAdapter->pBChannelArray[ulDeviceID - pAdapter->DeviceIdBase]); \
        ASSERT(ulDeviceID >= pAdapter->DeviceIdBase); \
        ASSERT(ulDeviceID <  pAdapter->DeviceIdBase+pAdapter->NumBChannels)

/* @doc INTERNAL BChannel BChannel_h GET_DEVICEID_FROM_BCHANNEL


@func ULONG | GET_DEVICEID_FROM_BCHANNEL |
    Use this macro to get the TAPI DeviceID associated with a specific
    <t BCHANNEL_OBJECT>.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm <t PBCHANNEL_OBJECT> | pBChannel |
    A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

*/

#define GET_DEVICEID_FROM_BCHANNEL(pAdapter, pBChannel) \
        (pBChannel->BChannelIndex + pAdapter->DeviceIdBase)

/* @doc INTERNAL BChannel BChannel_h GET_BCHANNEL_FROM_HDLINE


@func <t BCHANNEL_OBJECT> | GET_BCHANNEL_FROM_HDLINE |
    Use this macro to get a pointer to the <t BCHANNEL_OBJECT> associated
    with the TAPI hdLine handle.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm <t HTAPI_LINE> | hdLine |
    Miniport line handle associated with this <t BCHANNEL_OBJECT>.

@rdesc Returns a pointer to the associated <t PBCHANNEL_OBJECT>.

@devnote This driver associates TAPI lines 1:1 with BChannels so they are
    the same thing.

*/
#define GET_BCHANNEL_FROM_HDLINE(pAdapter, hdLine) \
        (PBCHANNEL_OBJECT) hdLine

/* @doc INTERNAL BChannel BChannel_h GET_BCHANNEL_FROM_HDCALL


@func <t BCHANNEL_OBJECT> | GET_BCHANNEL_FROM_HDCALL |
    Use this macro to get a pointer to the <t BCHANNEL_OBJECT> associated
    with the TAPI hdCall handle.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm <t HTAPI_CALL> | hdCall |
    Miniport call handle associated with this <t BCHANNEL_OBJECT>.

@rdesc Returns a pointer to the associated <t PBCHANNEL_OBJECT>.

@devnote This driver associates TAPI calls 1:1 with BChannels so they are
    the same thing.

*/
#define GET_BCHANNEL_FROM_HDCALL(pAdapter, hdCall) \
        (PBCHANNEL_OBJECT) hdCall


/*


    Function prototypes.

*/

NDIS_STATUS BChannelCreate(
    OUT PBCHANNEL_OBJECT *      pBChannel,
    IN ULONG                    BChannelIndex,
    IN PUCHAR                   pTapiLineAddress,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void BChannelDestroy(
    IN PBCHANNEL_OBJECT         pBChannel
    );

void BChannelInitialize(
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS BChannelOpen(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN HTAPI_LINE               htLine
    );

void BChannelClose(
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS BChannelAddToReceiveQueue(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PVOID                    pReceiveContext,
    IN PUCHAR                   BufferPointer,
    IN ULONG                    BufferSize
    );

NDIS_STATUS BChannelAddToTransmitQueue(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PVOID                    pTransmitContext,
    IN PUCHAR                   BufferPointer,
    IN ULONG                    BufferSize
    );

#endif // _BCHANNEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\dchannel.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL DChannel DChannel_h

@module DChannel.h |

    This module defines the interface to the <t DCHANNEL_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | DChannel_h

@end

*/

#ifndef _DCHANNEL_H
#define _DCHANNEL_H

#define DCHANNEL_OBJECT_TYPE    ((ULONG)'D')+\
                                ((ULONG)'C'<<8)+\
                                ((ULONG)'H'<<16)+\
                                ((ULONG)'N'<<24)

/* @doc INTERNAL DChannel DChannel_h DCHANNEL_OBJECT


@struct DCHANNEL_OBJECT |

    This structure contains the data associated with an ISDN DChannel.  Here,
    DChannel is defined as an interface by which to setup and teardown a
    BChannel connection between two end-points.  This channel is responsible
    for establishing a point-to-point connection over one of the available
    BChannels.

@comm

    This logical DChannel does not necessarily map to a physical DChannel
    on the NIC.  The NIC may in fact have multiple DChannels depending on
    how many ports and whether it is BRI, PRI, T-1, or E-1.  The NIC may in
    fact not have DChannels at all, as may be the case with channelized T-1.
    The DChannel is just a convenient abstraction for announcing and
    answering incoming calls, and for placing outgoing calls.


    There will be one DChannel created for each NIC.  The number of physical
    D-channels depends on how many ports the NIC has, and how the ports are
    provisioned and configured.  The provisioning can be configured at install
    time or changed using the control panel.  The driver does not allow the
    configuration to change at run-time, so the computer or the adapter must
    be restarted to enable the configuration changes.

*/

typedef struct DCHANNEL_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'DCHN'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    BOOLEAN                     IsOpen;                     // @field
    // Set TRUE if this DChannel is open, otherwise set FALSE.

    ULONG                       TotalMakeCalls;             // @field
    // Total number of <f DChannelMakeCall> requests.

    ULONG                       TotalAnswers;               // @field
    // Total number of <f DChannelAnswer> requests.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} DCHANNEL_OBJECT;

#define GET_ADAPTER_FROM_DCHANNEL(pDChannel)    (pDChannel->pAdapter)


/*


    Function prototypes.

*/

NDIS_STATUS DChannelCreate(
    OUT PDCHANNEL_OBJECT *      ppDChannel,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void DChannelDestroy(
    IN PDCHANNEL_OBJECT         pDChannel
    );

void DChannelInitialize(
    IN PDCHANNEL_OBJECT         pDChannel
    );

NDIS_STATUS DChannelOpen(
    IN PDCHANNEL_OBJECT         pDChannel
    );

void DChannelClose(
    IN PDCHANNEL_OBJECT         pDChannel
    );

NDIS_STATUS DChannelMakeCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PUCHAR                   DialString,
    IN USHORT                   DialStringLength,
    IN PLINE_CALL_PARAMS        pLineCallParams
    );

NDIS_STATUS DChannelAnswer(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS DChannelDropCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS DChannelCloseCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

VOID DChannelRejectCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

#endif // _DCHANNEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\card.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Card Card_h

@module Card.h |

    This module defines the hardware specific structures and values used to
    control the network interface card.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Card_h

@end

*/

#ifndef _CARD_H
#define _CARD_H

#define CARD_OBJECT_TYPE                ((ULONG)'C')+\
                                        ((ULONG)'A'<<8)+\
                                        ((ULONG)'R'<<16)+\
                                        ((ULONG)'D'<<24)

/*
// TODO - These values will normally come from the NIC or the installer.
*/
#define MAX_ADAPTERS                    4
#define CARD_NUM_PORTS                  1

//#define CARD_MIN_IOPORT_SIZE            256
// TODO - How many I/O ports does the card have?  (undefined if none)

//#define CARD_MIN_MEMORY_SIZE            256
// TODO - How much memory does the card have?  (undefined if none)

#define CARD_IS_BUS_MASTER              FALSE
// TODO - Is the card a bus master device?  (TRUE or FALSE)
#if (CARD_IS_BUS_MASTER)
#   define CARD_MAP_REGISTERS_NEEDED    NUM_DEV_PER_ADAP
// TODO - How many map registers needed to transmit data to card.
#endif

//#define CARD_REQUEST_ISR                TRUE
// TODO - How do you want to handle interrupts from the card?
// TRUE if you want to always use MiniportISR().
// FALSE if you want to use MiniportDisable() and MiniportEnable().
// Undefined if your card does not generate interrupts.

#if defined(CARD_REQUEST_ISR)

#define CARD_INTERRUPT_SHARED           TRUE
// TODO - Is your interrupt shared? (TRUE or FALSE).

#define CARD_INTERRUPT_MODE             NdisInterruptLevelSensitive
// TODO - Is your interrupt latched or level sensitve?

#endif // defined(CARD_REQUEST_ISR)

/*
// Maximum packet size allowed by the adapter -- must be restricted to
// 1500 bytes at this point, and must also allow for frames at least 32
// bytes longer.
*/
#define NDISWAN_EXTRA_SIZE              32
#define CARD_MIN_PACKET_SIZE            ( 480 + NDISWAN_EXTRA_SIZE)
#define CARD_MAX_PACKET_SIZE            (2016 + NDISWAN_EXTRA_SIZE)
#define CARD_DEFAULT_PACKET_SIZE        (1504 + NDISWAN_EXTRA_SIZE)

/*
// The WAN miniport must indicate the entire packet when it is received.
*/
#define CARD_MAX_LOOKAHEAD              (pAdapter->pCard->BufferSize)

/*
// Number of digits allowed in a phone number (not including spaces).
*/
#define CARD_MAX_DIAL_DIGITS            32

/*
// These time out values depend on the card firmware and media contraints.
// We should then see an answer within at most 30 seconds.
// When a call arrives, it should be accepted within 10 seconds.
*/
#define CARD_NO_ANSWER_TIMEOUT          (30*1000)   // 30 seconds
#define CARD_NO_ACCEPT_TIMEOUT          (10*1000)   // 10 seconds
#define CARD_NO_CLOSECALL_TIMEOUT       (5*1000)    // 5 seconds - NDISWAN_BUG

#define NULL_BUFFER_POOL                ((NDIS_HANDLE) 0xFFFFFFFF)

/* @doc INTERNAL Card Card_h CARD_RESOURCES


@struct CARD_RESOURCES |

    This structure contains the data associated with the hardware resources
    required to configure the NIC.  These values are isolated from the rest
    of the <t CARD_OBJECT> because they depend on the underlying hardware.

@comm

    The contents of this structure depends on compile time flags and should
    only include information about the resource actually used by the NIC.

    This structure is filled in by <f CardFindNIC> and is used to configure
    and allocate resources from NDIS when <f CardInitialize> is called.

*/

typedef struct CARD_RESOURCES
{
    NDIS_INTERFACE_TYPE         BusInterfaceType;           // @field
    // This value is used to tell NDIS what type of adapter this is.
    // This is usually the same as the registry parameter BusType, but
    // may be different in the case of a bridged adapter.

    BOOLEAN                     Master;                     // @field
    // This is TRUE if the adapter is capable of bus master transfers.
    // Use the <t CARD_IS_BUS_MASTER> defininition to set this value
    // so the other bus master values will be included if needed.
    // See <f NdisMAllocateMapRegisters> for more details on the bus
    // master parameters.

#if (CARD_IS_BUS_MASTER)
    BOOLEAN                     Dma32BitAddresses;          // @field
    // This is TRUE if the bus master device uses 32-bit addresses.
    // Almost always TRUE for today's devices.

    ULONG                       PhysicalMapRegistersNeeded; // @field
    // This should be set to the maximum number of outstanding DMA
    // transfers that can be active at one time.  One for each physical
    // buffer segment.

    ULONG                       MaximumPhysicalMapping;     // @field
    // This should be set to the maximum number of contigous bytes that
    // can make up a single DMA transfer.

    ULONG                       DmaChannel;                 // @field
    // This should only be set if your adapter is an ISA bus master and
    // requires the use of one of the host DMA channels.

#endif // (CARD_IS_BUS_MASTER)

#if defined(CARD_MIN_MEMORY_SIZE)
    ULONG                       MemoryLength;               // @field
    // The number of bytes of memory the NIC has on board.
    // Use the <t CARD_MIN_MEMORY_SIZE> defininition to set the minimum value
    // so the other NIC based memory values will be included if needed.

    NDIS_PHYSICAL_ADDRESS       MemoryPhysicalAddress;      // @field
    // System physical address assigned to the NIC's on board memory.

#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    ULONG                       IoPortLength;               // @field
    // The number of bytes of I/O ports the NIC has on board.
    // Use the <t CARD_MIN_IOPORT_SIZE> defininition to set the minimum value
    // so the other NIC based memory values will be included if needed.

    NDIS_PHYSICAL_ADDRESS       IoPortPhysicalAddress;      // @field
    // System physical address assigned to the NIC's on board I/O ports.

#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_REQUEST_ISR)
    ULONG                       InterruptVector;            // @field
    // System interrupt vector assigned to the NIC's interrupt request line.

    ULONG                       InterruptLevel;             // @field
    // System interrupt level assigned to the NIC's interrupt request line.

    ULONG                       InterruptMode;              // @field
    // Set this value to NdisInterruptLevelSensitive or NdisInterruptLatched.
    // Use the <t CARD_INTERRUPT_MODE> defininition to set this value.

    BOOLEAN                     InterruptShared;            // @field
    // Set TRUE if you want to allow the NIC's <f InterruptVector> to be
    // shared with other drivers in the system.
    // Use the <t CARD_INTERRUPT_SHARED> defininition to set this value.

#endif // defined(CARD_REQUEST_ISR)

} CARD_RESOURCES;


#if !defined(CARD_REQUEST_ISR)


/* @doc INTERNAL Card Card_h CARD_EVENT_CODE


@enum CARD_EVENT_CODE |

    This enumeration defines the events generated by the card.

*/

typedef enum CARD_EVENT_CODE
{
    CARD_EVENT_NULL,                                        // @emem
    // Not used for anything.

    CARD_EVENT_RING,                                        // @emem
    // Indicates that a call is incoming on the given BChannel.

    CARD_EVENT_CONNECT,                                     // @emem
    // Indicates that a call is connected on the given BChannel.

    CARD_EVENT_DISCONNECT,                                  // @emem
    // Indicates that a call is disconnected on the given BChannel.

    CARD_EVENT_RECEIVE,                                     // @emem
    // Indicates that a packet is incoming on the given BChannel.

    CARD_EVENT_TRANSMIT_COMPLETE                            // @emem
    // Indicates that the transmit is complete on the given BChannel.

} CARD_EVENT_CODE;

/* @doc INTERNAL Card Card_h CARD_EVENT_OBJECT


@struct CARD_EVENT_OBJECT |

    This structure is used to keep track of events passed between the
    callee and caller.  Each <t CARD_OBJECT> keeps a list of these events.
*/

typedef struct CARD_EVENT_OBJECT
{
    LIST_ENTRY                  Queue;                      // @field
    // Used to place the buffer on one of the receive lists.

    CARD_EVENT_CODE             ulEventCode;                // @field
    // Reason for event notification.

    PVOID                       pSendingObject;             // @field
    // Interface object that is notifying.  See <t BCHANNEL_OBJECT> or
    // <t DCHANNEL_OBJECT>,

    PVOID                       pReceivingObject;           // @field
    // Interface object that is notifying.  See <t BCHANNEL_OBJECT> or
    // <t DCHANNEL_OBJECT>,

    PNDIS_WAN_PACKET            pWanPacket;                 // @field
    // A pointer to the associated NDIS packet structure <t NDIS_WAN_PACKET>.

} CARD_EVENT_OBJECT, *PCARD_EVENT_OBJECT;

#endif // !defined(CARD_REQUEST_ISR)


/* @doc INTERNAL Card Card_h CARD_OBJECT


@struct CARD_OBJECT |

    This structure contains the data associated with the Network Interface
    Card (NIC).  This object is responsible for managing all the hardware
    specific components of the NIC.

@comm

    The <t MINIPORT_ADAPTER_OBJECT> manages the interface between NDIS and
    the driver, and then passes off the hardware specific interface to this
    object.  There is one <t CARD_OBJECT> for each <t MINIPORT_ADAPTER_OBJECT>.

    One of these objects is created each time that our <f MiniportInitialize>
    routine is called.  The NDIS wrapper calls this routine once for each of
    NIC installed and enabled in the system.  In the case of a hot swappable
    NIC (e.g. PCMCIA) the adapter might come and go several times during a
    single Windows session.

*/

typedef struct CARD_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'CARD'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    CARD_RESOURCES              ResourceInformation;        // @field
    // Contains adapter specific resource requirements and settings.
    // See <t CARD_RESOURCES>.

    ULONG                       InterruptStatus;            // @field
    // Bits indicating which interrupts need to be processed.

    NDIS_MINIPORT_INTERRUPT     Interrupt;                  // @field
    // Miniport interrupt object used by NDIS.

    USHORT                      ReceiveBuffersPerLink;      // @field
    // Maximum number of receive buffers per channel, registry parameter.

    USHORT                      TransmitBuffersPerLink;     // @field
    // Maximum number of transmit buffers per channel, registry parameter.

    USHORT                      BufferSize;                 // @field
    // The maxmimum packet size.  The NDISWAN spec says this must be 1500+32,
    // but everything seems to work okay if it is set smaller.

    ULONG                       NumChannels;                // @field
    // Number of communication channels configured on the NIC.

    ULONG                       NumPorts;                   // @field
    // Number of <t PORT_OBJECT>'s allocated in <p pPortArray>.

    PPORT_OBJECT *              pPortArray;                 // @field
    // An array of <t PORT_OBJECT>'s created by <f PortCreate>.
    // One entry for each port on NIC.

#if defined(PCI_BUS)
    ULONG                       PciSlotNumber;              // @field
    // PCI slot number for this adapter (FunctionNumber * 32) + DeviceNumber.

#endif // PCI_BUS

#if defined(CARD_MIN_MEMORY_SIZE)
    PCHAR                       pMemoryVirtualAddress;      // @field
    // Virtual adress of NIC memory area.

#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    PCHAR                       pIoPortVirtualAddress;      // @field
    // Virtual adress of NIC I/O port area.

#endif // CARD_MIN_IOPORT_SIZE

#if (CARD_IS_BUS_MASTER)
    ULONG                       MapRegisterIndex;           // @field
    // Next map register index to be used for DMA transfer.

    long                        MapRegistersInUse;          // @field
    // Number of map registers currently in use.

#endif // (CARD_IS_BUS_MASTER)

    ULONG                       TODO;                       // @field
    // Add your data members here.

    ULONG                       NumDChannels;               // @field
    // The sample driver uses this registry value to determine the number
    // of ports to simulate.

#if defined(SAMPLE_DRIVER)

    LIST_ENTRY                  EventList;                  // @field
    // Events waiting to be processed.  See <t CARD_EVENT_OBJECT>.

#   define MAX_EVENTS 32
    CARD_EVENT_OBJECT           EventArray[MAX_EVENTS];     // @field
    // Card event allocation array.

    ULONG                       NextEvent;                  // @field
    // Index into EventArray.

#endif // SAMPLE_DRIVER

} CARD_OBJECT;

#define GET_ADAPTER_FROM_CARD(pCard)            (pCard->pAdapter)


/*

    Object Interface Prototypes
*/

NDIS_STATUS CardCreate(
    OUT PCARD_OBJECT *          ppCard,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void CardDestroy(
    IN PCARD_OBJECT             pCard
    );

NDIS_STATUS CardInitialize(
    IN PCARD_OBJECT             pCard
    );

ULONG CardNumChannels(
    IN PCARD_OBJECT             pCard
    );

ULONG CardNumPorts(
    IN PCARD_OBJECT             pCard
    );

void CardInterruptHandler(
    IN PCARD_OBJECT             pCard
    );

NDIS_STATUS CardLineConnect(
    IN PCARD_OBJECT             pCard,
    IN PBCHANNEL_OBJECT         pBChannel
    );

void CardLineDisconnect(
    IN PCARD_OBJECT             pCard,
    IN PBCHANNEL_OBJECT         pBChannel
    );

BOOLEAN CardTransmitPacket(
    IN PCARD_OBJECT             pCard,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PNDIS_WAN_PACKET         pWanPacket
    );

PUCHAR CardGetReceiveInfo(
    IN PCARD_OBJECT             pCard,
    OUT PBCHANNEL_OBJECT *      ppBChannel,
    OUT PULONG                  pBytesReceived
    );

void CardReceiveComplete(
    IN PCARD_OBJECT             pCard,
    IN PBCHANNEL_OBJECT         pBChannel
    );

USHORT CardCleanPhoneNumber(
    OUT PUCHAR                  Dst,
    IN  PUCHAR                  Src,
    IN  USHORT                  Length
    );

NDIS_STATUS CardReset(
    IN PCARD_OBJECT             pCard
    );

#if defined(SAMPLE_DRIVER)

PBCHANNEL_OBJECT GET_BCHANNEL_FROM_PHONE_NUMBER(
    IN  PUCHAR                  pDialString
    );

VOID CardNotifyEvent(
    IN PCARD_OBJECT             pCard,
    IN PCARD_EVENT_OBJECT       pEvent
    );

PCARD_EVENT_OBJECT CardEventAllocate(
    IN PCARD_OBJECT             pCard
    );

VOID CardEventRelease(
    IN PCARD_OBJECT             pCard,
    IN PCARD_EVENT_OBJECT       pEvent
    );

#endif // SAMPLE_DRIVER

#endif // _CARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\bchannel.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL BChannel BChannel_c

@module BChannel.c |

    This module implements the interface to the <t BCHANNEL_OBJECT>.
    Supports the high-level channel control functions used by the NDIS WAN
    Minport driver.  This module isolates most the vendor specific channel
    access interfaces.  It will require some changes to accomodate your
    hardware device's channel access methods.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | BChannel_c

@end

*/

#define  __FILEID__             BCHANNEL_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                    g_BChannelInstanceCounter   // @globalv
// Keeps track of how many <t BCHANNEL_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL BChannel BChannel_c g_BChannelParameters


@topic 5.3 BChannel Parameters |

    This section describes the registry parameters read into the
    <t BCHANNEL_OBJECT>.

@globalv PARAM_TABLE | g_BChannelParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t BCHANNEL_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t BCHANNEL_OBJECT>
    you will need to modify <f BChannelReadParameters> and add the parameter
    definitions to the <f g_BChannelParameters> table.

*/

DBG_STATIC PARAM_TABLE              g_BChannelParameters[] =
{
    PARAM_ENTRY(BCHANNEL_OBJECT,
                TODO, PARAM_TODO,
                FALSE, NdisParameterInteger, 0,
                0, 0, 0),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL BChannel BChannel_c BChannelReadParameters


@func

    <f BChannelReadParameters> reads the BChannel parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f BChannelCreate>.

@rdesc

    <f BChannelReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

    <f Note>:
    If you add any registry based data members to <t BCHANNEL_OBJECT>
    you will need to modify <f BChannelReadParameters> and add the parameter
    definitions to the <f g_BChannelParameters> table.

*/

DBG_STATIC NDIS_STATUS BChannelReadParameters(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pBChannel,
                    g_BChannelParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pBChannel->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pBChannel->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL BChannel BChannel_c BChannelCreateObjects


@func

    <f BChannelCreateObjects> calls the create routines for all the objects
    contained in <t BCHANNEL_OBJECT>.  This should only be called
    by <f BChannelCreate>.

    <f Note>:
    If you add any new objects to <t BCHANNEL_OBJECT> you will need
    to modify <f BChannelCreateObjects> and <f BChannelDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f BChannelCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS BChannelCreateObjects(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelCreate


@func

    <f BChannelCreate> allocates memory for a <t BCHANNEL_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppBChannel> will be set to point to the newly created
    <t BCHANNEL_OBJECT>.  Otherwise, <p ppBChannel> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f BChannelDestroy> must be called to
    release the <t BCHANNEL_OBJECT> created by this function.

@rdesc

    <f BChannelCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelCreate(
    OUT PBCHANNEL_OBJECT *      ppBChannel,                 // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t BCHANNEL_OBJECT>.

    IN ULONG                    BChannelIndex,              // @parm
    // Index into the pBChannelArray.

    IN PUCHAR                   pTapiLineAddress,           // @parm
    // A pointer to the RAS/TAPI line address assigned to each RAS line.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("BChannelCreate")

    PBCHANNEL_OBJECT            pBChannel;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppBChannel = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pBChannel, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pBChannel->ObjectType = BCHANNEL_OBJECT_TYPE;
        pBChannel->ObjectID = ++g_BChannelInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pBChannel->pAdapter = pAdapter;
        pBChannel->BChannelIndex = BChannelIndex;

        strcpy(pBChannel->pTapiLineAddress, pTapiLineAddress);

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = BChannelReadParameters(pBChannel);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = BChannelCreateObjects(pBChannel);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppBChannel = pBChannel;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            BChannelDestroy(pBChannel);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelDestroyObjects


@func

    <f BChannelDestroyObjects> calls the destroy routines for all the objects
    contained in <t BCHANNEL_OBJECT>.  This should only be called by
    <f BChannelDestroy>.

    <f Note>:
    If you add any new objects to <t PBCHANNEL_OBJECT> you will need to
    modify <f BChannelCreateObjects> and <f BChannelDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void BChannelDestroyObjects(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL BChannel BChannel_c BChannelDestroy


@func

    <f BChannelDestroy> frees the memory for this <t BCHANNEL_OBJECT>.
    All memory allocated by <f BChannelCreate> will be released back to the
    OS.

*/

void BChannelDestroy(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pBChannel)
    {
        ASSERT(pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        BChannelDestroyObjects(pBChannel);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pBChannel->ObjectType = 0;
        FREE_OBJECT(pBChannel);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL BChannel BChannel_c BChannelInitialize


@func

    <f BChannelInitialize> resets all the internal data members contained
    in <t BCHANNEL_OBJECT> back to their initial state.

    <f Note>:
    If you add any new members to <t BCHANNEL_OBJECT> you will need to
    modify <f BChannelInitialize> to initialize your new data mamebers.

*/

void BChannelInitialize(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelInitialize")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);


    /*
    // Initially, the BChannel is not allocated to anyone and these fields
    // must be reset.
    */
    ASSERT(pBChannel->NdisLinkContext == NULL);
    ASSERT(pBChannel->htLine == (HTAPI_LINE)0);
    ASSERT(pBChannel->htCall == (HTAPI_CALL)0);

    /*
    // Setup the static features of the link.
    */
    pBChannel->LinkSpeed         = _64KBPS;
    pBChannel->BearerModesCaps   = LINEBEARERMODE_DATA
                                 | LINEBEARERMODE_VOICE
                                 ;
    pBChannel->MediaModesCaps    = LINEMEDIAMODE_DIGITALDATA
                                 | LINEMEDIAMODE_UNKNOWN
                                 // | LINEMEDIAMODE_DATAMODEM
                                 ;

    /*
    // Initialize the TAPI event capabilities supported by the link.
    */
    pBChannel->DevStatesCaps     = LINEDEVSTATE_RINGING
                                 | LINEDEVSTATE_CONNECTED
                                 | LINEDEVSTATE_DISCONNECTED
                                 | LINEDEVSTATE_INSERVICE
                                 | LINEDEVSTATE_OUTOFSERVICE
                                 | LINEDEVSTATE_OPEN
                                 | LINEDEVSTATE_CLOSE
                                 | LINEDEVSTATE_REINIT
                                 ;
    pBChannel->AddressStatesCaps = 0;
    pBChannel->CallStatesCaps    = LINECALLSTATE_IDLE
                                 | LINECALLSTATE_DIALTONE
                                 | LINECALLSTATE_DIALING
                                 | LINECALLSTATE_PROCEEDING
                                 | LINECALLSTATE_RINGBACK
                                 | LINECALLSTATE_BUSY
                                 | LINECALLSTATE_OFFERING
                                 | LINECALLSTATE_ACCEPTED
                                 | LINECALLSTATE_CONNECTED
                                 | LINECALLSTATE_DISCONNECTED
                                 ;

    /*
    // We use this timer to keep track of incoming and outgoing call
    // status, and to provide timeouts for certain call states.
    */
    NdisMInitializeTimer(
            &pBChannel->CallTimer,
            pAdapter->MiniportAdapterHandle,
            TspiCallTimerHandler,
            pBChannel
            );

    /*
    // Set the TransmitBusyList and ReceivePendingList to empty.
    */
    InitializeListHead(&pBChannel->TransmitBusyList);
    InitializeListHead(&pBChannel->ReceivePendingList);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL BChannel BChannel_c BChannelOpen


@func

    <f BChannelOpen> makes the BChannel connection ready to transmit and
    receive data.

@rdesc

    <f BChannelOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelOpen(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN HTAPI_LINE               htLine
    )
{
    DBG_FUNC("BChannelOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    if (!pBChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Opening BChannel #%d\n",
                   pBChannel->ObjectID));

        /*
        // The htLine field is used to associate this BChannel with the
        // TAPI Connection Wrapper.  Reset all the state information for
        // this BChannel.
        */
        pBChannel->htLine            = htLine;
        pBChannel->CallClosing       = FALSE;
        // Don't clear the line state flags that are set by card.c
        pBChannel->DevState         &= (LINEDEVSTATE_CONNECTED |
                                        LINEDEVSTATE_INSERVICE);
        pBChannel->DevStatesMask     = 0;    // Default to indicate no line events
        pBChannel->AddressState      = 0;
        pBChannel->AddressStatesMask = 0;    // Default to indicate no address events
        pBChannel->CallState         = 0;
        pBChannel->CallStateMode     = 0;
        pBChannel->CallStatesMask    = pBChannel->CallStatesCaps;
        pBChannel->MediaMode         = 0;
        pBChannel->MediaModesMask    = 0;
        pBChannel->TotalRxPackets    = 0;
        pBChannel->AppSpecificCallInfo = 0;

        /*
        // Initialize the default BChannel information structure.  It may be
        // changed later by MiniportSetInformation.
        */
        pBChannel->WanLinkInfo.MiniportLinkContext = pBChannel;
        pBChannel->WanLinkInfo.MaxSendFrameSize = pAdapter->WanInfo.MaxFrameSize;
        pBChannel->WanLinkInfo.MaxRecvFrameSize = pAdapter->WanInfo.MaxFrameSize;
        pBChannel->WanLinkInfo.SendFramingBits  = pAdapter->WanInfo.FramingBits;
        pBChannel->WanLinkInfo.RecvFramingBits  = pAdapter->WanInfo.FramingBits;
        pBChannel->WanLinkInfo.SendACCM         = pAdapter->WanInfo.DesiredACCM;
        pBChannel->WanLinkInfo.RecvACCM         = pAdapter->WanInfo.DesiredACCM;

#if defined(SAMPLE_DRIVER)
        // Sample just tells tapi that the line is connected and in service.
        TspiLineDevStateHandler(pAdapter, pBChannel, LINEDEVSTATE_CONNECTED);
        TspiLineDevStateHandler(pAdapter, pBChannel, LINEDEVSTATE_INSERVICE);
#else  // SAMPLE_DRIVER
        // TODO - Add code here
        TspiLineDevStateHandler(pAdapter, pBChannel, LINEDEVSTATE_CONNECTED);
#endif // SAMPLE_DRIVER

        pBChannel->IsOpen = TRUE;
    }
    else
    {
        DBG_ERROR(pAdapter,("BChannel #%d already opened\n",
                  pBChannel->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelClose


@func

    <f BChannelClose> closes the given B-channel.

*/

void BChannelClose(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    if (pBChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Closing BChannel #%d\n",
                   pBChannel->ObjectID));

        /*
        // Make sure call is cleared and B channel is disabled.
        */
        DChannelCloseCall(pAdapter->pDChannel, pBChannel);

        // TODO - Add code here

        // Don't clear the line state flags that are set by card.c
        pBChannel->DevState       &= (LINEDEVSTATE_CONNECTED |
                                      LINEDEVSTATE_INSERVICE);
        pBChannel->CallState       = 0;
        pBChannel->htLine          = (HTAPI_LINE)0;
        pBChannel->htCall          = (HTAPI_CALL)0;
        pBChannel->NdisLinkContext = NULL;

        pBChannel->IsOpen = FALSE;
    }
    else
    {
        DBG_ERROR(pAdapter,("BChannel #%d already closed\n",
                  pBChannel->ObjectID));
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL BChannel BChannel_c BChannelAddToReceiveQueue


@func

    <f BChannelAddToReceiveQueue> adds a buffer to the queue of available
    receive buffers associated with this B-channel.

@rdesc

    <f BChannelAddToReceiveQueue> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelAddToReceiveQueue(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PVOID                    pReceiveContext,            // @parm
    // A context value to be passed back to <f TransmitComplete>.

    IN PUCHAR                   BufferPointer,              // @parm
    //  A pointer to the buffer to be transmitted.

    IN ULONG                    BufferSize                  // @parm
    // The size in bytes of the buffer to be transmitted.
    )
{
    DBG_FUNC("BChannelAddToReceiveQueue")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pBChannel->IsOpen);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelAddToTransmitQueue


@func

    <f BChannelAddToTransmitQueue>  adds a buffer to the queue of buffers
    to be transmitted on this B-channel.

@rdesc

    <f BChannelAddToTransmitQueue> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelAddToTransmitQueue(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PVOID                    pTransmitContext,           // @parm
    // A context value to be passed back to <f TransmitComplete>.

    IN PUCHAR                   BufferPointer,              // @parm
    //  A pointer to the buffer to be transmitted.

    IN ULONG                    BufferSize                  // @parm
    // The size in bytes of the buffer to be transmitted.
    )
{
    DBG_FUNC("BChannelAddToTransmitQueue")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pBChannel->IsOpen);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\dchannel.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL DChannel DChannel_c

@module DChannel.c |

    This module implements the interface to the <t DCHANNEL_OBJECT>.
    Supports the high-level channel control functions used by the NDIS WAN
    Minport driver.  This module isolates most the vendor specific Call
    Control interfaces.  It will require some changes to accomodate your
    hardware device's call control mechanism.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | DChannel_c

@end

*/

#define  __FILEID__             DCHANNEL_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                    g_DChannelInstanceCounter   // @globalv
// Keeps track of how many <t DCHANNEL_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL DChannel DChannel_c g_DChannelParameters


@topic 5.4 DChannel Parameters |

    This section describes the registry parameters read into the
    <t DCHANNEL_OBJECT>.

@globalv PARAM_TABLE | g_DChannelParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t DCHANNEL_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t DCHANNEL_OBJECT>
    you will need to modify <f DChannelReadParameters> and add the parameter
    definitions to the <f g_DChannelParameters> table.

*/

DBG_STATIC PARAM_TABLE              g_DChannelParameters[] =
{
    PARAM_ENTRY(DCHANNEL_OBJECT,
                TODO, PARAM_TODO,
                FALSE, NdisParameterInteger, 0,
                0, 0, 0),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL DChannel DChannel_c DChannelReadParameters


@func

    <f DChannelReadParameters> reads the DChannel parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f DChannelCreate>.

    <f Note>:
    If you add any registry based data members to <t DCHANNEL_OBJECT>
    you will need to modify <f DChannelReadParameters> and add the parameter
    definitions to the <f g_DChannelParameters> table.

@rdesc

    <f DChannelReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS DChannelReadParameters(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pDChannel,
                    g_DChannelParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pDChannel->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pDChannel->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCreateObjects


@func

    <f DChannelCreateObjects> calls the create routines for all the objects
    contained in <t DCHANNEL_OBJECT>.  This should only be called
    by <f DChannelCreate>.

    <f Note>:
    If you add any new objects to <t DCHANNEL_OBJECT> you will need
    to modify <f DChannelCreateObjects> and <f DChannelDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f DChannelCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS DChannelCreateObjects(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to allocate any sub-objects needed to support
    // your physical DChannels.

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCreate


@func

    <f DChannelCreate> allocates memory for a <t DCHANNEL_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppDChannel> will be set to point to the newly created
    <t DCHANNEL_OBJECT>.  Otherwise, <p ppDChannel> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f DChannelDestroy> must be called to
    release the <t DCHANNEL_OBJECT> created by this function.

@rdesc

    <f DChannelCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelCreate(
    OUT PDCHANNEL_OBJECT *      ppDChannel,                 // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t DCHANNEL_OBJECT>.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("DChannelCreate")

    PDCHANNEL_OBJECT            pDChannel;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppDChannel = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pDChannel, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pDChannel->ObjectType = DCHANNEL_OBJECT_TYPE;
        pDChannel->ObjectID = ++g_DChannelInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pDChannel->pAdapter = pAdapter;

        // TODO - Add code here to allocate any resources needed to support
        // your physical DChannels.

        /*
        // Parse the registry parameters.
        */
        Result = DChannelReadParameters(pDChannel);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = DChannelCreateObjects(pDChannel);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppDChannel = pDChannel;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            DChannelDestroy(pDChannel);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelDestroyObjects


@func

    <f DChannelDestroyObjects> calls the destroy routines for all the objects
    contained in <t DCHANNEL_OBJECT>.  This should only be called by
    <f DChannelDestroy>.

    <f Note>: If you add any new objects to <t PDCHANNEL_OBJECT> you will need to
    modify <f DChannelCreateObjects> and <f DChannelDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void DChannelDestroyObjects(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to release any sub-objects allocated by
    // DChannelCreateObjects.

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelDestroy


@func

    <f DChannelDestroy> frees the memory for this <t DCHANNEL_OBJECT>.
    All memory allocated by <f DChannelCreate> will be released back to the
    OS.

*/

void DChannelDestroy(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pDChannel)
    {
        ASSERT(pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

        DBG_ENTER(pAdapter);

        // TODO - Add code here to release any resources allocated by
        // DChannelCreate.

        /*
        // Release all objects allocated within this object.
        */
        DChannelDestroyObjects(pDChannel);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pDChannel->ObjectType = 0;
        FREE_OBJECT(pDChannel);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL DChannel DChannel_c DChannelInitialize


@func

    <f DChannelInitialize> resets all the internal data members contained
    in <t BCHANNEL_OBJECT> back to their initial state.

    <f Note>:
    If you add any new members to <t DCHANNEL_OBJECT> you will need to
    modify <f DChannelInitialize> to initialize your new data mamebers.

*/

void DChannelInitialize(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelInitialize")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to initialize all the physical D-Channels on
    // your adapter.

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelOpen


@func

    <f DChannelOpen> establishes a communications path between the miniport
    and the DChannel.

@rdesc

    <f DChannelOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelOpen(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    if (!pDChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Opening DChannel #%d\n",
                   pDChannel->ObjectID));

        // TODO - Add code here to open all the physical D-Channels on
        // your adapter.

        pDChannel->IsOpen = TRUE;
    }
    else
    {
        DBG_ERROR(pAdapter,("DChannel #%d already opened\n",
                  pDChannel->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelClose


@func

    <f DChannelClose> tears down the communications path between the miniport
    and the DChannel.

*/

void DChannelClose(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    if (pDChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Closing DChannel #%d\n",
                   pDChannel->ObjectID));

        // TODO - Add code here to close all the physical D-Channels on
        // your adapter.

        pDChannel->IsOpen = FALSE;
    }
    else
    {
        DBG_WARNING(pAdapter,("DChannel #%d already closed\n",
                    pDChannel->ObjectID));
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelMakeCall


@func

    <f DChannelMakeCall> places a call over the selected line device.

@rdesc

    <f DChannelMakeCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelMakeCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PUCHAR                   DialString,                 // @parm
    // A pointer to an ASCII null-terminated string of digits.

    IN USHORT                   DialStringLength,           // @parm
    // Number of bytes in dial string.

    IN PLINE_CALL_PARAMS        pLineCallParams             // @parm
    // A pointer to the TAPI <t LINE_CALL_PARAMS> to be used for this call.
    )
{
    DBG_FUNC("DChannelMakeCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    pDChannel->TotalMakeCalls++;

#if defined(SAMPLE_DRIVER)
    // This sample code uses the phone number to select one of the other
    // BChannels on which to complete the connection.
{
    PBCHANNEL_OBJECT            pPeerBChannel;
    PCARD_EVENT_OBJECT          pEvent;

    pPeerBChannel = GET_BCHANNEL_FROM_PHONE_NUMBER(DialString);
    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            /*
            // Start the call state sequence so we don't leave it in the
            // IDLE state.
            */
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_DIALING,
                                 0);

            /*
            // We should get an answer within N seconds if the call has gone
            // through.
            */
            NdisMSetTimer(&pBChannel->CallTimer, pAdapter->NoAnswerTimeOut);

            pEvent->ulEventCode      = CARD_EVENT_RING;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            pBChannel->pPeerBChannel = pPeerBChannel;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
        }
        else
        {
            Result = NDIS_STATUS_TAPI_RESOURCEUNAVAIL;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("Cannot map phone number '%s' to BChannel\n",
                  DialString));
        Result = NDIS_STATUS_TAPI_INVALPARAM;
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to place a call.
#endif // SAMPLE_DRIVER

    if (Result == NDIS_STATUS_SUCCESS)
    {
        LinkLineUp(pBChannel);
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelAnswer


@func

    <f DChannelAnswer> answers the incoming call so it can be connected.

@rdesc

    <f DChannelAnswer> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelAnswer(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelAnswer")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    pDChannel->TotalAnswers++;

#if defined(SAMPLE_DRIVER)
    // This sample code sends a connect over to the calling BChannel.
{
    PCARD_EVENT_OBJECT          pEvent;
    PBCHANNEL_OBJECT            pPeerBChannel = pBChannel->pPeerBChannel;

    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            pEvent->ulEventCode      = CARD_EVENT_CONNECT;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);

            // Indicate call connected to the calling channel.
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_CONNECTED,
                                 0);
        }
        else
        {
            Result = NDIS_STATUS_TAPI_CALLUNAVAIL;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("pPeerBChannel == NULL\n"));
        Result = NDIS_STATUS_TAPI_CALLUNAVAIL;
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to answer a call.
#endif // SAMPLE_DRIVER

    if (Result == NDIS_STATUS_SUCCESS)
    {
        LinkLineUp(pBChannel);
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelDropCall


@func

    <f DChannelDropCall> drops a previously opened call instance.  The call
    remains open and can be queried after the call is dropped.

@rdesc

    <f DChannelDropCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelDropCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelDropCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    // Tell NDIS that the link is no longer available.
    LinkLineDown(pBChannel);

    // This routine may be called several times during line/call cleanup.
    // If the call is already closed, just return success.
    if (pBChannel->CallState != 0 &&
        pBChannel->CallState != LINECALLSTATE_IDLE)
    {
#if defined(SAMPLE_DRIVER)
        // This sample code sends a disconnect over to the connected BChannel.
        PCARD_EVENT_OBJECT      pEvent;
        PBCHANNEL_OBJECT        pPeerBChannel = pBChannel->pPeerBChannel;

        if (pPeerBChannel)
        {
            pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
            if (pEvent)
            {
                pEvent->ulEventCode      = CARD_EVENT_DISCONNECT;
                pEvent->pSendingObject   = pBChannel;
                pEvent->pReceivingObject = pPeerBChannel;
                CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            }
            pBChannel->pPeerBChannel = NULL;
            // Indicate call discconect to the calling channel.
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_DISCONNECTED,
                                 LINEDISCONNECTMODE_NORMAL);
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_IDLE,
                                 0);
        }
        else
        {
            DBG_WARNING(pAdapter,("#%d NO PEER CHANNEL - CALLSTATE=%X\n",
                        pBChannel->BChannelIndex, pBChannel->CallState));
        }
#else  // SAMPLE_DRIVER
        // TODO - Add code here to drop a call.
#endif // SAMPLE_DRIVER
    }
    else
    {
        DBG_NOTICE(pAdapter,("#%d ALREADY IDLE - CALLSTATE=%X\n",
                   pBChannel->BChannelIndex, pBChannel->CallState));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCloseCall


@func

    <f DChannelCloseCall> closes a previously opened call instance as
    initiated from <f DChannelMakeCall> or <f DChannelAnswer>.  After the
    call is closed, no one else should reference it.

@rdesc

    <f DChannelCloseCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelCloseCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelCloseCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    // This routine may be called several times during line/call cleanup.
    // If the call is already closed, just return success.
    if (pBChannel->CallState != 0)
    {
        // Make sure the call is dropped before closing.
        DChannelDropCall(pDChannel, pBChannel);
        pBChannel->CallState = 0;
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelRejectCall


@func

    <f DChannelRejectCall> rejects an incoming call as initiated from a
    LINEDEVSTATE_RINGING event sent to <f TspiLineDevStateHandler>.

*/

VOID DChannelRejectCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelRejectCall")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to reject an incoming call.

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\card.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Card Card_c

@module Card.c |

    This module implements the interface to the <t CARD_OBJECT>.
    Supports the low-level hardware control functions used by the NDIS WAN
    Minport driver.  This module isolates most the vendor specific hardware
    access interfaces.  It will require signficant changes to accomodate
    your hardware device.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Card_c

@end

*/

#define  __FILEID__             CARD_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                    g_CardInstanceCounter       // @globalv
// Keeps track of how many <t CARD_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL Card Card_c g_CardParameters


@topic 5.3 Card Parameters |

    This section describes the registry parameters read into the
    <t CARD_OBJECT>.

@globalv PARAM_TABLE | g_CardParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t CARD_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t CARD_OBJECT>
    you will need to modify <f CardReadParameters> and add the parameter
    definitions to the <f g_CardParameters> table.

*/

DBG_STATIC PARAM_TABLE              g_CardParameters[] =
{
#if defined(PCI_BUS)
    PARAM_ENTRY(CARD_OBJECT,
                PciSlotNumber, PARAM_PciSlotNumber,
                TRUE, NdisParameterInteger, 0,
                0, 0, 31),
#endif // PCI_BUS

    PARAM_ENTRY(CARD_OBJECT,
                BufferSize, PARAM_BufferSize,
                FALSE, NdisParameterInteger, 0,
                CARD_DEFAULT_PACKET_SIZE, CARD_MIN_PACKET_SIZE, CARD_MAX_PACKET_SIZE),

    PARAM_ENTRY(CARD_OBJECT,
                ReceiveBuffersPerLink, PARAM_ReceiveBuffersPerLink,
                FALSE, NdisParameterInteger, 0,
                2, 2, 16),

    PARAM_ENTRY(CARD_OBJECT,
                TransmitBuffersPerLink, PARAM_TransmitBuffersPerLink,
                FALSE, NdisParameterInteger, 0,
                2, 1, 16),

    PARAM_ENTRY(CARD_OBJECT,
                NumDChannels, PARAM_NumDChannels,
                FALSE, NdisParameterInteger, 0,
                1, 1, 4),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL Card Card_c CardReadParameters


@func

    <f CardReadParameters> reads the Card parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f CardCreate>.

    <f Note>:
    If you add any registry based data members to <t CARD_OBJECT>
    you will need to modify <f CardReadParameters> and add the parameter
    definitions to the <f g_CardParameters> table.

@rdesc

    <f CardReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardReadParameters(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pCard,
                    g_CardParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pCard->BufferSize & 0x1F)
        {
            DBG_ERROR(pAdapter,("Invalid value 'BufferSize'=0x0x%X must be multiple of 32\n",
                        pCard->BufferSize));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pCard->BufferSize,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Card Card_c CardFindNIC


@func

    <f CardFindNIC> locates the NIC associated with this NDIS device.

@rdesc

    <f CardFindNIC> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardFindNIC(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardFindNIC")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

#if defined(PCI_BUS)
    ULONG                       Index;
    // Loop counter.

    PNDIS_RESOURCE_LIST         pPciResourceList;

    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPciResource;

#endif // PCI_BUS

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

#if defined(PCI_BUS)
    /*
    // Read the PCI data and initialize the driver data structure
    // with the data returned.
    */
    pPciResourceList = NULL;

    Result = NdisMPciAssignResources(pAdapter->MiniportAdapterHandle,
                                     pCard->PciSlotNumber,
                                     &pPciResourceList);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(pAdapter,("NdisMPciAssignResources Result=0x%X\n",
                  Result));
        NdisWriteErrorLogEntry(
                pAdapter->MiniportAdapterHandle,
                NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                4,
                pCard->PciSlotNumber,
                Result,
                __FILEID__,
                __LINE__
                );
    }

    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < pPciResourceList->Count; ++Index)
    {
        ASSERT(pPciResourceList);
        pPciResource = &pPciResourceList->PartialDescriptors[Index];
        ASSERT(pPciResource);

        switch (pPciResource->Type)
        {
        case CmResourceTypePort:
#if defined(CARD_MIN_IOPORT_SIZE)
            if (pPciResource->u.Port.Start.LowPart &&
                pPciResource->u.Port.Length >= CARD_MIN_IOPORT_SIZE)
            {
                DBG_NOTICE(pAdapter,("Port: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Port.Start.LowPart,
                          pPciResource->u.Port.Length,
                          CARD_MIN_IOPORT_SIZE));
                pCard->ResourceInformation.IoPortPhysicalAddress =
                        pPciResource->u.Port.Start;
                pCard->ResourceInformation.IoPortLength =
                        pPciResource->u.Port.Length;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Port: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Port.Start,
                          pPciResource->u.Port.Length,
                          CARD_MIN_IOPORT_SIZE));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Port.Length,
                        CARD_MIN_IOPORT_SIZE,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
#endif // CARD_MIN_IOPORT_SIZE
            break;

        case CmResourceTypeInterrupt:
#if defined(CARD_REQUEST_ISR)
            if (pPciResource->u.Interrupt.Level)
            {
                DBG_NOTICE(pAdapter,("Interrupt: Lev=%d,Vec=%d\n",
                           pPciResource->u.Interrupt.Level,
                           pPciResource->u.Interrupt.Vector));
                pCard->ResourceInformation.InterruptLevel =
                        pPciResource->u.Interrupt.Level;
                pCard->ResourceInformation.InterruptVector =
                        pPciResource->u.Interrupt.Vector;

                pCard->ResourceInformation.InterruptShared = CARD_INTERRUPT_SHARED;
                pCard->ResourceInformation.InterruptMode = CARD_INTERRUPT_MODE;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Interrupt: Lev=%d,Vec=%d\n",
                          pPciResource->u.Interrupt.Level,
                          pPciResource->u.Interrupt.Vector));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Interrupt.Level,
                        pPciResource->u.Interrupt.Vector,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
#endif // defined(CARD_REQUEST_ISR)
            break;

        case CmResourceTypeMemory:
#if defined(CARD_MIN_MEMORY_SIZE)
            if (pPciResource->u.Memory.Start.LowPart &&
                pPciResource->u.Memory.Length >= CARD_MIN_MEMORY_SIZE)
            {
                DBG_NOTICE(pAdapter,("Memory: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Memory.Start.LowPart,
                          pPciResource->u.Memory.Length,
                          CARD_MIN_MEMORY_SIZE));
                pCard->ResourceInformation.MemoryPhysicalAddress =
                        pPciResource->u.Memory.Start;
                pCard->ResourceInformation.MemoryLength =
                        pPciResource->u.Memory.Length;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Memory: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Memory.Start.LowPart,
                          pPciResource->u.Memory.Length,
                          CARD_MIN_MEMORY_SIZE));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Memory.Length,
                        CARD_MIN_MEMORY_SIZE,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
            break;
#endif // CARD_MIN_MEMORY_SIZE

        default:
            DBG_ERROR(pAdapter,("Unknown resource type=%d\n",
                      pPciResource->Type));
            break;
        }
    }
    pCard->ResourceInformation.BusInterfaceType = NdisInterfacePci;

#endif // PCI_BUS

    pCard->ResourceInformation.Master = CARD_IS_BUS_MASTER;
#if (CARD_IS_BUS_MASTER)
    pCard->ResourceInformation.DmaChannel = 0;
    pCard->ResourceInformation.Dma32BitAddresses = TRUE,
    pCard->ResourceInformation.MaximumPhysicalMapping = pCard->BufferSize;
    pCard->ResourceInformation.PhysicalMapRegistersNeeded = CARD_MAP_REGISTERS_NEEDED;
#endif // (CARD_IS_BUS_MASTER)

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreateInterface


@func

    <f CardCreateInterface> allocates a shared memory pool and uses it to
    establish the message interface between the Miniport and the NIC.

@rdesc

    <f CardCreateInterface> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardCreateInterface(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreateObjects


@func

    <f CardCreateObjects> calls the create routines for all the objects
    contained in <t CARD_OBJECT>.  This should only be called
    by <f CardCreate>.

    <f Note>:
    If you add any new objects to <t CARD_OBJECT> you will need
    to modify <f CardCreateObjects> and <f CardDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f CardCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardCreateObjects(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ULONG                       Index;
    // Loop counter.

    ULONG                       NumPorts;
    // The number of Ports supported by the NIC.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Try to locate the NIC on the PCI bus.
    */
    Result = CardFindNIC(pCard);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        goto ExceptionExit;
    }

    /*
    // Create the message interface to the NIC.
    */
    Result = CardCreateInterface(pCard);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        goto ExceptionExit;
    }

    /*
    // Create the Port objects.
    */
    NumPorts = CardNumPorts(pCard);
    Result = ALLOCATE_MEMORY(pCard->pPortArray,
                             sizeof(PVOID) * NumPorts,
                             pAdapter->MiniportAdapterHandle);
    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < NumPorts; Index++)
    {
        Result = PortCreate(&pCard->pPortArray[Index], pCard);

        /*
        // Keep track of how many are created.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            pCard->NumPorts++;
        }
    }

ExceptionExit:

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreate


@func

    <f CardCreate> allocates memory for a <t CARD_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppCard> will be set to point to the newly created
    <t CARD_OBJECT>.  Otherwise, <p ppCard> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f CardDestroy> must be called to
    release the <t CARD_OBJECT> created by this function.

@rdesc

    <f CardCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardCreate(
    OUT PCARD_OBJECT *          ppCard,                     // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t CARD_OBJECT>.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("CardCreate")

    PCARD_OBJECT                pCard;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppCard = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pCard, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pCard->ObjectType = CARD_OBJECT_TYPE;
        pCard->ObjectID = ++g_CardInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pCard->pAdapter = pAdapter;

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = CardReadParameters(pCard);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = CardCreateObjects(pCard);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppCard = pCard;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            CardDestroy(pCard);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardDestroyObjects


@func

    <f CardDestroyObjects> calls the destroy routines for all the objects
    contained in <t CARD_OBJECT>.  This should only be called by
    <f CardDestroy>.

    <f Note>:
    If you add any new objects to <t PCARD_OBJECT> you will need to
    modify <f CardCreateObjects> and <f CardDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void CardDestroyObjects(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardDestroyObjects")

    ULONG                       NumPorts;
    // The number of Ports supported by the NIC.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    /*
    // Destory the Port objects.
    */
    NumPorts = pCard->NumPorts;
    while (NumPorts--)
    {
        PortDestroy(pCard->pPortArray[NumPorts]);
    }
    pCard->NumPorts = 0;

    /*
    // Free space for the Ports.
    */
    if (pCard->pPortArray)
    {
        NumPorts = CardNumPorts(pCard);
        FREE_MEMORY(pCard->pPortArray, sizeof(PVOID) * NumPorts);
    }

    /*
    // Release the system resources back to NDIS.
    */
#if defined(CARD_REQUEST_ISR)
    if (pCard->Interrupt.InterruptObject)
    {
        NdisMDeregisterInterrupt(&pCard->Interrupt);
        pCard->Interrupt.InterruptObject = NULL;
    }
#endif // defined(CARD_REQUEST_ISR)

#if defined(CARD_MIN_IOPORT_SIZE)
    if (pCard->pIoPortVirtualAddress)
    {
        NdisMDeregisterIoPortRange(
                pAdapter->MiniportAdapterHandle,
                pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                pCard->ResourceInformation.IoPortLength,
                pCard->pIoPortVirtualAddress);
        pCard->pIoPortVirtualAddress = NULL;
    }
#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_MIN_MEMORY_SIZE)
    if (pCard->pMemoryVirtualAddress)
    {
        NdisMUnmapIoSpace(
                pAdapter->MiniportAdapterHandle,
                pCard->pMemoryVirtualAddress,
                pCard->ResourceInformation.MemoryLength
                );
        pCard->pMemoryVirtualAddress = NULL;
    }
#endif // CARD_MIN_MEMORY_SIZE

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardDestroy


@func

    <f CardDestroy> frees the memory for this <t CARD_OBJECT>.  All memory
    allocated by <f CardCreate> will be released back to the OS.

*/

void CardDestroy(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pCard)
    {
        ASSERT(pCard->ObjectType == CARD_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_CARD(pCard);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        CardDestroyObjects(pCard);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pCard->ObjectType = 0;
        FREE_OBJECT(pCard);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Card Card_c CardNumPorts


@func

    <f CardNumPorts> will return the total number of ports available on the
    NIC.

@rdesc

    <f CardNumPorts> returns the total number of ports available.

*/

ULONG CardNumPorts(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardNumPorts")

    // TODO - Get the actual number of ports from the card.
    return (pCard->NumDChannels);
}


/* @doc INTERNAL Card Card_c CardNumChannels


@func

    <f CardNumChannels> will return the total number of channels capable
    of supporting data connections to a remote end-point.

@rdesc

    <f CardNumChannels> returns the total number of data channels supported
    on all the NIC ports.

*/

ULONG CardNumChannels(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardNumChannels")

    UINT                        PortIndex;
    // Loop index.

    if (pCard->NumChannels == 0)
    {
        // NumPorts should already be known.
        ASSERT(pCard->NumPorts);

        // Get the actual number of channels configured on all ports.
        for (PortIndex = 0; PortIndex < pCard->NumPorts; PortIndex++)
        {
            pCard->NumChannels += pCard->pPortArray[PortIndex]->NumChannels;
        }
        ASSERT(pCard->NumChannels);
    }

    return (pCard->NumChannels);
}


/* @doc INTERNAL Card Card_c CardInitialize


@func

    <f CardInitialize> will attempt to initialize the NIC, but will not
    enable transmits or receives.

@rdesc

    <f CardInitialize> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardInitialize(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardInitialize")

    int                         num_dial_chan = 0;
    int                         num_sync_chan = 0;
    // The number of channels supported by card is based on InterfaceType.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Inform the wrapper of the physical attributes of this adapter.
    // This must be called before any NdisMRegister functions!
    // This call also associates the MiniportAdapterHandle with this pAdapter.
    */
    NdisMSetAttributes(pAdapter->MiniportAdapterHandle,
                       (NDIS_HANDLE) pAdapter,
                       pCard->ResourceInformation.Master,
                       pCard->ResourceInformation.BusInterfaceType
                       );
#if (CARD_IS_BUS_MASTER)
    if (pCard->ResourceInformation.Master)
    {
        ASSERT(pCard->ResourceInformation.DmaChannel == 0 ||
               pCard->ResourceInformation.BusInterfaceType == NdisInterfaceIsa);
        Result = NdisMAllocateMapRegisters(
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.DmaChannel,
                        pCard->ResourceInformation.Dma32BitAddresses,
                        pCard->ResourceInformation.PhysicalMapRegistersNeeded + 1,
                        pCard->ResourceInformation.MaximumPhysicalMapping
                        );

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMAllocateMapRegisters(%d,%d) Result=0x%X\n",
                      pCard->ResourceInformation.PhysicalMapRegistersNeeded,
                      pCard->ResourceInformation.MaximumPhysicalMapping,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.PhysicalMapRegistersNeeded,
                    pCard->ResourceInformation.MaximumPhysicalMapping,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
    }
#endif // (CARD_IS_BUS_MASTER)

#if defined(CARD_MIN_MEMORY_SIZE)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.MemoryLength)
    {
        Result = NdisMMapIoSpace(
                        &pCard->pMemoryVirtualAddress,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.MemoryPhysicalAddress,
                        pCard->ResourceInformation.MemoryLength);

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMMapIoSpace(0x%X,0x%X) Result=0x%X\n",
                      pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                      pCard->ResourceInformation.MemoryLength,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                    pCard->ResourceInformation.MemoryLength,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            DBG_NOTICE(pAdapter,("NdisMMapIoSpace(0x%X,0x%X) VirtualAddress=0x%X\n",
                      pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                      pCard->ResourceInformation.MemoryLength,
                      pCard->pMemoryVirtualAddress));
        }
    }
#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.IoPortLength)
    {
        Result = NdisMRegisterIoPortRange(
                        &pCard->pIoPortVirtualAddress,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                        pCard->ResourceInformation.IoPortLength);

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMRegisterIoPortRange(0x%X,0x%X) Result=0x%X\n",
                      pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                      pCard->ResourceInformation.IoPortLength,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                    pCard->ResourceInformation.IoPortLength,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            DBG_NOTICE(pAdapter,("NdisMRegisterIoPortRange(0x%X,0x%X) VirtualAddress=0x%X\n",
                      pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                      pCard->ResourceInformation.IoPortLength,
                      pCard->pIoPortVirtualAddress));
        }
    }
#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_REQUEST_ISR)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.InterruptVector)
    {
        ASSERT(pCard->ResourceInformation.InterruptShared == FALSE ||
               (pCard->ResourceInformation.InterruptMode == NdisInterruptLevelSensitive &&
                CARD_REQUEST_ISR == TRUE));
        Result = NdisMRegisterInterrupt(
                        &pCard->Interrupt,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.InterruptVector,
                        pCard->ResourceInformation.InterruptLevel,
                        CARD_REQUEST_ISR,
                        pCard->ResourceInformation.InterruptShared,
                        pCard->ResourceInformation.InterruptMode
                        );
        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMRegisterInterrupt failed: Vec=%d, Lev=%d\n",
                     (UINT)pCard->ResourceInformation.InterruptVector,
                     (UINT)pCard->ResourceInformation.InterruptLevel));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.InterruptVector,
                    pCard->ResourceInformation.InterruptLevel,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
    }
#endif // defined(CARD_REQUEST_ISR)

    // TODO - Add your card initialization here.

    if (Result == NDIS_STATUS_SUCCESS)
    {

    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardLineConnect


@func

    <f CardLineConnect> will connect a call to the selected line.

@rdesc

    <f CardLineConnect> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardLineConnect(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t NDIS_LINK_OBJECT> returned by <f NdisLinkCreate>.
    )
{
    DBG_FUNC("CardLineConnect")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardLineDisconnect


@func

    <f CardLineDisconnect> will disconnect any call currently on the line.

*/

void CardLineDisconnect(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t NDIS_LINK_OBJECT> returned by <f NdisLinkCreate>.
    )
{
    DBG_FUNC("CardLineDisconnect")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardTransmitPacket


@func

    <f CardTransmitPacket> will start sending the current packet out.

@rdesc

    <f CardTransmitPacket> returns TRUE if the packet is being transmitted,
    otherwise FALSE is returned.

*/

BOOLEAN CardTransmitPacket(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PNDIS_WAN_PACKET         pWanPacket                  // @parm
    // A pointer to the associated NDIS packet structure <t NDIS_WAN_PACKET>.
    )
{
    DBG_FUNC("CardTransmitPacket")

    BOOLEAN                     bResult = FALSE;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

#if defined(SAMPLE_DRIVER)
{
    PBCHANNEL_OBJECT            pPeerBChannel;
    // A pointer to the peer <t BCHANNEL_OBJECT>.

    PCARD_EVENT_OBJECT          pEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    // If you can transmit the packet on pBChannel, do it now.
    pPeerBChannel = pBChannel->pPeerBChannel;
    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            /*
            // Append the packet onto TransmitBusyList while it is being sent.
            // Then move it to the TransmitCompleteList in CardInterruptHandler
            // after the card is done with it.
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
            InsertTailList(&pBChannel->TransmitBusyList,
                           &pWanPacket->WanPacketQueue);
            NdisReleaseSpinLock(&pAdapter->TransmitLock);
            pEvent->ulEventCode      = CARD_EVENT_RECEIVE;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            pEvent->pWanPacket       = pWanPacket;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            bResult = TRUE;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("pPeerBChannel == NULL\n"));
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to transmit the packet.
#endif // SAMPLE_DRIVER

    DBG_RETURN(pAdapter, bResult);
    return (bResult);
}


/* @doc INTERNAL Card Card_c CardGetReceiveInfo


@func

    <f CardGetReceiveInfo> will retrieve the packet header information from
    the receive buffer.  This assumes that the controller has notified the
    driver that a packet has been received.

@rdesc

    <f CardGetReceiveInfo> returns a pointer to the receive buffer if there
    is a packet available, otherwise NULL is returned.

*/

PUCHAR CardGetReceiveInfo(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    OUT PBCHANNEL_OBJECT *      ppBChannel,                 // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t BCHANNEL_OBJECT>.

    OUT PULONG                  pBytesReceived              // @parm
    // Points to a caller-defined memory location to which this function
    // writes the number of bytes received on this BChannel.
    )
{
    DBG_FUNC("CardGetReceiveInfo")

    PUCHAR                      pBuffer = NULL;

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // The length field tells us how many bytes are in the packet.
    // Make sure it isn't bigger than we expect!
    */
    *pBytesReceived = 0;
    *ppBChannel = NULL;

    DBG_RETURN(pAdapter, pBuffer);
    return (pBuffer);
}


/* @doc INTERNAL Card Card_c CardReceiveComplete


@func

    <f CardReceiveComplete> will return the last receive buffer to the
    B-channel queue so it can be used for another incoming packet.

*/

VOID CardReceiveComplete(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("CardReceiveComplete")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardInterruptHandler


@func

    <f CardInterruptHandler> dequeues an event from the asynchronous event
    callback queue <t CARD_EVENT_OBJECT>, and processes it according to
    whether it is a BChannel event, Card event, or B-Advise event.
    The associated callback routines are responsible for processing the
    event.

@comm

    <f NdisAcquireSpinLock> and <f NdisReleaseSpinLock> are used to provide
    protection around the dequeueing code and keep it from being re-entered
    as a result of another asynchronous callback event.

*/

VOID CardInterruptHandler(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardInterruptHandler")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

#if defined(SAMPLE_DRIVER)
{
    PCARD_EVENT_OBJECT          pEvent;
    PCARD_EVENT_OBJECT          pNewEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    PBCHANNEL_OBJECT            pBChannel;
    PBCHANNEL_OBJECT            pPeerBChannel;
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    PNDIS_WAN_PACKET            pWanPacket;
    // A pointer to the associated NDIS packet structure <t NDIS_WAN_PACKET>.

    /*
    // Clear out all packets in the receive buffer.
    */
    NdisDprAcquireSpinLock(&pAdapter->EventLock);
    while (!IsListEmpty(&pAdapter->EventList))
    {
        pEvent = (PCARD_EVENT_OBJECT)RemoveHeadList(&pAdapter->EventList);
        NdisDprReleaseSpinLock(&pAdapter->EventLock);

        ASSERT(pEvent->pReceivingObject);

        switch (pEvent->ulEventCode)
        {
        case CARD_EVENT_RING:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            DBG_NOTICE(pAdapter,("#%d CallState=0x%X CARD_EVENT_RING\n",
                       pBChannel->BChannelIndex, pBChannel->CallState));
            pBChannel->pPeerBChannel = pEvent->pSendingObject;
            ASSERT(pBChannel->pPeerBChannel &&
                   pBChannel->pPeerBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            // We only have to spoof digital data for this sample.
            pBChannel->MediaMode  = LINEMEDIAMODE_DIGITALDATA;
            pBChannel->BearerMode = LINEBEARERMODE_DATA;
            pBChannel->LinkSpeed  = _64KBPS;
            TspiLineDevStateHandler(pAdapter, pBChannel,
                                    LINEDEVSTATE_RINGING);
            break;

        case CARD_EVENT_CONNECT:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            DBG_NOTICE(pAdapter,("#%d CallState=0x%X CARD_EVENT_CONNECT\n",
                       pBChannel->BChannelIndex, pBChannel->CallState));
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_CONNECTED,
                                 0);
            break;

        case CARD_EVENT_DISCONNECT:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            DBG_NOTICE(pAdapter,("#%d CallState=0x%X CARD_EVENT_DISCONNECT\n",
                       pBChannel->BChannelIndex, pBChannel->CallState));
            pBChannel->pPeerBChannel = NULL;
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_DISCONNECTED,
                                 LINEDISCONNECTMODE_NORMAL);
            break;

        case CARD_EVENT_RECEIVE:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            DBG_NOTICE(pAdapter,("#%d CallState=0x%X CARD_EVENT_RECEIVE\n",
                       pBChannel->BChannelIndex, pBChannel->CallState));
            ReceivePacketHandler(pBChannel, pEvent->pWanPacket->CurrentBuffer,
                                 pEvent->pWanPacket->CurrentLength);

            pPeerBChannel = pBChannel->pPeerBChannel;
            if (pPeerBChannel)
            {
                pNewEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
                if (pNewEvent)
                {
                    pNewEvent->ulEventCode      = CARD_EVENT_TRANSMIT_COMPLETE;
                    pNewEvent->pSendingObject   = pBChannel;
                    pNewEvent->pReceivingObject = pPeerBChannel;
                    CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pNewEvent);
                }
            }
            else
            {
                DBG_ERROR(pAdapter,("pPeerBChannel == NULL\n"));
            }
            break;

        case CARD_EVENT_TRANSMIT_COMPLETE:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            DBG_NOTICE(pAdapter,("#%d CallState=0x%X CARD_EVENT_TRANSMIT_COMPLETE\n",
                       pBChannel->BChannelIndex, pBChannel->CallState));
            /*
            // Remove the packet from the BChannel's TransmitBusyList and
            // place it on the adapter's TransmitCompleteList now that the
            // card has completed the transmit.
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
            pWanPacket = (PNDIS_WAN_PACKET)RemoveHeadList(
                                                &pBChannel->TransmitBusyList);
            InsertTailList(&pBChannel->pAdapter->TransmitCompleteList,
                           &pWanPacket->WanPacketQueue);
            NdisReleaseSpinLock(&pAdapter->TransmitLock);

            TransmitCompleteHandler(pAdapter);
            break;

        default:
            DBG_ERROR(pAdapter,("Unknown event code=%d\n",
                      pEvent->ulEventCode));
            break;
        }
        CardEventRelease(pCard, pEvent);
        NdisDprAcquireSpinLock(&pAdapter->EventLock);
    }
    NdisDprReleaseSpinLock(&pAdapter->EventLock);
}
#else  // SAMPLE_DRIVER
    // TODO - Add interrupt handler code here
#endif // SAMPLE_DRIVER

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardCleanPhoneNumber


@func

    <f CardCleanPhoneNumber> copies the phone number from the input string
    to the output string, deleting any non-phone number characters (i.e.
    dashes, parens, modem keywords, etc.).

@rdesc

    <f CardCleanPhoneNumber> returns the length of the output string in bytes.

*/

USHORT CardCleanPhoneNumber(
    OUT PUCHAR                  Dst,                        // @parm
    // A pointer to the output string.

    IN  PUCHAR                  Src,                        // @parm
    // A pointer to the input string.

    IN  USHORT                  Length                      // @parm
    // The length of the input string in bytes.
    )
{
    DBG_FUNC("CardCleanPhoneNumber")

    USHORT                  NumDigits;

    /*
    // Strip out any character which are not digits or # or *.
    */
    for (NumDigits = 0; Length > 0; --Length)
    {
        if ((*Src >= '0' && *Src <= '9') ||
            (*Src == '#' || *Src == '*'))
        {
            /*
            // Make sure dial string is within the limit of the adapter.
            */
            if (NumDigits < CARD_MAX_DIAL_DIGITS)
            {
                ++NumDigits;
                *Dst++ = *Src;
            }
            else
            {
                break;
            }
        }
        Src++;
    }
    *Dst++ = 0;
    return (NumDigits);
}


/* @doc INTERNAL Card Card_c CardReset


@func

    <f CardReset> issues a hard reset to the NIC.  Same as power up.

@rdesc

    <f CardReset> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardReset(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardReset")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    DBG_BREAK(pAdapter);

    // TODO - Add code here to reset your hardware to its initial state.

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


#if defined(SAMPLE_DRIVER)

/* @doc INTERNAL Card Card_c GET_BCHANNEL_FROM_PHONE_NUMBER


@func

    <f GET_BCHANNEL_FROM_PHONE_NUMBER> assumes the phone number is a tapi
    DeviceID, and uses it to lookup the associated BChannel on one of our
    adapters.

@rdesc

    <f GET_BCHANNEL_FROM_PHONE_NUMBER> returns a pointer to the associated
    <t BCHANNEL_OBJECT> if successful.  Otherwise, NULL is returned.

*/

PBCHANNEL_OBJECT GET_BCHANNEL_FROM_PHONE_NUMBER(
    IN  PUCHAR                 pDialString                      // @parm
    // A pointer to the dial string.
    )
{
    DBG_FUNC("GET_BCHANNEL_FROM_PHONE_NUMBER")

    ULONG                       ulCalledID = 0;
    // Phone number converted to BChannel ObjectID (spans all adapters).

    ULONG                       ulAdapterIndex;
    ULONG                       ulBChannelIndex;
    // Loop index.

    /*
    // Strip out any character which are not digits or # or *.
    */
    while (*pDialString)
    {
        if (*pDialString >= '0' && *pDialString <= '9')
        {
            ulCalledID *= 10;
            ulCalledID += *pDialString - '0';
        }
        else
        {
            break;
        }
        pDialString++;
    }
    if (*pDialString)
    {
        DBG_ERROR(DbgInfo,("Invalid dial string '%s'\n", pDialString));
    }
    else
    {
        PMINIPORT_ADAPTER_OBJECT    pAdapter;

        for (ulAdapterIndex = 0; ulAdapterIndex < MAX_ADAPTERS; ++ulAdapterIndex)
        {
            pAdapter = g_Adapters[ulAdapterIndex];
            if (pAdapter)
            {
                PBCHANNEL_OBJECT            pBChannel;

                for (ulBChannelIndex = 0;
                     ulBChannelIndex < pAdapter->NumBChannels;
                     ulBChannelIndex++)
                {
                    pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, ulBChannelIndex);
                    if (pBChannel->htCall == (HTAPI_CALL)0 &&
                        pBChannel->MediaModesMask != 0)
                    {
                        if (ulCalledID == 0)
                        {
                            // Find first available channel.
                            return (pBChannel);
                        }
                        else if (ulCalledID == pBChannel->ObjectID)
                        {
                            // Find selected channel.
                            return (pBChannel);
                        }
                    }
                }
            }
        }
    }
    return (NULL);
}


/* @doc INTERNAL Card Card_c CardNotifyEvent


@func

    <f CardNotifyEvent> queues an IMS event to be processed by the DPC
    handler when things quiet down.

@comm

    We have to queue the event to be processed in DPC context.  We have
    to make sure that the queue is protected by a mutual exclusion
    primative which cannot be violated by the callback.

*/

VOID CardNotifyEvent(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PCARD_EVENT_OBJECT       pEvent                      // @parm
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.
    )
{
    DBG_FUNC("CardNotifyEvent")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    DBG_NOTICE(pAdapter,("pEvent=%X\n",pEvent));

    /*
    // Schedule the event handler to run as soon as possible.
    // We must schedule the event to go through the NDIS wrapper
    // so the proper spin locks will be held.
    // Don't schedule another event if processing is already in progress.
    */
    NdisAcquireSpinLock(&pAdapter->EventLock);
    InsertTailList(&pAdapter->EventList, &pEvent->Queue);
    NdisReleaseSpinLock(&pAdapter->EventLock);
    NdisMSetTimer(&pAdapter->EventTimer, 0);

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardEventAllocate


@func

    <f CardEventAllocate> allocates an <t CARD_EVENT_OBJECT> from the
    <p pCard>'s EventList.

@rdesc

    <f CardEventAllocate> returns a pointer to a <t CARD_EVENT_OBJECT>
    if it is successful.<nl>
    Otherwise, a NULL return value indicates an error condition.

*/

PCARD_EVENT_OBJECT CardEventAllocate(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    PCARD_EVENT_OBJECT          pEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    pEvent = &pCard->EventArray[pCard->NextEvent++];
    ASSERT(pEvent->pReceivingObject == NULL);
    if (pCard->NextEvent >= MAX_EVENTS)
    {
        pCard->NextEvent = 0;
    }
    return (pEvent);
}


/* @doc INTERNAL Card Card_c CardEventRelease


@func

    <f CardEventRelease> returns a previously allocate <t CARD_EVENT_OBJECT>
    to the <p pCard>'s EventList.

*/

VOID CardEventRelease(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PCARD_EVENT_OBJECT       pEvent                      // @parm
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.
    )
{
    pEvent->pReceivingObject = NULL;
}

#endif // SAMPLE_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\link.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Link Link_h

@module Link.h |

    This module defines the interface to the <t NDISLINK_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Link_h

@end

*/

#ifndef _LINK_H
#define _LINK_H

#define LINK_OBJECT_TYPE        ((ULONG)'L')+\
                                ((ULONG)'I'<<8)+\
                                ((ULONG)'N'<<16)+\
                                ((ULONG)'K'<<24)

/*


    Function prototypes.

*/

VOID LinkLineUp(
    IN PBCHANNEL_OBJECT         pBChannel
    );

VOID LinkLineDown(
    IN PBCHANNEL_OBJECT         pBChannel
    );

VOID LinkLineError(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN ULONG                    Errors
    );

#endif // _LINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\link.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Link Link_c

@module Link.c |

    This module implements the NDIS_MAC_LINE_UP, NDIS_MAC_LINE_DOWN, and
    NDIS_MAC_FRAGMENT interfaces between the NDIS WAN Miniport and the
    NDIS WAN Wrapper.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Link_c

@end

*/

#define  __FILEID__             LINK_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Link Link_c NDIS_MAC_LINE_UP


@struct NDIS_MAC_LINE_UP |
        This structure is passed to <f NdisMIndicateStatus> with the
        <t NDIS_STATUS_WAN_LINE_UP> status message when <f LinkLineUp> is
        called by the Miniport.

@field IN ULONG | LinkSpeed |
        The speed of the link, in 100 bps units (bits per second).

@field IN NDIS_WAN_QUALITY | Quality |
        The quality of service indicator for this link.

@field IN USHORT | SendWindow |
        The recommended send window, i.e., the number of packets that should
        be given to the adapter before pausing to wait for an acknowledgement.
        Some devices achieve higher throughput if they have several packets
        to send at once; others are especially unreliable.  A value of zero
        indicates no recommendation.

@field IN NDIS_HANDLE | ConnectionWrapperID |
        The Miniport supplied handle by which this line will be known to the
        Connection Wrapper clients.  This must be a unique handle across all
        drivers using the Connection Wrapper, so typically <f htCall> should
        be used to gaurantee it is unique.  This must be the same value
        returned from the OID_TAPI_GETID request for the <p  "ndis">
        DeviceClass (See <f TspiGetID>).  Refer to the Connection Wrapper
        Interface Specification for further details.  If not using the
        Connection Wrapper, this value must be zero.

@field IN NDIS_HANDLE | MiniportLinkContext |
        The Miniport supplied handle passed down in future Miniport calls
        (such as <f MiniportWanSend> for this link.  Typically, the Miniport
        will provide a pointer to its control block for that link.  The value
        must be unique, for the first LINE_UP indication on a particular
        link.  Subsequent LINE_UP indications may be called if line
        characteristics change.  When subsequent LINE_UP indication calls are
        made, the <p  MiniportLinkContext> must be filled with the value
        returned on the first LINE_UP indication call.

@field IN NDIS_HANDLE | NdisLinkContext |
        The WAN wrapper supplied handle to be used in future Miniport calls
        (such as <f NdisMWanIndicateReceive>) to the WAN Wrapper. The WAN
        Wrapper will provide a unique handle for every LINE_UP indication.
        The <p NdisLinkContext> must be zero if this is the first LINE_UP
        indication.  It must contain the value returned on the first LINE_UP
        indication for subsequent LINE_UP indication calls.

*/


/* @doc INTERNAL Link Link_c LinkLineUp


@func

    <f LinkLineUp> marks a link as connected and sends a LINE_UP indication
    to the WAN wrapper.

    A line up indication is generated when a new link becomes active. Prior
    to this the MAC will accept frames and may let them succeed or fail, but
    it is unlikely that they will actually be received by any remote. During
    this state protocols are encouraged to reduce their timers and retry
    counts so as to quickly fail any outgoing connection attempts.

    <f Note>: This indication must be sent to the WAN wrapper prior to returning
    from the OID_TAPI_ANSWER request, and prior to indicating the
    LINECALLSTATE_CONNECTED to the Connection Wrapper.  Otherwise, the
    Connection Wrapper client might attempt to send data to the WAN wrapper
    before it is aware of the line.

@comm

    The status code for the line up indication is <t NDIS_STATUS_WAN_LINE_UP>
    and is passed to <f NdisMIndicateStatus>.  The format of the StatusBuffer
    for this code is defined by <t NDIS_MAC_LINE_UP>.

*/

VOID LinkLineUp(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("LinkLineUp")

    NDIS_MAC_LINE_UP            LineUpInfo;
    // Line up structure passed to NdisMIndicateStatus.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    /*
    // We can't bring up a NULL link.
    */
    if (pBChannel->IsOpen && pBChannel->NdisLinkContext == NULL)
    {
        DBG_ENTER(pAdapter);
        ASSERT(pBChannel->htCall);

        /*
        // Initialize the LINE_UP event packet.
        */
        LineUpInfo.LinkSpeed           = pBChannel->LinkSpeed / 100;
        LineUpInfo.Quality             = NdisWanErrorControl;
        LineUpInfo.SendWindow          = (USHORT)pAdapter->WanInfo.MaxTransmit;
        LineUpInfo.ConnectionWrapperID = (NDIS_HANDLE) pBChannel->htCall;
        LineUpInfo.MiniportLinkContext = pBChannel;
        LineUpInfo.NdisLinkContext     = pBChannel->NdisLinkContext;

        /*
        // Indicate the event to the WAN wrapper.
        */
        NdisMIndicateStatus(pAdapter->MiniportAdapterHandle,
                            NDIS_STATUS_WAN_LINE_UP,
                            &LineUpInfo,
                            sizeof(LineUpInfo)
                            );
        pAdapter->NeedStatusCompleteIndication = TRUE;
        /*
        // Save the WAN wrapper link context for use when indicating received
        // packets and errors.
        */
        pBChannel->NdisLinkContext = LineUpInfo.NdisLinkContext;

        DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                  ("#%d Call=0x%X CallState=0x%X NdisLinkContext=0x%X MiniportLinkContext=0x%X\n",
                   pBChannel->BChannelIndex,
                   pBChannel->htCall, pBChannel->CallState,
                   pBChannel->NdisLinkContext,
                   pBChannel
                  ));

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Link Link_c NDIS_MAC_LINE_DOWN


@struct NDIS_MAC_LINE_DOWN |
        This structure is passed to <f NdisMIndicateStatus> with the
        <t NDIS_STATUS_WAN_LINE_DOWN> status message when <f LinkLineDown>
        is called by the Miniport.

@field IN NDIS_HANDLE | NdisLinkContext |
        The value returned in the <t NDIS_MAC_LINE_UP> structure during a
        previous call to <f LinkLineUp>.

*/


/* @doc INTERNAL Link Link_c LinkLineDown


@func

    <f LinkLineDown> marks a link as disconnected and sends a LINE_DOWN
    indication to the WAN wrapper.

    A line down indication is generated when a link goes down. Protocols
    should again reduce their timers and retry counts until the next line
    up indication.

@comm

    The status code for the line down indication is <t NDIS_STATUS_WAN_LINE_DOWN>
    and is passed to <f NdisMIndicateStatus>. The format of the StatusBuffer
    for this code is defined by <t NDIS_MAC_LINE_DOWN>.

*/

VOID LinkLineDown(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("LinkLineDown")

    NDIS_MAC_LINE_DOWN          LineDownInfo;
    // Line down structure passed to NdisMIndicateStatus.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    /*
    // We can't allow indications to NULL...
    */
    if (pBChannel->NdisLinkContext)
    {
        DBG_ENTER(pAdapter);

        DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                  ("#%d Call=0x%X CallState=0x%X NdisLinkContext=0x%X MiniportLinkContext=0x%X\n",
                   pBChannel->BChannelIndex,
                   pBChannel->htCall, pBChannel->CallState,
                   pBChannel->NdisLinkContext,
                   pBChannel
                  ));

        /*
        // Setup the LINE_DOWN event packet and indicate the event to the
        // WAN wrapper.
        */
        LineDownInfo.NdisLinkContext = pBChannel->NdisLinkContext;

        NdisMIndicateStatus(pAdapter->MiniportAdapterHandle,
                            NDIS_STATUS_WAN_LINE_DOWN,
                            &LineDownInfo,
                            sizeof(LineDownInfo)
                            );
        pAdapter->NeedStatusCompleteIndication = TRUE;
        /*
        // The line is down, so there's no more context for receives.
        */
        pBChannel->NdisLinkContext = NULL;
        pBChannel->CallClosing     = FALSE;

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Link Link_c NDIS_MAC_FRAGMENT


@struct NDIS_MAC_FRAGMENT |
        This structure is passed to <f NdisMIndicateStatus> with the
        <t NDIS_STATUS_WAN_FRAGMENT> status message when <f LinkLineError>
        is called by the Miniport.

@field IN NDIS_HANDLE | NdisLinkContext |
        The value returned in the <t NDIS_MAC_LINE_UP> structure during a
        previous call to <f LinkLineUp>.

@field IN ULONG | Errors |
     Is a bit OR'd mask of the following values:
     WAN_ERROR_CRC,
     WAN_ERROR_FRAMING,
     WAN_ERROR_HARDWAREOVERRUN,
     WAN_ERROR_BUFFEROVERRUN,
     WAN_ERROR_TIMEOUT,
     WAN_ERROR_ALIGNMENT

*/


/* @doc INTERNAL Link Link_c LinkLineError


@func

    <f LinkLineError> is used to indicate to the WAN wrapper that a partial
    packet was received from the remote end.  The <t NDIS_STATUS_WAN_FRAGMENT>
    indication is used to notify WAN wrapper.

    A fragment indication indicates that a partial packet was received from
    the remote. The protocol is encouraged to send frames to the remote that
    will notify it of this situation, rather than waiting for a timeout to
    occur.

    <f Note>: The WAN wrapper keeps track of dropped packets by counting the
    number of fragment indications on the link.

@comm

    The status code for the fragment indication is <t NDIS_STATUS_WAN_FRAGMENT>
    and is passed to <f NdisMIndicateStatus>.  The format of the StatusBuffer
    for this code is defined by <t NDIS_MAC_LINE_DOWN>.

*/

void LinkLineError(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN ULONG                    Errors                      // @parm
    // A bit field set to one or more bits indicating the reason the fragment
    // was received.  If no direct mapping from the WAN medium error to one
    // of the six errors listed below exists, choose the most apropriate
    // error.
    )
{
    DBG_FUNC("LinkLineError")

    NDIS_MAC_FRAGMENT           FragmentInfo;
    // Error information structure passed to NdisMIndicateStatus.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    /*
    // NOTE - Don't report any errors until we receive at least one
    // good packet.  Connecting to a Digi NT system, we get a burst
    // of bad packets while Digi tries some odd framing.  After a
    // couple seconds, Digi syncs up and things work okay.
    */
    if (pBChannel->TotalRxPackets == 0)
    {
        return;
    }

    /*
    // We can't allow indications to NULL...
    */
    if (pBChannel->NdisLinkContext)
    {
        DBG_ENTER(pAdapter);

        DBG_WARNING(pAdapter,
                  ("#%d Call=0x%X CallState=0x%X NdisLinkContext=0x%X Errors=0x%X NumRxPkts=%d\n",
                   pBChannel->BChannelIndex,
                   pBChannel->htCall, pBChannel->CallState,
                   pBChannel->NdisLinkContext,
                   Errors, pBChannel->TotalRxPackets
                  ));

        /*
        // Setup the FRAGMENT event packet and indicate it to the WAN wrapper.
        */
        FragmentInfo.NdisLinkContext = pBChannel->NdisLinkContext;
        FragmentInfo.Errors = Errors;
        NdisMIndicateStatus(pAdapter->MiniportAdapterHandle,
                            NDIS_STATUS_WAN_FRAGMENT,
                            &FragmentInfo,
                            sizeof(FragmentInfo)
                            );
        pAdapter->NeedStatusCompleteIndication = TRUE;
        DBG_LEAVE(pAdapter);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\keywords.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Keywords Keywords_h

@module Keywords.h |

    This file defines the driver parameter keywords used in the registry.
    This file should be #include'd into the driver module defining the
    configuration parameter table <t PARAM_TABLE>.

@comm

    The configuration parmaeters should be parsed early in the initialization
    process so they can be used to configure software and hardware settings.

    You can easily add new parameters using the following procuedure:<nl>
    1) #define a new keyword string here in <f Keywords\.h>.<nl>
    2) Add a corresponding <f PARAM_ENTRY> into your parameter table <t PARAM_TABLE>.<nl>
    3) Add a variable to the associated data structure (e.g. <t MINIPORT_ADAPTER_OBJECT>).

    These values can then be parsed by calling <f ParamParseRegistry> with a
    pointer to your configuration parameter table <t PARAM_TABLE>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Keywords_h

@end

*/


/* @doc EXTERNAL INTERNAL


@topic 5.0 Registry Parameters |

    This section describes the registry parameters used by the driver.
    These parameters are stored in the following registry path.<nl>

    Windows NT registry path:<nl>
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\"VER_PRODUCT_STR"<nl>

    Windows 95 registry path:<nl>
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\Net\0001><nl>
    The final path key "\0001" depends on the adapter instance number assigned
    by NDIS during installation.<nl>

    <f Note>: Windows 95 DWORD registry parameters are stored as strings.
    The NDIS wrapper converts them to integers when they are read.  The string
    can be decimal or hexadecimal as long as you read it with the appropriate
    NDIS parameter type.

    These values are declared as entries in the <t PARAM_TABLE> and are parsed
    from the registry using the <f ParamParseRegistry> routine.
    
@flag <f AddressList> (HIDDEN) |

    This MULTI_STRING parameter contains the list of addresses assigned to
    each logical link exported by the Miniport to RAS.
    This parameter is required on Windows NT, but is not used by the
    Windows 95 Miniport.  It cannot be changed by the user. <nl>

    <tab><f Default Value:><tab><tab>"1-1-0"<nl>

@flag <f DeviceName> (HIDDEN) |

    This STRING parameter is the name we use to identify the Miniport to RAS.
    This parameter is required on Windows NT, but is not used by the
    Windows 95 Miniport.  It cannot be changed by the user. <nl>

    <tab><f Default Value:><tab><tab>"VER_PRODUCT_STR"

@flag <f MediaType> (HIDDEN) |

    This STRING parameter is the media type this Miniport supports for RAS.
    This parameter is required on Windows NT, but is not used by the
    Windows 95 Miniport.  It cannot be changed by the user. <nl>

    <tab><f Default Value:><tab><tab>"isdn"<nl>

@flag <f BufferSize> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum buffer size used
    to transmit and receive packets over the IDSN line.  Typically, this is
    defined to be 1500 bytes for most Point to Point (PPP) connections.<nl>

    <tab><f Default Value:><tab><tab>1532<nl>
    <tab><f Valid Range N:><tab><tab>532 <lt>= N <lt>= 4032<nl>

    <f Note>: You must add 32 bytes to the maximum packet size you
    expect to send or receive.  Therefore, if you have a maximum packet size
    of 1500 bytes, excluding media headers, you should set the <f BufferSize>
    value to 1532.<nl>

@flag <f ReceiveBuffersPerLink> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of incoming
    packets that can in progress at any one time.  The Miniport will allocate
    this number of packets per BChannel and set them up for incoming packets.
    Typically, three or four should be sufficient to handle a few short bursts
    that may occur with small packets.  If the Miniport is not able to service
    the incoming packets fast enough, new packets will be dropped and it is up
    to the NDIS WAN Wrapper to resynchronize with the remote station.<nl>

    <tab><f Default Value:><tab><tab>3<nl>
    <tab><f Valid Range N:><tab><tab>2 <lt>= N <lt>= 16<nl>

@flag <f TransmitBuffersPerLink> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of outgoing
    packets that can in progress at any one time.  The Miniport will allow
    this number of packets per BChannel to be outstanding (i.e. in progress).
    Typically, two or three should be sufficient to keep the channel busy for
    normal sized packets.  If there are alot of small packets being sent, the
    BChannel may become idle for brief periods while new packets are being
    queued.  Windows does not normally work this way if it has large amounts
    of data to transfer, so the default value should be sufficient. <nl>

    <tab><f Default Value:><tab><tab>2<nl>
    <tab><f Valid Range N:><tab><tab>1 <lt>= N <lt>= 16<nl>

@flag <f NoAnswerTimeOut> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of
    miliseconds that an outgoing call will be allowed to wait for the remote
    end to respond.  If the remote end does not respond within this time, the
    call will be disconnected and RAS will alert the user. <nl>

    <tab><f Default Value:><tab><tab>15000 (15 seconds)<nl>
    <tab><f Valid Range N:><tab><tab>5000 <lt>= N <lt>= 120000<nl>

@flag <f NoAcceptTimeOut> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of
    miliseconds that an incoming call will be allowed to wait for the user or
    an application to accept the call.  If the local end does not respond
    within this time, the call will be rejected and the network will alert
    the caller. <nl>

    <tab><f Default Value:><tab><tab>10000 (10 seconds)<nl>
    <tab><f Valid Range N:><tab><tab>1000 <lt>= N <lt>= 60000<nl>

@flag <f DebugFlags> (OPTIONAL) (DEBUG VERSION ONLY) |

    This DWORD parameter allows you to control how much debug information is
    displayed to the debug monitor.  This is a bit OR'd flag using the values
    defined in <t DBG_FLAGS>.  This value is not used by the released version
    of the driver.<nl>

*/

#ifndef _KEYWORDS_H
#define _KEYWORDS_H

#define PARAM_MAX_KEYWORD_LEN               128

/*
// These parameters names are predefined by NDIS - don't change them.
*/
#define PARAM_BusNumber                     "BusNumber"
#define PARAM_BusType                       "BusType"
#define PARAM_MediaType                     "MediaType"

/*
// These parameters are placed in the registry during installation.
*/
#define PARAM_AddressList                   "AddressList"
#define PARAM_DeviceName                    "DeviceName"
#define PARAM_NumDChannels                  "IsdnNumDChannels"
#define PARAM_NumBChannels                  "IsdnNumBChannels"

/*
// These parameters are not placed in the registry by default, but they
// will be used if present.
*/
#define PARAM_BufferSize                    "BufferSize"
#define PARAM_ReceiveBuffersPerLink         "ReceiveBuffersPerLink"
#define PARAM_TransmitBuffersPerLink        "TransmitBuffersPerLink"
#define PARAM_NoAnswerTimeOut               "NoAnswerTimeOut"
#define PARAM_NoAcceptTimeOut               "NoAcceptTimeOut"
#define PARAM_RunningWin95                  "RunningWin95"
#define PARAM_DebugFlags                    "DebugFlags"

#define PARAM_TODO                          "TODO"
// Add your keywords here.

// Port based parameters
#define PARAM_PORT_PREFIX                   "Line" // Line0 .. Line9
#define PARAM_SwitchType                    "IsdnSwitchType"

#endif // _KEYWORDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\port.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Port Port_c

@module Port.c |

    This module implements the interface to the <t PORT_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Port_c

@end

*/

#define  __FILEID__             PORT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                    g_PortInstanceCounter = 0;
// Keeps track of how many <t PORT_OBJECT>s are created.


/* @doc EXTERNAL INTERNAL Port Port_c g_PortParameters


@topic 5.6 Port Parameters |

    This section describes the registry parameters read into the
    <t PORT_OBJECT>.

@globalv PARAM_TABLE | g_PortParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t PORT_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t PORT_OBJECT>
    you will need to modify <f PortReadParameters> and add the parameter
    definitions to the <f g_PortParameters> table.

*/

DBG_STATIC PARAM_TABLE              g_PortParameters[] =
{
    PARAM_ENTRY(PORT_OBJECT,
                SwitchType, PARAM_SwitchType,
                FALSE, NdisParameterInteger, 0,
                0x0001, 0x0001, 0x8000),

    PARAM_ENTRY(PORT_OBJECT,
                NumChannels, PARAM_NumBChannels,
                FALSE, NdisParameterInteger, 0,
                2, 2, 24),

    /* The last entry must be an empty string! */
    { { 0 } }
};


DBG_STATIC NDIS_STRING  PortPrefix = INIT_STRING_CONST(PARAM_PORT_PREFIX);


/* @doc INTERNAL Port Port_c PortReadParameters


@func

    <f PortReadParameters> reads the Port parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f PortCreate>.

    <f Note>:
    If you add any registry based data members to <t PORT_OBJECT>
    you will need to modify <f PortReadParameters> and add the parameter
    definitions to the <f g_PortParameters> table.

@rdesc

    <f PortReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS PortReadParameters(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pPort,
                    g_PortParameters
                    );

    DBG_NOTICE(pAdapter,("PortPrefixLen=%d:%d:%ls\n",
                PortPrefix.Length, PortPrefix.MaximumLength, PortPrefix.Buffer));

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pPort->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pPort->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Port Port_c PortCreateObjects


@func

    <f PortCreateObjects> calls the create routines for all the objects
    contained in <t PORT_OBJECT>.  This should only be called
    by <f PortCreate>.

    <f Note>:
    If you add any new objects to <t PORT_OBJECT> you will need
    to modify <f PortCreateObjects> and <f PortDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f PortCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS PortCreateObjects(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortCreate


@func

    <f PortCreate> allocates memory for a <t PORT_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppPort> will be set to point to the newly created
    <t PORT_OBJECT>.  Otherwise, <p ppPort> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f PortDestroy> must be called to
    release the <t PORT_OBJECT> created by this function.

@rdesc

    <f PortCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS PortCreate(
    OUT PPORT_OBJECT *          ppPort,                     // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t PORT_OBJECT>.

    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("PortCreate")

    PPORT_OBJECT                pPort;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppPort = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pPort, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pPort->ObjectType = PORT_OBJECT_TYPE;
        pPort->ObjectID = ++g_PortInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pPort->pCard = pCard;

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = PortReadParameters(pPort);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = PortCreateObjects(pPort);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppPort = pPort;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            PortDestroy(pPort);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortDestroyObjects


@func

    <f PortDestroyObjects> calls the destroy routines for all the objects
    contained in <t PORT_OBJECT>.  This should only be called by
    <f PortDestroy>.

    <f Note>:
    If you add any new objects to <t PPORT_OBJECT> you will need to
    modify <f PortCreateObjects> and <f PortDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void PortDestroyObjects(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> instance.
    )
{
    DBG_FUNC("PortDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Port Port_c PortDestroy


@func

    <f PortDestroy> frees the memory for this <t PORT_OBJECT>.
    All memory allocated by <f PortCreate> will be released back to the
    OS.

*/

void PortDestroy(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pPort)
    {
        ASSERT(pPort->ObjectType == PORT_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_PORT(pPort);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        PortDestroyObjects(pPort);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pPort->ObjectType = 0;
        FREE_OBJECT(pPort);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Port Port_c PortOpen


@func

    <f PortOpen> makes the Port connection ready to transmit and
    receive data.

@rdesc

    <f PortOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS PortOpen(
    IN PPORT_OBJECT             pPort,                      // @parm
    // A pointer to the <t PORT_OBJECT> associated with this request.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> to be associated with this
    // Port.
    )
{
    DBG_FUNC("PortOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel);
    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    if (!pPort->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Opening Port #%d\n",
                   pPort->ObjectID));

        // TODO - Add code here

        pPort->IsOpen = TRUE;
    }
    else
    {
        DBG_ERROR(pAdapter,("Port #%d already opened\n",
                  pPort->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortClose


@func

    <f PortClose> closes the given B-channel.

*/

void PortClose(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> associated with this request.
    )
{
    DBG_FUNC("PortClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    if (pPort->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Closing Port #%d\n",
                   pPort->ObjectID));

        // TODO - Add code here

        pPort->IsOpen = FALSE;
    }
    else
    {
        DBG_ERROR(pAdapter,("Port #%d already closed\n",
                  pPort->ObjectID));
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\interupt.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Interupt Interupt_c

@module Interupt.c |

    This module implements the Miniport interrupt processing routines and
    asynchronous processing routines.  This module is very dependent on the
    hardware/firmware interface and should be looked at whenever changes
    to these interfaces occur.

@comm

    This driver does not support the physical hardware, so there is no need
    for the typical interrupt handler routines.  However, the driver does
    have an asynchronous event handler which is contained in this module.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Interupt_c

@end

*/

#define  __FILEID__             INTERRUPT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Interupt Interupt_c MiniportCheckForHang

@func

    <f MiniportCheckForHang> reports the state of the network interface card.

@comm

    In NIC drivers, <f MiniportCheckForHang> does nothing more than check
    the internal state of the NIC and return TRUE if it detects that
    the NIC is not operating correctly.

    In intermediate drivers, <f MiniportCheckForHang> can periodically check the
    state of the driver's virtual NIC to determine whether the underlying
    device driver appears to be hung.

    By default, the NDIS library calls <f MiniportCheckForHang> approximately
    every two seconds.

    If <f MiniportCheckForHang> returns TRUE, NDIS then calls the driver's
    MiniportReset function.

    If a NIC driver has no <f MiniportCheckForHang> function and NDIS
    judges the driver unresponsive as, for example, when NDIS holds
    many pending sends and requests queued to the miniport for a time-out
    interval, NDIS calls the driver's <f MiniportReset> function. The NDIS
    library's default time-out interval for queued sends and requests is
    around four seconds. However, a NIC driver's <f MiniportInitialize>
    function can extend NDIS's time-out interval by calling NdisMSetAttributesEx
    from <f MiniportInitialize> to avoid unnecessary resets.

    The <f MiniportInitialize> function of an intermediate driver
    should disable NDIS's time-out interval with NdisMSetAttributesEx
    because such a driver can neither control nor estimate a reasonable
    completion interval for the underlying device driver.

    <f MiniportCheckForHang> can be pre-empted by an interrupt.

    By default, <f MiniportCheckForHang> runs at IRQL DISPATCH_LEVEL.

    <f Note>:
    If your hardware/firmware is flakey you can request that the NDIS
    wrapper call your MiniportReset routine by returning TRUE from this
    routine.  For well behaved hardware/firmware you should always return
    FALSE from this routine.

@rdesc

    <f MiniportCheckForHang> returns FALSE if the NIC is working properly.<nl>
    Otherwise, a TRUE return value indicates that the NIC needs to be reset.

*/

BOOLEAN MiniportCheckForHang(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportCheckForHang")
    // If your hardware can lockup, then you can return TRUE here.
    // If you return TRUE, your MiniportReset routine will be called.
    return (FALSE);
}


#if defined(CARD_REQUEST_ISR)
#if (CARD_REQUEST_ISR == FALSE)

/* @doc INTERNAL Interupt Interupt_c MiniportDisableInterrupt

@func

    <f MiniportDisableInterrupt> disables the interrupt capability of
    the NIC to keep it from generating interrupts.

@comm

    <f MiniportDisableInterrupt> typically disables interrupts by writing
    a mask to the NIC. If a driver does not have this function, typically
    its <f MiniportISR> disables interrupts on the NIC.

    If the NIC does not support dynamic enabling and disabling of
    interrupts or if it shares an IRQ, the miniport driver must register
    a <f MiniportISR> function and set RequestIsr to TRUE when it calls
    NdisMRegisterMiniport. Such a driver's MiniportISR function must
    acknowledge each interrupt generated by the NIC and save any
    necessary interrupt information for the driver's
    MiniportHandleInterrupt function.

    By default, MiniportDisableInterrupt runs at DIRQL, in particular
    at the DIRQL assigned when the NIC driver's MiniportInitialize
    function called NdisMRegisterInterrupt. Therefore,
    MiniportDisableInterrupt can call only a subset of the NDIS library
    functions, such as the NdisRawXxx functions that are safe to call
    at any IRQL.

    If <f MiniportDisableInterrupt> shares resources, such as NIC registers,
    with another MiniportXxx that runs at a lower IRQL, that MiniportXxx
    must call NdisMSychronizeWithInterrupt so the driver's
    <f MiniportSynchronizeISR> function will access those shared
    resources in a synchronized and multiprocessor-safe manner.
    Otherwise, while it is accessing the shared resources, that
    MiniportXxx function can be pre-empted by <f MiniportDisableInterrupt>,
    possibly undoing the work just done by MiniportXxx.

@xref

    <f MiniportEnableInterrupt>
    <f MiniportHandleInterrupt>
    <f MiniportInitialize>
    <f MiniportISR>

*/

void MiniportDisableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportDisableInterrupt")
    DBG_ERROR(pAdapter,("This should not be called!\n"));
}


/* @doc INTERNAL Interupt Interupt_c MiniportEnableInterrupt

@func

    <f MiniportEnableInterrupt> enables the NIC to generate interrupts.

@comm

    <f MiniportEnableInterrupt> typically enables interrupts by writing
    a mask to the NIC.

    A NIC driver that exports a <f MiniportDisableInterrupt> function
    need not have a reciprocal <f MiniportEnableInterrupt> function.
    Such a driver's <f MiniportHandleInterrupt> function is responsible
    for re-enabling interrupts on the NIC.

    If its NIC does not support dynamic enabling and disabling of
    interrupts or if it shares an IRQ, the NIC driver must register
    a <f MiniportISR> function and set RequestIsr to TRUE when it calls
    NdisMRegisterMiniport. Such a driver's <f MiniportISR> function must
    acknowledge each interrupt generated by the NIC and save any
    necessary interrupt information for the driver's
    <f MiniportHandleInterrupt> function.

    <f MiniportEnableInterrupt> can be pre-empted by an interrupt.

    By default, <f MiniportEnableInterrupt> runs at IRQL DISPATCH_LEVEL.

@xref

    <f MiniportDisableInterrupt>
    <f MiniportHandleInterrupt>
    <f MiniportInitialize>
    <f MiniportISR>

*/

void MiniportEnableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportEnableInterrupt")
    DBG_ERROR(pAdapter,("This should not be called!\n"));
}

#else // !(CARD_REQUEST_ISR == FALSE)

/* @doc INTERNAL Interupt Interupt_c MiniportISR

@func

    <f MiniportISR> is the miniport driver's interrupt service routine
    and it runs at a high priority in response to an interrupt.


@comm

    Any NIC driver should do as little work as possible in its
    <f MiniportISR> function, deferring I/O operations for each
    interrupt the NIC generates to the <f MiniportHandleInterrupt>
    function. A NIC driver's ISR is not re-entrant, although two
    instantiations of a <f MiniportISR> function can execute concurrently
    in SMP machines, particularly if the miniport supports
    full-duplex sends and receives.

    Miniport ISR is called under the following conditions:

    An interrupt occurs on the NIC while the driver's <f MiniportInitialize>
    or <f MiniportHalt> function is running.  An interrupt occurs on the I/O bus
    and the NIC shares an IRQ with other devices on that bus.
    If the NIC shares an IRQ with other devices, that miniport's ISR
    must be called on every interrupt to determine whether its NIC
    actually generated the interrupt. If not, <f MiniportISR> should return
    FALSE immediately so the driver of the device that actually generated
    the interrupt is called quickly. This strategy maximizes I/O throughput
    for every device on the same bus.

    An interrupt occurs and the NIC driver specified that its ISR should be
    called to handle every interrupt when its <f MiniportInitialize> function
    called NdisMRegisterInterrupt.

    Miniports that do not provide <f MiniportDisableInterrupt>/<f MiniportEnableInterrupt>
    functionality must have their ISRs called on every interrupt.

    <f MiniportISR> dismisses the interrupt on the NIC, saves whatever state
    it must about the interrupt, and defers as much of the I/O processing
    for each interrupt as possible to the <f MiniportHandleInterrupt> function.

    After <f MiniportISR> returns control with the variables at InterruptRecognized
    and QueueMiniportHandleInterrupt set to TRUE, the corresponding
    <f MiniportHandleInterrupt> function runs at a lower hardware priority
    (IRQL DISPATCH_LEVEL) than that of the ISR (DIRQL). As a general
    rule, <f MiniportHandleInterrupt> should do all the work for interrupt-driven
    I/O operations except for determining whether the NIC actually generated
    the interrupt, and, if necessary, preserving the type (receive, send,
    reset...) of interrupt.

    However, a driver writer should not rely on a one-to-one correspondence
    between the execution of <f MiniportISR> and <f MiniportHandleInterrupt>. A
    <f MiniportHandleInterrupt> function should be written to handle the I/O
    processing for more than one NIC interrupt. Its MiniportISR and
    <f MiniportHandleInterrupt> functions can run concurrently in SMP machines.
    Moreover, as soon as <f MiniportISR> acknowledges a NIC interrupt, the NIC
    can generate another interrupt, while the <f MiniportHandleInterrupt> DPC
    can be queued for execution once for such a sequence of interrupts.

    The <f MiniportHandleInterrupt> function is not queued if the driver's
    <f MiniportHalt> or <f MiniportInitialize> function is currently executing.

    If <f MiniportISR> shares resources, such as NIC registers or state
    variables, with another MiniportXxx that runs at lower IRQL,
    that MiniportXxx must call NdisMSychronizeWithInterrupt so the
    driver's MiniportSynchronizeISR function will access those shared
    resources in a synchronized and multiprocessor-safe manner. Otherwise,
    while it is accessing the shared resources, that MiniportXxx function
    can be pre-empted by <f MiniportISR>, possibly undoing the work just done
    by MiniportXxx.

    By default, <f MiniportISR> runs at DIRQL, in particular at the DIRQL
    assigned when the driver initialized the interrupt object with
    NdisMRegisterInterrupt. Therefore, <f MiniportIsr> can call only a
    subset of the NDIS library functions, such as the NdisRawXxx or
    NdisRead/WriteRegisterXxx functions that are safe to call at
    any IRQL.

@devnote
    <f MiniportISR> must not call any support functions in the NDIS
    interface library or the transport driver.

@xref
    <f MiniportDisableInterrupt>
    <f MiniportEnableInterrupt>
    <f MiniportHalt>
    <f MiniportHandleInterrupt>
    <f MiniportInitialize>
    <f MiniportSynchronizeISR>

*/

void MiniportISR(
    OUT PBOOLEAN                InterruptRecognized,        // @parm
    // If the miniport driver is sharing an interrupt line and it detects
    // that the interrupt came from its NIC, <f MiniportISR> should set
    // this parameter to TRUE.

    OUT PBOOLEAN                QueueMiniportHandleInterrupt, // @parm
    // If the miniport driver is sharing an interrupt line and if
    // <f MiniportHandleInterrupt> must be called to complete handling of
    // the interrupt, <f MiniportISR> should set this parameter to TRUE.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportISR")

    ULONG                       InterruptStatus;

    if ((InterruptStatus = pAdapter->TODO) == 0)
    {
        *InterruptRecognized =
        *QueueMiniportHandleInterrupt = FALSE;
    }
    else
    {
        pAdapter->pCard->InterruptStatus = InterruptStatus;
        *InterruptRecognized =
        *QueueMiniportHandleInterrupt = TRUE;
    }
}

#endif // (CARD_REQUEST_ISR == FALSE)
#endif // defined(CARD_REQUEST_ISR)

/* @doc INTERNAL Interupt Interupt_c MiniportHandleInterrupt

@func

    <f MiniportHandleInterrupt> is called by the deferred processing routine
    in the NDIS library to process an interrupt.

@comm

    <f MiniportHandleInterrupt> does the deferred processing of all
    outstanding interrupt operations and starts any new operations.
    That is, the driver's <f MiniportISR> or <f MiniportDisableInterrupt>
    function dismisses the interrupt on the NIC, saves any necessary
    state about the operation, and returns control as quickly as possible,
    thereby deferring most interrupt-driven I/O operations to
    <f MiniportHandleInterrupt>.

    <f MiniportHandleInterrupt> carries out most operations to indicate
    receives on NICs that generate interrupts, including but not
    limited to the following:

    Adjusting the size of the buffer descriptor(s) to match the size of
    the received data and chaining the buffer descriptor(s) to the packet
    descriptor for the indication.

    Setting up an array of packet descriptors and setting up any
    out-of-band information for each packet in the array for the
    indication or, if the miniport does not support multipacket
    receive indications, setting up a lookahead buffer

    If the driver supports multipacket receives, it must indicate
    packet arrays in which the packet descriptors were allocated
    from packet pool and the buffer descriptors chained to those
    packets were allocated from buffer pool.

    Calling the appropriate Ndis..IndicateReceive function for the
    received data.

    <f MiniportHandleInterrupt> also can call NdisSendComplete on packets
    for which the MiniportSendPackets or <f MiniportWanSend> function
    returned NDIS_STATUS_PENDING.

    If the NIC shares an IRQ, <f MiniportHandleInterrupt> is called only i
    f the <f MiniportISR> function returned InterruptRecognized set to
    TRUE, thereby indicating that the NIC generated a particular interrupt.

    When <f MiniportHandleInterrupt> is called, interrupts are disabled
    on the NIC, either by the <f MiniportISR> or <f MiniportDisableInterrupt>
    function. Before it returns control, <f MiniportHandleInterrupt> can
    re-enable interrupts on the NIC. Otherwise, NDIS calls a driver-supplied
    MiniportEnableInterrupt function to do so when <f MiniportHandleInterrupt>
    returns control.

    By default, <f MiniportHandleInterrupt> runs at IRQL DISPATCH_LEVEL.

@xref

    <f MiniportDisableInterrupt>
    <f MiniportEnableInterrupt>
    <f MiniportInitialize>
    <f MiniportISR>
    <f MiniportWanSend>

*/

void MiniportHandleInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportHandleInterrupt")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    ULONG                       BChannelIndex;
    // Index into the pBChannelArray.

    /*
    // Process NIC interrupt.
    */
    CardInterruptHandler(pAdapter->pCard);

    /*
    // Walk through all the links to see if there is any post-proccessing
    // that needs to be done.
    */
    for (BChannelIndex = 0; BChannelIndex < pAdapter->NumBChannels; ++BChannelIndex)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex);

        if (pBChannel->IsOpen)
        {
            /*
            // If this is the last transmit queued on this link, and it has
            // been closed, close the link and notify the protocol that the
            // link has been closed.
            */
            if (IsListEmpty(&pBChannel->TransmitBusyList)
                && pBChannel->CallClosing)
            {
                DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                           ("#%d Call=0x%X CallState=0x%X CLOSE PENDED\n",
                            pBChannel->BChannelIndex,
                            pBChannel->htCall, pBChannel->CallState));

                /*
                // This must not be called until all transmits have been dequeued
                // and ack'd.  Otherwise the wrapper will hang waiting for transmit
                // request to complete.
                */
                DChannelCloseCall(pAdapter->pDChannel, pBChannel);

                /*
                // Indicate close complete to the wrapper.
                */
                NdisMSetInformationComplete(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_STATUS_SUCCESS
                        );
            }

            /*
            // Indicate a receive complete if it's needed.
            */
            if (pBChannel->NeedReceiveCompleteIndication)
            {
                pBChannel->NeedReceiveCompleteIndication = FALSE;

                /*
                // Indicate receive complete to the NDIS wrapper.
                */
                DBG_RXC(pAdapter, pBChannel->BChannelIndex);
                NdisMWanIndicateReceiveComplete(
                        pAdapter->MiniportAdapterHandle,
                        pBChannel->NdisLinkContext
                        );
            }
        }
    }

    /*
    // Indicate a status complete if it's needed.
    */
    if (pAdapter->NeedStatusCompleteIndication)
    {
        pAdapter->NeedStatusCompleteIndication = FALSE;
        NdisMIndicateStatusComplete(pAdapter->MiniportAdapterHandle);
    }
}


/* @doc INTERNAL Interupt Interupt_c MiniportTimer


@func

    <f MiniportTimer> is a required function if a Miniport's NIC does not
    generate interrupts.  Otherwise, one or more <f MiniportTimer> functions
    are optional.

@comm

    For a NIC that does not generate interrupts, the <f MiniportTimer>
    function is used to poll the state of the NIC.

    After such a driver's <f MiniportInitialize> function sets up the
    driver-allocated timer object with NdisMInitializeTimer, a
    call to NdisMSetPeriodicTimer causes the <f MiniportTimer> function
    associated with the timer object to be run repeatedly and
    automatically at the interval specified by MillisecondsPeriod.
    Such a polling <f MiniportTimer> function monitors the state of the
    NIC to determine when to make indications, when to complete
    pending sends, and so forth. In effect, such a polling <f MiniportTimer>
    function has the same functionality as the <f MiniportHandleInterrupt>
    function in the driver of a NIC that does generate interrupts.

    By contrast, calling NdisMSetTimer causes the <f MiniportTimer>
    function associated with the timer object to be run once when
    the given MillisecondsToDelay expires. Such a <f MiniportTimer>
    function usually performs some driver-determined action if a
    particular operation times out.

    If either type of <f MiniportTimer> function shares resources with
    other driver functions, the driver should synchronize access to
    those resources with a spin lock.

    Any NIC driver or intermediate driver can have more than one
    <f MiniportTimer> function at the discretion of the driver writer.
    Each such <f MiniportTimer> function must be associated with a
    driver-allocated and initialized timer object.

    A call to NdisMCancelTimer cancels execution of a nonpolling
    <f MiniportTimer> function, provided that the interval passed in
    the immediately preceding call to NdisMSetTimer has not yet
    expired. After a call to NdisMSetPeriodicTimer, a call to
    NdisMSetTimer or NdisMCancelTimer with the same timer object
    disables a polling <f MiniportTimer> function: either the
    MiniportTimer function runs once, or it is canceled.

    The <f MiniportHalt> function of any driver with a <f MiniportTimer>
    function should call NdisMCancelTimer to ensure that the
    <f MiniportTimer> function does not attempt to access resources
    that <f MiniportHalt> has already released.

    By default, <f MiniportTimer> runs at IRQL DISPATCH_LEVEL.

@xref
    <f MiniportHalt>
    <f MiniportInitialize>
    <f NdisAcquireSpinLock>
    <f NdisAllocateSpinLock>


*/

void MiniportTimer(
    IN PVOID                    SystemSpecific1,            // @parm
    // Points to a system-specific variable, which is opaque
    // to <f MiniportTimer> and reserved for system use.
    // UNREFERENCED_PARAMETER

    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PVOID                    SystemSpecific2,            // @parm
    // UNREFERENCED_PARAMETER

    IN PVOID                    SystemSpecific3             // @parm
    // UNREFERENCED_PARAMETER
    )
{
    DBG_FUNC("MiniportTimer")

    DBG_ENTER(pAdapter);

    /*
    // If this is a nested callback, just return, and we'll loop back to
    // the DoItAgain before leaving the outermost callback.
    */
    if (++(pAdapter->NestedEventHandler) > 1)
    {
        DBG_WARNING(pAdapter,("NestedEventHandler=%d > 1\n",
                  pAdapter->NestedEventHandler));
        return;
    }

DoItAgain:
#if defined(SAMPLE_DRIVER)
    /*
    // This sample driver uses timer to simulate interrupts.
    */
    MiniportHandleInterrupt(pAdapter);
#else  // SAMPLE_DRIVER
    // TODO - Add code here to handle timer interrupt events.
#endif // SAMPLE_DRIVER

    /*
    // If we got a nested callback, we have to loop back around.
    */
    if (--(pAdapter->NestedEventHandler) > 0)
    {
        goto DoItAgain;
    }
    else if (pAdapter->NestedEventHandler < 0)
    {
        DBG_ERROR(pAdapter,("NestedEventHandler=%d < 0\n",
                  pAdapter->NestedEventHandler));
    }

    DBG_LEAVE(pAdapter);

    UNREFERENCED_PARAMETER(SystemSpecific1);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    UNREFERENCED_PARAMETER(SystemSpecific3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\miniport.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Miniport Miniport_h

@module Miniport.h |

    This module defines the interface to the <t MINIPORT_DRIVER_OBJECT_TYPE>.

@comm

    This module defines the software structures and values used to support
    the NDIS WAN/TAPI Minport.  It's a good place to look when your trying
    to figure out how the driver structures are related to each other.

    Include this file at the top of each module in the Miniport.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Miniport_h

@end

*/

#ifndef _MPDMAIN_H
#define _MPDMAIN_H

#define MINIPORT_DRIVER_OBJECT_TYPE     ((ULONG)'D')+\
                                        ((ULONG)'R'<<8)+\
                                        ((ULONG)'V'<<16)+\
                                        ((ULONG)'R'<<24)

#define INTERRUPT_OBJECT_TYPE           ((ULONG)'I')+\
                                        ((ULONG)'N'<<8)+\
                                        ((ULONG)'T'<<16)+\
                                        ((ULONG)'R'<<24)

#define RECEIVE_OBJECT_TYPE             ((ULONG)'R')+\
                                        ((ULONG)'E'<<8)+\
                                        ((ULONG)'C'<<16)+\
                                        ((ULONG)'V'<<24)

#define TRANSMIT_OBJECT_TYPE            ((ULONG)'T')+\
                                        ((ULONG)'R'<<8)+\
                                        ((ULONG)'A'<<16)+\
                                        ((ULONG)'N'<<24)

#define REQUEST_OBJECT_TYPE             ((ULONG)'R')+\
                                        ((ULONG)'Q'<<8)+\
                                        ((ULONG)'S'<<16)+\
                                        ((ULONG)'T'<<24)

/*
// NDIS_MINIPORT_DRIVER and BINARY_COMPATIBLE must be defined before the
// NDIS include files.  Normally, it is defined on the command line by
// setting the C_DEFINES variable in the SOURCES build file.
*/
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include "vTarget.h"
#include "TpiDebug.h"

// Figure out which DDK we're building with.
#if defined(NDIS_LCODE)
#  if defined(NDIS_DOS)
#    define USING_WFW_DDK
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#  elif defined(OID_WAN_GET_INFO)
#    define USING_WIN98_DDK
#  elif defined(NDIS_WIN)
#    define USING_WIN95_DDK
#  else
#    error "BUILDING WITH UNKNOWN 9X DDK"
#  endif
#elif defined(NDIS_NT)
#  if defined(OID_GEN_MACHINE_NAME)
#    define USING_NT51_DDK
#  elif defined(OID_GEN_SUPPORTED_GUIDS)
#    define USING_NT50_DDK
#  elif defined(OID_GEN_MEDIA_CONNECT_STATUS)
#    define USING_NT40_DDK
#  elif defined(OID_WAN_GET_INFO)
#    define USING_NT351_DDK
#  else
#    define USING_NT31_DDK
#  endif
#else
#  error "BUILDING WITH UNKNOWN DDK"
#endif

// Figure out which DDK we should be building with.
#if defined(NDIS51) || defined(NDIS51_MINIPORT)
#  if defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x05
#    define NDIS_MINOR_VERSION          0x01
#  else
#    error "YOU MUST BUILD WITH THE NT 5.1 DDK"
#  endif
#elif defined(NDIS50) || defined(NDIS50_MINIPORT)
#  if defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x05
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 5.0 or 5.1 DDK"
#  endif
#elif defined(NDIS40) || defined(NDIS40_MINIPORT)
#  if defined(USING_NT40_DDK) || defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x04
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 4.0 or 5.0 DDK"
#  endif
#elif defined(NDIS_MINIPORT_DRIVER)
#  if defined(USING_NT351_DDK) || defined(USING_NT40_DDK) || defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 3.51, 4.0, or 5.0 DDK"
#  endif
#elif !defined(NDIS_MAJOR_VERSION) || !defined(NDIS_MINOR_VERSION)
//   Must be FULL MAC
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#endif

// Gotta nest NDIS_STRING_CONST or compiler/preprocessor won't be able to
// handle L##DEFINED_STRING.
#define INIT_STRING_CONST(name) NDIS_STRING_CONST(name)

typedef struct MINIPORT_ADAPTER_OBJECT  *PMINIPORT_ADAPTER_OBJECT;
typedef struct BCHANNEL_OBJECT          *PBCHANNEL_OBJECT;
typedef struct DCHANNEL_OBJECT          *PDCHANNEL_OBJECT;
typedef struct CARD_OBJECT              *PCARD_OBJECT;
typedef struct PORT_OBJECT              *PPORT_OBJECT;

/*
// The <t NDIS_MAC_LINE_UP> structure is confusing, so I redefine the
// field name to be what makes sense.
*/
#define MiniportLinkContext                 NdisLinkHandle

#if defined(_VXD_) && !defined(NDIS_LCODE)
#  define NDIS_LCODE code_seg("_LTEXT", "LCODE")
#  define NDIS_LDATA data_seg("_LDATA", "LCODE")
#endif

/*
// The link speeds we support.
*/
#define _64KBPS                     64000
#define _56KBPS                     56000

#define MICROSECONDS                (1)
#define MILLISECONDS                (1000*MICROSECONDS)
#define SECONDS                     (1000*MILLISECONDS)

/*
// Include everything here so the driver modules can just include this
// file and get all they need.
*/
#include "Keywords.h"
#include "Card.h"
#include "Adapter.h"
#include "BChannel.h"
#include "DChannel.h"
#include "Link.h"
#include "Port.h"
#include "Tspi.h"
#include "TpiParam.h"
#include "TpiMem.h"

/***************************************************************************
// These routines are defined in Miniport.c
*/

NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath
    );

NDIS_STATUS MiniportInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PUINT                   SelectedMediumIndex,
    IN PNDIS_MEDIUM             MediumArray,
    IN UINT                     MediumArraySize,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              WrapperConfigurationContext
    );

void MiniportHalt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

NDIS_STATUS MiniportReset(
    OUT PBOOLEAN                AddressingReset,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

/***************************************************************************
// These routines are defined in interrup.c
*/
BOOLEAN MiniportCheckForHang(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportDisableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportEnableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportHandleInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportISR(
    OUT PBOOLEAN                InterruptRecognized,
    OUT PBOOLEAN                QueueMiniportHandleInterrupt,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportTimer(
    IN PVOID                    SystemSpecific1,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PVOID                    SystemSpecific2,
    IN PVOID                    SystemSpecific3
    );

/***************************************************************************
// These routines are defined in receive.c
*/
void ReceivePacketHandler(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PUCHAR                   ReceiveBuffer,
    IN ULONG                    BytesReceived
    );

/***************************************************************************
// These routines are defined in request.c
*/
NDIS_STATUS MiniportQueryInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_OID                 Oid,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS MiniportSetInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_OID                 Oid,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

/***************************************************************************
// These routines are defined in send.c
*/
NDIS_STATUS MiniportWanSend(
    IN NDIS_HANDLE              MacBindingHandle,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PNDIS_WAN_PACKET         pWanPacket
    );

void TransmitCompleteHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

#endif // _MPDMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tpimem.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiMem TpiMem_h

@module TpiMem.h |

    This module defines the interface to the memory allocation wrappers.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiMem_h

@end

*/

#ifndef _TPIMEM_H
#define _TPIMEM_H

#include <ndis.h>

#define TPIMEMORY_OBJECT_TYPE           ((ULONG)'T')+\
                                        ((ULONG)'M'<<8)+\
                                        ((ULONG)'E'<<16)+\
                                        ((ULONG)'M'<<24)

#define ALLOCATE_MEMORY(pObject, dwSize, MiniportAdapterHandle)\
            TpiAllocateMemory((PVOID *)&(pObject), dwSize,\
                              __FILEID__, __FILE__, __LINE__,\
                              MiniportAdapterHandle)

#define FREE_MEMORY(pObject, dwSize)\
            TpiFreeMemory((PVOID *)&(pObject), dwSize,\
                          __FILEID__, __FILE__, __LINE__)

#define ALLOCATE_OBJECT(pObject, MiniportAdapterHandle)\
            ALLOCATE_MEMORY(pObject, sizeof(*(pObject)), MiniportAdapterHandle)

#define FREE_OBJECT(pObject)\
            FREE_MEMORY(pObject, sizeof(*(pObject)))

#define FREE_NDISSTRING(ndisString)\
            FREE_MEMORY(ndisString.Buffer, ndisString.MaximumLength)

NDIS_STATUS TpiAllocateMemory(
    OUT PVOID *                 ppObject,
    IN ULONG                    dwSize,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber,
    IN NDIS_HANDLE              MiniportAdapterHandle
    );

void TpiFreeMemory(
    IN OUT PVOID *              ppObject,
    IN ULONG                    dwSize,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

NDIS_STATUS TpiAllocateSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN ULONG                    dwSize,
    IN BOOLEAN                  bCached,
    OUT PVOID *                 pVirtualAddress,
    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

void TpiFreeSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN ULONG                    dwSize,
    IN BOOLEAN                  bCached,
    OUT PVOID *                 pVirtualAddress,
    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

extern NDIS_PHYSICAL_ADDRESS g_HighestAcceptableAddress;

#endif // _TPIMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\port.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Port Port_h

@module Port.h |

    This module defines the interface to the <t PORT_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Port_h

@end

*/

#ifndef _PORT_H
#define _PORT_H

#define PORT_OBJECT_TYPE        ((ULONG)'P')+\
                                ((ULONG)'O'<<8)+\
                                ((ULONG)'R'<<16)+\
                                ((ULONG)'T'<<24)

#define MAX_PORTS               10
// The most I've ever seen is 4 - If you have more than 10, the code will
// have to change to handle more than a single digit "PortX" parameter.

/* @doc INTERNAL Port Port_h PORT_OBJECT


@struct PORT_OBJECT |

    This structure contains the data associated with an ISDN port.  Here,
    a port is defined as a single BRI, PRI, T-1, or E-1 physical interface.

*/

typedef struct PORT_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'PORT'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PCARD_OBJECT                pCard;                      // @field
    // Pointer to the <t CARD_OBJECT> owning this port.

    BOOLEAN                     IsOpen;                     // @field
    // Set TRUE if this BChannel is open, otherwise set FALSE.

    ULONG                       NumChannels;                // @field
    // Number of communications channels configured on this port.

    ULONG                       PortIndex;                  // @field
    // Port Index (0 .. MAX_PORTS-1).

    ULONG                       SwitchType;                 // @field
    // ISDN switch type.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} PORT_OBJECT, *PPORT_OBJECT;

#define GET_ADAPTER_FROM_PORT(pPort)            (pPort->pCard->pAdapter)


/*


    Function prototypes.

*/

NDIS_STATUS PortCreate(
    OUT PPORT_OBJECT *          ppPort,
    IN PCARD_OBJECT             pCard
    );

void PortInitialize(
    PPORT_OBJECT                pPort
    );

void PortDestroy(
    PPORT_OBJECT                pPort
    );

#endif // _PORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tpimem.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiMem TpiMem_c

@module TpiMem.c |

    This module implements the interface to the memory allocation wrappers.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiMem_c

@end

*/

#define  __FILEID__             TPIMEMORY_OBJECT_TYPE
// Unique file ID for error logging

#include "TpiMem.h"
#include "TpiDebug.h"

DBG_STATIC ULONG                g_MemoryAllocated = 0;
DBG_STATIC ULONG                g_MemoryFreed = 0;
DBG_STATIC ULONG                g_SharedMemoryAllocated = 0;
DBG_STATIC ULONG                g_SharedMemoryFreed = 0;


/* @doc INTERNAL TpiMem TpiMem_c TpiAllocateMemory


@func

    <f TpiAllocateMemory> provides a wrapper interface for standard memory
    allocation via <f NdisAllocateMemory>.  This interface is used to help
    debug memory allocation problems.  It can be used to keep track of how
    much memory has been allocated and freed by the Miniport, and can report
    the usage counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisAllocateMemory> (i.e. non-paged system memory).  Do not use this
    routine to allocate continuous or non-cached memory.

@rdesc

    <f TpiAllocateMemory> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS TpiAllocateMemory(
    OUT PVOID *                 ppObject,                   // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber,               // @parm
    // Line number of the file where called from.

    IN NDIS_HANDLE              MiniportAdapterHandle       // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.
    )
{
    DBG_FUNC("TpiAllocateMemory")

    NDIS_STATUS                 Status;
    // Holds the status result returned from an NDIS function call.

    ASSERT(ppObject);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|ppObject=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               ppObject,
               dwSize,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    /*
    // Allocate memory from NDIS.
    */
#if !defined(NDIS50_MINIPORT)
    Status = NdisAllocateMemory(ppObject, dwSize, 0, g_HighestAcceptableAddress);
#else  // NDIS50_MINIPORT
    Status = NdisAllocateMemoryWithTag(ppObject, dwSize, dwFileID);
#endif // NDIS50_MINIPORT

    if (Status == NDIS_STATUS_SUCCESS)
    {
        ASSERT(*ppObject);
        NdisZeroMemory(*ppObject, dwSize);
        g_MemoryAllocated += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("Memory Allocated=%d Freed=%d -- Ptr=0x%X\n",
                   g_MemoryAllocated, g_MemoryFreed, *ppObject));
    }
    else
    {
        DBG_ERROR(DbgInfo,("NdisAllocateMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                  dwSize, szFileName, dwLineNumber, Status));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                3,
                Status,
                dwFileID,
                dwLineNumber
                );

        *ppObject = NULL;
    }

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiFreeMemory


@func

    <f TpiFreeMemory> provides a wrapper interface for <f NdisFreeMemory>.
    This interface is used to help debug memory allocation problems.  It can
    be used to keep track of how much memory has been allocated and freed by
    the Miniport, and can report the usage counters via the debugger.

    <f TpiFreeMemory> provides a wrapper interface for standard memory free
    via <f NdisFreeMemory>.  This interface is used to help debug memory
    allocation problems.  It can be used to keep track of how much memory
    has been allocated and freed by the Miniport, and can report the usage
    counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisFreeMemory> (i.e. non-paged system memory).  Do no use this
    routine to free continuous or non-cached memory.

*/

void TpiFreeMemory(
    IN OUT PVOID *              ppObject,                   // @parm
    // Points to a caller-defined memory location which this function
    // passes to <f NdisFreeMemory> and then writes NULL to.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiFreeMemory")

    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|ppObject=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               ppObject,
               dwSize,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    if (ppObject && *ppObject)
    {
        /*
        // Release memory to NDIS.
        */
        NdisFreeMemory(*ppObject, dwSize, 0);
        g_MemoryFreed += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("Memory Allocated=%d Freed=%d -- Ptr=0x%X\n",
                   g_MemoryAllocated, g_MemoryFreed, *ppObject));

        *ppObject = NULL;
    }
    else
    {
        DBG_ERROR(DbgInfo,("NULL POINTER (Size=%d, File=%s, Line=%d)\n",
                  dwSize, szFileName, dwLineNumber));
    }

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiAllocateSharedMemory


@func

    <f TpiAllocateSharedMemory> provides a wrapper interface for shared memory
    allocation via <f NdisMAllocateSharedMemory>.  This interface is used to help
    debug memory allocation problems.  It can be used to keep track of how
    much memory has been allocated and freed by the Miniport, and can report
    the usage counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisMAllocateSharedMemory> (i.e. non-paged system memory).  Do not
    use this routine to allocate continuous or non-cached memory.

@rdesc

    <f TpiAllocateSharedMemory> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS TpiAllocateSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN BOOLEAN                  bCached,                    // @parm
    // Specifies whether the requested memory is cached or not.

    OUT PVOID *                 pVirtualAddress,            // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,           // @parm
    // Points to a caller-defined memory location to which this function
    // writes the physical address of the allocated memory.  If memory of
    // the specified type is not available, the physical address is zero.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiAllocateSharedMemory")

    NDIS_STATUS                 Status;
    // Holds the status result returned from an NDIS function call.

    ASSERT(pVirtualAddress);
    ASSERT(pPhysicalAddress);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|pVirtualAddress=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|bCached=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               pVirtualAddress,
               dwSize,
               bCached,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    /*
    // Allocate memory from NDIS.
    */
    NdisMAllocateSharedMemory(MiniportAdapterHandle,
                              dwSize,
                              bCached,
                              pVirtualAddress,
                              pPhysicalAddress
                              );


    if (*pVirtualAddress)
    {
        Status = NDIS_STATUS_SUCCESS;

        NdisZeroMemory(*pVirtualAddress, dwSize);
        g_SharedMemoryAllocated += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("SharedMemory Allocated=%d Freed=%d -- Ptr=0x%X @0x%X\n",
                   g_SharedMemoryAllocated, g_SharedMemoryFreed,
                   *pVirtualAddress, pPhysicalAddress->LowPart));
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;

        DBG_ERROR(DbgInfo,("NdisAllocateSharedMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                  dwSize, szFileName, dwLineNumber, Status));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                3,
                Status,
                dwFileID,
                dwLineNumber
                );

        *pVirtualAddress = NULL;
        pPhysicalAddress->LowPart = 0;
        pPhysicalAddress->HighPart = 0;
    }

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiFreeSharedMemory


@func

    <f TpiFreeSharedMemory> provides a wrapper interface for <f NdisFreeSharedMemory>.
    This interface is used to help debug memory allocation problems.  It can
    be used to keep track of how much memory has been allocated and freed by
    the Miniport, and can report the usage counters via the debugger.

    <f TpiFreeSharedMemory> provides a wrapper interface for standard memory free
    via <f NdisFreeSharedMemory>.  This interface is used to help debug memory
    allocation problems.  It can be used to keep track of how much memory
    has been allocated and freed by the Miniport, and can report the usage
    counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisFreeSharedMemory> (i.e. non-paged system memory).  Do no use this
    routine to free continuous or non-cached memory.

*/

void TpiFreeSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN BOOLEAN                  bCached,                    // @parm
    // Specifies whether the requested memory is cached or not.

    IN PVOID *                  pVirtualAddress,            // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    IN NDIS_PHYSICAL_ADDRESS *  pPhysicalAddress,           // @parm
    // Points to a caller-defined memory location to which this function
    // writes the physical address of the allocated memory.  If memory of
    // the specified type is not available, the physical address is zero.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiFreeSharedMemory")

    ASSERT(pVirtualAddress);
    ASSERT(pPhysicalAddress);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|pVirtualAddress=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|bCached=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               pVirtualAddress,
               dwSize,
               bCached,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    if (pVirtualAddress && *pVirtualAddress)
    {
        /*
        // Release memory to NDIS.
        */
        NdisMFreeSharedMemory(MiniportAdapterHandle,
                              dwSize,
                              bCached,
                              *pVirtualAddress,
                              *pPhysicalAddress
                              );
        g_SharedMemoryFreed += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("SharedMemory Allocated=%d Freed=%d -- Ptr=0x%X @0x%X\n",
                   g_SharedMemoryAllocated, g_SharedMemoryFreed,
                   *pVirtualAddress, pPhysicalAddress->LowPart));

        *pVirtualAddress = NULL;
        pPhysicalAddress->LowPart = 0;
        pPhysicalAddress->HighPart = 0;
    }
    else
    {
        DBG_ERROR(DbgInfo,("NULL POINTER (Size=%d, File=%s, Line=%d)\n",
                  dwSize, szFileName, dwLineNumber));
    }

    DBG_LEAVE(DbgInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tpidebug.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiDebug TpiDebug_h

@module TpiDebug.h |

    This module, along with <f TpiDebug\.c>, implements code and macros to
    support NDIS driver debugging.  This file should be #include'd in all
    the driver source code modules.

@comm

    The code and macros defined by these modules is only generated during
    development debugging when the C pre-processor macro flag (DBG == 1).
    If (DBG == 0) no code will be generated, and all debug strings will be
    removed from the image.

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiDebug_h

@end

*/

#ifndef _TPIDEBUG_H
#define _TPIDEBUG_H

/* @doc INTERNAL TpiDebug TpiDebug_h


@topic Debug Globals |

    Debug macros are used to display error conditions, warnings, interesting
    events, and general flow through the components.  Setting one or more bits
    in the <f DbgInfo> global variable will enable the output from these
    macros.  See <t DEBUG_FLAGS> for details of the bits.  Only the debug
    version of the driver will contain code for this purpose.  All these
    macros will be compiled out in the release version.

    Each component has a separate <f DbgInfo> variable, so you can control
    debug output for each module separately.  By default, all the modules
    breakpoint at their entry point to display the current value and memory
    location of the module's <f DbgInfo> variable.  This way you can use
    the debugger to change the flags when the module is started.  The default
    flag for each module is set at compile time, but can be overridden at
    run time using the debugger.

@globalv DBG_SETTINGS | DbgInfo |

    DbgInfo is a global variable which points to the <t DBG_SETTINGS> for
    the module linked with <f TpiDebug\.c>.  It is passed to most of
    the debug output macros to control which output is to be displayed.  
    See <t DBG_FLAGS> to determine which bits to set.

*/

/*
// Module ID numbers to use for error logging
*/
#define TPI_MODULE_PARAMS               ((unsigned long)'P')+\
                                        ((unsigned long)'A'<<8)+\
                                        ((unsigned long)'R'<<16)+\
                                        ((unsigned long)'M'<<24)
#define TPI_MODULE_DEBUG                ((unsigned long)'D')+\
                                        ((unsigned long)'B'<<8)+\
                                        ((unsigned long)'U'<<16)+\
                                        ((unsigned long)'G'<<24)
#define TPI_MODULE_PERF                 ((unsigned long)'P')+\
                                        ((unsigned long)'E'<<8)+\
                                        ((unsigned long)'R'<<16)+\
                                        ((unsigned long)'F'<<24)
#define TPI_MODULE_WRAPS                ((unsigned long)'W')+\
                                        ((unsigned long)'R'<<8)+\
                                        ((unsigned long)'A'<<16)+\
                                        ((unsigned long)'P'<<24)

// In case these aren't defined in the current environment.
#if !defined(IN)
# define    IN
# define    OUT
#endif

/* @doc INTERNAL TpiDebug TpiDebug_h DBG_FLAGS


@enum DBG_FLAGS |

    The registry parameter <f DebugFlags> is read by the driver at
    initialization time and saved in the <f DbgFlags> field of the
    debug settings structure (See <t DBG_SETTINGS>).  This value
    controls the output of debug information according to the
    following bit OR'd flags.  The most significant 16 bits of the
    DbgFlags is available to use as you please, and can be used
    with the <f DBG_FILTER> macro.

*/

#define DBG_ERROR_ON        0x0001L
        // @emem DBG_ERROR_ON | (0x0001) Display <f DBG_ERROR> messages.

#define DBG_WARNING_ON      0x0002L
        // @emem DBG_WARNING_ON | (0x0002) Display <f DBG_WARNING> messages.

#define DBG_NOTICE_ON       0x0004L
        // @emem DBG_NOTICE_ON | (0x0004) Display <f DBG_NOTICE> messages.

#define DBG_TRACE_ON        0x0008L
        // @emem DBG_TRACE_ON | (0x0008) Display <f DBG_ENTER>, <f DBG_LEAVE>,
        // and <f DBG_TRACE> messages.

#define DBG_REQUEST_ON      0x0010L
        // @emem DBG_REQUEST_ON | (0x0010) Display NDIS Set/Query request
        // parameters using <f DBG_REQUEST>.

#define DBG_INDICATE_ON     0x0020L
        // @emem DBG_INDICATE_ON | (0x0020) Display NDIS status indications.

#define DBG_TAPICALL_ON     0x0040L
        // @emem DBG_TAPICALL_ON | (0x0040) Display TAPI call state messages
        // using <f DBG_FILTER>.

#define DBG_PARAMS_ON       0x0080L
        // @emem DBG_PARAMS_ON | (0x0080) Display function parameters and
        // return values using <f DBG_PARAMS>.

#define DBG_TXRX_LOG_ON     0x0100L
        // @emem DBG_TXRX_LOG_ON | (0x0100) Enable Tx/Rx data logging.

#define DBG_TXRX_ON         0x0200L
        // @emem DBG_TXRX_ON | (0x0200) Display Tx/Rx terse packet info.
        // This flag will just display the link index and packet length Rx#:#.

#define DBG_TXRX_HEADERS_ON 0x0400L
        // @emem DBG_TXRX_HEADERS_ON | (0x0400) Display Tx/Rx packet headers.

#define DBG_HEADERS_ON      DBG_TXRX_HEADERS_ON

#define DBG_TXRX_VERBOSE_ON 0x0800L
        // @emem DBG_TXRX_VERBOSE_ON | (0x0800) Display Tx/Rx packet data.

#define DBG_PACKETS_ON      DBG_TXRX_VERBOSE_ON

#define DBG_MEMORY_ON       0x1000L
        // @emem DBG_MEMORY_ON | (0x1000) Display memory allocate and
        // free usage information.

#define DBG_BUFFER_ON       0x2000L
        // @emem DBG_BUFFER_ON | (0x2000) Display buffer allocate and
        // free usage information.

#define DBG_PACKET_ON       0x4000L
        // @emem DBG_PACKET_ON | (0x4000) Display packet allocate and
        // free usage information.

#define DBG_BREAK_ON        0x8000L
        // @emem DBG_BREAK_ON | (0x8000) Enable <f DBG_BREAK> breakpoints.

#define DbgFlags            DebugFlags      // For compatability
#define DbgID               AnsiDeviceName  // For compatability

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/* @doc INTERNAL TpiDebug TpiDebug_h DBG_SETTINGS


@struct DBG_SETTINGS |

    This structure is used to control debug output for a given module.
    You can set and clear bits in the DbgFlags field to enabled and
    disable various debug macros.  See <t DBG_FLAGS> to determine which 
    bits to set.

*/

typedef struct DBG_SETTINGS
{
    unsigned long DbgFlags;                                 // @field
    // Debug flags control how much debug is displayed in the checked build.
    // Put this field at the front so you can set it easily with debugger.
    // See <t DBG_FLAGS> to determine which bits to set in this field.

    unsigned char DbgID[12];                                // @field
    // This field is initialized to an ASCII string containing a unique
    // module identifier.  It is used to prefix debug messages.  If you
    // have more than one module based on this code, you may want to
    // change the default value to a unqiue string for each module.
    // This string is used a C string, so the last byte must be a zero.

} DBG_SETTINGS, *PDBG_SETTINGS;

extern PDBG_SETTINGS DbgInfo;


/* @doc INTERNAL TpiDebug TpiDebug_h DBG_FIELD_TABLE


@struct DBG_FIELD_TABLE |

    This structure contains the data associated with a C data structure.
    You can use the <f DBG_FIELD_ENTRY> macro to add entries into a
    <t DBG_FIELD_TABLE>.  At run-time you can pass this table pointer to
    the <f DbgPrintFieldTable> routine, and it will display the current
    contents of that data structure.  This is useful for debugging drivers
    or code where no symbolic debugger is available, or if you have want to
    dump structure contents when certain run-time events are encountered.

@comm

    If you have nested structures, you must display them separately.  The
    <f DBG_FIELD_ENTRY> macro can only be used to declare integer type
    fields, and pointers.  Pointers will be displayed as a long integer.<nl>

    The last entry in the table must be all zeros {0}.

*/

typedef struct DBG_FIELD_TABLE
{
    unsigned int    FieldOffset;                            // @parm
    // This value indicates the offset, in bytes, from the <f pBaseContext>
    // pointer passed into <f DbgPrintFieldTable>.  The value for the field
    // will be displayed from this offset from <f pBaseContext>.
    // <nl>*(PUINT)((PUCHAR)BaseContext+Offset) = (UINT) Value;

    unsigned int    FieldType;                              // @parm
    // This value determines how the value will be displayed.
    // <f FieldType> can be one of the following values:
    // <nl>1=UCHAR  - unsigned char integer (8 bits).
    // <nl>2=USHORT - unsigned short integer (16 bits).
    // <nl>4=ULONG  - unsigned long integer (32 bits).

    unsigned char * FieldName;                              // @parm
    // This value points to a C String which is the name of the field within
    // the structure.

} DBG_FIELD_TABLE, *PDBG_FIELD_TABLE;

#define DBG_FIELD_BUFF      0
#define DBG_FIELD_CHAR      1
#define DBG_FIELD_SHORT     2
#define DBG_FIELD_LONG      4

#define DBG_FIELD_OFFSET(Strct, Field) ((unsigned int)((unsigned char *) &((Strct *) 0)->Field))
#define DBG_FIELD_SIZEOF(Strct, Field) sizeof(((Strct *) 0)->Field)
#define DBG_FIELD_ENTRY(Strct, Field) \
    { DBG_FIELD_OFFSET(Strct, Field), \
      DBG_FIELD_SIZEOF(Strct, Field), \
      #Field )

extern VOID DbgPrintFieldTable(
    IN PDBG_FIELD_TABLE     pFields,
    IN unsigned char *               pBaseContext,
    IN unsigned char *               pBaseName
    );

extern VOID DbgPrintData(
    IN unsigned char *               Data,
    IN unsigned int                 NumBytes,
    IN unsigned long                Offset
    );

extern VOID DbgQueueData(
    IN unsigned char *               Data,
    IN unsigned int                 NumBytes,
    IN unsigned int                 Flags
    );

#if !defined(NDIS_WIN) || !defined(DEBUG)
extern unsigned long __cdecl DbgPrint(char * Format, ...);
#endif

// DbgBreakPoint is ugly because it is defined by NTDDK as _stdcall,
// and 95DDK #defines it, and we must define our own for non-DDK builds.
// So all these ifdefs are used to figure out how to handle it.
#ifdef DbgBreakPoint
#   undef DbgBreakPoint
#endif // DbgBreakPoint

#if defined(_MSC_VER) && (_MSC_VER <= 800)
    // Must be building with 16-bit compiler
    extern VOID __cdecl DbgBreakPoint(VOID);
#else
    // Must be building with 32-bit compiler
    extern VOID __stdcall DbgBreakPoint(VOID);
#endif

extern VOID DbgSilentQueue(unsigned char * str);

#ifdef __cplusplus
};
#endif // __cplusplus

// NDIS builds define DBG=0 or DBG=1
#if defined(DEBUG) || defined(_DEBUG)
# ifndef DBG
#  define DBG 1
# endif
#else
# ifndef DBG
#  define DBG 0
# endif
#endif

//###############################################################################
#if DBG
//###############################################################################

#ifndef ASSERTS_ENABLED
#   define ASSERTS_ENABLED  1
#endif

#ifndef DBG_DEFAULTS
#   define DBG_DEFAULTS (DBG_ERROR_ON | DBG_WARNING_ON | DBG_BREAK_ON)
#endif

/* @doc INTERNAL TpiDebug TpiDebug_h


*/

#   define STATIC
#   define DBG_STATIC
    // Make all variables and functions global, so debugger can see them.

#   define TRAPFAULT        DbgBreakPoint()
    // Use this macro to insert an unconditional INT-1 breakpoint.  This
    // is used to distinguish between normal debugger breakpoints (INT-3)
    // and any special cases, such as ASSERT.

#   define BREAKPOINT       DbgBreakPoint()
    // Use this macro to insert an unconditional INT-3 breakpoint.

#   define DBG_FUNC(F)      static const char __FUNC__[] = F;
    // @func const char [] | DBG_FUNC |
    //
    // Use this macro to define the __FUNC__ string used by the rest of the
    // debugger macros to report the name of the function calling the macro.
    //
    // @parm const char * | FunctionName | Name of the function being defined.
    //
    // @ex <tab> | DBG_FUNC("MyFunctionName");

#   define DBG_BREAK(A)     {if ((A) && ((A)->DbgFlags & DBG_BREAK_ON) || !(A)) \
                                BREAKPOINT;}
    // @func VOID | DBG_BREAK |
    //
    // Use this macro to insert a conditional INT-3 breakpoint.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_BREAK(DbgInfo);

#   define DBG_ENTER(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON)) \
                                {DbgPrint("%s:>>>:%s\n",(A)->DbgID,__FUNC__);}}
    // @func VOID | DBG_ENTER |
    //
    // Use this macro to report entry to a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_ENTER(DbgInfo);

#   define DBG_TRACE(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON)) \
                                {DbgPrint("%s:%d:%s\n",(A)->DbgID,__LINE__,\
                                 __FUNC__);}}
    // @func VOID | DBG_TRACE |
    //
    // Use this macro to report a trace location within a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_TRACE(DbgInfo);

#   define DBG_LEAVE(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON))  \
                                {DbgPrint("%s:<<<:%s\n",(A)->DbgID,__FUNC__);}}
    // @func VOID | DBG_LEAVE |
    //
    // Use this macro to report exit from a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_LEAVE(DbgInfo);

#   define DBG_RETURN(A,S)  {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON))  \
                                {DbgPrint("%s:<<<:%s Return(0x%lX)\n",(A)->DbgID,__FUNC__,S);}}
    // @func VOID | DBG_RETURN |
    //
    // Use this macro to report exit from a function with a result.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_RETURN(DbgInfo, Result);

#   define DBG_ERROR(A,S)   {if ((A) && ((A)->DbgFlags & DBG_ERROR_ON))   \
                                {DbgPrint("%s:ERROR:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S; \
                                 if ((A)->DbgFlags & DBG_BREAK_ON) \
                                    {TRAPFAULT;}}}
    // @func VOID | DBG_ERROR |
    //
    // Use this macro to report any unexpected error conditions.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_ERROR(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_WARNING(A,S) {if ((A) && ((A)->DbgFlags & DBG_WARNING_ON)) \
                                {DbgPrint("%s:WARNING:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_WARNING |
    //
    // Use this macro to report any unusual run-time conditions.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_WARNING(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_NOTICE(A,S)  {if ((A) && ((A)->DbgFlags & DBG_NOTICE_ON))  \
                                {DbgPrint("%s:NOTICE:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_NOTICE |
    //
    // Use this macro to report any verbose debug information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_NOTICE(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_REQUEST(A,S)  {if ((A) && ((A)->DbgFlags & DBG_REQUEST_ON))  \
                                {DbgPrint("%s:REQUEST:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_REQUEST |
    //
    // Use this macro to report NDIS Set/Query request information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_REQUEST(DbgInfo, ("Oid #0x%08X - %s\n", Oid, DbgGetOidString(Oid)));

#   define DBG_PARAMS(A,S)  {if ((A) && ((A)->DbgFlags & DBG_PARAMS_ON))  \
                                {DbgPrint("%s:PARAMS:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_PARAMS |
    //
    // Use this macro to report NDIS Set/Query request information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_PARAMS(DbgInfo, ("\n\tNum=0x%X\n\tStr='%s'\n", Num, Str));

#   define DBG_TX(A,I,N,B)  {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Tx%d:%03X:\n",(A)->DbgID,I,N); \
                                if (((A)->DbgFlags & DBG_TXRX_VERBOSE_ON))  \
                                    DbgPrintData((unsigned char *)B, (unsigned int)N, 0); \
                                else if (((A)->DbgFlags & DBG_TXRX_HEADERS_ON))  \
                                    DbgPrintData((unsigned char *)B, 0x10, 0); \
                                }\
                             if ((A) && ((A)->DbgFlags & DBG_TXRX_LOG_ON)) \
                                DbgQueueData((unsigned char *)B, (unsigned int)N, \
                                              (USHORT)((I<< 8) + 0x4000)); \
                            }
    // @func VOID | DBG_TX |
    //
    // Use this macro to report outgoing packet information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @parm IN UINT | NumBytes | Number of bytes being transmitted.
    //
    // @parm IN PUCHAR | Buffer | Pointer to data buffer being transmitted.
    //
    // @ex <tab> | DBG_TX(DbgInfo, BChannelIndex, BytesToSend, CurrentBuffer);

#   define DBG_TXC(A,I)     {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Tc%d\n",(A)->DbgID,I); \
                                }}
    // @func VOID | DBG_TXC |
    //
    // Use this macro to report outgoing packet completion.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @ex <tab> | DBG_TXC(DbgInfo, BChannelIndex);

#   define DBG_RX(A,I,N,B)  {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Rx%d:%03X:\n",(A)->DbgID,I,N); \
                                if (((A)->DbgFlags & DBG_TXRX_VERBOSE_ON))  \
                                    DbgPrintData((unsigned char *)B, (unsigned int)N, 0); \
                                else if (((A)->DbgFlags & DBG_TXRX_HEADERS_ON))  \
                                    DbgPrintData((unsigned char *)B, 0x10, 0); \
                                }\
                             if ((A) && ((A)->DbgFlags & DBG_TXRX_LOG_ON)) \
                                DbgQueueData((unsigned char *)B, (unsigned int)N, \
                                              (USHORT)((I<< 8) + 0x8000)); \
                            }
    // @func VOID | DBG_RX |
    //
    // Use this macro to report incoming packet information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @parm IN UINT | NumBytes | Number of bytes being received.
    //
    // @parm IN PUCHAR | Buffer | Pointer to data buffer being received.
    //
    // @ex <tab> | DBG_RX(DbgInfo, BChannelIndex, BytesReceived, ReceiveBuffer);

#   define DBG_RXC(A,I)     {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Rc%d\n",(A)->DbgID,I); \
                                }}
    // @func VOID | DBG_RXC |
    //
    // Use this macro to report incoming packet completion.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @ex <tab> | DBG_RXC(DbgInfo, BChannelIndex);

#   define DBG_FILTER(A,M,S){if ((A) && ((A)->DbgFlags & (M)))            \
                                {DbgPrint("%s:%s: ",(A)->DbgID,__FUNC__); \
                                 DbgPrint S;}}
    // @func VOID | DBG_FILTER |
    //
    // Use this macro to filter for specific DbgFlag combinations.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN DBG_FLAGS | DbgMask | OR'd mask of <t DBG_FLAGS>.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_FILTER(DbgInfo, DBG_FILTER1_ON | DBG_REQUEST_ON,
    //                 ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_DISPLAY(S)   {DbgPrint("%s: ",__FUNC__); DbgPrint S;}
    // @func VOID | DBG_DISPLAY |
    //
    // Use this macro to unconditionally report a message.  This macro does
    // not take a pointer to the DBG_SETTINGS structure, so it can be used in
    // any module or function of the driver.  There is no way to disable the
    // display of these messages.  The funcion name precedes the output string.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_DISPLAY(("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_PRINT(S)     {DbgPrint S;}
    // @func VOID | DBG_PRINT |
    //
    // Use this macro to unconditionally report a message.  This macro does
    // not take a pointer to the DBG_SETTINGS structure, so it can be used in
    // any module or function of the driver.  There is no way to disable the
    // display of these messages.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_PRINT(("What happened at line %d!\n",__LINE__));

//###############################################################################
#else // !DBG
//###############################################################################

#ifndef ASSERTS_ENABLED
#   define ASSERTS_ENABLED  0
#endif

#   define DBG_DEFAULTS (0)

/*
// When (DBG == 0) we disable all the debug macros.
*/

#   define STATIC           static
#   define DBG_STATIC       static
#   define TRAPFAULT        DbgBreakPoint()
#   define BREAKPOINT
#   define DBG_FUNC(F)
#   define DBG_BREAK
#   define DBG_ENTER(A)
#   define DBG_TRACE(A)
#   define DBG_LEAVE(A)
#   define DBG_RETURN(A,S)
#   define DBG_ERROR(A,S)
#   define DBG_WARNING(A,S)
#   define DBG_NOTICE(A,S)
#   define DBG_REQUEST(A,S)
#   define DBG_PARAMS(A,S)
#   define DBG_TX(A,I,N,P)
#   define DBG_TXC(A,I)
#   define DBG_RX(A,I,N,P)
#   define DBG_RXC(A,I)
#   define DBG_FILTER(A,M,S)
#   define DBG_DISPLAY(S)
#   define DBG_PRINT(S)

//###############################################################################
#endif // DBG
//###############################################################################

#ifdef ASSERT
#   undef ASSERT
#endif
#ifdef assert
#   undef  assert
#endif

#if ASSERTS_ENABLED
#define ASSERT(C)   if (!(C)) { \
                        DbgPrint("ASSERT(%s) -- FILE:%s LINE:%d\n", \
                                 #C, __FILE__, __LINE__); \
                        TRAPFAULT; \
                    }
    // @func VOID | ASSERT |
    //
    // Use this macro to conditionally report a fatal error if the condition
    // specified is NOT true.
    //
    // @parm BOOLEAN_EXPRESSION | Expression | Any valid if (Expression).
    //
    // @ex <tab> | ASSERT(Actual == Expected);

#   define assert(C) ASSERT(C)
#else // !ASSERTS_ENABLED
#   define ASSERT(C)
#   define assert(C)
#endif // ASSERTS_ENABLED


#endif // _TPIDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tpidebug.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiDebug TpiDebug_c

@module TpiDebug.c |

    This module, along with <f TpiDebug\.h>, implements code and macros to
    support NDIS driver debugging.  This file must be linked with the driver
    to support debug dumps and logging.

@comm

    The code and macros defined by these modules is only generated during
    development debugging when the C pre-processor macro flag (DBG == 1).
    If (DBG == 0) no code will be generated, and all debug strings will be
    removed from the image.

    This is a device independent module which can be re-used, without
    change, by any driver or application.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiDebug_c

@end

*/

#if defined(_EXE_) || defined(_DLL_)
typedef char CHAR, *PCHAR;
typedef unsigned char  UCHAR,  *PUCHAR;
typedef unsigned short USHORT, *PUSHORT;
typedef unsigned long  ULONG,  *PULONG;
typedef unsigned int  *PUINT;

# include <windows.h>
#elif defined(_VXD_)
# include <basedef.h>
# include <vmm.h>
# pragma VxD_LOCKED_CODE_SEG
# pragma VxD_LOCKED_DATA_SEG
#else
# include <windef.h>
#endif

#include "TpiDebug.h"

#if DBG

/*
// Sometimes the debug output seriously impacts the run-time performance,
// so it is necessary to turn off the debug output.  In this case, you can
// capture some debug trace information into the DbgLogBuffer, and it can
// be examined later without impacting the run-time performance.
*/
#define DBG_LOG_ENTRIES     100     // Maximum number of FIFO log entries.
#define DBG_LOG_SIZE        128     // Maximum number of bytes per entry.

#if defined(_VXD_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'V','X','D',0 } };
#elif defined(_EXE_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'E','X','E',0 } };
#elif defined(_DLL_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'D','L','L',0 } };
#elif defined(_SYS_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'S','Y','S',0 } };
#else
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'T','P','I',0 } };
#endif

PDBG_SETTINGS   DbgInfo = &DbgSettings;
UINT            DbgLogIndex = 0;
UCHAR           DbgLogBuffer[DBG_LOG_ENTRIES][DBG_LOG_SIZE] = { { 0 } };


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrintData


@func

    <f DbgPrintData> outputs data to the debug display formatted in HEX and
    ASCII for easy viewing.

    <f Note>: This routine is used for debug output only.
    It is not compiled into the retail version.

@ex <tab> |
    DbgPrintData(ReceiveBuffer, 14, 0);                     // Packet header
    DbgPrintData(ReceiveBuffer+14, BytesReceived-14, 14);   // Packet data

0000: ff ff ff ff ff ff 0a 22 23 01 02 03 00 10        ......."#.....
000E: 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 40  ABCDEFGHIJKMNOPQ

*/

VOID DbgPrintData(
    IN PUCHAR                   Data,                       // @parm
    // Pointer to first byte of data to be displayed.

    IN UINT                     NumBytes,                   // @parm
    // Number of bytes to be displayed.

    IN ULONG                    Offset                      // @parm
    // Value to be added to the offset counter displayed at the start of each
    // line.  This is useful for viewing data whose base offset is relative to
    // another, non-zero starting address.

    )
{
    UINT                        LineStart;
    UINT                        LineIndex;

    /*
    // Display the caller's buffer with up to 16 bytes per line.
    */
    for (LineStart = 0; LineStart < NumBytes; LineStart += 16)
    {
        /*
        // Display the starting offset of the line.
        */
        DbgPrint("%04lx: ", LineStart + Offset);

        /*
        // Display a line of HEX byte values.
        */
        for (LineIndex = LineStart; LineIndex < (LineStart+16); LineIndex++)
        {
            if (LineIndex < NumBytes)
            {
                DbgPrint("%02x ",(UINT)((UCHAR)*(Data+LineIndex)));
            }
            else
            {
                DbgPrint("   ");
            }
        }
        DbgPrint("  ");     // A little white space between HEX and ASCII.

        /*
        // Display the corresponding ASCII byte values if they are printable.
        // (i.e. 0x20 <= N <= 0x7F).
        */
        for (LineIndex = LineStart; LineIndex < (LineStart+16); LineIndex++)
        {
            if (LineIndex < NumBytes)
            {
                char c = *(Data+LineIndex);

                if (c < ' ' || c > 'z')
                {
                    c = '.';
                }
                DbgPrint("%c", (UINT)c);
            }
            else
            {
                DbgPrint(" ");
            }
        }
        DbgPrint("\n");     // End of line.
    }
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgQueueData


@func

    <f DbgQueueData> saves data to the DbgLogBuffer so it can be viewed later
    with the debugger.

    <f Note>: This routine is used for debug output only.
    It is not compiled into the retail version.

*/

VOID DbgQueueData(
    IN PUCHAR                   Data,                       // @parm
    // Pointer to first byte of data to be displayed.

    IN UINT                     NumBytes,                   // @parm
    // Number of bytes to be displayed.

    IN UINT                     Flags                       // @parm
    // A flag descriptor to help identify the log entry.
    )
{
    /*
    // Point to the next available entry in the DbgLogBuffer.
    */
    PUCHAR LogEntry = &DbgLogBuffer[DbgLogIndex++][0];

    /*
    // Wrap around on the next entry if needed.
    */
    if (DbgLogIndex >= DBG_LOG_ENTRIES)
    {
        DbgLogIndex = 0;
    }

    /*
    // Save the flags parameter in the first WORD of the log buffer.
    */
    *((PUSHORT) LogEntry) = (USHORT) Flags;
    LogEntry += sizeof(PUSHORT);

    /*
    // Save the NumBytes parameter in the second WORD of the log buffer.
    */
    *((PUSHORT) LogEntry) = (USHORT) NumBytes;
    LogEntry += sizeof(NumBytes);

    /*
    // Don't try to save more than we have room for.
    */
    if (NumBytes > DBG_LOG_SIZE - sizeof(USHORT) * 2)
    {
        NumBytes = DBG_LOG_SIZE - sizeof(USHORT) * 2;
    }

    /*
    // Save the rest of the data in the remaining portion of the log buffer.
    */
    while (NumBytes--)
    {
        *LogEntry++ = *Data++;
    }
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgBreakPoint


@func VOID | DbgBreakPoint |

    <f DbgBreakPoint> is defined in the NT kernel for SYS drivers, but we
    override it here so we can support for SYS's, EXE's, VXD's, and DLL's.

*/
#if defined(_MSC_VER) && (_MSC_VER <= 800)
// Must be building with 16-bit compiler
VOID __cdecl DbgBreakPoint(VOID)
#else
// Must be building with 32-bit compiler
VOID __stdcall DbgBreakPoint(VOID)
#endif
{
#if !defined(_WIN64)
    __asm int 3;
#endif
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrint


@func ULONG __cdecl | DbgPrint |

    <f DbgPrint> is defined in the kernel for SYS drivers, otherwise it is
    supported here for EXE's, VXD's, and DLL's.

@parm PCHAR | Format |
    printf style format string.

@parm OPTIONAL | Params |
    Zero or more optional parameters as needed by the format string.

*/

#if defined(_VXD_)

#if !defined(NDIS_DOS)
ULONG __cdecl DbgPrint(PCHAR Format, ...)
{
    ULONG   result = 0;

    __asm lea  eax, (Format + 4)
    __asm push eax
    __asm push Format
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 4*2
    __asm mov result, eax

    return (result);
}
#endif

#elif defined(_EXE_) || defined(_DLL_)

UCHAR   DbgString[1024];

ULONG __cdecl DbgPrint(PCHAR Format, ...)
{
    ULONG   result;

    result = wvsprintf(DbgString, Format, ((PCHAR) &Format) + sizeof(PCHAR));

    OutputDebugString(DbgString);

    if (result >= sizeof(DbgString))
    {
        // We just blew the stack!
        // Since we can't return, we have to generate a stack-fault interrupt
        __asm int 1;
        __asm int 3;
        __asm int 12;
    }
    return (result);
}
#endif // DbgPrint

/*
 * If DBG_SILENT is set, all TERSE debug goes here. An assertion
 * will dump the block.
 */
#define DBG_QUEUE_LEN       4096
UINT    DbgIndex=0;
UINT    DbgLen=0;
UCHAR   DbgQueue[DBG_QUEUE_LEN] =  {0};
UCHAR   DbgLock=0;


/* @doc INTERNAL TpiDebug TpiDebug_c DbgDumpSilentQueue


@func

    <f DbgDumpSilentQueue> dumps the contents of the silent debug queue to
    the monitor.

*/

void DbgDumpSilentQueue(
    void
    )
{
    if (DbgLen >= DBG_QUEUE_LEN)
    {
        DbgPrintData(
            &DbgQueue[DbgIndex],
            DBG_QUEUE_LEN-DbgIndex,
            0);
        if (DbgIndex)
        {
            DbgPrint("\n");
            DbgPrintData(
                DbgQueue,
                DbgIndex-1,
                0);
        }
        DbgPrint("\n");
    }
    else if (DbgLen)
    {
        DbgPrintData(
                DbgQueue,
                DbgIndex-1,
                0);
        DbgPrint("\n");
    }
}

#if NDIS_NT

/* @doc INTERNAL TpiDebug TpiDebug_c _assert


@func

    <f _assert> overrides the assertion function provided by the operating
    system. Dumps the contents of debug queue, prints the assertion, and
    then traps to the debugger.  Used for debugging only.

*/

void _CRTAPI1 _assert(
    void *                      exp,                        // @parm
    // ASCIIZ pointer to the expression causing the fault.

    void *                      file,                       // @parm
    // ASCIIZ pointer to the name of the file.

    unsigned                    line                        // @parm
    // Line offset within the file where the assertion is defined.
    )
{
    DbgDumpSilentQueue();
    DbgPrint("Assertion Failed: %s at %s:%d\n",exp,file,line);
    DbgBreakPoint();
}
#endif


/* @doc INTERNAL TpiDebug TpiDebug_c DbgSilentQueue


@func

    <f DbgSilentQueue> logs a string to the debug queue which can be
    displayed later using <f DbgDumpSilentQueue>.  Used for debugging only.

*/

void DbgSilentQueue(
    PUCHAR                      str                         // @parm
    // Pointer to string to be placed in DbgQueue.
    )
{
    /*
    // If the debug queue is busy, just
    // bail out.
    */
    if ((++DbgLock) > 1)
    {
        goto exit;
    }

    while (str && *str)
    {
        DbgQueue[DbgIndex] = *str++;
        DbgLen++;
        if ((++DbgIndex) >= DBG_QUEUE_LEN)
        {
            DbgIndex = 0;
        }
    }
exit:
    DbgLock--;
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrintFieldTable


@func

    <f DbgPrintFieldTable> displays the contents of a C data structure in
    a formatted output to the debugger.  This can be used when symbolic
    debugging is not available on the target platform.

*/

void DbgPrintFieldTable(
    IN PDBG_FIELD_TABLE         pFields,                    // @parm
    // A pointer to an array of field records <t DBG_FIELD_TABLE>.

    IN PUCHAR                   pBaseContext,               // @parm
    // References the base of the structure where the values will be displayed
    // from.  This should be a pointer to the first byte of the structure.

    IN PUCHAR                   pBaseName                   // @parm
    // Pointer to C string containing the name of the structure being displayed.
    )
{
    DbgPrint("STRUCTURE: @0x%08X %s\n", pBaseContext, pBaseName);

    while (pFields->FieldName)
    {
        switch (pFields->FieldType)
        {
        case sizeof(ULONG):
            DbgPrint("\t%04X: %-32s=0x%08X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PULONG)(pBaseContext+pFields->FieldOffset));
            break;

        case sizeof(USHORT):
            DbgPrint("\t%04X: %-32s=0x%04X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PUSHORT)(pBaseContext+pFields->FieldOffset));
            break;

        case sizeof(UCHAR):
            DbgPrint("\t%04X: %-32s=0x%02X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PUCHAR)(pBaseContext+pFields->FieldOffset));
            break;

        default:
            ASSERT(0);
            break;
        }
        pFields++;
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\request.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Request Request_c

@module Request.c |

    This module implements the NDIS request routines for the Miniport.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Request_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.2 Query/Set Request Processing |

    For querying and setting network interface card binding information, the
    NDIS library calls <f MiniportQueryInformation> or <f MiniportSetInformation>.
    The upper layers place an object identifier (OID) in the structure for
    an object in the miniport NIC driver MIB that it wants to query or set.
    The <f MiniportQueryInformation> function fills in results and returns an
    appropriate status code to the NDIS library. See Part I of the Network
    Driver Reference for more information on OIDs.

    These two functions are potentially asynchronous. If they behave
    synchronously, they return immediately with a status code other than
    NDIS_STATUS_PENDING. If asynchronous, the function returns
    NDIS_STATUS_PENDING; and the miniport NIC driver later completes the
    request operation by a call to NdisMQueryInformationComplete for the
    query function or NdisMSetInformationComplete for the set function.

    The NDIS library guarantees that the miniport NIC driver will have only
    one outstanding request at a time so there is no need for the miniport
    NIC driver to queue requests.

@end
*/

#define  __FILEID__             REQUEST_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif

/*
// The following is a list of all the possible NDIS QuereyInformation requests
// that might be directed to the miniport.
// Comment out any that are not supported by this driver.
*/
static const NDIS_OID g_SupportedOidArray[] =
{
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_CURRENT_LOOKAHEAD,

    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_MEDIUM_SUBTYPE,

    OID_WAN_GET_INFO,
    OID_WAN_SET_LINK_INFO,
    OID_WAN_GET_LINK_INFO,

#if defined(NDIS50_MINIPORT)
    OID_WAN_LINE_COUNT,

    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
#endif // NDIS50_MINIPORT

    0
};

#if DBG

/*
// Make sure the following list is in the same order as the list above!
*/
static char *g_SupportedOidNames[] =
{
    "OID_GEN_SUPPORTED_LIST",
    "OID_GEN_HARDWARE_STATUS",
    "OID_GEN_MEDIA_SUPPORTED",
    "OID_GEN_MEDIA_IN_USE",
    "OID_GEN_MAXIMUM_LOOKAHEAD",
    "OID_GEN_MAC_OPTIONS",
    "OID_GEN_VENDOR_ID",
    "OID_GEN_VENDOR_DESCRIPTION",
    "OID_GEN_DRIVER_VERSION",
    "OID_GEN_CURRENT_LOOKAHEAD",

    "OID_WAN_PERMANENT_ADDRESS",
    "OID_WAN_CURRENT_ADDRESS",
    "OID_WAN_MEDIUM_SUBTYPE",

    "OID_WAN_GET_INFO",
    "OID_WAN_SET_LINK_INFO",
    "OID_WAN_GET_LINK_INFO",

#if defined(NDIS50_MINIPORT)
    "OID_WAN_LINE_COUNT",

    "OID_PNP_CAPABILITIES",
    "OID_PNP_SET_POWER",
    "OID_PNP_QUERY_POWER",
#endif // NDIS50_MINIPORT

    "OID_UNKNOWN"
};

#define NUM_OID_ENTRIES (sizeof(g_SupportedOidArray) / sizeof(g_SupportedOidArray[0]))

/*
// This debug routine will lookup the printable name for the selected OID.
*/
static char * DbgGetOidString(NDIS_OID Oid)
{
    UINT i;

    for (i = 0; i < NUM_OID_ENTRIES-1; i++)
    {
        if (g_SupportedOidArray[i] == Oid)
        {
            break;
        }
    }
    return(g_SupportedOidNames[i]);
}

#endif // DBG

/*
// Returned from an OID_WAN_PERMANENT_ADDRESS MiniportQueryInformation request.
// The WAN wrapper wants the miniport to return a unique address for this
// adapter.  This is used as an ethernet address presented to the protocols.
// The least significant bit of the first byte must not be a 1, or it could
// be interpreted as an ethernet multicast address.  If the vendor has an
// assigned ethernet vendor code (the first 3 bytes), they should be used
// to assure that the address does not conflict with another vendor's address.
// The last digit is replaced during the call with the adapter instance number.
*/
static UCHAR        g_PermanentWanAddress[6] = VER_VENDOR_ID;

/*
// Returned from an OID_GEN_VENDOR_ID MiniportQueryInformation request.
// Again, the vendor's assigned ethernet vendor code should be used if possible.
*/
static UCHAR        g_Vendor3ByteID[4] = VER_VENDOR_ID;

/*
// Returned from an OID_GEN_VENDOR_DESCRIPTION MiniportQueryInformation request.
// This is an arbitrary string which may be used by upper layers to present
// a user friendly description of the adapter.
*/
static NDIS_STRING  g_VendorDescriptionString = INIT_STRING_CONST(VER_PRODUCT_NAME_STR);


/* @doc INTERNAL Request Request_c MiniportQueryInformation


@func

    <f MiniportQueryInformation> is a required function that
    returns information about the capabilities and status of
    the driver and/or its NIC.

@comm

    NDIS calls the <f MiniportQueryInformation> function either
    on its own behalf, such as to determine which options the
    driver supports or to manage binding-specific information
    for the miniport, or when a bound protocol driver calls
    <f NdisRequest>.

    NDIS makes one or more calls to <f MiniportQueryInformation>
    just after a driver's <f MiniportInitialize> function returns
    NDIS_STATUS_SUCCESS. NDIS supplies the following OIDs in
    its initialization-time calls to the driver's
    <f MiniportQueryInformation> function:

    <f OID_GEN_MAXIMUM_LOOKAHEAD><nl>
        <f MiniportQueryInformation> must return how many bytes of lookahead
        data the NIC can provide, that is, the initial transfer capacity
        of the NIC.<nl>
        Even if a driver supports multipacket receives and, therefore,
        will indicate an array of pointers to fully set up packets,
        MiniportQueryInformation must supply this information. Such a
        driver should return the maximum packet size it can indicate.

    <f OID_GEN_MAC_OPTIONS><nl>
        <f MiniportQueryInformation> must return a bitmask set with the
        appropriate NDIS_MAC_OPTION_XXX flags indicating which options
        it (or its NIC) supports, or it can return zero at InformationBuffer
        if the driver supports none of the options designated by these flags.
        For example, a NIC driver always sets the
        NDIS_MAC_OPTION_NO_LOOPBACK flag if its NIC has no
        internal hardware support for loopback. This tells
        NDIS to manage loopback for the driver, which cannot
        provide software loopback code as efficient as the NDIS
        library's because NDIS manages all binding-specific
        information for miniports. Any miniport that tries to provide
        software loopback must check the destination address of every
        send packet against the currently set filter addresses to
        determine whether to loop back each packet. WAN NIC drivers
        must set this flag.

    If the NIC driver sets the NDIS_MAC_OPTION_FULL_DUPLEX flag,
    the NDIS library serializes calls to the MiniportSendPackets
    or <f MiniportWanSend> function separately from its serialized
    calls to other MiniportXxx functions in SMP machines. However,
    NDIS returns incoming send packets to protocols while such a
    driver's <f MiniportReset> function is executing: that is, NDIS
    never calls a full-duplex miniport to transmit a packet until
    its reset operation is completed. The designer of any full-duplex
    driver can expect that driver to achieve significantly higher
    performance in SMP machines, but the driver must synchronize
    its accesses to shared resources carefully to prevent race
    conditions or deadlocks from occurring. NDIS assumes that
    all intermediate drivers are full-duplex drivers.

    Depending on the NdisMediumXxx that <f MiniportInitialize> selected,
    NDIS submits additional intialization-time requests to
    <f MiniportQueryInformation>, such as the following:

    <f OID_XXX_CURRENT_ADDRESS><nl>
        If the driver's <f MiniportInitialize> function selected an NdisMediumXxx
        for which the system supplies a filter, NDIS calls
        <f MiniportQueryInformation> to return the NIC's current
        address in medium-specific format. For FDDI drivers, NDIS
        requests both long and short current addresses.

    <f OID_802_3_MAXIMUM_LIST_SIZE><nl>
        For Ethernet drivers, NDIS requests the multicast list size.

    <f OID_FDDI_LONG>/<f SHORT_MAX_LIST_SIZE><nl>
        For FDDI drivers, NDIS requests the multicast list sizes.

    If possible, <f MiniportQueryInformation> should not return
    <f NDIS_STATUS_PENDING> for initialization-time requests.
    Until NDIS has sufficient information to set up bindings
    to the miniport, such requests should be handled synchronously.

    If the Miniport does not complete the call immediately (by returning
    <f NDIS_STATUS_PENDING>), it must call NdisMQueryInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesWritten, and BytesNeeded until the request
    completes.

    No other requests will be submitted to the Miniport until
    this request has been completed.

    <f Note>: that the wrapper will intercept all queries of the following OIDs:
        OID_GEN_CURRENT_PACKET_FILTER,
        OID_GEN_PROTOCOL_OPTIONS,
        OID_802_5_CURRENT_FUNCTIONAL,
        OID_802_3_MULTICAST_LIST,
        OID_FDDI_LONG_MULTICAST_LIST,
        OID_FDDI_SHORT_MULTICAST_LIST.

    <f Note>: Interrupts will be in any state when called.

@rdesc

    <f MiniportQueryInformation> can return one of the following:

    @flag NDIS_STATUS_SUCCESS |
        <f MiniportQueryInformation> returned the requested information at
        InformationBuffer and set the variable at BytesWritten to the amount
        of information it returned.

    @flag NDIS_STATUS_PENDING |
        The driver will complete the request asynchronously with a call to
        NdisMQueryInformationComplete when it has gathered the requested
        information.

    @flag NDIS_STATUS_INVALID_OID |
        <f MiniportQueryInformation> does not recognize the Oid.

    @flag NDIS_STATUS_INVALID_LENGTH |
        The InformationBufferLength does not match the length required
        by the given Oid. <f MiniportQueryInformation> returned how many
        bytes the buffer should be at BytesNeeded.

    @flag NDIS_STATUS_NOT_ACCEPTED |
        <f MiniportQueryInformation> attempted to gather the requested
        information from the NIC but was unsuccessful.

    @flag NDIS_STATUS_NOT_SUPPORTED |
        <f MiniportQueryInformation> does not support the Oid, which
        is optional.

    @flag NDIS_STATUS_RESOURCES |
        <f MiniportQueryInformation> could not allocate sufficient
        resources to return the requested information. This return
        value does not necessarily mean that the same request,
        submitted at a later time, will be failed for the same
        reason.

@xref

    <f MiniportInitialize>
    <f MiniportSetInformation>


*/

NDIS_STATUS MiniportQueryInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN NDIS_OID                 Oid,                        // @parm
    // The OID.  (See section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs.)

    IN PVOID                    InformationBuffer,          // @parm
    // The buffer that will receive the information. (See section 7.4 of the
    // NDIS 3.0 specification for a description of the length required for
    // each OID.)

    IN ULONG                    InformationBufferLength,    // @parm
    // The length in bytes of InformationBuffer.

    OUT PULONG                  BytesWritten,               // @parm
    // Returns the number of bytes written into InformationBuffer.

    OUT PULONG                  BytesNeeded                 // @parm
    // Returns the number of additional bytes needed to satisfy the OID.
    )
{
    DBG_FUNC("MiniportQueryInformation")

    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    // Holds the status result returned by this function.

    PVOID                       SourceBuffer;
    // Pointer to driver data to be copied back to caller's InformationBuffer

    ULONG                       SourceBufferLength;
    // Number of bytes to be copied from driver.

    ULONG                       GenericULong = 0;
    // Most return values are long integers, so this is used to hold the
    // return value of a constant or computed result.

    UCHAR                       VendorId[4];
    // Used to store vendor ID string.

#if defined(NDIS50_MINIPORT)
    NDIS_PNP_CAPABILITIES       PnpCapabilities;
    // Used to return our PNP capabilities.
#endif // NDIS50_MINIPORT

    /*
    // If this is a TAPI OID, pass it on over.
    */
    if ((Oid & 0xFFFFFF00L) == (OID_TAPI_ACCEPT & 0xFFFFFF00L))
    {
        Status = TspiRequestHandler(pAdapter,
                        Oid,
                        InformationBuffer,
                        InformationBufferLength,
                        BytesWritten,
                        BytesNeeded
                        );
        return (Status);
    }

    DBG_ENTER(pAdapter);
    DBG_REQUEST(pAdapter,
              ("(OID=0x%08X %s)\n\t\tInfoLength=%d InfoBuffer=0x%X\n",
               Oid, DbgGetOidString(Oid),
               InformationBufferLength,
               InformationBuffer
              ));

    /*
    // Initialize these once, since this is the majority of cases.
    */
    SourceBuffer = &GenericULong;
    SourceBufferLength = sizeof(ULONG);

    /*
    // Determine which OID is being requested and do the right thing.
    // Refer to section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs and their return values.
    */
    switch (Oid)
    {
    case OID_GEN_SUPPORTED_LIST:
        /*
        // NDIS wants to know which OID's to pass down to us.
        // So we report back these new IOCTL's in addition to any NDIS OID's.
        */
        SourceBuffer =  (PVOID)g_SupportedOidArray;
        SourceBufferLength = sizeof(g_SupportedOidArray);
        break;

    case OID_GEN_HARDWARE_STATUS:
        GenericULong = NdisHardwareStatusReady;
        break;

    case OID_GEN_MEDIA_SUPPORTED:
        GenericULong = NdisMediumWan;
        break;

    case OID_GEN_MEDIA_IN_USE:
        GenericULong = NdisMediumWan;
        break;

    case OID_GEN_VENDOR_ID:
        NdisMoveMemory((PVOID)VendorId, (PVOID)g_PermanentWanAddress, 3);
        VendorId[3] = 0x0;
        SourceBuffer = &g_PermanentWanAddress[0];
        SourceBufferLength = sizeof(VendorId);
        break;

    case OID_GEN_VENDOR_DESCRIPTION:
        SourceBuffer = (PUCHAR) g_VendorDescriptionString.Buffer;
        SourceBufferLength = g_VendorDescriptionString.MaximumLength;
        break;

    case OID_GEN_MAXIMUM_LOOKAHEAD:
        GenericULong = CARD_MAX_LOOKAHEAD;
        break;

    case OID_GEN_CURRENT_LOOKAHEAD:
        GenericULong = CARD_MAX_LOOKAHEAD;
        break;

    case OID_GEN_MAC_OPTIONS:
        GenericULong = NDIS_MAC_OPTION_RECEIVE_SERIALIZED |
                       NDIS_MAC_OPTION_NO_LOOPBACK |
                       NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
        break;

    case OID_WAN_PERMANENT_ADDRESS:
    case OID_WAN_CURRENT_ADDRESS:
        g_PermanentWanAddress[5] = (UCHAR) ((pAdapter->ObjectID & 0xFF) + '0');
        SourceBuffer = g_PermanentWanAddress;
        SourceBufferLength = sizeof(g_PermanentWanAddress);
        break;

    case OID_WAN_MEDIUM_SUBTYPE:
        GenericULong = NdisWanMediumIsdn;
        break;

    case OID_WAN_GET_INFO:
        SourceBuffer = &pAdapter->WanInfo;
        SourceBufferLength = sizeof(NDIS_WAN_INFO);
        break;

    case OID_WAN_GET_LINK_INFO:
        {
            PNDIS_WAN_GET_LINK_INFO pGetWanLinkInfo;

            PBCHANNEL_OBJECT        pBChannel;
            // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

            /*
            // The InformationBuffer really points to a NDIS_WAN_GET_LINK_INFO
            // which contains a pointer to one of our BCHANNEL_OBJECT's in the
            // NdisLinkHandle field.
            */
            pGetWanLinkInfo = (PNDIS_WAN_GET_LINK_INFO)InformationBuffer;
            pBChannel = (PBCHANNEL_OBJECT) pGetWanLinkInfo->NdisLinkHandle;

            /*
            // Make sure what I just said is true.
            */
            if (!IS_VALID_BCHANNEL(pAdapter, pBChannel))
            {
                SourceBufferLength = 0;
                Status = NDIS_STATUS_INVALID_DATA;
                break;
            }

            DBG_PARAMS(pAdapter,
                        ("Returning:\n"
                        "NdisLinkHandle   = %08lX\n"
                        "MaxSendFrameSize = %08lX\n"
                        "MaxRecvFrameSize = %08lX\n"
                        "SendFramingBits  = %08lX\n"
                        "RecvFramingBits  = %08lX\n"
                        "SendACCM         = %08lX\n"
                        "RecvACCM         = %08lX\n",
                        pBChannel->WanLinkInfo.NdisLinkHandle,
                        pBChannel->WanLinkInfo.MaxSendFrameSize ,
                        pBChannel->WanLinkInfo.MaxRecvFrameSize ,
                        pBChannel->WanLinkInfo.SendFramingBits  ,
                        pBChannel->WanLinkInfo.RecvFramingBits  ,
                        pBChannel->WanLinkInfo.SendACCM         ,
                        pBChannel->WanLinkInfo.RecvACCM         ));

            SourceBuffer = &(pBChannel->WanLinkInfo);
            SourceBufferLength = sizeof(NDIS_WAN_GET_LINK_INFO);
        }
        break;

#if defined(NDIS50_MINIPORT)
    case OID_WAN_LINE_COUNT:
        GenericULong = pAdapter->NumBChannels;
        break;

    case OID_PNP_CAPABILITIES:
        // The sample just returns success for all PM events even though we
        // don't really do anything with them.
        PnpCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp =
                                               NdisDeviceStateUnspecified;
        PnpCapabilities.WakeUpCapabilities.MinPatternWakeUp =
                                               NdisDeviceStateUnspecified;
        PnpCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp =
                                                NdisDeviceStateUnspecified;
        SourceBuffer = &PnpCapabilities;
        SourceBufferLength = sizeof(PnpCapabilities);
        break;

    case OID_PNP_QUERY_POWER:
        // The sample just returns success for all PM events even though we
        // don't really do anything with them.
        break;
#endif // NDIS50_MINIPORT

    default:
        /*
        // Unknown OID
        */
        Status = NDIS_STATUS_INVALID_OID;
        SourceBufferLength = 0;
        DBG_WARNING(pAdapter,("UNSUPPORTED Oid=0x%08x\n", Oid));
        break;
    }

    /*
    // Now we copy the data into the caller's buffer if there's enough room,
    // otherwise, we report the error and tell em how much we need.
    */
    if (SourceBufferLength > InformationBufferLength)
    {
        *BytesNeeded = SourceBufferLength;
        *BytesWritten = 0;
        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else if (SourceBufferLength)
    {
        NdisMoveMemory(InformationBuffer,
                       SourceBuffer,
                       SourceBufferLength
                      );
        *BytesNeeded = *BytesWritten = SourceBufferLength;
    }
    else
    {
        *BytesNeeded = *BytesWritten = 0;
    }
    DBG_REQUEST(pAdapter,
              ("RETURN: Status=0x%X Needed=%d Written=%d\n",
               Status, *BytesNeeded, *BytesWritten));

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Request Request_c MiniportSetInformation


@func

    <f MiniportSetInformation> is a required function that allows
    bound protocol drivers (or NDIS) to request changes in the
    state information that the miniport maintains for
    particular OIDs, such as changes in multicast addresses.

@comm

    NDIS calls <f MiniportSetInformation> either on its own
    behalf, such as to manage bindings to the miniport, or
    when a bound protocol driver calls <f NdisRequest>.

    If <f MiniportSetInformation> returns NDIS_STATUS_PENDING, the
    driver must complete the request later by calling
    NdisMSetInformationComplete. Until it completes any request,
    the miniport can safely access the memory at InformationBuffer,
    BytesRead, and BytesNeeded. After the miniport completes any set
    request, ownership of these variables and the buffer reverts to
    NDIS or the caller of <f NdisRequest>, whichever allocated the memory.

    No other requests will be submitted to the WAN driver until the
    current set request is complete. If the WAN driver does not complete
    the call immediately (by returning NDIS_STATUS_PENDING), it must call
    NdisMSetInformationComplete to complete the call.

    Any of the settable NDIS global OIDs can be used, although a WAN
    miniport cannot set the <f NDIS_MAC_OPTION_FULL_DUPLEX> flag in
    response to an <f OID_GEN_MAC_OPTIONS> request. The following
    WAN-specific OID is passed to MiniportSetInformation.

    <f OID_WAN_SET_LINK_INFO><nl>
        This OID is used to set the link characteristics.
        The parameters in the structure passed for this OID
        are described previously for OID_WAN_GET_LINK_INFO.

    For more information about the system-defined OIDs, see Part 2 of the
    Network Drivers Network Reference document.

    <f MiniportSetInformation> can be pre-empted by an interrupt.

    By default, <f MiniportSetInformation> runs at IRQL DISPATCH_LEVEL.

    Calls to MiniportSetInformation changes information maintained by
    the miniport. This function definition and operation is the same
    as in a LAN miniport NIC driver except that certain WAN-specific
    OIDs must be recognized.



@rdesc

    <f MiniportSetInformation> can return one of the following:

    @flag NDIS_STATUS_SUCCESS |
        MiniportSetInformation used the data at InformationBuffer to
        set itself or its NIC to the state required by the given Oid,
        and it set the variable at BytesRead to the amount of supplied
        data it used.

    @flag NDIS_STATUS_PENDING |
        The driver will complete the request asynchronously with a call
        to NdisMSetInformationComplete when it has set itself or its NIC
        to the state requested.

    @flag NDIS_STATUS_INVALID_OID |
        MiniportSetInformation did not recognize the Oid.

    @flag NDIS_STATUS_INVALID_LENGTH |
        The InformationBufferLength does not match the length required
        by the given Oid. MiniportSetInformation returned how many bytes
        the buffer should be at BytesNeeded.

    @flag NDIS_STATUS_INVALID_DATA |
        The data supplied at InformationBuffer was invalid for the given Oid.

    @flag NDIS_STATUS_NOT_ACCEPTED |
        MiniportSetInformation attempted the requested set operation on
        the NIC but was unsuccessful.

    @flag NDIS_STATUS_NOT_SUPPORTED |
        MiniportSetInformation does not support the Oid, which is optional.

    @flag NDIS_STATUS_RESOURCES |
        MiniportSetInformation could not carry out the requested operation
        due to resource constraints. This return value does not necessarily
        mean that the same request, submitted at a later time, will be
        failed for the same reason.

@xref

    <f MiniportInitialize>
    <f MiniportQueryInformation>

*/

NDIS_STATUS MiniportSetInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN NDIS_OID                 Oid,                        // @parm
    // The OID.  (See section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs.)

    IN PVOID                    InformationBuffer,          // @parm
    // The buffer that will receive the information. (See section 7.4 of the
    // NDIS 3.0 specification for a description of the length required for
    // each OID.)

    IN ULONG                    InformationBufferLength,    // @parm
    // The length in bytes of InformationBuffer.

    OUT PULONG                  BytesRead,                  // @parm
    // Returns the number of bytes read from InformationBuffer.

    OUT PULONG                  BytesNeeded                 // @parm
    // Returns the number of additional bytes needed to satisfy the OID.
    )
{
    DBG_FUNC("MiniportSetInformation")

    NDIS_STATUS                 Status;
    // Holds the status result returned by this function.

    /*
    // If this is a TAPI OID, pass it on over.
    */
    if ((Oid & 0xFFFFFF00L) == (OID_TAPI_ACCEPT & 0xFFFFFF00L))
    {
        Status = TspiRequestHandler(pAdapter,
                        Oid,
                        InformationBuffer,
                        InformationBufferLength,
                        BytesRead,
                        BytesNeeded
                        );
        return (Status);
    }

    DBG_ENTER(pAdapter);
    DBG_REQUEST(pAdapter,
              ("(OID=0x%08X %s)\n\t\tInfoLength=%d InfoBuffer=0x%X\n",
               Oid, DbgGetOidString(Oid),
               InformationBufferLength,
               InformationBuffer
              ));

    /*
    // Assume no extra bytes are needed.
    */
    ASSERT(BytesRead && BytesNeeded);
    *BytesRead = 0;
    *BytesNeeded = 0;

    /*
    // Determine which OID is being requested and do the right thing.
    */
    switch (Oid)
    {
    case OID_GEN_CURRENT_LOOKAHEAD:
        /*
        // WAN drivers always indicate the entire packet regardless of the
        // lookahead size.  So this request should be politely ignored.
        */
        DBG_NOTICE(pAdapter,("OID_GEN_CURRENT_LOOKAHEAD: set=%d expected=%d\n",
                    *(PULONG) InformationBuffer, CARD_MAX_LOOKAHEAD));
        ASSERT(InformationBufferLength == sizeof(ULONG));
        *BytesNeeded = *BytesRead = sizeof(ULONG);
        Status = NDIS_STATUS_SUCCESS;
        break;

    case OID_WAN_SET_LINK_INFO:

        if (InformationBufferLength == sizeof(NDIS_WAN_SET_LINK_INFO))
        {
            PNDIS_WAN_SET_LINK_INFO pSetWanLinkInfo;

            PBCHANNEL_OBJECT        pBChannel;
            // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

            /*
            // The InformationBuffer really points to a NDIS_WAN_SET_LINK_INFO
            // which contains a pointer to one of our BCHANNEL_OBJECT's in the
            // NdisLinkHandle field.
            */
            pSetWanLinkInfo = (PNDIS_WAN_SET_LINK_INFO)InformationBuffer;
            pBChannel = (PBCHANNEL_OBJECT) pSetWanLinkInfo->NdisLinkHandle;

            /*
            // Make sure what I just said is true.
            */
            if (!IS_VALID_BCHANNEL(pAdapter, pBChannel))
            {
                Status = NDIS_STATUS_INVALID_DATA;
                break;
            }

            ASSERT(pBChannel->WanLinkInfo.NdisLinkHandle == pBChannel);
            ASSERT(!(pBChannel->WanLinkInfo.SendFramingBits & ~pAdapter->WanInfo.FramingBits));
            ASSERT(!(pBChannel->WanLinkInfo.RecvFramingBits & ~pAdapter->WanInfo.FramingBits));

            /*
            // Copy the data into our WanLinkInfo sturcture.
            */
            NdisMoveMemory(&(pBChannel->WanLinkInfo),
                           InformationBuffer,
                           InformationBufferLength
                          );
            *BytesRead = sizeof(NDIS_WAN_SET_LINK_INFO);
            Status = NDIS_STATUS_SUCCESS;

            if (pBChannel->WanLinkInfo.MaxSendFrameSize != pAdapter->WanInfo.MaxFrameSize ||
                pBChannel->WanLinkInfo.MaxRecvFrameSize != pAdapter->WanInfo.MaxFrameSize)
            {
                DBG_NOTICE(pAdapter,("Line=%d - "
                            "NdisLinkHandle=%08lX - "
                            "SendFrameSize=%08lX - "
                            "RecvFrameSize=%08lX\n",
                            pBChannel->BChannelIndex,
                            pBChannel->WanLinkInfo.NdisLinkHandle,
                            pBChannel->WanLinkInfo.MaxSendFrameSize,
                            pBChannel->WanLinkInfo.MaxRecvFrameSize));
            }

            DBG_PARAMS(pAdapter,
                       ("\n                   setting    expected\n"
                        "NdisLinkHandle   = %08lX=?=%08lX\n"
                        "MaxSendFrameSize = %08lX=?=%08lX\n"
                        "MaxRecvFrameSize = %08lX=?=%08lX\n"
                        "SendFramingBits  = %08lX=?=%08lX\n"
                        "RecvFramingBits  = %08lX=?=%08lX\n"
                        "SendACCM         = %08lX=?=%08lX\n"
                        "RecvACCM         = %08lX=?=%08lX\n",
                        pBChannel->WanLinkInfo.NdisLinkHandle   , pBChannel,
                        pBChannel->WanLinkInfo.MaxSendFrameSize , pAdapter->WanInfo.MaxFrameSize,
                        pBChannel->WanLinkInfo.MaxRecvFrameSize , pAdapter->WanInfo.MaxFrameSize,
                        pBChannel->WanLinkInfo.SendFramingBits  , pAdapter->WanInfo.FramingBits,
                        pBChannel->WanLinkInfo.RecvFramingBits  , pAdapter->WanInfo.FramingBits,
                        pBChannel->WanLinkInfo.SendACCM         , pAdapter->WanInfo.DesiredACCM,
                        pBChannel->WanLinkInfo.RecvACCM         , pAdapter->WanInfo.DesiredACCM));
        }
        else
        {
            DBG_WARNING(pAdapter, ("OID_WAN_SET_LINK_INFO: Invalid size:%d expected:%d\n",
                        InformationBufferLength, sizeof(NDIS_WAN_SET_LINK_INFO)));
            Status = NDIS_STATUS_INVALID_LENGTH;
        }
        *BytesNeeded = sizeof(NDIS_WAN_SET_LINK_INFO);
        break;

#if defined(NDIS50_MINIPORT)
    case OID_PNP_SET_POWER:
        // The sample just returns success for all PM events even though we
        // don't really do anything with them.
        break;
#endif // NDIS50_MINIPORT

    default:
        /*
        // Unknown OID
        */
        Status = NDIS_STATUS_INVALID_OID;
        DBG_WARNING(pAdapter,("UNSUPPORTED Oid=0x%08x\n", Oid));
        break;
    }
    DBG_REQUEST(pAdapter,
              ("RETURN: Status=0x%X Needed=%d Read=%d\n",
               Status, *BytesNeeded, *BytesRead));

    DBG_RETURN(pAdapter, Status);
    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tpiparam.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiParam TpiParam_c

@module TpiParam.c |

    This module, along with <f TpiParam\.h>, implements a table driven parser
    for the NDIS registry parameters.

@comm

    See <f Keywords\.h> for details of how to add new parameters.<nl>

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiParam_c

@end

*/

#define  __FILEID__     TPI_MODULE_PARAMS   // Unique file ID for error logging

#include <ndis.h>
#include "TpiDebug.h"
#include "TpiParam.h"

#if defined(_VXD_) && !defined(NDIS_LCODE)
#  define NDIS_LCODE code_seg("_LTEXT", "LCODE")
#  define NDIS_LDATA data_seg("_LDATA", "LCODE")
#endif

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif

static NDIS_PHYSICAL_ADDRESS    g_HighestAcceptableAddress =
                                    NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);

static NDIS_STRING              g_NullString =
                                    NDIS_STRING_CONST("\0");


/* @doc INTERNAL TpiParam TpiParam_c ustrlen


@func

    <f ustrlen> counts the number of characters in
    a UNICODE (wide) string.

@comm

@rdesc

    <f ustrlen> returns the length of the UNICODE string
    pointed to by <p string>.  The terminating NULL character is not
    counted.

*/
USHORT ustrlen(
    IN PUSHORT                  string                      // @parm
    // Pointer to the beginning of a UNICODE string ending
    // with a 0x0000 value.
    )
{
    USHORT                      ct;

    for (ct = 0; *string != 0x0000; string++, ct++)
        ;

    return(ct);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamUnicodeStringToAnsiString


@func

    <f ParamUnicodeStringToAnsiString> converts a double byte string to a
    single byte string.

@comm

    The original release of the NDIS Wrapper for Windows 95 and 3.1 does not
    return UNICODE strings from the NdisReadConfiguration routine.  So this
    routine attempts to auto detect this situation by examining the first
    character of the string.  If the second byte of the first character is
    a zero, the string is assumed to be UNICODE, and it is converted to an
    ANSI string; otherwise the ANSI string is just copied.
    <nl>
    <f Note>: This also assumes that the first character of any UNICODE
    string will not use the second byte (i.e. not an extended character).
    This routine will only successfully convert non-extended character
    strings anyway.

@xref
    <f ParamParseRegistry>
*/

VOID ParamUnicodeStringToAnsiString(
    OUT PANSI_STRING            out,                        // @parm
    // A pointer to where the converted ANSI string is to be stored.

    IN PUNICODE_STRING          in                          // @parm
    // A pointer to the UNICODE string to be converted.
    )
{
    DBG_FUNC("ParamUnicodeStringToAnsiString")

    UINT Index;

    /* CAVEAT - NDIS_BUG
    // NDIS driver for Windows 95 does not return UNICODE from
    // registry parser, so we need to kludge it up here.
    */
    if (in->Length > 1)
    {
        if (((PUCHAR)(in->Buffer))[1] == 0)
        {
            /*
            // Probably a UNICODE string since all our parameters are ASCII
            // strings.
            */
            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("UNICODE STRING IN @%x#%d='%ls'\n",
                       in->Buffer, in->Length, in->Buffer));
            for (Index = 0; Index < (in->Length / sizeof(WCHAR)) &&
                 Index < out->MaximumLength; Index++)
            {
                out->Buffer[Index] = (UCHAR) in->Buffer[Index];
            }
        }
        else
        {
            /*
            // Probably an ANSI string since all our parameters are more
            // than 1 byte long and should not be zero in the second byte.
            */
            PANSI_STRING in2 = (PANSI_STRING) in;

            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("ANSI STRING IN @%x#%d='%s'\n",
                       in2->Buffer, in2->Length, in2->Buffer));

            for (Index = 0; Index < in2->Length &&
                 Index < out->MaximumLength; Index++)
            {
                out->Buffer[Index] = in2->Buffer[Index];
            }
        }
    }
    else
    {
        DBG_WARNING(DbgInfo,("1 BYTE STRING IN @%x=%04x\n",
                    in->Buffer, in->Buffer[0]));
        out->Buffer[0] = (UCHAR) in->Buffer[0];
        Index = 1;
    }
    out->Length = (USHORT) Index; // * sizeof(UCHAR);

    // NULL terminate the string if there's room.
    if (out->Length <= (out->MaximumLength - sizeof(UCHAR)))
    {
        out->Buffer[Index] = 0;
    }
    ASSERT(out->Length <= out->MaximumLength);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamUnicodeCopyString


@func

    <f ParamUnicodeCopyString> copies a double byte string to a double byte
    string.

@comm

    The original release of the NDIS Wrapper for Windows 95 and 3.1 does not
    return UNICODE strings from the NdisReadConfiguration routine.  So this
    routine attempts to auto detect this situation by examining the first
    character of the string.  If the second byte of the first character is
    a zero, the string is assumed to be UNICODE, and it just copied;
    otherwise the ANSI string is converted to UNICODE.
    <nl>
    <f Note>: This also assumes that the first character of any UNICODE
    string will not use the second byte (i.e. not an extended character).
    This routine will only successfully convert non-extended character
    strings anyway.

@xref
    <f ParamParseRegistry>

*/

VOID ParamUnicodeCopyString(
    OUT PUNICODE_STRING         out,                        // @parm
    // A pointer to where the new UNICODE string is to be stored.

    IN PUNICODE_STRING          in                          // @parm
    // A pointer to the UNICODE string to be copied.
    )
{
    DBG_FUNC("ParamUnicodeCopyString")

    UINT Index;

    /* CAVEAT - NDIS_BUG
    // NDIS driver for Windows 95 does not return UNICODE from
    // registry parser, so we need to kludge it up here.
    */
    if (in->Length > 1)
    {
        if (((PUCHAR)(in->Buffer))[1] == 0)
        {
            /*
            // Probably a UNICODE string since all our parameters are ASCII
            // strings.
            */
            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("UNICODE STRING IN @%x#%d='%ls'\n",
                       in->Buffer, in->Length, in->Buffer));
            for (Index = 0; Index < (in->Length / sizeof(WCHAR)) &&
                 Index < (out->MaximumLength / sizeof(WCHAR)); Index++)
            {
                out->Buffer[Index] = in->Buffer[Index];
            }
        }
        else
        {
            /*
            // Probably an ANSI string since all our parameters are more
            // than 1 byte long and should not be zero in the second byte.
            */
            PANSI_STRING in2 = (PANSI_STRING) in;

            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("ANSI STRING IN @%x#%d='%s'\n",
                       in2->Buffer, in2->Length, in2->Buffer));
            for (Index = 0; Index < in2->Length &&
                 Index < (out->MaximumLength / sizeof(WCHAR)); Index++)
            {
                out->Buffer[Index] = (WCHAR) in2->Buffer[Index];
            }
        }
    }
    else
    {
        DBG_WARNING(DbgInfo,("1 BYTE STRING IN @%x=%04x\n",
                    in->Buffer, in->Buffer[0]));
        out->Buffer[0] = (WCHAR) in->Buffer[0];
        Index = 1;
    }
    out->Length = Index * sizeof(WCHAR);

    // NULL terminate the string if there's room.
    if (out->Length <= (out->MaximumLength - sizeof(WCHAR)))
    {
        out->Buffer[Index] = 0;
    }
    ASSERT(out->Length <= out->MaximumLength);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamGetNumEntries


@func

    <f ParamGetNumEntries> counts the number of records in the registry
    parameter table.

@rdesc

    <f ParamGetNumEntries> returns the number of entries in the parameter
    table.

@xref
    <f ParamParseRegistry>

*/

DBG_STATIC UINT ParamGetNumEntries(
    IN PPARAM_TABLE             Parameters                  // @parm
    // A pointer to an array of registry parameter records.
    )
{
    UINT NumRecs = 0;

    /*
    // Scan the parameter array until we find an entry with zero length name.
    */
    if (Parameters)
    {
        while (Parameters->RegVarName.Length)
        {
            NumRecs++;
            Parameters++;
        }
    }
    return(NumRecs);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamParseRegistry


@func

    <f ParamParseRegistry> parses the registry parameter table and attempts
    to read a value from the registry for each parameter record.

@rdesc

    <f ParamParseRegistry> returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE

@xref
    <f MiniportInitialize>
    <f ParamGetNumEntries>
    <f NdisOpenConfiguration>
    <f NdisWriteErrorLogEntry>
    <f NdisReadConfiguration>
    <f NdisCloseConfiguration>
    <f NdisAllocateMemory>
    <f NdisZeroMemory>
    <f ParamUnicodeStringToAnsiString>
    <f ParamUnicodeCopyString>
*/

NDIS_STATUS ParamParseRegistry(
    IN NDIS_HANDLE              AdapterHandle,              // @parm
    // Handle to pass to NdisWriteErrorLogEntry if any errors are encountered.

    IN NDIS_HANDLE              WrapperConfigurationContext,// @parm
    // Handle to pass to NdisOpenConfiguration.

    IN PUCHAR                   BaseContext,                // @parm
    // References the base of the structure where the values read from the
    // registry are written.  Typically, this will be a pointer to the first
    // byte of the adapter information structure.

    IN PPARAM_TABLE             Parameters                  // @parm
    // A pointer to an array of registry parameter records <t PARAM_TABLE>.
    )
{
    DBG_FUNC("ParamParseRegistry")

    PNDIS_CONFIGURATION_PARAMETER   pReturnedValue;
    NDIS_CONFIGURATION_PARAMETER    ReturnedValue;
    NDIS_PARAMETER_TYPE             ParamType;

    /*
    // The handle for reading from the registry.
    */
    NDIS_HANDLE     ConfigHandle;

    UINT            NumRecs = ParamGetNumEntries(Parameters);
    UINT            i;
    PPARAM_TABLE    pParameter;
    NDIS_STATUS     Status;
    UINT            Value;
    PANSI_STRING    pAnsi;
    UINT            Length;

    /*
    // Open the configuration registry so we can get our config values.
    */
    NdisOpenConfiguration(
            &Status,
            &ConfigHandle,
            WrapperConfigurationContext
            );

    if (Status != NDIS_STATUS_SUCCESS)
    {
        /*
        // Log error message and exit.
        */
        DBG_ERROR(DbgInfo,("NdisOpenConfiguration failed (Status=%X)\n",Status));

        NdisWriteErrorLogEntry(
                AdapterHandle,
                NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                3,
                Status,
                __FILEID__,
                __LINE__
                );
        return NDIS_STATUS_FAILURE;
    }

    /*
    // Walk through all the parameters in the table.
    */
    for (i = 0, pParameter = Parameters; i < NumRecs; i++, pParameter++)
    {
#if DBG
        ANSI_STRING ansiRegString;
        char        ansiRegName[64];

        /*
        // Get a printable parameter name.
        */
        ansiRegString.Length = 0;
        ansiRegString.MaximumLength = sizeof(ansiRegName);
        ansiRegString.Buffer = (PCHAR)ansiRegName;
        NdisZeroMemory(ansiRegName, sizeof(ansiRegName));
        ParamUnicodeStringToAnsiString(
                &ansiRegString,
                (PUNICODE_STRING)&pParameter->RegVarName
                );
#endif // DBG

        ASSERT(pParameter->Type <= (UINT) NdisParameterMultiString);

        /*
        // Attempt to read the parameter value from the registry.
        */
        ParamType = (NDIS_PARAMETER_TYPE) pParameter->Type;
        NdisReadConfiguration(&Status,
                              &pReturnedValue,
                              ConfigHandle,
                              &pParameter->RegVarName,
                              ParamType
                             );
        /*
        // If value is not present, and it is mandatory, return failure code.
        */
        if (Status != NDIS_STATUS_SUCCESS && pParameter->Mandantory)
        {
            /*
            // Log error message and exit.
            */
            DBG_ERROR(DbgInfo,("%s: NOT IN REGISTRY!\n",
                      ansiRegName));

            NdisWriteErrorLogEntry(
                    AdapterHandle,
                    NDIS_ERROR_CODE_MISSING_CONFIGURATION_PARAMETER,
                    4,
                    i,
                    Status,
                    __FILEID__,
                    __LINE__
                    );

            NdisCloseConfiguration(ConfigHandle);
            return NDIS_STATUS_FAILURE;
        }

        /*
        // Determine how the caller wants to interpret this parameter.
        */
        if (ParamType == NdisParameterInteger ||
            ParamType == NdisParameterHexInteger)
        {
            ASSERT(pParameter->Size <= sizeof(ULONG));

            /*
            // If value read, use it, otherwise use default.
            */
            if (Status == NDIS_STATUS_SUCCESS)
            {
                Value = pReturnedValue->ParameterData.IntegerData;
            }
            else
            {
                Value = (UINT) (LONG_PTR)(pParameter->Default);
            }

            /*
            // If there are min/max boundaries, verify that value is in range.
            */
            if (pParameter->Min || pParameter->Max)
            {
                if (Value < pParameter->Min)
                {
                    DBG_ERROR(DbgInfo,("%s: Value=%X < Min=%X\n",
                              ansiRegName, Value, pParameter->Min));
                    Value = pParameter->Min;
                }
                else if (Value > pParameter->Max)
                {
                    DBG_ERROR(DbgInfo,("%s: Value=%X > Max=%X\n",
                              ansiRegName, Value, pParameter->Max));
                    Value = pParameter->Max;
                }
            }

            /*
            // Size of destination in bytes 1, 2, or 4 (default==INT).
            */
            switch (pParameter->Size)
            {
            case 0:
                *(PUINT)(BaseContext+pParameter->Offset)   = (UINT) Value;
                break;

            case 1:
                if (Value & 0xFFFFFF00)
                {
                    DBG_WARNING(DbgInfo,("%s: OVERFLOWS UCHAR\n",
                                ansiRegName));
                }
                *(PUCHAR)(BaseContext+pParameter->Offset)  = (UCHAR) Value;
                break;

            case 2:
                if (Value & 0xFFFF0000)
                {
                    DBG_WARNING(DbgInfo,("%s: OVERFLOWS USHORT\n",
                                ansiRegName));
                }
                *(PUSHORT)(BaseContext+pParameter->Offset) = (USHORT) Value;
                break;

            case 4:
                *(PULONG)(BaseContext+pParameter->Offset)  = (ULONG) Value;
                break;

            default:
                DBG_ERROR(DbgInfo,("%s: Invalid ParamSize=%d\n",
                          ansiRegName, pParameter->Size));
                NdisCloseConfiguration(ConfigHandle);
                return NDIS_STATUS_FAILURE;
                break;
            }

            if (ParamType == NdisParameterInteger)
            {
                DBG_PARAMS(DbgInfo,("%s: Value=%d Size=%d (%s)\n",
                           ansiRegName, Value, pParameter->Size,
                           (Status == NDIS_STATUS_SUCCESS) ?
                           "Registry" : "Default"));
            }
            else
            {
                DBG_PARAMS(DbgInfo,("%s: Value=0x%X Size=%d (%s)\n",
                           ansiRegName, Value, pParameter->Size,
                           (Status == NDIS_STATUS_SUCCESS) ?
                           "Registry" : "Default"));
            }
        }
        else if (ParamType == NdisParameterString ||
                 ParamType == NdisParameterMultiString)
        {
            ASSERT(pParameter->Size == sizeof(ANSI_STRING));

            /*
            // If value not read from registry.
            */
            if (Status != NDIS_STATUS_SUCCESS)
            {
                /*
                // Use our own temporary ReturnedValue.
                */
                pReturnedValue = &ReturnedValue;
                pReturnedValue->ParameterType = ParamType;

                /*
                // If default non-zero, use default value.
                */
                if (pParameter->Default != 0)
                {
                    NdisMoveMemory(&pReturnedValue->ParameterData.StringData,
                                   (PANSI_STRING) pParameter->Default,
                                   sizeof(ANSI_STRING));
                }
                else
                {
                    /*
                    // Otherwise, use null string value.
                    */
                    NdisMoveMemory(&pReturnedValue->ParameterData.StringData,
                                   &g_NullString,
                                   sizeof(g_NullString));
                }
            }

            /*
            // Assume the string is ANSI and points to the string data
            // structure.  We can get away with this because ANSI and
            // UNICODE strings have a common structure header.  An extra
            // character is allocated to make room for a null terminator.
            */
            pAnsi = (PANSI_STRING) (BaseContext+pParameter->Offset);
            Length = pReturnedValue->ParameterData.StringData.Length+1;

            /*
            // The caller wants a UNICODE string returned, we have to
            // allocated twice as many bytes to hold the result.
            // NOTE:
            // This wouldn't be necessary if NDIS would always return
            // a UNICODE string, but some Win95 versions of NDIS return
            // an ANSI string, so Length will be too small for UNICODE.
            // The down-side is that we may allocate twice as much as
            // we need to hold the string.  (oh well)
            */
            if (pParameter->Flags == PARAM_FLAGS_UNICODESTRING)
            {
                Length *= sizeof(WCHAR);
            }

            /*
            // Allocate memory for the string.
            */
#if !defined(NDIS50_MINIPORT)
            Status = NdisAllocateMemory(
                            (PVOID *) &(pAnsi->Buffer),
                            Length,
                            0,
                            g_HighestAcceptableAddress
                            );
#else  // NDIS50_MINIPORT
            Status = NdisAllocateMemoryWithTag(
                            (PVOID *) &(pAnsi->Buffer),
                            Length,
                            __FILEID__
                            );
#endif // NDIS50_MINIPORT

            if (Status != NDIS_STATUS_SUCCESS)
            {
                /*
                // Log error message and exit.
                */
                DBG_ERROR(DbgInfo,("NdisAllocateMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                          Length, __FILE__, __LINE__, Status));

                NdisWriteErrorLogEntry(
                        AdapterHandle,
                        NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                        4,
                        Status,
                        Length,
                        __FILEID__,
                        __LINE__
                        );
                NdisCloseConfiguration(ConfigHandle);
                return NDIS_STATUS_FAILURE;
            }
            else
            {
                DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                           ("NdisAllocateMemory(Size=%d, Ptr=0x%x)\n",
                            Length, pAnsi->Buffer));
            }
            /*
            // Zero the string buffer to start with.
            */
            ASSERT(pAnsi->Buffer);
            NdisZeroMemory(pAnsi->Buffer, Length);
            pAnsi->MaximumLength = (USHORT) Length;

            if (pParameter->Flags == PARAM_FLAGS_ANSISTRING)
            {
                /*
                // The caller wants an ANSI string returned, so we convert
                // it from UNICODE to ANSI.
                */
                ParamUnicodeStringToAnsiString(
                        pAnsi,
                        (PUNICODE_STRING) &(pReturnedValue->ParameterData.StringData)
                        );
#if DBG
                if (ParamType == NdisParameterMultiString)
                    {
                    USHORT        ct = 0;

                    while (ct < pAnsi->Length)
                        {
                        DBG_PARAMS(DbgInfo,("%s: ANSI='%s' Len=%d of %d\n",
                            ansiRegName,
                            &(pAnsi->Buffer[ct]),
                            (strlen(&(pAnsi->Buffer[ct]))),
                            pAnsi->Length));

                        ct = ct + (strlen(&(pAnsi->Buffer[ct])) + 1);
                        }
                    }
                else
                    {
                    DBG_PARAMS(DbgInfo,("%s: ANSI='%s' Len=%d\n",
                           ansiRegName, pAnsi->Buffer, pAnsi->Length));
                    }
#endif
            }
            else // PARAM_FLAGS_UNICODESTRING
            {
                /*
                // The caller wants a UNICODE string returned, so we can
                // just copy it.  The pAnsi buffer was allocated large
                // enough to hold the UNICODE string.
                */
                ParamUnicodeCopyString(
                        (PUNICODE_STRING) pAnsi,
                        (PUNICODE_STRING) &(pReturnedValue->ParameterData.StringData)
                        );
#if DBG
                if (ParamType == NdisParameterMultiString)
                    {
                    USHORT        ct = 0;

                    BREAKPOINT;

                    while (ct < (pAnsi->Length / 2))
                        {
                        DBG_PARAMS(DbgInfo,("%s: UNICODE='%ls' Len=%d of %d\n",
                           ansiRegName,
                           &((PUSHORT)pAnsi->Buffer)[ct],
                           (ustrlen(&((PUSHORT)pAnsi->Buffer)[ct]) * 2),
                           pAnsi->Length));

                        ct = ct + (ustrlen(&((PUSHORT)pAnsi->Buffer)[ct]) + 1);
                        }
                    }
                else
                    {
                    DBG_PARAMS(DbgInfo,("%s: UNICODE='%ls' Len=%d\n",
                               ansiRegName, pAnsi->Buffer, pAnsi->Length));
                    }
#endif

            }
        }
        else
        {
            /*
            // Report a bogus parameter type in the caller's table.
            */
            DBG_ERROR(DbgInfo,("Invalid ParamType=%d '%s'\n",
                      ParamType, ansiRegName));

            NdisCloseConfiguration(ConfigHandle);
            return NDIS_STATUS_FAILURE;
        }
    }
    NdisCloseConfiguration(ConfigHandle);
    return(NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\receive.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Receive Receive_c

@module Receive.c |

    This module implements the Miniport packet receive routines.  Basically,
    the asynchronous receive processing routine.  This module is very
    dependent on the hardware/firmware interface and should be looked at
    whenever changes to these interfaces occur.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Receive_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.4 Receiving Packets General |

    A WAN miniport calls NdisMWanIndicateReceive to indicate that a
    packet has arrived and that the entire packet (there is no lookahead)
    is available for inspection. When this call is made, NDISWAN indicates
    the arrival of the packet to the ProtocolReceive handlers of bound
    higher-level drivers.

    <f Note>: Since the entire packet is always passed up, the miniport driver will
    never receive a transfer-data call (the data is copied by NDISWAN and
    then passed up to the next higher driver). The entire packet is always
    passed up due to compression and encryption that might have been applied
    to the packet. Also, because the link is point-to-point, at least one
    bound protocol will always want to look at the packet.

    The data contained in the header is the same as that received on the
    NIC. The NIC driver will not remove any headers or trailers from the
    data it receives. The transmitting driver cannot add padding to the
    packet.

    A WAN miniport calls NdisMWanIndicateReceiveComplete to indicate the
    end of one or more receive indications so that protocols can postprocess
    received packets. As a result, NDISWAN calls the ProtocolReceiveComplete
    handler(s) of bound protocols to notifying each protocol that it can
    now process the received data. In its receive-complete handler, a
    protocol need not operate under the severe time constraints that it
    does in its receive handler.

    The protocol should assume that interrupts are enabled during the
    call to ProtocolReceiveComplete. In an SMP machine, the receive
    handler and the receive complete handler can be running concurrently
    on different processors.

    Note that a WAN driver need not deliver NdisMWanIndicateReceiveComplete
    indications in one-to-one correspondence with NdisMWanIndicateReceive
    indications. It can issue a single receive-complete indication
    after several receive indications have occurred. For example, a
    WAN miniport could call NdisMWanIndicateReceiveComplete from its
    receive handler every ten packets or before exiting the handler,
    whichever occurs first.

@topic 3.5 Receiving Packets Specific |

    Packets are recevied asynchronously by the Miniport from the driver's
    BChannel services as a stream of raw HDLC frames.  See the Sending
    Packets section for details on the frame format.

    When a call is connected, the Miniport pre-loads the driver receive queue
    with the number of buffers defined by the registry parameter
    <p ReceiveBuffersPerLink>.

    When the driver has read an HDLC frame from the associated BChannel, it calls
    the Miniport routine <f BChannelEventHandler> with <t BREASON_RECEIVE_DONE>.
    The Miniport then calls <f CardNotifyReceive> which de-queues the buffer
    from the link's <p ReceivePendingList> and places it on the adapter's
    <p ReceiveCompleteList>.  <f CardNotifyReceive> then schedules the routine
    <f MiniportTimer> to be called as soon as it is safe to process the
    event (i.e. the Miniport can be re-entered).

    When <f MiniportTimer> runs, it calls <f ReceivePacketHandler> to
    process ALL the packets on the <p ReceiveCompleteList>.  Each packet is
    dequeued and passed up to <f NdisMWanIndicateReceive>.  After the packet
    is copied by the WAN wrapper, the buffer is then reset and posted back to
    the driver so it can be used to receive another frame.

    After all packets have been processed by the <f ReceivePacketHandler>,
    before leaving <f MiniportTimer>, <f NdisMWanIndicateReceiveComplete>
    is called so the WAN wrapper can do its post-processing.

@end
*/

#define  __FILEID__             RECEIVE_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Receive Receive_c ReceivePacketHandler


@func

    <f ReceivePacketHandler> is called from <f MiniportTimer> to handle
    a packet receive event.  We enter here with interrupts enabled on
    the adapter and the processor, but the NDIS Wrapper holds a spin lock
    since we are executing on an NDIS timer thread.

@comm

    We loop in here until all the available incoming packets have been passed
    up to the protocol stack.  As we find each good packet, it is passed up
    to the protocol stack using <f NdisMWanIndicateReceive>.  When NDIS
    returns control from this call, we resubmit the packet to the adapter
    so it can be used to receive another incoming packet.  The link flag
    <p NeedReceiveCompleteIndication> is set TRUE if any packets are received
    on a particular link.  This is used later, before returning from the
    async event handler, to notify NDIS of any ReceiveCompleteIndications.

*/

void ReceivePacketHandler(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    IN PUCHAR                   ReceiveBuffer,              // @parm
    // Pointer to first byte received.

    IN ULONG                    BytesReceived               // @parm
    // Number of bytes received.
    )
{
    DBG_FUNC("ReceivePacketHandler")

    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (++(pAdapter->NestedDataHandler) > 1)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d > 1\n",
                  pAdapter->NestedDataHandler));
    }

    /*
    // Is there someone up there who cares?
    */
    if (pBChannel->NdisLinkContext == NULL)
    {
        DBG_WARNING(pAdapter, ("Packet recvd on disconnected line #%d\n",pBChannel->BChannelIndex));
    }
#ifdef NDISWAN_BUG // NDISWAN is sometimes setting this to zero - ignore it!
    /*
    // Return if we were told to expect nothing.
    */
    else if (pBChannel->WanLinkInfo.MaxRecvFrameSize == 0)
    {
        DBG_WARNING(pAdapter,("Packet size=%d > %d\n",
                    BytesReceived, pBChannel->WanLinkInfo.MaxRecvFrameSize));
    }
#endif // NDISWAN_BUG
    else
    {
        pAdapter->TotalRxBytes += BytesReceived;
        pAdapter->TotalRxPackets++;

        /*
        // We have to accept the frame if possible, I just want to know
        // if somebody has lied to us...
        */
        if (BytesReceived > pBChannel->WanLinkInfo.MaxRecvFrameSize)
        {
            DBG_NOTICE(pAdapter,("Packet size=%d > %d\n",
                       BytesReceived, pBChannel->WanLinkInfo.MaxRecvFrameSize));
        }
        DBG_RX(pAdapter, pBChannel->BChannelIndex,
               BytesReceived, ReceiveBuffer);

        /*
        // Indiciate the packet up to the protocol stack.
        */
        NdisMWanIndicateReceive(
                &Status,
                pAdapter->MiniportAdapterHandle,
                pBChannel->NdisLinkContext,
                ReceiveBuffer,
                BytesReceived
                );

        if (Status == NDIS_STATUS_SUCCESS)
        {
            pBChannel->NeedReceiveCompleteIndication = TRUE;
        }
        else
        {
            DBG_WARNING(pAdapter,("NdisMWanIndicateReceive returned error 0x%X\n",
                        Status));
        }
    }

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (--(pAdapter->NestedDataHandler) < 0)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d < 0\n",
                  pAdapter->NestedDataHandler));
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tpiparam.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiParam TpiParam_h

@module TpiParam.h |

    This module, along with <f TpiParam\.c>, implements a table driven parser
    for the NDIS registry parameters.  This file defines the parameter
    parsing structures and values used by the routine <f ParamParseRegistry>.
    You should #include this file into the driver module defining the
    configuration parameter table <t PARAM_TABLE>.

@comm

    See <f Keywords\.h> for details of how to add new parameters.

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiParam_h

@end

*/

#ifndef _TPIPARAM_H
#define _TPIPARAM_H

#if !defined(NDIS_NT) && !defined(UNICODE_NULL)

/*
// These types were culled from the NT ndis.h file
// We should be compiling with the NT DDK's ndis.h to get these,
// but sometimes we need to compile with the 95 DDK ndis.h.
*/

#undef PUNICODE_STRING
typedef USHORT  WCHAR;
typedef WCHAR   *PWSTR;

typedef STRING  ANSI_STRING;
typedef PSTRING PANSI_STRING;

/*
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
*/

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;

typedef UNICODE_STRING *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

#endif // NDIS_NT

/* @doc INTERNAL TpiParam TpiParam_h PARAM_ENTRY


@func <t PARAM_TABLE> | PARAM_ENTRY |

    This macro is used to define an entry in the registry parameter table,
    one entry per parameter.  See <t PARAM_TABLE> for more details on the
    expected input values.

@parm struct | Strct | The structure type associated with <f Field>.

@parm type | Field | The name of the field within the structure <f Strct>.

@parm const char * | Name | The name of the registry parameter key.

@parm BOOL | Required | True if parameter is required.

@parm NDIS_PARAMETER_TYPE | Type | The kind of parameter value.

@parm UCHAR | Flags | How to return a string parameter value (ANSI, UNICODE).

@parm UINT | Default | The default value for an undefined integer parameter.

@parm UINT | Min | The minimum value for an integer parameter.

@parm UINT | Max | The minimum value for an integer parameter.

@comm
    Parameters that need to be stored in different data structures, need to
    be declared in separate parameter tables, and then parsed separately
    using mulitple calls to <f ParamParseRegistry>.

@iex
    PARAM_TABLE ParameterTable[] =
    {
        PARAM_ENTRY(MINIPORT_CONTEXT, DbgFlags, PARAM_DEBUGFLAGS_STRING,
                    FALSE, NdisParameterHexInteger, 0,
                    DBG_ERROR_ON|DBG_WARNING_ON, 0, 0xffffffff),
        // The last entry must be an empty string!
        { { 0 } }
    };

@normal
*/
#if defined(_IA64_)
# define PARAM_OFFSET(Strct, Field) ((LONG)(LONG_PTR)&(((Strct *)0)->Field))
#else
# define PARAM_OFFSET(Strct, Field) ((UINT)((PUCHAR) &((Strct *) 0)->Field))
#endif
#define PARAM_SIZEOF(Strct, Field) sizeof(((Strct *) 0)->Field)
#define PARAM_ENTRY(Strct, Field, Name, \
                    Required, Type, Flags, \
                    Default, Min, Max) \
    { NDIS_STRING_CONST(Name), \
      Required, \
      Type, \
      Flags, \
      PARAM_SIZEOF(Strct, Field), \
      PARAM_OFFSET(Strct, Field), \
      (PVOID) (Default), \
      Min, \
      Max }


/* @doc INTERNAL TpiParam TpiParam_h PARAM_TABLE


@struct PARAM_TABLE |
    This structure defines how a parameter is to be parsed from the Windows
    registry.  The driver declares an array of these parameter records and
    passes it to <f ParamParseRegistry> during initialization.  The values
    for each parameter are then read from the registry and can be used to
    configure the driver.
    <nl>
    <f Note>: Multiple parameter tables can be used to parse parameters that
    must be stored in different memory locations.
*/
typedef struct PARAM_TABLE
{
    NDIS_STRING     RegVarName; // @field
    // Parameter name string declared as an <t NDIS_STRING>.  The registry
    // parameter key must match this string.

    UCHAR           Mandantory; // @field
    // Set to FALSE, zero, if parameter value is optional; otherwise set to
    // TRUE, non-zero, if the parameter is required to exist in the registry.
    // If FALSE, and the parameter does not exist, the <y Default> value will
    // be returned.  If TRUE, and the parameter does not exist, an error code
    // is returned and no further parsing is done.

    UCHAR           Type;       // @field
    // This value determines how the parameter will be parsed from the
    // registry.  The value can be one of the following values defined
    // by <t NDIS_PARAMETER_TYPE>.
    // <nl>0=NdisParameterInteger - Decimal integer value.
    // <nl>1=NdisParameterHexInteger - Hexadecimal integer value.
    // <nl>2=NdisParameterString - Single UNICODE string value.
    // <nl>3=NdisParameterMultiString - Multiple UNICODE string values.
    // These are returned as a list of N strings, separated by NULL
    // terminators, the last string is followed by two NULL terminators.

    UCHAR           Flags;      // @field
    // This value determines how a string parameter will be translated before
    // it is returned to the caller.  <f Flags> can be one of the following
    // values:
    // <nl>0=PARAM_FLAGS_ANSISTRING - Return string value as an ANSI string.
    // <nl>0=PARAM_FLAGS_ANSISTRING - Return string value as a UNICODE string.
#   define          PARAM_FLAGS_ANSISTRING      0
#   define          PARAM_FLAGS_UNICODESTRING   1

    UCHAR           Size;       // @field
    // This value determines how an integer parameter will be translated
    // before it is returned to the caller.  <f Size> can be one of the
    // following values:
    // <nl>0=UINT   - unsigned integer (16 or 32 bits).
    // <nl>1=UCHAR  - unsigned char integer (8 bits).
    // <nl>2=USHORT - unsigned short integer (16 bits).
    // <nl>4=ULONG  - unsigned long integer (32 bits).
    // <f Note>: The most-significant bits will be truncated in the conversion.

    UINT            Offset;     // @field
    // This value indicates the offset, in bytes, from the <f BaseContext>
    // pointer passed into <f ParamParseRegistry>.  The return value for
    // the parameter will be saved at this offset from <f BaseContext>.
    // <nl>*(PUINT)((PUCHAR)BaseContext+Offset) = (UINT) Value;

    PVOID           Default;    // @field
    // This value is used as the default value for the parameter if it is
    // not found in the registry, and it is not mandatory.  This only applys
    // to integer parameters.  String parameters must provide support for
    // their own default values.

    UINT            Min;        // @field
    // If this value is non-zero, and the parameter is an integer type, the
    // registry value will be compared to make sure it is \>= <f Min>.
    // If the registry value is less, the returned value will be set to
    // <f Min> and no error is returned.

    UINT            Max;        // @field
    // If this value is non-zero, and the parameter is an integer type, the
    // registry value will be compared to make sure it is \<= <f Max>.
    // If the registry value is greater, the returned value will be set to
    // <f Max> and no error is returned.

    UINT            Reserved;   // @field
    // This field is not currently used, and it must be zero for future
    // compatability.

} PARAM_TABLE, *PPARAM_TABLE;

extern USHORT ustrlen(
    IN PUSHORT          string
    );

extern NDIS_STATUS ParamParseRegistry(
    IN NDIS_HANDLE      AdapterHandle,
    IN NDIS_HANDLE      RegistryConfigHandle,
    IN PUCHAR           BaseContext,
    IN PPARAM_TABLE     Parameters
    );

extern VOID ParamUnicodeStringToAnsiString(
    OUT PANSI_STRING out,
    IN PUNICODE_STRING in
    );

extern VOID ParamUnicodeCopyString(
    OUT PUNICODE_STRING out,
    IN PUNICODE_STRING in
    );

#endif // _TPIPARAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tspi.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Tspi Tspi_h

@module Tspi.h |

    This module defines the interface to the <t TAPILINE_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Tspi_h

@end

*/

#ifndef _TSPI_H
#define _TSPI_H

#define TSPI_OBJECT_TYPE                ((ULONG)'T')+\
                                        ((ULONG)'S'<<8)+\
                                        ((ULONG)'P'<<16)+\
                                        ((ULONG)'I'<<24)

#define TSPIDEV_OBJECT_TYPE             ((ULONG)'T')+\
                                        ((ULONG)'S'<<8)+\
                                        ((ULONG)'P'<<16)+\
                                        ((ULONG)'D'<<24)

#define TSPILINE_OBJECT_TYPE            ((ULONG)'T')+\
                                        ((ULONG)'S'<<8)+\
                                        ((ULONG)'P'<<16)+\
                                        ((ULONG)'L'<<24)

#define TSPIADDR_OBJECT_TYPE            ((ULONG)'T')+\
                                        ((ULONG)'S'<<8)+\
                                        ((ULONG)'P'<<16)+\
                                        ((ULONG)'A'<<24)

#define TSPICALL_OBJECT_TYPE            ((ULONG)'T')+\
                                        ((ULONG)'S'<<8)+\
                                        ((ULONG)'P'<<16)+\
                                        ((ULONG)'C'<<24)

/*
// There is only one TAPI address ID per line device (zero based).
*/
#define TSPI_NUM_ADDRESSES              1
#define TSPI_ADDRESS_ID                 0

/*
// The following constants are used by the TSPI to determine the DeviceClass.
*/
#define TAPI_DEVICECLASS_NAME       "tapi/line"
#define TAPI_DEVICECLASS_ID         1
#define NDIS_DEVICECLASS_NAME       "ndis"
#define NDIS_DEVICECLASS_ID         2


/* @doc INTERNAL Tspi Tspi_h TAPI_DEVICE_ID


@struct TAPI_DEVICE_ID |

    This structure is defined by the Win32 TAPI extensions for the "ndis"
    device class.

    The ndis device class consists of devices that can be associated with
    network driver interface specification (NDIS) media access control (MAC)
    drivers to support network communications. You access these devices by
    using functions.

    The lineGetID and phoneGetID functions fill a VARSTRING structure,
    setting the dwStringFormat member to the STRINGFORMAT_BINARY value and
    appending these additional members.

@iex

    HANDLE  hDevice;          // NDIS connection identifier
    CHAR    szDeviceType[1];  // name of device

@comm

    The hDevice member is the identifier to pass to a MAC, such as the
    asynchronous MAC for dial-up networking, to associate a network
    connection with the call/modem connection. The szDeviceType member is a
    null-terminated ASCII string specifying the name of the device associated
    with the identifier. For more information, see documentation about
    writing NDIS MAC drivers for use with dial-up networking.

*/

typedef struct TAPI_DEVICE_ID
{
    ULONG   hDevice;                                // @field
    // The NDIS Connection Wrapper identifier <p ConnectionWrapperID>.

    UCHAR   DeviceName[sizeof(VER_DEFAULT_MEDIATYPE)];    // @field
    // Name of device (e.g. "isdn", "x25", or "framerelay" )

} TAPI_DEVICE_ID, *PTAPI_DEVICE_ID;

/*


    Function prototypes.

*/

BOOLEAN STR_EQU(
    IN PCHAR                    s1,
    IN PCHAR                    s2,
    IN int                      len
    );

NDIS_STATUS TspiRequestHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_OID                 Oid,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength,
    OUT PULONG                  BytesUsed,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiConfigDialog(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CONFIG_DIALOG Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetAddressCaps(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_CAPS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetAddressID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetAddressStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetCallAddressID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_ADDRESS_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetCallInfo(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_INFO Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetCallStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetDevCaps(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_DEV_CAPS  Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetDevConfig(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_DEV_CONFIG Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiGetLineDevStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_LINE_DEV_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiMakeCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_MAKE_CALL     Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiOpen(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_OPEN          Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiProviderInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_PROVIDER_INITIALIZE Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiAccept(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_ACCEPT Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiAnswer(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_ANSWER        Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiClose(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CLOSE         Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiCloseCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CLOSE_CALL    Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiConditionalMediaDetection(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiDrop(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_DROP          Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiProviderShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_PROVIDER_SHUTDOWN Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetAppSpecific(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_APP_SPECIFIC Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetCallParams(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_CALL_PARAMS Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetDefaultMediaDetection(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetDevConfig(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_DEV_CONFIG Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetMediaMode(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_MEDIA_MODE Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS TspiSetStatusMessages(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_STATUS_MESSAGES Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

VOID TspiAddressStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN ULONG                    AddressState
    );

VOID TspiCallStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN ULONG                    CallState,
    IN ULONG                    StateParam
    );

VOID TspiLineDevStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN ULONG                    LineDevState
    );

VOID TspiResetHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

VOID TspiCallTimerHandler(
    IN PVOID                    SystemSpecific1,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PVOID                    SystemSpecific2,
    IN PVOID                    SystemSpecific3
    );

#endif // _TSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tspidev.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TspiDev TspiDev_c

@module TspiDev.c |

    This module implements the Telephony Service Provider Interface for
    TapiDevice objects.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TspiDev_c

@end

*/

#define  __FILEID__             TSPIDEV_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "string.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL TspiDev TspiDev_c TspiGetDevCaps


@func

    This request queries a specified line device to determine its telephony
    capabilities. The returned information is valid for all addresses on the
    line device.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_DEV_CAPS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_DEV_CAPS
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulExtVersion;
        OUT LINE_DEV_CAPS   LineDevCaps;

    } NDIS_TAPI_GET_DEV_CAPS, *PNDIS_TAPI_GET_DEV_CAPS;

    typedef struct _LINE_DEV_CAPS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulProviderInfoSize;
        ULONG   ulProviderInfoOffset;

        ULONG   ulSwitchInfoSize;
        ULONG   ulSwitchInfoOffset;

        ULONG   ulPermanentLineID;
        ULONG   ulLineNameSize;
        ULONG   ulLineNameOffset;
        ULONG   ulStringFormat;

        ULONG   ulAddressModes;
        ULONG   ulNumAddresses;
        ULONG   ulBearerModes;
        ULONG   ulMaxRate;
        ULONG   ulMediaModes;

        ULONG   ulGenerateToneModes;
        ULONG   ulGenerateToneMaxNumFreq;
        ULONG   ulGenerateDigitModes;
        ULONG   ulMonitorToneMaxNumFreq;
        ULONG   ulMonitorToneMaxNumEntries;
        ULONG   ulMonitorDigitModes;
        ULONG   ulGatherDigitsMinTimeout;
        ULONG   ulGatherDigitsMaxTimeout;

        ULONG   ulMedCtlDigitMaxListSize;
        ULONG   ulMedCtlMediaMaxListSize;
        ULONG   ulMedCtlToneMaxListSize;
        ULONG   ulMedCtlCallStateMaxListSize;

        ULONG   ulDevCapFlags;
        ULONG   ulMaxNumActiveCalls;
        ULONG   ulAnswerMode;
        ULONG   ulRingModes;
        ULONG   ulLineStates;

        ULONG   ulUUIAcceptSize;
        ULONG   ulUUIAnswerSize;
        ULONG   ulUUIMakeCallSize;
        ULONG   ulUUIDropSize;
        ULONG   ulUUISendUserUserInfoSize;
        ULONG   ulUUICallInfoSize;

        LINE_DIAL_PARAMS    MinDialParams;
        LINE_DIAL_PARAMS    MaxDialParams;
        LINE_DIAL_PARAMS    DefaultDialParams;

        ULONG   ulNumTerminals;
        ULONG   ulTerminalCapsSize;
        ULONG   ulTerminalCapsOffset;
        ULONG   ulTerminalTextEntrySize;
        ULONG   ulTerminalTextSize;
        ULONG   ulTerminalTextOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_DEV_CAPS, *PLINE_DEV_CAPS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_NODEVICE

*/

NDIS_STATUS TspiGetDevCaps(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_DEV_CAPS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetDevCaps")

    static UCHAR                LineDeviceName[] = VER_DEVICE_STR " Line 00";
    static UCHAR                LineSwitchName[] = VER_DEVICE_STR " Switch";

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    UINT                        InfoOffset;
    // Offset from the start of the Request buffer to the various information
    // fields we fill in and return to the caller.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceID=%d\n"
               "\tulExtVersion=0x%X\n"
               "\tLineDevCaps=0x%X\n",
               Request->ulDeviceID,
               Request->ulExtVersion,
               &Request->LineDevCaps
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_DEVICEID(pAdapter, Request->ulDeviceID);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODEVICE\n"));
        return (NDIS_STATUS_TAPI_NODEVICE);
    }

    Request->LineDevCaps.ulNeededSize =
    Request->LineDevCaps.ulUsedSize = sizeof(Request->LineDevCaps);

    /*
    // The driver numbers lines sequentially from 1, so this will always
    // be the same number.
    */
    Request->LineDevCaps.ulPermanentLineID = pBChannel->BChannelIndex+1;

    /*
    // All the strings are ASCII format rather than UNICODE.
    */
    Request->LineDevCaps.ulStringFormat = STRINGFORMAT_ASCII;

    /*
    // Report the capabilities of this device.
    */
    Request->LineDevCaps.ulAddressModes = LINEADDRESSMODE_ADDRESSID;
    Request->LineDevCaps.ulNumAddresses = 1;
    Request->LineDevCaps.ulBearerModes  = pBChannel->BearerModesCaps;
    Request->LineDevCaps.ulMaxRate      = pBChannel->LinkSpeed;
    Request->LineDevCaps.ulMediaModes   = pBChannel->MediaModesCaps;

    /*
    // Each line on the PRI only supports a single call.
    */
    Request->LineDevCaps.ulDevCapFlags = LINEDEVCAPFLAGS_CLOSEDROP;
    Request->LineDevCaps.ulMaxNumActiveCalls = 1;
    Request->LineDevCaps.ulAnswerMode = LINEANSWERMODE_DROP;
    Request->LineDevCaps.ulRingModes  = 1;
    Request->LineDevCaps.ulLineStates = pBChannel->DevStatesCaps;

    /*
    // RASTAPI requires the "MediaType\0DeviceName" be placed in the
    // ProviderInfo field at the end of this structure.
    */
    InfoOffset = sizeof(Request->LineDevCaps);
    Request->LineDevCaps.ulNeededSize += pAdapter->ProviderInfoSize;
    *BytesNeeded += pAdapter->ProviderInfoSize;
    if (Request->LineDevCaps.ulNeededSize <= Request->LineDevCaps.ulTotalSize)
    {
        Request->LineDevCaps.ulProviderInfoSize   = pAdapter->ProviderInfoSize;
        Request->LineDevCaps.ulProviderInfoOffset = InfoOffset;
        NdisMoveMemory((PUCHAR) &Request->LineDevCaps + InfoOffset,
                pAdapter->ProviderInfo,
                pAdapter->ProviderInfoSize
                );
        Request->LineDevCaps.ulUsedSize += pAdapter->ProviderInfoSize;
        InfoOffset += pAdapter->ProviderInfoSize;
    }

    /*
    // LineName is displayed by the Dialup Networking App.
    // UniModem TSP returns the modem name here.
    // We'll return the name of the line.
    */
    Request->LineDevCaps.ulNeededSize += sizeof(LineDeviceName);
    *BytesNeeded += sizeof(LineDeviceName);
    if (Request->LineDevCaps.ulNeededSize <= Request->LineDevCaps.ulTotalSize)
    {
        // FIXME - This code only handles 99 lines!
        LineDeviceName[sizeof(LineDeviceName)-3] = '0' +
                        (UCHAR) Request->LineDevCaps.ulPermanentLineID / 10;
        LineDeviceName[sizeof(LineDeviceName)-2] = '0' +
                        (UCHAR) Request->LineDevCaps.ulPermanentLineID % 10;

        Request->LineDevCaps.ulLineNameSize   = sizeof(LineDeviceName);
        Request->LineDevCaps.ulLineNameOffset = InfoOffset;
        NdisMoveMemory((PUCHAR) &Request->LineDevCaps + InfoOffset,
                LineDeviceName,
                sizeof(LineDeviceName)
                );
        Request->LineDevCaps.ulUsedSize += sizeof(LineDeviceName);
        InfoOffset += sizeof(LineDeviceName);
    }

    /*
    // SwitchName is not yet displayed by the Dialup Networking App,
    // but we'll return something reasonable just in case.
    */
    Request->LineDevCaps.ulNeededSize += sizeof(LineSwitchName);
    *BytesNeeded += sizeof(LineSwitchName);
    if (Request->LineDevCaps.ulNeededSize <= Request->LineDevCaps.ulTotalSize)
    {
        Request->LineDevCaps.ulSwitchInfoSize   = sizeof(LineSwitchName);
        Request->LineDevCaps.ulSwitchInfoOffset = InfoOffset;
        NdisMoveMemory((PUCHAR) &Request->LineDevCaps + InfoOffset,
                LineSwitchName,
                sizeof(LineSwitchName)
                );
        Request->LineDevCaps.ulUsedSize += sizeof(LineSwitchName);
        InfoOffset += sizeof(LineSwitchName);
    }
    else
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineDevCaps.ulTotalSize,
                   Request->LineDevCaps.ulNeededSize));
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiDev TspiDev_c TspiGetDevConfig


@func

    This request returns a data structure object, the contents of which are
    specific to the line (miniport) and device class, giving the current
    configuration of a device associated one-to-one with the line device.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_DEV_CONFIG | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_DEV_CONFIG
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulDeviceClassSize;
        IN  ULONG       ulDeviceClassOffset;
        OUT VAR_STRING  DeviceConfig;

    } NDIS_TAPI_GET_DEV_CONFIG, *PNDIS_TAPI_GET_DEV_CONFIG;

    typedef struct _VAR_STRING
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulStringFormat;
        ULONG   ulStringSize;
        ULONG   ulStringOffset;

    } VAR_STRING, *PVAR_STRING;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALDEVICECLASS
    NDIS_STATUS_TAPI_NODEVICE

*/

NDIS_STATUS TspiGetDevConfig(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_DEV_CONFIG Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetDevConfig")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    UINT                        DeviceClass;
    // Remember which device class is being requested.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceID=%d\n"
               "\tulDeviceClassSize=%d\n"
               "\tulDeviceClassOffset=0x%X = '%s'\n",
               Request->ulDeviceID,
               Request->ulDeviceClassSize,
               Request->ulDeviceClassOffset,
               ((PCHAR) Request + Request->ulDeviceClassOffset)
              ));
    /*
    // Make sure this is a tapi/line or ndis request.
    */
    if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  NDIS_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = NDIS_DEVICECLASS_ID;
    }
    else if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  TAPI_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = TAPI_DEVICECLASS_ID;
    }
    else
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALDEVICECLASS\n"));
        return (NDIS_STATUS_TAPI_INVALDEVICECLASS);
    }

    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_DEVICEID(pAdapter, Request->ulDeviceID);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODEVICE\n"));
        return (NDIS_STATUS_TAPI_NODEVICE);
    }

    /*
    // Now we need to adjust the variable field to place the requested device
    // configuration.
    */
#   define DEVCONFIG_INFO       "Dummy Configuration Data"
#   define SIZEOF_DEVCONFIG     0 // sizeof(DEVCONFIG_INFO)

    Request->DeviceConfig.ulNeededSize = sizeof(VAR_STRING) + SIZEOF_DEVCONFIG;
    Request->DeviceConfig.ulUsedSize = sizeof(VAR_STRING);

    *BytesNeeded += SIZEOF_DEVCONFIG;
    if (Request->DeviceConfig.ulTotalSize >= Request->DeviceConfig.ulNeededSize)
    {
        Request->DeviceConfig.ulUsedSize     = Request->DeviceConfig.ulNeededSize;
        Request->DeviceConfig.ulStringFormat = STRINGFORMAT_BINARY;
        Request->DeviceConfig.ulStringSize   = SIZEOF_DEVCONFIG;
        Request->DeviceConfig.ulStringOffset = sizeof(VAR_STRING);

        /*
        // There are currently no return values defined for this case.
        // This is just a place holder for future extensions.
        */
        NdisMoveMemory((PUCHAR) &Request->DeviceConfig + sizeof(VAR_STRING),
               DEVCONFIG_INFO,
               SIZEOF_DEVCONFIG
               );
    }
    else
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->DeviceConfig.ulTotalSize,
                   Request->DeviceConfig.ulNeededSize));
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiDev TspiDev_c TspiSetDevConfig


@func

    This request restores the configuration of a device associated one-to-one
    with the line device from an  data structure previously obtained using
    OID_TAPI_GET_DEV_CONFIG.  The contents of this data structure are specific
    to the line (miniport) and device class.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_DEV_CONFIG | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_DEV_CONFIG
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulDeviceClassSize;
        IN  ULONG       ulDeviceClassOffset;
        IN  ULONG       ulDeviceConfigSize;
        IN  UCHAR       DeviceConfig[1];

    } NDIS_TAPI_SET_DEV_CONFIG, *PNDIS_TAPI_SET_DEV_CONFIG;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALDEVICECLASS
    NDIS_STATUS_TAPI_INVALPARAM
    NDIS_STATUS_TAPI_NODEVICE

*/

NDIS_STATUS TspiSetDevConfig(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_DEV_CONFIG Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetDevConfig")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    UINT                        DeviceClass;
    // Remember which device class is being requested.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceID=%d\n"
               "\tulDeviceClassSize=%d\n"
               "\tulDeviceClassOffset=0x%X = '%s'\n"
               "\tulDeviceConfigSize=%d\n",
               Request->ulDeviceID,
               Request->ulDeviceClassSize,
               Request->ulDeviceClassOffset,
               ((PCHAR) Request + Request->ulDeviceClassOffset),
               Request->ulDeviceConfigSize
              ));
    /*
    // Make sure this is a tapi/line or ndis request.
    */
    if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  NDIS_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = NDIS_DEVICECLASS_ID;
    }
    else if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  TAPI_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = TAPI_DEVICECLASS_ID;
    }
    else
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALDEVICECLASS\n"));
        return (NDIS_STATUS_TAPI_INVALDEVICECLASS);
    }

    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_DEVICEID(pAdapter, Request->ulDeviceID);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODEVICE\n"));
        return (NDIS_STATUS_TAPI_NODEVICE);
    }

    /*
    // Make sure this configuration is the proper size.
    */
    if (Request->ulDeviceConfigSize)
    {
        if (Request->ulDeviceConfigSize != SIZEOF_DEVCONFIG)
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALPARAM Size!=%d\n",
                        SIZEOF_DEVCONFIG));
            return (NDIS_STATUS_TAPI_INVALPARAM);
        }

        /*
        // Retore the configuration information returned by TspiGetDevConfig.
        //
        // There are currently no configuration values defined this case.
        // This is just a place holder for future extensions.
        */
        else if (!STR_EQU(Request->DeviceConfig,
                  DEVCONFIG_INFO, SIZEOF_DEVCONFIG))
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALPARAM DevCfg=0x%X\n",
                    *((ULONG *) &Request->DeviceConfig[0]) ));
#if DBG
            DbgPrintData(Request->DeviceConfig, SIZEOF_DEVCONFIG, 0);
#endif // DBG
            // Since we don't use this info, we'll just return success.
            // return (NDIS_STATUS_TAPI_INVALPARAM);
        }
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiDev TspiDev_c TspiGetID


@func

    This request returns a device ID for the specified device class
    associated with the selected line, address or call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_ID | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_ID
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulAddressID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulSelect;
        IN  ULONG       ulDeviceClassSize;
        IN  ULONG       ulDeviceClassOffset;
        OUT VAR_STRING  DeviceID;

    } NDIS_TAPI_GET_ID, *PNDIS_TAPI_GET_ID;

    typedef struct _VAR_STRING
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulStringFormat;
        ULONG   ulStringSize;
        ULONG   ulStringOffset;

    } VAR_STRING, *PVAR_STRING;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALDEVICECLASS
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INVALCALLHANDLE
    NDIS_STATUS_TAPI_OPERATIONUNAVAIL

*/

NDIS_STATUS TspiGetID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetID")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    UINT                        DeviceClass;
    // Remember which device class is being requested.

    /*
    // A pointer to the requested device ID, and its size in bytes.
    */
    PUCHAR                      IDPtr;
    UINT                        IDLength;
    TAPI_DEVICE_ID              DeviceID;

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulAddressID=%d\n"
               "\thdCall=0x%X\n"
               "\tulSelect=0x%X\n"
               "\tulDeviceClassSize=%d\n"
               "\tulDeviceClassOffset=0x%X='%s'\n",
               Request->hdLine,
               Request->ulAddressID,
               Request->hdCall,
               Request->ulSelect,
               Request->ulDeviceClassSize,
               Request->ulDeviceClassOffset,
               ((PCHAR) Request + Request->ulDeviceClassOffset)
              ));

    /*
    // If there is no DChannel, we can't allow this.
    */
    if (pAdapter->pDChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODRIVER\n"));
        return (NDIS_STATUS_TAPI_NODRIVER);
    }

    /*
    // Make sure this is a tapi/line or ndis request.
    */
    if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  NDIS_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = NDIS_DEVICECLASS_ID;
    }
    else if (STR_EQU((PCHAR) Request + Request->ulDeviceClassOffset,
                  TAPI_DEVICECLASS_NAME, Request->ulDeviceClassSize))
    {
        DeviceClass = TAPI_DEVICECLASS_ID;
    }
    else
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALDEVICECLASS\n"));
        return (NDIS_STATUS_TAPI_INVALDEVICECLASS);
    }

    /*
    // Find the link structure associated with the request/deviceclass.
    */
    if (Request->ulSelect == LINECALLSELECT_LINE)
    {
        pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
        if (pBChannel == NULL)
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
            return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
        }
        /*
        // TAPI wants the ulDeviceID for this line.
        */
        DeviceID.hDevice = (ULONG) GET_DEVICEID_FROM_BCHANNEL(pAdapter, pBChannel);
    }
    else if (Request->ulSelect == LINECALLSELECT_ADDRESS)
    {
        pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
        if (pBChannel == NULL)
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
            return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
        }

        if (Request->ulAddressID >= TSPI_NUM_ADDRESSES)
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALADDRESSID\n"));
            return (NDIS_STATUS_TAPI_INVALADDRESSID);
        }
        /*
        // TAPI wants the ulDeviceID for this line.
        */
        DeviceID.hDevice = (ULONG) GET_DEVICEID_FROM_BCHANNEL(pAdapter, pBChannel);
    }
    else if (Request->ulSelect == LINECALLSELECT_CALL)
    {
        pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
        if (pBChannel == NULL)
        {
            DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
            return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
        }
        /*
        // TAPI wants the htCall for this line.
        */
        DeviceID.hDevice = (ULONG) (ULONG_PTR) (pBChannel->htCall);
    }
    else
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_FAILURE\n"));
        return (NDIS_STATUS_FAILURE);
    }

    /*
    // NT RAS only expects to see hDevice.
    // Win95 RAS expects to see hDevice followed by "isdn\0".
    */
    IDLength = strlen(VER_DEFAULT_MEDIATYPE) + 1;
    NdisMoveMemory(&DeviceID.DeviceName, VER_DEFAULT_MEDIATYPE, IDLength);
    IDLength += sizeof(ULONG);
    IDPtr = (PUCHAR) &DeviceID;

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
               ("#%d Call=0x%X CallState=0x%X GETID-%d=0x%X-'%s'@%dKbps\n",
               pBChannel->BChannelIndex,
               pBChannel->htCall, pBChannel->CallState,
               Request->ulSelect, DeviceID.hDevice, DeviceID.DeviceName,
               pBChannel->LinkSpeed/1000));

    /*
    // Now we need to adjust the variable field to place the device ID.
    */
    Request->DeviceID.ulNeededSize = sizeof(VAR_STRING) + IDLength;
    Request->DeviceID.ulUsedSize  = sizeof(VAR_STRING);

    *BytesNeeded += IDLength;
    if (Request->DeviceID.ulTotalSize >= Request->DeviceID.ulNeededSize)
    {
        Request->DeviceID.ulStringFormat = STRINGFORMAT_BINARY;
        Request->DeviceID.ulUsedSize     = Request->DeviceID.ulNeededSize;
        Request->DeviceID.ulStringSize   = IDLength;
        Request->DeviceID.ulStringOffset = sizeof(VAR_STRING);

        /*
        // Now we return the requested ID value.
        */
        NdisMoveMemory(
                (PCHAR) &Request->DeviceID + sizeof(VAR_STRING),
                IDPtr,
                IDLength
                );
    }
    else
    {
        if ((Request->DeviceID.ulNeededSize - Request->DeviceID.ulTotalSize) >=
            sizeof(ULONG))
        {
            /*
            // Return just the hDevice part (the first 4 bytes).
            */
            NdisMoveMemory(
                    (PCHAR) &Request->DeviceID + sizeof(VAR_STRING),
                    IDPtr,
                    sizeof(ULONG)
                    );
            Request->DeviceID.ulStringFormat = STRINGFORMAT_BINARY;
            Request->DeviceID.ulUsedSize    += sizeof(ULONG);
            Request->DeviceID.ulStringSize   = sizeof(ULONG);
            Request->DeviceID.ulStringOffset = sizeof(VAR_STRING);
        }

        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->DeviceID.ulTotalSize,
                   Request->DeviceID.ulNeededSize));
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\vlang.h ===
// Define the language and sublanguge supported by your program.
#define VER_LANGUAGE_NUM                0x0409
#define VER_SUBLANGUAGE_NUM             0x04B0
// Concatenate the two, 4 digit hex numbers above.
#define VER_LANGUAGE_STRING             "040904B0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tspi.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Tspi Tspi_c

@module Tspi.c |

    This module contains all the Miniport TAPI OID processing routines.  It
    is called by the <f MiniportSetInformation> and <f MiniportQueryInformation>
    routines to handle the TAPI OIDs.

    This driver conforms to the NDIS 3.0 Miniport interface and provides
    extensions to support Telephonic Services.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Tspi_c

@end

*/


/* @doc EXTERNAL INTERNAL


@topic 4.0 NDISWAN TAPI Service Provider Interface |

    The Connection Wrapper interface defines how WAN miniport NIC drivers
    implement telephonic services. It is closely related to the Service
    Provider Interface established in Windows Telephony version 1.0, with
    telephony-aware NDIS miniport NIC drivers taking the place of TAPI
    service providers.  This section touches briefly on the concepts
    embodied in Windows Telephony, but the reader is advised to consult the
    documentation published with the Telephony SDK for an in-depth
    discussion.

    <f Note>: There are subtle differences between the TAPI specification and the
    Windows 95 TAPI implementation.  Please refer to the Microsoft Win32 SDK
    for details on the Win32 TAPI specification.

    The Connection Wrapper itself is an extension of the NDIS WAN library,
    and serves as a router for telephonic requests passed down through TAPI
    from user-mode client applications. WAN Miniport NIC drivers register
    for Connection Wrapper services by calling NdisMRegisterMiniport, and
    then register one or more adapters. When registration and other driver
    initialization have successfully completed, WAN miniport NIC drivers can
    receive telephonic requests from the Connection Wrapper via the standard
    NdisMSetInformation and NdisMQueryInformation mechanisms, and respond by
    calling NdisMQueryInformationComplete or NdisMSetInformationComplete and
    NdisMIndicateStatus to notify the Connection Wrapper of asynchronous
    request completion and unsolicited events (e.g. incoming calls, remote
    disconnections), respectively.

@end
*/

#define  __FILEID__             TSPI_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "string.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Tspi Tspi_c STR_EQU


@func

    <f STR_EQU> compares two strings for equality, ignoring case.

@parm IN PCHAR | s1 |
    A pointer to the string to be compared.

@parm IN PCHAR | s2 |
    A pointer to the string to be compared.

@parm IN int | len |
    The length of the strings in bytes.

@rdesc STR_EQU returns TRUE if the strings are equal, otherwise FASLE.

*/

BOOLEAN STR_EQU(
    IN PCHAR                    s1,
    IN PCHAR                    s2,
    IN int                      len
    )
{
    DBG_FUNC("STR_EQU")

    int index;
    int c1 = 0;
    int c2 = 0;

    for (index = 0; index < len; index++)
    {
        c1 = *s1++;
        c2 = *s2++;
        if (c1 == 0 || c2 == 0)
        {
            break;
        }
        if (c1 >= 'A' && c1 <= 'Z')
        {
            c1 += 'a' - 'A';
        }
        if (c2 >= 'A' && c2 <= 'Z')
        {
            c2 += 'a' - 'A';
        }
        if (c1 != c2)
        {
            break;
        }
    }
    return (c1 == c2);
}

/*
// This defines the prototype for all TAPI OID request handlers.
*/
typedef NDIS_STATUS (__stdcall * PTSPI_REQUEST)
(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PVOID Request,
    OUT PULONG BytesUsed,
    OUT PULONG                  BytesNeeded
);

/* @doc EXTERNAL INTERNAL Tspi Tspi_c TSPI_OID_INFO


@struct TSPI_OID_INFO |

    This structure defines the format of the TAPI OID table entries.

@comm

*/

typedef struct TSPI_OID_INFO
{
    ULONG           Oid;                                    // @field
    // TSPI OID value which identifies this record uniquely.

    ULONG           MinBytesNeeded;                         // @field
    // Minimum number of bytes needed when this request is given to
    // the miniport.

    PTSPI_REQUEST   Request;                                // @field
    // Pointer to a function which will be invoked to handle the
    // TSPI request.

    PUCHAR          OidString;                              // @field
    // OID description string.

} TSPI_OID_INFO, *PTSPI_OID_INFO;

/*
// The NDISTAPI.H file defines some of the variable length structures with
// an extra byte at end (e.g. UCHAR VarArgs[1]).  Since the caller is not
// required to use the optional fields, the length of the structure passed
// in can be exactly equal to the size of the TAPI request structure, without
// any extra bytes.  So we use TSPI_OPTIONAL_SIZE compensate for this
// problem in our minimum structure size requirements.  With structure pad,
// there is an additional 4 bytes at the end.
*/
#define TSPI_OPTIONAL_SIZE      sizeof(ULONG)

/*
// The following is a list of all the possible TAPI OIDs.
// WARNING! The list is ordered so that it can be indexed directly by the
// (OID_TAPI_xxx - OID_TAPI_ACCEPT).
*/
DBG_STATIC TSPI_OID_INFO TspiSupportedOidTable[] =
{
    {
        OID_TAPI_ACCEPT,
        sizeof(NDIS_TAPI_ACCEPT)-TSPI_OPTIONAL_SIZE,
        TspiAccept,
        "OID_TAPI_ACCEPT"
    },
    {
        OID_TAPI_ANSWER,
        sizeof(NDIS_TAPI_ANSWER)-TSPI_OPTIONAL_SIZE,
        TspiAnswer,
        "OID_TAPI_ANSWER"
    },
    {
        OID_TAPI_CLOSE,
        sizeof(NDIS_TAPI_CLOSE),
        TspiClose,
        "OID_TAPI_CLOSE"
    },
    {
        OID_TAPI_CLOSE_CALL,
        sizeof(NDIS_TAPI_CLOSE_CALL),
        TspiCloseCall,
        "OID_TAPI_CLOSE_CALL"
    },
    {
        OID_TAPI_CONDITIONAL_MEDIA_DETECTION,
        sizeof(NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION),
        TspiConditionalMediaDetection,
        "OID_TAPI_CONDITIONAL_MEDIA_DETECTION"
    },
    {
        OID_TAPI_DROP,
        sizeof(NDIS_TAPI_DROP)-TSPI_OPTIONAL_SIZE,
        TspiDrop,
        "OID_TAPI_DROP"
    },
    {
        OID_TAPI_GET_ADDRESS_CAPS,
        sizeof(NDIS_TAPI_GET_ADDRESS_CAPS),
        TspiGetAddressCaps,
        "OID_TAPI_GET_ADDRESS_CAPS"
    },
    {
        OID_TAPI_GET_ADDRESS_ID,
        sizeof(NDIS_TAPI_GET_ADDRESS_ID)-TSPI_OPTIONAL_SIZE,
        TspiGetAddressID,
        "OID_TAPI_GET_ADDRESS_ID"
    },
    {
        OID_TAPI_GET_ADDRESS_STATUS,
        sizeof(NDIS_TAPI_GET_ADDRESS_STATUS),
        TspiGetAddressStatus,
        "OID_TAPI_GET_ADDRESS_STATUS"
    },
    {
        OID_TAPI_GET_CALL_ADDRESS_ID,
        sizeof(NDIS_TAPI_GET_CALL_ADDRESS_ID),
        TspiGetCallAddressID,
        "OID_TAPI_GET_CALL_ADDRESS_ID"
    },
    {
        OID_TAPI_GET_CALL_INFO,
        sizeof(NDIS_TAPI_GET_CALL_INFO),
        TspiGetCallInfo,
        "OID_TAPI_GET_CALL_INFO"
    },
    {
        OID_TAPI_GET_CALL_STATUS,
        sizeof(NDIS_TAPI_GET_CALL_STATUS),
        TspiGetCallStatus,
        "OID_TAPI_GET_CALL_STATUS"
    },
    {
        OID_TAPI_GET_DEV_CAPS,
        sizeof(NDIS_TAPI_GET_DEV_CAPS),
        TspiGetDevCaps,
        "OID_TAPI_GET_DEV_CAPS"
    },
    {
        OID_TAPI_GET_DEV_CONFIG,
        sizeof(NDIS_TAPI_GET_DEV_CONFIG),
        TspiGetDevConfig,
        "OID_TAPI_GET_DEV_CONFIG"
    },
    {
        OID_TAPI_GET_ID,
        sizeof(NDIS_TAPI_GET_ID),
        TspiGetID,
        "OID_TAPI_GET_ID"
    },
    {
        OID_TAPI_GET_LINE_DEV_STATUS,
        sizeof(NDIS_TAPI_GET_LINE_DEV_STATUS),
        TspiGetLineDevStatus,
        "OID_TAPI_GET_LINE_DEV_STATUS"
    },
    {
        OID_TAPI_MAKE_CALL,
        sizeof(NDIS_TAPI_MAKE_CALL),
        TspiMakeCall,
        "OID_TAPI_MAKE_CALL"
    },
    {
        OID_TAPI_OPEN,
        sizeof(NDIS_TAPI_OPEN),
        TspiOpen,
        "OID_TAPI_OPEN"
    },
    {
        OID_TAPI_PROVIDER_INITIALIZE,
        sizeof(OID_TAPI_PROVIDER_INITIALIZE),
        TspiProviderInitialize,
        "OID_TAPI_PROVIDER_INITIALIZE"
    },
    {
        OID_TAPI_PROVIDER_SHUTDOWN,
        sizeof(NDIS_TAPI_PROVIDER_SHUTDOWN),
        TspiProviderShutdown,
        "OID_TAPI_PROVIDER_SHUTDOWN"
    },
    {
        OID_TAPI_SET_APP_SPECIFIC,
        sizeof(NDIS_TAPI_SET_APP_SPECIFIC),
        TspiSetAppSpecific,
        "OID_TAPI_SET_APP_SPECIFIC"
    },
    {
        OID_TAPI_SET_CALL_PARAMS,
        sizeof(NDIS_TAPI_SET_CALL_PARAMS),
        TspiSetCallParams,
        "OID_TAPI_SET_CALL_PARAMS"
    },
    {
        OID_TAPI_SET_DEFAULT_MEDIA_DETECTION,
        sizeof(NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION),
        TspiSetDefaultMediaDetection,
        "OID_TAPI_SET_DEFAULT_MEDIA_DETECTION"
    },
    {
        OID_TAPI_SET_DEV_CONFIG,
        sizeof(NDIS_TAPI_SET_DEV_CONFIG)-TSPI_OPTIONAL_SIZE,
        TspiSetDevConfig,
        "OID_TAPI_SET_DEV_CONFIG"
    },
    {
        OID_TAPI_SET_MEDIA_MODE,
        sizeof(NDIS_TAPI_SET_MEDIA_MODE),
        TspiSetMediaMode,
        "OID_TAPI_SET_MEDIA_MODE"
    },
    {
        OID_TAPI_SET_STATUS_MESSAGES,
        sizeof(NDIS_TAPI_SET_STATUS_MESSAGES),
        TspiSetStatusMessages,
        "OID_TAPI_SET_STATUS_MESSAGES"
    },
    {
        0,
        0,
        NULL,
        "OID_UNKNOWN"
    }
};

#define NUM_OID_ENTRIES (sizeof(TspiSupportedOidTable) / sizeof(TspiSupportedOidTable[0]))

/* @doc INTERNAL Tspi Tspi_c GetOidInfo


@func

    <f GetOidInfo> converts an NDIS TAPI OID to a TSPI_OID_INFO pointer.

@parm IN NDIS_OID | Oid |
    The OID to be converted.

@rdesc GetOidInfo returns a pointer into the TspiSupportedOidTable for the
    associated OID.  If the Oid is not supported in the table, a pointer
    to the last entry is returned, which will contain a NULL Request pointer.

*/

PTSPI_OID_INFO GetOidInfo(
    IN NDIS_OID Oid
    )
{
    DBG_FUNC("GetOidInfo")

    UINT i;

    for (i = 0; i < NUM_OID_ENTRIES-1; i++)
    {
        if (TspiSupportedOidTable[i].Oid == Oid)
        {
            break;
        }
    }
    return (&TspiSupportedOidTable[i]);
}

/* @doc INTERNAL Tspi Tspi_c TspiRequestHandler


@func

    The <f TspiRequestHandler> request allows for inspection of the TAPI
    portion of the driver's capabilities and current line status.

    If the Miniport does not complete the call immediately (by returning
    NDIS_STATUS_PENDING), it must call NdisMQueryInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesWritten, and BytesNeeded until the request
    completes.

    No other requests will be submitted to the Miniport until
    this request has been completed.

    <f Note>: Interrupts are in any state during this call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN NDIS_OID | Oid |
    The OID.  (See section 2.2.1,2 of the Extensions to NDIS 3.0 Miniports to
    support Telephonic Services specification for a complete description of
    the OIDs.)

@parm IN PVOID | InformationBuffer |
    The buffer that will receive the information. (See section 2.2.1,2 of
    the Extensions to NDIS 3.0 Miniports to support Telephonic Services
    specification for a description of the length required for each OID.)

@parm IN ULONG | InformationBufferLength |
    The length in bytes of InformationBuffer.

@parm OUT PULONG | BytesUsed |
    Returns the number of bytes used from the InformationBuffer.

@parm OUT PULONG | BytesNeeded |
    Returns the number of additional bytes needed to satisfy the OID.

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_INVALID_DATA
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_PENDING
    NDIS_STATUS_SUCCESS

*/

NDIS_STATUS TspiRequestHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesUsed,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiRequestHandler")

    NDIS_STATUS Status;

    PTSPI_OID_INFO OidInfo;

    DBG_ENTER(pAdapter);

    /*
    // Get TSPI_OID_INFO pointer.
    */
    OidInfo = GetOidInfo(Oid);

    DBG_REQUEST(pAdapter,
              ("(OID=0x%08X %s)\n\t\tInfoLength=%d InfoBuffer=0x%X MinLength=%d\n",
               Oid, OidInfo->OidString,
               InformationBufferLength,
               InformationBuffer,
               OidInfo->MinBytesNeeded
              ));

    /*
    // Make sure this is a valid request.
    */
    if (OidInfo->Request != NULL)
    {
        /*
        // If the buffer provided is at least the minimum required,
        // call the handler to do the work.
        */
        if (InformationBufferLength >= OidInfo->MinBytesNeeded)
        {
            /*
            // Default BytesUsed indicates that we used the minimum necessary.
            */
            *BytesUsed = OidInfo->MinBytesNeeded;

            /*
            // Default BytesNeeded indicates that we don't need any more.
            */
            *BytesNeeded = 0;

            Status = OidInfo->Request(pAdapter, InformationBuffer,
                                      BytesUsed, BytesNeeded);
        }
        else
        {
            /*
            // The caller did not provide an adequate buffer, so we have to
            // tell them how much more we need to satisfy the request.
            // Actually, this is the minimum additional bytes we'll need,
            // the request handler may have even more bytes to add.
            */
            *BytesUsed = 0;
            *BytesNeeded = (OidInfo->MinBytesNeeded - InformationBufferLength);
            Status = NDIS_STATUS_INVALID_LENGTH;
        }
    }
    else
    {
        Status = NDIS_STATUS_TAPI_OPERATIONUNAVAIL;
    }

    DBG_REQUEST(pAdapter,
              ("RETURN: Status=0x%X Needed=%d Used=%d\n",
               Status, *BytesNeeded, *BytesUsed));

    /*
    // Indicate a status complete if it's needed.
    */
    if (pAdapter->NeedStatusCompleteIndication)
    {
        pAdapter->NeedStatusCompleteIndication = FALSE;
        NdisMIndicateStatusComplete(pAdapter->MiniportAdapterHandle);
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Tspi Tspi_c TspiProviderInitialize


@func

    This request initializes the TAPI portion of the miniport.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_PROVIDER_INITIALIZE | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_PROVIDER_INITIALIZE
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceIDBase;
        OUT ULONG       ulNumLineDevs;
        OUT ULONG       ulProviderID;

    } NDIS_TAPI_PROVIDER_INITIALIZE, *PNDIS_TAPI_PROVIDER_INITIALIZE;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_RESOURCEUNAVAIL

*/

NDIS_STATUS TspiProviderInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_PROVIDER_INITIALIZE Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiProviderInitialize")

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceIDBase=%d\n"
               "\tNumLineDevs=%d\n",
               Request->ulDeviceIDBase,
               pAdapter->NumBChannels
              ));
    /*
    // Save the device ID base value.
    */
    pAdapter->DeviceIdBase = Request->ulDeviceIDBase;

    /*
    // Return the number of lines.
    */
    Request->ulNumLineDevs = pAdapter->NumBChannels;

    /*
    // Before completing the PROVIDER_INIT request, the miniport should fill
    // in the ulNumLineDevs field of the request with the number of line
    // devices supported by the adapter. The miniport should also set the
    // ulProviderID field to a unique (per adapter) value. (There is no
    // method currently in place to guarantee unique ulProviderID values,
    // so we use the virtual address of our adapter structure.)
    */
    Request->ulProviderID = (ULONG) (ULONG_PTR)pAdapter;

    /*
    // TODO - Reinitialize the stat counters.
    */
    pAdapter->TotalRxBytes            = 0;
    pAdapter->TotalTxBytes            = 0;
    pAdapter->TotalRxPackets          = 0;
    pAdapter->TotalTxPackets          = 0;

    /*
    // Try to connect to the DChannel.
    */
    if (DChannelOpen(pAdapter->pDChannel) != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(pAdapter,("Returning NDIS_STATUS_TAPI_NODRIVER\n"));
        return (NDIS_STATUS_TAPI_NODRIVER);
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL Tspi Tspi_c TspiProviderShutdown


@func

    This request shuts down the miniport. The miniport should terminate any
    activities it has in progress.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_PROVIDER_SHUTDOWN | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_PROVIDER_SHUTDOWN
    {
        IN  ULONG       ulRequestID;

    } NDIS_TAPI_PROVIDER_SHUTDOWN, *PNDIS_TAPI_PROVIDER_SHUTDOWN;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

*/

NDIS_STATUS TspiProviderShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_PROVIDER_SHUTDOWN Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiProviderShutdown")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    USHORT                      BChannelIndex;
    // Index into the pBChannelArray.

    DBG_ENTER(pAdapter);

    /*
    // Hangup all of the lines.
    */
    for (BChannelIndex = 0; BChannelIndex < pAdapter->NumBChannels; BChannelIndex++)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex);

        if (pBChannel->IsOpen)
        {
            /*
            // Close the BChannel - any open call will be dropped.
            */
            BChannelClose(pBChannel);
        }
    }
    pAdapter->NumLineOpens = 0;

    /*
    // Close DChannel.
    */
    DChannelClose(pAdapter->pDChannel);

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL Tspi Tspi_c TspiResetHandler


@func

    <f TspiResetHandler> is called by the MiniportReset routine after the
    hardware has been reset due to some failure detection.  We need to make
    sure the line and call state information is conveyed properly to the
    Connection Wrapper.

    We only generate hangups on streams which have issued ENABLE_D_CHANNELs

    This function is called when the PRI board is RESET and when we receive a
    T1_STATUS message with RED alarm set.  When we get a RED alarm, we issue
    disable D channel messages for all open links. This is indicated by the
    argument nohup_Link set to NULL.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

*/

VOID TspiResetHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    )
{
    DBG_FUNC("TspiResetHandler")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    USHORT                      BChannelIndex;
    // Index into the pBChannelArray.

    DBG_ENTER(pAdapter);

    /*
    // Force disconnect on all lines.
    */
    for (BChannelIndex = 0; BChannelIndex < pAdapter->NumBChannels; BChannelIndex++)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex);

        if (pBChannel->IsOpen &&
            pBChannel->CallState != 0 &&
            pBChannel->CallState != LINECALLSTATE_IDLE)
        {
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_IDLE,
                                 0);
            pBChannel->CallState = 0;
        }
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\transmit.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Transmit Transmit_c

@module Transmit.c |

    This module implements the Miniport packet Transmit routines. This module is
    very dependent on the hardware/firmware interface and should be looked at
    whenever changes to these interfaces occur.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Transmit_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.3 Sending Packets |

    <f MiniportWanSend> transmits a packet through the adapter
    onto the network.

    Ownership of both the packet descriptor and the packet data
    is transferred to the WAN NIC driver until this request is
    completed, either synchronously or asynchronously. If the
    WAN miniport returns NDIS_STATUS_PENDING, it must later
    indicate completion of the request by calling NdisMWanSendComplete.
    If the WAN miniport returns a status other than NDIS_STATUS_PENDING,
    the request is considered to be complete, and ownership of the packet
    immediately reverts to the caller.

    Unlike LAN miniports, the WAN driver cannot return a status of
    NDIS_STATUS_RESOURCES to indicate that it does not have enough
    resources currently available to process the transmit. Instead,
    the WAN miniport should queue the send internally for a later
    time and perhaps lower the SendWindow value on the line by
    making a line-up indication. The NDISWAN driver will insure
    that the WAN miniport driver never has more than SendWindow
    packets outstanding. If a WAN miniport makes a line-up indication
    for a particular line, and sets the SendWindow to zero, NDISWAN
    reverts to using the default value of the transmit window passed
    as the MaxTransmit value provided to an earlier OID_WAN_GET_INFO
    request.

    It is also an error for the WAN miniport NIC driver to
    call NdisMSendResourcesAvailable.

    The packet passed to <f MiniportWanSend> will contain simple HDLC
    PPP framing if PPP framing is set. For SLIP or RAS framing, the
    packet contains only the data portion with no framing whatsoever.
    Simple HDLC PPP framing is discussed later in more detail.

    A WAN NIC driver must not attempt to provide software loopback or
    promiscuous mode loopback. Both of these are fully supported in
    the NDISWAN driver.

    The MacReservedx members as well as the WanPacketQueue member of
    the <t NDIS_WAN_PACKET> is fully available for use by the WAN miniport.

    The available header padding is simply CurrentBuffer-StartBuffer.
    The available tail padding is EndBuffer-(CurrentBuffer+CurrentLength).
    The header and tail padding is guaranteed to be at least the amount
    requested, but it can be more.

    See <t NDIS_WAN_PACKET> in the Network Driver Reference for details of
    the WAN packet descriptor structure.

    A WAN miniport calls NdisMWanSendComplete to indicate that it has
    completed a previous transmit operation for which it returned
    NDIS_STATUS_PENDING. This does not necessarily imply that the
    packet has been transmitted, although, with the exception of
    intelligent adapters, it generally has. It does however, mean
    the miniport is ready to release ownership of the packet.

    When a WAN miniport calls NdisMWanSendComplete, it passes back
    the original packet to indicate which send operation was completed.
    If <f MiniportWanSend> returns a status other than NDIS_STATUS_PENDING,
    it does not call NdisMWanSendComplete for that packet.

@end
*/

#define  __FILEID__             TRANSMIT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Transmit Transmit_c TransmitAddToQueue


@func

    <f TransmitAddToQueue> places the packet on the transmit queue.  If the
    queue was empty to begin with, TRUE is returned so the caller can kick
    start the transmiter.

@rdesc

    <f TransmitAddToQueue> returns TRUE if this is the only entry in the
    list, FALSE otherwise.

*/

DBG_STATIC BOOLEAN TransmitAddToQueue(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PNDIS_WAN_PACKET         pWanPacket                  // @parm
    // A pointer to the associated NDIS packet structure <t NDIS_WAN_PACKET>.
    )
{
    DBG_FUNC("TransmitAddToQueue")

    /*
    // Note if the list is empty to begin with.
    */
    BOOLEAN     ListWasEmpty;

    DBG_ENTER(pAdapter);

    /*
    // Place the packet on the TransmitPendingList.
    */
    NdisAcquireSpinLock(&pAdapter->TransmitLock);
    ListWasEmpty = IsListEmpty(&pAdapter->TransmitPendingList);
    InsertTailList(&pAdapter->TransmitPendingList, &pWanPacket->WanPacketQueue);
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    DBG_RETURN(pAdapter, ListWasEmpty);
    return (ListWasEmpty);
}


/* @doc INTERNAL Transmit Transmit_c TransmitPacketHandler


@func

    <f TransmitPacketHandler> removes an entry from the TransmitPendingList
    and places the packet on the appropriate B-channel and starts the
    transmission.  The packet is then placed on the <t TransmitBusyList> to
    await a transmit complete event processed by <f TransmitCompleteHandler>.

@comm

    The packets go out in a FIFO order for the entire driver, independent of
    the channel on which it goes out.  This means that a slow link, or one
    that is backed up can hold up all other channels.  There is no good way
    to get around this because we must to deliver packets in the order they
    are given to the Miniport, regardless of the link they are on.

*/

DBG_STATIC VOID TransmitPacketHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("TransmitPacketHandler")

    PNDIS_WAN_PACKET            pWanPacket;
    // Holds the packet being transmitted.

    USHORT                      BytesToSend;
    // Tells us how many bytes are to be transmitted.

    PBCHANNEL_OBJECT            pBChannel;
    // A pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);

    /*
    // MUTEX to protect against async EventHandler access at the same time.
    */
    NdisAcquireSpinLock(&pAdapter->TransmitLock);

#if DBG
    {   // Sanity check!
        PLIST_ENTRY pList = &pAdapter->TransmitPendingList;
        ASSERT(pList->Flink && pList->Flink->Blink == pList);
        ASSERT(pList->Blink && pList->Blink->Flink == pList);
    }
#endif // DBG

    /*
    // This might be called when no packets are queued!
    */
    while (!IsListEmpty(&pAdapter->TransmitPendingList))
    {
        /*
        // Remove the packet from the TransmitPendingList.
        */
        pWanPacket = (PNDIS_WAN_PACKET)RemoveHeadList(&pAdapter->TransmitPendingList);

        /*
        // Release MUTEX
        */
        NdisReleaseSpinLock(&pAdapter->TransmitLock);

        /*
        // Retrieve the information we saved in the packet reserved fields.
        */
        pBChannel = (PBCHANNEL_OBJECT) pWanPacket->MacReserved1;

        /*
        // Make sure the link is still up and can accept transmits.
        */
        if (pBChannel->CallState != LINECALLSTATE_CONNECTED)
        {
            /*
            // Indicate send complete failure to the NDIS wrapper.
            */
            DBG_WARNING(pAdapter,("Flushing send on link#%d (Packet=0x%X)\n",
                      pBChannel->BChannelIndex, pWanPacket));
            if (pBChannel->NdisLinkContext)
            {
                NdisMWanSendComplete(pAdapter->MiniportAdapterHandle,
                                     pWanPacket, NDIS_STATUS_FAILURE);
            }

            /*
            // Reacquire MUTEX
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
        }
        else
        {
            BytesToSend = (USHORT) pWanPacket->CurrentLength;
            pAdapter->TotalTxBytes += BytesToSend;
            pAdapter->TotalTxPackets++;

            /*
            // Attempt to place the packet on the NIC for transmission.
            */
            if (!CardTransmitPacket(pAdapter->pCard, pBChannel, pWanPacket))
            {
                /*
                // ReQueue the packet on the TransmitPendingList and leave.
                // Reacquire MUTEX
                */
                NdisAcquireSpinLock(&pAdapter->TransmitLock);
                InsertHeadList(&pAdapter->TransmitPendingList, &pWanPacket->WanPacketQueue);
                break;
            }
            DBG_TX(pAdapter, pBChannel->BChannelIndex,
                   BytesToSend, pWanPacket->CurrentBuffer);

            /*
            // Reacquire MUTEX
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
        }
    }
    /*
    // Release MUTEX
    */
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Transmit Transmit_c TransmitCompleteHandler


@func

    <f TransmitCompleteHandler> is called by <f MiniportTimer> to handle a
    transmit complete event.  We walk the <t TransmitCompleteList> to find
    all the packets that have been sent out on the wire, and then tell the
    protocol stack that we're done with the packet, and it can be re-used.

*/

VOID TransmitCompleteHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("TransmitCompleteHandler")

    PNDIS_WAN_PACKET            pWanPacket;
    // Holds the packet that's just been transmitted.

    PBCHANNEL_OBJECT            pBChannel;
    // A pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (++(pAdapter->NestedDataHandler) > 1)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d > 1\n",
                  pAdapter->NestedDataHandler));
    }

    /*
    // MUTEX to protect against async EventHandler access at the same time.
    */
    NdisDprAcquireSpinLock(&pAdapter->TransmitLock);

#if DBG
    {   // Sanity check!
        PLIST_ENTRY pList = &pAdapter->TransmitCompleteList;
        ASSERT(pList->Flink && pList->Flink->Blink == pList);
        ASSERT(pList->Blink && pList->Blink->Flink == pList);
    }
#endif // DBG

    while (!IsListEmpty(&pAdapter->TransmitCompleteList))
    {
        /*
        // Remove the packet from the TransmitCompleteList.
        */
        pWanPacket = (PNDIS_WAN_PACKET)RemoveHeadList(&pAdapter->TransmitCompleteList);

        /*
        // Release MUTEX
        */
        NdisDprReleaseSpinLock(&pAdapter->TransmitLock);

        /*
        // Retrieve the information we saved in the packet reserved fields.
        */
        pBChannel = (PBCHANNEL_OBJECT) pWanPacket->MacReserved1;

        /*
        // Indicate send complete to the NDIS wrapper.
        */
        DBG_TXC(pAdapter, pBChannel->BChannelIndex);
        NdisMWanSendComplete(pAdapter->MiniportAdapterHandle,
                             pWanPacket, NDIS_STATUS_SUCCESS);

        /*
        // Reacquire MUTEX
        */
        NdisDprAcquireSpinLock(&pAdapter->TransmitLock);
    }
    /*
    // Release MUTEX
    */
    NdisDprReleaseSpinLock(&pAdapter->TransmitLock);

    /*
    // Start any other pending transmits.
    */
    TransmitPacketHandler(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (--(pAdapter->NestedDataHandler) < 0)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d < 0\n",
                  pAdapter->NestedDataHandler));
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Transmit Transmit_c MiniportWanSend


@func

    <f MiniportWanSend> instructs a WAN driver to transmit a packet through
    the adapter onto the medium.

@iex

    typedef struct _NDIS_WAN_PACKET
    {
        LIST_ENTRY          WanPacketQueue;
        PUCHAR              CurrentBuffer;
        ULONG               CurrentLength;
        PUCHAR              StartBuffer;
        PUCHAR              EndBuffer;
        PVOID               ProtocolReserved1;
        PVOID               ProtocolReserved2;
        PVOID               ProtocolReserved3;
        PVOID               ProtocolReserved4;
        PVOID               MacReserved1;       // pBChannel
        PVOID               MacReserved2;
        PVOID               MacReserved3;
        PVOID               MacReserved4;

    } NDIS_WAN_PACKET, *PNDIS_WAN_PACKET;

@comm

    When <f MiniportWanSend> is called, ownership of both the packet descriptor and
    the packet data is transferred to the driver until it completes the given
    packet, either synchronously or asynchronously. If <f MiniportWanSend>
    returns a status other than NDIS_STATUS_PENDING, the request is
    considered complete and ownership of the packet immediately reverts
    to the initiator of the send request. If MiniportWanSend returns
    NDIS_STATUS_PENDING, the miniport subsequently must call
    NdisMWanSendComplete with the packet to indicate completion
    of the transmit request.

    MiniportWanSend can use both the <t MacReservedX> and <t WanPacketQueue>
    areas within the <t NDIS_WAN_PACKET> structure. However, the miniport
    cannot access the ProtocolReservedx members.

    Any NDIS intermediate driver that binds itself to an underlying
    WAN miniport is responsible for providing a fresh <t NDIS_WAN_PACKET>
    structure to the underlying driver's <f MiniportWanSend> function. Before
    such an intermediate driver calls NdisSend, it must repackage the send
    packet given to its MiniportWanSend function so the underlying driver
    will have MacReservedx and WanPacketQueue areas of its own to use.

    The available header padding within a given packet can be calculated
    as (CurrentBuffer - StartBuffer), the available tail padding as
    (EndBuffer - (CurrentBuffer + CurrentLength)). The header and
    tail padding is guaranteed to be at least the length that the
    miniport requested in response to a preceding OID_WAN_GET_INFO
    query. The header and/or tail padding for any packet given to
    <f MiniportWanSend> can be more than the length that was requested.

    <f MiniportWanSend> can neither return NDIS_STATUS_RESOURCES for an
    input packet nor call NdisMSendResourcesAvailable. Instead, the
    miniport must queue incoming send packets internally for subsequent
    transmission. The miniport controls how many packets NDIS will
    submit to MiniportWanSend when the NIC driver sets the SendWindow
    value in the driver's NDIS_MAC_LINE_UP indication to establish the
    given link. NDISWAN uses this value as an upper bound on uncompleted
    sends submitted to <f MiniportWanSend>, so the miniport's internal queue
    cannot be overrun, and the miniport can adjust the SendWindow
    dynamically with subsequent line-up indications for established
    links. If the miniport set the SendWindow to zero when it called
    NdisMIndicateStatus with a particular line-up indication, NDISWAN
    uses the MaxTransmit value that the driver originally set in response
    to the OID_WAN_GET_INFO query as its limit on submitted but uncompleted
    send packets.

    Each packet passed to <f MiniportWanSend> is set up according to one of
    the flags that the miniport set in the FramingBits member in response
    to the OID_WAN_GET_INFO query. It will contain simple HDLC PPP framing
    if the driver claimed to support PPP. For SLIP or RAS framing, such
    a packet contains only the data portion with no framing whatsoever.

    For more information about system-defined WAN and TAPI OIDs, see Part 2.

    <f Note>: A WAN driver cannot manage software loopback or promiscuous mode
    loopback internally. NDISWAN supplies this loopback support for
    WAN drivers.

    <f Note>: <f MiniportWanSend> can be pre-empted by an interrupt.

    By default, <f MiniportWanSend> runs at IRQL DISPATCH_LEVEL.


@rdesc

    <f MiniportWanSend> can return one of the following:

    @flag NDIS_STATUS_SUCCESS |
        The driver (or its NIC) has accepted the packet data for
        transmission, so <f MiniportWanSend> is returning the packet.<nl>

    <f Note>: A non-zero return value indicates one of the following
    error codes:

@iex
    NDIS_STATUS_INVALID_DATA
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_PENDING
    NDIS_STATUS_FAILURE
*/

NDIS_STATUS MiniportWanSend(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PNDIS_WAN_PACKET         pWanPacket                  // @parm
    // A pointer to the associated NDIS packet structure <t NDIS_WAN_PACKET>.
    // The structure contains a pointer to a contiguous buffer with guaranteed
    // padding at the beginning and end.  The driver may manipulate the buffer
    // in any way.
    )
{
    DBG_FUNC("MiniportWanSend")

    UINT                        BytesToSend;
    // Tells us how many bytes are to be transmitted.

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    ASSERT(pAdapter == pBChannel->pAdapter);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the packet size is something we can deal with.
    */
    BytesToSend = pWanPacket->CurrentLength;
    if ((BytesToSend == 0) || (BytesToSend > pAdapter->pCard->BufferSize))
    {
        DBG_ERROR(pAdapter,("Bad packet size = %d\n",BytesToSend));
        Result = NDIS_STATUS_FAILURE;
    }
    /*
    // Return if line has been closed.
    */
    else if (pBChannel->CallClosing)
    {
        DBG_ERROR(pAdapter,("BChannel Closed\n"));
        Result = NDIS_STATUS_FAILURE;
    }
    else
    {
        /*
        // We have to accept the frame if possible, I just want to know
        // if somebody has lied to us...
        */
        if (BytesToSend > pBChannel->WanLinkInfo.MaxSendFrameSize)
        {
            DBG_NOTICE(pAdapter,("Line=%d  Packet size=%d > %d\n",
                    pBChannel->BChannelIndex, BytesToSend,
                    pBChannel->WanLinkInfo.MaxSendFrameSize));
        }

        /*
        // We'll need to use these when the transmit completes.
        */
        pWanPacket->MacReserved1 = (PVOID) pBChannel;

        /*
        // Place the packet in the transmit list.
        */
        if (TransmitAddToQueue(pAdapter, pBChannel, pWanPacket) &&
            pAdapter->NestedDataHandler < 1)
        {
            /*
            // The queue was empty so we've gotta kick start it.
            // Once it's going, it runs off the DPC.
            //
            // No kick start is necessary if we're already running the the
            // TransmitCompleteHandler -- In fact, it will screw things up if
            // we call TransmitPacketHandler while TransmitCompleteHandler is
            // running.
            */
            TransmitPacketHandler(pAdapter);
        }
        Result = NDIS_STATUS_PENDING;
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tspiaddr.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TspiAddr TspiAddr_c

@module TspiAddr.c |

    This module implements the Telephony Service Provider Interface for
    Address objects.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TspiAddr_c

@end

*/

#define  __FILEID__             TSPIADDR_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "string.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL TspiAddr TspiAddr_c TspiGetAddressID


@func

    This request returns the address ID associated with address in a different
    format on the specified line.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_ADDRESS_ID | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_ADDRESS_ID
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        OUT ULONG       ulAddressID;
        IN  ULONG       ulAddressMode;
        IN  ULONG       ulAddressSize;
        IN  CHAR        szAddress[1];

    } NDIS_TAPI_GET_ADDRESS_ID, *PNDIS_TAPI_GET_ADDRESS_ID;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_RESOURCEUNAVAIL

*/

NDIS_STATUS TspiGetAddressID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetAddressID")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulAddressMode=0x%X\n"
               "\tulAddressSize=%d\n"
               "\tszAddress=0x%X\n",
               Request->hdLine,
               Request->ulAddressMode,
               Request->ulAddressSize,
               Request->szAddress
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // We only support ID mode.
    */
    if (Request->ulAddressMode != LINEADDRESSMODE_DIALABLEADDR)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_FAILURE\n"));
        return (NDIS_STATUS_FAILURE);
    }

    /*
    // Make sure we have enough room set aside for this address string.
    */
    if (Request->ulAddressSize > sizeof(pBChannel->pTapiLineAddress)-1)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_RESOURCEUNAVAIL\n"));
        return (NDIS_STATUS_TAPI_RESOURCEUNAVAIL);
    }

    /*
    // This driver only supports one address per link.
    */
    Request->ulAddressID = TSPI_ADDRESS_ID;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiAddr TspiAddr_c TspiGetAddressCaps


@func

    This request queries the specified address on the specified line device
    to determine its telephony capabilities.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_ADDRESS_CAPS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_ADDRESS_CAPS
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulAddressID;
        IN  ULONG       ulExtVersion;
        OUT LINE_ADDRESS_CAPS   LineAddressCaps;

    } NDIS_TAPI_GET_ADDRESS_CAPS, *PNDIS_TAPI_GET_ADDRESS_CAPS;

    typedef struct _LINE_ADDRESS_CAPS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;
        ULONG   ulLineDeviceID;

        ULONG   ulAddressSize;
        ULONG   ulAddressOffset;
        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

        ULONG   ulAddressSharing;
        ULONG   ulAddressStates;
        ULONG   ulCallInfoStates;
        ULONG   ulCallerIDFlags;

        ULONG   ulCalledIDFlags;
        ULONG   ulConnectedIDFlags;
        ULONG   ulRedirectionIDFlags;
        ULONG   ulRedirectingIDFlags;

        ULONG   ulCallStates;
        ULONG   ulDialToneModes;
        ULONG   ulBusyModes;
        ULONG   ulSpecialInfo;

        ULONG   ulDisconnectModes;
        ULONG   ulMaxNumActiveCalls;
        ULONG   ulMaxNumOnHoldCalls;
        ULONG   ulMaxNumOnHoldPendingCalls;

        ULONG   ulMaxNumConference;
        ULONG   ulMaxNumTransConf;
        ULONG   ulAddrCapFlags;
        ULONG   ulCallFeatures;

        ULONG   ulRemoveFromConfCaps;
        ULONG   ulRemoveFromConfState;
        ULONG   ulTransferModes;
        ULONG   ulParkModes;

        ULONG   ulForwardModes;
        ULONG   ulMaxForwardEntries;
        ULONG   ulMaxSpecificEntries;
        ULONG   ulMinFwdNumRings;

        ULONG   ulMaxFwdNumRings;
        ULONG   ulMaxCallCompletions;
        ULONG   ulCallCompletionConds;
        ULONG   ulCallCompletionModes;

        ULONG   ulNumCompletionMessages;
        ULONG   ulCompletionMsgTextEntrySize;
        ULONG   ulCompletionMsgTextSize;
        ULONG   ulCompletionMsgTextOffset;

    } LINE_ADDRESS_CAPS, *PLINE_ADDRESS_CAPS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION
    NDIS_STATUS_TAPI_NODEVICE

*/

NDIS_STATUS TspiGetAddressCaps(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_CAPS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetAddressCaps")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    UINT                        AddressLength;
    // Length of the address string assigned to this line device.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceID=%d\n"
               "\tulAddressID=%d\n"
               "\tulExtVersion=0x%X\n",
               Request->ulDeviceID,
               Request->ulAddressID,
               Request->ulExtVersion
              ));
    /*
    // Make sure the address is within range - we only support one per line.
    */
    if (Request->ulAddressID >= TSPI_NUM_ADDRESSES)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALADDRESSID\n"));
        return (NDIS_STATUS_TAPI_INVALADDRESSID);
    }

    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_DEVICEID(pAdapter, Request->ulDeviceID);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODEVICE\n"));
        return (NDIS_STATUS_TAPI_NODEVICE);
    }

    Request->LineAddressCaps.ulNeededSize =
    Request->LineAddressCaps.ulUsedSize = sizeof(Request->LineAddressCaps);

    Request->LineAddressCaps.ulLineDeviceID = GET_DEVICEID_FROM_BCHANNEL(pAdapter, pBChannel);

    /*
    // Return the various address capabilites for the adapter.
    */
    Request->LineAddressCaps.ulAddressSharing = LINEADDRESSSHARING_PRIVATE;
    Request->LineAddressCaps.ulAddressStates = pBChannel->AddressStatesCaps;
    Request->LineAddressCaps.ulCallStates = pBChannel->CallStatesCaps;
    Request->LineAddressCaps.ulDialToneModes = LINEDIALTONEMODE_NORMAL;
    Request->LineAddressCaps.ulDisconnectModes =
            LINEDISCONNECTMODE_NORMAL |
            LINEDISCONNECTMODE_UNKNOWN |
            LINEDISCONNECTMODE_BUSY |
            LINEDISCONNECTMODE_NOANSWER;
    /*
    // This driver does not support conference calls, transfers, or holds.
    */
    Request->LineAddressCaps.ulMaxNumActiveCalls = 1;
    Request->LineAddressCaps.ulAddrCapFlags = LINEADDRCAPFLAGS_DIALED;
    Request->LineAddressCaps.ulCallFeatures = LINECALLFEATURE_ACCEPT |
                                              LINECALLFEATURE_ANSWER |
                                              LINECALLFEATURE_DROP;

    /*
    // RASTAPI requires the "I-L-A" be placed in the Address field at the end
    // of this structure.  Where:
    // I = The device intance assigned to this adapter in the registry
    //     \LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards\I
    // L = The device line number associated with this line (1..NumLines)
    // A = The address (channel) to be used on this line (0..NumAddresses-1)
    */
    AddressLength = strlen(pBChannel->pTapiLineAddress);
    Request->LineAddressCaps.ulNeededSize += AddressLength;
    *BytesNeeded += AddressLength;
    if (Request->LineAddressCaps.ulNeededSize <= Request->LineAddressCaps.ulTotalSize)
    {
        Request->LineAddressCaps.ulUsedSize += AddressLength;
        Request->LineAddressCaps.ulAddressSize = AddressLength;
        Request->LineAddressCaps.ulAddressOffset = sizeof(Request->LineAddressCaps);
        NdisMoveMemory((PUCHAR) &Request->LineAddressCaps +
                                 Request->LineAddressCaps.ulAddressOffset,
                pBChannel->pTapiLineAddress,
                AddressLength
                );
    }
    else
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineAddressCaps.ulTotalSize,
                   Request->LineAddressCaps.ulNeededSize));
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiAddr TspiAddr_c TspiGetAddressStatus


@func

    This request queries the specified address for its current status.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_ADDRESS_STATUS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_ADDRESS_STATUS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulAddressID;
        OUT LINE_ADDRESS_STATUS LineAddressStatus;

    } NDIS_TAPI_GET_ADDRESS_STATUS, *PNDIS_TAPI_GET_ADDRESS_STATUS;

    typedef struct _LINE_ADDRESS_STATUS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulNumInUse;
        ULONG   ulNumActiveCalls;
        ULONG   ulNumOnHoldCalls;
        ULONG   ulNumOnHoldPendCalls;
        ULONG   ulAddressFeatures;

        ULONG   ulNumRingsNoAnswer;
        ULONG   ulForwardNumEntries;
        ULONG   ulForwardSize;
        ULONG   ulForwardOffset;

        ULONG   ulTerminalModesSize;
        ULONG   ulTerminalModesOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_ADDRESS_STATUS, *PLINE_ADDRESS_STATUS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESSID

*/

NDIS_STATUS TspiGetAddressStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetAddressStatus")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulAddressID=%d\n",
               Request->hdLine,
               Request->ulAddressID
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // Make sure the address is within range - we only support one per line.
    */
    if (Request->ulAddressID >= TSPI_NUM_ADDRESSES)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALADDRESSID\n"));
        return (NDIS_STATUS_TAPI_INVALADDRESSID);
    }

    Request->LineAddressStatus.ulNeededSize =
    Request->LineAddressStatus.ulUsedSize = sizeof(Request->LineAddressStatus);

    if (Request->LineAddressStatus.ulNeededSize > Request->LineAddressStatus.ulTotalSize)
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineAddressStatus.ulTotalSize,
                   Request->LineAddressStatus.ulNeededSize));
    }

    /*
    // Return the current status information for the line.
    */
    Request->LineAddressStatus.ulNumInUse =
            pBChannel->CallState <= LINECALLSTATE_IDLE ? 0 : 1;
    Request->LineAddressStatus.ulNumActiveCalls =
            pBChannel->CallState <= LINECALLSTATE_IDLE ? 0 : 1;
    Request->LineAddressStatus.ulAddressFeatures =
            pBChannel->CallState <= LINECALLSTATE_IDLE ?
                LINEADDRFEATURE_MAKECALL : 0;
    Request->LineAddressStatus.ulNumRingsNoAnswer = 999;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiAddr TspiAddr_c TspiGetCallAddressID


@func

    This request retrieves the address ID for the indicated call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_CALL_ADDRESS_ID | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_CALL_ADDRESS_ID
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        OUT ULONG       ulAddressID;

    } NDIS_TAPI_GET_CALL_ADDRESS_ID, *PNDIS_TAPI_GET_CALL_ADDRESS_ID;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiGetCallAddressID(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_ADDRESS_ID Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetCallAddressID")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n",
               Request->hdCall
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // Return the address ID associated with this call.
    */
    Request->ulAddressID = TSPI_ADDRESS_ID;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiAddr TspiAddr_c TspiAddressStateHandler


@func

    <f TspiAddressStateHandler> will indicate the given LINEADDRESSSTATE to
    the Connection Wrapper if the event has been enabled by the wrapper.
    Otherwise the state information is saved, but no indication is made.

@parm IN ULONG | AddressState |
    The LINEADDRESSSTATE event to be posted to TAPI/WAN.

*/

VOID TspiAddressStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN ULONG                    AddressState
    )
{
    DBG_FUNC("TspiAddressStateHandler")

    /*
    // The event structure passed to the Connection Wrapper.
    */
    NDIS_TAPI_EVENT Event;

    DBG_ENTER(pAdapter);

    if (pBChannel->AddressStatesMask & AddressState)
    {
        Event.htLine   = pBChannel->htLine;
        Event.htCall   = pBChannel->htCall;
        Event.ulMsg    = LINE_CALLSTATE;
        Event.ulParam1 = AddressState;
        Event.ulParam2 = 0;
        Event.ulParam3 = 0;

        /*
        // We really don't have much to do here with this adapter.
        // And RASTAPI doesn't handle these events anyway...
        */
        switch (AddressState)
        {
        case LINEADDRESSSTATE_INUSEZERO:
            break;

        case LINEADDRESSSTATE_INUSEONE:
            break;
        }
        NdisMIndicateStatus(
                pAdapter->MiniportAdapterHandle,
                NDIS_STATUS_TAPI_INDICATION,
                &Event,
                sizeof(Event)
                );
        pAdapter->NeedStatusCompleteIndication = TRUE;
    }
    else
    {
        DBG_NOTICE(pAdapter, ("#%d ADDRESSSTATE EVENT=0x%X IS NOT ENABLED\n",
                   pBChannel->BChannelIndex, AddressState));
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\vtargnum.h ===
// WARNING --- DO NOT CHANGE THIS FILE --- WARNING
// It is updated automatically by the TpiBuild procedure using VerInc.exe.
#define VER_FILE_MAJOR_NUM      0
#define VER_FILE_MINOR_NUM      7
#define VER_FILE_SUB_MINOR_NUM  0
#define VER_FILE_MAJOR_STR      "0"
#define VER_FILE_MINOR_STR      "07"
#define VER_FILE_SUB_MINOR_STR  "00"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tspicall.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TspiCall TspiCall_c

@module TspiCall.c |

    This module implements the Telephony Service Provider Interface for
    Call objects (TspiCall).

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TspiCall_c

@end

*/

#define  __FILEID__             TSPICALL_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "string.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL TspiCall TspiCall_c TspiMakeCall


@func

    This request places a call on the specified line to the specified
    destination address. Optionally, call parameters can be specified if
    anything but default call setup parameters are requested.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_MAKE_CALL | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_MAKE_CALL
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  HTAPI_CALL  htCall;
        OUT HDRV_CALL   hdCall;
        IN  ULONG       ulDestAddressSize;
        IN  ULONG       ulDestAddressOffset;
        IN  BOOLEAN     bUseDefaultLineCallParams;
        IN  LINE_CALL_PARAMS    LineCallParams;

    } NDIS_TAPI_MAKE_CALL, *PNDIS_TAPI_MAKE_CALL;

    typedef struct _LINE_CALL_PARAMS        // Defaults:
    {
        ULONG   ulTotalSize;                // ---------

        ULONG   ulBearerMode;               // voice
        ULONG   ulMinRate;                  // (3.1kHz)
        ULONG   ulMaxRate;                  // (3.1kHz)
        ULONG   ulMediaMode;                // interactiveVoice

        ULONG   ulCallParamFlags;           // 0
        ULONG   ulAddressMode;              // addressID
        ULONG   ulAddressID;                // (any available)

        LINE_DIAL_PARAMS DialParams;        // (0, 0, 0, 0)

        ULONG   ulOrigAddressSize;          // 0
        ULONG   ulOrigAddressOffset;
        ULONG   ulDisplayableAddressSize;
        ULONG   ulDisplayableAddressOffset;

        ULONG   ulCalledPartySize;          // 0
        ULONG   ulCalledPartyOffset;

        ULONG   ulCommentSize;              // 0
        ULONG   ulCommentOffset;

        ULONG   ulUserUserInfoSize;         // 0
        ULONG   ulUserUserInfoOffset;

        ULONG   ulHighLevelCompSize;        // 0
        ULONG   ulHighLevelCompOffset;

        ULONG   ulLowLevelCompSize;         // 0
        ULONG   ulLowLevelCompOffset;

        ULONG   ulDevSpecificSize;          // 0
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_PARAMS, *PLINE_CALL_PARAMS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_ADDRESSBLOCKED
    NDIS_STATUS_TAPI_BEARERMODEUNAVAIL
    NDIS_STATUS_TAPI_CALLUNAVAIL
    NDIS_STATUS_TAPI_DIALBILLING
    NDIS_STATUS_TAPI_DIALQUIET
    NDIS_STATUS_TAPI_DIALDIALTONE
    NDIS_STATUS_TAPI_DIALPROMPT
    NDIS_STATUS_TAPI_INUSE
    NDIS_STATUS_TAPI_INVALADDRESSMODE
    NDIS_STATUS_TAPI_INVALBEARERMODE
    NDIS_STATUS_TAPI_INVALMEDIAMODE
    NDIS_STATUS_TAPI_INVALLINESTATE
    NDIS_STATUS_TAPI_INVALRATE
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESS
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INVALCALLPARAMS
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_TAPI_OPERATIONUNAVAIL
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_RESOURCEUNAVAIL
    NDIS_STATUS_TAPI_RATEUNAVAIL
    NDIS_STATUS_TAPI_USERUSERINFOTOOBIG

*/

NDIS_STATUS TspiMakeCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_MAKE_CALL Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiMakeCall")

    NDIS_STATUS                 Status = NDIS_STATUS_TAPI_INVALPARAM;

    PLINE_CALL_PARAMS           pLineCallParams;

    USHORT                      DialStringLength;

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\thtCall=0x%X\n"
               "\tulDestAddressSize=%d\n"
               "\tulDestAddressOffset=0x%X\n"
               "\tbUseDefaultLineCallParams=%d\n"
               "\tLineCallParams=0x%X:0x%X\n",
               Request->hdLine,
               Request->htCall,
               Request->ulDestAddressSize,
               Request->ulDestAddressOffset,
               Request->bUseDefaultLineCallParams,
               &Request->LineCallParams,
               Request
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // The line must be in-service before we can let this request go thru.
    */
    if ((pBChannel->DevState & LINEDEVSTATE_INSERVICE) == 0)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINESTATE\n"));
        return (NDIS_STATUS_TAPI_INVALLINESTATE);
    }

    /*
    // We should be idle when this call comes down, but if we're out of
    // state for some reason, don't let this go any further.
    */
    if (pBChannel->CallState != 0)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INUSE\n"));
        return (NDIS_STATUS_TAPI_INUSE);
    }

    /*
    // Which set of call parameters should we use?
    */
    if (Request->bUseDefaultLineCallParams)
    {
        pLineCallParams = &pAdapter->DefaultLineCallParams;
        DBG_NOTICE(pAdapter, ("UseDefaultLineCallParams\n"));
    }
    else
    {
        pLineCallParams = &Request->LineCallParams;
    }

    /*
    // Make sure the call parameters are valid for us.
    */
    if (pLineCallParams->ulBearerMode & ~pBChannel->BearerModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALBEARERMODE=0x%X\n",
                    pLineCallParams->ulBearerMode));
        return (NDIS_STATUS_TAPI_INVALBEARERMODE);
    }
    if (pLineCallParams->ulMediaMode & ~pBChannel->MediaModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALMEDIAMODE=0x%X\n",
                    pLineCallParams->ulMediaMode));
        return (NDIS_STATUS_TAPI_INVALMEDIAMODE);
    }
    if (pLineCallParams->ulMinRate > _64KBPS ||
        pLineCallParams->ulMinRate > pLineCallParams->ulMaxRate)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALRATE=%d:%d\n",
                    pLineCallParams->ulMinRate,pLineCallParams->ulMaxRate));
        return (NDIS_STATUS_TAPI_INVALRATE);
    }
    if (pLineCallParams->ulMaxRate && pLineCallParams->ulMaxRate < _56KBPS)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALRATE=%d:%d\n",
                    pLineCallParams->ulMinRate,pLineCallParams->ulMaxRate));
        return (NDIS_STATUS_TAPI_INVALRATE);
    }

    /*
    // Remember the TAPI call connection handle.
    */
    pBChannel->htCall = Request->htCall;

    /*
    // Since we only allow one call per line, we use the same handle.
    */
    Request->hdCall = (HDRV_CALL) pBChannel;

    /*
    // Dial the number if it's available, otherwise it may come via
    // OID_TAPI_DIAL.  Be aware the the phone number format may be
    // different for other applications.  I'm assuming an ASCII digits
    // string.
    */
    DialStringLength = (USHORT) Request->ulDestAddressSize;
    if (DialStringLength > 0)
    {
        PUCHAR                  pDestAddress;
        UCHAR                   DialString[CARD_MAX_DIAL_DIGITS+1];
        // Temporary copy of dial string.  One extra for NULL terminator.

        pDestAddress = ((PUCHAR)Request) + Request->ulDestAddressOffset;

        /*
        // Dial the number, but don't include the null terminator.
        */
        DialStringLength = CardCleanPhoneNumber(DialString,
                                                pDestAddress,
                                                DialStringLength);

        if (DialStringLength > 0)
        {
            /*
            // Save the call parameters.
            */
            pBChannel->MediaMode  = pLineCallParams->ulMediaMode;
            pBChannel->BearerMode = pLineCallParams->ulBearerMode;
            pBChannel->LinkSpeed  = pLineCallParams->ulMaxRate == 0 ?
                                    _64KBPS : pLineCallParams->ulMaxRate;

            DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                        ("#%d Call=0x%X CallState=0x%X DIALING: '%s'\n"
                         "Rate=%d-%d - MediaMode=0x%X - BearerMode=0x%X\n",
                        pBChannel->BChannelIndex,
                        pBChannel->htCall, pBChannel->CallState,
                        pDestAddress,
                        Request->LineCallParams.ulMinRate,
                        Request->LineCallParams.ulMaxRate,
                        Request->LineCallParams.ulMediaMode,
                        Request->LineCallParams.ulBearerMode
                        ));

            Status = DChannelMakeCall(pAdapter->pDChannel,
                                      pBChannel,
                                      DialString,
                                      DialStringLength,
                                      pLineCallParams);
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiDrop


@func

    This request drops or disconnects the specified call. User-to-user
    information can optionally be transmitted as part of the call disconnect.
    This function can be called by the application at any time. When
    OID_TAPI_DROP returns with success, the call should be idle.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_DROP | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_DROP
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulUserUserInfoSize;
        IN  UCHAR       UserUserInfo[1];

    } NDIS_TAPI_DROP, *PNDIS_TAPI_DROP;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiDrop(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_DROP Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiDrop")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulUserUserInfoSize=%d\n"
               "\tUserUserInfo=0x%X\n",
               Request->hdCall,
               Request->ulUserUserInfoSize,
               Request->UserUserInfo
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // The user wants to disconnect, so make it happen cappen.
    */
    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                ("#%d Call=0x%X CallState=0x%X\n",
                pBChannel->BChannelIndex,
                pBChannel->htCall, pBChannel->CallState));

    /*
    // Drop the call after flushing the transmit and receive buffers.
    */
    DChannelDropCall(pAdapter->pDChannel, pBChannel);

#if !defined(NDIS50_MINIPORT)
    /*
    // NDISWAN_BUG
    // Under some conditions, NDISWAN does not do a CLOSE_CALL,
    // so the line would be left unusable if we don't timeout
    // and force a close call condition.
    */
    NdisMSetTimer(&pBChannel->CallTimer, CARD_NO_CLOSECALL_TIMEOUT);
#endif // NDIS50_MINIPORT

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiCloseCall


@func

    This request deallocates the call after completing or aborting all
    outstanding asynchronous requests on the call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_CLOSE_CALL | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_CLOSE_CALL
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;

    } NDIS_TAPI_CLOSE_CALL, *PNDIS_TAPI_CLOSE_CALL;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiCloseCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CLOSE_CALL Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiCloseCall")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    /*
    // The results of this call.
    */
    NDIS_STATUS Status;

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n",
               Request->hdCall
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // Mark the link as closing, so no more packets will be accepted,
    // and when the last transmit is complete, the link will be closed.
    */
    if (!IsListEmpty(&pBChannel->TransmitBusyList))
    {
        DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                    ("#%d Call=0x%X CallState=0x%X PENDING\n",
                    pBChannel->BChannelIndex,
                    pBChannel->htCall, pBChannel->CallState));

        pBChannel->CallClosing = TRUE;
        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                    ("#%d Call=0x%X CallState=0x%X CLOSING\n",
                    pBChannel->BChannelIndex,
                    pBChannel->htCall, pBChannel->CallState));

        DChannelCloseCall(pAdapter->pDChannel, pBChannel);

        Status = NDIS_STATUS_SUCCESS;
    }

#if !defined(NDIS50_MINIPORT)
{
    /*
    // NDISWAN_BUG
    // Cancel the CARD_NO_CLOSECALL_TIMEOUT.
    */
    BOOLEAN                     TimerCancelled;
    // Flag tells whether call time-out routine was cancelled.

    NdisMCancelTimer(&pBChannel->CallTimer, &TimerCancelled);
}
#endif // NDIS50_MINIPORT

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiAccept


@func

    This request accepts the specified offered call. It may optionally send
    the specified user-to-user information to the calling party.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_ACCEPT | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_ACCEPT
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulUserUserInfoSize;
        IN  UCHAR       UserUserInfo[1];

    } NDIS_TAPI_ACCEPT, *PNDIS_TAPI_ACCEPT;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE
    NDIS_STATUS_TAPI_OPERATIONUNAVAIL

*/

NDIS_STATUS TspiAccept(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_ACCEPT Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiAccept")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulUserUserInfoSize=%d\n"
               "\tUserUserInfo=0x%X\n",
               Request->hdCall,
               Request->ulUserUserInfoSize,
               Request->UserUserInfo
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // Note that the call has been accepted, we should see and answer soon.
    */
    DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                ("#%d Call=0x%X CallState=0x%X ACCEPTING\n",
                pBChannel->BChannelIndex,
                pBChannel->htCall, pBChannel->CallState));

    TspiCallStateHandler(pAdapter, pBChannel, LINECALLSTATE_ACCEPTED, 0);

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiAnswer


@func

    This request answers the specified offering call.  It may optionally send
    the specified user-to-user information to the calling party.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_ANSWER | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_ANSWER
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulUserUserInfoSize;
        IN  UCHAR       UserUserInfo[1];

    } NDIS_TAPI_ANSWER, *PNDIS_TAPI_ANSWER;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiAnswer(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_ANSWER Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiAnswer")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    /*
    // The results of this call.
    */
    NDIS_STATUS Status;

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulUserUserInfoSize=%d\n"
               "\tUserUserInfo=0x%X\n",
               Request->hdCall,
               Request->ulUserUserInfoSize,
               Request->UserUserInfo
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                ("#%d Call=0x%X CallState=0x%X ANSWERING\n",
                pBChannel->BChannelIndex,
                pBChannel->htCall, pBChannel->CallState));

    Status = DChannelAnswer(pAdapter->pDChannel, pBChannel);

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiGetCallInfo


@func

    This request returns detailed information about the specified call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_CALL_INFO | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_CALL_INFO
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        OUT LINE_CALL_INFO  LineCallInfo;

    } NDIS_TAPI_GET_CALL_INFO, *PNDIS_TAPI_GET_CALL_INFO;

    typedef struct _LINE_CALL_INFO
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   hLine;
        ULONG   ulLineDeviceID;
        ULONG   ulAddressID;

        ULONG   ulBearerMode;
        ULONG   ulRate;
        ULONG   ulMediaMode;

        ULONG   ulAppSpecific;
        ULONG   ulCallID;
        ULONG   ulRelatedCallID;
        ULONG   ulCallParamFlags;
        ULONG   ulCallStates;

        ULONG   ulMonitorDigitModes;
        ULONG   ulMonitorMediaModes;
        LINE_DIAL_PARAMS    DialParams;

        ULONG   ulOrigin;
        ULONG   ulReason;
        ULONG   ulCompletionID;
        ULONG   ulNumOwners;
        ULONG   ulNumMonitors;

        ULONG   ulCountryCode;
        ULONG   ulTrunk;

        ULONG   ulCallerIDFlags;
        ULONG   ulCallerIDSize;
        ULONG   ulCallerIDOffset;
        ULONG   ulCallerIDNameSize;
        ULONG   ulCallerIDNameOffset;

        ULONG   ulCalledIDFlags;
        ULONG   ulCalledIDSize;
        ULONG   ulCalledIDOffset;
        ULONG   ulCalledIDNameSize;
        ULONG   ulCalledIDNameOffset;

        ULONG   ulConnectedIDFlags;
        ULONG   ulConnectedIDSize;
        ULONG   ulConnectedIDOffset;
        ULONG   ulConnectedIDNameSize;
        ULONG   ulConnectedIDNameOffset;

        ULONG   ulRedirectionIDFlags;
        ULONG   ulRedirectionIDSize;
        ULONG   ulRedirectionIDOffset;
        ULONG   ulRedirectionIDNameSize;
        ULONG   ulRedirectionIDNameOffset;

        ULONG   ulRedirectingIDFlags;
        ULONG   ulRedirectingIDSize;
        ULONG   ulRedirectingIDOffset;
        ULONG   ulRedirectingIDNameSize;
        ULONG   ulRedirectingIDNameOffset;

        ULONG   ulAppNameSize;
        ULONG   ulAppNameOffset;

        ULONG   ulDisplayableAddressSize;
        ULONG   ulDisplayableAddressOffset;

        ULONG   ulCalledPartySize;
        ULONG   ulCalledPartyOffset;

        ULONG   ulCommentSize;
        ULONG   ulCommentOffset;

        ULONG   ulDisplaySize;
        ULONG   ulDisplayOffset;

        ULONG   ulUserUserInfoSize;
        ULONG   ulUserUserInfoOffset;

        ULONG   ulHighLevelCompSize;
        ULONG   ulHighLevelCompOffset;

        ULONG   ulLowLevelCompSize;
        ULONG   ulLowLevelCompOffset;

        ULONG   ulChargingInfoSize;
        ULONG   ulChargingInfoOffset;

        ULONG   ulTerminalModesSize;
        ULONG   ulTerminalModesOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_INFO, *PLINE_CALL_INFO;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiGetCallInfo(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_INFO Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetCallInfo")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n",
               Request->hdCall
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    Request->LineCallInfo.ulNeededSize =
    Request->LineCallInfo.ulUsedSize = sizeof(Request->LineCallInfo);

    if (Request->LineCallInfo.ulNeededSize > Request->LineCallInfo.ulTotalSize)
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineCallInfo.ulTotalSize,
                   Request->LineCallInfo.ulNeededSize));
    }

    /*
    // The link has all the call information we need to return.
    */
    Request->LineCallInfo.hLine = (ULONG) (ULONG_PTR) pBChannel;
    Request->LineCallInfo.ulLineDeviceID = GET_DEVICEID_FROM_BCHANNEL(pAdapter, pBChannel);
    Request->LineCallInfo.ulAddressID = TSPI_ADDRESS_ID;

    Request->LineCallInfo.ulBearerMode = pBChannel->BearerMode;
    Request->LineCallInfo.ulRate = pBChannel->LinkSpeed;
    Request->LineCallInfo.ulMediaMode = pBChannel->MediaMode;

    Request->LineCallInfo.ulCallParamFlags = LINECALLPARAMFLAGS_IDLE;
    Request->LineCallInfo.ulCallStates = pBChannel->CallStatesMask;

    Request->LineCallInfo.ulAppSpecific = pBChannel->AppSpecificCallInfo;

    /*
    // We don't support any of the callerid functions.
    */
    Request->LineCallInfo.ulCallerIDFlags =
    Request->LineCallInfo.ulCalledIDFlags =
    Request->LineCallInfo.ulConnectedIDFlags =
    Request->LineCallInfo.ulRedirectionIDFlags =
    Request->LineCallInfo.ulRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiGetCallStatus


@func

    This request returns detailed information about the specified call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_CALL_STATUS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_CALL_STATUS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        OUT LINE_CALL_STATUS    LineCallStatus;

    } NDIS_TAPI_GET_CALL_STATUS, *PNDIS_TAPI_GET_CALL_STATUS;

    typedef struct _LINE_CALL_STATUS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulCallState;
        ULONG   ulCallStateMode;
        ULONG   ulCallPrivilege;
        ULONG   ulCallFeatures;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_STATUS, *PLINE_CALL_STATUS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiGetCallStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_CALL_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetCallStatus")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("hdCall=0x%X\n",
               Request->hdCall
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    Request->LineCallStatus.ulNeededSize =
    Request->LineCallStatus.ulUsedSize = sizeof(Request->LineCallStatus);

    if (Request->LineCallStatus.ulNeededSize > Request->LineCallStatus.ulTotalSize)
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineCallStatus.ulTotalSize,
                   Request->LineCallStatus.ulNeededSize));
    }

    /*
    // The link has all the call information.
    */
    Request->LineCallStatus.ulCallPrivilege = LINECALLPRIVILEGE_OWNER;
    Request->LineCallStatus.ulCallState = pBChannel->CallState;
    Request->LineCallStatus.ulCallStateMode = pBChannel->CallStateMode;

    /*
    // The call features depend on the call state.
    */
    switch (pBChannel->CallState)
    {
    case LINECALLSTATE_CONNECTED:
        Request->LineCallStatus.ulCallFeatures = LINECALLFEATURE_DROP;
        break;

    case LINECALLSTATE_OFFERING:
        Request->LineCallStatus.ulCallFeatures = LINECALLFEATURE_ACCEPT |
                                                 LINECALLFEATURE_ANSWER;

    case LINECALLSTATE_ACCEPTED:
        Request->LineCallStatus.ulCallFeatures = LINECALLFEATURE_ANSWER;
        break;
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiSetAppSpecific


@func

    This request sets the application-specific field of the specified call's
    LINECALLINFO structure.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_APP_SPECIFIC | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_APP_SPECIFIC
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulAppSpecific;

    } NDIS_TAPI_SET_APP_SPECIFIC, *PNDIS_TAPI_SET_APP_SPECIFIC;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiSetAppSpecific(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_APP_SPECIFIC Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetAppSpecific")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulAppSpecific=%d\n",
               Request->hdCall,
               Request->ulAppSpecific
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // The app wants us to save a ulong for him to associate with this call.
    */
    pBChannel->AppSpecificCallInfo = Request->ulAppSpecific;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiSetCallParams


@func

    This request sets certain call parameters for an existing call.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_CALL_PARAMS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_CALL_PARAMS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulBearerMode;
        IN  ULONG       ulMinRate;
        IN  ULONG       ulMaxRate;
        IN  BOOLEAN     bSetLineDialParams;
        IN  LINE_DIAL_PARAMS    LineDialParams;

    } NDIS_TAPI_SET_CALL_PARAMS, *PNDIS_TAPI_SET_CALL_PARAMS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiSetCallParams(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_CALL_PARAMS Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetCallParams")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulBearerMode=0x%X\n",
               "\tulMinRate=%d\n",
               "\tulMaxRate=%d\n",
               "\tbSetLineDialParams=%d\n",
               "\tLineDialParams=0x%X\n",
               Request->hdCall,
               Request->ulBearerMode,
               Request->ulMinRate,
               Request->ulMaxRate,
               Request->bSetLineDialParams,
               Request->LineDialParams
              ));

    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // Make sure the call parameters are valid for us.
    */
    if (Request->ulBearerMode & ~pBChannel->BearerModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALMEDIAMODE\n"));
        return (NDIS_STATUS_TAPI_INVALBEARERMODE);
    }
    if (Request->ulMinRate > _64KBPS ||
        Request->ulMinRate > Request->ulMaxRate)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALRATE=%d:%d\n",
                    Request->ulMinRate,Request->ulMaxRate));
        return (NDIS_STATUS_TAPI_INVALRATE);
    }
    if (Request->ulMaxRate && Request->ulMaxRate < _56KBPS)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALRATE=%d:%d\n",
                    Request->ulMinRate,Request->ulMaxRate));
        return (NDIS_STATUS_TAPI_INVALRATE);
    }

    /*
    // Make sure we've got an active call on this channel.
    */
    if (pBChannel->CallState == 0 ||
        pBChannel->CallState == LINECALLSTATE_IDLE ||
        pBChannel->CallState == LINECALLSTATE_DISCONNECTED)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLSTATE=0x%X\n",
                    pBChannel->CallState));
        return (NDIS_STATUS_TAPI_INVALCALLSTATE);
    }

    /*
    // RASTAPI only places calls through the MAKE_CALL interface.
    // So there's nothing to do here for the time being.
    */

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiSetMediaMode


@func

    This request changes a call's media mode as stored in the call's
    LINE_CALL_INFO structure.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_MEDIA_MODE | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_MEDIA_MODE
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulMediaMode;

    } NDIS_TAPI_SET_MEDIA_MODE, *PNDIS_TAPI_SET_MEDIA_MODE;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

*/

NDIS_STATUS TspiSetMediaMode(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_MEDIA_MODE Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetMediaMode")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdCall=0x%X\n"
               "\tulMediaMode=0x%X\n",
               Request->hdCall,
               Request->ulMediaMode
              ));
    /*
    // This request must be associated with a call.
    */
    pBChannel = GET_BCHANNEL_FROM_HDCALL(pAdapter, Request->hdCall);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALCALLHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    /*
    // Don't accept the request for media modes we don't support.
    */
    if (Request->ulMediaMode & ~pBChannel->MediaModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALMEDIAMODE\n"));
        return (NDIS_STATUS_TAPI_INVALMEDIAMODE);
    }

    /*
    // If you can detect different medias, you will need to setup to use
    // the selected media here.
    */
    pBChannel->MediaMode = Request->ulMediaMode & pBChannel->MediaModesCaps;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiCallStateHandler


@func

    <f TspiCallStateHandler> will indicate the given LINECALLSTATE to the
    Connection Wrapper if the event has been enabled by the wrapper.
    Otherwise the state information is saved, but no indication is made.

*/

VOID TspiCallStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN ULONG                    CallState,                  // @parm
    // The LINECALLSTATE event to be posted to TAPI/WAN.

    IN ULONG                    StateParam                  // @parm
    // This value depends on the event being posted, and some events will
    // pass in zero if they don't use this parameter.
    )
{
    DBG_FUNC("TspiCallStateHandler")

    NDIS_TAPI_EVENT             CallEvent;
    // The event structure passed to the Connection Wrapper.

    BOOLEAN                     TimerCancelled;
    // Flag tells whether call time-out routine was cancelled.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("#%d Call=0x%X CallState=0x%X "
               "NewCallState=0x%X Param=0x%X\n",
               pBChannel->BChannelIndex,
               pBChannel->htCall,
               pBChannel->CallState,
               CallState, StateParam
              ));

    /*
    // Cancel any call time-outs events associated with this link.
    // Don't cancel for network status indications.
    */
    if (CallState != LINECALLSTATE_PROCEEDING &&
        CallState != LINECALLSTATE_RINGBACK &&
        CallState != LINECALLSTATE_UNKNOWN)
    {
        NdisMCancelTimer(&pBChannel->CallTimer, &TimerCancelled);
    }

    /*
    // Init the optional parameters.  They will be set as needed below.
    */
    CallEvent.ulParam2 = StateParam;
    CallEvent.ulParam3 = pBChannel->MediaMode;

    /*
    // OUTGOING) The expected sequence of events for outgoing calls is:
    // 0, LINECALLSTATE_DIALTONE, LINECALLSTATE_DIALING,
    // LINECALLSTATE_PROCEEDING, LINECALLSTATE_RINGBACK,
    // LINECALLSTATE_CONNECTED, LINECALLSTATE_DISCONNECTED,
    // LINECALLSTATE_IDLE
    //
    // INCOMING) The expected sequence of events for incoming calls is:
    // 0, LINECALLSTATE_OFFERING, LINECALLSTATE_ACCEPTED,
    // LINECALLSTATE_CONNECTED, LINECALLSTATE_DISCONNECTED,
    // LINECALLSTATE_IDLE
    //
    // Under certain failure conditions, these sequences may be violated.
    // So I used ASSERTs to verify the normal state transitions which will
    // cause a debug break point if an unusual transition is detected.
    */
    switch (CallState)
    {
    case 0:
    case LINECALLSTATE_IDLE:
        /*
        // Make sure that an idle line is disconnected.
        */
        if (pBChannel->CallState != 0 &&
            pBChannel->CallState != LINECALLSTATE_IDLE &&
            pBChannel->CallState != LINECALLSTATE_DISCONNECTED)
        {
            DBG_WARNING(pAdapter, ("#%d NOT DISCONNECTED OldState=0x%X\n",
                        pBChannel->BChannelIndex, pBChannel->CallState));
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_DISCONNECTED,
                                 LINEDISCONNECTMODE_UNKNOWN);
        }
        pBChannel->CallStateMode = 0;
        break;

    case LINECALLSTATE_DIALTONE:
        ASSERT(pBChannel->CallState == 0);
        break;

    case LINECALLSTATE_DIALING:
        ASSERT(pBChannel->CallState == 0 ||
               pBChannel->CallState == LINECALLSTATE_DIALTONE);
        break;

    case LINECALLSTATE_PROCEEDING:
        ASSERT(pBChannel->CallState == LINECALLSTATE_DIALING ||
               pBChannel->CallState == LINECALLSTATE_PROCEEDING);
        break;

    case LINECALLSTATE_RINGBACK:
        ASSERT(pBChannel->CallState == LINECALLSTATE_DIALING ||
               pBChannel->CallState == LINECALLSTATE_PROCEEDING);
        break;

    case LINECALLSTATE_BUSY:
        ASSERT(pBChannel->CallState == LINECALLSTATE_DIALING ||
               pBChannel->CallState == LINECALLSTATE_PROCEEDING);
        pBChannel->CallStateMode = StateParam;
        break;

    case LINECALLSTATE_CONNECTED:
        ASSERT(pBChannel->CallState == LINECALLSTATE_DIALING ||
               pBChannel->CallState == LINECALLSTATE_RINGBACK ||
               pBChannel->CallState == LINECALLSTATE_PROCEEDING ||
               pBChannel->CallState == LINECALLSTATE_OFFERING ||
               pBChannel->CallState == LINECALLSTATE_ACCEPTED);
        pBChannel->CallStateMode = 0;
        break;

    case LINECALLSTATE_DISCONNECTED:
        ASSERT(pBChannel->CallState == 0 ||
               pBChannel->CallState == LINECALLSTATE_IDLE ||
               pBChannel->CallState == LINECALLSTATE_DIALING ||
               pBChannel->CallState == LINECALLSTATE_RINGBACK ||
               pBChannel->CallState == LINECALLSTATE_PROCEEDING ||
               pBChannel->CallState == LINECALLSTATE_OFFERING ||
               pBChannel->CallState == LINECALLSTATE_ACCEPTED ||
               pBChannel->CallState == LINECALLSTATE_CONNECTED ||
               pBChannel->CallState == LINECALLSTATE_DISCONNECTED);
        if (pBChannel->CallState != 0 &&
            pBChannel->CallState != LINECALLSTATE_IDLE &&
            pBChannel->CallState != LINECALLSTATE_DISCONNECTED)
        {
            pBChannel->CallStateMode = StateParam;
        }
        else
        {
            // Don't do anything if there is no call on this line.
            CallState = pBChannel->CallState;
        }
        break;

    case LINECALLSTATE_OFFERING:
        ASSERT(pBChannel->CallState == 0);
        break;

    case LINECALLSTATE_ACCEPTED:
        ASSERT(pBChannel->CallState == LINECALLSTATE_OFFERING);
        break;

    case LINECALLSTATE_UNKNOWN:
        // Unknown call state doesn't cause any change here.
        CallState = pBChannel->CallState;
        break;

    default:
        DBG_ERROR(pAdapter, ("#%d UNKNOWN CALLSTATE=0x%X IGNORED\n",
                  pBChannel->BChannelIndex, CallState));
        CallState = pBChannel->CallState;
        break;
    }
    /*
    // Change the current CallState and notify the Connection Wrapper if it
    // wants to know about this event.
    */
    if (pBChannel->CallState != CallState)
    {
        pBChannel->CallState = CallState;
        if (pBChannel->CallStatesMask & CallState)
        {
            CallEvent.htLine   = pBChannel->htLine;
            CallEvent.htCall   = pBChannel->htCall;
            CallEvent.ulMsg    = LINE_CALLSTATE;
            CallEvent.ulParam1 = CallState;
            NdisMIndicateStatus(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_STATUS_TAPI_INDICATION,
                    &CallEvent,
                    sizeof(CallEvent)
                    );
            pAdapter->NeedStatusCompleteIndication = TRUE;
        }
        else
        {
            DBG_NOTICE(pAdapter, ("#%d LINE_CALLSTATE=0x%X EVENT NOT ENABLED\n",
                       pBChannel->BChannelIndex, CallState));
        }
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL TspiCall TspiCall_c TspiCallTimerHandler


@func

    <f TspiCallTimerHandler> is called when the CallTimer timeout occurs.
    It will handle the event according to the current CallState and make
    the necessary indications and changes to the call state.

*/

VOID TspiCallTimerHandler(
    IN PVOID                    SystemSpecific1,            // @parm
    // UNREFERENCED_PARAMETER

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PVOID                    SystemSpecific2,            // @parm
    // UNREFERENCED_PARAMETER

    IN PVOID                    SystemSpecific3             // @parm
    // UNREFERENCED_PARAMETER
    )
{
    DBG_FUNC("TspiCallTimerHandler")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    DBG_ERROR(pAdapter, ("#%d TIMEOUT CallState=0x%X\n",
              pBChannel->BChannelIndex, pBChannel->CallState));

    switch (pBChannel->CallState)
    {
    case LINECALLSTATE_DIALTONE:
    case LINECALLSTATE_DIALING:
#if !defined(NDIS50_MINIPORT)
        // NDISWAN_BUG
        // NDIS will hang if we try to disconnect before proceeding state!
        TspiCallStateHandler(pAdapter, pBChannel, LINECALLSTATE_PROCEEDING, 0);
        // Fall through.
#endif // NDIS50_MINIPORT

    case LINECALLSTATE_PROCEEDING:
    case LINECALLSTATE_RINGBACK:
        /*
        // We did not get a connect from remote end,
        // so hangup and abort the call.
        */
        LinkLineError(pBChannel, WAN_ERROR_TIMEOUT);
        TspiCallStateHandler(pAdapter, pBChannel, LINECALLSTATE_IDLE, 0);
        break;

    case LINECALLSTATE_OFFERING:
    case LINECALLSTATE_ACCEPTED:
        /*
        // Call has been offered, but no one has answered, so reject the call.
        // And
        */
        DChannelRejectCall(pAdapter->pDChannel, pBChannel);
        TspiCallStateHandler(pAdapter, pBChannel, 0, 0);
        break;

    case LINECALLSTATE_DISCONNECTED:
        TspiCallStateHandler(pAdapter, pBChannel, LINECALLSTATE_IDLE, 0);
        break;

    default:
        break;
    }

    DBG_LEAVE(pAdapter);

    UNREFERENCED_PARAMETER(SystemSpecific1);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    UNREFERENCED_PARAMETER(SystemSpecific3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\tspiline.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TspiLine TspiLine_c

@module TspiLine.c |

    This module implements the Telephony Service Provider Interface for
    Line objects (TapiLine).

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TspiLine_c

@end

*/

#define  __FILEID__             TSPILINE_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "string.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL TspiLine TspiLine_c TspiOpen


@func

    This function opens the line device whose device ID is given, returning
    the miniport's handle for the device. The miniport must retain the
    Connection Wrapper's handle for the device for use in subsequent calls to
    the LINE_EVENT callback procedure.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_OPEN | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_OPEN
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  HTAPI_LINE  htLine;
        OUT HDRV_LINE   hdLine;

    } NDIS_TAPI_OPEN, *PNDIS_TAPI_OPEN;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_PENDING
    NDIS_STATUS_TAPI_ALLOCATED
    NDIS_STATUS_TAPI_NODRIVER

*/

NDIS_STATUS TspiOpen(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_OPEN          Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiOpen")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\tulDeviceID=%d\n"
               "\thtLine=0x%X\n",
               Request->ulDeviceID,
               Request->htLine
              ));

    /*
    // If there is no DChannel, we can't allow an open line.
    */
    if (pAdapter->pDChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODRIVER\n"));
        return (NDIS_STATUS_TAPI_NODRIVER);
    }

    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_DEVICEID(pAdapter, Request->ulDeviceID);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_NODEVICE\n"));
        return (NDIS_STATUS_TAPI_NODEVICE);
    }

    /*
    // Make sure the requested line device is not already in use.
    */
    if (BChannelOpen(pBChannel, Request->htLine) != NDIS_STATUS_SUCCESS)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_ALLOCATED\n"));
        return (NDIS_STATUS_TAPI_ALLOCATED);
    }

    /*
    // Tell the wrapper the line context and set the line/call state.
    */
    Request->hdLine = (HDRV_LINE) pBChannel;

    /*
    // Make sure the line is configured for dialing when we open up.
    */
    TspiLineDevStateHandler(pAdapter, pBChannel, LINEDEVSTATE_OPEN);

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiLine TspiLine_c TspiClose


@func

    This request closes the specified open line device after completing or
    aborting all outstanding calls and asynchronous requests on the device.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_CLOSE | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_CLOSE
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;

    } NDIS_TAPI_CLOSE, *PNDIS_TAPI_CLOSE;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_PENDING
    NDIS_STATUS_TAPI_INVALLINEHANDLE

*/

NDIS_STATUS TspiClose(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CLOSE         Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiClose")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n",
               Request->hdLine
              ));
    /*
    // This request must be associated with a line device.
    // And it must not be called until all calls are closed or idle.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL ||
        (pBChannel->DevState & LINEDEVSTATE_OPEN) == 0)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // Close the TAPI line device and release the channel.
    */
    BChannelClose(pBChannel);

    TspiLineDevStateHandler(pAdapter, pBChannel, LINEDEVSTATE_CLOSE);

    Result = NDIS_STATUS_SUCCESS;

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL TspiLine TspiLine_c TspiGetLineDevStatus


@func

    This request queries the specified open line device for its current status.
    The information returned is global to all addresses on the line.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_GET_LINE_DEV_STATUS | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_GET_LINE_DEV_STATUS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        OUT LINE_DEV_STATUS LineDevStatus;

    } NDIS_TAPI_GET_LINE_DEV_STATUS, *PNDIS_TAPI_GET_LINE_DEV_STATUS;

    typedef struct _LINE_DEV_STATUS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulNumOpens;
        ULONG   ulOpenMediaModes;
        ULONG   ulNumActiveCalls;
        ULONG   ulNumOnHoldCalls;
        ULONG   ulNumOnHoldPendCalls;
        ULONG   ulLineFeatures;
        ULONG   ulNumCallCompletions;
        ULONG   ulRingMode;
        ULONG   ulSignalLevel;
        ULONG   ulBatteryLevel;
        ULONG   ulRoamMode;

        ULONG   ulDevStatusFlags;

        ULONG   ulTerminalModesSize;
        ULONG   ulTerminalModesOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_DEV_STATUS, *PLINE_DEV_STATUS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALLINEHANDLE

*/

NDIS_STATUS TspiGetLineDevStatus(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_GET_LINE_DEV_STATUS Request,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiGetLineDevStatus")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n",
               Request->hdLine
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    Request->LineDevStatus.ulNeededSize =
    Request->LineDevStatus.ulUsedSize = sizeof(Request->LineDevStatus);

    if (Request->LineDevStatus.ulNeededSize > Request->LineDevStatus.ulTotalSize)
    {
        DBG_PARAMS(pAdapter,
                   ("STRUCTURETOOSMALL %d<%d\n",
                   Request->LineDevStatus.ulTotalSize,
                   Request->LineDevStatus.ulNeededSize));
    }

    /*
    // Return the current line status information.
    */
    Request->LineDevStatus.ulNumOpens = 1;

    Request->LineDevStatus.ulNumActiveCalls =
            pBChannel->CallState <= LINECALLSTATE_IDLE ? 0 : 1;

    Request->LineDevStatus.ulLineFeatures =
            pBChannel->CallState <= LINECALLSTATE_IDLE ?
                LINEFEATURE_MAKECALL : 0;

    Request->LineDevStatus.ulRingMode =
            pBChannel->CallState == LINECALLSTATE_OFFERING ? 1: 0;

    Request->LineDevStatus.ulDevStatusFlags =
            (pBChannel->DevState & LINEDEVSTATE_CONNECTED) ?
                LINEDEVSTATUSFLAGS_CONNECTED : 0;

    Request->LineDevStatus.ulDevStatusFlags |=
            (pBChannel->DevState & LINEDEVSTATE_INSERVICE) ?
                LINEDEVSTATUSFLAGS_INSERVICE : 0;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiLine TspiLine_c TspiSetDefaultMediaDetection


@func

    This request informs the miniport of the new set of media modes to detect
    for the indicated line (replacing any previous set).

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulMediaModes;

    } NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION, *PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALLINEHANDLE

@comm

    <f Note>:
    After a miniport NIC driver has received an OPEN request for a line, it
    may also receive one or more SET_DEFAULT_MEDIA_DETECTION requests. This
    latter request informs the NIC driver of the type(s) of incoming calls,
    with respect to media mode, it should indicate to the Connection Wrapper
    with the LINE_NEWCALL message. If an incoming call appears with a media
    mode type not specified in the last (successfully completed)
    SET_DEFAULT_MEDIA_DETECTION request for that line, the miniport should
    not indicate the new call to the Connection Wrapper. If a miniport does
    not receive a SET_DEFAULT_MEDIA_DETECTION request for a line, it should
    not indicate any incoming calls to the Connection Wrapper; that line is
    to be used only for outbound calls.

*/

NDIS_STATUS TspiSetDefaultMediaDetection(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetDefaultMediaDetection")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulMediaModes=0x%X\n",
               Request->hdLine,
               Request->ulMediaModes
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // Don't accept the request for media modes we don't support.
    */
    if (Request->ulMediaModes & ~pBChannel->MediaModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALMEDIAMODE\n"));
        return (NDIS_STATUS_TAPI_INVALMEDIAMODE);
    }

    /*
    // Set the media modes mask and make sure the adapter is ready to
    // accept incoming calls.  If you can detect different medias, you
    // will need to notify the approriate interface for the media detected.
    */
    pBChannel->MediaModesMask = Request->ulMediaModes & pBChannel->MediaModesCaps;

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiLine TspiLine_c XXX

@func

    This request is invoked by the Connection Wrapper whenever a client
    application uses LINEMAPPER as the dwDeviceID in the lineOpen function
    to request that lines be scanned to find one that supports the desired
    media mode(s) and call parameters. The Connection Wrapper scans based on
    the union of the desired media modes and the other media modes currently
    being monitored on the line, to give the miniport the opportunity to
    indicate if it cannot simultaneously monitor for all of the requested
    media modes. If the miniport can monitor for the indicated set of media
    modes AND support the capabilities indicated in CallParams, it replies
    with a success inidication. It leaves the active media monitoring modes
    for the line unchanged.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulMediaModes;
        IN  LINE_CALL_PARAMS    LineCallParams;

    } NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION, *PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION;

    typedef struct _LINE_CALL_PARAMS        // Defaults:
    {
        ULONG   ulTotalSize;                // ---------

        ULONG   ulBearerMode;               // voice
        ULONG   ulMinRate;                  // (3.1kHz)
        ULONG   ulMaxRate;                  // (3.1kHz)
        ULONG   ulMediaMode;                // interactiveVoice

        ULONG   ulCallParamFlags;           // 0
        ULONG   ulAddressMode;              // addressID
        ULONG   ulAddressID;                // (any available)

        LINE_DIAL_PARAMS DialParams;        // (0, 0, 0, 0)

        ULONG   ulOrigAddressSize;          // 0
        ULONG   ulOrigAddressOffset;
        ULONG   ulDisplayableAddressSize;
        ULONG   ulDisplayableAddressOffset;

        ULONG   ulCalledPartySize;          // 0
        ULONG   ulCalledPartyOffset;

        ULONG   ulCommentSize;              // 0
        ULONG   ulCommentOffset;

        ULONG   ulUserUserInfoSize;         // 0
        ULONG   ulUserUserInfoOffset;

        ULONG   ulHighLevelCompSize;        // 0
        ULONG   ulHighLevelCompOffset;

        ULONG   ulLowLevelCompSize;         // 0
        ULONG   ulLowLevelCompOffset;

        ULONG   ulDevSpecificSize;          // 0
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_PARAMS, *PLINE_CALL_PARAMS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_TAPI_INVALLINEHANDLE

*/

NDIS_STATUS TspiConditionalMediaDetection(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiConditionalMediaDetection")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulMediaModes=0x%X\n"
               "\tLineCallParams=0x%X\n",
               Request->hdLine,
               Request->ulMediaModes,
               &Request->LineCallParams
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // We don't expect user user info.
    */
    ASSERT(Request->LineCallParams.ulUserUserInfoSize == 0);

    /*
    // Don't accept the request for media modes we don't support.
    */
    if (Request->ulMediaModes & ~pBChannel->MediaModesCaps)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALMEDIAMODE\n"));
        return (NDIS_STATUS_TAPI_INVALMEDIAMODE);
    }

    DBG_RETURN(pAdapter, NDIS_STATUS_SUCCESS);
    return (NDIS_STATUS_SUCCESS);
}


/* @doc INTERNAL TspiLine TspiLine_c TspiSetStatusMessages


@func

    This request enables the Connection Wrapper to specify which notification
    messages the miniport should generate for events related to status changes
    for the specified line or any of its addresses. By default, address and
    line status reporting is initially disabled for a line.

@parm IN PMINIPORT_ADAPTER_OBJECT | pAdapter |
    A pointer to the Miniport's adapter context structure <t MINIPORT_ADAPTER_OBJECT>.
    This is the <t MiniportAdapterContext> we passed into <f NdisMSetAttributes>.

@parm IN PNDIS_TAPI_SET_STATUS_MESSAGES | Request |
    A pointer to the NDIS_TAPI request structure for this call.

@iex
    typedef struct _NDIS_TAPI_SET_STATUS_MESSAGES
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulLineStates;
        IN  ULONG       ulAddressStates;

    } NDIS_TAPI_SET_STATUS_MESSAGES, *PNDIS_TAPI_SET_STATUS_MESSAGES;

@rdesc This routine returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        This function always returns success.

*/

NDIS_STATUS TspiSetStatusMessages(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_TAPI_SET_STATUS_MESSAGES Request,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    )
{
    DBG_FUNC("TspiSetStatusMessages")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("\n\thdLine=0x%X\n"
               "\tulLineStates=0x%X\n"
               "\tulAddressStates=0x%X\n",
               Request->hdLine,
               Request->ulLineStates,
               Request->ulAddressStates
              ));
    /*
    // This request must be associated with a line device.
    */
    pBChannel = GET_BCHANNEL_FROM_HDLINE(pAdapter, Request->hdLine);
    if (pBChannel == NULL)
    {
        DBG_WARNING(pAdapter, ("Returning NDIS_STATUS_TAPI_INVALLINEHANDLE\n"));
        return (NDIS_STATUS_TAPI_INVALLINEHANDLE);
    }

    /*
    // TAPI may pass down more than we are capable of handling.
    // We have to accept the request, but can ignore the extras.
    */
    if (Request->ulLineStates & ~pBChannel->DevStatesCaps)
    {
        DBG_WARNING(pAdapter, ("ulLineStates=0x%X !< DevStatesCaps=0x%X\n",
                   Request->ulLineStates, pBChannel->DevStatesCaps));
        Result = NDIS_STATUS_TAPI_INVALPARAM;
    }

    /*
    // TAPI may pass down more than we are capable of handling.
    // We have to accept the request, but can ignore the extras.
    */
    if (Request->ulAddressStates & ~pBChannel->AddressStatesCaps)
    {
        DBG_WARNING(pAdapter, ("ulAddressStates=0x%X !< AddressStatesCaps=0x%X\n",
                   Request->ulAddressStates, pBChannel->AddressStatesCaps));
        Result = NDIS_STATUS_TAPI_INVALPARAM;
    }

    /*
    // Save the new event notification masks so we will only indicate the
    // appropriate events.
    */
    pBChannel->DevStatesMask     = Request->ulLineStates & pBChannel->DevStatesCaps;
    pBChannel->AddressStatesMask = Request->ulAddressStates & pBChannel->AddressStatesCaps;

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL TspiLine TspiLine_c TspiLineDevStateHandler


@func

    <f TspiLineDevStateHandler> will indicate the given LINEDEVSTATE to the
    Connection Wrapper if the event has been enabled by the wrapper.
    Otherwise the state information is saved, but no indication is made.

*/

VOID TspiLineDevStateHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN ULONG                    LineDevState                // @parm
    // The <t LINEDEVSTATE> event to be posted to TAPI/WAN.
    )
{
    DBG_FUNC("TspiLineDevStateHandler")

    NDIS_TAPI_EVENT             LineEvent;
    NDIS_TAPI_EVENT             CallEvent;
    // The event structure passed to the Connection Wrapper.

    ULONG                       NewCallState = 0;
    ULONG                       StateParam = 0;
    // The line state change may cause a call state change as well.

    DBG_ENTER(pAdapter);
    DBG_PARAMS(pAdapter,
              ("#%d OldState=0x%X "
               "NewState=0x%X\n",
               pBChannel->BChannelIndex,
               pBChannel->DevState,
               LineDevState
              ));

    LineEvent.ulParam2 = 0;
    LineEvent.ulParam3 = 0;

    /*
    // Handle the line state transition as needed.
    */
    switch (LineDevState)
    {
    case LINEDEVSTATE_RINGING:
        /*
        // We have an incoming call, see if there's anyone who cares.
        */
        if (pBChannel->CallState == 0 &&
            pBChannel->MediaModesMask)
        {
            LineEvent.ulParam2 = 1;     // only one RingMode
            NewCallState = LINECALLSTATE_OFFERING;
        }
        else
        {
            DChannelRejectCall(pAdapter->pDChannel, pBChannel);
        }
        break;

    case LINEDEVSTATE_CONNECTED:
        /*
        // The line has been connected, but we may already know this.
        */
        if ((pBChannel->DevState & LINEDEVSTATE_CONNECTED) == 0)
        {
            pBChannel->DevState |= LINEDEVSTATE_CONNECTED;
        }
        else
        {
            LineDevState = 0;
        }
        break;

    case LINEDEVSTATE_DISCONNECTED:
        /*
        // The line has been dis-connected, but we may already know this.
        // If not, this will effect any calls on the line.
        */
        if ((pBChannel->DevState & LINEDEVSTATE_CONNECTED) != 0)
        {
            pBChannel->DevState &= ~(LINEDEVSTATE_CONNECTED |
                                     LINEDEVSTATE_INSERVICE);
            NewCallState = LINECALLSTATE_DISCONNECTED;
            StateParam = LINEDISCONNECTMODE_NORMAL;
        }
        else
        {
            LineDevState = 0;
        }
        break;

    case LINEDEVSTATE_INSERVICE:
        /*
        // The line has been placed in service, but we may already know this.
        */
        if ((pBChannel->DevState & LINEDEVSTATE_INSERVICE) == 0)
        {
            pBChannel->DevState |= LINEDEVSTATE_INSERVICE;
        }
        else
        {
            LineDevState = 0;
        }
        break;

    case LINEDEVSTATE_OUTOFSERVICE:
        /*
        // The line has been taken out of service, but we may already know this.
        // If not, this will effect any calls on the line.
        */
        if ((pBChannel->DevState & LINEDEVSTATE_INSERVICE) != 0)
        {
            pBChannel->DevState &= ~LINEDEVSTATE_INSERVICE;
            NewCallState = LINECALLSTATE_DISCONNECTED;
            StateParam = LINEDISCONNECTMODE_UNKNOWN;
        }
        else
        {
            LineDevState = 0;
        }
        break;

    case LINEDEVSTATE_OPEN:
        pBChannel->DevState |= LINEDEVSTATE_OPEN;
        pAdapter->NumLineOpens++;
        break;

    case LINEDEVSTATE_CLOSE:
        pBChannel->DevState &= ~LINEDEVSTATE_OPEN;
        pAdapter->NumLineOpens--;
        break;
    }

    /*
    // If this is the first indication of an incoming call, we need to
    // let TAPI know about it so we can get a htCall handle associated
    // with it.
    */
    if (pBChannel->DevState & LINEDEVSTATE_OPEN)
    {
        if (NewCallState == LINECALLSTATE_OFFERING)
        {
            CallEvent.htLine   = pBChannel->htLine;
            CallEvent.htCall   = (HTAPI_CALL)0;
            CallEvent.ulMsg    = LINE_NEWCALL;
            CallEvent.ulParam1 = (ULONG) (ULONG_PTR) pBChannel;
            CallEvent.ulParam2 = 0;
            CallEvent.ulParam3 = 0;

            NdisMIndicateStatus(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_STATUS_TAPI_INDICATION,
                    &CallEvent,
                    sizeof(CallEvent)
                    );
            pAdapter->NeedStatusCompleteIndication = TRUE;
            pBChannel->htCall = (HTAPI_CALL)CallEvent.ulParam2;

            DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                       ("#%d Call=0x%X CallState=0x%X NEW_CALL\n",
                       pBChannel->BChannelIndex,
                       pBChannel->htCall, pBChannel->CallState));

            if (pBChannel->htCall == 0)
            {
                /*
                // TAPI won't accept the call, so toss it.
                */
                NewCallState = 0;
                LineDevState = 0;
            }
        }

        /*
        // Only send those line messages TAPI wants to hear about.
        */
        if (pBChannel->DevStatesMask & LineDevState)
        {
            LineEvent.htLine   = pBChannel->htLine;
            LineEvent.htCall   = pBChannel->htCall;
            LineEvent.ulMsg    = LINE_LINEDEVSTATE;
            LineEvent.ulParam1 = LineDevState;

            NdisMIndicateStatus(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_STATUS_TAPI_INDICATION,
                    &LineEvent,
                    sizeof(LineEvent)
                    );
            pAdapter->NeedStatusCompleteIndication = TRUE;
            DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                       ("#%d Line=0x%X LineState=0x%X\n",
                       pBChannel->BChannelIndex,
                       pBChannel->htLine, LineDevState));
        }
        else
        {
            DBG_NOTICE(pAdapter, ("#%d LINEDEVSTATE=0x%X EVENT NOT ENABLED\n",
                       pBChannel->BChannelIndex, LineDevState));
        }

        if (NewCallState != 0)
        {
            /*
            // Check to see if we need to disconnect the call, but only
            // if there is one active.
            */
            if (NewCallState == LINECALLSTATE_DISCONNECTED)
            {
                if (pBChannel->CallState != 0 &&
                    pBChannel->CallState != LINECALLSTATE_IDLE &&
                    pBChannel->CallState != LINECALLSTATE_DISCONNECTED)
                {
                    TspiCallStateHandler(pAdapter, pBChannel,
                                         NewCallState, StateParam);
#if defined(NDIS40_MINIPORT)
                    /*
                    // NDISWAN_BUG
                    // Under some conditions, NDISWAN does not do a CLOSE_CALL,
                    // so the line would be left unusable if we don't timeout
                    // and force a close call condition.
                    */
                    NdisMSetTimer(&pBChannel->CallTimer, CARD_NO_CLOSECALL_TIMEOUT);
#endif // NDIS50_MINIPORT
                }
            }
            else
            {
                TspiCallStateHandler(pAdapter, pBChannel,
                                     NewCallState, StateParam);
                if (NewCallState == LINECALLSTATE_OFFERING)
                {
                    /*
                    // If an offered call is not accepted within N seconds, we
                    // need to force the line back to an idle state.
                    */
                    NdisMSetTimer(&pBChannel->CallTimer, pAdapter->NoAcceptTimeOut);
                }
            }
        }
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\vtarget.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.



@doc INTERNAL TpiBuild vTarget vTarget_h

@module vTarget.h |

    This module defines the version information as displayed in the Windows
    file property sheet.  You must change the fields below as appropriate
    for your target.  This file is then included by <f vTarget\.rc> to
    defined the necessary elements of the target file's version resource.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vTarget_h

@end

*/

#ifndef _VTARGET_H_
#define _VTARGET_H_

// The following file should be included from the project's include directory
#include <vProduct.h>   // Product specific information

// Base name of this target.
#define VER_TARGET_STR                  VER_PRODUCT_STR
// File name this target is distributed under.
#define VER_ORIGINAL_FILE_NAME_STR      DEFINE_STRING(VER_TARGET_STR ".sys")
// Description displayed in the Windows file property sheet - limit to 40 characters.
#define VER_FILE_DESCRIPTION_STR        DEFINE_STRING(VER_PRODUCT_STR \
                                        " NDIS WAN/TAPI Miniport for Windows.")
// Take credit for a job well done...
#define VER_INTERNAL_NAME_STR           "larryh@tpi.com"
// Look in winver.h for the proper settings of these values.
#define VER_FILE_OS                     VOS__WINDOWS32      // dwFileOS
#define VER_FILE_TYPE                   VFT_DRV             // dwFileType
#define VER_FILE_SUB_TYPE               VFT2_DRV_NETWORK    // dwFileSubtype

#endif // _VTARGET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\vprodnum.h ===
// WARNING --- DO NOT CHANGE THIS FILE --- WARNING
// It is updated automatically by the TpiBuild procedure using VerInc.exe.
#define VER_PRODUCT_MAJOR_NUM      0
#define VER_PRODUCT_MINOR_NUM      7
#define VER_PRODUCT_SUB_MINOR_NUM  0
#define VER_PRODUCT_BUILD_NUM      24
#define VER_PRODUCT_MAJOR_STR      "0"
#define VER_PRODUCT_MINOR_STR      "07"
#define VER_PRODUCT_SUB_MINOR_STR  "00"
#define VER_PRODUCT_BUILD_STR      "0024"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\vproduct.h ===
/*

                                                                             
    (C) Copyright 1999 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiBuild vProduct vProduct_h

@module vProduct.h |

    This module defines the product version information.  It is included by 
    all the target components of the project by including <f vTarget\.h>.

    <f Note>:
    This file should not be changed.  The definitions used by this file 
    are defined in <f vVendor\.h>, <f vTarget\.h>, <f vProdNum\.h>, and 
    <f vTargNum\.h>

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vProduct_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic Versioning Overview |

    This section describes the interfaces defined in <f vProduct\.h>,
    <f vVendor\.h>, <f vTarget\.h>, <f vProdNum\.h>, and <f vTargNum\.h>

    A module is usually just one component of an entire product, so we've
    defined the versioning information for the module so that it can be
    easily included into a complete product package.
    
@flag <f vTarget\.rc> |
    Included this into your module specific rc file.  Do not change.
    You must remove any existing versioning information from your rc file.
    Place this file in a common include directory for the product.

@flag <f vTarget\.h> |
    Defines the module specific version information such as file name, type, etc.
    One of these files would exist for each component included in your product.

@flag <f vTargNum\.h> |
    Is meant to be updated whenever you make a change to a specific module.
    One of these files would exist for each component included in your product.
    This is separated from the rest of the versioning files so it can be easily 
    updated with a tool or script.
    
@flag <f vVendor\.h> |
    Defines the vendor specific version information such as company name,
    copyright. etc.  It is separate to allow easier OEM customization.
    Place this file in a common include directory for the product.
    
@flag <f vProdNum\.h> |
    Is meant to be updated whenever you release a new product version.
    This is separated from the rest of the versioning files so it can be easily 
    updated with a tool or script.
    Place this file in a common include directory for the product.
    
@flag <f vLang\.h> |
    Defines the language to be used to record the version information.
    If this file is modified for another language, you will generally have 
    to create localized versions of the vVendor.h and vTarget.h files as well.
    Place this file in a common include directory for the product.
    
@flag <f vProduct\.rc> |
    Is included by <f vTarget\.rc>.  Do not change.
    Place this file in a common include directory for the product.

@flag <f vProduct\.h> |
    Is included by <f vTarget\.h>.  You should not change this file unless you
    want to change the way version numbers are represented for all modules in
    your product.
    Place this file in a common include directory for the product.

*/

#ifndef _VPRODUCT_H_
#define _VPRODUCT_H_

#if !defined(_VTARGET_H_)
#  error You should not include vProduct.h directly, include vTarget.h instead.
#endif

// Only include winver.h if RC_INVOKED.  Otherwise we don't need it.
#if defined(RC_INVOKED)
# if defined(WIN32)
#  include <winver.h>
# else
#  include <ver.h>
# endif
#endif

#include "vVendor.h"    // Edit this file to change vendor specific information
#include "vLang.h"      // Edit this file to change language specific information

// The following file should be included from the target's include directory
#include "vTargNum.h"   // Target version information

#if !defined(VER_FILE_MAJOR_NUM) || !defined(VER_FILE_MINOR_NUM) || \
    !defined(VER_FILE_SUB_MINOR_NUM)
#  error Your vTargNum.h file is corrupt or missing required VER_xxx_NUM fields.
#endif
#if !defined(VER_FILE_MAJOR_STR) || !defined(VER_FILE_MINOR_STR) || \
    !defined(VER_FILE_SUB_MINOR_STR)
#  error Your vTargNum.h file is corrupt or missing required VER_xxx_STR fields.
#endif

// The following file should be included from the project's include directory
#include "vProdNum.h"   // Product version and build information

#if !defined(VER_PRODUCT_MAJOR_NUM) || !defined(VER_PRODUCT_MINOR_NUM) || \
    !defined(VER_PRODUCT_SUB_MINOR_NUM) || !defined(VER_PRODUCT_BUILD_NUM)
#  error Your vProdNum.h file is corrupt or missing required VER_xxx_NUM fields.
#endif
#if !defined(VER_PRODUCT_MAJOR_STR) || !defined(VER_PRODUCT_MINOR_STR) || \
    !defined(VER_PRODUCT_SUB_MINOR_STR) || !defined(VER_PRODUCT_BUILD_STR)
#  error Your vProdNum.h file is corrupt or missing required VER_xxx_STR fields.
#endif

// Macro used to force C preprocessor to concatenate string defines
#define DEFINE_STRING(STR)              STR

// Macro to make this stuff easier to read.
#define VER_STR_CAT(sep,maj,min,sub,bld) maj sep min sep sub sep bld

// PRODUCT version information is displayed in the About box of each
// component and is stored in the registry during installation.
// The About box code must get the value from the registry instead of
// using these macros in order to get the currently installed version.
// Therefore, these macros should only be used by the installer.
#define VER_PRODUCT_VERSION_NUM         ((VER_PRODUCT_MAJOR_NUM << 24) | \
                                            (VER_PRODUCT_MINOR_NUM << 16) | \
                                            (VER_PRODUCT_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_PRODUCT_VERSION_NUM_RC      VER_PRODUCT_MAJOR_NUM,\
                                            VER_PRODUCT_MINOR_NUM,\
                                            VER_PRODUCT_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_PRODUCT_VERSION_STR         VER_STR_CAT(".",\
                                            VER_PRODUCT_MAJOR_STR,\
                                            VER_PRODUCT_MINOR_STR,\
                                            VER_PRODUCT_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_PRODUCT_VERSION_STR_RC      VER_STR_CAT(".",\
                                            VER_PRODUCT_MAJOR_STR,\
                                            VER_PRODUCT_MINOR_STR,\
                                            VER_PRODUCT_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

// COMPONENT version information is displayed in the ProductVersion 
// field of a file's Windows property sheet.  It is the same as the
// FILE version info with the addition of the build number.
#define VER_COMPONENT_VERSION_NUM       ((VER_FILE_MAJOR_NUM << 24) | \
                                            (VER_FILE_MINOR_NUM << 16) | \
                                            (VER_FILE_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_COMPONENT_VERSION_NUM_RC    VER_FILE_MAJOR_NUM,\
                                            VER_FILE_MINOR_NUM,\
                                            VER_FILE_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_COMPONENT_VERSION_STR       VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_COMPONENT_VERSION_STR_RC    VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

// FILE version information is an abbreviated component version info
// and is displayed at the top of a file's Windows property sheet.
#define VER_FILE_VERSION_NUM            ((VER_FILE_MAJOR_NUM << 24) | \
                                            (VER_FILE_MINOR_NUM << 16) | \
                                            (VER_FILE_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_FILE_VERSION_NUM_RC         VER_FILE_MAJOR_NUM,\
                                            VER_FILE_MINOR_NUM,\
                                            VER_FILE_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_FILE_VERSION_STR            VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_FILE_VERSION_STR_RC         VER_FILE_MAJOR_STR "."\
                                            VER_FILE_MINOR_STR "."\
                                            VER_FILE_SUB_MINOR_STR

#endif /* _VPRODUCT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\muxim\public.h ===
/*++
Copyright (c) 1990-2000    Microsoft Corporation All Rights Reserved

Module Name:

    public.h

Abstract:

    This module contains the common declarations shared by driver
    and user applications.

Author:

     
Environment:

    user and kernel
Notes:


Revision History:


--*/
#ifndef __PUBLIC_H
#define __PUBLIC_H

//
// To support ioctls from user-mode:
//

#define LINKNAME_STRING     L"\\DosDevices\\Mux"
#define NTDEVICE_STRING     L"\\Device\\Mux"

#define  MUX_CUSTOM_EVENT      1

#define NOTIFY_SIGNATURE       0xAFCDABAB

typedef struct _NOTIFY_CUSTOM_EVENT {
  ULONG           uSignature;
  ULONG           uEvent;
  WCHAR           szMiniport[1];
} NOTIFY_CUSTOM_EVENT, *PNOTIFY_CUSTOM_EVENT;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\muxim\mux.h ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    mux.h

Abstract:

    Data structures, defines and function prototypes for the MUX driver.

Environment:

    Kernel mode only.

Revision History:


--*/

#ifdef NDIS51_MINIPORT
#define MUX_MAJOR_NDIS_VERSION         5
#define MUX_MINOR_NDIS_VERSION         1
#else
#define MUX_MAJOR_NDIS_VERSION         4
#define MUX_MINOR_NDIS_VERSION         0
#endif

#ifdef NDIS51
#define MUX_PROT_MAJOR_NDIS_VERSION    5
#define MUX_PROT_MINOR_NDIS_VERSION    0
#else
#define MUX_PROT_MAJOR_NDIS_VERSION    4
#define MUX_PROT_MINOR_NDIS_VERSION    0
#endif

#define TAG 'SxuM'
#define WAIT_INFINITE 0

#if DBG
//
// Debug levels: lower values indicate higher urgency
//
#define MUX_EXTRA_LOUD       20
#define MUX_VERY_LOUD        10
#define MUX_LOUD             8
#define MUX_INFO             6
#define MUX_WARN             4
#define MUX_ERROR            2
#define MUX_FATAL            0

extern INT                muxDebugLevel;


#define DBGPRINT(lev, Fmt)                                   \
    {                                                        \
        if ((lev) <= muxDebugLevel)                          \
        {                                                    \
            DbgPrint("MUX-IM: ");                            \
            DbgPrint Fmt;                                    \
        }                                                    \
    }
#else

#define DBGPRINT(lev, Fmt)

#endif //DBG

// forward declarations
typedef struct _ADAPT ADAPT, *PADAPT;
typedef struct _VELAN VELAN, *PVELAN;
typedef struct _MUX_NDIS_REQUEST MUX_NDIS_REQUEST, *PMUX_NDIS_REQUEST;


typedef
VOID
(*PMUX_REQ_COMPLETE_HANDLER) (
    IN PADAPT                           pAdapt,
    IN struct _MUX_NDIS_REQUEST *       pMuxRequest,
    IN NDIS_STATUS                      Status
    );

// This OID specifies the NDIS version in use by the
// virtual miniport driver. The high byte is the major version.
// The low byte is the minor version.
#define VELAN_DRIVER_VERSION            ((MUX_MAJOR_NDIS_VERSION << 8) + \
                                         (MUX_MINOR_NDIS_VERSION))

// media type, we use ethernet, change if necessary
#define VELAN_MEDIA_TYPE                NdisMedium802_3

// change to your company name instead of using Microsoft
#define VELAN_VENDOR_DESC               "Microsoft"

// Highest byte is the NIC byte plus three vendor bytes, they are normally
// obtained from the NIC
#define VELAN_VENDOR_ID                 0x00FFFFFF

#define VELAN_MAX_MCAST_LIST            32
#define VELAN_MAX_SEND_PKTS             5

#define ETH_MAX_PACKET_SIZE             1514
#define ETH_MIN_PACKET_SIZE             60
#define ETH_HEADER_SIZE                 14


#define VELAN_SUPPORTED_FILTERS ( \
            NDIS_PACKET_TYPE_DIRECTED      | \
            NDIS_PACKET_TYPE_MULTICAST     | \
            NDIS_PACKET_TYPE_BROADCAST     | \
            NDIS_PACKET_TYPE_PROMISCUOUS   | \
            NDIS_PACKET_TYPE_ALL_MULTICAST)

#define MUX_ADAPTER_PACKET_FILTER           \
            NDIS_PACKET_TYPE_PROMISCUOUS

//
// Define flag bits we set on send packets to prevent
// loopback from occurring on the lower binding.
//
#ifdef NDIS51

#define MUX_SEND_PACKET_FLAGS           NDIS_FLAGS_DONT_LOOPBACK

#else

#define NDIS_FLAGS_SKIP_LOOPBACK_WIN2K  0x400
#define MUX_SEND_PACKET_FLAGS           (NDIS_FLAGS_DONT_LOOPBACK |  \
                                         NDIS_FLAGS_SKIP_LOOPBACK_WIN2K)
#endif
                                         

#define MIN_PACKET_POOL_SIZE            255
#define MAX_PACKET_POOL_SIZE            4096

typedef UCHAR   MUX_MAC_ADDRESS[6];

//
// Our context stored in packets sent down to the
// lower binding. Note that this sample driver only forwards
// sends down; it does not originate sends itself.
// These packets are allocated from the SendPacketPool.
//
typedef struct _MUX_SEND_RSVD
{
    PVELAN              pVElan;             // originating ELAN
    PNDIS_PACKET        pOriginalPacket;    // original packet

} MUX_SEND_RSVD, *PMUX_SEND_RSVD;

#define MUX_RSVD_FROM_SEND_PACKET(_pPkt)            \
        ((PMUX_SEND_RSVD)(_pPkt)->ProtocolReserved)

//
// Our context stored in each packet forwarded up to an
// ELAN from a lower binding. The original packet refers to
// a packet indicated up to us that should be returned via
// NdisReturnPackets when our packet is returned to us. This
// is set to NULL there isn't such a packet.
// These packets are allocated from the RecvPacketPool.
//
typedef struct _MUX_RECV_RSVD
{
    PNDIS_PACKET        pOriginalPacket;

} MUX_RECV_RSVD, *PMUX_RECV_RSVD;

#define MUX_RSVD_FROM_RECV_PACKET(_pPkt)            \
        ((PMUX_RECV_RSVD)(_pPkt)->MiniportReserved)

//
// Make sure we don't attempt to use more than the allowed
// room in MiniportReserved on received packets.
//
C_ASSERT(sizeof(MUX_RECV_RSVD) <= sizeof(((PNDIS_PACKET)0)->MiniportReserved));


//
// Out context stored in each packet that we use to forward
// a TransferData request to the lower binding.
// These packets are allocated from the RecvPacketPool.
//
typedef struct _MUX_TD_RSVD
{
    PVELAN              pVElan;
    PNDIS_PACKET        pOriginalPacket;
} MUX_TD_RSVD, *PMUX_TD_RSVD;

#define MUX_RSVD_FROM_TD_PACKET(_pPkt)              \
        ((PMUX_TD_RSVD)(_pPkt)->ProtocolReserved)


//
// Default values:
//
#define MUX_DEFAULT_LINK_SPEED          100000  // in 100s of bits/sec
#define MUX_DEFAULT_LOOKAHEAD_SIZE      512


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT            DriverObject,
    IN PUNICODE_STRING           RegistryPath
    );

NTSTATUS
PtDispatch(
    IN PDEVICE_OBJECT            DeviceObject,
    IN PIRP                      Irp
    );

NDIS_STATUS
PtRegisterDevice(
    VOID
    );

NDIS_STATUS
PtDeregisterDevice(
    VOID
   );
//
// Protocol proto-types
//

VOID
PtOpenAdapterComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_STATUS               Status,
    IN    NDIS_STATUS               OpenErrorStatus
    );


VOID
PtQueryAdapterInfo(
    IN  PADAPT                      pAdapt
    );


VOID
PtQueryAdapterSync(
    IN  PADAPT                      pAdapt,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       InformationBuffer,
    IN  ULONG                       InformationBufferLength
    );


VOID
PtRequestAdapterAsync(
    IN  PADAPT                      pAdapt,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       InformationBuffer,
    IN  ULONG                       InformationBufferLength,
    IN  PMUX_REQ_COMPLETE_HANDLER   pCallback
    );

VOID
PtCloseAdapterComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_STATUS               Status
    );


VOID
PtResetComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_STATUS               Status
    );


VOID
PtRequestComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNDIS_REQUEST             NdisRequest,
    IN    NDIS_STATUS               Status
    );


VOID
PtCompleteForwardedRequest(
    IN PADAPT                       pAdapt,
    IN PMUX_NDIS_REQUEST            pMuxNdisRequest,
    IN NDIS_STATUS                  Status
    );

VOID
PtPostProcessPnPCapabilities(
    IN PVELAN                       pVElan,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength
    );

VOID
PtCompleteBlockingRequest(
    IN PADAPT                       pAdapt,
    IN PMUX_NDIS_REQUEST            pMuxNdisRequest,
    IN NDIS_STATUS                  Status
    );

VOID
PtDiscardCompletedRequest(
    IN PADAPT                       pAdapt,
    IN PMUX_NDIS_REQUEST            pMuxNdisRequest,
    IN NDIS_STATUS                  Status
    );


VOID
PtStatus(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_STATUS               GeneralStatus,
    IN    PVOID                     StatusBuffer,
    IN    UINT                      StatusBufferSize
    );


VOID
PtStatusComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext
    );


VOID
PtSendComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNDIS_PACKET              Packet,
    IN    NDIS_STATUS               Status
    );


VOID
PtTransferDataComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNDIS_PACKET              Packet,
    IN    NDIS_STATUS               Status,
    IN    UINT                      BytesTransferred
    );


NDIS_STATUS
PtReceive(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_HANDLE               MacReceiveContext,
    IN    PVOID                     HeaderBuffer,
    IN    UINT                      HeaderBufferSize,
    IN    PVOID                     LookAheadBuffer,
    IN    UINT                      LookaheadBufferSize,
    IN    UINT                      PacketSize
    );


VOID
PtReceiveComplete(
    IN    NDIS_HANDLE               ProtocolBindingContext
    );


INT
PtReceivePacket(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNDIS_PACKET              Packet
    );


VOID
PtBindAdapter(
    OUT   PNDIS_STATUS              Status,
    IN    NDIS_HANDLE               BindContext,
    IN    PNDIS_STRING              DeviceName,
    IN    PVOID                     SystemSpecific1,
    IN    PVOID                     SystemSpecific2
    );


VOID
PtUnbindAdapter(
    OUT   PNDIS_STATUS              Status,
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    NDIS_HANDLE               UnbindContext
    );



NDIS_STATUS
PtPNPHandler(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNET_PNP_EVENT            pNetPnPEvent
    );


NDIS_STATUS
PtCreateAndStartVElan(
    IN  PADAPT                      pAdapt,
    IN  PNDIS_STRING                pVElanKey
);

PVELAN
PtAllocateAndInitializeVElan(
    IN PADAPT                       pAdapt,
    IN PNDIS_STRING                 pVElanKey
    );

VOID
PtDeallocateVElan(
    IN PVELAN                   pVElan
    );

VOID
PtStopVElan(
    IN  PVELAN                      pVElan
);

VOID
PtUnlinkVElanFromAdapter(
    IN PVELAN                       pVElan
);

PVELAN
PtFindVElan(
    IN    PADAPT                    pAdapt,
    IN    PNDIS_STRING              pElanKey
);


VOID
PtBootStrapVElans(
    IN  PADAPT                      pAdapt
);

VOID
PtReferenceVElan(
    IN    PVELAN                    pVElan,
    IN    PUCHAR                    String
    );

ULONG
PtDereferenceVElan(
    IN    PVELAN                    pVElan,
    IN    PUCHAR                    String
    );

BOOLEAN
PtReferenceAdapter(
    IN    PADAPT                    pAdapt,
    IN    PUCHAR                    String
    );

ULONG
PtDereferenceAdapter(
    IN    PADAPT                    pAdapt,
    IN    PUCHAR                    String
    );

//
// Miniport proto-types
//
NDIS_STATUS
MPInitialize(
    OUT   PNDIS_STATUS              OpenErrorStatus,
    OUT   PUINT                     SelectedMediumIndex,
    IN    PNDIS_MEDIUM              MediumArray,
    IN    UINT                      MediumArraySize,
    IN    NDIS_HANDLE               MiniportAdapterHandle,
    IN    NDIS_HANDLE               WrapperConfigurationContext
    );

VOID
MPSendPackets(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    PPNDIS_PACKET             PacketArray,
    IN    UINT                      NumberOfPackets
    );

NDIS_STATUS
MPQueryInformation(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    NDIS_OID                  Oid,
    IN    PVOID                     InformationBuffer,
    IN    ULONG                     InformationBufferLength,
    OUT   PULONG                    BytesWritten,
    OUT   PULONG                    BytesNeeded
    );

NDIS_STATUS
MPSetInformation(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    NDIS_OID                  Oid,
    IN    PVOID                     InformationBuffer,
    IN    ULONG                     InformationBufferLength,
    OUT   PULONG                    BytesRead,
    OUT   PULONG                    BytesNeeded
    );

VOID
MPReturnPacket(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    PNDIS_PACKET              Packet
    );

NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET                Packet,
    OUT PUINT                       BytesTransferred,
    IN  NDIS_HANDLE                 MiniportAdapterContext,
    IN  NDIS_HANDLE                 MiniportReceiveContext,
    IN  UINT                        ByteOffset,
    IN  UINT                        BytesToTransfer
    );

VOID
MPHalt(
    IN    NDIS_HANDLE               MiniportAdapterContext
    );


NDIS_STATUS
MPSetPacketFilter(
    IN    PVELAN                    pVElan,
    IN    ULONG                     PacketFilter
    );

NDIS_STATUS
MPSetMulticastList(
    IN PVELAN                       pVElan,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      pBytesRead,
    OUT PULONG                      pBytesNeeded
    );

PUCHAR
MacAddrToString(PVOID In
    );

VOID
MPGenerateMacAddr(
    PVELAN                          pVElan
);

#ifdef NDIS51_MINIPORT

VOID
MPCancelSendPackets(
    IN    NDIS_HANDLE              MiniportAdapterContext,
    IN    PVOID                    CancelId
    );

VOID
MPDevicePnPEvent(
    IN NDIS_HANDLE                 MiniportAdapterContext,
    IN NDIS_DEVICE_PNP_EVENT       DevicePnPEvent,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength
    );


VOID
MPAdapterShutdown(
    IN NDIS_HANDLE                  MiniportAdapterContext
    );

#endif //NDIS51_MINIPORT

VOID
MPUnload(
    IN    PDRIVER_OBJECT            DriverObject
    );

NDIS_STATUS
MPForwardRequest(
    IN PVELAN                       pVElan,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      BytesReadOrWritten,
    OUT PULONG                      BytesNeeded
    );


//
// Super-structure for NDIS_REQUEST, to allow us to keep context
// about requests sent down to a lower binding.
//
typedef struct _MUX_NDIS_REQUEST
{
    PVELAN                      pVElan;     // Set iff this is a forwarded
                                            // request from a VELAN.
    NDIS_STATUS                 Status;     // Completion status
    NDIS_EVENT                  Event;      // Used to block for completion.
    PMUX_REQ_COMPLETE_HANDLER   pCallback;  // Called on completion of request
    NDIS_REQUEST                Request;

} MUX_NDIS_REQUEST, *PMUX_NDIS_REQUEST;


//
// The ADAPT object represents a binding to a lower adapter by
// the protocol edge of this driver. Based on the configured
// Upper bindings, zero or more virtual miniport devices (VELANs)
// are created above this binding.
//
typedef struct _ADAPT
{
    // Chain adapters. Access to this is protected by the global lock.
    LIST_ENTRY                  Link;

    // References to this adapter.
    ULONG                       RefCount;

    // Handle to the lower adapter, used in NDIS calls referring
    // to this adapter.
    NDIS_HANDLE                 BindingHandle;

    // List of all the virtual ELANs created on this lower binding
    LIST_ENTRY                  VElanList;

    // Length of above list.
    ULONG                       VElanCount;

    // String used to access configuration for this binding.
    NDIS_STRING                 ConfigString;

    // Open Status. Used by bind/halt for Open/Close Adapter status.
    NDIS_STATUS                 Status;

    NDIS_EVENT                  Event;

    //
    // Packet filter set to the underlying adapter. This is
    // a combination (union) of filter bits set on all
    // attached VELAN miniports.
    //
    ULONG                       PacketFilter;

    // Medium of the underlying Adapter.
    NDIS_MEDIUM                 Medium;

    // Link speed of the underlying adapter.
    ULONG                       LinkSpeed;

    // Max lookahead size for the underlying adapter.
    ULONG                       MaxLookAhead;

    // Power state of the underlying adapter
    NDIS_DEVICE_POWER_STATE     PtDevicePowerState;

    // Ethernet address of the underlying adapter.
    UCHAR                       CurrentAddress[ETH_LENGTH_OF_ADDRESS];

#ifndef WIN9X
    //
    // Read/Write lock: allows multiple readers but only a single
    // writer. Used to protect the VELAN list and fields (e.g. packet
    // filter) shared on an ADAPT by multiple VELANs. Code that
    // needs to traverse the VELAN list safely acquires a READ lock.
    // Code that needs to safely modify the VELAN list or shared
    // fields acquires a WRITE lock (which also excludes READers).
    //
    // See macros MUX_ACQUIRE_ADAPT_xxx/MUX_RELEASE_ADAPT_xxx below.
    //
    // TBD - if we want to support this on Win9X, reimplement this!
    //
    NDIS_RW_LOCK                ReadWriteLock;
#endif // WIN9X

} ADAPT, *PADAPT;


//
// VELAN object represents a virtual ELAN instance and its
// corresponding virtual miniport adapter.
//
typedef struct _VELAN
{
    // Link into parent adapter's VELAN list.
    LIST_ENTRY                  Link;

    // References to this VELAN.
    ULONG                       RefCount;

    // Parent ADAPT.
    PADAPT                      pAdapt;

    // Copy of BindingHandle from ADAPT.
    NDIS_HANDLE                 BindingHandle;

    // Adapter handle for NDIS up-calls related to this virtual miniport.
    NDIS_HANDLE                 MiniportAdapterHandle;

    // Virtual miniport's power state.
    NDIS_DEVICE_POWER_STATE     MPDevicePowerState;

    // Has our Halt entry point been called?
    BOOLEAN                     MiniportHalting;

    // Do we need to indicate receive complete?
    BOOLEAN                     IndicateRcvComplete;

    // Do we need to indicate status complete?
    BOOLEAN                     IndicateStatusComplete;

    // Synchronization fields
    BOOLEAN                     MiniportInitPending;
    NDIS_EVENT                  MiniportInitEvent;

    // Uncompleted Sends/Requests to the adapter below.
    ULONG                       OutstandingSends;

    // Count outstanding indications, including received
    // packets, passed up to protocols on this VELAN.
    ULONG                       OutstandingReceives;

    // Packet pool for send packets
    NDIS_HANDLE                 SendPacketPoolHandle;

    // Packet pool for receive packets
    NDIS_HANDLE                 RecvPacketPoolHandle;

    // A request block that is used to forward a request presented
    // to the virtual miniport, to the lower binding. Since NDIS
    // serializes requests to a miniport, we only need one of these
    // per VELAN.
    //
    MUX_NDIS_REQUEST            Request;        
    PULONG                      BytesNeeded;
    PULONG                      BytesReadOrWritten;
    // Have we queued a request because the lower binding is
    // at a low power state?
    BOOLEAN                     QueuedRequest;

    // Have we started to deinitialize this VELAN?
    BOOLEAN                     DeInitializing;

    // configuration
    UCHAR                       PermanentAddress[ETH_LENGTH_OF_ADDRESS];
    UCHAR                       CurrentAddress[ETH_LENGTH_OF_ADDRESS];

    NDIS_STRING                 CfgDeviceName;  // used as the unique
                                                // ID for the VELAN
    ULONG                       VElanNumber;    // logical Elan number


    //
    //  ----- Buffer Management: Header buffers and Protocol buffers ----
    //

    // Some standard miniport parameters (OID values).
    ULONG                       PacketFilter;
    ULONG                       LookAhead;
    ULONG                       LinkSpeed;

    ULONG                       MaxBusySends;
    ULONG                       MaxBusyRecvs;

    // Packet counts
    ULONG64                     GoodTransmits;
    ULONG64                     GoodReceives;
    ULONG                       NumTxSinceLastAdjust;

    // Count of transmit errors
    ULONG                       TxAbortExcessCollisions;
    ULONG                       TxLateCollisions;
    ULONG                       TxDmaUnderrun;
    ULONG                       TxLostCRS;
    ULONG                       TxOKButDeferred;
    ULONG                       OneRetry;
    ULONG                       MoreThanOneRetry;
    ULONG                       TotalRetries;
    ULONG                       TransmitFailuresOther;

    // Count of receive errors
    ULONG                       RcvCrcErrors;
    ULONG                       RcvAlignmentErrors;
    ULONG                       RcvResourceErrors;
    ULONG                       RcvDmaOverrunErrors;
    ULONG                       RcvCdtFrames;
    ULONG                       RcvRuntErrors;
#if IEEE_VLAN_SUPPORT    
    ULONG                       RcvFormatErrors;
    ULONG                       RcvVlanIdErrors;
#endif    
    ULONG                       RegNumTcb;

    // Multicast list
    MUX_MAC_ADDRESS             McastAddrs[VELAN_MAX_MCAST_LIST];
    ULONG                       McastAddrCount;
#if IEEE_VLAN_SUPPORT
    ULONG                       VlanId;
    NDIS_HANDLE                 BufferPoolHandle;
    NPAGED_LOOKASIDE_LIST       TagLookaside;
#endif
    NDIS_STATUS                 LastIndicatedStatus;
    NDIS_STATUS                 LatestUnIndicateStatus;


} VELAN, *PVELAN;

#if IEEE_VLAN_SUPPORT

#define TPID                            0x0081    
//
// Define tag_header structure
//
typedef struct _VLAN_TAG_HEADER
{
    UCHAR       TagInfo[2];    
} VLAN_TAG_HEADER, *PVLAN_TAG_HEADER;

//
// Define context struct that used when the lower driver
// uses non-packet indication. It contains the original
// context, the tagging information and the tag-header
// length
// 
typedef struct _MUX_RCV_CONTEXT
{
    ULONG                   TagHeaderLen;
    NDIS_PACKET_8021Q_INFO  NdisPacket8021QInfo;
    PVOID                   MacRcvContext;
}MUX_RCV_CONTEXT, *PMUX_RCV_CONTEXT;

//
// Macro definitions for VLAN support
// 
#define VLAN_TAG_HEADER_SIZE        4 

#define VLANID_DEFAULT              0 
#define VLAN_ID_MAX                 0xfff
#define VLAN_ID_MIN                 0x0

#define USER_PRIORITY_MASK          0xe0
#define CANONICAL_FORMAT_ID_MASK    0x10
#define HIGH_VLAN_ID_MASK           0x0F

//
// Get information for tag headre
// 
#define GET_CANONICAL_FORMAT_ID_FROM_TAG(_pTagHeader)  \
    ( _pTagHeader->TagInfo[0] & CANONICAL_FORMAT_ID_MASK)   
    
#define GET_USER_PRIORITY_FROM_TAG(_pTagHeader)  \
    ( _pTagHeader->TagInfo[0] & USER_PRIORITY_MASK)
    
#define GET_VLAN_ID_FROM_TAG(_pTagHeader)   \
    (((USHORT)(_pTagHeader->TagInfo[0] & HIGH_VLAN_ID_MASK) << 8) | (USHORT)(_pTagHeader->TagInfo[1]))
     
//
// Clear the tag header struct
// 
#define INITIALIZE_TAG_HEADER_TO_ZERO(_pTagHeader) \
{                                                  \
     _pTagHeader->TagInfo[0] = 0;                  \
     _pTagHeader->TagInfo[1] = 0;                  \
}
     
//
// Set VLAN information to tag header 
// Before we called all the set macro, first we need to initialize pTagHeader  to be 0
// 
#define SET_CANONICAL_FORMAT_ID_TO_TAG(_pTagHeader, CanonicalFormatId)  \
     _pTagHeader->TagInfo[0] |= ((UCHAR)CanonicalFormatId << 4)

#define SET_USER_PRIORITY_TO_TAG(_pTagHeader, UserPriority)  \
     _pTagHeader->TagInfo[0] |= ((UCHAR)UserPriority << 5)

#define SET_VLAN_ID_TO_TAG(_pTagHeader, VlanId)                 \
{                                                               \
    _pTagHeader->TagInfo[0] |= (((UCHAR)VlanId >> 8) & 0x0f);   \
     _pTagHeader->TagInfo[1] |= (UCHAR)VlanId;\
}

//
// Copy tagging information in the indicated frame to per packet info
// 
#define COPY_TAG_INFO_FROM_HEADER_TO_PACKET_INFO(_Ieee8021qInfo, _pTagHeader)                                   \
{                                                                                                               \
    (_Ieee8021qInfo).TagHeader.UserPriority = ((_pTagHeader->TagInfo[0] & USER_PRIORITY_MASK) >> 5);              \
    (_Ieee8021qInfo).TagHeader.CanonicalFormatId = ((_pTagHeader->TagInfo[0] & CANONICAL_FORMAT_ID_MASK) >> 4);   \
    (_Ieee8021qInfo).TagHeader.VlanId = (((USHORT)(_pTagHeader->TagInfo[0] & HIGH_VLAN_ID_MASK) << 8)| (USHORT)(_pTagHeader->TagInfo[1]));                                                                \
}

//
// Function to handle tagging on sending side
// 
NDIS_STATUS
MPHandleSendTagging(
    IN  PVELAN              pVElan,
    IN  PNDIS_PACKET        Packet,
    IN  OUT PNDIS_PACKET    MyPacket
    );

//
// Functions to handle tagging on receiving side with packet indication
//
NDIS_STATUS
PtHandleRcvTagging(
    IN  PVELAN              pVElan,
    IN  PNDIS_PACKET        Packet,
    IN  OUT PNDIS_PACKET    MyPacket
    );

#endif //IEEE_VLAN_SUPPORT

//
// Macro definitions for others.
//

//
// Is a given power state a low-power state?
//
#define MUX_IS_LOW_POWER_STATE(_PwrState)                       \
            ((_PwrState) > NdisDeviceStateD0)

#define MUX_INIT_ADAPT_RW_LOCK(_pAdapt) \
            NdisInitializeReadWriteLock(&(_pAdapt)->ReadWriteLock)


#define MUX_ACQUIRE_ADAPT_READ_LOCK(_pAdapt, _pLockState)       \
            NdisAcquireReadWriteLock(&(_pAdapt)->ReadWriteLock, \
                                     FALSE,                     \
                                     _pLockState)

#define MUX_RELEASE_ADAPT_READ_LOCK(_pAdapt, _pLockState)       \
            NdisReleaseReadWriteLock(&(_pAdapt)->ReadWriteLock, \
                                     _pLockState)

#define MUX_ACQUIRE_ADAPT_WRITE_LOCK(_pAdapt, _pLockState)      \
            NdisAcquireReadWriteLock(&(_pAdapt)->ReadWriteLock, \
                                     TRUE,                      \
                                     _pLockState)

#define MUX_RELEASE_ADAPT_WRITE_LOCK(_pAdapt, _pLockState)      \
            NdisReleaseReadWriteLock(&(_pAdapt)->ReadWriteLock, \
                                     _pLockState)

#define MUX_INCR_PENDING_RECEIVES(_pVElan)                      \
            NdisInterlockedIncrement(&pVElan->OutstandingReceives)

#define MUX_DECR_PENDING_RECEIVES(_pVElan)                      \
            NdisInterlockedDecrement(&pVElan->OutstandingReceives)

#define MUX_INCR_PENDING_SENDS(_pVElan)                         \
            NdisInterlockedIncrement(&pVElan->OutstandingSends)

#define MUX_DECR_PENDING_SENDS(_pVElan)                         \
            NdisInterlockedDecrement(&pVElan->OutstandingSends)




#define MUX_INCR_STATISTICS(_pUlongVal)                         \
            NdisInterlockedIncrement(_pUlongVal)

#define MUX_INCR_STATISTICS64(_pUlong64Val)                     \
{                                                               \
    PLARGE_INTEGER      _pLargeInt = (PLARGE_INTEGER)_pUlong64Val;\
    if (NdisInterlockedIncrement(&_pLargeInt->LowPart) == 0)    \
    {                                                           \
        NdisInterlockedIncrement(&_pLargeInt->HighPart);        \
    }                                                           \
}

#define ASSERT_AT_PASSIVE()                                     \
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL)



//
// Simple Mutual Exclusion constructs used in preference to
// using KeXXX calls since we don't have Mutex calls in NDIS.
// These can only be called at passive IRQL.
//

typedef struct _MUX_MUTEX
{
    ULONG                   Counter;
    ULONG                   ModuleAndLine;  // useful for debugging

} MUX_MUTEX, *PMUX_MUTEX;

#define MUX_INIT_MUTEX(_pMutex)                                 \
{                                                               \
    (_pMutex)->Counter = 0;                                     \
    (_pMutex)->ModuleAndLine = 0;                               \
}

#define MUX_ACQUIRE_MUTEX(_pMutex)                              \
{                                                               \
    while (NdisInterlockedIncrement(&((_pMutex)->Counter)) != 1)\
    {                                                           \
        NdisInterlockedDecrement(&((_pMutex)->Counter));        \
        NdisMSleep(10000);                                      \
    }                                                           \
    (_pMutex)->ModuleAndLine = (MODULE_NUMBER << 16) | __LINE__;\
}

#define MUX_RELEASE_MUTEX(_pMutex)                              \
{                                                               \
    (_pMutex)->ModuleAndLine = 0;                               \
    NdisInterlockedDecrement(&(_pMutex)->Counter);              \
}


//
// Global variables
//
extern NDIS_HANDLE           ProtHandle, DriverHandle;
extern NDIS_MEDIUM           MediumArray[1];
extern NDIS_SPIN_LOCK        GlobalLock;
extern MUX_MUTEX             GlobalMutex;
extern LIST_ENTRY            AdapterList;
extern ULONG                 NextVElanNumber;


//
// Module numbers for debugging
//
#define MODULE_MUX          'X'
#define MODULE_PROT         'P'
#define MODULE_MINI         'M'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\muxim\miniport.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    NDIS Miniport Entry points and utility functions for the NDIS
    MUX Intermediate Miniport sample. The driver exposes zero or more
    Virtual Ethernet LANs (VELANs) as NDIS miniport instances over
    each lower (protocol-edge) binding to an underlying adapter.

Environment:

    Kernel mode.

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define MODULE_NUMBER           MODULE_MINI

NDIS_OID VElanSupportedOids[] =
{
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_RCV_CRC_ERROR,
    OID_GEN_TRANSMIT_QUEUE_LENGTH,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_802_3_XMIT_DEFERRED,
    OID_802_3_XMIT_MAX_COLLISIONS,
    OID_802_3_RCV_OVERRUN,
    OID_802_3_XMIT_UNDERRUN,
    OID_802_3_XMIT_HEARTBEAT_FAILURE,
    OID_802_3_XMIT_TIMES_CRS_LOST,
    OID_802_3_XMIT_LATE_COLLISIONS,
    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
    OID_PNP_ADD_WAKE_UP_PATTERN,
    OID_PNP_REMOVE_WAKE_UP_PATTERN,
#if IEEE_VLAN_SUPPORT
    OID_GEN_VLAN_ID,
#endif    
    OID_PNP_ENABLE_WAKE_UP
    
};


NDIS_STATUS
MPInitialize(
    OUT PNDIS_STATUS               OpenErrorStatus,
    OUT PUINT                      SelectedMediumIndex,
    IN  PNDIS_MEDIUM               MediumArray,
    IN  UINT                       MediumArraySize,
    IN  NDIS_HANDLE                MiniportAdapterHandle,
    IN  NDIS_HANDLE                WrapperConfigurationContext
    )
/*++

Routine Description:

    This is the Miniport Initialize routine which gets called as a
    result of our call to NdisIMInitializeDeviceInstanceEx.
    The context parameter which we pass there is the VELan structure
    which we retrieve here.

Arguments:

    OpenErrorStatus            Not used by us.
    SelectedMediumIndex        Place-holder for what media we are using
    MediumArray                Array of ndis media passed down to us to pick from
    MediumArraySize            Size of the array
    MiniportAdapterHandle       The handle NDIS uses to refer to us
    WrapperConfigurationContext    For use by NdisOpenConfiguration

Return Value:

    NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
    UINT                i;
    PVELAN              pVElan;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    NDIS_MEDIUM         Medium;
    NDIS_HANDLE         ConfigurationHandle;
    PVOID               NetworkAddress;

#if IEEE_VLAN_SUPPORT
    PNDIS_CONFIGURATION_PARAMETER   Params;
    NDIS_STRING                     strVlanId = NDIS_STRING_CONST("VlanID");
#endif
    
    //
    // Start off by retrieving our virtual miniport context (VELAN) and 
    // storing the Miniport handle in it.
    //
    pVElan = NdisIMGetDeviceContext(MiniportAdapterHandle);

    DBGPRINT(MUX_LOUD, ("==> Miniport Initialize: VELAN %p\n", pVElan));

    ASSERT(pVElan != NULL);
    ASSERT(pVElan->pAdapt != NULL);

    do
    {
        pVElan->MiniportAdapterHandle = MiniportAdapterHandle;

        for (i = 0; i < MediumArraySize; i++)
        {
            if (MediumArray[i] == VELAN_MEDIA_TYPE)
            {
                *SelectedMediumIndex = i;
                break;
            }
        }

        if (i == MediumArraySize)
        {
            Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            break;
        }

        //
        // Access configuration parameters for this miniport.
        //
        NdisOpenConfiguration(
            &Status,
            &ConfigurationHandle,
            WrapperConfigurationContext);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }


        NdisReadNetworkAddress(
            &Status,
            &NetworkAddress,
            &i,
            ConfigurationHandle);

        //
        // If there is a NetworkAddress override, use it 
        //
        if ((Status == NDIS_STATUS_SUCCESS) && (i == ETH_LENGTH_OF_ADDRESS))
        {
            ETH_COPY_NETWORK_ADDRESS(
                pVElan->CurrentAddress,
                NetworkAddress);
        }
        else
        {
            MPGenerateMacAddr(pVElan);
        }
   
#if IEEE_VLAN_SUPPORT
        //
        // Read VLAN ID
        //
        NdisReadConfiguration(
                &Status,
                &Params,
                ConfigurationHandle,
                &strVlanId,
                NdisParameterInteger);
        if (Status == NDIS_STATUS_SUCCESS)
        {
            //
            // Check for out of bound
            //
            if (Params->ParameterData.IntegerData > VLAN_ID_MAX)
            {
                pVElan->VlanId = VLANID_DEFAULT;
            }
            else
            {
                pVElan->VlanId = Params->ParameterData.IntegerData;
            }
        }
        else 
        {
            //
            // Should fail the initialization or use default value
            //
            pVElan->VlanId = VLANID_DEFAULT;
            Status = NDIS_STATUS_SUCCESS;
            
        }
                
#endif    
        
        NdisCloseConfiguration(ConfigurationHandle);

        //
        // Set the attributes now. NDIS_ATTRIBUTE_DESERIALIZE enables us
        // to make up-calls to NDIS from arbitrary execution contexts.
        // This also forces us to protect our data structures using
        // spinlocks where appropriate. Also in this case NDIS does not queue
        // packets on our behalf.
        //
        NdisMSetAttributesEx(MiniportAdapterHandle,
                             pVElan,
                             0,                                        
                             NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT    |
                                NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT|
                                NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |
                                NDIS_ATTRIBUTE_DESERIALIZE |
                                NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                             0);


        //
        // Create an ioctl interface
        //
        (VOID)PtRegisterDevice();

        Status = NDIS_STATUS_SUCCESS;
    } while (FALSE);
    
    //
    // If we had received an UnbindAdapter notification on the underlying
    // adapter, we would have blocked that thread waiting for the IM Init
    // process to complete. Wake up any such thread.
    //
    // See PtUnbindAdapter for more details.
    //
    ASSERT(pVElan->MiniportInitPending == TRUE);
    pVElan->MiniportInitPending = FALSE;
    NdisSetEvent(&pVElan->MiniportInitEvent);

    DBGPRINT(MUX_INFO, ("<== Miniport Initialize: VELAN %p, Status %x\n", pVElan, Status));

    return Status;
}

VOID
MPSendPackets(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    PPNDIS_PACKET             PacketArray,
    IN    UINT                      NumberOfPackets
    )
/*++

Routine Description:

    Send Packet Array handler. Called by NDIS whenever a protocol
    bound to our VELAN miniport sends one or more packets.

    We forward each packet to the lower binding.

    NOTE: NDIS will not Halt this VELAN miniport until all
    these packets are "send-completed", and we don't unbind
    the lower binding until all VELANs are halted. Therefore
    we don't need locks or references on VELAN or ADAPT structures.

Arguments:

    MiniportAdapterContext    Pointer to our VELAN
    PacketArray               Set of packets to send
    NumberOfPackets           Length of above array

Return Value:

    None - we call NdisMSendComplete whenever we are done with a packet.

--*/
{
    PVELAN          pVElan = (PVELAN)MiniportAdapterContext;
    PADAPT          pAdapt = pVElan->pAdapt;
    PNDIS_PACKET    Packet, MyPacket;
    NDIS_STATUS     Status;
    PVOID           MediaSpecificInfo;
    ULONG           MediaSpecificInfoSize;
    UINT            i;

    
    for (i = 0; i < NumberOfPackets; i++)
    {
        Packet = PacketArray[i];

        //
        // Allocate a new packet to encapsulate data from the original.
        //
        NdisAllocatePacket(&Status,
                           &MyPacket,
                           pVElan->SendPacketPoolHandle);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            PMUX_SEND_RSVD      pSendReserved;

            pSendReserved = MUX_RSVD_FROM_SEND_PACKET(MyPacket);
            pSendReserved->pOriginalPacket = Packet;
            pSendReserved->pVElan = pVElan;

            MyPacket->Private.Flags = NdisGetPacketFlags(Packet) |
                                        MUX_SEND_PACKET_FLAGS;

            MyPacket->Private.Head = Packet->Private.Head;
            MyPacket->Private.Tail = Packet->Private.Tail;
#ifdef WIN9X
            //
            // Work around the fact that NDIS does not initialize this
            // to FALSE on Win9x.
            //
            MyPacket->Private.ValidCounts = FALSE;
#endif // WIN9X

            //
            // Copy OOB data to the new packet.
            //
            NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(MyPacket),
                           NDIS_OOB_DATA_FROM_PACKET(Packet),
                           sizeof(NDIS_PACKET_OOB_DATA));
            //
            // Copy relevant parts of per packet info into the new packet.
            //
#ifndef WIN9X
            NdisIMCopySendPerPacketInfo(MyPacket, Packet);
#endif

            //
            // Copy Media specific information.
            //
            NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(Packet,
                                                &MediaSpecificInfo,
                                                &MediaSpecificInfoSize);

            if (MediaSpecificInfo || MediaSpecificInfoSize)
            {
                NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(MyPacket,
                                                    MediaSpecificInfo,
                                                    MediaSpecificInfoSize);
            }

#if IEEE_VLAN_SUPPORT
            Status = MPHandleSendTagging(pVElan, Packet, MyPacket);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                NdisFreePacket(MyPacket);
                NdisMSendComplete(pVElan->MiniportAdapterHandle,
                                    Packet,
                                    Status);
                continue;
            }
#endif                

            //
            // Make note of the upcoming send.
            //
            MUX_INCR_PENDING_SENDS(pVElan);

            //
            // Send it to the lower binding.
            //
            NdisSend(&Status,
                     pAdapt->BindingHandle,
                     MyPacket);

            if (Status != NDIS_STATUS_PENDING)
            {
                PtSendComplete((NDIS_HANDLE)pAdapt,
                               MyPacket,
                               Status);
            }
        }
        else
        {
            //
            // Failed to allocate a packet.
            //
            break;
        }
    }

    //
    // If we bailed out above, fail any unprocessed sends.
    //
    while (i < NumberOfPackets)
    {
        NdisMSendComplete(pVElan->MiniportAdapterHandle,
                          PacketArray[i],
                          NDIS_STATUS_RESOURCES);
        i++;
    }
}


NDIS_STATUS
MPQueryInformation(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    NDIS_OID                  Oid,
    IN    PVOID                     InformationBuffer,
    IN    ULONG                     InformationBufferLength,
    OUT   PULONG                    BytesWritten,
    OUT   PULONG                    BytesNeeded
    )
/*++

Routine Description:

    Entry point called by NDIS to query for the value of the specified OID.
    All OID values are responded to right here, since this is a virtual
    device (not pass-through).

Arguments:

    MiniportAdapterContext      Pointer to the adapter structure
    Oid                         Oid for this query
    InformationBuffer           Buffer for information
    InformationBufferLength     Size of this buffer
    BytesWritten                Specifies how much info is written
    BytesNeeded                 In case the buffer is smaller than 
                                what we need, tell them how much is needed


Return Value:

    Return code from the NdisRequest below.

--*/
{
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    PVELAN                      pVElan;
    NDIS_HARDWARE_STATUS HardwareStatus = NdisHardwareStatusReady;
    NDIS_MEDIUM                 Medium = VELAN_MEDIA_TYPE;
    UCHAR                       VendorDesc[] = VELAN_VENDOR_DESC;
    ULONG                       ulInfo;
    ULONG64                     ulInfo64;
    USHORT                      usInfo;
    UCHAR                       arrInfo[ETH_LENGTH_OF_ADDRESS];
    PVOID                       pInfo = (PVOID) &ulInfo;
    ULONG                       ulInfoLen = sizeof(ulInfo);
    // Should we forward the request to the miniport below?
    BOOLEAN                     bForwardRequest = FALSE;

    
    pVElan = (PVELAN) MiniportAdapterContext;

    // Initialize the result
    *BytesWritten = 0;
    *BytesNeeded = 0;

    switch (Oid)
    {
        case OID_GEN_SUPPORTED_LIST:
            pInfo = (PVOID) VElanSupportedOids;
            ulInfoLen = sizeof(VElanSupportedOids);
            break;

        case OID_GEN_SUPPORTED_GUIDS:
            //
            // Do NOT forward this down, otherwise we will
            // end up with spurious instances of private WMI
            // classes supported by the lower driver(s).
            //
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;

        case OID_GEN_HARDWARE_STATUS:
            pInfo = (PVOID) &HardwareStatus;
            ulInfoLen = sizeof(NDIS_HARDWARE_STATUS);
            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
            pInfo = (PVOID) &Medium;
            ulInfoLen = sizeof(NDIS_MEDIUM);
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_MAXIMUM_LOOKAHEAD:
            ulInfo = pVElan->LookAhead - ETH_HEADER_SIZE;
            break;            
            
        case OID_GEN_MAXIMUM_FRAME_SIZE:
            ulInfo = ETH_MAX_PACKET_SIZE - ETH_HEADER_SIZE;

#if IEEE_VLAN_SUPPORT
            ulInfo -= VLAN_TAG_HEADER_SIZE;
#endif
            
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
            ulInfo = (ULONG) ETH_MAX_PACKET_SIZE;
#if IEEE_VLAN_SUPPORT
            ulInfo -= VLAN_TAG_HEADER_SIZE;
#endif            
            break;
            
        case OID_GEN_MAC_OPTIONS:
            ulInfo = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA | 
                     NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                     NDIS_MAC_OPTION_NO_LOOPBACK;

#if IEEE_VLAN_SUPPORT
            ulInfo |= (NDIS_MAC_OPTION_8021P_PRIORITY |
                        NDIS_MAC_OPTION_8021Q_VLAN);
#endif
            
            break;

        case OID_GEN_LINK_SPEED:
            bForwardRequest = TRUE;
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            ulInfo = ETH_MAX_PACKET_SIZE * pVElan->MaxBusySends;
#if IEEE_VLAN_SUPPORT
            ulInfo -= VLAN_TAG_HEADER_SIZE * pVElan->MaxBusySends;
#endif            
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            ulInfo = ETH_MAX_PACKET_SIZE * pVElan->MaxBusyRecvs;
#if IEEE_VLAN_SUPPORT
            ulInfo -= VLAN_TAG_HEADER_SIZE * pVElan->MaxBusyRecvs;
#endif            
            
            break;

        case OID_GEN_VENDOR_ID:
            ulInfo = VELAN_VENDOR_ID;
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            pInfo = VendorDesc;
            ulInfoLen = sizeof(VendorDesc);
            break;
            
        case OID_GEN_VENDOR_DRIVER_VERSION:
            ulInfo = VELAN_VENDOR_ID;
            break;

        case OID_GEN_DRIVER_VERSION:
            usInfo = (USHORT) VELAN_DRIVER_VERSION;
            pInfo = (PVOID) &usInfo;
            ulInfoLen = sizeof(USHORT);
            break;

        case OID_802_3_PERMANENT_ADDRESS:
            pInfo = pVElan->PermanentAddress;
            ulInfoLen = ETH_LENGTH_OF_ADDRESS;
            break;

        case OID_802_3_CURRENT_ADDRESS:
            pInfo = pVElan->CurrentAddress;
            ulInfoLen = ETH_LENGTH_OF_ADDRESS;
            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:
            ulInfo = VELAN_MAX_MCAST_LIST;
            break;

        case OID_GEN_MAXIMUM_SEND_PACKETS:
            ulInfo = VELAN_MAX_SEND_PKTS;
            break;

        case OID_GEN_MEDIA_CONNECT_STATUS:
            //
            // Get this from the adapter below.
            //
            bForwardRequest = TRUE;
            break;

        case OID_PNP_QUERY_POWER:
            // simply succeed this.
            ulInfoLen = 0;
            break;

        case OID_PNP_CAPABILITIES:
        case OID_PNP_WAKE_UP_PATTERN_LIST:
            //
            // Pass down these power management/PNP OIDs.
            //
            bForwardRequest = TRUE;
            break;

        case OID_GEN_XMIT_OK:
            ulInfo64 = pVElan->GoodTransmits;
            pInfo = &ulInfo64;
            if (InformationBufferLength >= sizeof(ULONG64) ||
                InformationBufferLength == 0)
            {
                ulInfoLen = sizeof(ULONG64);
            }
            else
            {
                ulInfoLen = sizeof(ULONG);
            }
            break;
    
        case OID_GEN_RCV_OK:
            ulInfo64 = pVElan->GoodReceives;
            pInfo = &ulInfo64;
            if (InformationBufferLength >= sizeof(ULONG64) ||
                InformationBufferLength == 0)
            {
                ulInfoLen = sizeof(ULONG64);
            }
            else
            {
                ulInfoLen = sizeof(ULONG);
            }
            break;
    
        case OID_GEN_XMIT_ERROR:
            ulInfo = pVElan->TxAbortExcessCollisions +
                pVElan->TxDmaUnderrun +
                pVElan->TxLostCRS +
                pVElan->TxLateCollisions+
                pVElan->TransmitFailuresOther;
            break;
    
        case OID_GEN_RCV_ERROR:
            ulInfo = pVElan->RcvCrcErrors +
                pVElan->RcvAlignmentErrors +
                pVElan->RcvResourceErrors +
                pVElan->RcvDmaOverrunErrors +
                pVElan->RcvRuntErrors;
#if IEEE_VLAN_SUPPORT
            ulInfo +=
                (pVElan->RcvVlanIdErrors +
                pVElan->RcvFormatErrors);
#endif

            break;
    
        case OID_GEN_RCV_NO_BUFFER:
            ulInfo = pVElan->RcvResourceErrors;
            break;
    
        case OID_GEN_RCV_CRC_ERROR:
            ulInfo = pVElan->RcvCrcErrors;
            break;
    
        case OID_GEN_TRANSMIT_QUEUE_LENGTH:
            ulInfo = pVElan->RegNumTcb;
            break;
    
        case OID_802_3_RCV_ERROR_ALIGNMENT:
            ulInfo = pVElan->RcvAlignmentErrors;
            break;
    
        case OID_802_3_XMIT_ONE_COLLISION:
            ulInfo = pVElan->OneRetry;
            break;
    
        case OID_802_3_XMIT_MORE_COLLISIONS:
            ulInfo = pVElan->MoreThanOneRetry;
            break;
    
        case OID_802_3_XMIT_DEFERRED:
            ulInfo = pVElan->TxOKButDeferred;
            break;
    
        case OID_802_3_XMIT_MAX_COLLISIONS:
            ulInfo = pVElan->TxAbortExcessCollisions;
            break;
    
        case OID_802_3_RCV_OVERRUN:
            ulInfo = pVElan->RcvDmaOverrunErrors;
            break;
    
        case OID_802_3_XMIT_UNDERRUN:
            ulInfo = pVElan->TxDmaUnderrun;
            break;
    
        case OID_802_3_XMIT_HEARTBEAT_FAILURE:
            ulInfo = pVElan->TxLostCRS;
            break;
    
        case OID_802_3_XMIT_TIMES_CRS_LOST:
            ulInfo = pVElan->TxLostCRS;
            break;
    
        case OID_802_3_XMIT_LATE_COLLISIONS:
            ulInfo = pVElan->TxLateCollisions;
            break;
   
#if IEEE_VLAN_SUPPORT            
        case OID_GEN_VLAN_ID:
            ulInfo = pVElan->VlanId;
            break;

#endif

        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    if (bForwardRequest == FALSE)
    {
        //
        // No need to forward this request down.
        //
        if (Status == NDIS_STATUS_SUCCESS)
        {
            if (ulInfoLen <= InformationBufferLength)
            {
                // Copy result into InformationBuffer
                *BytesWritten = ulInfoLen;
                if(ulInfoLen)
                {
                    NdisMoveMemory(InformationBuffer, pInfo, ulInfoLen);
                }
            }
            else
            {
                // too short
                *BytesNeeded = ulInfoLen;
                Status = NDIS_STATUS_BUFFER_TOO_SHORT;
            }
        }
    }
    else
    {
        //
        // Send this request to the binding below.
        //
        Status = MPForwardRequest(pVElan,
                                   NdisRequestQueryInformation,
                                   Oid,
                                   InformationBuffer,
                                   InformationBufferLength,
                                   BytesWritten,
                                   BytesNeeded);
    }

    if ((Status != NDIS_STATUS_SUCCESS) &&
        (Status != NDIS_STATUS_PENDING))
    {
        DBGPRINT(MUX_WARN, ("MPQueryInformation VELAN %p, OID 0x%08x, Status = 0x%08x\n",
                    pVElan, Oid, Status));
    }
    
    return(Status);

}


NDIS_STATUS
MPSetInformation(
    IN    NDIS_HANDLE               MiniportAdapterContext,
    IN    NDIS_OID                  Oid,
    IN    PVOID                     InformationBuffer,
    IN    ULONG                     InformationBufferLength,
    OUT   PULONG                    BytesRead,
    OUT   PULONG                    BytesNeeded
    )
/*++

Routine Description:

    This is the handler for an OID set operation. Relevant
    OIDs are forwarded down to the lower miniport for handling.

Arguments:

    MiniportAdapterContext      Pointer to the adapter structure
    Oid                         Oid for this query
    InformationBuffer           Buffer for information
    InformationBufferLength     Size of this buffer
    BytesRead                   Specifies how much info is read
    BytesNeeded                 In case the buffer is smaller than what 
                                we need, tell them how much is needed

Return Value:

    Return code from the NdisRequest below.

--*/
{
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PVELAN                  pVElan = (PVELAN) MiniportAdapterContext;
    ULONG                   PacketFilter;
    NDIS_DEVICE_POWER_STATE NewDeviceState;
    
    // Should we forward the request to the miniport below?
    BOOLEAN                 bForwardRequest = FALSE;

    *BytesRead = 0;
    *BytesNeeded = 0;

    switch (Oid)
    {
        //
        // Let the miniport below handle these OIDs:
        //
        case OID_PNP_ADD_WAKE_UP_PATTERN:
        case OID_PNP_REMOVE_WAKE_UP_PATTERN:
        case OID_PNP_ENABLE_WAKE_UP:
            bForwardRequest = TRUE;
            break;

        case OID_PNP_SET_POWER:
            //
            // Store new power state and succeed the request.
            //
            *BytesNeeded = sizeof(NDIS_DEVICE_POWER_STATE);
            if (InformationBufferLength < *BytesNeeded)
            {
                Status = NDIS_STATUS_INVALID_LENGTH;
                break;
            }
           
            NewDeviceState = (*(PNDIS_DEVICE_POWER_STATE)InformationBuffer);
            
            //
            // Check if the VELAN adapter goes from lower power state to D0
            // 
            if ((MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState)) 
                    && (!MUX_IS_LOW_POWER_STATE(NewDeviceState)))
            {
                //
                // Indicate the media status is necessary
                // 
                if (pVElan->LastIndicatedStatus != pVElan->LatestUnIndicateStatus)
                {
                    NdisMIndicateStatus(pVElan->MiniportAdapterHandle,
                                        pVElan->LatestUnIndicateStatus,
                                        (PVOID)NULL,
                                        0);
                    NdisMIndicateStatusComplete(pVElan->MiniportAdapterHandle);
                    pVElan->LastIndicatedStatus = pVElan->LatestUnIndicateStatus;
                }
            }
            //
            // Check if the VELAN adapter goes from D0 to lower power state
            // 
            if ((!MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState)) 
                    && (MUX_IS_LOW_POWER_STATE(NewDeviceState)))
            {
                //
                //  Initialize LastUnIndicateStatus 
                // 
                pVElan->LatestUnIndicateStatus = pVElan->LastIndicatedStatus;
            }
            
            NdisMoveMemory(&pVElan->MPDevicePowerState,
                           InformationBuffer,
                           *BytesNeeded);

            DBGPRINT(MUX_INFO, ("SetInfo: VElan %p, new miniport power state --- %d\n",
                    pVElan, pVElan->MPDevicePowerState));

            break;

        case OID_802_3_MULTICAST_LIST:
            Status = MPSetMulticastList(pVElan,
                                        InformationBuffer,
                                        InformationBufferLength,
                                        BytesRead,
                                        BytesNeeded);
            break;

        case OID_GEN_CURRENT_PACKET_FILTER:
            if (InformationBufferLength != sizeof(ULONG))
            {
                Status = NDIS_STATUS_INVALID_LENGTH;
                *BytesNeeded = sizeof(ULONG);
                break;
            }

            NdisMoveMemory(&PacketFilter, InformationBuffer, sizeof(ULONG));
            *BytesRead = sizeof(ULONG);

            Status = MPSetPacketFilter(pVElan,
                                       PacketFilter);
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
#if IEEE_VLAN_SUPPORT
            //
            // In order to simplify parsing and to avoid excessive
            // copying, we need the tag header also to be present in the
            // lookahead buffer. Make sure that the driver below
            // includes that.
            //
            *(PULONG)InformationBuffer += VLAN_TAG_HEADER_SIZE;
#endif            
            bForwardRequest = TRUE;
            break;
            
#if IEEE_VLAN_SUPPORT
        case OID_GEN_VLAN_ID:
            if (InformationBufferLength != sizeof(ULONG))
            {
                Status = NDIS_STATUS_INVALID_LENGTH;
                *BytesNeeded = sizeof(ULONG);
                break;
            }
            NdisMoveMemory(&(pVElan->VlanId), InformationBuffer, sizeof(ULONG));
            break;
#endif
            
        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;

    }
    
    if (bForwardRequest == FALSE)
    {
        if (Status == NDIS_STATUS_SUCCESS)
        {
            *BytesRead = InformationBufferLength;
        }
    }
    else
    {
        //
        // Send this request to the binding below.
        //
        Status = MPForwardRequest(pVElan,
                                  NdisRequestSetInformation,
                                  Oid,
                                  InformationBuffer,
                                  InformationBufferLength,
                                  BytesRead,
                                  BytesNeeded);
    }

    return(Status);
}

VOID
MPReturnPacket(
    IN    NDIS_HANDLE             MiniportAdapterContext,
    IN    PNDIS_PACKET            Packet
    )
/*++

Routine Description:

    NDIS Miniport entry point called whenever protocols are done with
    a packet that we had indicated up and they had queued up for returning
    later.

Arguments:

    MiniportAdapterContext    - pointer to VELAN structure
    Packet    - packet being returned.

Return Value:

    None.

--*/
{
    PVELAN              pVElan = (PVELAN)MiniportAdapterContext;
    PNDIS_PACKET        pOriginalPacket;
    PMUX_RECV_RSVD      pRecvRsvd;
#if IEEE_VLAN_SUPPORT
    NDIS_PACKET_8021Q_INFO  NdisPacket8021qInfo;
#endif    
    
    pRecvRsvd = MUX_RSVD_FROM_RECV_PACKET(Packet);
    pOriginalPacket = pRecvRsvd->pOriginalPacket;

    //
    // Reclaim our packet.
    //
#if IEEE_VLAN_SUPPORT
    //
    // We would have set per-packet information if we had
    // extracted a tag header from the received packet.
    // 
    NdisPacket8021qInfo.Value = NDIS_PER_PACKET_INFO_FROM_PACKET (
                                                Packet,
                                                Ieee8021QInfo);
    //
    // If we did remove the tag header from the received packet,
    // we would have allocated a buffer to describe the "untagged"
    // header (see PtHandleRcvTagging); free it.
    // 
    if (NdisPacket8021qInfo.Value)
    {
        NdisFreeBuffer(Packet->Private.Head);
    }

#endif
    
    NdisFreePacket(Packet);

    //
    // Return the original packet received at our protocol
    // edge, if any.
    //
    // NOTE that we might end up calling NdisReturnPackets
    // multiple times with the same "lower" packet, based on
    // the number of VELANs to which we had indicated that
    // packet. The number of times we do so should match
    // the return value from our PtReceivePacket handler.
    //
    if (pOriginalPacket != NULL)
    {
        NdisReturnPackets(&pOriginalPacket, 1);
    }
    else
    {
        //
        // If no original packet, then we have been called
        // here to reclaim a packet used to forward up
        // a non-packet receive (see PtReceive). There
        // is nothing more to be done.
        //
    }


    MUX_DECR_PENDING_RECEIVES(pVElan);
}


NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET                Packet,
    OUT PUINT                       BytesTransferred,
    IN  NDIS_HANDLE                 MiniportAdapterContext,
    IN  NDIS_HANDLE                 MiniportReceiveContext,
    IN  UINT                        ByteOffset,
    IN  UINT                        BytesToTransfer
    )
/*++

Routine Description:

    Miniport's transfer data handler.  This is called if we had
    indicated receive data using a non-packet API, for e.g. if
    the lookahead buffer did not contain the entire data.

    We need to forward this to the miniport below to that it can
    copy in the rest of the data. We call NdisTransferData to do so.
    However, when that completes (see PtTransferDataComplete), we
    have to get back at the VELAN from which this packet came so that
    we can complete this request with the right MiniportAdapterHandle.
    We therefore allocate a new packet, pointing to the same buffer
    as the packet just passed in, and use reserved space in the packet
    to hold a backpointer to the VELAN from which this came.

Arguments:

    Packet                    Destination packet
    BytesTransferred          Place to return how much data was copied
    MiniportAdapterContext    Pointer to the VELAN structure
    MiniportReceiveContext    Context
    ByteOffset                Offset into the packet for copying data
    BytesToTransfer           How much to copy.

Return Value:

    Status of transfer

--*/
{
    PVELAN          pVElan = (PVELAN)MiniportAdapterContext;
    NDIS_STATUS     Status;
    PNDIS_PACKET    MyPacket;
    PMUX_TD_RSVD    pTDReserved;
#if IEEE_VLAN_SUPPORT
    PMUX_RCV_CONTEXT        pMuxRcvContext;
#endif    
    

    do
    {
        NdisAllocatePacket(&Status,
                           &MyPacket,
                           pVElan->SendPacketPoolHandle);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        pTDReserved = MUX_RSVD_FROM_TD_PACKET(MyPacket);
        pTDReserved->pOriginalPacket = Packet;
        pTDReserved->pVElan = pVElan;

        MyPacket->Private.Flags = NdisGetPacketFlags(Packet) |
                                        MUX_SEND_PACKET_FLAGS;

        MyPacket->Private.Head = Packet->Private.Head;
        MyPacket->Private.Tail = Packet->Private.Tail;
#ifdef WIN9X
        //
        // Work around the fact that NDIS does not initialize this
        // field on Win9x.
        //
        MyPacket->Private.ValidCounts = FALSE;
#endif // WIN9X

#if IEEE_VLAN_SUPPORT
        //
        // Check if the original received packet did contain a
        // VLAN tag header. If so, make sure we get the upcoming
        // call to NdisTransferData to skip the tag header.
        //
        pMuxRcvContext = (PMUX_RCV_CONTEXT)MiniportReceiveContext;
        if (pMuxRcvContext->TagHeaderLen == VLAN_TAG_HEADER_SIZE)
        {
            //
            // There was a tag header in the received packet.
            //
            ByteOffset += VLAN_TAG_HEADER_SIZE;

            //
            // Copy the 8021Q info into the packet
            //
            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, Ieee8021QInfo) =
                                        pMuxRcvContext->NdisPacket8021QInfo.Value;
        }

        //
        // Get back the lower driver's receive context for this indication.
        //
        MiniportReceiveContext = pMuxRcvContext->MacRcvContext;
#endif
        
        NdisTransferData(&Status,
                         pVElan->pAdapt->BindingHandle,
                         MiniportReceiveContext,
                         ByteOffset,
                         BytesToTransfer,
                         MyPacket,
                         BytesTransferred);
    
        if (Status != NDIS_STATUS_PENDING)
        {
            PtTransferDataComplete(pVElan->pAdapt,
                                   MyPacket,
                                   Status,
                                   *BytesTransferred);

            Status = NDIS_STATUS_PENDING;
        }
    }
    while (FALSE);

    return(Status);
}
    
    

VOID
MPHalt(
    IN    NDIS_HANDLE                MiniportAdapterContext
    )
/*++

Routine Description:

    Halt handler. Add any further clean-up for the VELAN to this
    function.

    We wait for all pending I/O on the VELAN to complete and then
    unlink the VELAN from the adapter.

Arguments:

    MiniportAdapterContext    Pointer to the pVElan

Return Value:

    None.

--*/
{
    PVELAN            pVElan = (PVELAN)MiniportAdapterContext;
    PADAPT            pAdapt = pVElan->pAdapt;

    DBGPRINT(MUX_LOUD, ("==>MiniportHalt: VELAN %p\n", pVElan));

    //
    // Mark the VELAN so that we don't send down any new requests or
    // sends to the adapter below, or new receives/indications to
    // protocols above.
    //
    pVElan->MiniportHalting = TRUE;

    //
    // Update the packet filter on the underlying adapter if needed.
    //
    if (pVElan->PacketFilter != 0)
    {
        MPSetPacketFilter(pVElan, 0);
    }

    //
    // Wait for any outstanding sends or requests to complete.
    //
    while (pVElan->OutstandingSends)
    {
        DBGPRINT(MUX_INFO, ("MiniportHalt: VELAN %p has %d outstanding sends\n",
                            pVElan, pVElan->OutstandingSends));
        NdisMSleep(20000);
    }

    //
    // Wait for all outstanding indications to be completed and
    // any pended receive packets to be returned to us.
    //
    while (pVElan->OutstandingReceives)
    {
        DBGPRINT(MUX_INFO, ("MiniportHalt: VELAN %p has %d outstanding receives\n",
                            pVElan, pVElan->OutstandingReceives));
        NdisMSleep(20000);
    }

    //
    // Delete the ioctl interface that was created when the miniport
    // was created.
    //
    (VOID)PtDeregisterDevice();

    //
    // Unlink the VELAN from its parent ADAPT structure. This will
    // dereference the VELAN.
    //
    pVElan->MiniportAdapterHandle = NULL;
    PtUnlinkVElanFromAdapter(pVElan);
    
    DBGPRINT(MUX_LOUD, ("<== MiniportHalt: pVElan %p\n", pVElan));
}


NDIS_STATUS
MPForwardRequest(
    IN PVELAN                       pVElan,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      BytesReadOrWritten,
    OUT PULONG                      BytesNeeded
    )
/*++

Routine Description:

    Utility routine that forwards an NDIS request made on a VELAN to the
    lower binding. Since at most a single request can be pended on a VELAN,
    we use the pre-allocated request structure embedded in the VELAN struct.

Arguments:


Return Value:

    NDIS_STATUS_PENDING if a request was sent down.

--*/
{
    NDIS_STATUS         Status;
    PMUX_NDIS_REQUEST   pMuxNdisRequest = &pVElan->Request;

    DBGPRINT(MUX_LOUD, ("MPForwardRequest: VELAN %p, OID %x\n", pVElan, Oid));

    do
    {
        MUX_INCR_PENDING_SENDS(pVElan);

        //
        // If the virtual miniport edge is at a low power
        // state, fail this request.
        //
        if (MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState))
        {
            MUX_DECR_PENDING_SENDS(pVElan);
            Status = NDIS_STATUS_ADAPTER_NOT_READY;
            break;
        }

        pVElan->BytesNeeded = BytesNeeded;
        pVElan->BytesReadOrWritten = BytesReadOrWritten;
        pMuxNdisRequest->pCallback = PtCompleteForwardedRequest;

        switch (RequestType)
        {
            case NdisRequestQueryInformation:
                pMuxNdisRequest->Request.RequestType = NdisRequestQueryInformation;
                pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.Oid = Oid;
                pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.InformationBuffer = 
                                            InformationBuffer;
                pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.InformationBufferLength = 
                                            InformationBufferLength;
                break;

            case NdisRequestSetInformation:
                pMuxNdisRequest->Request.RequestType = NdisRequestSetInformation;
                pMuxNdisRequest->Request.DATA.SET_INFORMATION.Oid = Oid;
                pMuxNdisRequest->Request.DATA.SET_INFORMATION.InformationBuffer = 
                                            InformationBuffer;
                pMuxNdisRequest->Request.DATA.SET_INFORMATION.InformationBufferLength = 
                                            InformationBufferLength;
                break;

            default:
                ASSERT(FALSE);
                break;
        }

        //
        // If the lower binding has been notified of a low
        // power state, queue this request; it will be picked
        // up again when the lower binding returns to D0.
        //
        if (MUX_IS_LOW_POWER_STATE(pVElan->pAdapt->PtDevicePowerState))
        {
            DBGPRINT(MUX_INFO, ("ForwardRequest: VELAN %p, Adapt %p power"
                                " state is %d, queueing OID %x\n",
                                pVElan, pVElan->pAdapt,
                                pVElan->pAdapt->PtDevicePowerState, Oid));

            pVElan->QueuedRequest = TRUE;
            Status = NDIS_STATUS_PENDING;
            break;
        }

        NdisRequest(&Status,
                    pVElan->BindingHandle,
                    &pMuxNdisRequest->Request);

        if (Status != NDIS_STATUS_PENDING)
        {
            PtRequestComplete(pVElan->pAdapt, &pMuxNdisRequest->Request, Status);
            Status = NDIS_STATUS_PENDING;
            break;
        }
    }
    while (FALSE);

    return (Status);
}

NDIS_STATUS
MPSetPacketFilter(
    IN PVELAN               pVElan,
    IN ULONG                PacketFilter
    )
/*++
Routine Description:

    This routine will set up the VELAN so that it accepts packets 
    that match the specified packet filter.  The only filter bits   
    that can truly be toggled are for broadcast and promiscuous.

    The MUX driver always sets the lower binding to promiscuous
    mode, but we do some optimization here to avoid turning on
    receives too soon. That is, we set the packet filter on the lower
    binding to a non-zero value iff at least one of the VELANs
    has a non-zero filter value.
    
    NOTE: setting the lower binding to promiscuous mode can
    impact CPU utilization. The only reason we set the lower binding
    to promiscuous mode in this sample is that we need to be able
    to receive unicast frames directed to MAC address(es) that do not
    match the local adapter's MAC address. If VELAN MAC addresses
    are set to be equal to that of the adapter below, it is sufficient
    to set the lower packet filter to the bitwise OR'ed value of
    packet filter settings on all VELANs.
                                    

Arguments:

    pVElan - pointer to VELAN
    PacketFilter - the new packet filter 
    
Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_SUPPORTED
    
--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PADAPT          pAdapt;
    PVELAN          pTmpVElan;
    PLIST_ENTRY     p;
    ULONG           AdapterFilter;
    BOOLEAN         bSendUpdate = FALSE;
    LOCK_STATE      LockState;

    DBGPRINT(MUX_LOUD, ("=> SetPacketFilter VELAN %p, Filter %x\n", pVElan, PacketFilter));
    
    do
    {
        //
        // Any bits not supported?
        //
        if (PacketFilter & ~VELAN_SUPPORTED_FILTERS)
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
    
        AdapterFilter = 0;
        pAdapt = pVElan->pAdapt;

        //
        // Grab a Write lock on the adapter so that this operation
        // does not interfere with any receives that might be accessing
        // filter information.
        //
        MUX_ACQUIRE_ADAPT_WRITE_LOCK(pAdapt, &LockState);

        //
        // Save the new packet filter value
        //
        pVElan->PacketFilter = PacketFilter;

        //
        // Compute the new combined filter for all VELANs on this
        // adapter.
        //
        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            pTmpVElan = CONTAINING_RECORD(p, VELAN, Link);
            AdapterFilter |= pTmpVElan->PacketFilter;
        }

        //
        // If all VELANs have packet filters set to 0, turn off
        // receives on the lower adapter, if not already done.
        //
        if ((AdapterFilter == 0) && (pAdapt->PacketFilter != 0))
        {
            bSendUpdate = TRUE;
            pAdapt->PacketFilter = 0;
        }
        else
        //
        // If receives had been turned off on the lower adapter, and
        // the new filter is non-zero, turn on the lower adapter.
        // We set the adapter to promiscuous mode in this sample
        // so that we are able to receive packets directed to
        // any of the VELAN MAC addresses.
        //
        if ((AdapterFilter != 0) && (pAdapt->PacketFilter == 0))
        {
            bSendUpdate = TRUE;
            pAdapt->PacketFilter = MUX_ADAPTER_PACKET_FILTER;
        }
        
        MUX_RELEASE_ADAPT_WRITE_LOCK(pAdapt, &LockState);

        if (bSendUpdate)
        {
            PtRequestAdapterAsync(
                pAdapt,
                NdisRequestSetInformation,
                OID_GEN_CURRENT_PACKET_FILTER,
                &pAdapt->PacketFilter,
                sizeof(pAdapt->PacketFilter),
                PtDiscardCompletedRequest);
        }

        break;
    }
    while (FALSE);

    DBGPRINT(MUX_INFO, ("<= SetPacketFilter VELAN %p, Status %x\n", pVElan, Status));
    
    return(Status);
}


NDIS_STATUS
MPSetMulticastList(
    IN PVELAN                   pVElan,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength,
    OUT PULONG                  pBytesRead,
    OUT PULONG                  pBytesNeeded
    )
/*++

Routine Description:

    Set the multicast list on the specified VELAN miniport.
    We simply validate all information and copy in the multicast
    list.

    We don't forward the multicast list information down since
    we set the lower binding to promisc. mode.

Arguments:

    pVElan - VELAN on which to set the multicast list
    InformationBuffer - pointer to new multicast list
    InformationBufferLength - length in bytes of above list
    pBytesRead - place to return # of bytes read from the above
    pBytesNeeded - place to return expected min # of bytes

Return Value:

    NDIS_STATUS

--*/
{
    NDIS_STATUS         Status;
    PADAPT              pAdapt;
    LOCK_STATE          LockState;

    //
    // Initialize.
    //
    *pBytesNeeded = sizeof(MUX_MAC_ADDRESS);
    *pBytesRead = 0;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        if (InformationBufferLength % sizeof(MUX_MAC_ADDRESS))
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        if (InformationBufferLength > (VELAN_MAX_MCAST_LIST * sizeof(MUX_MAC_ADDRESS)))
        {
            Status = NDIS_STATUS_MULTICAST_FULL;
            *pBytesNeeded = VELAN_MAX_MCAST_LIST * sizeof(MUX_MAC_ADDRESS);
            break;
        }

        pAdapt = pVElan->pAdapt;

        //
        // Grab a Write lock on the adapter so that this operation
        // does not interfere with any receives that might be accessing
        // multicast list information.
        //
        MUX_ACQUIRE_ADAPT_WRITE_LOCK(pAdapt, &LockState);

        NdisZeroMemory(&pVElan->McastAddrs[0],
                       VELAN_MAX_MCAST_LIST * sizeof(MUX_MAC_ADDRESS));
        
        NdisMoveMemory(&pVElan->McastAddrs[0],
                       InformationBuffer,
                       InformationBufferLength);
        
        pVElan->McastAddrCount = InformationBufferLength / sizeof(MUX_MAC_ADDRESS);
        
        MUX_RELEASE_ADAPT_WRITE_LOCK(pAdapt, &LockState);
    }
    while (FALSE);

    return (Status);
}


//
// Careful! Uses static storage for string. Used to simplify DbgPrints
// of MAC addresses.
//
PUCHAR
MacAddrToString(PVOID In)
{
    static UCHAR String[20];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR EthAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s;
    
    for (i = 0, s = String; i < 6; i++, EthAddr++)
    {
        *s++ = HexChars[(*EthAddr) >> 4];
        *s++ = HexChars[(*EthAddr) & 0xf];
    }
    *s = '\0';
    return String; 
}


VOID
MPGenerateMacAddr(
    PVELAN                    pVElan
)
/*++

Routine Description:

    Generates a "virtual" MAC address for a VELAN.
    NOTE: this is only a sample implementation of selecting
    a MAC address for the VELAN. Other implementations are possible,
    including using the MAC address of the underlying adapter as
    the MAC address of the VELAN.
    
Arguments:

    pVElan  - Pointer to velan structure

Return Value:

    None

--*/
{

    pVElan->PermanentAddress[0] = 
        0x02 | (((UCHAR)pVElan->VElanNumber & 0x3f) << 2);
    pVElan->PermanentAddress[1] = 
        0x02 | (((UCHAR)pVElan->VElanNumber & 0x3f) << 3);

    ETH_COPY_NETWORK_ADDRESS(
            pVElan->CurrentAddress,
            pVElan->PermanentAddress);
    
    DBGPRINT(MUX_LOUD, ("%d CurrentAddress %s\n",
        pVElan->VElanNumber, MacAddrToString(&pVElan->CurrentAddress)));
    DBGPRINT(MUX_LOUD, ("%d PermanentAddress  %s\n",
        pVElan->VElanNumber, MacAddrToString(&pVElan->PermanentAddress)));

}


#ifdef NDIS51_MINIPORT

VOID
MPCancelSendPackets(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN PVOID                    CancelId
    )
/*++

Routine Description:

    The miniport entry point to handle cancellation of all send packets
    that match the given CancelId. If we have queued any packets that match
    this, then we should dequeue them and call NdisMSendComplete for all
    such packets, with a status of NDIS_STATUS_REQUEST_ABORTED.

    We should also call NdisCancelSendPackets in turn, on each lower binding
    that this adapter corresponds to. This is to let miniports below cancel
    any matching packets.

Arguments:

    MiniportAdapterContext    - pointer to VELAN structure
    CancelId    - ID of packets to be cancelled.

Return Value:

    None

--*/
{
    PVELAN  pVElan = (PVELAN)MiniportAdapterContext;

    //
    // If we queue packets on our VELAN/adapter structure, this would be 
    // the place to acquire a spinlock to it, unlink any packets whose
    // Id matches CancelId, release the spinlock and call NdisMSendComplete
    // with NDIS_STATUS_REQUEST_ABORTED for all unlinked packets.
    //

    //
    // Next, pass this down so that we let the miniport(s) below cancel
    // any packets that they might have queued.
    //
    NdisCancelSendPackets(pVElan->pAdapt->BindingHandle, CancelId);

    return;
}

VOID
MPDevicePnPEvent(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN NDIS_DEVICE_PNP_EVENT    DevicePnPEvent,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength
    )
/*++

Routine Description:

    This handler is called to notify us of PnP events directed to
    our miniport device object.

Arguments:

    MiniportAdapterContext - pointer to VELAN structure
    DevicePnPEvent - the event
    InformationBuffer - Points to additional event-specific information
    InformationBufferLength - length of above

Return Value:

    None
--*/
{
    // TBD - add code/comments about processing this.

    return;
}


VOID
MPAdapterShutdown(
    IN NDIS_HANDLE              MiniportAdapterContext
    )
/*++

Routine Description:

    This handler is called to notify us of an impending system shutdown.
    Since this is not a hardware driver, there isn't anything specific
    we need to do about this.

Arguments:

    MiniportAdapterContext  - pointer to VELAN structure

Return Value:

    None
--*/
{
    return;
}


#endif // NDIS51_MINIPORT

VOID
MPUnload(
    IN    PDRIVER_OBJECT        DriverObject
    )
{
    NDIS_STATUS Status;
    
    DBGPRINT(MUX_LOUD, ("==> MPUnload: DriverObj %p\n", DriverObject));  
    NdisDeregisterProtocol(&Status, ProtHandle);
    DBGPRINT(MUX_LOUD, ("<== MPUnload \n"));    
}

#if IEEE_VLAN_SUPPORT
NDIS_STATUS
MPHandleSendTagging(
    IN  PVELAN              pVElan,
    IN  PNDIS_PACKET        Packet,
    IN  OUT PNDIS_PACKET    MyPacket
    )
/*++

Routine Description:

    This function is called when the driver supports IEEE802Q tagging.
    It checks the packet to be sent on a VELAN and inserts a tag header
    if necessary.

Arguments:

    PVELAN  - pointer to VELAN structure
    Packet - pointer to original packet
    MyPacket - pointer to the new allocated packet
    
Return Value:

    NDIS_STATUS_SUCCESS if the packet was successfully parsed
    and hence should be passed down to the lower driver. NDIS_STATUS_XXX
    otherwise.
    
--*/
{
    NDIS_PACKET_8021Q_INFO      NdisPacket8021qInfo;
    PVOID                       pEthTagBuffer;
    PNDIS_BUFFER                pNdisBuffer;
    PVOID                       pVa;
    ULONG                       BufferLength;
    PNDIS_BUFFER                pFirstBuffer;
    PNDIS_BUFFER                pSecondBuffer;
    NDIS_STATUS                 Status;
    NDIS_STATUS                 Status2;
    PVOID                       pStartVa;
    BOOLEAN                     IsFirstVa;
    PVLAN_TAG_HEADER            pTagHeader;
    PUSHORT                     TypeLength;
    PUSHORT                     pTpid;
    ULONG                       BytesToSkip;
    PUSHORT                     pTypeLength;
    //
    // Add tag header here
    //
    Status = NDIS_STATUS_SUCCESS;
    
    NdisPacket8021qInfo.Value =  NDIS_PER_PACKET_INFO_FROM_PACKET(
                                                            MyPacket,         
                                                            Ieee8021QInfo);
            
    do
    {
        //
        // Insert a tag only if we have a configured VLAN ID
        // or there is non-zero VLAN/priority information to be
        // sent with the packet.
        //
        if ((pVElan->VlanId == 0) && (NdisPacket8021qInfo.Value == 0))
        {
            //
            // No tag header needed.
            //
            break;
        }
            
        //
        // We don't support E-RIF
        // 
        if (NdisPacket8021qInfo.TagHeader.CanonicalFormatId)
        {
            //
            // skip the packet, return NDIS_STATUS_FAILURE
            //
            Status = NDIS_STATUS_INVALID_PACKET;
            break;
        }

        //
        // The Vlan Id must be the same as the configured VLAN ID if it is non-zero
        // 
        if ((NdisPacket8021qInfo.TagHeader.VlanId)
                && (pVElan->VlanId)
                && (NdisPacket8021qInfo.TagHeader.VlanId != pVElan->VlanId))
        {
            Status = NDIS_STATUS_INVALID_PACKET;
            break;
        }
                
        //
        // Find the virtual address after the Ethernet Header
        //
        BytesToSkip = ETH_HEADER_SIZE;
        pNdisBuffer = Packet->Private.Head;
        IsFirstVa = TRUE;
            
        //
        // Assume the Ethernet Header is in the first buffer of the packet.
        // The following loop is to find the start address of the data after
        // the ethernet header. This may be either in the first NDIS buffer
        // or in the second.
        // 
        while (TRUE)
        {
#ifdef NDIS51_MINIPORT
            NdisQueryBufferSafe(pNdisBuffer, &pVa, &BufferLength, NormalPagePriority);
#else
            NdisQueryBuffer(pNdisBuffer, &pVa, &BufferLength);
#endif
            //
            // The query can fail if the system is low on resources.
            // 
            if (pVa == NULL)
            {
                break;
            }

            //
            // Remember the start of the ethernet header for later.
            // 
            if (IsFirstVa)
            {
                pStartVa = pVa;
                IsFirstVa = FALSE;
            }

            //
            // Have we gone far enough into the packet?
            // 
            if (BytesToSkip == 0)
            {
                break;
            }

            //
            // Does the current buffer contain bytes past the Ethernet
            // header? If so, stop.
            // 
            if (BufferLength > BytesToSkip)
            {
                pVa = (PVOID)((PUCHAR)pVa + BytesToSkip);
                BufferLength -= BytesToSkip;
                break;
            }

            //
            // We haven't gone past the Ethernet header yet, so go
            // to the next buffer.
            //
            BytesToSkip -= BufferLength;
            pNdisBuffer = NDIS_BUFFER_LINKAGE(pNdisBuffer);
        }

        if (pVa == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Allocate space for the Ethernet + VLAN tag header.
        // 
        pEthTagBuffer = NdisAllocateFromNPagedLookasideList(&pVElan->TagLookaside);
            
        //
        // Memory allocation failed, can't send out the packet
        // 
        if (pEthTagBuffer == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Allocate NDIS buffers for the Ethernet + VLAN tag header and
        // the data that follows these.
        //
        NdisAllocateBuffer(&Status,
                            &pSecondBuffer,
                            pVElan->BufferPoolHandle,
                            pVa,    // byte following the Eth+tag headers
                            BufferLength);
        
        NdisAllocateBuffer(&Status2,
                            &pFirstBuffer,
                            pVElan->BufferPoolHandle,
                            pEthTagBuffer,
                            ETH_HEADER_SIZE + VLAN_TAG_HEADER_SIZE);

        if (Status != NDIS_STATUS_SUCCESS || Status2 != NDIS_STATUS_SUCCESS)
        {
            //
            // One of the buffer allocations failed.
            //
            if (Status == NDIS_STATUS_SUCCESS)
            {
                NdisFreeBuffer(pSecondBuffer);
            }   
        
            if (Status2 == NDIS_STATUS_SUCCESS)
            {
                NdisFreeBuffer(pFirstBuffer);
            }

            NdisFreeToNPagedLookasideList(&pVElan->TagLookaside, pEthTagBuffer);
        
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // All allocations were successful, now prepare the packet
        // to be sent down to the lower driver.
        //
        MyPacket->Private.Head = NDIS_BUFFER_LINKAGE(pNdisBuffer);
        NdisChainBufferAtFront(MyPacket, pSecondBuffer)
        NdisChainBufferAtFront(MyPacket, pFirstBuffer)
        
        //
        // Prepare the Ethernet and tag headers.
        //
        NdisMoveMemory(pEthTagBuffer, pStartVa, 2 * ETH_LENGTH_OF_ADDRESS);
        pTpid = (PUSHORT)((PUCHAR)pEthTagBuffer + 2 * ETH_LENGTH_OF_ADDRESS);
        *pTpid = TPID;
        pTagHeader = (PVLAN_TAG_HEADER)(pTpid + 1);
    
        //
        // Write Ieee 802Q info to packet frame
        // 
        INITIALIZE_TAG_HEADER_TO_ZERO(pTagHeader);
        if (NdisPacket8021qInfo.Value)
        {
            SET_USER_PRIORITY_TO_TAG(pTagHeader, NdisPacket8021qInfo.TagHeader.UserPriority);
        }
        else
        {
            SET_USER_PRIORITY_TO_TAG(pTagHeader, 0);
        }

        SET_CANONICAL_FORMAT_ID_TO_TAG (pTagHeader, 0);
            
        if (NdisPacket8021qInfo.TagHeader.VlanId)
        {
            SET_VLAN_ID_TO_TAG (pTagHeader, NdisPacket8021qInfo.TagHeader.VlanId);
        }
        else
        {
            SET_VLAN_ID_TO_TAG (pTagHeader, pVElan->VlanId);
        }   

        pTypeLength = (PUSHORT)((PUCHAR)pTagHeader + sizeof(pTagHeader->TagInfo));
        *pTypeLength = *((PUSHORT)((PUCHAR)pStartVa + 2 * ETH_LENGTH_OF_ADDRESS));

        //
        // Clear the Ieee8021QInfo field in packet being sent down
        // to prevent double tag insertion!
        // 
        NDIS_PER_PACKET_INFO_FROM_PACKET(MyPacket, Ieee8021QInfo) = 0;
        break;
    }
    while (FALSE);
    
    return Status;
}
    
#endif // IEEE_VLAN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\vvendor.h ===
/*

                                                                             
    (C) Copyright 1998 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.



@doc INTERNAL TpiBuild vVendor vVendor_h

@module vVendor.h |

    This module defines the version information as displayed in the Windows 
    file property sheet.  You must change the fields below as appropriate 
    for your product.  This file is then included by <f vTarget\.rc> to 
    defined the necessary elements of the target file's version resource.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vVendor_h

@end

*/

#ifndef _VVENDOR_H_
#define _VVENDOR_H_

// Short vendor name - no spaces - limit to 32 characters if possible.
#define VER_VENDOR_STR                  "TriplePoint"
// Long vendor name - legal name of the company.
#define VER_VENDOR_NAME_STR             "TriplePoint, Inc."
// Legal copyright notice - limit to to 40 characters for appearance.
#define VER_COPYRIGHT_STR               "Copyright \251 1998"
// Short product name - no spaces - limit to 32 characters if possible.
#define VER_PRODUCT_STR                 "IsdnWan"
// Long product name - usually the same as put on the product packaging.
#define VER_PRODUCT_NAME_STR            "TriplePoint ISDNWAN Miniport for Windows."
// Vendor and product name - typically used as a registry key.
#define VER_VENDOR_PRODUCT_STR          VER_VENDOR_STR "\\" VER_PRODUCT_STR
// Device description used to identify the device in the NDIS/TAPI user interface.
#define VER_DEVICE_STR                  "TriplePoint ISDNWAN"
// IEEE Organization Unique Identifier assigned to your company.
#define VER_VENDOR_ID                   "TPI"
// Set according to NDISWAN MediaType supported by the driver.
#define VER_DEFAULT_MEDIATYPE           "ISDN"
// The default AddressList for the line devices supported by the driver.
#define VER_DEFAULT_ADDRESSLIST         "1-1-0\0" L"1-2-0\0"

#endif // _VVENDOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\muxim\mux.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation
 
Module Name:
 
    mux.c

Abstract:

    DriverEntry and NT dispatch functions for the NDIS MUX Intermediate
    Miniport driver sample.

Environment:

    Kernel mode

Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define MODULE_NUMBER           MODULE_MUX

#pragma NDIS_INIT_FUNCTION(DriverEntry)


#if DBG
//
// Debug level for mux driver
// 
INT     muxDebugLevel = MUX_WARN;

#endif //DBG
//
//  G L O B A L   V A R I A B L E S
//  -----------   -----------------
//

NDIS_MEDIUM        MediumArray[1] =
                    {
                        NdisMedium802_3,    // Ethernet
                    };


//
// Global Mutex protects the AdapterList;
// see macros MUX_ACQUIRE/RELEASE_MUTEX
//
MUX_MUTEX          GlobalMutex = {0};

//
// List of all bound adapters.
//
LIST_ENTRY         AdapterList;

//
// Total number of VELAN miniports in existance:
//
LONG               MiniportCount = 0;

//
// Used to assign VELAN numbers (which are used to generate MAC
// addresses).
//
ULONG              NextVElanNumber = 0; // monotonically increasing count

//
// Some global NDIS handles:
//
NDIS_HANDLE        NdisWrapperHandle = NULL;// From NdisMInitializeWrapper
NDIS_HANDLE        ProtHandle = NULL;       // From NdisRegisterProtocol
NDIS_HANDLE        DriverHandle = NULL;     // From NdisIMRegisterLayeredMiniport
NDIS_HANDLE        NdisDeviceHandle = NULL; // From NdisMRegisterDevice

PDEVICE_OBJECT     ControlDeviceObject = NULL;  // Device for IOCTLs
MUX_MUTEX          ControlDeviceMutex;



NTSTATUS
DriverEntry(
    IN    PDRIVER_OBJECT        DriverObject,
    IN    PUNICODE_STRING        RegistryPath
    )
/*++

Routine Description:

    First entry point to be called, when this driver is loaded.
    Register with NDIS as an intermediate driver.

Arguments:

    DriverObject - pointer to the system's driver object structure
        for this driver
    
    RegistryPath - system's registry path for this driver
    
Return Value:

    STATUS_SUCCESS if all initialization is successful, STATUS_XXX
    error code if not.

--*/
{
    NDIS_STATUS                     Status;
    NDIS_PROTOCOL_CHARACTERISTICS   PChars;
    NDIS_MINIPORT_CHARACTERISTICS   MChars;
    PNDIS_CONFIGURATION_PARAMETER   Param;
    NDIS_STRING                     Name;

    NdisInitializeListHead(&AdapterList);
    MUX_INIT_MUTEX(&GlobalMutex);
    MUX_INIT_MUTEX(&ControlDeviceMutex);

    NdisMInitializeWrapper(&NdisWrapperHandle, DriverObject, RegistryPath, NULL);

    do
    {
        //
        // Register the miniport with NDIS. Note that it is the
        // miniport which was started as a driver and not the protocol.
        // Also the miniport must be registered prior to the protocol
        // since the protocol's BindAdapter handler can be initiated
        // anytime and when it is, it must be ready to
        // start driver instances.
        //
        NdisZeroMemory(&MChars, sizeof(NDIS_MINIPORT_CHARACTERISTICS));

        MChars.MajorNdisVersion = MUX_MAJOR_NDIS_VERSION;
        MChars.MinorNdisVersion = MUX_MINOR_NDIS_VERSION;

        MChars.InitializeHandler = MPInitialize;
        MChars.QueryInformationHandler = MPQueryInformation;
        MChars.SetInformationHandler = MPSetInformation;
        MChars.TransferDataHandler = MPTransferData;
        MChars.HaltHandler = MPHalt;
#ifdef NDIS51_MINIPORT
        MChars.CancelSendPacketsHandler = MPCancelSendPackets;
        MChars.PnPEventNotifyHandler = MPDevicePnPEvent;
        MChars.AdapterShutdownHandler = MPAdapterShutdown;
#endif // NDIS51_MINIPORT

        //
        // We will disable the check for hang timeout so we do not
        // need a check for hang handler!
        //
        MChars.CheckForHangHandler = NULL;
        MChars.ReturnPacketHandler = MPReturnPacket;

        //
        // Either the Send or the SendPackets handler should be specified.
        // If SendPackets handler is specified, SendHandler is ignored
        //
        MChars.SendHandler = NULL;   
        MChars.SendPacketsHandler = MPSendPackets;

        Status = NdisIMRegisterLayeredMiniport(NdisWrapperHandle,
                                               &MChars,
                                               sizeof(MChars),
                                               &DriverHandle);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        NdisMRegisterUnloadHandler(NdisWrapperHandle, MPUnload);

        //
        // Now register the protocol.
        //
        NdisZeroMemory(&PChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
        PChars.MajorNdisVersion = MUX_PROT_MAJOR_NDIS_VERSION;
        PChars.MinorNdisVersion = MUX_PROT_MINOR_NDIS_VERSION;

        //
        // Make sure the protocol-name matches the service-name
        // (from the INF) under which this protocol is installed.
        // This is needed to ensure that NDIS can correctly determine
        // the binding and call us to bind to miniports below.
        //
        NdisInitUnicodeString(&Name, L"MUXP");    // Protocol name
        PChars.Name = Name;
        PChars.OpenAdapterCompleteHandler = PtOpenAdapterComplete;
        PChars.CloseAdapterCompleteHandler = PtCloseAdapterComplete;
        PChars.SendCompleteHandler = PtSendComplete;
        PChars.TransferDataCompleteHandler = PtTransferDataComplete;
        
        PChars.ResetCompleteHandler = PtResetComplete;
        PChars.RequestCompleteHandler = PtRequestComplete;
        PChars.ReceiveHandler = PtReceive;
        PChars.ReceiveCompleteHandler = PtReceiveComplete;
        PChars.StatusHandler = PtStatus;
        PChars.StatusCompleteHandler = PtStatusComplete;
        PChars.BindAdapterHandler = PtBindAdapter;
        PChars.UnbindAdapterHandler = PtUnbindAdapter;
        PChars.UnloadHandler = NULL;
        PChars.ReceivePacketHandler = PtReceivePacket;
        PChars.PnPEventHandler= PtPNPHandler;

        NdisRegisterProtocol(&Status,
                             &ProtHandle,
                             &PChars,
                             sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            NdisIMDeregisterLayeredMiniport(DriverHandle);
            break;
        }

        //
        // Let NDIS know of the association between our protocol
        // and miniport entities.
        //
        NdisIMAssociateMiniport(DriverHandle, ProtHandle);
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisTerminateWrapper(NdisWrapperHandle, NULL);
    }

    return(Status);
}


NDIS_STATUS
PtRegisterDevice(
    VOID
    )
/*++

Routine Description:

    Register an ioctl interface - a device object to be used for this
    purpose is created by NDIS when we call NdisMRegisterDevice.

    This routine is called whenever a new miniport instance is
    initialized. However, we only create one global device object,
    when the first miniport instance is initialized. This routine
    handles potential race conditions with PtDeregisterDevice via
    the ControlDeviceMutex.

    NOTE: do not call this from DriverEntry; it will prevent the driver
    from being unloaded (e.g. on uninstall).

Arguments:

    None

Return Value:

    NDIS_STATUS_SUCCESS if we successfully register a device object.

--*/
{
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    UNICODE_STRING      DeviceName;
    UNICODE_STRING      DeviceLinkUnicodeString;
    PDRIVER_DISPATCH    DispatchTable[IRP_MJ_MAXIMUM_FUNCTION];
    UINT                i;

    DBGPRINT(MUX_LOUD, ("==>PtRegisterDevice\n"));

    MUX_ACQUIRE_MUTEX(&ControlDeviceMutex);

    ++MiniportCount;
    
    if (1 == MiniportCount)
    {
        for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
        {
            DispatchTable[i] = PtDispatch;
        }

        NdisInitUnicodeString(&DeviceName, NTDEVICE_STRING);
        NdisInitUnicodeString(&DeviceLinkUnicodeString, LINKNAME_STRING);

        //
        // Create a device object and register our dispatch handlers
        //
        Status = NdisMRegisterDevice(
                    NdisWrapperHandle, 
                    &DeviceName,
                    &DeviceLinkUnicodeString,
                    &DispatchTable[0],
                    &ControlDeviceObject,
                    &NdisDeviceHandle
                    );
    }

    MUX_RELEASE_MUTEX(&ControlDeviceMutex);

    DBGPRINT(MUX_INFO, ("<==PtRegisterDevice: %x\n", Status));

    return (Status);
}


NTSTATUS
PtDispatch(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp
    )
/*++
Routine Description:

    Process IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object
    Irp      - pointer to an I/O Request Packet

Return Value:

    NTSTATUS - STATUS_SUCCESS always - change this when adding
    real code to handle ioctls.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG                   inlen, outlen;
    PVOID                   buffer;
    NDIS_STRING                        KeyName;
    WCHAR                           Device[100];

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    DBGPRINT(MUX_LOUD, ("==>PtDispatch %d\n", irpStack->MajorFunction));
      
    switch (irpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            break;
        case IRP_MJ_CLOSE:
            break;        
        case IRP_MJ_DEVICE_CONTROL: {

          buffer = Irp->AssociatedIrp.SystemBuffer;  
          inlen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
          
          switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
            //
            // Add code here to handle ioctl commands.
            //
          }
          break;  
        }
        default:
            break;
    }
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(MUX_LOUD, ("<== Pt Dispatch\n"));

    return status;

} 


NDIS_STATUS
PtDeregisterDevice(
    VOID
    )
/*++

Routine Description:

    Deregister the ioctl interface. This is called whenever a miniport
    instance is halted. When the last miniport instance is halted, we
    request NDIS to delete the device object

Arguments:

    NdisDeviceHandle - Handle returned by NdisMRegisterDevice

Return Value:

    NDIS_STATUS_SUCCESS if everything worked ok

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DBGPRINT(MUX_LOUD, ("==>PassthruDeregisterDevice\n"));

    MUX_ACQUIRE_MUTEX(&ControlDeviceMutex);

    ASSERT(MiniportCount > 0);

    --MiniportCount;
    
    if (0 == MiniportCount)
    {
        //
        // All VELAN miniport instances have been halted.
        // Deregister the control device.
        //

        if (NdisDeviceHandle != NULL)
        {
            Status = NdisMDeregisterDevice(NdisDeviceHandle);
            NdisDeviceHandle = NULL;
        }
    }

    MUX_RELEASE_MUTEX(&ControlDeviceMutex);

    DBGPRINT(MUX_INFO, ("<== PassthruDeregisterDevice: %x\n", Status));
    return Status;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\muxim\precomp.h ===
#include <ndis.h>
#include "mux.h"
#include "public.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\afilter.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    afilter.c

Abstract:

    This module implements a set of library routines to handle packet
    filtering for NDIS MAC drivers. It also provides routines for collecting fragmented packets and
    breaking up a packet into fragmented packets

Author:

    Alireza Dabagh  3-22-1993, (partially borrowed from EFILTER.C)


Revision History:

    Jameel Hyder (JameelH) Re-organization 01-Jun-95
--*/

#include <precomp.h>
#pragma hdrstop

#if ARCNET

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_AFILTER

//
//  Given an NDIS_PACKET this macro will tell us if it is
//  encapsulated ethernet.
//
#define ARC_PACKET_IS_ENCAPSULATED(_NSR) \
        ((_NSR)->Open->Flags & fMINIPORT_OPEN_USING_ETH_ENCAPSULATION)

//
// Defines for resource growth
//
#define ARC_BUFFER_SIZE 1024
#define ARC_BUFFER_ALLOCATION_UNIT 8
#define ARC_PACKET_ALLOCATION_UNIT 2


NDIS_STATUS
ArcAllocateBuffers(
    IN  PARC_FILTER             Filter
    )
/*++

Routine Description:

    This routine allocates Receive buffers for the filter database.

Arguments:

    Filter - The filter db to allocate for.

Returns:

    NDIS_STATUS_SUCCESS if any buffer was allocated.

--*/
{
    ULONG            i;
    PARC_BUFFER_LIST Buffer;
    PVOID            DataBuffer;
    NDIS_STATUS      Status = NDIS_STATUS_SUCCESS;

    for (i = ARC_BUFFER_ALLOCATION_UNIT; i != 0; i--)
    {
        Buffer = ALLOC_FROM_POOL(sizeof(ARC_BUFFER_LIST), NDIS_TAG_ARC_BUFFER);
        if (Buffer == NULL)
        {
            if (i == ARC_BUFFER_ALLOCATION_UNIT)
            {
                Status = NDIS_STATUS_FAILURE;
            }
            break;
        }

        DataBuffer = ALLOC_FROM_POOL(ARC_BUFFER_SIZE, NDIS_TAG_ARC_DATA);

        if (DataBuffer == NULL)
        {
            FREE_POOL(Buffer);

            if (i == ARC_BUFFER_ALLOCATION_UNIT)
            {
                Status = NDIS_STATUS_FAILURE;
            }
            //
            // We allocated some packets, that is good enough for now
            //
            break;
        }

        Buffer->BytesLeft = Buffer->Size = ARC_BUFFER_SIZE;
        Buffer->Buffer = DataBuffer;
        Buffer->Next = Filter->FreeBufferList;
        Filter->FreeBufferList = Buffer;
    }

    return Status;
}


NDIS_STATUS
ArcAllocatePackets(
    IN  PARC_FILTER             Filter
    )
/*++

Routine Description:

    This routine allocates Receive packets for the filter database.

Arguments:

    Filter - The filter db to allocate for.

Returns:

    NDIS_STATUS_SUCCESS if any packet was allocated.

--*/
{
    ULONG       i;
    PARC_PACKET Packet;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    for (i = ARC_PACKET_ALLOCATION_UNIT; i != 0; i--)
    {
        Packet = ALLOC_FROM_POOL(sizeof(ARC_PACKET), NDIS_TAG_ARC_PACKET);
        if (Packet == NULL)
        {
            if (i == ARC_PACKET_ALLOCATION_UNIT)
            {
                Status = NDIS_STATUS_FAILURE;
            }
            break;
        }

        ZeroMemory(Packet, sizeof(ARC_PACKET));

        NdisReinitializePacket(&(Packet->TmpNdisPacket));

        Packet->Next = Filter->FreePackets;
        Filter->FreePackets = Packet;
    }

    return Status;
}


VOID
ArcDiscardPacketBuffers(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet
    )
/*++

Routine description:

    This routine takes an arcnet packet that contains buffers of data and
    puts the buffers on the free list.

    NOTE: This assumes that LastBuffer points to the real last buffer
    in the chain.

Arguments:

    Filter - The filter to free the buffers to.

    Packet - The packet to free up.

Return values:

    None

--*/
{
    PARC_BUFFER_LIST Buffer;

    //
    // Reset Packet info
    //
    Packet->LastFrame = FALSE;
    Packet->TotalLength = 0;

    //
    // Reset buffer sizes
    //
    Buffer = Packet->FirstBuffer;
    while (Buffer != NULL)
    {
        Buffer->BytesLeft = Buffer->Size;
        Buffer = Buffer->Next;
    }

    //
    // Put buffers on free list
    //
    if (Packet->LastBuffer != NULL)
    {
        Packet->LastBuffer->Next = Filter->FreeBufferList;
        Filter->FreeBufferList = Packet->FirstBuffer;
        Packet->FirstBuffer = Packet->LastBuffer = NULL;
    }
}


VOID
ArcDestroyPacket(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet
    )
/*++

Routine description:

    This routine takes an arcnet packet and frees up the entire packet.

Arguments:

    Filter - Filter to free to.

    Packet - The packet to free up.

Return values:

    None

--*/
{
    PNDIS_BUFFER NdisBuffer, NextNdisBuffer;

    NdisQueryPacket(&Packet->TmpNdisPacket,
                    NULL,
                    NULL,
                    &NdisBuffer,
                    NULL);

    while (NdisBuffer != NULL)
    {
        NdisGetNextBuffer(NdisBuffer, &NextNdisBuffer);

        NdisFreeBuffer(NdisBuffer);

        NdisBuffer = NextNdisBuffer;
    }

    NdisReinitializePacket(&(Packet->TmpNdisPacket));

    ArcDiscardPacketBuffers(Filter, Packet);

    //
    // Now put packet on free list
    //
    Packet->Next = Filter->FreePackets;
    Filter->FreePackets = Packet;
}


BOOLEAN
ArcConvertToNdisPacket(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet,
    IN  BOOLEAN                 ConvertWholePacket
    )
/*++

Routine description:

    This routine builds a corresponding NDIS_PACKET in TmpNdisPacket,
    that corresponds to the arcnet packet. The flag ConvertWholePacket
    is used to convert only part of the arcnet packet, or the whole
    stream. If the flag is FALSE, then only the buffers that have
    free space (starting with buffer LastBuffer on up) are converted.

    NOTE: It assumes TmpNdisPacket is an initialized ndis_packet structure.

Arguments:

    Filter - Filter to allocate from.

    Packet - The packet to convert.

    ConvertWholePacket - Convert the whole stream, or only part?

Return values:

    TRUE - If successful, else FALSE

--*/
{
    PNDIS_BUFFER NdisBuffer;
    PARC_BUFFER_LIST Buffer;
    NDIS_STATUS NdisStatus;

    Buffer = Packet->FirstBuffer;

    while (Buffer != NULL)
    {
        NdisAllocateBuffer(&NdisStatus,
                           &NdisBuffer,
                           Filter->ReceiveBufferPool,
                           Buffer->Buffer,
                           Buffer->Size - Buffer->BytesLeft);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            return(FALSE);
        }

        NdisChainBufferAtBack(&(Packet->TmpNdisPacket), NdisBuffer);

        Buffer = Buffer->Next;
    }

    return(TRUE);
}


VOID
ArcFilterDprIndicateReceive(
    IN  PARC_FILTER             Filter,             // Pointer to filter database
    IN  PUCHAR                  pRawHeader,         // Pointer to Arcnet frame header
    IN  PUCHAR                  pData,              // Pointer to data portion of Arcnet frame
    IN  UINT                    Length              // Data Length
    )
{
    ARC_PACKET_HEADER   NewFrameInfo;
    PARC_PACKET         Packet, PrevPacket;
    BOOLEAN             NewFrame, LastFrame;
    PARC_BUFFER_LIST    Buffer;
    UCHAR               TmpUchar;
    UINT                TmpLength;
    USHORT              TmpUshort;
    
    //
    // if filter is null, the adapter is indicating too early
    //  
    if (Filter == NULL)
    {
    #if DBG
        DbgPrint("Driver is indicating packets too early\n");
        if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
        {
            DbgBreakPoint();
        }
    #endif
    
        return;     
    }

    if (!MINIPORT_TEST_FLAG(Filter->Miniport, fMINIPORT_MEDIA_CONNECTED))
    {
        return;     
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

    //
    // Check for ethernet encapsulation first
    //
    TmpUchar = ((ARC_PROTOCOL_HEADER *)pRawHeader)->ProtId;

    if ( TmpUchar == 0xE8 )
    {
        if ((Length < (ARC_MAX_FRAME_SIZE + 4)) && (Length > 0))
        {
            //
            // Yes! Indicate it to the wrapper for indicating to all
            // protocols running ethernet on top of the arcnet miniport
            // driver.
            //
            ndisMArcIndicateEthEncapsulatedReceive(Filter->Miniport,// miniport.
                                                   pRawHeader,      // 878.2 header.
                                                   pData,           // ethernet header.
                                                   Length);         // length of ethernet frame.
            //
            // Ethernet header should be pData now
            // Length should be data now
            // We're done.
            //
        }

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
        return;
    }

    // If the data portion is greater than 507 its a bad deal
    if ((Length > ARC_MAX_FRAME_SIZE + 3) || (Length == 0))
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
        return;
    }

    //
    // Get information from packet
    //
    NewFrameInfo.ProtHeader.SourceId[0] = *((PUCHAR)pRawHeader);
    NewFrameInfo.ProtHeader.DestId[0] = *((PUCHAR)pRawHeader + 1);

    NewFrameInfo.ProtHeader.ProtId = TmpUchar;

    //
    //  Read the split flag. If this is an exception packet (i.e.
    //  TmpUChar == 0xFF then we need to add an extra 3 onto
    //  pData to skip the series of 0xFF 0xFF 0xFF.
    //
    TmpUchar = *((PUCHAR)pData);

    if (TmpUchar == 0xFF)
    {
        pData += 4;
        Length -= 4;

        //
        //  Re-read the split flag.
        //
        TmpUchar = *((PUCHAR)pData);
    }

    //
    //  Save off the split flag.
    //
    NewFrameInfo.SplitFlag = TmpUchar;

    //
    //  Read the sequence number, which follows the split flag.
    //
    TmpUshort = 0;
    TmpUshort = *((PUCHAR)pData + 1);
    TmpUchar = *((PUCHAR)pData + 2);

    TmpUshort = TmpUshort | (TmpUchar << 8);
    NewFrameInfo.FrameSequence = TmpUshort;
    //
    //  Point pData at protocol data.
    //
    Length -= 3;            //... Length of protocol data.
    pData += 3;          //... Beginning of protocol data.
    // Length is decreased by SF + SEQ0 + SEQ 1 = 3

    //
    // NOTE: Length is now the Length of the data portion of this packet
    //
    DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_INFO,
            ("ArcFilter: Frame received: SourceId= %#1x\nDestId=%#1x\nProtId=%#1x\nSplitFlag=%#1x\nFrameSeq=%d\n",
                (USHORT)NewFrameInfo.ProtHeader.SourceId[0],
                (USHORT)NewFrameInfo.ProtHeader.DestId[0],
                (USHORT)NewFrameInfo.ProtHeader.ProtId,
                (USHORT)NewFrameInfo.SplitFlag,
                NewFrameInfo.FrameSequence));
    DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_INFO,
            ("ArcFilter: Data at address: %p, Length = %ld\n", pData, Length));

    NewFrame = TRUE;
    LastFrame = TRUE;

    PrevPacket = NULL;
    Packet = Filter->OutstandingPackets;

    //
    // Walk throgh all outstanding packet to see if this frame belongs to any one of them
    //

    while ( Packet != NULL )
    {
        if (Packet->Header.ProtHeader.SourceId[0] == NewFrameInfo.ProtHeader.SourceId[0])
        {
            //
            // A packet received from the same source, check packet Sequence number and throw away
            // outstanding packet if they don't match. We are allowed to do this since we know
            // all the frames belonging to one packet are sent before starting a new packet. We
            // HAVE to do this, because this is how we find out that a send at the other end, was aborted
            // after some of the frames were already sent and received here.
            //

            if((Packet->Header.FrameSequence == NewFrameInfo.FrameSequence) &&
               (Packet->Header.ProtHeader.DestId[0] == NewFrameInfo.ProtHeader.DestId[0]) &&
               (Packet->Header.ProtHeader.ProtId == NewFrameInfo.ProtHeader.ProtId))
            {
                //
                // We found a packet that this frame belongs to, check split flag
                //
                if (Packet->Header.FramesReceived * 2 == NewFrameInfo.SplitFlag)
                {
                    //
                    //  A packet found for this frame and SplitFlag is OK, check to see if it is
                    //  the last frame of the packet
                    //
                    NewFrame = FALSE;
                    LastFrame = (BOOLEAN)(NewFrameInfo.SplitFlag == Packet->Header.LastSplitFlag);
                }
                else
                {
                    //
                    // compare current split flag with the one from the last frame, if not equal
                    // the whole packet should be dropped.
                    //

                    if (Packet->Header.SplitFlag != NewFrameInfo.SplitFlag)
                    {
                        //
                        // Corrupted incomplete packet, get rid of it, but keep the new frame
                        // and we will re-use this Packet pointer.
                        //
                        ArcDiscardPacketBuffers(Filter, Packet);
                        break;
                    }
                    else
                    {
                        //
                        // We see to have received a duplicate frame. Ignore it.
                        //
                        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                        return;
                    }
                }
            }
            else
            {
                //
                // We received a frame from a source that already has an incomplete packet outstanding
                // But Frame Seq. or DestId or ProtId are not the same.
                // We have to discard the old packet and check the new frame for validity,
                // we will re-use this packet pointer below.
                //
                ArcDiscardPacketBuffers(Filter, Packet);
            }

            break;
        }
        else
        {
            PrevPacket = Packet;
            Packet = Packet->Next;
        }
    }

    if (NewFrame)
    {
        //
        // first frame of a packet, split flag must be odd or zero
        // NewFrame is already TRUE
        // LastFrame is already TRUE
        //
        if (NewFrameInfo.SplitFlag)
        {
            if (!(NewFrameInfo.SplitFlag & 0x01))
            {
                //
                // This frame is the middle of another split, but we
                // don't have it on file.  Drop the frame.
                //
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                return;
            }

            //
            // First Frame of a multiple frame packet
            //
            NewFrameInfo.LastSplitFlag = NewFrameInfo.SplitFlag + 1;
            NewFrameInfo.FramesReceived = 1;
            LastFrame = FALSE;    // New packet and SplitFlag not zero
        }
        else
        {
            //
            // The frame is fully contained in this packet.
            //
        }

        //
        // allocate a new packet descriptor if it is a new packet
        //
        if (Packet == NULL)
        {
            if (Filter->FreePackets == NULL)
            {
                ArcAllocatePackets(Filter);

                if (Filter->FreePackets == NULL)
                {
                    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                    return;
                }
            }

            Packet = Filter->FreePackets;
            Filter->FreePackets = Packet->Next;

            if (!LastFrame)
            {
                //
                // Insert the packet in list of outstanding packets
                //
                Packet->Next = Filter->OutstandingPackets;
                Filter->OutstandingPackets = Packet;
            }
        }
        else
        {
            if (LastFrame)
            {
                //
                // remove it from the list
                //
                if (PrevPacket == NULL)
                {
                    Filter->OutstandingPackets = Packet->Next;
                }
                else
                {
                    PrevPacket->Next = Packet->Next;
                }
            }
        }

        Packet->Header = NewFrameInfo;
    }
    else
    {
        if (LastFrame)
        {
            //
            // Remove it from the queue
            //

            if (PrevPacket == NULL)
            {
                Filter->OutstandingPackets = Packet->Next;
            }
            else
            {
                PrevPacket->Next = Packet->Next;
            }
        }

        Packet->Header.FramesReceived++;

        //
        // keep track of last split flag to detect duplicate frames
        //
        Packet->Header.SplitFlag=NewFrameInfo.SplitFlag;
    }

    //
    // At this point we know Packet points to the packet to receive
    // the buffer into. If this is the LastFrame, then Packet will
    // have been removed from the OutstandingPackets list, otw it will
    // be in the list.
    //
    // Now get around to getting space for the buffer.
    //

    //
    // Find the last buffer in the packet
    //
    Buffer = Packet->LastBuffer;

    if (Buffer == NULL)
    {
        //
        // Allocate a new buffer to hold the packet
        //
        if (Filter->FreeBufferList == NULL)
        {
            if (ArcAllocateBuffers(Filter) != NDIS_STATUS_SUCCESS)
            {
                ArcDiscardPacketBuffers(Filter,Packet);
                //
                // Do not have to discard any packet that may have
                // been allocated above, as it will get discarded
                // the next time a packet comes in from that source.
                //
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                return;
            }
        }

        Buffer = Filter->FreeBufferList;
        Filter->FreeBufferList = Buffer->Next;

        Packet->FirstBuffer = Packet->LastBuffer = Buffer;
        Buffer->Next = NULL;
    }

    // Copy the data off into the ARC_PACKET list.
    // If it doesn't fit within the current buffer, we'll need to
    // allocate more

    TmpLength = Length;

    while ( Buffer->BytesLeft < TmpLength )
    {
        //
        // Copy the data
        //

        NdisMoveFromMappedMemory((PUCHAR) Buffer->Buffer + (Buffer->Size - Buffer->BytesLeft),
                                 pData,
                                 Buffer->BytesLeft);

        pData += Buffer->BytesLeft;
        TmpLength -= Buffer->BytesLeft;
        Buffer->BytesLeft = 0;

        //
        // Need to allocate more
        //
        if (Filter->FreeBufferList == NULL)
        {
            if (ArcAllocateBuffers(Filter) != NDIS_STATUS_SUCCESS)
            {
                ArcDiscardPacketBuffers(Filter,Packet);
                //
                // Do not have to discard any packet that may have
                // been allocated above, as it will get discarded
                // the next time a packet comes in from that source.
                //
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                return;
            }
        }

        Buffer->Next = Filter->FreeBufferList;
        Filter->FreeBufferList = Filter->FreeBufferList->Next;
        Buffer = Buffer->Next;
        Buffer->Next = NULL;

        Packet->LastBuffer->Next = Buffer;
        Packet->LastBuffer = Buffer;
    }

    //
    // Copy the last bit
    //

    NdisMoveFromMappedMemory((PUCHAR) Buffer->Buffer + (Buffer->Size - Buffer->BytesLeft),
                             pData,
                             TmpLength);


    Buffer->BytesLeft -= TmpLength;
    Packet->TotalLength += Length;

    //
    // And now we can start indicating the packet to the bindings that want it
    //
    if (LastFrame)
    {
        ArcFilterDoIndication(Filter, Packet);
        ArcDestroyPacket(Filter, Packet);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
}



BOOLEAN
ArcCreateFilter(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  UCHAR                   AdapterAddress,
    OUT PARC_FILTER *           Filter
    )
/*++

Routine Description:

    This routine is used to create and initialize the Arcnet filter database.

Arguments:

    Miniport - Pointer to the mini-port object.

    AdapterAddress - the address of the adapter associated with this filter
    database.

    Lock - Pointer to the lock that should be held when mutual exclusion
    is required.

    Filter - A pointer to an ARC_FILTER.  This is what is allocated and
    created by this routine.

Return Value:

    If the function returns false then one of the parameters exceeded
    what the filter was willing to support.

--*/
{
    PARC_FILTER LocalFilter;
    NDIS_STATUS AllocStatus;
    BOOLEAN     rc = TRUE;

    do
    {
        LocalFilter = ALLOC_FROM_POOL(sizeof(ARC_FILTER), NDIS_TAG_FILTER);
        *Filter = LocalFilter;
        if (LocalFilter == NULL)
        {
            rc = FALSE;
            break;
        }
    
        ZeroMemory(LocalFilter, sizeof(ARC_FILTER));
    
        LocalFilter->Miniport = Miniport;
        LocalFilter->OpenList = NULL;
        LocalFilter->AdapterAddress = AdapterAddress;
    
        NdisAllocateBufferPool(&AllocStatus,
                               (PNDIS_HANDLE)(&LocalFilter->ReceiveBufferPool),
                               ARC_RECEIVE_BUFFERS);
    
        if (AllocStatus != NDIS_STATUS_SUCCESS)
        {
            FREE_POOL(LocalFilter);
            rc = FALSE;
            break;
        }
    
        ArcReferencePackage();
    } while (FALSE);
    return rc;
}

//
// NOTE: THIS CANNOT BE PAGEABLE
//
VOID
ArcDeleteFilter(
    IN  PARC_FILTER             Filter
    )
/*++

Routine Description:

    This routine is used to delete the memory associated with a filter
    database.  Note that this routines *ASSUMES* that the database
    has been cleared of any active filters.

Arguments:

    Filter - A pointer to an ARC_FILTER to be deleted.

Return Value:

    None.

--*/
{
    PARC_PACKET Packet;
    PARC_BUFFER_LIST Buffer;

    ASSERT(Filter->OpenList == NULL);


    NdisFreeBufferPool(Filter->ReceiveBufferPool);

    //
    // Free all ARC_PACKETS
    //

    while (Filter->OutstandingPackets != NULL)
    {
        Packet = Filter->OutstandingPackets;
        Filter->OutstandingPackets = Packet->Next;

        //
        // This puts all the component parts on the free lists.
        //
        ArcDestroyPacket(Filter, Packet);
    }

    while (Filter->FreePackets != NULL)
    {
        Packet = Filter->FreePackets;
        Filter->FreePackets = Packet->Next;

        FREE_POOL(Packet);
    }

    while (Filter->FreeBufferList)
    {
        Buffer = Filter->FreeBufferList;
        Filter->FreeBufferList = Buffer->Next;

        FREE_POOL(Buffer->Buffer);
        FREE_POOL(Buffer);
    }

    FREE_POOL(Filter);

    ArcDereferencePackage();
}


BOOLEAN
ArcNoteFilterOpenAdapter(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisBindingHandle,
    OUT PNDIS_HANDLE            NdisFilterHandle
    )
/*++

Routine Description:

    This routine is used to add a new binding to the filter database.

    NOTE: THIS ROUTINE ASSUMES THAT THE DATABASE IS LOCKED WHEN
    IT IS CALLED.

Arguments:

    Filter - A pointer to the previously created and initialized filter
    database.

    NdisBindingHandle - a pointer to Ndis Open block

    NdisFilterHandle - A pointer to filter open.

Return Value:

    Will return false if creating a new filter index will cause the maximum
    number of filter indexes to be exceeded.

--*/
{
    PARC_BINDING_INFO LocalOpen;


    //
    // Get the first free binding slot and remove that slot from
    // the free list.  We check to see if the list is empty.
    //
    LocalOpen = ALLOC_FROM_POOL(sizeof(ARC_BINDING_INFO), NDIS_TAG_ARC_BINDING_INFO);
    if (LocalOpen == NULL)
    {
        return FALSE;
    }

    LocalOpen->NextOpen = Filter->OpenList;
    Filter->OpenList = LocalOpen;

    LocalOpen->References = 1;
    LocalOpen->NdisBindingHandle = NdisBindingHandle;
    LocalOpen->PacketFilters = 0;
    LocalOpen->ReceivedAPacket = FALSE;

    *NdisFilterHandle = (NDIS_HANDLE)LocalOpen;

    return TRUE;
}


NDIS_STATUS
ArcDeleteFilterOpenAdapter(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

    When an adapter is being closed this routine should
    be called to delete knowledge of the adapter from
    the filter database.  This routine is likely to call
    action routines associated with clearing filter classes
    and addresses.

    NOTE: THIS ROUTINE SHOULD ****NOT**** BE CALLED IF THE ACTION
    ROUTINES FOR DELETING THE FILTER CLASSES OR THE MULTICAST ADDRESSES
    HAVE ANY POSSIBILITY OF RETURNING A STATUS OTHER THAN NDIS_STATUS_PENDING
    OR NDIS_STATUS_SUCCESS.  WHILE THESE ROUTINES WILL NOT BUGCHECK IF
    SUCH A THING IS DONE, THE CALLER WILL PROBABLY FIND IT DIFFICULT
    TO CODE A CLOSE ROUTINE!

    NOTE: THIS ROUTINE ASSUMES THAT IT IS CALLED WITH THE LOCK HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

    NdisRequest - If it is necessary to call the action routines,
    this will be passed to it.

Return Value:

    If action routines are called by the various address and filtering
    routines the this routine will likely return the status returned
    by those routines.  The exception to this rule is noted below.

    Given that the filter and address deletion routines return a status
    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS this routine will then
    try to return the filter index to the freelist.  If the routine
    detects that this binding is currently being indicated to via
    NdisIndicateReceive, this routine will return a status of
    NDIS_STATUS_CLOSING_INDICATING.

--*/
{
    //
    // Holds the status returned from the packet filter and address
    // deletion routines.  Will be used to return the status to
    // the caller of this routine.
    //
    NDIS_STATUS StatusToReturn;

    //
    // Local variable.
    //
    PARC_BINDING_INFO LocalOpen = (PARC_BINDING_INFO)NdisFilterHandle;

    StatusToReturn = ArcFilterAdjust(Filter,
                                     NdisFilterHandle,
                                     NdisRequest,
                                     (UINT)0,
                                     FALSE);

    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING) ||
        (StatusToReturn == NDIS_STATUS_RESOURCES))
    {
        //
        // Remove the reference from the original open.
        //

        if (--(LocalOpen->References) == 0)
        {
            PARC_BINDING_INFO   *ppBI;

            //
            // Remove it from the list.
            //

            for (ppBI = &Filter->OpenList;
                 *ppBI != NULL;
                 ppBI = &(*ppBI)->NextOpen)
            {
                if (*ppBI == LocalOpen)
                {
                    *ppBI = LocalOpen->NextOpen;
                    break;
                }
            }
            ASSERT(*ppBI == LocalOpen->NextOpen);

            //
            // First we finish any NdisIndicateReceiveComplete that
            // may be needed for this binding.
            //

            if (LocalOpen->ReceivedAPacket)
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

                FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);

                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
            }

            FREE_POOL(LocalOpen);
        }
        else
        {
            //
            // Let the caller know that there is a reference to the open
            // by the receive indication. The close action routine will be
            // called upon return from NdisIndicateReceive.
            //

            StatusToReturn = NDIS_STATUS_CLOSING_INDICATING;
        }
    }

    return StatusToReturn;
}


VOID
arcUndoFilterAdjust(
    IN  PARC_FILTER             Filter,
    IN  PARC_BINDING_INFO       Binding
    )
{
    Binding->PacketFilters = Binding->OldPacketFilters;
    Filter->CombinedPacketFilter = Filter->OldCombinedPacketFilter;
}



NDIS_STATUS
ArcFilterAdjust(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_REQUEST           NdisRequest,
    IN  UINT                    FilterClasses,
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    The FilterAdjust routine will call an action routine when a
    particular filter class is changes from not being used by any
    binding to being used by at least one binding or vice versa.

    If the action routine returns a value other than pending or
    success then this routine has no effect on the packet filters
    for the open or for the adapter as a whole.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - A pointer to the open.

    NdisRequest - If it is necessary to call the action routine,
    this will be passed to it.

    FilterClasses - The filter classes that are to be added or
    deleted.

    Set - A boolean that determines whether the filter classes
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    If it calls the action routine then it will return the
    status returned by the action routine.  If the status
    returned by the action routine is anything other than
    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING the filter database
    will be returned to the state it was in upon entrance to this
    routine.

    If the action routine is not called this routine will return
    the following statum:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    //
    // Contains the value of the combined filter classes before
    // it is adjusted.
    //
    UINT OldCombined = Filter->CombinedPacketFilter;

    PARC_BINDING_INFO LocalOpen = (PARC_BINDING_INFO)NdisFilterHandle;
    PARC_BINDING_INFO OpenList;

    //
    // Contains the value of the particlar opens packet filters
    // prior to the change.  We save this incase the action
    // routine (if called) returns an "error" status.
    //
    UINT OldOpenFilters = LocalOpen->PacketFilters;

    //
    // Set the new filter information for the open.
    //
    LocalOpen->OldPacketFilters = LocalOpen->PacketFilters;
    LocalOpen->PacketFilters = FilterClasses;

    //
    // We always have to reform the compbined filter since
    // this filter index may have been the only filter index
    // to use a particular bit.
    //
    Filter->OldCombinedPacketFilter = Filter->CombinedPacketFilter;


    for (OpenList = Filter->OpenList, Filter->CombinedPacketFilter = 0;
         OpenList != NULL;
         OpenList = OpenList->NextOpen)
    {
        Filter->CombinedPacketFilter |= OpenList->PacketFilters;
    }

    return ((OldCombined != Filter->CombinedPacketFilter) ?
                                    NDIS_STATUS_PENDING : NDIS_STATUS_SUCCESS);
}



VOID
ArcFilterDoIndication(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet
    )
/*++

Routine Description:

    This routine is called by the filter package only to indicate
    that a packet is ready to be indicated to procotols.

Arguments:

    Filter - Pointer to the filter database.

    Packet - Packet to indicate.

Return Value:

    None.

--*/
{

    //
    // Will hold the type of address that we know we've got.
    //
    UINT AddressType;

    NDIS_STATUS StatusOfReceive;

    //
    // Current Open to indicate to.
    //
    PARC_BINDING_INFO LocalOpen, NextOpen;

    if (Packet->Header.ProtHeader.DestId[0] != 0x00)
    {
        AddressType = NDIS_PACKET_TYPE_DIRECTED;
    }
    else
    {
        AddressType = NDIS_PACKET_TYPE_BROADCAST;
    }

    //
    // We need to acquire the filter exclusively while we're finding
    // bindings to indicate to.
    //

    if (!ArcConvertToNdisPacket(Filter, Packet, TRUE))
    {
        //
        // Out of resources, abort.
        //
        return;
    }

    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        NextOpen = LocalOpen->NextOpen;

        //
        // Reference the open during indication.
        //
        if (LocalOpen->PacketFilters & AddressType)
        {
            LocalOpen->References++;

            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

            //
            // Indicate the packet to the binding.
            //
            FilterIndicateReceive(&StatusOfReceive,
                                  LocalOpen->NdisBindingHandle,
                                  &Packet->TmpNdisPacket,
                                  &(Packet->Header.ProtHeader),
                                  3,
                                  Packet->FirstBuffer->Buffer,
                                  Packet->FirstBuffer->Size - Packet->FirstBuffer->BytesLeft,
                                  Packet->TotalLength);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

            LocalOpen->ReceivedAPacket = TRUE;

            if ((--(LocalOpen->References)) == 0)
            {
                PARC_BINDING_INFO   *ppBI;

                //
                // This binding is shutting down.  We have to kill it.
                //

                //
                // Remove it from the list.
                //

                for (ppBI = &Filter->OpenList;
                     *ppBI != NULL;
                     ppBI = &(*ppBI)->NextOpen)
                {
                    if (*ppBI == LocalOpen)
                    {
                        *ppBI = LocalOpen->NextOpen;
                        break;
                    }
                }
                ASSERT(*ppBI == LocalOpen->NextOpen);

                //
                // Call the IndicateComplete routine.
                //


                if (LocalOpen->ReceivedAPacket)
                {
                    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

                    FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);

                    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
                }

                //
                // Call the macs action routine so that they know we
                // are no longer referencing this open binding.
                //
                ndisMDereferenceOpen((PNDIS_OPEN_BLOCK)LocalOpen->NdisBindingHandle);

                FREE_POOL(LocalOpen);
            }   // end of if binding is shutting down

        }       // end of if any binding wants the packet
    }   // end of there are more open bindings
}


VOID
ArcFilterDprIndicateReceiveComplete(
    IN  PARC_FILTER             Filter
    )
/*++

Routine Description:

    This routine is called by to indicate that the receive
    process is complete to all bindings.  Only those bindings which
    have received packets will be notified.

Arguments:

    Filter - Pointer to the filter database.

Return Value:

    None.

--*/
{

    PARC_BINDING_INFO LocalOpen, NextOpen;

    //
    // We need to acquire the filter exclusively while we're finding
    // bindings to indicate to.
    //
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

    for (LocalOpen = Filter->OpenList; LocalOpen != NULL; LocalOpen = NextOpen)
    {
        NextOpen = LocalOpen->NextOpen;

        if (LocalOpen->ReceivedAPacket)
        {
            //
            // Indicate the binding.
            //

            LocalOpen->ReceivedAPacket = FALSE;

            LocalOpen->References++;

            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

            FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);

            if ((--(LocalOpen->References)) == 0)
            {
                PARC_BINDING_INFO   *ppBI;

                //
                // This binding is shutting down.  We have to kill it.
                //

                //
                // Remove it from the list.
                //

                for (ppBI = &Filter->OpenList;
                     *ppBI != NULL;
                     ppBI = &(*ppBI)->NextOpen)
                {
                    if (*ppBI == LocalOpen)
                    {
                        *ppBI = LocalOpen->NextOpen;
                        break;
                    }
                }
                ASSERT(*ppBI == LocalOpen->NextOpen);

                //
                // Call the macs action routine so that they know we
                // are no longer referencing this open binding.
                //
                ndisMDereferenceOpen((PNDIS_OPEN_BLOCK)LocalOpen->NdisBindingHandle);

                FREE_POOL(LocalOpen);
            }
        }
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Filter->Miniport);
}


NDIS_STATUS
ArcConvertOidListToEthernet(
    IN  PNDIS_OID               OidList,
    IN  PULONG                  NumberOfOids
    )
/*++

Routine Description:

    This routine converts an arcnet supported OID list into
    an ethernet OID list by replacing or removing arcnet
    OID's.

Arguments:

Return Value:

    None.

--*/

{
    ULONG       c;
    ULONG       cArcOids;
    NDIS_OID    EthernetOidList[ARC_NUMBER_OF_EXTRA_OIDS] = {
                    OID_802_3_MULTICAST_LIST,
                    OID_802_3_MAXIMUM_LIST_SIZE
                };

    //
    // Now we need to copy the returned results into the callers buffer,
    // removing arcnet OID's and adding in ethernet OID's. At this point
    // we do not know if the callers buffer is big enough since we may
    // remove some entries, checking it up front may not yield correct
    // results (i.e. it may actually be big enough).
    //
    for (c = 0, cArcOids = 0; c < *NumberOfOids; c++)
    {
        switch (OidList[c])
        {
            case OID_ARCNET_PERMANENT_ADDRESS:
                OidList[cArcOids++] = OID_802_3_PERMANENT_ADDRESS;
                break;

            case OID_ARCNET_CURRENT_ADDRESS:
                OidList[cArcOids++] = OID_802_3_CURRENT_ADDRESS;
                break;

            case OID_ARCNET_RECONFIGURATIONS:
                break;

            default:
                if ((OidList[c] & 0xFFF00000) != 0x06000000)
                    OidList[cArcOids++] = OidList[c];
                break;
        }
    }

    //
    //  Add the ethernet OIDs.
    //
    CopyMemory((PUCHAR)OidList + (cArcOids * sizeof(NDIS_OID)),
               EthernetOidList,
               ARC_NUMBER_OF_EXTRA_OIDS * sizeof(NDIS_OID));

    //
    //  Update the size of the buffer to send back to the caller.
    //
    *NumberOfOids = cArcOids + ARC_NUMBER_OF_EXTRA_OIDS;

    return(NDIS_STATUS_SUCCESS);
}


VOID
ndisMArcCopyFromBufferToPacket(
    IN  PCHAR                   Buffer,
    IN  UINT                    BytesToCopy,
    IN  PNDIS_PACKET            Packet,
    IN  UINT                    Offset,
    OUT PUINT                   BytesCopied
    )
/*++

Routine Description:

    Copy from a buffer into an ndis packet.

Arguments:

    Buffer - The packet to copy from.

    Offset - The offset from which to start the copy.

    BytesToCopy - The number of bytes to copy from the buffer.

    Packet - The destination of the copy.

    BytesCopied - The number of bytes actually copied.  Will be less
        than BytesToCopy if the packet is not large enough.

Return Value:

    None

--*/
{
    //
    // Holds the count of the number of ndis buffers comprising the
    // destination packet.
    //
    UINT DestinationBufferCount;

    //
    // Points to the buffer into which we are putting data.
    //
    PNDIS_BUFFER DestinationCurrentBuffer;

    //
    // Points to the location in Buffer from which we are extracting data.
    //
    PUCHAR SourceCurrentAddress;

    //
    // Holds the virtual address of the current destination buffer.
    //
    PVOID DestinationVirtualAddress;

    //
    // Holds the length of the current destination buffer.
    //
    UINT DestinationCurrentLength;

    //
    // Keep a local variable of BytesCopied so we aren't referencing
    // through a pointer.
    //
    UINT LocalBytesCopied = 0;


    //
    // Take care of boundary condition of zero length copy.
    //

    *BytesCopied = 0;
    if (!BytesToCopy)
        return;

    //
    // Get the first buffer of the destination.
    //

    NdisQueryPacket(Packet,
                    NULL,
                    &DestinationBufferCount,
                    &DestinationCurrentBuffer,
                    NULL);

    //
    // Could have a null packet.
    //

    if (!DestinationBufferCount)
        return;

    NdisQueryBuffer(DestinationCurrentBuffer,
                    &DestinationVirtualAddress,
                    &DestinationCurrentLength);

    //
    // Set up the source address.
    //

    SourceCurrentAddress = Buffer;

    while (LocalBytesCopied < BytesToCopy)
    {
        //
        // Check to see whether we've exhausted the current destination
        // buffer.  If so, move onto the next one.
        //

        if (!DestinationCurrentLength)
        {
            NdisGetNextBuffer(DestinationCurrentBuffer, &DestinationCurrentBuffer);

            if (!DestinationCurrentBuffer)
            {
                //
                // We've reached the end of the packet.  We return
                // with what we've done so far. (Which must be shorter
                // than requested.)
                //

                break;
            }

            NdisQueryBuffer(DestinationCurrentBuffer,
                            &DestinationVirtualAddress,
                            &DestinationCurrentLength);

            continue;
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (Offset)
        {
            if (Offset > DestinationCurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                Offset -= DestinationCurrentLength;
                DestinationCurrentLength = 0;
                continue;
            }
            else
            {
                DestinationVirtualAddress = (PCHAR)DestinationVirtualAddress + Offset;
                DestinationCurrentLength -= Offset;
                Offset = 0;
            }
        }

        //
        // Copy the data.
        //
        {

            //
            // Holds the amount of data to move.
            //
            UINT AmountToMove;

            //
            // Holds the amount desired remaining.
            //
            UINT Remaining = BytesToCopy - LocalBytesCopied;


            AmountToMove = DestinationCurrentLength;

            AmountToMove = ((Remaining < AmountToMove)?
                    (Remaining):(AmountToMove));

            NdisMoveFromMappedMemory(DestinationVirtualAddress,
                                     SourceCurrentAddress,
                                     AmountToMove);

            SourceCurrentAddress += AmountToMove;
            LocalBytesCopied += AmountToMove;
            DestinationCurrentLength -= AmountToMove;

        }
    }

    *BytesCopied = LocalBytesCopied;
}

VOID
ndisMArcIndicateEthEncapsulatedReceive(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PVOID                   HeaderBuffer,
    IN  PVOID                   DataBuffer,
    IN  UINT                    Length
    )
/*++

    HeaderBuffer - This is the 878.2 header.
    DataBuffer  - This is the 802.3 header.
    Length   - This is the length of the ethernet frame.

--*/
{
    ULONG_PTR   MacReceiveContext[2];

    //
    //  Indicate the packet.
    //

    MacReceiveContext[0] = (ULONG_PTR) DataBuffer;
    MacReceiveContext[1] = Length;

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
    if (Length > 14)
    {
        ULONG   PacketLength = 0;
        PUCHAR  Header = DataBuffer;

        PacketLength = (ULONG)(((USHORT)Header[12] << 8) | (USHORT)Header[13]);

        NdisMEthIndicateReceive((NDIS_HANDLE)Miniport,          // miniport handle.
                                (NDIS_HANDLE)MacReceiveContext, // receive context.
                                DataBuffer,                     // ethernet header.
                                14,                             // ethernet header length.
                                (PUCHAR)DataBuffer + 14,        // ethernet data.
                                PacketLength,                   // ethernet data length.
                                PacketLength);                  // ethernet data length.
    }
    else
    {
        NdisMEthIndicateReceive((NDIS_HANDLE)Miniport,          // miniport handle.
                                (NDIS_HANDLE)MacReceiveContext, // receive context.
                                DataBuffer,                     // ethernet header.
                                Length,                         // ethernet header length.
                                NULL,                           // ethernet data.
                                0,                              // ethernet data length.
                                0);                             // ethernet data length.
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
}

NDIS_STATUS
ndisMArcTransferData(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    IN  OUT PNDIS_PACKET        DstPacket,
    OUT PUINT                   BytesTransferred
    )
/*++

Routine Description:

    This routine handles the transfer data calls to arcnet mini-port.

Arguments:

    NdisBindingHandle - Pointer to open block.

    MacReceiveContext - Context given for the indication

    ByteOffset - Offset to start transfer at.

    BytesToTransfer - Number of bytes to transfer

    Packet - Packet to transfer into

    BytesTransferred - the number of actual bytes copied

Return values:

    NDIS_STATUS_SUCCESS, if successful, else NDIS_STATUS_FAILURE.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_OPEN_BLOCK        MiniportOpen;
    PNDIS_PACKET            SrcPacket;
    PNDIS_BUFFER            NdisBuffer;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    NDIS_PACKET             TempPacket;
    KIRQL                   OldIrql;

    MiniportOpen = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    Miniport     = MiniportOpen->MiniportHandle;
    NdisBuffer  = NULL;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    //
    //  If this is encapsulated ethernet then we don't currently
    //  have the source packet from which to copy from.
    //

    if (MINIPORT_TEST_FLAG(MiniportOpen, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
    {
        //
        //  If this is not loopback then we need to create a
        //  temp NDIS_PACKET for the packet-to-packet copy.
        //
        if (INDICATED_PACKET(Miniport) == NULL)
        {
            PUCHAR  DataBuffer = (PUCHAR)((PULONG_PTR) MacReceiveContext)[0];
            UINT    DataLength = (UINT)((PULONG_PTR) MacReceiveContext)[1];

            //
            //  We'll always be in the scope of this function so we
            //  can use local stack space rather than allocating dynamic
            //  memory.
            //
            SrcPacket = &TempPacket;    // Use the local stack for packet store.

            ZeroMemory(SrcPacket, sizeof(NDIS_PACKET));

            NdisAllocateBuffer(&Status,     // Status code.
                               &NdisBuffer, // NDIS buffer to chain onto the packet.
                               NULL,        // On NT, this parameter is ignored.
                               DataBuffer,  // The ethernet frame.
                               DataLength); // The ethernet frame length.

            if (Status == NDIS_STATUS_SUCCESS)
            {
                NdisChainBufferAtFront(SrcPacket, NdisBuffer);
            }
        }
        else
        {
            SrcPacket = INDICATED_PACKET(Miniport);

            ByteOffset += 3;        // Skip fake arcnet header.
        }

        //
        // Skip the ethernet header.
        //

        ByteOffset += 14;
    }
    else
    {
        SrcPacket = (PNDIS_PACKET) MacReceiveContext;
    }

    //
    // Now we can simply copy from the source packet to the
    // destination packet.
    //
    NdisCopyFromPacketToPacket(DstPacket,       // destination packet.
                               0,               // destination offset.
                               BytesToTransfer, // bytes to copy.
                               SrcPacket,       // source packet.
                               ByteOffset,      // source offset.
                               BytesTransferred);// bytes copied.

    //
    //  If we allocated an NDIS_BUFFER then we need to free it. We don't
    //  need to unchain the buffer from the packet since the packet is
    //  a local stack variable the will just get trashed anyway.
    //

    if (NdisBuffer != NULL)
    {
        NdisFreeBuffer(NdisBuffer);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    return Status;
}

NDIS_STATUS
ndisMBuildArcnetHeader(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_OPEN_BLOCK        Open,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_BUFFER        TmpBuffer;
    UINT                i, Flags;
    PUCHAR              Address;
    PARC_BUFFER_LIST    Buffer;
    PNDIS_BUFFER        NdisBuffer;
    NDIS_STATUS         Status;

    //
    //  Only ethernet encapsulation needs this.
    //
    if (!MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
    {
        return(NDIS_STATUS_SUCCESS);
    }

    if (Miniport->ArcBuf->NumFree == 0)
    {
        //
        // Set flag
        //
        CLEAR_RESOURCE(Miniport, 'S');

        return(NDIS_STATUS_PENDING);
    }

    NdisQueryPacket(Packet, NULL, NULL, &TmpBuffer, NULL);
    NdisQueryBuffer(TmpBuffer, &Address, &Flags);

    for (i = 0, Buffer = &Miniport->ArcBuf->ArcnetBuffers[0];
         i < ARC_SEND_BUFFERS;
         Buffer++, i++)
    {
        if (Buffer->Next == NULL)
        {
            Buffer->Next = (PARC_BUFFER_LIST)-1;
            Miniport->ArcBuf->NumFree --;
            break;
        }
    }
    ASSERT(i < ARC_SEND_BUFFERS);

    NdisAllocateBuffer(&Status,
                       &NdisBuffer,
                       Miniport->ArcBuf->ArcnetBufferPool,
                       Buffer->Buffer,
                       3);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        CLEAR_RESOURCE(Miniport, 'S');

        return(NDIS_STATUS_PENDING);
    }

    NdisChainBufferAtFront(Packet, NdisBuffer);

    ((PUCHAR)Buffer->Buffer)[0] = Miniport->ArcnetAddress;

    if (Address[0] & 0x01)
    {
        //
        // Broadcast
        //
        ((PUCHAR)Buffer->Buffer)[1] = 0x00;
    }
    else
    {
        ((PUCHAR)Buffer->Buffer)[1] = Address[5];
    }

    ((PUCHAR) Buffer->Buffer)[2] = 0xE8;

    return(NDIS_STATUS_SUCCESS);
}

VOID
ndisMFreeArcnetHeader(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet,
    IN  PNDIS_OPEN_BLOCK        Open
    )
/*++

Routine Description:

    This function strips off the arcnet header appended to
    ethernet encapsulated packets

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    Packet - Ndis packet.


    None.

--*/
{
    PARC_BUFFER_LIST        Buffer;
    PNDIS_BUFFER            NdisBuffer = NULL;
    PVOID                   BufferVa;
    UINT                    i, Length;

    if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
    {
        NdisUnchainBufferAtFront(Packet, &NdisBuffer);

        if (NdisBuffer != NULL)
        {
            NdisQueryBuffer(NdisBuffer, (PVOID *)&BufferVa, &Length);

            NdisFreeBuffer(NdisBuffer);

            for (i = 0, Buffer = &Miniport->ArcBuf->ArcnetBuffers[0];
                 i < ARC_SEND_BUFFERS;
                 Buffer++, i++)
            {
                if (Buffer->Buffer == BufferVa)
                {
                    Buffer->Next = NULL;
                    Miniport->ArcBuf->NumFree ++;
                    break;
                }
            }
        }
    }
}

BOOLEAN
FASTCALL
ndisMArcnetSendLoopback(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    )
/*++

    Routine Description:
    
        Checks if a packet needs to be loopbacked and does so if necessary.
        
        NOTE: Must be called at DPC_LEVEL with lock HELD!
    
    Arguments:
    
        Miniport    -   Miniport to send to.
        Packet      -   Packet to loopback.
    
    Return Value:
    
        FALSE if the packet should be sent on the net, TRUE if it is
        a self-directed packet.

--*/
{
    BOOLEAN                 Loopback;
    BOOLEAN                 SelfDirected;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_BUFFER            FirstBuffer, NewBuffer;
    PNDIS_PACKET            pNewPacket;
    UINT                    BufferLength = 0;
    PUCHAR                  BufferAddress;
    UINT                    Length;
    UINT                    BytesToCopy;
    UINT                    Offset;
    PVOID                   PacketMemToFree = NULL;


    // We should not be here if the driver handles loopback
    ASSERT(Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK);
    ASSERT(MINIPORT_AT_DPC_LEVEL);
    ASSERT(NdisMediumArcnet878_2 == Miniport->MediaType);

    FirstBuffer = Packet->Private.Head;
    BufferAddress = MDL_ADDRESS_SAFE(FirstBuffer, HighPagePriority);
    if (BufferAddress == NULL)
    {
        return(FALSE);      // Can't determine if it is a loopback packet
    }

    //
    //  Is this an ethernet encapsulated packet?
    //
    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
    if (ARC_PACKET_IS_ENCAPSULATED(NSR))
    {
        //
        // The second buffer in the packet is the ethernet
        // header so we need to get that one before we can
        // proceed.
        //
        NdisGetNextBuffer(FirstBuffer, &FirstBuffer);

        BufferAddress = MDL_ADDRESS_SAFE(FirstBuffer, HighPagePriority);

        if (BufferAddress == NULL)
        {
            return(FALSE);      // Can't determine if it is a loopback packet
        }

        //
        // Now we can continue as though this were ethernet.
        //
        EthShouldAddressLoopBackMacro(Miniport->EthDB,
                                      BufferAddress,
                                      &Loopback,
                                      &SelfDirected);
    }
    else
    {
        Loopback = ((BufferAddress[0] == BufferAddress[1]) ||
                   ((BufferAddress[1] == 0x00) &&
                   (ARC_QUERY_FILTER_CLASSES(Miniport->ArcDB) |
                   NDIS_PACKET_TYPE_BROADCAST)));
    
        if (BufferAddress[0] == BufferAddress[1])
        {
            SelfDirected = TRUE;
            Loopback = TRUE;
        }
        else
        {
            SelfDirected = FALSE;
        }
    }

    //
    //  If it's not a loopback packet then get out of here!
    //  
    if (!Loopback)
    {
        ASSERT(!SelfDirected);
        return(FALSE);
    }

    //
    // Get the buffer length
    //
    NdisQueryPacket(Packet, NULL, NULL, NULL, &Length);

    //
    // See if we need to copy the data from the packet
    // into the loopback buffer.
    //
    // We need to copy to the local loopback buffer if
    // the first buffer of the packet is less than the
    // minimum loopback size AND the first buffer isn't
    // the total packet. We always need to copy in case of encapsulation
    //
    if (ARC_PACKET_IS_ENCAPSULATED(NSR))
    {
        PNDIS_STACK_RESERVED NSR;
        NDIS_STATUS Status;
        UINT    PktSize;
        ULONG   j;


        //
        //  If the packet is encapsulated ethernet then don't count the
        //  arcnet header in with the length.
        //
        Length -= ARC_PROTOCOL_HEADER_SIZE;

        //
        //  Skip the fake arcnet header.
        //
        Offset = ARC_PROTOCOL_HEADER_SIZE;
        
        PktSize = NdisPacketSize(PROTOCOL_RESERVED_SIZE_IN_PACKET);


        //
        //  Allocate a buffer for the packet.
        //
        pNewPacket = (PNDIS_PACKET)ALLOC_FROM_POOL(Length + PktSize, NDIS_TAG_LOOP_PKT);
        PacketMemToFree = (PVOID)pNewPacket;
        
        if (NULL == pNewPacket)
        {
            return(FALSE);
        }
    
        ZeroMemory(pNewPacket, PktSize);
        BufferAddress = (PUCHAR)pNewPacket + PktSize;
        pNewPacket = (PNDIS_PACKET)((PUCHAR)pNewPacket + SIZE_PACKET_STACKS);

        for (j = 0; j < ndisPacketStackSize; j++)
        {
            CURR_STACK_LOCATION(pNewPacket) = j;
            NDIS_STACK_RESERVED_FROM_PACKET(pNewPacket, &NSR);
            INITIALIZE_SPIN_LOCK(&NSR->Lock);
        }

        CURR_STACK_LOCATION(pNewPacket) = -1;
        
        //
        //  Allocate an MDL for the packet.
        //
        NdisAllocateBuffer(&Status, &NewBuffer, NULL, BufferAddress, Length);
        if (NDIS_STATUS_SUCCESS != Status)
        {    
            FREE_POOL(PacketMemToFree);
            return(FALSE);
        }
    
        //
        //  NdisChainBufferAtFront()
        //
        pNewPacket->Private.Head = NewBuffer;
        pNewPacket->Private.Tail = NewBuffer;
        pNewPacket->Private.Pool = (PVOID)'pooL';
        pNewPacket->Private.NdisPacketOobOffset = (USHORT)(PktSize - (SIZE_PACKET_STACKS +
                                                                      sizeof(NDIS_PACKET_OOB_DATA) +
                                                                      sizeof(NDIS_PACKET_EXTENSION)));
                                                                      
        NDIS_SET_ORIGINAL_PACKET(pNewPacket, pNewPacket);
                                                                      
        ndisMCopyFromPacketToBuffer(Packet,     // Packet to copy from.
                                    Offset,     // Offset from beginning of packet.
                                    Length,     // Number of bytes to copy.
                                    BufferAddress,// The destination buffer.
                                    &BufferLength);
    
        MINIPORT_SET_PACKET_FLAG(pNewPacket, fPACKET_IS_LOOPBACK);
        pNewPacket->Private.Flags = NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK;
    }
    else if ((BufferLength < NDIS_M_MAX_LOOKAHEAD) && (BufferLength != Length))
    {
        //
        //  Copy the arcnet header.
        //
        BufferLength = MDL_SIZE(FirstBuffer);
        BytesToCopy = ARC_PROTOCOL_HEADER_SIZE;

        //
        //  Don't skip anything.
        //
        Offset = 0;

        BufferAddress = Miniport->ArcBuf->ArcnetLookaheadBuffer;
        BytesToCopy += Miniport->CurrentLookahead;

        ndisMCopyFromPacketToBuffer(Packet,             // Packet to copy from.
                                    Offset,             // Offset from beginning of packet.
                                    BytesToCopy,        // Number of bytes to copy.
                                    BufferAddress,      // The destination buffer.
                                    &BufferLength);     // The number of bytes copied.
    }

    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    //
    // Indicate the packet to every open binding
    // that could want it.
    //
    if (ARC_PACKET_IS_ENCAPSULATED(NSR))
    {
        NDIS_SET_PACKET_HEADER_SIZE(pNewPacket, 14);
        ethFilterDprIndicateReceivePacket(Miniport,
                                          &pNewPacket,
                                          1);
        NdisFreeBuffer(pNewPacket->Private.Head);
        FREE_POOL(PacketMemToFree);
    }
    else
    {
        PUCHAR  PlaceInBuffer;
        PUCHAR  ArcDataBuffer;
        UINT    ArcDataLength;
        UINT    PacketDataOffset;
        UCHAR   FrameCount;
        UCHAR   i;
        UINT    IndicateDataLength;

        //
        // Calculate how many frames we will need.
        //
        ArcDataLength = Length - ARC_PROTOCOL_HEADER_SIZE;
        PacketDataOffset = ARC_PROTOCOL_HEADER_SIZE;

        FrameCount = (UCHAR)(ArcDataLength / ARC_MAX_FRAME_SIZE);

        if ((ArcDataLength % ARC_MAX_FRAME_SIZE) != 0)
        {
            FrameCount++;
        }

        for (i = 0; i < FrameCount; ++i)
        {
            PlaceInBuffer = Miniport->ArcBuf->ArcnetLookaheadBuffer;

            //
            // Point data buffer to start of 'data'
            // Don't include system code as part of data
            //
            ArcDataBuffer = Miniport->ArcBuf->ArcnetLookaheadBuffer + ARC_PROTOCOL_HEADER_SIZE;

            //
            // Copy Header (SrcId/DestId/ProtId)
            //
            ndisMCopyFromPacketToBuffer(Packet,
                                        0,
                                        ARC_PROTOCOL_HEADER_SIZE,
                                        PlaceInBuffer,
                                        &BufferLength);

            PlaceInBuffer += ARC_PROTOCOL_HEADER_SIZE;

            //
            // Put in split flag
            //
            if (FrameCount > 1)
            {
                //
                // Multi-frame indication...
                //
                if ( i == 0 )
                {
                    //
                    // first frame
                    //

                    // *PlaceInBuffer = ( (FrameCount - 2) * 2 ) + 1;

                    *PlaceInBuffer = 2 * FrameCount - 3;
                }
                else
                {
                    //
                    // Subsequent frame
                    //
                    *PlaceInBuffer = ( i * 2 );
                }
            }
            else
            {
                //
                // Only frame in the indication
                //
                *PlaceInBuffer = 0;
            }

            //
            // Skip split flag
            //
            PlaceInBuffer++;

            //
            // Put in packet number.
            //
            *PlaceInBuffer++ = 0;
            *PlaceInBuffer++ = 0;

            //
            // Copy data
            //
            if (ArcDataLength > ARC_MAX_FRAME_SIZE)
            {
                IndicateDataLength = ARC_MAX_FRAME_SIZE;
            }
            else
            {
                IndicateDataLength = ArcDataLength;
            }

            ndisMCopyFromPacketToBuffer(Packet,
                                        PacketDataOffset,
                                        IndicateDataLength,
                                        PlaceInBuffer,
                                        &BufferLength);

            //
            //  Indicate the actual data length which should not
            //  include the system code.
            //
            ArcFilterDprIndicateReceive(Miniport->ArcDB,
                                        Miniport->ArcBuf->ArcnetLookaheadBuffer,
                                        ArcDataBuffer,
                                        IndicateDataLength + ARC_PROTOCOL_HEADER_SIZE);

            ArcDataLength -= ARC_MAX_FRAME_SIZE;
            PacketDataOffset += ARC_MAX_FRAME_SIZE;
        }

        ArcFilterDprIndicateReceiveComplete(Miniport->ArcDB);
    }

    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    return(SelfDirected);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\cdata.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    cdata.c

Abstract:

    NDIS wrapper Data

Author:

    01-Jun-1995 JameelH  Re-organization

Environment:

    Kernel mode, FSD

Revision History:

    10-July-1995    KyleB    Added spinlock logging debug code.

--*/

#include <precomp.h>
#pragma hdrstop

#include <initguid.h>
#include <ndisguid.h>
//
// Memphis uses a private wdmguid.h becuase the power guids are not defined
// in wdmguid.h in the build, so use "" instead of <>
//
#include "wdmguid.h"

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_DATA

OID_SETINFO_HANDLER ndisMSetInfoHandlers[] =
{
    { OID_GEN_CURRENT_PACKET_FILTER,    ndisMSetPacketFilter } ,
    { OID_GEN_CURRENT_LOOKAHEAD,        ndisMSetCurrentLookahead } ,
    { OID_GEN_PROTOCOL_OPTIONS,         ndisMSetProtocolOptions } ,
    { OID_802_3_MULTICAST_LIST,         ndisMSetMulticastList } ,
    { OID_802_5_CURRENT_FUNCTIONAL,     ndisMSetFunctionalAddress } ,
    { OID_802_5_CURRENT_GROUP,          ndisMSetGroupAddress } ,
    { OID_FDDI_LONG_MULTICAST_LIST,     ndisMSetFddiMulticastList } ,
    { OID_PNP_ADD_WAKE_UP_PATTERN,      ndisMSetAddWakeUpPattern } ,
    { OID_PNP_REMOVE_WAKE_UP_PATTERN,   ndisMSetRemoveWakeUpPattern } ,
    { OID_PNP_ENABLE_WAKE_UP,           ndisMSetEnableWakeUp },
    { 0,                                NULL }
};


BOOLEAN ndisMediaTypeCl[NdisMediumMax] =
{
    TRUE,
    TRUE,
    TRUE,
    FALSE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    FALSE,
    TRUE,
    TRUE,
    TRUE,
    FALSE,
    FALSE
};

NDIS_MEDIUM ndisMediumBuffer[NdisMediumMax + EXPERIMENTAL_SIZE] =   // Keep some space for experimental media
{
    NdisMedium802_3,
    NdisMedium802_5,
    NdisMediumFddi,
    NdisMediumWan,
    NdisMediumLocalTalk,
    NdisMediumDix,
    NdisMediumArcnetRaw,
    NdisMediumArcnet878_2,
    NdisMediumAtm,
    NdisMediumWirelessWan,
    NdisMediumIrda,
    NdisMediumBpc,
    NdisMediumCoWan,
    NdisMedium1394
};

NDIS_MEDIUM *           ndisMediumArray = ndisMediumBuffer;
UINT                    ndisMediumArraySize = NdisMediumMax * sizeof(NDIS_MEDIUM);
UINT                    ndisMediumArrayMaxSize = sizeof(ndisMediumBuffer);
WCHAR                   ndisHexLookUp[] = {L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F'};
ULONG                   ndisInstanceNumber = 0;
UINT                    ndisPacketStackSize = NUM_PACKET_STACKS;


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

//
//  Array of the GUIDs that represent the General OIDs
//
NDIS_GUID               ndisSupportedGuids[36] =
{
    //
    //  GUIDs that do get passed to the miniport.
    //
    {{0x981f2d7f, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ENUMERATE_ADAPTER
     0,
     -1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_ALLOW_READ
    },
    {{0x981f2d80, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_NOTIFY_ADAPTER_REMOVAL
     0,
     -1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_TO_STATUS
    },
    {{0x981f2d81, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL
     0,
     -1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_TO_STATUS
    },
    {{0x827c0a6fL, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a}, //  GUID_POWER_DEVICE_ENABLE
     0,
    -1,
    fNDIS_GUID_NDIS_ONLY
    },
    {{0xa9546a82L, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a}, //  GUID_POWER_DEVICE_WAKE_ENABLE
     0,
    -1,
    fNDIS_GUID_NDIS_ONLY
    },
    {{0x981f2d82, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ENUMERATE_VC
     0,
     0, //  No data for this GUID
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_ALLOW_READ
    },
    {{0x981f2d79, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_NOTIFY_VC_REMOVAL
     0,
     0, //  No data for this GUID 
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_TO_STATUS | fNDIS_GUID_CO_NDIS
    },
    {{0x182f9e0c, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_NOTIFY_VC_ARRIVAL
     0,
     0, //  No data for this GUID 
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_NDIS_ONLY | fNDIS_GUID_TO_STATUS | fNDIS_GUID_CO_NDIS
    },
    {{0xa14f1c97, 0x8839, 0x4f8a, 0x99, 0x96, 0xa2, 0x89, 0x96, 0xeb, 0xbf, 0x1d},  //  GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY
     0,
    -1,
    fNDIS_GUID_NDIS_ONLY
    },
    

    //
    //  General oids.
    //
    {{0x5ec10354, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_HARDWARE_STATUS
     OID_GEN_HARDWARE_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10355, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MEDIA_SUPPORTED
     OID_GEN_MEDIA_SUPPORTED,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10356, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MEDIA_IN_USE
     OID_GEN_MEDIA_IN_USE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10357, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MAXIMUM_LOOKAHEAD
     OID_GEN_MAXIMUM_LOOKAHEAD,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10358, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MAXIMUM_FRAME_SIZE
     OID_GEN_MAXIMUM_FRAME_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10359, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_LINK_SPEED
     OID_GEN_LINK_SPEED,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035a, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_TRANSMIT_BUFFER_SPACE
     OID_GEN_TRANSMIT_BUFFER_SPACE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035b, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_RECEIVE_BUFFER_SPACE
     OID_GEN_RECEIVE_BUFFER_SPACE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035c, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_TRANSMIT_BLOCK_SIZE
     OID_GEN_TRANSMIT_BLOCK_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035d, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_RECEIVE_BLOCK_SIZE
     OID_GEN_RECEIVE_BLOCK_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035e, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_VENDOR_ID
     OID_GEN_VENDOR_ID,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec1035f, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_VENDOR_DESCRIPTION
     OID_GEN_VENDOR_DESCRIPTION,
     -1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ANSI_STRING | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10360, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_CURRENT_PACKET_FILTER
     OID_GEN_CURRENT_PACKET_FILTER,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10361, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_CURRENT_LOOKAHEAD
     OID_GEN_CURRENT_LOOKAHEAD,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10362, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_DRIVER_VERSION
     OID_GEN_DRIVER_VERSION,
     2,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10363, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MAXIMUM_TOTAL_SIZE
     OID_GEN_MAXIMUM_TOTAL_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10365, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MAC_OPTIONS
     OID_GEN_MAC_OPTIONS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10366, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MEDIA_CONNECT_STATUS
     OID_GEN_MEDIA_CONNECT_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x5ec10367, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_MAXIMUM_SEND_PACKETS
     OID_GEN_MAXIMUM_SEND_PACKETS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x447956f9, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_VENDOR_DRIVER_VERSION
     OID_GEN_VENDOR_DRIVER_VERSION,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x765dc702, 0xc5e8, 0x4b67, 0x84, 0x3b, 0x3f, 0x5a, 0x4f, 0xf2, 0x64, 0x8b},   //  GUID_NDIS_GEN_VLAN_ID
     OID_GEN_VLAN_ID,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x418ca16d, 0x3937, 0x4208, 0x94, 0x0a, 0xec, 0x61, 0x96, 0x27, 0x80, 0x85},   //  GUID_NDIS_GEN_PHYSICAL_MEDIUM
     OID_GEN_PHYSICAL_MEDIUM,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },    

    //
    //  General required statistics.
    //
    {{0x447956fa, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_XMIT_OK
     OID_GEN_XMIT_OK,
     sizeof(ULONG64),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x447956fb, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_RCV_OK
     OID_GEN_RCV_OK,
     sizeof(ULONG64),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x447956fc, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_XMIT_ERROR
     OID_GEN_XMIT_ERROR,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x447956fd, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_RCV_ERROR
     OID_GEN_RCV_ERROR,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x447956fe, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_GEN_RCV_NO_BUFFER
     OID_GEN_RCV_NO_BUFFER,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    }
};

NDIS_GUID               ndisCoSupportedGuids[16] =
{
    //
    //  CoNDIS general required oids
    //
    {{0x791ad192, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_HARDWARE_STATUS
     OID_GEN_CO_HARDWARE_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad193, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_MEDIA_SUPPORTED
     OID_GEN_CO_MEDIA_SUPPORTED,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad194, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_MEDIA_IN_USE
     OID_GEN_CO_MEDIA_IN_USE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad195, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_LINK_SPEED
     OID_GEN_CO_LINK_SPEED,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad196, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_VENDOR_ID
     OID_GEN_CO_VENDOR_ID,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad197, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_VENDOR_DESCRIPTION
     OID_GEN_CO_VENDOR_DESCRIPTION,
     -1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ANSI_STRING | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad198, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_DRIVER_VERSION
     OID_GEN_CO_DRIVER_VERSION,
     2,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad19a, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_MAC_OPTIONS
     OID_GEN_CO_MAC_OPTIONS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad19b, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_MEDIA_CONNECT_STATUS
     OID_GEN_CO_MEDIA_CONNECT_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad19c, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_VENDOR_DRIVER_VERSION
     OID_GEN_CO_VENDOR_DRIVER_VERSION,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x791ad19d, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_GEN_CO_MINIMUM_LINK_SPEED
     OID_GEN_CO_MINIMUM_LINK_SPEED,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },

    //
    //  CoNDIS general required statistics.
    //
    {{0x0a214805, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  NDIS_GUID_GEN_CO_XMIT_PDUS_OK
     OID_GEN_CO_XMIT_PDUS_OK,
     sizeof(ULONG64),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a214806, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   // GUID_NDIS_GEN_CO_RCV_PDUS_OK
     OID_GEN_CO_RCV_PDUS_OK,
     sizeof(ULONG64),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a214807, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   // GUID_NDIS_GEN_CO_XMIT_PDUS_ERROR
     OID_GEN_CO_XMIT_PDUS_ERROR,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a214808, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   // GUID_NDIS_GEN_CO_RCV_PDUS_ERROR
     OID_GEN_CO_RCV_PDUS_ERROR,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a214809, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   // GUID_NDIS_GEN_CO_RCV_PDUS_NO_BUFFER
     OID_GEN_CO_RCV_PDUS_NO_BUFFER,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    }
};

NDIS_GUID               ndisMediaSupportedGuids[75] =
{
    //
    //  802.3 required oids.
    //
    {{0x447956ff, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_802_3_PERMANENT_ADDRESS
     OID_802_3_PERMANENT_ADDRESS,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795700, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_CURRENT_ADDRESS
     OID_802_3_CURRENT_ADDRESS,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795701, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_MULTICAST_LIST
     OID_802_3_MULTICAST_LIST,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795702, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_MAXIMUM_LIST_SIZE
     OID_802_3_MAXIMUM_LIST_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795703, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_MAC_OPTIONS
     OID_802_3_MAC_OPTIONS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  802.3 required statistics oids.
    //
    {{0x44795704, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_RCV_ERROR_ALIGNMENT
     OID_802_3_RCV_ERROR_ALIGNMENT,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795705, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_XMIT_ONE_COLLISION
     OID_802_3_XMIT_ONE_COLLISION,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795706, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_3_XMIT_MORE_COLLISIONS
     OID_802_3_XMIT_MORE_COLLISIONS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  802.5 required oids.
    //
    {{0x44795707, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_802_5_PERMANENT_ADDRESS
     OID_802_5_PERMANENT_ADDRESS,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795708, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_CURRENT_ADDRESS
     OID_802_5_CURRENT_ADDRESS,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x44795709, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_CURRENT_FUNCTIONAL
     OID_802_5_CURRENT_FUNCTIONAL,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x4479570a, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_CURRENT_GROUP
     OID_802_5_CURRENT_GROUP,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x4479570b, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_LAST_OPEN_STATUS
     OID_802_5_LAST_OPEN_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0x890a36ec, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_CURRENT_RING_STATUS
     OID_802_5_CURRENT_RING_STATUS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14032, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_CURRENT_RING_STATE
     OID_802_5_CURRENT_RING_STATE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  802.5 required statistics oids.
    //
    {{0xacf14033, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_LINE_ERRORS
     OID_802_5_LINE_ERRORS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14034, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_802_5_LOST_FRAMES
     OID_802_5_LOST_FRAMES,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  FDDI required oids.
    //
    {{0xacf14035, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_FDDI_LONG_PERMANENT_ADDR
     OID_FDDI_LONG_PERMANENT_ADDR,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14036, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LONG_CURRENT_ADDR
     OID_FDDI_LONG_CURRENT_ADDR,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14037, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LONG_MULTICAST_LIST
     OID_FDDI_LONG_MULTICAST_LIST,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14038, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LONG_MAX_LIST_SIZE
     OID_FDDI_LONG_MAX_LIST_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14039, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_SHORT_PERMANENT_ADDR
     OID_FDDI_SHORT_PERMANENT_ADDR,
     2,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf1403a, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_SHORT_CURRENT_ADDR
     OID_FDDI_SHORT_CURRENT_ADDR,
     2,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf1403b, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_SHORT_MULTICAST_LIST
     OID_FDDI_SHORT_MULTICAST_LIST,
     2,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf1403c, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_SHORT_MAX_LIST_SIZE
     OID_FDDI_SHORT_MAX_LIST_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  FDDI required statistics oids.
    //
    {{0xacf1403d, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_ATTACHMENT_TYPE
     OID_FDDI_ATTACHMENT_TYPE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf1403e, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_UPSTREAM_NODE_LONG
     OID_FDDI_UPSTREAM_NODE_LONG,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf1403f, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_DOWNSTREAM_NODE_LONG
     OID_FDDI_DOWNSTREAM_NODE_LONG,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14040, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_FRAME_ERRORS
     OID_FDDI_FRAME_ERRORS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14041, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_FRAMES_LOST
     OID_FDDI_FRAMES_LOST,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14042, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_RING_MGT_STATE
     OID_FDDI_RING_MGT_STATE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14043, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LCT_FAILURES
     OID_FDDI_LCT_FAILURES,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14044, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LEM_REJECTS
     OID_FDDI_LEM_REJECTS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },
    {{0xacf14045, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},   //  GUID_NDIS_FDDI_LCONNECTION_STATE
     OID_FDDI_LCONNECTION_STATE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    //
    //  Wireless (802.11) OIDs.
    //
    {{0x2504b6c2, 0x1fa5, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_BSSID
     OID_802_11_BSSID,
     sizeof(NDIS_802_11_MAC_ADDRESS),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x7d2a90ea, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_SSID
     OID_802_11_SSID,
     sizeof(NDIS_802_11_SSID),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x8531d6e6, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_NETWORK_TYPES_SUPPORTED
     OID_802_11_NETWORK_TYPES_SUPPORTED,
     -1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x857e2326, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_NETWORK_TYPE_IN_USE
     OID_802_11_NETWORK_TYPE_IN_USE,
     sizeof(NDIS_802_11_NETWORK_TYPE),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x85be837c, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_POWER_MODE
     OID_802_11_POWER_MODE,
     sizeof(NDIS_802_11_POWER_MODE),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x11e6ba76, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_TX_POWER_LEVEL
     OID_802_11_TX_POWER_LEVEL,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x1507db16, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_RSSI
     OID_802_11_RSSI,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x155689b8, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_RSSI_TRIGGER
     OID_802_11_RSSI_TRIGGER,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x69526f9a, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_BSSID_LIST
     OID_802_11_BSSID_LIST,
     -1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x697d5a7e, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_INFRASTRUCTURE_MODE
     OID_802_11_INFRASTRUCTURE_MODE,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x69aaa7c4, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_FRAGMENTATION_THRESHOLD
     OID_802_11_FRAGMENTATION_THRESHOLD,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x0134d07e, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_RTS_THRESHOLD
     OID_802_11_RTS_THRESHOLD,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x01779336, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_NUMBER_OF_ANTENNAS
     OID_802_11_NUMBER_OF_ANTENNAS,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x01ac07a2, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_RX_ANTENNA_SELECTED
     OID_802_11_RX_ANTENNA_SELECTED,
     sizeof(ULONG),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x01dbb74a, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_TX_ANTENNA_SELECTED
     OID_802_11_TX_ANTENNA_SELECTED,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x49db8722, 0x2068, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_SUPPORTED_RATES
     OID_802_11_SUPPORTED_RATES,
     -1,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x452ee08e, 0x2536, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_DESIRED_RATES
     OID_802_11_DESIRED_RATES,
     -1,
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x4a4df982, 0x2068, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_CONFIGURATION
     OID_802_11_CONFIGURATION,
     sizeof(NDIS_802_11_CONFIGURATION),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x42bb73b0, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_STATISTICS
     OID_802_11_STATISTICS,
     sizeof(NDIS_802_11_STATISTICS),
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x4307bff0, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_ADD_WEP
     OID_802_11_ADD_WEP,
     sizeof(NDIS_802_11_WEP),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x433c345c, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_REMOVE_WEP
     OID_802_11_REMOVE_WEP,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x43671f40, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_DISASSOCIATE
     OID_802_11_DISASSOCIATE,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x0d9e01e1, 0xba70, 0x11d4, 0xb6, 0x75, 0x00, 0x20, 0x48, 0x57, 0x03, 0x37},  // GUID_NDIS_802_11_BSSID_LIST_SCAN
     OID_802_11_BSSID_LIST_SCAN,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x43920a24, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_AUTHENTICATION_MODE
     OID_802_11_AUTHENTICATION_MODE,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x6733c4e9, 0x4792, 0x11d4, 0x97, 0xf1, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03},  // GUID_NDIS_802_11_PRIVACY_FILTER
     OID_802_11_PRIVACY_FILTER,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0xb027a21f, 0x3cfa, 0x4125, 0x80, 0x0b, 0x3f, 0x7a, 0x18, 0xfd, 0xdc, 0xdc},  // GUID_NDIS_802_11_WEP_STATUS
     OID_802_11_WEP_STATUS,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },

    {{0x748b14e8, 0x32ee, 0x4425, 0xb9, 0x1b, 0xc9, 0x84, 0x8c, 0x58, 0xb5, 0x5a},  // GUID_NDIS_802_11_RELOAD_DEFAULTS
     OID_802_11_RELOAD_DEFAULTS,
     sizeof(ULONG),
     fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ
    },


    //
    //  ATM required oids.
    //
    {{0x791ad19e, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_SUPPORTED_VC_RATES
     OID_ATM_SUPPORTED_VC_RATES,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad19f, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_SUPPORTED_SERVICE_CATEGORY
     OID_ATM_SUPPORTED_SERVICE_CATEGORY,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a0, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_SUPPORTED_AAL_TYPES
     OID_ATM_SUPPORTED_AAL_TYPES,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a1, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_HW_CURRENT_ADDRESS
     OID_ATM_HW_CURRENT_ADDRESS,
     6,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a2, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_ACTIVE_VCS
     OID_ATM_MAX_ACTIVE_VCS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a3, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_ACTIVE_VCI_BITS
     OID_ATM_MAX_ACTIVE_VCI_BITS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a4, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_ACTIVE_VPI_BITS
     OID_ATM_MAX_ACTIVE_VPI_BITS,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a5, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_AAL0_PACKET_SIZE
     OID_ATM_MAX_AAL0_PACKET_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a6, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_AAL1_PACKET_SIZE
     OID_ATM_MAX_AAL1_PACKET_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad1a7, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_AAL34_PACKET_SIZE
     OID_ATM_MAX_AAL34_PACKET_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },                                                                                  
    {{0x791ad191, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_MAX_AAL5_PACKET_SIZE
     OID_ATM_MAX_AAL5_PACKET_SIZE,
     4,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },

    //
    //  ATM required statistics oids.
    //
    {{0x0a21480a, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_RCV_CELLS_OK
     OID_ATM_RCV_CELLS_OK,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a21480b, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_XMIT_CELLS_OK
     OID_ATM_XMIT_CELLS_OK,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    },
    {{0x0a21480c, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},  //  GUID_NDIS_ATM_RCV_CELLS_DROPPED
     OID_ATM_RCV_CELLS_DROPPED,
     8,
     fNDIS_GUID_NOT_SETTABLE | fNDIS_GUID_TO_OID | fNDIS_GUID_CO_NDIS | fNDIS_GUID_ALLOW_READ
    }
};

NDIS_GUID               ndisStatusSupportedGuids[10] =
{
    //
    //  NDIS Status indications (WMI Events)
    //
    {
     {0x981f2d76, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_RESET_START,
     0,
     fNDIS_GUID_TO_STATUS
    },
    {
     {0x981f2d77, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_RESET_END,
     0,
     fNDIS_GUID_TO_STATUS
    },
    {
     {0x981f2d7d, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_MEDIA_CONNECT,
     0,
     fNDIS_GUID_TO_STATUS
    },
    {
     {0x981f2d7e, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_MEDIA_DISCONNECT,
     0,
     fNDIS_GUID_TO_STATUS
    },
    {
     {0x981f2d84, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_MEDIA_SPECIFIC_INDICATION,
     1,
     fNDIS_GUID_TO_STATUS | fNDIS_GUID_ARRAY
    },
    {
     {0x981f2d85, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c},
     NDIS_STATUS_LINK_SPEED_CHANGE,
     8,     //  sizeof(NDIS_CO_LINK_SPEED)
     fNDIS_GUID_TO_STATUS
    },

    /* The following are not really status indications, however we park them here for convenience */
    {
     {0x5413531c, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c}, // GUID_NDIS_NOTIFY_BIND
     0,
     -1,
     0,
    },
    {
     {0x6e3ce1ec, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c}, // GUID_NDIS_NOTIFY_UNBIND
     0,
     -1,
     0,
    },
    {
     {0x5f81cfd0, 0xf046, 0x4342, 0xaf, 0x61, 0x89, 0x5a, 0xce, 0xda, 0xef, 0xd9}, // GUID_NDIS_NOTIFY_DEVICE_POWER_ON
     0,
     (ULONG)-1,
     0,
    },
    {
     {0x81bc8189, 0xb026, 0x46ab, 0xb9, 0x64, 0xf1, 0x82, 0xe3, 0x42, 0x93, 0x4e}, // GUID_NDIS_NOTIFY_DEVICE_POWER_OFF
     0,
     (ULONG)-1,
     0,
    }
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\muxim\protocol.c ===
/*++

Copyright(c) 1992-2000  Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    NDIS Protocol Entry points and utility functions for the NDIS
    MUX Intermediate Miniport sample.

    The protocol edge binds to Ethernet (NdisMedium802_3) adapters,
    and initiates creation of zero or more Virtual Ethernet LAN (VELAN)
    miniport instances by calling NdisIMInitializeDeviceInstanceEx once
    for each VELAN configured over a lower binding.

Environment:

    Kernel mode.

Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


#define MODULE_NUMBER           MODULE_PROT

VOID
PtBindAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            DeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    )
/*++

Routine Description:

    Called by NDIS to bind to a miniport below. This routine
    creates a binding by calling NdisOpenAdapter, and then
    initiates creation of all configured VELANs on this binding.

Arguments:

    Status            - Return status of bind here.
    BindContext       - Can be passed to NdisCompleteBindAdapter if this 
                        call is pended.
    DeviceName        - Device name to bind to. This is passed to 
                            NdisOpenAdapter.
    SystemSpecific1   - Can be passed to NdisOpenProtocolConfiguration to
                            read per-binding information
    SystemSpecific2   - Unused


Return Value:

    *Status is set to NDIS_STATUS_SUCCESS if no failure occurred
    while handling this call, otherwise an error code.

--*/
{
    PADAPT                            pAdapt = NULL;
    NDIS_STATUS                       OpenErrorStatus;
    UINT                              MediumIndex;
    PNDIS_STRING                      pConfigString;
    ULONG                             Length;

    pConfigString = (PNDIS_STRING)SystemSpecific1;
    
    DBGPRINT(MUX_LOUD, ("==> Protocol BindAdapter: %ws\n", pConfigString->Buffer));
   
    do
    {

        //
        // Allocate memory for Adapter struct plus the config
        // string with two extra WCHARs for NULL termination.
        //
        Length = sizeof(ADAPT) + 
                    pConfigString->MaximumLength + sizeof(WCHAR);
        
        NdisAllocateMemoryWithTag(&pAdapt, Length , TAG);

        if (pAdapt == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
             break;
        }
        
        //
        // Initialize the adapter structure
        //
        NdisZeroMemory(pAdapt, sizeof(ADAPT));        

        (VOID)PtReferenceAdapter(pAdapt, "openadapter");        
        

        //
        //  Copy in the Config string - we will use this to open the
        //  registry section for this adapter at a later point.
        //
        pAdapt->ConfigString.MaximumLength = pConfigString->MaximumLength;
        pAdapt->ConfigString.Length = pConfigString->Length;
        pAdapt->ConfigString.Buffer = (PWCHAR)((PUCHAR)pAdapt + 
                            sizeof(ADAPT));

        NdisMoveMemory(pAdapt->ConfigString.Buffer,
                       pConfigString->Buffer,
                       pConfigString->Length);
        pAdapt->ConfigString.Buffer[pConfigString->Length/sizeof(WCHAR)] = 
                                    ((WCHAR)0);

        NdisInitializeEvent(&pAdapt->Event);
        NdisInitializeListHead(&pAdapt->VElanList);

        pAdapt->PtDevicePowerState = NdisDeviceStateD0;

        MUX_INIT_ADAPT_RW_LOCK(pAdapt);

        //
        // TODO: Allocate a packet pool and buffers for send & receive.
        //
        // Now open the adapter below and complete the initialization
        //
        NdisOpenAdapter(Status,
                          &OpenErrorStatus,
                          &pAdapt->BindingHandle,
                          &MediumIndex,
                          MediumArray,
                          sizeof(MediumArray)/sizeof(NDIS_MEDIUM),
                          ProtHandle,
                          pAdapt,
                          DeviceName,
                          0,
                          NULL);

        if (*Status == NDIS_STATUS_PENDING)
        {
              NdisWaitEvent(&pAdapt->Event, 0);
              *Status = pAdapt->Status;
        }

        if (*Status != NDIS_STATUS_SUCCESS)
        {
              break;
        }
       
        pAdapt->Medium = MediumArray[MediumIndex];

        //
        // Add this adapter to the global AdapterList
        //
        MUX_ACQUIRE_MUTEX(&GlobalMutex);

        InsertTailList(&AdapterList, &pAdapt->Link);

        MUX_RELEASE_MUTEX(&GlobalMutex);

        //
        // Get some information from the adapter below.
        //
        PtQueryAdapterInfo(pAdapt);

        //
        // Start all VELANS configured on this adapter.
        //
        PtBootStrapVElans(pAdapt);        
       
    } while(FALSE);

    if (*Status != NDIS_STATUS_SUCCESS)
    {
        if (pAdapt != NULL)
        {
            PtDereferenceAdapter(pAdapt, "openadapter");
            pAdapt = NULL;
        }
    }


    DBGPRINT(MUX_INFO, ("<== Protocol BindAdapter: pAdapt %p, Status %x\n", pAdapt, *Status));
}


VOID
PtOpenAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenErrorStatus
    )
/*++

Routine Description:

    Completion routine for NdisOpenAdapter issued from within the 
    PtBindAdapter. Simply unblock the caller.

Arguments:

    ProtocolBindingContext    Pointer to the adapter
    Status                    Status of the NdisOpenAdapter call
    OpenErrorStatus            Secondary status(ignored by us).

Return Value:

    None

--*/
{
    PADAPT      pAdapt =(PADAPT)ProtocolBindingContext;

    DBGPRINT(MUX_LOUD, ("==> PtOpenAdapterComplete: Adapt %p, Status %x\n", pAdapt, Status));
    pAdapt->Status = Status;
    NdisSetEvent(&pAdapt->Event);
}


VOID
PtQueryAdapterInfo(
    IN  PADAPT                  pAdapt
    )
/*++

Routine Description:

    Query the adapter we are bound to for some standard OID values
    which we cache.

Arguments:

    pAdapt              Pointer to the adapter


Return Value:

    None
--*/
{
    
    //
    // Get the link speed.
    //
    pAdapt->LinkSpeed = MUX_DEFAULT_LINK_SPEED;
    PtQueryAdapterSync(pAdapt,
                       OID_GEN_LINK_SPEED,
                       &pAdapt->LinkSpeed,
                       sizeof(pAdapt->LinkSpeed));

    //
    // Get the max lookahead size.
    //
    pAdapt->MaxLookAhead = MUX_DEFAULT_LOOKAHEAD_SIZE;
    PtQueryAdapterSync(pAdapt,
                       OID_GEN_MAXIMUM_LOOKAHEAD,
                       &pAdapt->MaxLookAhead,
                       sizeof(pAdapt->MaxLookAhead));

    //
    // Get the Ethernet MAC address.
    //
    PtQueryAdapterSync(pAdapt,
                       OID_802_3_CURRENT_ADDRESS,
                       &pAdapt->CurrentAddress,
                       sizeof(pAdapt->CurrentAddress));
}


VOID
PtQueryAdapterSync(
    IN  PADAPT                      pAdapt,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       InformationBuffer,
    IN  ULONG                       InformationBufferLength
    )
/*++

Routine Description:

    Utility routine to query the adapter for a single OID value. This
    blocks for the query to complete.

Arguments:

    pAdapt                      Pointer to the adapter
    Oid                         OID to query for
    InformationBuffer           Place for the result
    InformationBufferLength     Length of the above

Return Value:

    None.

--*/
{
    PMUX_NDIS_REQUEST       pMuxNdisRequest = NULL;
    NDIS_STATUS             Status;

    do
    {
        NdisAllocateMemoryWithTag(&pMuxNdisRequest, sizeof(MUX_NDIS_REQUEST), TAG);
        if (pMuxNdisRequest == NULL)
        {
            break;
        }

        pMuxNdisRequest->pVElan = NULL; // internal request

        //
        // Set up completion routine.
        //
        pMuxNdisRequest->pCallback = PtCompleteBlockingRequest;
        NdisInitializeEvent(&pMuxNdisRequest->Event);

        pMuxNdisRequest->Request.RequestType = NdisRequestQueryInformation;
        pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.Oid = Oid;
        pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.InformationBuffer =
                            InformationBuffer;
        pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.InformationBufferLength =
                                                InformationBufferLength;

        NdisRequest(&Status,
                    pAdapt->BindingHandle,
                    &pMuxNdisRequest->Request);
        
        if (Status == NDIS_STATUS_PENDING)
        {
            NdisWaitEvent(&pMuxNdisRequest->Event, 0);
            Status = pMuxNdisRequest->Status;
        }
    }
    while (FALSE);

    if (NULL != pMuxNdisRequest)
    {
        NdisFreeMemory(pMuxNdisRequest, sizeof(MUX_NDIS_REQUEST), 0);
    }
}



VOID
PtRequestAdapterAsync(
    IN  PADAPT                      pAdapt,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       InformationBuffer,
    IN  ULONG                       InformationBufferLength,
    IN  PMUX_REQ_COMPLETE_HANDLER   pCallback
    )
/*++

Routine Description:

    Utility routine to query the adapter for a single OID value.
    This completes asynchronously, i.e. the calling thread is
    not blocked until the request completes.

Arguments:

    pAdapt                      Pointer to the adapter
    RequestType                 NDIS request type
    Oid                         OID to set/query
    InformationBuffer           Input/output buffer
    InformationBufferLength     Length of the above
    pCallback                   Function to call on request completion

Return Value:

    None.

--*/
{
    PMUX_NDIS_REQUEST       pMuxNdisRequest = NULL;
    PNDIS_REQUEST           pNdisRequest;
    NDIS_STATUS             Status;

    do
    {
        NdisAllocateMemoryWithTag(&pMuxNdisRequest, sizeof(MUX_NDIS_REQUEST), TAG);
        if (pMuxNdisRequest == NULL)
        {
            break;
        }

        pMuxNdisRequest->pVElan = NULL; // internal request

        //
        // Set up completion routine.
        //
        pMuxNdisRequest->pCallback = pCallback;

        pNdisRequest = &pMuxNdisRequest->Request;

        pNdisRequest->RequestType = RequestType;

        switch (RequestType)
        {
            case NdisRequestQueryInformation:
                pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
                pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                                    InformationBuffer;
                pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                                    InformationBufferLength;
        
                break;

            case NdisRequestSetInformation:
                pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
                pNdisRequest->DATA.SET_INFORMATION.InformationBuffer =
                                    InformationBuffer;
                pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
                                    InformationBufferLength;
        
                break;
            
            default:
                ASSERT(FALSE);
                break;
        }

        NdisRequest(&Status,
                    pAdapt->BindingHandle,
                    pNdisRequest);
        
        if (Status != NDIS_STATUS_PENDING)
        {
            PtRequestComplete(
                (NDIS_HANDLE)pAdapt,
                pNdisRequest,
                Status);
        }
    }
    while (FALSE);
}

            
VOID
PtUnbindAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             UnbindContext
    )
/*++

Routine Description:

    Called by NDIS when we are required to unbind to the adapter below.
    Go through all VELANs on the adapter and shut them down.

Arguments:

    Status                    Placeholder for return status
    ProtocolBindingContext    Pointer to the adapter structure
    UnbindContext             Context for NdisUnbindComplete() if this pends

Return Value:

    Status from closing the binding.

--*/
{
    PADAPT          pAdapt =(PADAPT)ProtocolBindingContext;
    PLIST_ENTRY     p;
    PVELAN          pVElan = NULL;
    LOCK_STATE      LockState;

    DBGPRINT(MUX_LOUD, ("==> PtUnbindAdapter: Adapt %p\n", pAdapt));

    //
    // Stop all VELANs associated with the adapter.
    // Repeatedly find the first unprocessed VELAN on
    // the adapter, mark it, and stop it.
    //
    MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

    do
    {
        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            pVElan = CONTAINING_RECORD(p, VELAN, Link);
            if (!pVElan->DeInitializing)
            {
                pVElan->DeInitializing = TRUE;
                break;
            }
        }

        if (p != &pAdapt->VElanList)
        {
            ASSERT(pVElan == CONTAINING_RECORD(p, VELAN, Link));

            //
            // Got a VELAN to stop. Add a temp ref
            // so that the VELAN won't go away when
            // we release the ADAPT lock below.
            //
            PtReferenceVElan(pVElan, "UnbindTemp");

            //
            // Release the read lock because we want to
            // run StopVElan at passive IRQL.
            //
            MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);
    
            PtStopVElan(pVElan);
    
            PtDereferenceVElan(pVElan, "UnbindTemp");

            MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);
        }
        else
        {
            //
            // No unmarked VELAN, so exit.
            //
            break;
        }
    }
    while (TRUE);

    //
    // Wait until all VELANs are unlinked from the adapter.
    // This is so that we don't attempt to forward down packets
    // and/or requests from VELANs after calling NdisCloseAdapter.
    //
    while (!IsListEmpty(&pAdapt->VElanList))
    {
        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

        DBGPRINT(MUX_INFO, ("PtUnbindAdapter: pAdapt %p, VELANlist not yet empty\n",
                    pAdapt));

        NdisMSleep(2000);

        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);
    }

    MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

    //
    // Close the binding to the lower adapter.
    //
    if (pAdapt->BindingHandle != NULL)
    {
        NdisResetEvent(&pAdapt->Event);

        NdisCloseAdapter(Status, pAdapt->BindingHandle);

        //
        // Wait for it to complete.
        //
        if (*Status == NDIS_STATUS_PENDING)
        {
             NdisWaitEvent(&pAdapt->Event, 0);
             *Status = pAdapt->Status;
        }
    }
    else
    {
        //
        // Binding Handle should not be NULL.
        //
        *Status = NDIS_STATUS_FAILURE;
        ASSERT(0);
    }

    //
    // Remove the adapter from the global AdapterList
    //
    
    MUX_ACQUIRE_MUTEX(&GlobalMutex);

    RemoveEntryList(&pAdapt->Link);

    MUX_RELEASE_MUTEX(&GlobalMutex);

    //
    // Free all the resources associated with this Adapter except the
    // ADAPT struct itself, because that will be freed by 
    // PtDereferenceAdapter call when the reference drops to zero. 
    // Note: Every VELAN associated with this Adapter takes a ref count
    // on it. So the adapter memory wouldn't be freed until all the VELANs
    // are shutdown. 
    //
    
    PtDereferenceAdapter(pAdapt, "Unbind");
    DBGPRINT(MUX_INFO, ("<== PtUnbindAdapter: Adapt %p\n", pAdapt));
}



VOID
PtCloseAdapterComplete(
    IN    NDIS_HANDLE            ProtocolBindingContext,
    IN    NDIS_STATUS            Status
    )
/*++

Routine Description:

    Completion for the CloseAdapter call.

Arguments:

    ProtocolBindingContext    Pointer to the adapter structure
    Status                    Completion status

Return Value:

    None.

--*/
{
    PADAPT      pAdapt =(PADAPT)ProtocolBindingContext;

    DBGPRINT(MUX_INFO, ("==> PtCloseAdapterComplete: Adapt %p, Status %x\n", 
                                pAdapt, Status));

    pAdapt->Status = Status;
    NdisSetEvent(&pAdapt->Event);
}


VOID
PtResetComplete(
    IN  NDIS_HANDLE            ProtocolBindingContext,
    IN  NDIS_STATUS            Status
    )
/*++

Routine Description:

    Completion for the reset.

Arguments:

    ProtocolBindingContext    Pointer to the adapter structure
    Status                    Completion status

Return Value:

    None.

--*/
{
    PADAPT    pAdapt =(PADAPT)ProtocolBindingContext;

    DBGPRINT(MUX_ERROR, ("==> PtResetComplete: Adapt %p, Status %x\n", 
                                pAdapt, Status));

    //
    // We never issue a reset, so we should not be here.
    //
    ASSERT(0);
}


VOID
PtRequestComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNDIS_REQUEST               NdisRequest,
    IN  NDIS_STATUS                 Status
    )
/*++

Routine Description:

    Completion handler for an NDIS request sent to a lower
    miniport.

Arguments:

    ProtocolBindingContext    Pointer to the adapter structure
    NdisRequest               The completed request
    Status                    Completion status

Return Value:

    None

--*/
{
    PADAPT              pAdapt = (PADAPT)ProtocolBindingContext;
    PMUX_NDIS_REQUEST   pMuxNdisRequest;

    pMuxNdisRequest = CONTAINING_RECORD(NdisRequest, MUX_NDIS_REQUEST, Request);

    ASSERT(pMuxNdisRequest->pCallback != NULL);

    //
    // Completion is handled by the callback routine:
    //
    (*pMuxNdisRequest->pCallback)(pAdapt, 
                                  pMuxNdisRequest,
                                  Status);

}


VOID
PtCompleteForwardedRequest(
    IN PADAPT                       pAdapt,
    IN PMUX_NDIS_REQUEST            pMuxNdisRequest,
    IN NDIS_STATUS                  Status
    )
/*++

Routine Description:

    Handle completion of an NDIS request that was originally
    submitted to our VELAN miniport and was forwarded down
    to the lower binding.

    We do some postprocessing, to cache the results of
    certain queries.

Arguments:

    pAdapt  - Adapter on which the request was forwarded
    pMuxNdisRequest - super-struct for request
    Status - request completion status

Return Value:

    None

--*/
{
    PVELAN              pVElan = NULL;
    PNDIS_REQUEST       pNdisRequest = &pMuxNdisRequest->Request;
    NDIS_OID            Oid = pNdisRequest->DATA.SET_INFORMATION.Oid;
    
    //
    // Get the originating VELAN. The VELAN will not be dereferenced
    // away until the pended request is completed.
    //
    pVElan = pMuxNdisRequest->pVElan;

    ASSERT(pVElan != NULL);
    ASSERT(pMuxNdisRequest == &pVElan->Request);
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(MUX_WARN, ("PtCompleteForwardedReq: pVElan %p, OID %x, Status %x\n", 
                    pVElan,
                    pMuxNdisRequest->Request.DATA.QUERY_INFORMATION.Oid,
                    Status));
    }

    //
    // Complete the original request.
    //
    switch (pNdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:

            *pVElan->BytesReadOrWritten = 
                    pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
            *pVElan->BytesNeeded = 
                    pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;

            //
            // Before completing the request, do any necessary
            // post-processing.
            //
            Oid = pNdisRequest->DATA.QUERY_INFORMATION.Oid;
            if (Status == NDIS_STATUS_SUCCESS)
            {
                if (Oid == OID_GEN_LINK_SPEED)
                {
                    pVElan->LinkSpeed = *(PULONG)
                        pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;
                }
                else if (Oid == OID_PNP_CAPABILITIES)
                {
                    PtPostProcessPnPCapabilities(pVElan,
                                                 pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                                                 pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength);
                }
            }

            NdisMQueryInformationComplete(pVElan->MiniportAdapterHandle, Status);

            break;

        case NdisRequestSetInformation:

            *pVElan->BytesReadOrWritten =
                    pNdisRequest->DATA.SET_INFORMATION.BytesRead;
            *pVElan->BytesNeeded =
                    pNdisRequest->DATA.SET_INFORMATION.BytesNeeded;

            //
            // Before completing the request, cache relevant information
            // in our structure.
            //
            if (Status == NDIS_STATUS_SUCCESS)
            {
                Oid = pNdisRequest->DATA.SET_INFORMATION.Oid;
                switch (Oid)
                {
                    case OID_GEN_CURRENT_LOOKAHEAD:
                        pVElan->LookAhead = *(PULONG)
                            pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;
                        break;

                    default:
                        break;
                }
            }

            NdisMSetInformationComplete(pVElan->MiniportAdapterHandle, Status);

            break;

        default:
            ASSERT(FALSE);
            break;
    }

    MUX_DECR_PENDING_SENDS(pVElan);

}



VOID
PtPostProcessPnPCapabilities(
    IN PVELAN                   pVElan,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength
    )
/*++

Routine Description:

    Postprocess a successfully completed query for OID_PNP_CAPABILITIES.
    We modify the returned information slightly before completing
    it to the VELAN above.

Arguments:

    pVElan - Pointer to VELAN
    InformationBuffer - points to buffer for the OID
    InformationBufferLength - byte length of the above.

Return Value:

    None

--*/
{
    PNDIS_PNP_CAPABILITIES          pPNPCapabilities;
    PNDIS_PM_WAKE_UP_CAPABILITIES   pPMstruct;

    if (InformationBufferLength >= sizeof(NDIS_PNP_CAPABILITIES))
    {
        pPNPCapabilities = (PNDIS_PNP_CAPABILITIES)InformationBuffer;

        //
        // The following fields must be overwritten by an IM driver.
        //
        pPMstruct= &pPNPCapabilities->WakeUpCapabilities;
        pPMstruct->MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
        pPMstruct->MinPatternWakeUp = NdisDeviceStateUnspecified;
        pPMstruct->MinLinkChangeWakeUp = NdisDeviceStateUnspecified;
    }
}

VOID
PtCompleteBlockingRequest(
    IN PADAPT                   pAdapt,
    IN PMUX_NDIS_REQUEST        pMuxNdisRequest,
    IN NDIS_STATUS              Status
    )
/*++

Routine Description:

    Handle completion of an NDIS request that was originated
    by this driver and the calling thread is blocked waiting
    for completion.

Arguments:

    pAdapt  - Adapter on which the request was forwarded
    pMuxNdisRequest - super-struct for request
    Status - request completion status

Return Value:

    None

--*/
{
    pMuxNdisRequest->Status = Status;

    //
    // The request was originated from this driver. Wake up the
    // thread blocked for its completion.
    //
    pMuxNdisRequest->Status = Status;
    NdisSetEvent(&pMuxNdisRequest->Event);
}


VOID
PtDiscardCompletedRequest(
    IN PADAPT                   pAdapt,
    IN PMUX_NDIS_REQUEST        pMuxNdisRequest,
    IN NDIS_STATUS              Status
    )
/*++

Routine Description:

    Handle completion of an NDIS request that was originated
    by this driver - the request is to be discarded.

Arguments:

    pAdapt  - Adapter on which the request was forwarded
    pMuxNdisRequest - super-struct for request
    Status - request completion status

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER(pAdapt);
    UNREFERENCED_PARAMETER(Status);

    NdisFreeMemory(pMuxNdisRequest, sizeof(MUX_NDIS_REQUEST), 0);
}


VOID
PtStatus(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 GeneralStatus,
    IN  PVOID                       StatusBuffer,
    IN  UINT                        StatusBufferSize
    )
/*++

Routine Description:

    Handle a status indication on the lower binding (ADAPT).
    If this is a media status indication, we also pass this
    on to all associated VELANs.

Arguments:

    ProtocolBindingContext      Pointer to the adapter structure
    GeneralStatus               Status code
    StatusBuffer                Status buffer
    StatusBufferSize            Size of the status buffer

Return Value:

    None

--*/
{
    PADAPT      pAdapt = (PADAPT)ProtocolBindingContext;
    PLIST_ENTRY p;
    PVELAN      pVElan;
    LOCK_STATE  LockState;

    DBGPRINT(MUX_LOUD, ("PtStatus: Adapt %p, Status %x\n", pAdapt, GeneralStatus));

    do
    {
        //
        // Ignore status indications that we aren't going
        // to pass up.
        //
        if ((GeneralStatus != NDIS_STATUS_MEDIA_CONNECT) &&
            (GeneralStatus != NDIS_STATUS_MEDIA_DISCONNECT))
        {
            break;
        }

        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            BOOLEAN     bIndicateReceive;

            pVElan = CONTAINING_RECORD(p, VELAN, Link);

            MUX_INCR_PENDING_RECEIVES(pVElan);

            //
            // Should the indication be sent on this VELAN?
            //
            if ((pVElan->MiniportHalting) ||
                (pVElan->MiniportAdapterHandle == NULL) ||   
                MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState))
            {
                MUX_DECR_PENDING_RECEIVES(pVElan);
                if (MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState))
                {
                    //
                    // Keep track of the lastest status to indicated when VELAN power is on
                    // 
                    ASSERT((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT));
                    pVElan->LatestUnIndicateStatus = GeneralStatus;
                }
                
                continue;
            }

            //
            // Save the last indicated status when 
            pVElan->LastIndicatedStatus = GeneralStatus;
            
            NdisMIndicateStatus(pVElan->MiniportAdapterHandle,
                                GeneralStatus,
                                StatusBuffer,
                                StatusBufferSize);
            
            //
            // Mark this so that we forward a status complete
            // indication as well.
            //
            pVElan->IndicateStatusComplete = TRUE;

            MUX_DECR_PENDING_RECEIVES(pVElan);
        }

        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);
    }
    while (FALSE);

}


VOID
PtStatusComplete(
    IN    NDIS_HANDLE            ProtocolBindingContext
    )
/*++

Routine Description:

    Marks the end of a status indication. Pass it on to
    associated VELANs if necessary.

Arguments:

    ProtocolBindingContext - pointer to ADAPT

Return Value:

    None.

--*/
{
    PADAPT      pAdapt = (PADAPT)ProtocolBindingContext;
    PLIST_ENTRY p;
    PVELAN      pVElan;
    LOCK_STATE  LockState;

    MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

    for (p = pAdapt->VElanList.Flink;
         p != &pAdapt->VElanList;
         p = p->Flink)
    {
        BOOLEAN     bIndicateReceive;

        pVElan = CONTAINING_RECORD(p, VELAN, Link);

        MUX_INCR_PENDING_RECEIVES(pVElan);

        //
        // Should this indication be sent on this VELAN?
        //
        if ((pVElan->MiniportHalting) ||
            (pVElan->MiniportAdapterHandle == NULL) ||
            (!pVElan->IndicateStatusComplete) ||
            (MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState)))
        {
            MUX_DECR_PENDING_RECEIVES(pVElan);
            continue;
        }

        pVElan->IndicateStatusComplete = FALSE;
        NdisMIndicateStatusComplete(pVElan->MiniportAdapterHandle);
        
        MUX_DECR_PENDING_RECEIVES(pVElan);
    }

    MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

}


VOID
PtSendComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    Called by NDIS when the miniport below had completed a send.
    We complete the corresponding upper-edge send this represents.
    The packet being completed belongs to our send packet pool,
    however we store a pointer to the original packet this represents,
    in the packet's reserved field.

Arguments:

    ProtocolBindingContext - Points to ADAPT structure
    Packet - Packet being completed by the lower miniport
    Status - status of send

Return Value:

    None

--*/
{
    PADAPT              pAdapt = (PADAPT)ProtocolBindingContext;
    PVELAN              pVElan;
    PMUX_SEND_RSVD      pSendReserved;
    PNDIS_PACKET        OriginalPacket;
#if IEEE_VLAN_SUPPORT
    NDIS_PACKET_8021Q_INFO      NdisPacket8021qInfo;
    BOOLEAN                     IsTagInsert;
    PNDIS_BUFFER                pNdisBuffer;
    PVOID                       pVa;
    ULONG                       BufferLength;
#endif
    
    pSendReserved = MUX_RSVD_FROM_SEND_PACKET(Packet);
    OriginalPacket = pSendReserved->pOriginalPacket;
    pVElan = pSendReserved->pVElan;

#if IEEE_VLAN_SUPPORT
    //
    // Check if we had inserted a tag header
    //	    
    IsTagInsert = FALSE;
    NdisPacket8021qInfo.Value = NDIS_PER_PACKET_INFO_FROM_PACKET(    
                                        OriginalPacket,
                                        Ieee8021QInfo);
    if ((pVElan->VlanId != 0) || (NdisPacket8021qInfo.Value != NULL))
    {
        IsTagInsert = TRUE;
    }
#endif
    
    
#ifndef WIN9X
    NdisIMCopySendCompletePerPacketInfo(OriginalPacket, Packet);
#endif

    //
    // Update statistics.
    //
    if (Status == NDIS_STATUS_SUCCESS)
    {
        MUX_INCR_STATISTICS64(&pVElan->GoodTransmits);
    }
    else
    {
        MUX_INCR_STATISTICS(&pVElan->TransmitFailuresOther);
    }

    //
    // Complete the original send.
    //
    NdisMSendComplete(pVElan->MiniportAdapterHandle,
                      OriginalPacket,
                      Status);

#if IEEE_VLAN_SUPPORT
    //
    // If we had inserted a tag header, then remove the header
    // buffer and free it. We would also have created a new
    // NDIS buffer to map part of the original packet's header;
    // free that, too.
    //
    if (IsTagInsert)
    {

        pNdisBuffer = Packet->Private.Head;
#ifdef NDIS51_MINIPORT
        NdisQueryBufferSafe(pNdisBuffer, &pVa, &BufferLength, NormalPagePriority);
#else
        NdisQueryBuffer(pNdisBuffer, &pVa, &BufferLength);
#endif
        if (pVa != NULL)
        {
            NdisFreeToNPagedLookasideList(&pVElan->TagLookaside, pVa);
        }
        NdisFreeBuffer(NDIS_BUFFER_LINKAGE(pNdisBuffer));
        NdisFreeBuffer (pNdisBuffer);
    }
                
#endif

    //
    // Free our packet.
    //
    NdisFreePacket(Packet);

    //
    // Note down send-completion.
    //
    MUX_DECR_PENDING_SENDS(pVElan);
}       


VOID
PtTransferDataComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    )
/*++

Routine Description:

    Entry point called by NDIS to indicate completion of a call by us
    to NdisTransferData. We locate the original packet and VELAN on
    which our TransferData function (see MPTransferData) was called,
    and complete the original request.

Arguments:

    ProtocolBindingContext - lower binding context, pointer to ADAPT
    Packet - Packet allocated by us
    Status - Completion status
    BytesTransferred - Number of bytes copied in

Return Value:

    None

--*/
{
    PADAPT          pAdapt = (PADAPT)ProtocolBindingContext;
    PVELAN          pVElan;
    PNDIS_PACKET    pOriginalPacket;
    PMUX_TD_RSVD    pTDReserved;

    pTDReserved = MUX_RSVD_FROM_TD_PACKET(Packet);
    pOriginalPacket = pTDReserved->pOriginalPacket;
    pVElan = pTDReserved->pVElan;

    //
    // Complete the original TransferData request.
    //
    NdisMTransferDataComplete(pVElan->MiniportAdapterHandle,
                              pOriginalPacket,
                              Status,
                              BytesTransferred);

    //
    // Free our packet.
    //
    NdisFreePacket(Packet);
}


BOOLEAN
PtMulticastMatch(
    IN PVELAN                       pVElan,
    IN PUCHAR                       pDstMac
    )
/*++

Routine Description:

    Check if the given multicast destination MAC address matches
    any of the multicast address entries set on the VELAN.

    NOTE: the caller is assumed to hold a READ/WRITE lock
    to the parent ADAPT structure. This is so that the multicast
    list on the VELAN is invariant for the duration of this call.

Arguments:

    pVElan  - VELAN to look in
    pDstMac - Destination MAC address to compare

Return Value:

    TRUE iff the address matches an entry in the VELAN

--*/
{
    ULONG           i;
    UINT            AddrCompareResult;

    for (i = 0; i < pVElan->McastAddrCount; i++)
    {
        ETH_COMPARE_NETWORK_ADDRESSES_EQ(pVElan->McastAddrs[i],
                                         pDstMac,
                                         &AddrCompareResult);
        
        if (AddrCompareResult == 0)
        {
            break;
        }
    }

    return (i != pVElan->McastAddrCount);
}


BOOLEAN
PtMatchPacketToVElan(
    IN PVELAN                       pVElan,
    IN PUCHAR                       pDstMac,
    IN BOOLEAN                      bIsMulticast,
    IN BOOLEAN                      bIsBroadcast
    )
/*++

Routine Description:

    Check if the destination address of a received packet
    matches the receive criteria on the specified VELAN.

    NOTE: the caller is assumed to hold a READ/WRITE lock
    to the parent ADAPT structure.

Arguments:

    pVElan  - VELAN to check on
    pDstMac - Destination MAC address in received packet
    bIsMulticast - is this a multicast address
    bIsBroadcast - is this a broadcast address

Return Value:

    TRUE iff this packet should be received on the VELAN

--*/
{
    UINT            AddrCompareResult;
    ULONG           PacketFilter;
    BOOLEAN         bPacketMatch;

    PacketFilter = pVElan->PacketFilter;

    //
    // Handle the directed packet case first.
    //
    if (!bIsMulticast)
    {
        //
        // If the VELAN is not in promisc. mode, check if
        // the destination MAC address matches the local
        // address.
        //
        if ((PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS) == 0)
        {
            ETH_COMPARE_NETWORK_ADDRESSES_EQ(pVElan->CurrentAddress,
                                             pDstMac,
                                             &AddrCompareResult);

            bPacketMatch = ((AddrCompareResult == 0) &&
                           ((PacketFilter & NDIS_PACKET_TYPE_DIRECTED) != 0));
        }
        else
        {
            bPacketMatch = TRUE;
        }
     }
     else
     {
        //
        // Multicast or broadcast packet.
        //

        //
        // Indicate if the filter is set to promisc mode ...
        //
        if ((PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS)
                ||

            //
            // or if this is a broadcast packet and the filter
            // is set to receive all broadcast packets...
            //
            (bIsBroadcast &&
             (PacketFilter & NDIS_PACKET_TYPE_BROADCAST))
                ||

            //
            // or if this is a multicast packet, and the filter is
            // either set to receive all multicast packets, or
            // set to receive specific multicast packets. In the
            // latter case, indicate receive only if the destn
            // MAC address is present in the list of multicast
            // addresses set on the VELAN.
            //
            (!bIsBroadcast &&
             ((PacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) ||
              ((PacketFilter & NDIS_PACKET_TYPE_MULTICAST) &&
               PtMulticastMatch(pVElan, pDstMac))))
           )
        {
            bPacketMatch = TRUE;
        }
        else
        {
            //
            // No protocols above are interested in this
            // multicast/broadcast packet.
            //
            bPacketMatch = FALSE;
        }
    }

    return (bPacketMatch);
}


NDIS_STATUS
PtReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookAheadBuffer,
    IN  UINT                    LookAheadBufferSize,
    IN  UINT                    PacketSize
    )
/*++

Routine Description:

    Handle receive data indicated up by the miniport below.

    We forward this up to all VELANs that are eligible to
    receive this packet:

    - If this is directed to a broadcast/multicast address,
      indicate up on all VELANs that have multicast or broadcast
      or promisc. bits set in their packet filters.

    - If this is a directed packet, indicate it up on all VELANs
      that have the a matching MAC address or have the promisc.
      bit set in their packet filters.

    We acquire a read lock on the ADAPT structure to ensure
    that the VELAN list on the adapter is undisturbed.

    If the miniport below indicates packets, NDIS would more
    likely call us at our ReceivePacket handler. However we
    might be called here in certain situations even though
    the miniport below has indicated a receive packet, e.g.
    if the miniport had set packet status to NDIS_STATUS_RESOURCES.
        
Arguments:

    <see DDK ref page for ProtocolReceive>

Return Value:

    NDIS_STATUS_SUCCESS if we processed the receive successfully,
    NDIS_STATUS_XXX error code if we discarded it.

--*/
{
    PADAPT          pAdapt =(PADAPT)ProtocolBindingContext;
    PLIST_ENTRY     p;
    PVELAN          pVElan, pNextVElan;
    PNDIS_PACKET    MyPacket, Packet;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PUCHAR          pData;
    PUCHAR          pDstMac;
    BOOLEAN         bIsMulticast, bIsBroadcast;
    PMUX_RECV_RSVD  pRecvReserved;
    LOCK_STATE      LockState;
#if IEEE_VLAN_SUPPORT
    VLAN_TAG_HEADER UNALIGNED * pTagHeader;
    USHORT UNALIGNED *          pTpid;
    MUX_RCV_CONTEXT             MuxRcvContext;
#endif
    
    do
    {
        if (HeaderBufferSize != ETH_HEADER_SIZE)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        if (pAdapt->PacketFilter == 0)
        {
            //
            // We could get receives in the interval between
            // initiating a request to set the packet filter on
            // the binding to 0 and completion of that request.
            // Drop such packets.
            //
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        //
        // Collect some information from the packet.
        //
        pData = (PUCHAR)HeaderBuffer;
        pDstMac = pData;
        bIsMulticast = ETH_IS_MULTICAST(pDstMac);
        bIsBroadcast = ETH_IS_BROADCAST(pDstMac);

        //
        // Get at the packet, if any, indicated up by the miniport below.
        //
        Packet = NdisGetReceivedPacket(pAdapt->BindingHandle, MacReceiveContext);

        //
        // Lock down the VELAN list on the adapter so that
        // no insertions/deletions to this list happen while
        // we loop through it. The packet filter will also not
        // change during the time we hold the read lock.
        //
        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            BOOLEAN     bIndicateReceive;

            pVElan = CONTAINING_RECORD(p, VELAN, Link);

            //
            // Should the packet be indicated up on this VELAN?
            //
            bIndicateReceive = PtMatchPacketToVElan(pVElan,
                                                    pDstMac,
                                                    bIsMulticast,
                                                    bIsBroadcast);
            if (!bIndicateReceive)
            {
                continue;
            }

            //
            // Make sure we don't Halt the VELAN miniport while
            // we are accessing it here. See MPHalt.
            //
            // Also don't indicate receives if the virtual miniport
            // has been set to a low power state. A specific case
            // is when the system is resuming from "Stand-by", if
            // the lower adapter is restored to D0 before the upper
            // miniports are.
            //
            //
            MUX_INCR_PENDING_RECEIVES(pVElan);

            if ((pVElan->MiniportHalting) ||
                (MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState)))
            {
                MUX_DECR_PENDING_RECEIVES(pVElan);
                continue;
            }


            if (Packet != NULL)
            {
                //
                // The miniport below did indicate up a packet. Use information
                // from that packet to construct a new packet to indicate up.
                //

                //
                // Get a packet off our receive pool and indicate that up.
                //
                NdisDprAllocatePacket(&Status,
                                      &MyPacket,
                                      pVElan->RecvPacketPoolHandle);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    //
                    // Make our packet point to data from the original
                    // packet. NOTE: this works only because we are
                    // indicating a receive directly from the context of
                    // our receive indication. If we need to queue this
                    // packet and indicate it from another thread context,
                    // we will also have to allocate a new buffer and copy
                    // over the packet contents, OOB data and per-packet
                    // information. This is because the packet data
                    // is available only for the duration of this
                    // receive indication call.
                    //
                    MyPacket->Private.Head = Packet->Private.Head;
                    MyPacket->Private.Tail = Packet->Private.Tail;
#if IEEE_VLAN_SUPPORT
                    Status = PtHandleRcvTagging(pVElan, Packet, MyPacket);

                    if (Status != NDIS_STATUS_SUCCESS)
                    {
                        NdisFreePacket(MyPacket);
                        MUX_DECR_PENDING_RECEIVES(pVElan);
                        continue;
                    }
#endif               
                    
                    //
                    // Get the original packet (it could be the same packet
                    // as the one received or a different one based on the
                    // number of layered miniports below) and set it on the
                    // indicated packet so the OOB data is visible correctly
                    // at protocols above.
                    //
                    NDIS_SET_ORIGINAL_PACKET(MyPacket,
                                 NDIS_GET_ORIGINAL_PACKET(Packet));

                    NDIS_SET_PACKET_HEADER_SIZE(MyPacket, HeaderBufferSize);
    
                    //
                    // Copy packet flags.
                    //
                    NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);

                    //
                    // Force protocols above to make a copy if they want to hang
                    // on to data in this packet. This is because we are in our
                    // Receive handler (not ReceivePacket), and the original
                    // packet can't be accessed after we return from here.
                    //
                    NDIS_SET_PACKET_STATUS(MyPacket, NDIS_STATUS_RESOURCES);

                    //
                    // Set our context information in the packet. Since
                    // the original packet from the miniport below is not being
                    // queued up, set this to NULL:
                    //
                    pRecvReserved = MUX_RSVD_FROM_RECV_PACKET(MyPacket);
                    pRecvReserved->pOriginalPacket = NULL;
                    
                    MUX_INCR_STATISTICS64(&pVElan->GoodReceives);
                    
                    //
                    // By setting NDIS_STATUS_RESOURCES, we also know that
                    // we can reclaim this packet as soon as the call to
                    // NdisMIndicateReceivePacket returns.
                    //
                                        
                    NdisMIndicateReceivePacket(pVElan->MiniportAdapterHandle,
                                               &MyPacket,
                                               1);

                    //
                    // Reclaim the indicated packet. Since we had set its status
                    // to NDIS_STATUS_RESOURCES, we are guaranteed that protocols
                    // above are done with it. Our ReturnPacket handler will
                    // not be called for this packet, so call it ourselves.
                    //
                    MPReturnPacket((NDIS_HANDLE)pVElan, MyPacket);

                    //
                    // Done with this VELAN.
                    //
                    continue;
                }

                //
                // else...
                //
                // Failed to allocate a packet to indicate up - fall through.
                // We will still indicate up using the non-packet API, but
                // other per-packet/OOB information won't be available
                // to protocols above.
                //
            }
            else
            {
                //
                // The miniport below us uses the old-style (not packet)
                // receive indication. Fall through.
                //
            }

            //
            // Fall through to here if the miniport below us has
            // either not indicated an NDIS_PACKET or we could not
            // allocate one.
            //

            //
            // Mark the VELAN so that we will forward up a receive
            // complete indication.
            //
            pVElan->IndicateRcvComplete = TRUE;

#if IEEE_VLAN_SUPPORT
            //
            // Get at the EtherType field.
            //
            pTpid = (PUSHORT)((PUCHAR)HeaderBuffer + 2 * ETH_LENGTH_OF_ADDRESS);

            //
            // Check if the EtherType indicates presence of a tag header.
            // 
            if (*pTpid == TPID)
            {
                pTagHeader = (VLAN_TAG_HEADER UNALIGNED *)LookAheadBuffer;
                //
                // Drop this frame if it contains Routing information;
                // we don't support this.
                // 
                if (GET_CANONICAL_FORMAT_ID_FROM_TAG(pTagHeader) != 0)
                {
                    Status = NDIS_STATUS_INVALID_PACKET;
                    MUX_DECR_PENDING_RECEIVES(pVElan);
                    MUX_INCR_STATISTICS(&pVElan->RcvFormatErrors);
                    continue;
                }
                //
                // If there is a VLAN ID in this frame, and we have
                // a configured VLAN ID for this VELAN, check if they
                // are the same - drop if not.
                // 
                if ((GET_VLAN_ID_FROM_TAG(pTagHeader) != 0) &&
                     (pVElan->VlanId != 0) &&
                     (GET_VLAN_ID_FROM_TAG(pTagHeader) != pVElan->VlanId))
                {
                    Status = NDIS_STATUS_NOT_ACCEPTED;
                    MUX_DECR_PENDING_RECEIVES(pVElan);
                    MUX_INCR_STATISTICS(&pVElan->RcvVlanIdErrors);
                    continue;
                }
                //
                // Copy information from the tag header to per-packet
                // info fields.
                //
                MuxRcvContext.NdisPacket8021QInfo.Value = NULL;
                COPY_TAG_INFO_FROM_HEADER_TO_PACKET_INFO(
                    MuxRcvContext.NdisPacket8021QInfo,
                    pTagHeader);
                //
                // Prepare for indicating up this frame (the tag
                // header must be removed). First, copy in the real
                // EtherType value from the tag header.
                // 
                *pTpid = *((PUSHORT)((PUCHAR)LookAheadBuffer + sizeof(pTagHeader->TagInfo)));
                //
                // Account for removing the tag header.
                //
                LookAheadBuffer = (PVOID)((PUCHAR)LookAheadBuffer + VLAN_TAG_HEADER_SIZE); 
                LookAheadBufferSize -= VLAN_TAG_HEADER_SIZE;
                PacketSize -= VLAN_TAG_HEADER_SIZE;
                //
                // Use MuxRcvContext to store context for the receive,
                // to be used in MpTransferData, if called.
                // 
                MuxRcvContext.TagHeaderLen = VLAN_TAG_HEADER_SIZE;
            }
            else
            {
                MuxRcvContext.TagHeaderLen = 0;
            }

            MuxRcvContext.MacRcvContext = MacReceiveContext;

            //
            // In order not to change the code a lot
            // 
            MacReceiveContext = &MuxRcvContext;
#endif            

            MUX_INCR_STATISTICS64(&pVElan->GoodReceives);
            //
            // Indicate receive using the non-packet API.
            //
            NdisMEthIndicateReceive(pVElan->MiniportAdapterHandle,
                                    MacReceiveContext,
                                    HeaderBuffer,
                                    HeaderBufferSize,
                                    LookAheadBuffer,
                                    LookAheadBufferSize,
                                    PacketSize);

            MUX_DECR_PENDING_RECEIVES(pVElan);

        } // for (each VELAN)

        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

        break;

    }
    while(FALSE);

    return Status;
}


VOID
PtReceiveComplete(
    IN    NDIS_HANDLE        ProtocolBindingContext
    )
/*++

Routine Description:

    Called by the adapter below us when it is done indicating a batch of
    received packets. We forward this up on all VELANs that need
    this indication.

Arguments:

    ProtocolBindingContext    Pointer to our adapter structure.

Return Value:

    None

--*/
{
    PADAPT          pAdapt = (PADAPT)ProtocolBindingContext;
    PLIST_ENTRY     p;
    PVELAN          pVElan;
    LOCK_STATE      LockState;

    MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

    for (p = pAdapt->VElanList.Flink;
         p != &pAdapt->VElanList;
         p = p->Flink)
    {
        pVElan = CONTAINING_RECORD(p, VELAN, Link);

        if (pVElan->IndicateRcvComplete)
        {
            pVElan->IndicateRcvComplete = FALSE;
            NdisMEthIndicateReceiveComplete(pVElan->MiniportAdapterHandle);
        }
    }

    MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);
}


INT
PtReceivePacket(
    IN    NDIS_HANDLE               ProtocolBindingContext,
    IN    PNDIS_PACKET              Packet
    )
/*++

Routine Description:

    ReceivePacket handler. Called by NDIS if the miniport below supports
    NDIS 4.0 style receives. Re-package the buffer chain in a new packet
    and indicate the new packet to interested protocols above us.

Arguments:

    ProtocolBindingContext - Pointer to our adapter structure.
    Packet - Pointer to the packet

Return Value:

    == 0 -> We are done with the packet
    != 0 -> We will keep the packet and call NdisReturnPackets() this
            many times when done.
--*/
{
    PADAPT                  pAdapt = (PADAPT)ProtocolBindingContext;
    PVELAN                  pVElan;
    PLIST_ENTRY             p;
    NDIS_STATUS             Status;
    PNDIS_PACKET            MyPacket;
    PUCHAR                  pData;
    PNDIS_BUFFER            pNdisBuffer;
    UINT                    FirstBufferLength;
    UINT                    TotalLength;
    PUCHAR                  pDstMac;
    BOOLEAN                 bIsMulticast, bIsBroadcast;
    PMUX_RECV_RSVD          pRecvReserved;
    ULONG                   ReturnCount;
    LOCK_STATE              LockState;
    
    
    ReturnCount = 0;

    do
    {
        if (pAdapt->PacketFilter == 0)
        {
            //
            // We could get receives in the interval between
            // initiating a request to set the packet filter on
            // the binding to 0 and completion of that request.
            // Drop such packets.
            //
            break;
        }

#ifdef NDIS51
        //
        // Collect some information from the packet.
        //
        NdisGetFirstBufferFromPacketSafe(Packet,
                                         &pNdisBuffer,
                                         &pData,
                                         &FirstBufferLength,
                                         &TotalLength,
                                         NormalPagePriority);
        if (pNdisBuffer == NULL)
        {
            //
            // Out of system resources. Drop this packet.
            //
            break;
        }
#else
        NdisGetFirstBufferFromPacket(Packet,
                                     &pNdisBuffer,
                                     &pData,
                                     &FirstBufferLength,
                                     &TotalLength);
#endif

        pDstMac = pData;
        bIsMulticast = ETH_IS_MULTICAST(pDstMac);
        bIsBroadcast = ETH_IS_BROADCAST(pDstMac);

        //
        // Lock down the VELAN list on the adapter so that
        // no insertions/deletions to this list happen while
        // we loop through it. The packet filter will also not
        // change during the time we hold the read lock.
        //
        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            BOOLEAN     bIndicateReceive;

            pVElan = CONTAINING_RECORD(p, VELAN, Link);

            //
            // Should the packet be indicated up on this VELAN?
            //
            bIndicateReceive = PtMatchPacketToVElan(pVElan,
                                                    pDstMac,
                                                    bIsMulticast,
                                                    bIsBroadcast);
            if (!bIndicateReceive)
            {
                continue;
            }

            //
            // Make sure we don't Halt the VELAN miniport while
            // we are accessing it here. See MPHalt.
            //
            // Also don't indicate receives if the virtual miniport
            // has been set to a low power state. A specific case
            // is when the system is resuming from "Stand-by", if
            // the lower adapter is restored to D0 before the upper
            // miniports are.
            //
            MUX_INCR_PENDING_RECEIVES(pVElan);

            if ((pVElan->MiniportHalting) ||
                (MUX_IS_LOW_POWER_STATE(pVElan->MPDevicePowerState)))
            {
                MUX_DECR_PENDING_RECEIVES(pVElan);
                continue;
            }


            //
            // Get a packet off the pool and indicate that up
            //
            NdisDprAllocatePacket(&Status,
                                  &MyPacket,
                                  pVElan->RecvPacketPoolHandle);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                pRecvReserved = MUX_RSVD_FROM_RECV_PACKET(MyPacket);
                pRecvReserved->pOriginalPacket = Packet;
        
                MyPacket->Private.Head = Packet->Private.Head;
                MyPacket->Private.Tail = Packet->Private.Tail;
        
                //
                // Get the original packet (it could be the same
                // packet as the one received or a different one
                // based on the number of layered miniports below)
                // and set it on the indicated packet so the OOB
                // data is visible correctly to protocols above us.
                //
                NDIS_SET_ORIGINAL_PACKET(MyPacket, NDIS_GET_ORIGINAL_PACKET(Packet));
        
                //
                // Copy Packet Flags
                //
                NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);
        
                Status = NDIS_GET_PACKET_STATUS(Packet);
        
                NDIS_SET_PACKET_STATUS(MyPacket, Status);
                NDIS_SET_PACKET_HEADER_SIZE(MyPacket, NDIS_GET_PACKET_HEADER_SIZE(Packet));

#if IEEE_VLAN_SUPPORT
                Status = PtHandleRcvTagging(pVElan, Packet, MyPacket);

                if (Status != NDIS_STATUS_SUCCESS)
                {
                    NdisFreePacket(MyPacket);
                    MUX_DECR_PENDING_RECEIVES(pVElan);
                    continue;
                }
#endif                
                MUX_INCR_STATISTICS64(&pVElan->GoodReceives);
                
                //
                // Indicate it up.
                //
                ReturnCount++;
                NdisMIndicateReceivePacket(pVElan->MiniportAdapterHandle,
                                           &MyPacket,
                                           1);
        
                //
                // Check if we had indicated up the packet with
                // status set to NDIS_STATUS_RESOURCES.
                //
                // NOTE -- do not use NDIS_GET_PACKET_STATUS(MyPacket)
                // for this since it might have changed! Use the value
                // saved in the local variable.
                //
                if (Status == NDIS_STATUS_RESOURCES)
                {
                    //
                    // Our ReturnPackets handler will not be called
                    // for this packet. We should reclaim it right here.
                    //
        
                    MPReturnPacket((NDIS_HANDLE)pVElan, MyPacket);
                }
            }
            else
            {
                //
                // Failed to allocate a packet.
                //
                MUX_INCR_STATISTICS(&pVElan->RcvResourceErrors);
                MUX_DECR_PENDING_RECEIVES(pVElan);
            }

        } // for (loop thru all VELANs)

        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

        break;
    }
    while (FALSE);

    //
    // Return the # of receive indications made for this packet.
    // We will call NdisReturnPackets for this packet as many
    // times (see MPReturnPackets).
    //
    return (ReturnCount);

}



NDIS_STATUS
PtPnPNetEventSetPower(
    IN PADAPT                   pAdapt,
    IN PNET_PNP_EVENT           pNetPnPEvent
    )
/*++
Routine Description:

    This is a notification to our protocol edge of the power state
    of the lower miniport. If it is going to a low-power state, we must
    wait here for all outstanding sends and requests to complete.

Arguments:

    pAdapt - Pointer to the adpater structure
    pNetPnPEvent - The Net Pnp Event. this contains the new device state

Return Value:

    NDIS_STATUS_SUCCESS

--*/
{
    PLIST_ENTRY                 p;
    PVELAN                      pVElan;
    LOCK_STATE                  LockState;
    NDIS_STATUS                 Status;

    //
    // Store the new power state.
    //
    pAdapt->PtDevicePowerState = *(PNDIS_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;

    DBGPRINT(MUX_LOUD, ("PnPNetEventSetPower: Adapt %p, SetPower to %d\n",
            pAdapt, pAdapt->PtDevicePowerState));

    //
    // Check if the miniport below is going to a low power state.
    //
    if (MUX_IS_LOW_POWER_STATE(pAdapt->PtDevicePowerState))
    {
        ULONG       i;

        //
        // It is going to a low power state. Wait for outstanding
        // I/O to complete on the adapter.
        //
        for (i = 0; i < 10000; i++)
        {
            MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

            for (p = pAdapt->VElanList.Flink;
                 p != &pAdapt->VElanList;
                 p = p->Flink)
            {
                pVElan = CONTAINING_RECORD(p, VELAN, Link);
                if ((pVElan->OutstandingSends != 0) ||
                    (pVElan->OutstandingReceives != 0))
                {
                    break;
                }
            }

            MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

            if (p == &pAdapt->VElanList)
            {
                //
                // There are no VELANs with pending I/O.
                //
                break;
            }
            
            DBGPRINT(MUX_INFO, ("SetPower: Adapt %p, waiting for pending IO to complete\n",
                                pAdapt));

            NdisMSleep(1000);
        }

    }
    else
    {
        //
        // The device below is powered on. If we had requests
        // pending on any VELANs, send them down now.
        //
        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

        for (p = pAdapt->VElanList.Flink;
             p != &pAdapt->VElanList;
             p = p->Flink)
        {
            pVElan = CONTAINING_RECORD(p, VELAN, Link);

            if (pVElan->QueuedRequest)
            {
                pVElan->QueuedRequest = FALSE;

                NdisRequest(&Status,
                            pAdapt->BindingHandle,
                            &pVElan->Request.Request);
                
                if (Status != NDIS_STATUS_PENDING)
                {
                    PtRequestComplete(pAdapt,
                                      &pVElan->Request.Request,
                                      Status);
                }
            }
        }

        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);
    }

    return (NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
PtPNPHandler(
    IN NDIS_HANDLE              ProtocolBindingContext,
    IN PNET_PNP_EVENT           pNetPnPEvent
    )

/*++
Routine Description:

    This is called by NDIS to notify us of a PNP event related to a lower
    binding. Based on the event, this dispatches to other helper routines.

Arguments:

    ProtocolBindingContext - Pointer to our adapter structure. Can be NULL
                for "global" notifications

    pNetPnPEvent - Pointer to the PNP event to be processed.

Return Value:

    NDIS_STATUS code indicating status of event processing.

--*/
{
    PADAPT              pAdapt  =(PADAPT)ProtocolBindingContext;
    NDIS_STATUS         Status  = NDIS_STATUS_SUCCESS;
    PNOTIFY_CUSTOM_EVENT event = NULL;
    PVELAN              pVElan = NULL;
    NDIS_STRING         deviceName;
    PLIST_ENTRY         p;

    DBGPRINT(MUX_LOUD, ("PtPnPHandler: Adapt %p, NetPnPEvent %d\n", pAdapt, 
                            pNetPnPEvent->NetEvent));

    switch (pNetPnPEvent->NetEvent)
    {
        case NetEventSetPower:

            Status = PtPnPNetEventSetPower(pAdapt, pNetPnPEvent);
            break;

        case NetEventReconfigure:
            //
            // Rescan configuration and bring up any VELANs that
            // have been newly added. Make sure that the global
            // adapter list is undisturbed while we traverse it.
            //
            MUX_ACQUIRE_MUTEX(&GlobalMutex);

            for (p = AdapterList.Flink;
                 p != &AdapterList;
                 p = p->Flink)
            {
                pAdapt = CONTAINING_RECORD(p, ADAPT, Link);

                PtBootStrapVElans(pAdapt);
            }

            MUX_RELEASE_MUTEX(&GlobalMutex);
                
            Status = NDIS_STATUS_SUCCESS;
            break;

        default:
            Status = NDIS_STATUS_SUCCESS;

            break;
    }

    return Status;
}

NDIS_STATUS
PtCreateAndStartVElan(
    IN  PADAPT                      pAdapt,
    IN  PNDIS_STRING                pVElanKey
)
/*++

Routine Description:

    Create and start a VELAN with the given key name. Check if a VELAN
    with this key name already exists; if so do nothing.

    ASSUMPTION: this is called from either the BindAdapter handler for
    the underlying adapter, or from the PNP reconfig handler. Both these
    routines are protected by NDIS against pre-emption by UnbindAdapter.
    If this routine will be called from any other context, it should
    be protected against a simultaneous call to our UnbindAdapter handler.
    
Arguments:

    pAdapt        - Pointer to Adapter structure
    pVElanKey     - Points to a Unicode string naming the VELAN to create. 
    
Return Value:

    NDIS_STATUS_SUCCESS if we either found a duplicate VELAN or
    successfully initiated a new ELAN with the given key.

    NDIS_STATUS_XXX error code otherwise (failure initiating a new VELAN).

--*/
{
    NDIS_STATUS             Status;
    PVELAN                  pVElan;
    
    Status = NDIS_STATUS_SUCCESS;
    pVElan = NULL;

    DBGPRINT(MUX_LOUD, ("=> Create VElan: Adapter %p, ElanKey %ws\n", 
                            pAdapt, pVElanKey->Buffer));

    do
    {
        //
        //  Weed out duplicates.
        //
        if (pVElanKey != NULL)
        {

            pVElan = PtFindVElan(pAdapt, pVElanKey);

            if (NULL != pVElan)
            {
                //
                // Duplicate - bail out silently.
                //
                DBGPRINT(MUX_WARN, ("CreateElan: found duplicate pVElan %x\n", pVElan));

                Status = NDIS_STATUS_SUCCESS;
                pVElan = NULL;
                break;
            }
        }

        pVElan = PtAllocateAndInitializeVElan(pAdapt, pVElanKey);
        if (pVElan == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        //
        // Request NDIS to initialize the virtual miniport. Set
        // the flag below just in case an unbind occurs before
        // MiniportInitialize is called.
        //
        pVElan->MiniportInitPending = TRUE;
        NdisInitializeEvent(&pVElan->MiniportInitEvent);

        Status = NdisIMInitializeDeviceInstanceEx(DriverHandle,
                                                  &pVElan->CfgDeviceName,
                                                  pVElan);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            PtUnlinkVElanFromAdapter(pVElan);   // IMInit failed
            pVElan = NULL;
            break;
        }
    
    }
    while (FALSE);

    DBGPRINT(MUX_INFO, ("<= Create VElan: Adapter %p, VELAN %p\n", pAdapt, pVElan));

    return Status;
}


PVELAN
PtAllocateAndInitializeVElan(
    IN PADAPT                       pAdapt,
    IN PNDIS_STRING                 pVElanKey
    )
/*++

Routine Description:

    Allocates and initializes a VELAN structure. Also links it to
    the specified ADAPT.

Arguments:

    pAdapt - Adapter to link VELAN to
    pVElanKey - Key to the VELAN

Return Value:

    Pointer to VELAN structure if successful, NULL otherwise.

--*/
{
    PVELAN          pVElan;
    ULONG           Length;
    NDIS_STATUS     Status;
    LOCK_STATE      LockState;

    pVElan = NULL;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        Length = sizeof(VELAN) + pVElanKey->Length + sizeof(WCHAR);
        
        //
        // Allocate a VELAN data structure.
        //
        NdisAllocateMemoryWithTag(&pVElan, Length, TAG);
        if (pVElan == NULL)
        {
            DBGPRINT(MUX_FATAL, ("AllocateVElan: Failed to allocate %d bytes for VELAN\n",
                                 Length));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Initialize it.
        //
        NdisZeroMemory(pVElan, Length);
        NdisInitializeListHead(&pVElan->Link);
        
        //
        // Initialize the built-in request structure to signify
        // that it is used to forward NDIS requests.
        //
        pVElan->Request.pVElan = pVElan;
        NdisInitializeEvent(&pVElan->Request.Event);
       
        //
        // Store in the key name.
        //
        pVElan->CfgDeviceName.Length = 0;
        pVElan->CfgDeviceName.Buffer = (PWCHAR)((PUCHAR)pVElan + 
                    sizeof(VELAN));       
        pVElan->CfgDeviceName.MaximumLength = 
                pVElanKey->MaximumLength + sizeof(WCHAR);
        (VOID)NdisUpcaseUnicodeString(&pVElan->CfgDeviceName, pVElanKey);
        pVElan->CfgDeviceName.Buffer[pVElanKey->Length/sizeof(WCHAR)] =
                        ((WCHAR)0);

        // 
        // Initialize LastIndicatedStatus to media connect
        //
        pVElan->LastIndicatedStatus = NDIS_STATUS_MEDIA_CONNECT;

        //
        // Set power state of virtual miniport to D0.
        //
        pVElan->MPDevicePowerState = NdisDeviceStateD0;

        //
        // Cache the binding handle for quick reference.
        //
        pVElan->BindingHandle = pAdapt->BindingHandle;
        pVElan->pAdapt = pAdapt;

        //
        // Copy in some adapter parameters.
        //
        pVElan->LookAhead = pAdapt->MaxLookAhead;
        pVElan->LinkSpeed = pAdapt->LinkSpeed;
        NdisMoveMemory(pVElan->PermanentAddress,
                       pAdapt->CurrentAddress,
                       sizeof(pVElan->PermanentAddress));

        NdisMoveMemory(pVElan->CurrentAddress,
                       pAdapt->CurrentAddress,
                       sizeof(pVElan->CurrentAddress));

        DBGPRINT(MUX_LOUD, ("Alloced VELAN %p, MAC addr %s\n",
                    pVElan, MacAddrToString(pVElan->CurrentAddress)));
#if IEEE_VLAN_SUPPORT
        //
        // Allocate lookaside list for tag headers.
        // 
        NdisInitializeNPagedLookasideList (
                &pVElan->TagLookaside,
                NULL,
                NULL,
                0,
                ETH_HEADER_SIZE + VLAN_TAG_HEADER_SIZE,
                'TxuM',
                0);
        
#endif
        //
        // Allocate a packet pool for sends.
        //
        NdisAllocatePacketPoolEx(&Status,
                                 &pVElan->SendPacketPoolHandle,
                                 MIN_PACKET_POOL_SIZE,
                                 MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                 sizeof(MUX_SEND_RSVD));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MUX_FATAL, ("PtAllocateVElan: failed to allocate send packet pool\n"));
            break;
        }

        //
        // NOTE: this sample driver does not -originate- packets in the
        // send or receive directions. If the driver must originate packets,
        // here is a good place to allocate NDIS buffer pool(s) for
        // this purpose.
        //
#if IEEE_VLAN_SUPPORT
        //
        // Allocate a buffer pool for tag headers.
        //
        NdisAllocateBufferPool (&Status,
                                &pVElan->BufferPoolHandle,
                                MIN_PACKET_POOL_SIZE);

        ASSERT(Status == NDIS_STATUS_SUCCESS);
        
#endif
        
        //
        // Allocate a packet pool for receives.
        //
        NdisAllocatePacketPoolEx(&Status,
                                 &pVElan->RecvPacketPoolHandle,
                                 MIN_PACKET_POOL_SIZE,
                                 MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                 PROTOCOL_RESERVED_SIZE_IN_PACKET);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MUX_FATAL, ("PtAllocateVElan: failed to allocate receive packet pool\n"));
            break;
        }

        //
        // Finally link this VELAN to the Adapter's VELAN list. 
        //
        PtReferenceVElan(pVElan, "adapter");        

        MUX_ACQUIRE_ADAPT_WRITE_LOCK(pAdapt, &LockState);

        PtReferenceAdapter(pAdapt, "VElan");
        InsertTailList(&pAdapt->VElanList, &pVElan->Link);
        pAdapt->VElanCount++;
        pVElan->VElanNumber = NdisInterlockedIncrement(&NextVElanNumber);

        MUX_RELEASE_ADAPT_WRITE_LOCK(pAdapt, &LockState);
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        if (pVElan)
        {
            PtDeallocateVElan(pVElan);
            pVElan = NULL;
        }
    }

    return (pVElan);
}


VOID
PtDeallocateVElan(
    IN PVELAN                   pVElan
    )
/*++

Routine Description:

    Free up all resources allocated to a VELAN, and then the VELAN
    structure itself.

Arguments:

    pVElan - Pointer to VELAN to be deallocated.

Return Value:

    None

--*/
{
    
    if (pVElan->SendPacketPoolHandle != NULL)
    {
        NdisFreePacketPool(pVElan->SendPacketPoolHandle);
    }

    if (pVElan->RecvPacketPoolHandle != NULL)
    {
        NdisFreePacketPool(pVElan->RecvPacketPoolHandle);
    }
#if IEEE_VLAN_SUPPORT 
    NdisFreeBufferPool(pVElan->BufferPoolHandle);
    NdisDeleteNPagedLookasideList(&pVElan->TagLookaside);
#endif    
    NdisFreeMemory(pVElan, 0, 0);
}


VOID
PtStopVElan(
    IN  PVELAN            pVElan
)
/*++

Routine Description:

    Stop a VELAN by requesting NDIS to halt the virtual miniport.
    The caller has a reference on the VELAN, so it won't go away
    while we are executing in this routine.

    ASSUMPTION: this is only called in the context of unbinding
    from the underlying miniport. If it may be called from elsewhere,
    this should protect itself from re-entrancy.
    
Arguments:

    pVElan      - Pointer to VELAN to be stopped.
    
Return Value:

    None

--*/
{
    NDIS_STATUS             Status;
    NDIS_HANDLE             MiniportAdapterHandle;
    BOOLEAN                 bMiniportInitCancelled = FALSE;

    DBGPRINT(MUX_LOUD, ("=> StopVElan: VELAN %p, Adapt %p\n", pVElan, pVElan->pAdapt));

    //
    // We make blocking calls below.
    //
    ASSERT_AT_PASSIVE();

    //
    // If there was a queued request on this VELAN, fail it now.
    //
    if (pVElan->QueuedRequest)
    {
        pVElan->QueuedRequest = FALSE;

        PtRequestComplete(pVElan->pAdapt,
                          &pVElan->Request.Request,
                          NDIS_STATUS_FAILURE);
    }

    //
    // Check if we had called NdisIMInitializeDeviceInstanceEx and
    // we are awaiting a call to MiniportInitialize.
    //
    if (pVElan->MiniportInitPending)
    {
        //
        // Attempt to cancel miniport init.
        //
        Status = NdisIMCancelInitializeDeviceInstance(
                    DriverHandle,
                    &pVElan->CfgDeviceName);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            //
            // Successfully cancelled IM initialization; our
            // Miniport Init routine will not be called for this
            // VELAN miniport.
            //
            pVElan->MiniportInitPending = FALSE;
            ASSERT(pVElan->MiniportAdapterHandle == NULL);
            bMiniportInitCancelled = TRUE;
        }
        else
        {
            //
            // Our Miniport Initialize routine will be called
            // (may be running on another thread at this time).
            // Wait for it to finish.
            //
            NdisWaitEvent(&pVElan->MiniportInitEvent, 0);
            ASSERT(pVElan->MiniportInitPending == FALSE);
        }
    }

    //
    // Check if Miniport Init has run. If so, deinitialize the virtual
    // miniport. This will result in a call to our Miniport Halt routine,
    // where the VELAN will be cleaned up.
    //
    MiniportAdapterHandle = pVElan->MiniportAdapterHandle;

    if ((NULL != MiniportAdapterHandle) &&
        (!pVElan->MiniportHalting))
    {
        //
        // The miniport was initialized, and has not yet halted.
        //
        ASSERT(bMiniportInitCancelled == FALSE);
        (VOID)NdisIMDeInitializeDeviceInstance(MiniportAdapterHandle);
    }
    else
    {
        if (bMiniportInitCancelled)
        {
            //
            // No NDIS events can come to this VELAN since it
            // was never initialized as a miniport. We need to unlink
            // it explicitly here.
            //
            PtUnlinkVElanFromAdapter(pVElan);
        }
    }
}


VOID
PtUnlinkVElanFromAdapter(
    IN PVELAN               pVElan
)
/*++

Routine Description:

    Utility routine to unlink a VELAN from its parent ADAPT structure.
    
Arguments:

    pVElan      - Pointer to VELAN to be unlinked.
    
Return Value:

    None

--*/
{
    PADAPT pAdapt = pVElan->pAdapt;    
    LOCK_STATE      LockState;
    
    ASSERT(pAdapt != NULL);

    //
    // Remove this VELAN from the Adapter list
    //
    MUX_ACQUIRE_ADAPT_WRITE_LOCK(pAdapt, &LockState);

    RemoveEntryList(&pVElan->Link);
    pAdapt->VElanCount--;
        
    MUX_RELEASE_ADAPT_WRITE_LOCK(pAdapt, &LockState);
    pVElan->pAdapt = NULL;
    PtDereferenceVElan(pVElan, "adapter");

    PtDereferenceAdapter(pAdapt, "VElan");
}


PVELAN
PtFindVElan(
    IN    PADAPT                pAdapt,
    IN    PNDIS_STRING          pVElanKey
)
/*++

Routine Description:

    Find an ELAN by bind name/key

Arguments:

    pAdapt     -    Pointer to an adapter struct.
    pVElanKey  -    The VELAN's device name

Return Value:

    Pointer to matching VELAN or NULL if not found.
    
--*/
{
    PLIST_ENTRY         p;
    PVELAN              pVElan;
    BOOLEAN             Found;
    NDIS_STRING         VElanKeyName;
    LOCK_STATE          LockState;

    ASSERT_AT_PASSIVE();

    DBGPRINT(MUX_LOUD, ("FindElan: Adapter %p, ElanKey %ws\n", pAdapt, 
                                        pVElanKey->Buffer));

    pVElan = NULL;
    Found = FALSE;
    VElanKeyName.Buffer = NULL;

    do
    {
        //
        // Make an up-cased copy of the given string.
        //
        NdisAllocateMemoryWithTag(&VElanKeyName.Buffer, 
                                pVElanKey->MaximumLength, TAG);
        if (VElanKeyName.Buffer == NULL)
        {
            break;
        }

        VElanKeyName.Length = pVElanKey->Length;
        VElanKeyName.MaximumLength = pVElanKey->MaximumLength;

        (VOID)NdisUpcaseUnicodeString(&VElanKeyName, pVElanKey);

        //
        // Go through all VELANs on the ADAPT structure, looking
        // for a VELAN that has a matching device name.
        //
        MUX_ACQUIRE_ADAPT_READ_LOCK(pAdapt, &LockState);

        p = pAdapt->VElanList.Flink;
        while (p != &pAdapt->VElanList)
        {
            pVElan = CONTAINING_RECORD(p, VELAN, Link);

            if ((VElanKeyName.Length == pVElan->CfgDeviceName.Length) &&
                (memcmp(VElanKeyName.Buffer, pVElan->CfgDeviceName.Buffer, 
                VElanKeyName.Length) == 0))
            {
                Found = TRUE;
                break;
            }
        
            p = p->Flink;
        }

        MUX_RELEASE_ADAPT_READ_LOCK(pAdapt, &LockState);

    }
    while (FALSE);

    if (!Found)
    {
        DBGPRINT(MUX_INFO, ( "FindElan: No match found!\n"));
        pVElan = NULL;
    }

    if (VElanKeyName.Buffer)
    {
        NdisFreeMemory(VElanKeyName.Buffer, VElanKeyName.Length, 0);
    }

    return pVElan;
}


VOID
PtBootStrapVElans(
    IN  PADAPT            pAdapt
)
/*++

Routine Description:

    Start up the VELANs configured for an adapter.

Arguments:

    pAdapt    - Pointer to ATMLANE Adapter structure

Return Value:

    None

--*/
{
    NDIS_STATUS                     Status;
    NDIS_HANDLE                     AdapterConfigHandle;
    PVELAN                          pVElan;
    PNDIS_CONFIGURATION_PARAMETER   Param;
    NDIS_STRING                     DeviceStr = NDIS_STRING_CONST("UpperBindings");
    PWSTR                           buffer;

    //
    //  Initialize.
    //
    Status = NDIS_STATUS_SUCCESS;
    AdapterConfigHandle = NULL;
    
    do
    {
        DBGPRINT(MUX_LOUD, ("BootStrapElans: Starting ELANs on adapter %x\n", pAdapt));

        //
        //  Open the protocol configuration section for this adapter.
        //

        NdisOpenProtocolConfiguration(&Status,
                                       &AdapterConfigHandle,
                                       &pAdapt->ConfigString);

        if (NDIS_STATUS_SUCCESS != Status)
        {
            AdapterConfigHandle = NULL;
            DBGPRINT(MUX_ERROR, ("BootStrapElans: OpenProtocolConfiguration failed\n"));
            Status = NDIS_STATUS_OPEN_FAILED;
            break;
        }
        
        //
        // Read the "UpperBindings" reserved key that contains a list
        // of device names representing our miniport instances corresponding
        // to this lower binding. The UpperBindings is a 
        // MULTI_SZ containing a list of device names. We will loop through
        // this list and initialize the virtual miniports.
        //
        NdisReadConfiguration(&Status,
                              &Param,
                                AdapterConfigHandle,
                                &DeviceStr,
                                NdisParameterMultiString);
        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT(MUX_ERROR, ("BootStrapElans: NdisReadConfiguration failed\n"));
              break;
        }

        //
        // Parse the Multi_sz string to extract the device name of each VELAN.
        // This is used as the key name for the VELAN.
        //
        buffer = (PWSTR)Param->ParameterData.StringData.Buffer;
        while(*buffer != L'\0')
        {
            NDIS_STRING     DeviceName;
            
            NdisInitUnicodeString(&DeviceName, buffer);
           

            Status = PtCreateAndStartVElan(pAdapt, &DeviceName); 
            if (NDIS_STATUS_SUCCESS != Status)
            {
                DBGPRINT(MUX_ERROR, ("BootStrapElans: CreateVElan failed\n"));
                break;
            }
            buffer = (PWSTR)((PUCHAR)buffer + DeviceName.Length + sizeof(WCHAR));
        };
          
    } while (FALSE);

    //
    //    Close config handles
    //        
    if (NULL != AdapterConfigHandle)
    {
        NdisCloseConfiguration(AdapterConfigHandle);
    }
    return;
}

VOID
PtReferenceVElan(
    IN    PVELAN            pVElan,
    IN    PUCHAR            String
    )
/*++

Routine Description:

    Add a references to an Elan structure.

Arguments:

    pElan    -    Pointer to the Elan structure.


Return Value:

    None.

--*/
{
    
    NdisInterlockedIncrement(&pVElan->RefCount);
    
    DBGPRINT(MUX_LOUD, ("ReferenceElan: Elan %p (%s) new count %d\n",
             pVElan, String, pVElan->RefCount));

    return;
}

ULONG
PtDereferenceVElan(
    IN    PVELAN            pVElan,
    IN    PUCHAR            String
    )
/*++

Routine Description:

    Subtract a reference from an VElan structure. 
    If the reference count becomes zero, deallocate it.

Arguments:

    pElan    -    Pointer to an VElan structure.


Return Value:

    None.

--*/
{
    ULONG        rc;

    ASSERT(pVElan->RefCount > 0);

    rc = NdisInterlockedDecrement(&pVElan->RefCount);

    if (rc == 0)
    {
        //
        // Free memory if there is no outstanding reference.
        // Note: Length field is not required if the memory 
        // is allocated with NdisAllocateMemoryWithTag.
        //
        PtDeallocateVElan(pVElan);
    }
    
    DBGPRINT(MUX_LOUD, ("DereferenceElan: VElan %p (%s) new count %d\n", 
                                    pVElan, String, rc));
    return (rc);
}


BOOLEAN
PtReferenceAdapter(
    IN    PADAPT            pAdapt,
    IN    PUCHAR            String
    )
/*++

Routine Description:

    Add a references to an Adapter structure.

Arguments:

    pAdapt    -    Pointer to the Adapter structure.

Return Value:

    None.

--*/
{
    NdisInterlockedIncrement(&pAdapt->RefCount);
    
    DBGPRINT(MUX_LOUD, ("ReferenceAdapter: Adapter %x (%s) new count %d\n",
                    pAdapt, String, pAdapt->RefCount));

    return TRUE;
}

ULONG
PtDereferenceAdapter(
    IN    PADAPT    pAdapt,
    IN    PUCHAR    String
    )
/*++

Routine Description:

    Subtract a reference from an Adapter structure. 
    If the reference count becomes zero, deallocate it.

Arguments:

    pAdapt    -    Pointer to an adapter structure.


Return Value:

    None.

--*/
{
    ULONG        rc;

    ASSERT(pAdapt->RefCount > 0);


    rc = NdisInterlockedDecrement (&pAdapt->RefCount);

    if (rc == 0)
    {
        //
        // Fr