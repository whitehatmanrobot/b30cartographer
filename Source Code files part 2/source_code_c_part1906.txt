>MaxAttachedBuffers;
    tdIndex = startingTD;
    do
    {
        endpoint->TransferDescriptors[tdIndex].IsochTransferDescriptor.StartingFrame = startingFrame;
        startingFrame += endpoint->TransferDescriptors[tdIndex].IsochTransferDescriptor.FrameCount+1;        
        tdIndex = (tdIndex+1)%endpoint->MaxAttachedBuffers;
    }while(tdIndex != endpoint->NextFreeTD);

    endpoint->NextUnusedFrame = startingFrame;

    //
    //  Clear the skip bit.
    //
    endpoint->HcEndpointDescriptor.Control.Skip = 0;

    //
    //  Set the OHCD_ISOCH_EDFL_TRANSFERING flag
    //
    endpoint->Flags |= OHCD_ISOCH_EDFL_TRANSFERING;

ExitIsochStartTransfer:
    KeLowerIrql(oldIrql);
    Urb->Header.Status = status;
    USBD_CompleteRequest((PURB)Urb);
    return status;

}

USBD_STATUS
FASTCALL
OHCD_fIsochStopTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
/*++
    Routine Description:
        This routine is the handler for URB_ISOCH_STOP_TRANSFER
        1) Set the Skip Bit.
        2) Record the current frame number.
    Parameters:
        DeviceExtension - host controller context
        Urb             - urb to handle
    Return Value:
    USBD_STATUS_SUCCESS or 
    USBD_STATUS_ISOCH_NOT_STARTED if the device has not been started.

--*/
{
    KIRQL oldIrql;
    POHCD_ISOCH_ENDPOINT endpoint = (POHCD_ISOCH_ENDPOINT)Urb->IsochStartTransfer.EndpointHandle;
    USBD_STATUS  status = USBD_STATUS_SUCCESS;

    ASSERT(USB_ENDPOINT_TYPE_ISOCHRONOUS == endpoint->EndpointType);
    
    oldIrql = KeRaiseIrqlToDpcLevel();
    //
    //  If the transfer is started, stop it.
    //
    if(endpoint->Flags&OHCD_ISOCH_EDFL_TRANSFERING)
    {
        //
        //  Set the skip bit.
        //
        endpoint->HcEndpointDescriptor.Control.Skip = TRUE;
        //
        //  Set the frame that we need to wait for.
        //
        endpoint->PauseFrame = OHCD_Get32BitFrameNumber(DeviceExtension)+2;
        //
        //   Change the flags.
        //
        endpoint->Flags &= ~OHCD_ISOCH_EDFL_TRANSFERING;
        endpoint->Flags |= OHCD_ISOCH_EDFL_STOPPING;
    } else
    {
        status = USBD_STATUS_ISOCH_NOT_STARTED;
    }
    KeLowerIrql(oldIrql);
    Urb->Header.Status = status;
    USBD_CompleteRequest((PURB)Urb);
    return status;
}

VOID
FASTCALL
OHCD_fIsochProcessTD(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_TRANSFER_DESCRIPTOR TransferDescriptor
    )
/*++
    Routine Description:
        This routine is called every time a transfer descriptor is retired.
        1) copy the status and notify the class driver.
        2) Relink the TD on to the end of the queue.
        3) if circular mode, recopy the offsets and set the starting frame
        4) if circular or needs dummy, move the tail pointer.
        5) if not circular mode, "free" the attached buffer (decrease attached buffer count).
    Parameters:
        DeviceExtension - host controller context
        TransferDescriptor - needs to be cast to an isoch transfer descriptor.
--*/
{
    POHCD_ISOCH_TRANSFER_DESCRIPTOR transferDescriptor = (POHCD_ISOCH_TRANSFER_DESCRIPTOR)TransferDescriptor;
    ULONG tdPhysical;
    POHCD_ISOCH_ENDPOINT endpoint = transferDescriptor->Endpoint;
    UCHAR tdIndexPrev = transferDescriptor->TdIndexPrev;
    PFNUSBD_ISOCH_TRANSFER_COMPLETE       transferComplete;
    PVOID                                 callbackContext;
    USBD_ISOCH_TRANSFER_STATUS            transferStatus;
    BOOLEAN  moveTail;
    
    //
    //  Copy the info we need for the callback, including the status, the callback itself, and the context
    //
    transferStatus.Status = (USBD_STATUS) transferDescriptor->IsochTransferDescriptor.ConditionCode;
    transferStatus.FrameCount = transferDescriptor->IsochTransferDescriptor.FrameCount + 1;
    RtlCopyMemory((PVOID)transferStatus.PacketStatus, (PVOID)transferDescriptor->IsochTransferDescriptor.Offset_PSW, sizeof(USHORT)*8);
    callbackContext = transferDescriptor->Context;
    transferComplete = transferDescriptor->TransferComplete;
    //
    //  Relink the transfer descriptor at the end of the endpoints queue.
    //
    transferDescriptor->IsochTransferDescriptor.NextTD = 0;
    tdPhysical = OHCD_PoolGetPhysicalAddress((PVOID)transferDescriptor);
    endpoint->TransferDescriptors[tdIndexPrev].IsochTransferDescriptor.NextTD = tdPhysical;
    
    //
    //  If we are in circular DMA mode, update the starting frame
    //  and recopy the offset information, and move nextFree
    //
    if(endpoint->Flags&OHCD_ISOCH_EDFL_CIRCULAR_DMA)
    {
        ULONG startingFrame = OHCD_Get32BitFrameNumber(DeviceExtension)+1;
        LONG FrameDiff = (LONG)endpoint->NextUnusedFrame - (LONG)startingFrame;
        if(FrameDiff >= 0)
        {
            startingFrame = endpoint->NextUnusedFrame;
        }
        transferDescriptor->IsochTransferDescriptor.StartingFrame = startingFrame;
        endpoint->NextUnusedFrame = startingFrame + transferDescriptor->IsochTransferDescriptor.FrameCount+1;
        RtlCopyMemory((PVOID)transferDescriptor->IsochTransferDescriptor.Offset_PSW, (PVOID)&transferDescriptor->Offsets, sizeof(USHORT)*8);
        //
        //  NextFreeTD is moved so that if we get a stop request it can restart on the
        //  next TD.  This may or may not be desirable.
        //
        endpoint->NextFreeTD = (endpoint->NextFreeTD+1)%endpoint->MaxAttachedBuffers;
        //
        //  Always move the tail pointer for circular mode.
        //
        moveTail = TRUE;
    } else
    {
        //
        //  Unlock the page(s)
        //
        //
        MmLockUnlockPhysicalPage(transferDescriptor->IsochTransferDescriptor.BufferPage0, TRUE);
        if((transferDescriptor->IsochTransferDescriptor.BufferPage0 ^ transferDescriptor->IsochTransferDescriptor.BufferEnd) & ~(PAGE_SIZE-1))
        {
            MmLockUnlockPhysicalPage(transferDescriptor->IsochTransferDescriptor.BufferEnd, TRUE);
        }
        //
        //  The number of attached buffers (prior to this one completing) is at the
        //  maximum, then the attach routine would not have been able to move the
        //  tail pointer to point to a dummy, so set moveTail.
        //
        moveTail = (endpoint->AttachedBuffers == endpoint->MaxAttachedBuffers) ? TRUE : FALSE;
        
        //
        //  Mark that the buffer is now unattached.  (i.e. the TD can be reused.
        //
        endpoint->AttachedBuffers--;
    }
    //
    //  If moveTail is TRUE, either because we are in circular, or because we need to
    //  add a dummy TD, then do it now.
    if(moveTail)
    {
        endpoint->HcEndpointDescriptor.TailP = tdPhysical;
    }
    //
    //  Call the class driver's callback
    //
    transferComplete(&transferStatus, callbackContext);
}

#endif  //OHCD_ISOCHRONOUS_SUPPORTED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\ohcd.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.


Module Name:

    ohcd.c

Abstract:
    
    Basic entry point implementation of the OpenHCI
    driver.
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-17-00 created by Mitchell Dernis (mitchd)

--*/


//
//  Pull in OS headers
//
#include <ntos.h>
#include <pci.h>


//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");


//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff
#include "devsys.h"     //checks for development systems

//----------------------------------------------------------------------------
//  Spew the build settings during compile
//----------------------------------------------------------------------------
#ifdef OHCD_XBOX_HARDWARE_ONLY
#pragma message("OHCD: Xbox Hardware Only Build")
#endif
#if(USB_HOST_CONTROLLER_CONFIGURATION==USB_SINGLE_HOST_CONTROLLER)
#pragma message("OHCD: Single Host Controller Support")
#endif
#if(USB_HOST_CONTROLLER_CONFIGURATION==USB_DUAL_HOST_CONTROLLER_XDK)
#pragma message("OHCD: Dual Host Controller for Silver XDK boxes")
#endif

//----------------------------------------------------------------------------
// Interrupt objects for each HC - this cannot come from the pool,
// because it has code in it, and the pool is not executable.
//----------------------------------------------------------------------------
KINTERRUPT OHCD_InterruptObject[HCD_MAX_HOST_CONTROLLERS];

//----------------------------------------------------------------------------
// Forward declaration of functions defined and used only this in this module
//----------------------------------------------------------------------------
USBD_STATUS
FASTCALL
OHCD_fOpenEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    );

USBD_STATUS
FASTCALL
OHCD_fCloseEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    );
USBD_STATUS
FASTCALL
OHCD_fGetEndpointState(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    );

USBD_STATUS
FASTCALL
OHCD_fSetEndpointState(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    );
USBD_STATUS
FASTCALL
OHCD_fAbortEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    );
VOID
FASTCALL
OHCD_fSetResources(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    PPCI_DEVICE_DESCRIPTOR      PciDevice
    );
VOID
FASTCALL
OHCD_fDequeueControlTransfer(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb
    );
VOID
FASTCALL
OHCD_fDequeueBulkTransfer(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb
    );
VOID
FASTCALL
OHCD_fDequeueInterruptTransfer(
    IN POHCD_ENDPOINT Endpoint,
    IN PURB Urb
    );
VOID
FASTCALL
OHCD_fCancelQueuedUrbs(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    );

VOID
OHCD_ShutDown(
    PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration
    );


//----------------------------------------------------------------------------
// Implementation of all entry points:
//      HCD_DriverEntry
//      HCD_NewHostController
//      HCD_SubmitRequest
//      HCD_CancelRequest
//----------------------------------------------------------------------------
#pragma code_seg(".XPPCINIT")
VOID
HCD_DriverEntry(
    IN PHCD_RESOURCE_REQUIREMENTS ResourceRequirements
    )
/*++

Routine Description:
    
    Performs one time initialization of driver.  Returns the size of the
    HCD portion of the extension.

Arguments:
    
    ResourceRequirements - tells the host controller how many resources
    to preallocate.

Return Value:

    None.

--*/
{
    USB_DBG_ENTRY_PRINT(("Entering HCD_DriverEntry"));
    USB_DBG_TRACE_PRINT(("Built on %s @%s", __DATE__,__TIME__));
    
    OHCD_fPoolInit(ResourceRequirements);
    
    USB_DBG_EXIT_PRINT(("Exiting HCD_DriverEntry"));
    return;
}

#ifdef SILVER
VOID
HCD_EnumHardware()
/*++
Routine Description:

  The HCD layer is responsible for calling HAL to find its hardware.
  This layer must do it, because only this layer knows the PCI PnP ID
  information about the proper host controller type.

  We call back USBD_NewHostController which allocates the USBD portion
  of the host controller and calls back HCD_NewHostController to
  initialize the hardware.

--*/

{
    PCI_DEVICE_DESCRIPTOR pciDevices[HCD_MAX_HOST_CONTROLLERS];
    ULONG hostControllerIndex=0;
    ULONG hostControllerCount=HCD_MAX_HOST_CONTROLLERS;
    //
    //  Initialize pciDevices array to HAL what we are looking for.
    //
    while(hostControllerCount--)
    {
        pciDevices[hostControllerCount].Bus=(ULONG)-1;
        pciDevices[hostControllerCount].Slot=(ULONG)-1;
        pciDevices[hostControllerCount].VendorID=(USHORT)-1;
		pciDevices[hostControllerCount].DeviceID=(USHORT)-1;
        pciDevices[hostControllerCount].BaseClass=PCI_CLASS_SERIAL_BUS_CTLR;
        pciDevices[hostControllerCount].SubClass=PCI_SUBCLASS_SB_USB;
        pciDevices[hostControllerCount].ProgIf=OHCI_PCI_PROGRAM_INTERFACE;
    }
    //
    //  Ask HAL to find our controllers
    //
    hostControllerCount=HCD_MAX_HOST_CONTROLLERS;
    HalSetupPciDevice(pciDevices, &hostControllerCount);
    
    //
    //  Kick off initialization by notifying USBD about each device.
    //  (Be sure not to change the order that we got from HAL.)
    //
    while(hostControllerIndex < hostControllerCount)
    {
        USBD_NewHostController(pciDevices+hostControllerIndex, sizeof(OHCD_DEVICE_EXTENSION));
        hostControllerIndex++;
    }
}
#else //!SILVER
VOID
HCD_EnumHardware()
/*++
Routine Description:

  On the real hardware the resource information is just hardcoded.
  HCD_MAX_HOST_CONTROLLERS is defined for 1 or 2.

  We call back USBD_NewHostController which allocates the USBD portion
  of the host controller and calls back HCD_NewHostController to
  initialize the hardware.

--*/

{
    PCI_DEVICE_DESCRIPTOR pciDevice;

    //Just return if this is Xbox MCP version A1.  USB cause interrupt storms on this
    //revision and doesn't work at all anyway.
    if (XboxHardwareInfo->McpRevision == 0xa1) return;

    pciDevice.ResourceData.Address[0].Type = CmResourceTypeMemory;
    pciDevice.ResourceData.Address[0].u.Memory.Length = XPCICFG_USB0_MEMORY_REGISTER_LENGTH_0;
    pciDevice.ResourceData.Address[0].u.Memory.TranslatedAddress = (PVOID)XPCICFG_USB0_MEMORY_REGISTER_BASE_0;
    pciDevice.ResourceData.Interrupt.Vector = HalGetInterruptVector(XPCICFG_USB0_IRQ, &pciDevice.ResourceData.Interrupt.Irql);
    USBD_NewHostController(&pciDevice, sizeof(OHCD_DEVICE_EXTENSION));
    if(1==HCD_MAX_HOST_CONTROLLERS) return;

    pciDevice.ResourceData.Address[0].Type = CmResourceTypeMemory;
    pciDevice.ResourceData.Address[0].u.Memory.Length = XPCICFG_USB1_MEMORY_REGISTER_LENGTH_0;
    pciDevice.ResourceData.Address[0].u.Memory.TranslatedAddress = (PVOID)XPCICFG_USB1_MEMORY_REGISTER_BASE_0;
    pciDevice.ResourceData.Interrupt.Vector = HalGetInterruptVector(XPCICFG_USB1_IRQ, &pciDevice.ResourceData.Interrupt.Irql);
    USBD_NewHostController(&pciDevice, sizeof(OHCD_DEVICE_EXTENSION));
}
#endif //!SILVER
    

NTSTATUS
HCD_NewHostController(
    IN PVOID  HcdExtension,
    IN UCHAR  HostControllerNumber,
    IN PPCI_DEVICE_DESCRIPTOR PciDevice
    )
/*++

Routine Description:
    
    When the USBD goes through HAL

Arguments:
    
    DeviceObject - device object associated with host controller.
    ResourceList - list of resources obtained from PCI bus.

Return Value:

    STATUS_SUCCESS.  Otherwise we will KeBugcheck before returning.

--*/
{
    HC_COMMAND_STATUS           HcCommandStatus;
    KIRQL                       oldIrql;
    POHCD_DEVICE_EXTENSION      deviceExtension = (POHCD_DEVICE_EXTENSION)HcdExtension;
    HC_FRAME_INTERVAL           frameInterval;
    BOOLEAN                     interruptConnected;
    POHCI_OPERATIONAL_REGISTERS operationalRegisters = NULL;

    //ULONG frameIntervalSniff1;
    //ULONG frameIntervalSniff2;
    //ULONG frameIntervalSniff3;
    //ULONG frameIntervalSniff4;
    //ULONG frameIntervalSniff5;

    
    USB_DBG_ENTRY_PRINT(("Entering HCD_NewHostController"));
    
    PROFILE_DECLARE_TIME_STAMP(ResetTiming);

    //
    //  Before we go initializing fields zero the whole extension.
    //  That way we can use a NULL check on pointers to see if something
    //  has been initialized yet.
    //  (Not necessary, USBD does this for us.)
    //RtlZeroMemory( (PVOID)deviceExtension, sizeof(OHCD_DEVICE_EXTENSION));

    //
    //  Remember the host controller number, it will come in
    //  handy when need to search the global TD pool for stuff
    //  that our hardware lost!
    //  (one based for USBD, but we want 0 based.)
    deviceExtension->HostControllerNumber = --HostControllerNumber;

    //
    //  Set the resources for the card.
    //
    OHCD_fSetResources(deviceExtension, PciDevice);

    //frameIntervalSniff1 = READ_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcFmInterval.ul);
    //
    //  Do a quick check of version and stuff.
    //  This should only happen on preliminary development
    //  system hardware. It is used to verify that
    //  a development system is using an XBOX compatible 
    //  USB driver.  It will also be used on XBOX
    //  to verify that the hardware is what we think it
    //  should be.
    //
    OHCD_DEVSYS_CHECK_HARDWARE(deviceExtension);

    //
    //  On a development system without the final XBOX
    //  BIOS, there may be an SMM driver or BIOS
    //  driver using the Host Controller.  We need
    //  to take control.
    //
    OHCD_DEVSYS_TAKE_CONTROL(deviceExtension);

    //
    //  Get the operational registers
    //
    operationalRegisters = deviceExtension->OperationalRegisters;

#ifdef OHCD_XBOX_HARDWARE_ONLY
    //
    //  Set up the few root hub registers that should be done while
    //  the host controller is in the reset state (or before reseting).
    //
    WRITE_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorA.ul, HC_RH_DESCRIPTOR_A_INIT_XBOX);
    WRITE_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorB.ul, HC_RH_DESCRIPTOR_B_INIT_XBOX);
    WRITE_REGISTER_ULONG(&operationalRegisters->HcRhStatus.ul, HC_RH_STATUS_INIT_XBOX);
#endif

    //
    //  Initialize the IsrDPC
    //
    KeInitializeDpc(&deviceExtension->IsrDpc, OHCD_IsrDpc, deviceExtension);
    
    //
    //  Get the HCCA and the physical address of it
    //
    deviceExtension->HCCA = OHCD_PoolGetHcca(HostControllerNumber);
    
    //
    //  Reset the host controller.
    //  
    //  TIMING NOTES:
    //      After writing the reset bit we must wait 10us before setting the hardware registers.
    //      However, we must complete setup and set it back to operational within 2 ms.
    //      We can easily do this in under 2ms as along as our quantum doesn't run out so
    //      raise IRQL to prevent it.
    //
    //
    HcCommandStatus.ul = READ_REGISTER_ULONG(&operationalRegisters->HcCommandStatus.ul);
    HcCommandStatus.HostControllerReset = 1;
    PROFILE_BEGIN_TIMING(ResetTiming);
    oldIrql = KeRaiseIrqlToDpcLevel();
    WRITE_REGISTER_ULONG(&operationalRegisters->HcCommandStatus.ul, HcCommandStatus.ul);
    
    //
    //  Delay for 10 us  
    //
    KeStallExecutionProcessor(10);

    //frameIntervalSniff2 = READ_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcFmInterval.ul);

    //
    //  Set up periodic schedule and HCCA
    //
    OHCD_ScheduleInitialize(deviceExtension);

    //frameIntervalSniff3 = READ_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcFmInterval.ul);
    //
    //  See header file with HC_CONTROL_REGISTER_START
    //  it saves a few instruction rather than using the
    //  bit fields to construct the ULONG.
    //
    //  Basically, we set the state to operational, disable all of the lists,
    //  and initialize things like wakeup behavior.
    //
    WRITE_REGISTER_ULONG(&operationalRegisters->HcControl.ul,HC_CONTROL_REGISTER_START|HC_CONTROL_ISOCH_ENABLE_STATE);
    
    
    //
    //  Apparently the FullSpeedMaximumPacketSize gets reset when moving to the
    //  operational state. This is slightly different then what the OpenHCI 
    //  specification seems to imply.  I read it has reseting this value to its
    //  default of 0x2edf when the
    //  So we moved these couple of lines out of OHCD_ScheduleInitialize
    //  and put them here.
    //
    
    
    frameInterval.ul = READ_REGISTER_ULONG(&operationalRegisters->HcFmInterval.ul);
    //frameIntervalSniff4 = frameInterval.ul;
    frameInterval.FrameInterval = OHCI_DEFAULT_FRAME_INTERVAL;
    frameInterval.FullSpeedMaximumPacketSize = OHCI_CLOCKS_TO_BITS(OHCI_DEFAULT_FRAME_INTERVAL);
    frameInterval.FrameIntervalToggle ^= 1;
    WRITE_REGISTER_ULONG(&operationalRegisters->HcFmInterval.ul, frameInterval.ul);
    

    //
    //  The 2ms time limit is up.  If profiling
    //  is turned let's make sure we made it
    //  within a comfortable margin.
    //  We are not worried about being interrupt
    //  so we can lower the IRQL again.
    //
    PROFILE_END_TIMING(ResetTiming);
    KeLowerIrql(oldIrql);

    //frameIntervalSniff5 = READ_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcFmInterval.ul);

    //
    // Setup the interrupt vector
    //
    KeInitializeInterrupt (
        &OHCD_InterruptObject[HostControllerNumber],
        (PKSERVICE_ROUTINE) OHCD_InterruptService,            
        (PVOID) deviceExtension,                        
        PciDevice->ResourceData.Interrupt.Vector,
        PciDevice->ResourceData.Interrupt.Irql,
        LevelSensitive,
        TRUE
        );

    interruptConnected = KeConnectInterrupt(&OHCD_InterruptObject[HostControllerNumber]);
    
    ASSERT(interruptConnected && "Failed to connect to interrupt");
    
    USB_DBG_TRACE_PRINT(("Interrupt Resource Set:"));
    USB_DBG_TRACE_PRINT(("  Irql(Level) = %d", PciDevice->ResourceData.Interrupt.Irql));
    USB_DBG_TRACE_PRINT(("  Vector      = %d", PciDevice->ResourceData.Interrupt.Vector));
    USB_DBG_TRACE_PRINT(("  Assigned InterruptObject at 0x%0.8x", &OHCD_InterruptObject[HostControllerNumber]));
    USB_DBG_TRACE_PRINT(("  IoConnectInterrupt returned 0x%0.8x", ntStatus));

    //
    //  Register for shutdown notification (now that we have an interrupt object,
    //  but before enabling interrupts.
    //

    deviceExtension->ShutdownRegistration.NotificationRoutine = OHCD_ShutDown;
    deviceExtension->ShutdownRegistration.Priority = 1;
    InitializeListHead(&deviceExtension->ShutdownRegistration.ListEntry);
    HalRegisterShutdownNotification(&deviceExtension->ShutdownRegistration, TRUE);

    //
    //  Enable Interrupts
    //
    WRITE_REGISTER_ULONG(&operationalRegisters->HcInterruptEnable, 
                            HCINT_SchedulingOverrun |
                            HCINT_WritebackDoneHead |
                            HCINT_UnrecoverableError |
                            HCINT_FrameNumberOverflow |
                            HCINT_MasterInterruptEnable
                            );

    //USB_DBG_WARN_PRINT(("frameIntervalSniff1 = 0x%0.8x", frameIntervalSniff1));
    //USB_DBG_WARN_PRINT(("frameIntervalSniff2 = 0x%0.8x", frameIntervalSniff2));
    //USB_DBG_WARN_PRINT(("frameIntervalSniff3 = 0x%0.8x", frameIntervalSniff3));
    //USB_DBG_WARN_PRINT(("frameIntervalSniff4 = 0x%0.8x", frameIntervalSniff4));
    //USB_DBG_WARN_PRINT(("frameIntervalSniff5 = 0x%0.8x", frameIntervalSniff5));

    //
    //  Now kick of detection of devices, by initializing the root hub.
    //
    OHCD_RootHubInitialize(deviceExtension);


    USB_DBG_EXIT_PRINT(("Exiting HCD_NewHostController"));
    return STATUS_SUCCESS;
}
#pragma code_seg(".XPPCODE")

USBD_STATUS
HCD_SubmitRequest(
    IN PVOID        HcdDeviceExtension,
    IN PURB         Urb
    )
/*++

Routine Description:

   Process URBs from the USBD layer.

Arguments:

   DeviceObject - pointer to a device object

   HcdUrb - pointer to a USB Request Block

Return Value:


--*/
{
    USBD_STATUS             usbdStatus = USBD_STATUS_SUCCESS;
    POHCD_DEVICE_EXTENSION  deviceExtension = (POHCD_DEVICE_EXTENSION)HcdDeviceExtension;
    
    USB_DBG_ENTRY_PRINT(("Entering HCD_SubmitRequest"));
    switch (Urb->Header.Function)
    {
        //
        // Open Endpoint and Close Endpoint IRPs are serialized
        // within USBD so we can execute them now.
        //
        case URB_FUNCTION_OPEN_ENDPOINT:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_HCD_OPEN_ENDPOINT"));
            usbdStatus = OHCD_fOpenEndpoint(deviceExtension, Urb);
            break;
        case URB_FUNCTION_CLOSE_ENDPOINT:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_HCD_CLOSE_ENDPOINT"));
            usbdStatus = OHCD_fCloseEndpoint(deviceExtension, Urb);
            break;
        case URB_FUNCTION_CONTROL_TRANSFER:
        case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_<XXXX>_TRANSFER"));
            ASSERT(Urb->CommonTransfer.EndpointHandle);
            usbdStatus = OHCD_fQueueTransferRequest(deviceExtension, Urb);
            break;
        case URB_FUNCTION_GET_FRAME_NUMBER:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_GET_CURRENT_FRAME_NUMBER"));
            Urb->GetFrame.FrameNumber = OHCD_Get32BitFrameNumber(deviceExtension);
            usbdStatus = USBD_STATUS_SUCCESS;
            break;
        case URB_FUNCTION_GET_ENDPOINT_STATE:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_HCD_GET_ENDPOINT_STATE"));
            usbdStatus=OHCD_fGetEndpointState(deviceExtension, Urb);
            break;
        case URB_FUNCTION_SET_ENDPOINT_STATE:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_HCD_SET_ENDPOINT_STATE"));
            usbdStatus=OHCD_fSetEndpointState(deviceExtension, Urb);
            break;
        case URB_FUNCTION_ABORT_ENDPOINT:
            USB_DBG_TRACE_PRINT(("URB_FUNCTION_HCD_ABORT_ENDPOINT"));
            usbdStatus=OHCD_fAbortEndpoint(deviceExtension, Urb);
            break;
        case URB_FUNCTION_ISOCH_OPEN_ENDPOINT:
            usbdStatus=OHCD_ISOCH_OPEN_ENDPOINT(deviceExtension, Urb);
            break;
        case URB_FUNCTION_ISOCH_CLOSE_ENDPOINT:
            usbdStatus=OHCD_ISOCH_CLOSE_ENDPOINT(deviceExtension, Urb);
            break;                                
        case URB_FUNCTION_ISOCH_ATTACH_BUFFER:
            usbdStatus=OHCD_ISOCH_ATTACH_BUFFERS(deviceExtension, Urb);
            break;
        case URB_FUNCTION_ISOCH_START_TRANSFER:
            usbdStatus=OHCD_ISOCH_START_TRANSFER(deviceExtension, Urb);
            break;
        case URB_FUNCTION_ISOCH_STOP_TRANSFER:
            usbdStatus=OHCD_ISOCH_STOP_TRANSFER(deviceExtension, Urb);
            break;
        default:
            ASSERT(FALSE && "Unsupported URB");
            usbdStatus = USBD_STATUS_INVALID_URB_FUNCTION;
    }

    //
    //  If we are not returning a pending status
    //  than we should call CompleteUsbRequest.
    //  
    if(!USBD_PENDING(usbdStatus ))
    {
        Urb->Header.Status = usbdStatus;
        USBD_CompleteRequest(Urb);
    }
    USB_DBG_EXIT_PRINT(("Exiting HCD_SubmitRequest: usbdStatus = 0x%0.8x", usbdStatus));
    return usbdStatus;
}


USBD_STATUS
HCD_CancelRequest(
    IN PVOID    HcdDeviceExtension,
    IN PURB     Urb
    )
/*++

Routine Description:

    Entry point called by USBD to cancel a transfer request.
    
    The URB could be either in a queue waiting to be programmed,
    or already programmed.
    
    If it is in a queue, we can find it, remove it, and complete
    as canceled right here.

    If it has been programmed, then we need to pause the endpoint,
    and place the Urb on the PendingCancels list.  On the next
    frame, we can access the endpoint from the DPC and cancel the URB.

Arguments:
    
    DeviceExtension - DeviceObject for this USB controller.

    HcdUrb          - Pointer to previously submitted URB to cancel

  Return Value:
        USBD_STATUS_CANCELED    - Urb has been canceled.
        USBD_STATUS_CANCELING   - Urb is in process of being canceled.
--*/
{
    POHCD_ENDPOINT          endpoint;
    USBD_STATUS             status = USBD_STATUS_CANCELED;
    POHCD_DEVICE_EXTENSION  deviceExtension = (POHCD_DEVICE_EXTENSION)HcdDeviceExtension;
    KIRQL                   oldIrql;

    USB_DBG_ENTRY_PRINT(("Entering HCD_CancelRequest"));
    //
    //  Only control, bulk and interrupt transfers can be cancelled.
    //  if the URB is not a transfer (or an isochronous transfer).
    //  There is a bug in the caller's code (USBD, or class driver).
    //
    ASSERT( 
        (URB_FUNCTION_CONTROL_TRANSFER == Urb->Header.Function) ||
        (URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER == Urb->Header.Function)
        );

    //
    //  It is not inconceivable that an URB would legitimately get canceled twice.
    //  Just ignore it if it happens.
    //
    if(Urb->CommonTransfer.Hca.HcdUrbFlags & OHCD_URB_FLAG_CANCELED)
    {
        return USBD_STATUS_CANCELING;
    }

    //
    //  We need to be at dispatch level while handling
    //  queues and stuff.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  If the URB has been queued, but not yet programmed
    //  we can handle everything here and now.
    endpoint = (POHCD_ENDPOINT)Urb->CommonTransfer.EndpointHandle;
    
    //
    //  If the endpoint is in the process of being closed
    //  ignore the cancel request.
    //
    if(OHCD_ENDPOINT_FLAG_CLOSING&endpoint->Flags)
    {
        status = USBD_STATUS_CANCELING;
        goto ExitHCD_CancelRequest;
    }

    if(Urb->CommonTransfer.Hca.HcdUrbFlags & OHCD_URB_FLAG_QUEUED)
    {
        //
        //  Dispatch to the proper routine to dequeue the URB
        //
        switch(endpoint->EndpointType)
        {
            case USB_ENDPOINT_TYPE_CONTROL:
                OHCD_fDequeueControlTransfer(deviceExtension, Urb);
                break;
            case USB_ENDPOINT_TYPE_BULK:
                OHCD_fDequeueBulkTransfer(deviceExtension, Urb);
                break;
            case USB_ENDPOINT_TYPE_INTERRUPT:
                OHCD_fDequeueInterruptTransfer(endpoint, Urb);
                break;
            default:
                //ISOCH endpoint never expected here.
                USB_DBG_ERROR_PRINT(("Unrecognized or Unsupported endpoint type in HCD_CancelRequest"));
                //Execution should be able to continue.
                status = USBD_STATUS_REQUEST_FAILED;
                goto ExitHCD_CancelRequest;
        }
        endpoint->QueuedUrbCount--;
        Urb->Header.Status = USBD_STATUS_CANCELED;
        Urb->CommonTransfer.Hca.HcdUrbFlags |= OHCD_URB_FLAG_CANCELED;
        USBD_CompleteRequest(Urb);
        status = USBD_STATUS_SUCCESS;
    } else 
    {
        //
        //  If we are not queued than we ought to be programmed.
        //
        ASSERT(Urb->CommonTransfer.Hca.HcdUrbFlags & OHCD_URB_FLAG_PROGRAMMED);

        //
        //  Mark the URB canceled.
        //
        Urb->CommonTransfer.Hca.HcdUrbFlags |= OHCD_URB_FLAG_CANCELED;

        //
        //  Add the URB to the PendingCancels list.
        //
        Urb->CommonTransfer.Hca.HcdUrbLink = deviceExtension->PendingCancels;
        deviceExtension->PendingCancels = Urb;

        //
        //  Pause the endpoint, the IsrDPC
        //  will take care of the rest.
        //
        OHCD_fPauseEndpoint(deviceExtension, endpoint);
        status = USBD_STATUS_CANCELING;
    }
    
    //
    //  Done with queues and stuff
    //
ExitHCD_CancelRequest:
    KeLowerIrql(oldIrql);
    
    USB_DBG_EXIT_PRINT(("Exiting HCD_CancelRequest: status = 0x%0.8x", status));
    return status;
}

USBD_STATUS
FASTCALL
OHCD_fOpenEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    )
/*++

Routine Description:

    Opens an endpoint.  This is a multistep process:

    1)  Get an endpoint

    2)  Zero the memory.
      
    3)  Initialize the endpoint header
    
    4)  Insert Endpoint in schedule.
	5)  Update the handle, or cleanup if something failed.

Arguments:
    
    DeviceExtension - DeviceObject for this USB controller.

    HcdUrb          - Pointer to URB which contains an open endpoint 
                        request

  Return Value:

    Error code several failure cases:
    1) Cannot allocate Endpoint.
    2) Cannot reserved descriptor blocks
    3) Not enough bandwidth in schedule (isoch and interrupt only)

--*/
{
    POHCD_ENDPOINT  newEndpoint = NULL;
    USBD_STATUS     status = USBD_STATUS_SUCCESS;
    KIRQL           oldIrql;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_OpenEndpoint"));

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  1) Allocate an endpoint from the pool.
    //
    newEndpoint = OHCD_PoolAllocateEndpoint();
    if(!newEndpoint)
    {
        USB_DBG_WARN_PRINT(("Attempt to exceed registered endpoints."));
        status = USBD_STATUS_NO_MEMORY;
        goto ExitOpenEndpoint;
    }

    //
    // 2) Zero memory and set flags
    //
    USB_DBG_ENTRY_PRINT(("Zeroing structure."));
    RtlZeroMemory( (PVOID)newEndpoint, sizeof(OHCD_ENDPOINT));

    //
    //  It is helpful to cache our physical address
    //
    newEndpoint->PhysicalAddress = OHCD_PoolGetPhysicalAddress(newEndpoint);

    //
    //  Save off the endpoint type
    //
    newEndpoint->EndpointType = Urb->OpenEndpoint.EndpointType;

    //
    //  Fill out polling interval, and bandwidth
    //
    newEndpoint->PollingInterval = Urb->OpenEndpoint.Interval;
    newEndpoint->Bandwidth = USBD_CalculateUsbBandwidth(
                                    Urb->OpenEndpoint.MaxPacketSize,
                                    newEndpoint->EndpointType,
                                    Urb->OpenEndpoint.LowSpeed
                                    );

    //
    //  Fill out everything in the control structure.
    //  Note the Direction here is set correctly for non-control endpoints.
    //  in the next step we have an if USB_ENDPOINT_TYPE_CONTROL and we fix it
    //  for the control endpoints.
    //
    newEndpoint->HcEndpointDescriptor.Control.FunctionAddress = Urb->OpenEndpoint.FunctionAddress;
    newEndpoint->HcEndpointDescriptor.Control.EndpointAddress = Urb->OpenEndpoint.EndpointAddress;
    if(USB_ENDPOINT_TYPE_CONTROL == newEndpoint->EndpointType)
    {
        newEndpoint->HcEndpointDescriptor.Control.Direction = 0;
    }else
    {
        newEndpoint->HcEndpointDescriptor.Control.Direction = (USB_ENDPOINT_DIRECTION_MASK & Urb->OpenEndpoint.EndpointAddress) ? 2 : 1;
    }
    newEndpoint->HcEndpointDescriptor.Control.Speed =  Urb->OpenEndpoint.LowSpeed;
    newEndpoint->HcEndpointDescriptor.Control.Skip = 1;
    newEndpoint->HcEndpointDescriptor.Control.Format = 0;
    newEndpoint->HcEndpointDescriptor.Control.MaximumPacketSize = Urb->OpenEndpoint.MaxPacketSize;

    //
    //  We do not have any URBs now either.
    //
    /*  Unneccessary, we zeroed the structure right after allocating it.
    newEndpoint->PendingUrbHeadP =
    newEndpoint->PendingUrbTailP =
    newEndpoint->PendingUrbCurrentP = NULL;
    */

    //
    //  3) Initialize Endpoint descriptor.
    //
    newEndpoint->HcEndpointDescriptor.NextED = 0;
    newEndpoint->HcEndpointDescriptor.HeadPHaltCarry = 0;
    newEndpoint->HcEndpointDescriptor.TailP = 0;

    //
    //  Set the initial data toggle
    //
    if(Urb->OpenEndpoint.DataToggleBits)
    {
        ULONG dataToggleMask = 1 << newEndpoint->HcEndpointDescriptor.Control.EndpointAddress;
        if(newEndpoint->HcEndpointDescriptor.Control.Direction == 2)
        {
            dataToggleMask <<= 16;
        }
        if((*Urb->OpenEndpoint.DataToggleBits)&dataToggleMask)
        {
            SET_TOGGLECARRY(&newEndpoint->HcEndpointDescriptor);
        }
    }

    //
    //  4) Insert endpoint into schedule, and
    //
    if( USB_ENDPOINT_TYPE_CONTROL == newEndpoint->EndpointType ||
        USB_ENDPOINT_TYPE_BULK == newEndpoint->EndpointType )
    //
    //  Control or bulk
    //
    {
        OHCD_ScheduleAddEndpointControlOrBulk(DeviceExtension, newEndpoint);
    }
    else
    //
    //  Interrupt
    //
    {
        ASSERT(USB_ENDPOINT_TYPE_INTERRUPT == newEndpoint->EndpointType);
        //
        //  Scheduling Periodic Endpoints can fail due to lack of bandwidth.
        //
        status = OHCD_ScheduleAddEndpointPeriodic(DeviceExtension, newEndpoint);
    }

    //
    //  5) Udpate URB handle
    //
    if(USBD_SUCCESS(status))
    {
        Urb->OpenEndpoint.EndpointHandle = newEndpoint;
    }
    else
    {
        Urb->OpenEndpoint.EndpointHandle = NULL;
        OHCD_PoolFreeEndpoint(newEndpoint);
    }

ExitOpenEndpoint:
    Urb->Header.Status = status;
    KeLowerIrql(oldIrql);
    USB_DBG_EXIT_PRINT(("Exiting OHCD_OpenEndpoint: usbdStatus = 0x%0.8x", status));
    return status;
}

USBD_STATUS
FASTCALL
OHCD_fCloseEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    )
{
    POHCD_ENDPOINT  endpoint = (POHCD_ENDPOINT)Urb->CloseEndpoint.EndpointHandle;
    KIRQL           oldIrql;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_CloseEndpoint"));

    oldIrql = KeRaiseIrqlToDpcLevel();
    endpoint->Flags |= OHCD_ENDPOINT_FLAG_CLOSING;

    //
    //  Cancel any queued URBs (but not programmed) right now.
    //
    OHCD_fCancelQueuedUrbs(DeviceExtension, endpoint);

    //
    //  Remove endpoint from schedule
    //
    ASSERT(USB_ENDPOINT_TYPE_ISOCHRONOUS != endpoint->EndpointType);
    if( USB_ENDPOINT_TYPE_CONTROL == endpoint->EndpointType ||
        USB_ENDPOINT_TYPE_BULK == endpoint->EndpointType )
    //
    //  Control or bulk
    //
    {
        OHCD_ScheduleRemoveEndpointControlOrBulk(DeviceExtension, endpoint);
    }
    else
    //
    //  Interrupt
    //
    {
        OHCD_ScheduleRemoveEndpointPeriodic(DeviceExtension, endpoint);
    }

    //
    //  Add to endpoint reclamation queue, we do not need to pause it,
    //  but the pause routine is convenient.
    //
    OHCD_fPauseEndpoint(DeviceExtension, endpoint);
    
    //
    //  Link the URB into the list of pending closes.
    //

    ASSERT(DeviceExtension->PendingCloses != Urb);
    
    Urb->CloseEndpoint.HcdNextClose = DeviceExtension->PendingCloses;
    DeviceExtension->PendingCloses = Urb;
    
    KeLowerIrql(oldIrql);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_CloseEndpoint: usbdStatus = USBD_STATUS_PENDING"));
    return USBD_STATUS_PENDING;
}

USBD_STATUS
FASTCALL
OHCD_fGetEndpointState(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    )
/*++

Routine Description:

    Gets the endpoint state.  The state consists of two flags:

        USB_ENDPOINT_TRANSFERS_QUEUED
        USB_ENDPOINT_HALTED

Arguments:

    DeviceExtension - DeviceObject for this USB controller.

    HcdUrb          - Pointer to URB that we are servicing.

  Return Value:

    USBD_STATUS_SUCCESS

--*/

{
    POHCD_ENDPOINT endpoint = (POHCD_ENDPOINT)Urb->GetSetEndpointState.EndpointHandle;
    
    USB_DBG_ENTRY_PRINT(("Entering OHCD_GetEndpointState"));
    USB_DBG_TRACE_PRINT(("Endpoint state flags:"));
    //
    //  Get whether or not is halted
    //
    Urb->GetSetEndpointState.EndpointState = 
        GET_HALTED(&endpoint->HcEndpointDescriptor) ? USB_ENDPOINT_STATE_HALTED : 0;

    USB_DBG_TRACE_PRINT(("%s",(Urb->GetSetEndpointState.EndpointState&USB_ENDPOINT_STATE_HALTED)?"     USB_ENDPOINT_HALTED":NULL));

    //
    //  Now set the USB_ENDPOINT_TRANSFERS_QUEUED flag.
    //
    
    if(endpoint->QueuedUrbCount || endpoint->ProgrammedUrbCount)
    {
        Urb->GetSetEndpointState.EndpointState |= USB_ENDPOINT_STATE_TRANSFERS_QUEUED;
        USB_DBG_TRACE_PRINT(("     USB_ENDPOINT_STATE_TRANSFERS_QUEUED"));
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_GetEndpointState"));
    return USBD_STATUS_SUCCESS;
}

USBD_STATUS
FASTCALL
OHCD_fSetEndpointState(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    )
/*++

Routine Description:

    Sets the endpoint state.  Basically, it can do only do things.
    Restart a halted endpoint.  Reset the data toggle on an endpoint.

    1) If USB_ENDPOINT_RESET_DATA_TOGGLE is set, we will reset the data toggle.
    2) If USB_ENDPOINT_HALTED is clear, we clear the halt bit.

Arguments:
    
    DeviceExtension - DeviceObject for this USB controller.

    HcdUrb          - Pointer to URB that we are servicing.

  Return Value:

    USBD_STATUS_SUCCESS

--*/
{
    POHCD_ENDPOINT endpoint = (POHCD_ENDPOINT)Urb->GetSetEndpointState.EndpointHandle;
    ULONG state = Urb->GetSetEndpointState.EndpointState;
    
    USB_DBG_ENTRY_PRINT(("Entering OHCD_SetEndpointState"));
    if(state & USB_ENDPOINT_STATE_DATA_TOGGLE_RESET)
    {
        USB_DBG_TRACE_PRINT(("Clearing the toggle carry."));
        CLEAR_TOGGLECARRY(&endpoint->HcEndpointDescriptor);
    }
    if(state & USB_ENDPOINT_STATE_DATA_TOGGLE_SET)
    {
        USB_DBG_TRACE_PRINT(("Setting the toggle carry."));
        SET_TOGGLECARRY(&endpoint->HcEndpointDescriptor);
    }
    if(!(state & USB_ENDPOINT_STATE_KEEP_HALT) && GET_HALTED(&endpoint->HcEndpointDescriptor))
    {
        USB_DBG_TRACE_PRINT(("Clearing a halt condition."));
        CLEAR_HALTED(&endpoint->HcEndpointDescriptor);
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_SetEndpointState"));
    return USBD_STATUS_SUCCESS;
}

USBD_STATUS
FASTCALL
OHCD_fAbortEndpoint(
    IN      POHCD_DEVICE_EXTENSION  DeviceExtension,
    IN OUT  PURB                    Urb
    )
/*++

Routine Description:

   Cancels all of the requests associated with a particular
   endpoint.

Arguments:
    
    DeviceExtension - DeviceObject for this USB controller.

    Urb             - Pointer to URB that we are servicing.

  Return Value:

    USBD_STATUS_SUCCESS

--*/
{
//
    POHCD_ENDPOINT  endpoint = (POHCD_ENDPOINT)Urb->AbortEndpoint.EndpointHandle;
    KIRQL           oldIrql;
    USBD_STATUS     status = USBD_STATUS_SUCCESS;
    
    oldIrql = KeRaiseIrqlToDpcLevel();
    //
    //  Cancel any queued URBs (but not programmed) right now.
    //
    OHCD_fCancelQueuedUrbs(DeviceExtension, endpoint);

    //
    //  If there are urbs programmed, we need to queue
    //  the abort urb, and pause the endpoint.
    //
    if(endpoint->ProgrammedUrbCount)
    {
        //
        //  Queue Abort Urb
        //
        Urb->AbortEndpoint.HcdNextAbort = DeviceExtension->PendingAborts;
        DeviceExtension->PendingAborts = Urb;
        OHCD_fPauseEndpoint(DeviceExtension, endpoint);
        status = USBD_STATUS_PENDING;
    }
    KeLowerIrql(oldIrql);

    return status;
}


#pragma code_seg(".XPPCINIT")
VOID
FASTCALL
OHCD_fSetResources(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    PPCI_DEVICE_DESCRIPTOR      PciDevice
    )
/*++

Routine Description:

    This routines uses the Hal routines to configure
    the PCI bus for the card.  And store those settings.
    
    This is two stages:
    1) Initialize out device extension with proper base address.
    2) Create an NT interrupt object.

Arguments:

   DeviceExtension      - DeviceExtension for this USB controller.
   PciDevice            - PCI BAR for device

Return Value:

    None

Failures:
    Assume everything works.  Assert failures.  Basically
    any possible errors are configuration, these shouldn't
    happen.

--*/
{
    USB_DBG_ENTRY_PRINT(("Entering OHCD_SetResources"));
    //
    //  Record memory resource
    //
    ASSERT(PciDevice->ResourceData.Address[0].Type == CmResourceTypeMemory);
    ASSERT(PciDevice->ResourceData.Address[0].u.Memory.Length >= sizeof(OHCI_OPERATIONAL_REGISTER_SIZE));
    DeviceExtension->OperationalRegistersLength = PciDevice->ResourceData.Address[0].u.Memory.Length;
    DeviceExtension->OperationalRegisters = 
        (POHCI_OPERATIONAL_REGISTERS)PciDevice->ResourceData.Address[0].u.Memory.TranslatedAddress;
    USB_DBG_TRACE_PRINT(("Virtual Register Address = 0x%0.8x", DeviceExtension->OperationalRegisters));
    
    USB_DBG_EXIT_PRINT(("Exiting OHCD_SetResources"));
    return;
}
#pragma code_seg(".XPPCODE")

VOID
FASTCALL
OHCD_fDequeueControlTransfer(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb
    )
{
    //
    //  Walk the control transfer queue and find the URB
    //
    PURB urbOnQueue = DeviceExtension->ControlUrbHeadP;
    PURB prevUrbOnQueue = NULL;
    while(urbOnQueue != Urb)
    {
        //
        //  Serious error, if we got to the end of the queue and didn't find it.
        //
        ASSERT(urbOnQueue != DeviceExtension->ControlUrbTailP);
        //
        //  Walk link for next iteration
        //
        prevUrbOnQueue = urbOnQueue;
        urbOnQueue = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    
    //
    //  Remove the Urb
    //
    if(NULL == prevUrbOnQueue)
    {
        DeviceExtension->ControlUrbHeadP = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    } else
    {
        prevUrbOnQueue->CommonTransfer.Hca.HcdUrbLink = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    //
    //  If it was the last URB, update the tail pointer too.
    //
    if(Urb == DeviceExtension->ControlUrbTailP)
    {
        DeviceExtension->ControlUrbTailP = prevUrbOnQueue;
    }
}

VOID
FASTCALL
OHCD_fDequeueBulkTransfer(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb
    )
{
    //
    //  Walk the control transfer queue and find the URB
    //
    PURB urbOnQueue = DeviceExtension->BulkUrbHeadP;
    PURB prevUrbOnQueue = NULL;
    while(urbOnQueue != Urb)
    {
        //
        //  Serious error, if we got to the end of the queue and didn't find it.
        //
        ASSERT(urbOnQueue != DeviceExtension->BulkUrbTailP);
        //
        //  Walk link for next iteration
        //
        prevUrbOnQueue = urbOnQueue;
        urbOnQueue = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    
    //
    //  Remove the Urb
    //
    if(NULL == prevUrbOnQueue)
    {
        DeviceExtension->BulkUrbHeadP = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    } else
    {
        prevUrbOnQueue->CommonTransfer.Hca.HcdUrbLink = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    //
    //  If it was the last URB, update the tail pointer too.
    //
    if(Urb == DeviceExtension->BulkUrbTailP)
    {
        DeviceExtension->BulkUrbTailP = prevUrbOnQueue;
    }
}

VOID
FASTCALL
OHCD_fDequeueInterruptTransfer(
    IN POHCD_ENDPOINT Endpoint,
    IN PURB Urb
    )
{
    //
    //  Walk the control transfer queue and find the URB
    //
    PURB urbOnQueue = Endpoint->PendingUrbHeadP;
    PURB prevUrbOnQueue = NULL;
    while(urbOnQueue != Urb)
    {
        //
        //  Serious error, if we got to the end of the queue and didn't find it.
        //
        ASSERT(urbOnQueue != Endpoint->PendingUrbTailP);
        //
        //  Walk link for next iteration
        //
        prevUrbOnQueue = urbOnQueue;
        urbOnQueue = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    
    //
    //  Remove the Urb
    //
    if(NULL == prevUrbOnQueue)
    {
        Endpoint->PendingUrbHeadP = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    } else
    {
        prevUrbOnQueue->CommonTransfer.Hca.HcdUrbLink = urbOnQueue->CommonTransfer.Hca.HcdUrbLink;
    }
    //
    //  If it was the last URB, update the tail pointer too.
    //
    if(Urb == Endpoint->PendingUrbTailP)
    {
        Endpoint->PendingUrbTailP = prevUrbOnQueue;
    }
}

VOID
FASTCALL
OHCD_fCancelQueuedUrbs(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    )
/*++

 Routine Description:

    Called by OHCD_AbortEndpoint and OHCD_CloseEndpoint, to
    cancel any Urbs which have been queued, but not yet programmed.
   
    Different types of endpoints have URBs queued in different
    places.  We first switch on the endpoint type, to initialize
    pointers to the queue pointers.

    Then we walk the queue using pointers to pointers.  I will
    be the first to admit that this is style of code is not
    terribly readable.  However, it is efficient, so I tried to
    just comment well.
    
Arguments:

   DeviceExtension      - DeviceExtension for this USB controller.

   Endpoint             - Endpoint to cancel URBs for.

Return Value:

    None

--*/
{

    PURB    *currentUrbP;                       //Pointer to official pointer to the URB we are currently processing
    PURB    *tailUrbP;                          //Pointer to official pointer to the tail URB in queue
    PURB    currentUrb = NULL;                  //Local pointer to current URB we are working.
    PURB    previousUrb;                        //Local pointer to the last URB prior to the current one that was not canceled.
    PVOID   endpointHandle = (PVOID) Endpoint;

    //
    //  We need to synchronize.
    //
    ASSERT_DISPATCH_LEVEL();
        
    //
    //  If there are any Urbs in the queue . . .
    //
    if(Endpoint->QueuedUrbCount)
    {
        //
        //  Where the heads and tails are stored
        //  depends on the endpoint type.
        //
        switch(Endpoint->EndpointType)
        {
            case USB_ENDPOINT_TYPE_CONTROL:
                currentUrbP = &DeviceExtension->ControlUrbHeadP;
                tailUrbP = &DeviceExtension->ControlUrbTailP;
                break;
            case USB_ENDPOINT_TYPE_BULK:
                currentUrbP = &DeviceExtension->BulkUrbHeadP;
                tailUrbP = &DeviceExtension->BulkUrbTailP;
                break;
            case USB_ENDPOINT_TYPE_INTERRUPT:
                currentUrbP = &Endpoint->PendingUrbHeadP;
                tailUrbP = &Endpoint->PendingUrbTailP;
                break;
			default:
                //ISOCH endpoint never expected here.
                USB_DBG_ERROR_PRINT(("Unrecognized endpoint type in OHCD_CancelQueuedUrbs"));
                //This is a serious error, continued execution might be feasible.
                return;
        }
        //
        //  Walk queue and remove any URB associated with Endpoint
        //
        do
        {
            currentUrb = *currentUrbP;
            ASSERT(currentUrb); //A serious coding error if we hit this.
            //
            //  If the URB belongs to this endpoint cancel it.
            //
            if(currentUrb->CommonTransfer.EndpointHandle == endpointHandle)
            {
                //
                //  Whoever was pointing at this urb, should now point to whoever
                //  this urb is pointing to.
                //
                *currentUrbP = currentUrb->CommonTransfer.Hca.HcdUrbLink;
                //
                //  Cancel the Urb
                //
                currentUrb->Header.Status = USBD_STATUS_CANCELED;
                Endpoint->QueuedUrbCount--;
                USBD_CompleteRequest(currentUrb);
            }
            //
            //  Otherwise skip the urb.
            //
            else
            {
                //
                //  This urb is now the official pointer to the next current URB.
                //  Since we didn't cancel it, it also the new previousUrb.
                //
                previousUrb = currentUrb;
                currentUrbP = &currentUrb->CommonTransfer.Hca.HcdUrbLink;
            }
        }while(*tailUrbP != currentUrb);
        //
        //  The official pointer to the tail URB, should now
        //  point to the last URB we didn't cancel.
        //
        *tailUrbP = previousUrb;
        //
        //  That should have dequeued every urb associated with the endpoint.
        //
        ASSERT(0 == Endpoint->QueuedUrbCount);
    }
}

VOID
FASTCALL
OHCD_fPauseEndpoint(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT  Endpoint
    )
/*++

 Routine Description:

    This routines makes sure that endpoint gets paused if it is not already.

Arguments:

   DeviceExtension      - DeviceExtension for this USB controller.

   Endpoint             - Endpoint to pause.

Return Value:

    None

--*/
{
    
    USB_DBG_ENTRY_PRINT(("Entering OHCD_PauseEndpoint"));
    
    ASSERT_DISPATCH_LEVEL();
    
    //
    // We reference count pauses
    //
    Endpoint->PendingPauseCount++;
    //
    //  If a pause is not already in progess,
    //  then pause it.
    if(!(Endpoint->Flags & OHCD_ENDPOINT_FLAG_PAUSING))
    {
        //
        //  Set the Skip bit
        //
        Endpoint->HcEndpointDescriptor.Control.Skip = TRUE;
        //
        //  Set the frame that we need to wait for.
        //
        Endpoint->PauseFrame = OHCD_Get32BitFrameNumber(DeviceExtension) + 1;
        
        //
        // Decide if we need to set the delay pause flag,
        // if are called between an interrupt and the DPC
        // to handle that interupt.  THIS MUST BE AFTER SETTING
        // THE SKIP BIT. The call to OHCD_Get32BitFrameNumber
        // should ensure that the compiler doesn't reorder this.
        //
        if(DeviceExtension->IsrDpc_Context.InterruptsSignaled)
        {
            Endpoint->Flags |= OHCD_ENDPOINT_FLAG_DELAY_PAUSE;
        }

        //
        //  Clear the status indicator for StartOfFrame.
        //
        WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcInterruptStatus, HCINT_StartOfFrame);
        //
        //  Enable the StartOfFrame interrupt
        //
        WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcInterruptEnable, HCINT_StartOfFrame);
        //
        //  Set the OHCD_ENDPOINT_FLAG_PAUSING_FLAG;
        //
        Endpoint->Flags |= OHCD_ENDPOINT_FLAG_PAUSING;
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_PauseEndpoint"));
}


VOID
OHCD_ShutDown(
    PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration
    )
/*++
    Routine Description: 
        Called by the HAL in order to do a quick reboot.  Basically,
        our job is to shut off the host controller, so that no extraneous
        calls happen during shutdown.
    Arguments:
        ShutdownRegistration - Shutdown registration that we passed to 
            HalRegisterShutdown.  We can use CONTAINING_RECORD to
            our device extension.
--*/
{
    POHCD_DEVICE_EXTENSION deviceExtension;
    KIRQL oldIrql;
    
    deviceExtension = CONTAINING_RECORD(
                            ShutdownRegistration,
                            OHCD_DEVICE_EXTENSION,
                            ShutdownRegistration
                            );

    KeRaiseIrql((KIRQL)OHCD_InterruptObject[deviceExtension->HostControllerNumber].Irql, &oldIrql);

    //
    //  Disable all interrupts
    //
    WRITE_REGISTER_ULONG(
        &deviceExtension->OperationalRegisters->HcInterruptDisable,
        HCINT_SchedulingOverrun |
        HCINT_WritebackDoneHead |
        HCINT_UnrecoverableError |
        HCINT_FrameNumberOverflow |
        HCINT_MasterInterruptEnable
       );

    //
    //  Reset the Host Controller
    //
    WRITE_REGISTER_ULONG(
        &deviceExtension->OperationalRegisters->HcControl.ul,
        HC_CONTROL_REGISTER_STOP
        );

    KeLowerIrql(oldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\isoch.h ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    isoch.h

Abstract:

    This file contains Macros and Declaration need
    for Isochronous support.  Since USBD can be compiled
    with or without isoch support there are two
    versions of every macro.

Environment:

    Designed for XBOX.

Notes:

Revision History:

    06-29-00 created by Mitchell Dernis (mitchd)

--*/
#ifndef __ISOCH_H__
#define __ISOCH_H__


#ifdef  OHCD_ISOCHRONOUS_SUPPORTED

//
//  Forward declaration of pointer types.
//
typedef struct _OHCD_ISOCH_ENDPOINT             *POHCD_ISOCH_ENDPOINT;
typedef struct _OHCD_ISOCH_TRANSFER_DESCRIPTOR  *POHCD_ISOCH_TRANSFER_DESCRIPTOR;
typedef struct _OHCD_ISOCH_TRANSFER_DESCRIPTOR
{
    OHCI_ISOCHRONOUS_TRANSFER_DESCRIPTOR  IsochTransferDescriptor;
    POHCD_ISOCH_ENDPOINT                  Endpoint;
    PFNUSBD_ISOCH_TRANSFER_COMPLETE       TransferComplete;
    PVOID                                 Context;
    UCHAR                                 TdIndex;
    UCHAR                                 TdIndexPrev;
    USHORT                                Pad;
    USHORT                                Offsets[8];
} OHCD_ISOCH_TRANSFER_DESCRIPTOR;

typedef struct _OHCD_ISOCH_ENDPOINT
{
    //
    //  OHCI mandated portion of endpoint.  This structure
    //  must start on a paragraph(16-byte) boundary.
    //
    OHCI_ENDPOINT_DESCRIPTOR    HcEndpointDescriptor;
    //
    //  Fields for managing the schedule (especially for interrupt)
    //
    UCHAR                       Flags;                  //Endpoint flags
    UCHAR                       EndpointType;           //Type of endpoint
    UCHAR                       ScheduleIndex;          //Index in schedule - see definitions above
    UCHAR                       PollingInterval;        //Maximum polling interval (in ms)
    
    ULONG                       PhysicalAddress;        //Physical address of this structure.
    POHCD_ENDPOINT              Next;                   //Next endpoint in schedule

    ULONG                       PauseFrame;             //Used to verify that we have waited at least

    UCHAR                       PendingPauseCount;      //Number of reasons that we are paused.
    UCHAR                       Padding;                //Padding to keep up DWORD alignement.
    USHORT                      Bandwidth;              //Bandwidth required by this endpoint (interrupt and isoch only)
    
    //
    //  Above here must be identical to OHCD_ENDPOINT so that the schedule routines work,
    //  and part of the close routines.
    //
    UCHAR                       MaxAttachedBuffers;
    UCHAR                       AttachedBuffers;

    UCHAR                       NextFreeTD;
    UCHAR                       Alignment;

    ULONG                           NextUnusedFrame;
    POHCD_ISOCH_TRANSFER_DESCRIPTOR TransferDescriptors;
} OHCD_ISOCH_ENDPOINT;

#define OHCD_ISOCH_EDFL_CIRCULAR_DMA 0x01
#define OHCD_ISOCH_EDFL_TRANSFERING  0x02
#define OHCD_ISOCH_EDFL_STOPPING     0x04
#define OHCD_ISOCH_EDFL_PAUSING      OHCD_ENDPOINT_FLAG_PAUSING

//
//  Isochronous function definitions
//
USBD_STATUS
FASTCALL
OHCD_fIsochOpenEndpoint(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fIsochCloseEndpoint(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fIsochAttachBuffer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fIsochStartTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fIsochStopTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

VOID
FASTCALL
OHCD_fIsochProcessTD(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_TRANSFER_DESCRIPTOR TransferDescriptor
    );

VOID
FASTCALL
OHCD_fIsochCompleteCloseEndpoint
    (
    IN POHCD_DEVICE_EXTENSION       DeviceExtension,
    IN PURB_ISOCH_CLOSE_ENDPOINT    Urb
    );

//
//  Macros used outside of isoch.c that require stub definitions.
//
#define OHCD_ISOCH_OPEN_ENDPOINT(DeviceExtension, Urb)\
           OHCD_fIsochOpenEndpoint(DeviceExtension, Urb)

#define OHCD_ISOCH_CLOSE_ENDPOINT(DeviceExtension, Urb)\
           OHCD_fIsochCloseEndpoint(DeviceExtension, Urb)

#define OHCD_ISOCH_ATTACH_BUFFERS(DeviceExtension, Urb)\
           OHCD_fIsochAttachBuffer(DeviceExtension, Urb)

#define OHCD_ISOCH_START_TRANSFER(DeviceExtension, Urb)\
           OHCD_fIsochStartTransfer(DeviceExtension, Urb)

#define OHCD_ISOCH_STOP_TRANSFER(DeviceExtension, Urb)\
           OHCD_fIsochStopTransfer(DeviceExtension, Urb)

//
//  The format bit should be clear for non-isoch transfers.
//  In non-isoch builds it doesn't really matter.  However,
//  the non-isoch checked build does some testing to make sure
//  that it is always cleared when it should be.
//
#define OHCD_CLEAR_TD_ISOCH_FORMAT_BIT(TD)\
          TD->HcTransferDescriptor.Format = 0;
#define OHCD_IS_ISOCH_TD(TD)\
           (TD->HcTransferDescriptor.Format)
#define OHCD_PROCESS_ISOCHRONOUS_TD(DeviceExtension, TD)\
           OHCD_fIsochProcessTD(DeviceExtension, TD)
#define OHCD_IS_ISOCH_CLOSE(urb)\
           (URB_FUNCTION_ISOCH_CLOSE_ENDPOINT == urb->Hdr.Function)
#define OHCD_ISOCH_COMPLETE_CLOSE_ENDPOINT(DeviceExtension, Urb)\
            OHCD_fIsochCompleteCloseEndpoint(DeviceExtension, Urb)
#define HC_CONTROL_ISOCH_ENABLE_STATE   0x00000008

#define OHCD_ISOCH_ENDPOINT_SIZE(MaxAttachedBuffers)\
    (sizeof(OHCD_ISOCH_ENDPOINT) +\
     MaxAttachedBuffers*sizeof(OHCD_ISOCH_TRANSFER_DESCRIPTOR))
#define OHCD_ISOCH_POOL ULONG_PTR IsochFreeEndpoints; ULONG IsochMaxBuffers;

#else

/*
**  DEFINITIONS WHEN COMPILED WITHOUT ISOCHRONOUS
**  AND CHECKED OR FREE DOESN'T MATTER
*/
#define HC_CONTROL_ISOCH_ENABLE_STATE   0
#define OHCD_IS_ISOCH_CLOSE(urb) (FALSE)
#define OHCD_ISOCH_COMPLETE_CLOSE_ENDPOINT(DeviceExtension, Urb)
#define OHCD_ISOCH_ENDPOINT_SIZE(MaxAttachedBuffers) 0
#define OHCD_ISOCH_FREE_ENDPOINTS

#if DBG
/*
**  DEFINITIONS WHEN COMPILED WITHOUT
**  ISOCHRONOUS SUPPORT AND CHECKED BUILD
**  In the checked build, some macros spew debug information
**  and/or break into the debugger if they are hit.
*/  

//
//  Stub for Isochronous Support Error.
//
__inline USBD_STATUS OHCD_ErrorNoIsochSupport()
{
    DbgPrint("ERROR: THIS VERSION OF USBD.SYS WAS BUILT WITHOUT SUPPORT FOR USING ISOCHRONOUS DEVICES.\n");
    DbgPrint("ERROR: THIS ERROR SHOULD NOT BE HIT MERELY BECAUSE AN ISOCHRONOUS DEVICE IS PLUGGED IN,\n");
    DbgPrint("ERROR: BUT ONLY IF A CLASS DRIVER FOR THE DEVICE IS PRESENT AND IF AN OPEN ON THE DEVICE\n");
    DbgPrint("ERROR: IS ATTEMPTED.\n");
    DbgBreakPoint();
    return USBD_STATUS_ISOCH_NOT_SUPPORTED;
}

//
//  Macros definitons
//  

#define OHCD_ISOCH_OPEN_ENDPOINT(DeviceExtension, Urb)\
                                OHCD_ErrorNoIsochSupport()

#define OHCD_ISOCH_CLOSE_ENDPOINT(DeviceExtension, Urb)\
                                OHCD_ErrorNoIsochSupport()

#define OHCD_ISOCH_ATTACH_BUFFERS(DeviceExtension, Urb)\
                                OHCD_ErrorNoIsochSupport()

#define OHCD_ISOCH_START_TRANSFER(DeviceExtension, Urb)\
                                OHCD_ErrorNoIsochSupport()

#define OHCD_ISOCH_STOP_TRANSFER(DeviceExtension, Urb)\
                                OHCD_ErrorNoIsochSupport()

//
//  Even though isochronous support is off, we keep track of the Format bit like in
//  an isoch build.  If OHCD_PROCESS_ISOCHRONOUS_TD is ever hit as a result,
//  it errors out and then calls OHCD_ProcessDoneTD, like it should anyway.
//  This should help find problems with how the format bit is being used, and may
//  reveal problems that would be hard to find or solve in the builds with isoch support.
//
#define OHCD_CLEAR_TD_ISOCH_FORMAT_BIT(TD) TD->HcTransferDescriptor.Format = 0;
#define OHCD_IS_ISOCH_TD(TD) (TD->HcTransferDescriptor.Format)
#define OHCD_PROCESS_ISOCHRONOUS_TD(deviceExtension, tempTD)\
{\
    DbgPrint("ERROR: Found TD with Format bit set in a build that does not support Isochronous transfers.\n");\
    DbgPrint("ERROR: This indicates that the format bit is not being cleared properly for non-isoch transfers.\n");\
    DbgPrint("ERROR: Hitting this suggests that builds which do support isochronous transfers may have undetected errors.\n");\
    DbgPrint("ERROR: If you hit 'g' in the debugger, it will handle this properly as a non-isoch TD.\n");\
    DbgBreakPoint();\
    OHCD_fProcessDoneTD(deviceExtension, tempTD);\
}

/*
**  DEFINITIONS WHEN COMPILED WITHOUT
**  ISOCHRONOUS SUPPORT AND FREE BUILD
**
**  In the free build, we do not spew debug information.  Macros that shouldn't
**  be hit simply return an ERROR.
*/
#else //DBG!=1

#define OHCD_ISOCH_OPEN_ENDPOINT(DeviceExtension, Urb) USBD_STATUS_ISOCH_NOT_SUPPORTED

#define OHCD_ISOCH_CLOSE_ENDPOINT(DeviceExtension, Urb) USBD_STATUS_ISOCH_NOT_SUPPORTED

#define OHCD_ISOCH_ATTACH_BUFFERS(DeviceExtension, Urb) USBD_STATUS_ISOCH_NOT_SUPPORTED

#define OHCD_ISOCH_START_TRANSFER(DeviceExtension, Urb) USBD_STATUS_ISOCH_NOT_SUPPORTED

#define OHCD_ISOCH_STOP_TRANSFER(DeviceExtension, Urb) USBD_STATUS_ISOCH_NOT_SUPPORTED


#define OHCD_CLEAR_TD_ISOCH_FORMAT_BIT(TD) //NOP, not necessary to clear the bit, if isoch not supported.
#define OHCD_IS_ISOCH_TD(TD) (FALSE)       //We don't care.
#define OHCD_PROCESS_ISOCHRONOUS_TD(deviceExtension, tempTD) //Should never be hit

#endif //end of else DBG!=1
#endif //end of else clause for ifdef OHCD_ISOCHRONOUS_SUPPORTED
#endif //__ISOCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\ohcd.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.


Module Name:

    ohcd.h

Abstract:

    Structures used by the OpenHCI hardware dependent driver.
    These are constructs specific to this driver implementation.
    Standard Structures defined by Specification are in ohci.h
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-14-00 created by Mitchell Dernis (mitchd)

--*/
#ifndef __OCHD_H__
#define __OCHD_H__

//
//  Pull in the hardware spec stuff
//
#include "ohci.h"

//
//  forward declaration of pointer types, easy access later.
//
typedef struct _OHCD_TRANSFER_DESCRIPTOR        *POHCD_TRANSFER_DESCRIPTOR;
typedef struct _OHCD_SETUP_BUFFER               *POHCD_SETUP_BUFFER;
typedef struct _OHCD_ENDPOINT                   *POHCD_ENDPOINT;
typedef struct _OHCD_POOL                       *POHCD_POOL;
typedef struct _OHCD_INTERRUPT_SCHEDULE_NODE    *POHCD_INTERRUPT_SCHEDULE_NODE;
typedef struct _OHCD_ENDPOINT_SCHEDULE          *POHCD_ENDPOINT_SCHEDULE;
typedef struct _OHCD_DEVICE_EXTENSION           *POHCD_DEVICE_EXTENSION;


//
//  READ_REGISTER_ULONG and WRITE_REGISTER_ULONG are no longer
//  support in the Xbox Kernel.  Registers must be mapped to 
//  noncached memory.  Define macros here that simply do
//  a C assignement.
//
#define WRITE_REGISTER_ULONG(preg,value)  (*((volatile ULONG *)(preg))=value)
#define READ_REGISTER_ULONG(preg)  (*((volatile ULONG *)(preg)))

//
// struct OHCD_TRANSFER_DESCRIPTOR
//
//  This is the transfer descriptor as seen by the OHCD driver.
//  It is padded with 16 bytes of driver related fields.
//  Followed by the OHCI defined structure.
//
typedef struct _OHCD_TRANSFER_DESCRIPTOR
{
    //
    //  OHCI defined structure
    //
    OHCI_TRANSFER_DESCRIPTOR    HcTransferDescriptor;

    //
    //  16 bytes of Extra driver related fields
    //
    ULONG                       PhysicalAddress;        //Physical address of this descriptor
    union{
    POHCD_TRANSFER_DESCRIPTOR   NextFree;               //Used when the block is on the free list.
    POHCD_ENDPOINT              Endpoint;               //Endpoint which executed this transfer
    };
    PURB                        Urb;                    //Urb we are connected to
    UCHAR                       Flags;                  //Various flags
    UCHAR                       Bytes;                  //Various flags
    UCHAR                       Type;                   //Type of TD
    UCHAR                       HostControllerNumber;   //0xFF when not in use.
} OHCD_TRANSFER_DESCRIPTOR;

#define OHCD_TD_FLAG_CANCEL_PENDING 0x00000001  //TD has been marked for cancel
#define OHCD_TD_FLAG_LAST_TD        0x00000002  //Last TD of an URB

#define OHCD_TD_TYPE_DATA           0   //Setup TD of control transfer
#define OHCD_TD_TYPE_SETUP          1   //Setup TD of control transfer
#define OHCD_TD_TYPE_STATUS         2   //Status TD of control transfer
#define OHCD_TD_TYPE_DUMMY          3   //Dummy TD of control transfer


//
//  Flags used for the HcdUrbFlags found in the HCD area
//  of asynchronous transfer URBS.  These flags are used
//  for tracking the state of an URB so that it can be
//  cancelled.
//
#define OHCD_URB_FLAG_CANCELED      0x0001
#define OHCD_URB_FLAG_QUEUED        0x0002
#define OHCD_URB_FLAG_PROGRAMMED    0x0004
#define OHCD_URB_FLAG_COMPLETED     0x0008
//  Flags for isoch use are defined in isoch.h
//  This mask just claims the bits.
#define OHCD_URB_FLAG_ISOCH_USE     0x0F00


//
// struct OHCD_SETUP_STATUS_BUFFER
//
//  This structure is used for control transfers
//  to hold the setup packet data.  We define it as a type of
//  descriptor block so that we can leverage
//  the same code used for EDs and TDs
//  
typedef struct _OHCD_SETUP_BUFFER
{
    UCHAR                   Setup[8];       //Holds the data for a setup packet
    ULONG                   Pad1[2];        //Padding to keep the structure the correct size
                                            
    //
    //  Standard driver dependent part of block
    //
    ULONG                   PhysicalAddress;        //Physical address of this block
    ULONG                   Pad2[3];                //Pad to 32 bytes
} OHCD_SETUP_BUFFER;

//
//  Interrupt Node - see schedule.c for overview
//
typedef struct _OHCD_INTERRUPT_SCHEDULE_NODE
{
    BOOLEAN         RegisterHead;
    UCHAR           Pad;
    USHORT          Bandwidth;
    USHORT          BandwidthChildren;
    USHORT          BandwidthParents;
    POHCD_ENDPOINT  EndpointHead;
    POHCD_ENDPOINT  EndpointTail;
} OHCD_INTERRUPT_SCHEDULE_NODE;


//
//  Endpoint schedule - see schedule.c for overview
//
typedef struct _OHCD_ENDPOINT_SCHEDULE
{
    OHCD_INTERRUPT_SCHEDULE_NODE InterruptSchedule[64];
    POHCD_ENDPOINT               ControlHead;
    POHCD_ENDPOINT               BulkHead;
    USHORT                       BandwidthPeriodic;
    USHORT                       BandwidthTotal;                         
} OHCD_ENDPOINT_SCHEDULE;


//
//  Endpoint.   Due to the first member this structure must start on a 16-byte boundary.
//
typedef struct _OHCD_ENDPOINT
{
    //
    //  OHCI mandated portion of endpoint.  This structure
    //  must start on a paragraph(16-byte) boundary.
    //
    OHCI_ENDPOINT_DESCRIPTOR    HcEndpointDescriptor;
    //
    //  Fields for managing the schedule (especially for interrupt)
    //
    UCHAR                       Flags;                  //Endpoint flags
    UCHAR                       EndpointType;           //Type of endpoint
    UCHAR                       ScheduleIndex;          //Index in schedule - see definitions above
    UCHAR                       PollingInterval;        //Maximum polling interval (in ms)
    
    ULONG                       PhysicalAddress;        //Physical address of this structure.
    POHCD_ENDPOINT              Next;                   //Next endpoint in schedule

    ULONG                       PauseFrame;             //Used to verify that we have waited at least

    UCHAR                       PendingPauseCount;      //Number of reasons that we are paused.
    UCHAR                       Padding;                //Padding to keep up DWORD alignement.
    USHORT                      Bandwidth;              //Bandwidth required by this endpoint (interrupt and isoch only)
    
    USHORT                      TDInUseCount;           //Count of TDs in use.
    UCHAR                       QueuedUrbCount;         //Count of URBs that are queued waiting to be programmed.
    UCHAR                       ProgrammedUrbCount;     //Count URBs that are currently programmed.
    
    //
    //  Fields for managing URBs and keeping track of transfers
    //
    PURB                        PendingUrbHeadP;
    PURB                        PendingUrbTailP;
    
} OHCD_ENDPOINT;


#define OHCD_ENDPOINT_FLAG_CLOSING      0x10        //Flag used to indicate that endpoint is being
                                                    //closed, block cancels when endpoint is closing
#define OHCD_ENDPOINT_FLAG_PAUSING      0x20        //Flag used so that we don't try
                                                    //to pause the endpoint twice.
#define OHCD_ENDPOINT_FLAG_DELAY_PAUSE  0x40        //Indicates that the endpoint should not be considered
                                                    //paused until the next interrupt, set by the pause
                                                    //routine if a DPC was already queued.

typedef struct _OHCD_ROOT_HUB_OBJECT
{
    UCHAR                   NumberOfPorts;              //Number of ports present on the root hub.
    UCHAR                   DeviceDetectedBitmap;       //Bitmap of ports which have a detected device
    LARGE_INTEGER           PowerOnToGoodTime;          //PowerOnToGoodTime in relative 100ns intervals
    PFNHCD_RESET_COMPLETE   ResetComplete;              //Completion Routine.
    PVOID                   ResetContext;               //Completion Context.
    KTIMER                  ResetTimeoutTimer;          //Timer in case reset times out.
    KDPC                    ResetTimeoutDPC;            //DPC to be called if reset time-out occurs.
} OHCD_ROOT_HUB_OBJECT, *POHCD_ROOT_HUB_OBJECT;

VOID
HCD_ResetRootHubPort(
    IN PVOID                    HcdDeviceExtension,
    IN ULONG                    PortNumber,
    IN PFNHCD_RESET_COMPLETE    ResetCompleteProc,
    IN PVOID                    CompleteContext
    );


typedef struct _OHCD_DEVICE_EXTENSION
{
    
    POHCI_OPERATIONAL_REGISTERS OperationalRegisters;       //Port address of operational registers
    ULONG                       OperationalRegistersLength; //May vary depending on downstream port count
    POHCI_HCCA                  HCCA;                       //HCD accessable pointer to HCCA
    OHCD_ENDPOINT_SCHEDULE      Schedule;                   //Everything we need to know about the schedule
    ULONG                       FrameHighPart;              //The high part of a 32-bit frame counter.
                                                            //The hardware only keeps 16 bits.
    PURB                        ControlUrbHeadP;            //Head of URBs for control transfers
    PURB                        ControlUrbTailP;            //Tail of URBs for control transfers
    PURB                        BulkUrbHeadP;               //Head of URBs for bulk transfers
    PURB                        BulkUrbTailP;               //Tail of URBs for bulk transfers
    PURB                        PendingCancels;             //URBs that need to be canceled.
    PURB                        PendingAborts;              //URBs that need to be aborted.
    PURB                        PendingCloses;              //URBs representing pending closes.
    struct
    {  /* A context structure between Isr and Dpc */
      ULONG InterruptsSignaled;     //Bit field of interrupt conditions signaled
      ULONG Frame;                  //The frame number when the interrupt occured
    } IsrDpc_Context;
    KDPC                        IsrDpc;                     //DPC for the ISR
    ULONG                       HostControllerNumber;       //Host Controller Number - really only a byte
    OHCD_ROOT_HUB_OBJECT        RootHubObject;              //Everything the root hub needs to know
    HAL_SHUTDOWN_REGISTRATION   ShutdownRegistration;
} OHCD_DEVICE_EXTENSION;

//
//  WorkItem Payload for Hotplug items.
//
typedef struct _OHCD_PORT_INFO
{
    USHORT                  PortsConnectionChanged;     //Bitfield of ports whose connection status needs updating
    USHORT                  PortsConnected;             //Bitfield of ports that now show connected status
} OHCD_PORT_INFO, *POHCD_PORT_INFO;


//---------------------------------------------------------------------------------------------------------------
// Choose max controller based on the number of controllers
//---------------------------------------------------------------------------------------------------------------
#define HCD_MAX_HOST_CONTROLLERS 1
#if (USB_HOST_CONTROLLER_CONFIGURATION!=USB_SINGLE_HOST_CONTROLLER)
#undef  HCD_MAX_HOST_CONTROLLERS
#define HCD_MAX_HOST_CONTROLLERS 2
#endif

//------------------------------------------------------
//  Pull in Isochronous Support (or stubs)
//------------------------------------------------------
#include "isoch.h"

//------------------------------------------------------
//  Implemented in OHCD.C
//------------------------------------------------------
VOID
FASTCALL
OHCD_fPauseEndpoint(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT  endpoint
    );
//--------------------------------------------------------
// Implemented in Schedule.c
//--------------------------------------------------------
VOID
FASTCALL
OHCD_ScheduleInitialize(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    );

USBD_STATUS
FASTCALL
OHCD_ScheduleAddEndpointPeriodic(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_ENDPOINT Endpoint
    );

VOID
FASTCALL
OHCD_ScheduleRemoveEndpointPeriodic(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_ENDPOINT Endpoint
    );

VOID
FASTCALL
OHCD_ScheduleAddEndpointControlOrBulk(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_ENDPOINT Endpoint
    );

VOID
FASTCALL
OHCD_ScheduleRemoveEndpointControlOrBulk(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    IN POHCD_ENDPOINT Endpoint
    );

//------------------------------------------------------------
// Implemented in Isr.c
//------------------------------------------------------------

BOOLEAN
OHCD_InterruptService( 
    IN PKINTERRUPT Interrupt, 
    IN PVOID ServiceContext 
    );

VOID
OHCD_IsrDpc(
    PKDPC Dpc,
    PVOID DeviceExtensionPtr,
    PVOID Bogus1,
    PVOID Bogus2
    );

ULONG
FASTCALL
OHCD_Get32BitFrameNumber(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    );

//------------------------------------------------------------
// Implemented in transfer.c
//------------------------------------------------------------
USBD_STATUS
FASTCALL
OHCD_fQueueTransferRequest(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    PURB                    HcdUrb
    );

VOID
FASTCALL
OHCD_fProgramInterruptTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    POHCD_ENDPOINT          Endpoint
    );

VOID
FASTCALL
OHCD_fProgramBulkTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension
    );

VOID
FASTCALL
OHCD_fProgramControlTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension
    );

//------------------------------------------------------------
// Implemented in roothub.c
//------------------------------------------------------------
VOID
FASTCALL
OHCD_RootHubInitialize(
    POHCD_DEVICE_EXTENSION  DeviceExtension
    );
VOID
FASTCALL
OHCD_RootHubProcessInterrupt(
    POHCD_DEVICE_EXTENSION      DeviceExtension
);

VOID
FASTCALL
OHCD_RootHubProcessHotPlug(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_PORT_INFO          PortInfo
);

//------------------------------------------------------
//  Implemented in pool.c
//------------------------------------------------------

//
//  struct OHCD_POOL - Global structure pool for
//                     all DMA managed structures
//
typedef struct _OHCD_POOL
{
    
    ULONG                       VirtualToPhysical;
    POHCI_HCCA                  Hcca[HCD_MAX_HOST_CONTROLLERS];
    POHCD_ENDPOINT              FreeEndpoints;
    POHCD_TRANSFER_DESCRIPTOR   FreeTDs;
    POHCD_TRANSFER_DESCRIPTOR   FirstTD;                   //First TD in pool
    POHCD_TRANSFER_DESCRIPTOR   LastTD;                    //Last TD in pool
    ULONG                       LostDoneHeadCount;         //Number of times the DoneHead was lost.
    ULONG                       LostMinimumDoneListLength; //minimum length of the DoneHead when
                                                           //it was lost
    USHORT                      ControlQuota;
    USHORT                      ControlQuotaRemaining;
    USHORT                      BulkQuota;
    USHORT                      BulkQuotaRemaining;
    OHCD_ISOCH_POOL
} OHCD_POOL;
extern OHCD_POOL OHCD_GlobalPool;
#define OHCD_INTERRUPT_TD_QUOTA  3 //Per endpoint quota

VOID
FASTCALL
OHCD_fPoolInit(
    IN PHCD_RESOURCE_REQUIREMENTS pResourceRequirements
    );

#ifdef SILVER
ULONG
FASTCALL
OHCD_fPoolFindLostDoneHead(
    POHCD_DEVICE_EXTENSION DeviceExtension
    );
#endif //SILVER

__inline
POHCI_HCCA
OHCD_PoolGetHcca(
    IN UCHAR HostControllerNumber
    )
{
    ASSERT(HCD_MAX_HOST_CONTROLLERS > HostControllerNumber);
    return OHCD_GlobalPool.Hcca[HostControllerNumber];
}

__inline
POHCD_ENDPOINT
OHCD_PoolAllocateEndpoint()
{
    POHCD_ENDPOINT retVal;
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    retVal = OHCD_GlobalPool.FreeEndpoints;
    if(retVal)
    {
        OHCD_GlobalPool.FreeEndpoints = retVal->Next;
    }
    ASSERT(retVal);
    return retVal;
}

__inline
VOID
OHCD_PoolFreeEndpoint(POHCD_ENDPOINT Endpoint)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    Endpoint->Next = OHCD_GlobalPool.FreeEndpoints;
    OHCD_GlobalPool.FreeEndpoints = Endpoint;
}


__inline
POHCD_TRANSFER_DESCRIPTOR
OHCD_PoolAllocateTD(UCHAR HostControllerNumber)
{
    POHCD_TRANSFER_DESCRIPTOR retVal;
    retVal = OHCD_GlobalPool.FreeTDs;
    if(retVal)
    {
        OHCD_GlobalPool.FreeTDs = retVal->NextFree;
    }
    ASSERT(retVal);
    retVal->HostControllerNumber = HostControllerNumber;
    OHCD_CLEAR_TD_ISOCH_FORMAT_BIT(retVal);
    return retVal;
}

__inline
VOID
OHCD_PoolFreeTD(
    IN  POHCD_TRANSFER_DESCRIPTOR   TransferDescriptor
    )
{
    // We want the hardware NextTD to be an invalid
    // non-NULL address.  This aids in searching for
    // lost TD lists.
    TransferDescriptor->HcTransferDescriptor.NextTD = 0xFFFFFFFF;
    TransferDescriptor->HostControllerNumber  = 0xFF;
    TransferDescriptor->NextFree = OHCD_GlobalPool.FreeTDs;
    OHCD_GlobalPool.FreeTDs = TransferDescriptor;
}

__inline
POHCD_TRANSFER_DESCRIPTOR
OHCD_PoolTDFromPhysicalAddress(
    IN  ULONG           PhysicalAddress
    )
{
    return (POHCD_TRANSFER_DESCRIPTOR)(OHCD_GlobalPool.VirtualToPhysical + PhysicalAddress);
}

__inline
ULONG
OHCD_PoolGetPhysicalAddress(PVOID VirtualAddress)
{
    return ((ULONG)VirtualAddress) - OHCD_GlobalPool.VirtualToPhysical;
}

__inline
USHORT
OHCD_PoolGetControlQuota()
{ return OHCD_GlobalPool.ControlQuota; }

__inline
BOOLEAN
OHCD_PoolDebitControlTDQuota(
    IN USHORT Count
    )
{
    return
        (OHCD_GlobalPool.ControlQuotaRemaining < Count) ?
            FALSE :
            (OHCD_GlobalPool.ControlQuotaRemaining -= Count, TRUE);
}

__inline
VOID
OHCD_PoolCreditControlTDQuota(
    IN USHORT Count
    )
{
    OHCD_GlobalPool.ControlQuotaRemaining += Count;
}

__inline
USHORT
OHCD_PoolGetBulkQuota()
{ return OHCD_GlobalPool.BulkQuota; }

__inline
BOOLEAN
OHCD_PoolDebitBulkTDQuota(
    IN USHORT Count
    )
{
    return
        (OHCD_GlobalPool.BulkQuotaRemaining < Count) ?
            FALSE :
            (OHCD_GlobalPool.BulkQuotaRemaining -= Count, TRUE);
}

__inline
VOID
OHCD_PoolCreditBulkTDQuota(
    IN USHORT Count
    )
{
    OHCD_GlobalPool.BulkQuotaRemaining += Count;
}

#ifdef DVTSNOOPBUG
VOID OHCD_PoolCreateDoubleBufferPool();
VOID OHCD_PoolStartDoubleBufferTransfer(PURB Urb);
VOID OHCD_PoolEndDoubleBufferTransfer(PURB Urb);
#endif

//Isoch routines are conditionally compiled
#ifdef  OHCD_ISOCHRONOUS_SUPPORTED
__inline
ULONG_PTR
OHCD_IsochPoolAllocateEndpoint()
{
    ULONG_PTR retVal;
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    retVal = OHCD_GlobalPool.IsochFreeEndpoints;
    if(retVal)
    {
        OHCD_GlobalPool.IsochFreeEndpoints = *((PULONG_PTR)retVal);
    }
    ASSERT(retVal);
    return retVal;
}

__inline
VOID
OHCD_IsochPoolFreeEndpoint(ULONG_PTR IsochEndpoint)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    *((PULONG_PTR)IsochEndpoint) = OHCD_GlobalPool.IsochFreeEndpoints;
    OHCD_GlobalPool.IsochFreeEndpoints = IsochEndpoint;
}

__inline
ULONG OHCD_IsochPoolGetMaxBuffers()
{
    return OHCD_GlobalPool.IsochMaxBuffers;
}

#endif //OHCD_ISOCHRONOUS_SUPPORTED


#endif __OCHD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\pool.c ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    pool.c

Abstract:
    
    Implementation of transfer descriptor pool manager.


    OHCI implements a multi-plexed DMA scheme.  Rather than having a number of fixed registers for
    programming DMA.  The host controller and the host controller driver share a common data structure.
    This structure must be locked down in physical memory at all times.

    The structure is a linked list of queues.  The head of each queue is referred to as an Endpoint Descriptor
    (Not to be confused to the endpoint descriptor in the USB specification, which is a different entity
    entirely.)  Each endpoint descriptor points to the head and tail of singly linked list of Transfer Descriptors.
    Each TD describes the user buffer for transfering a single packet of data across the USB wire.  The host controller
    walks through this schedule and pulls of transfer descriptors one at a time.  It performs the transfer (or records
    an error).  Then it places the TD on a DoneHead and moves on to the next one.

    Each of these TDs is 16 bytes long as defined by hardware.  However, the software needs additional fields so
    each block is expanded to 32 bytes.
    
    Isochronous Endpoints to not use a TD pool, but instead come as part of the Isochronous part of the URB extension.

    The code in this module allocates two pages of memory.  The first part of the first page is returned for use as the HCCA area.
    The rest is broken into 32 byte blocks.

    01-12-01  Originally, this code allocate memory for the TD's and the HCCA area.  There was a separate
    TD pool for each host controller.  Now there will be one TD pool for both host controllers, plus endpoints
    will also come out of here.  We can do this, because we are moving to an upfront iniitialization of everything.
    We also allocate isochronous endpoints from here.

Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-17-00 created by Mitchell Dernis (mitchd)
    01-12-01 changed name to pool.c (mitchd)

--*/

//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");

//
//  Pull in usb headers
//

#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff

OHCD_POOL OHCD_GlobalPool;

#pragma code_seg(".XPPCINIT")


//------------------------------------------
//  Initialize Pool
//------------------------------------------
VOID
FASTCALL
OHCD_fPoolInit(
    IN PHCD_RESOURCE_REQUIREMENTS pResourceRequirements
    )
{
    ULONG                       poolSize;
    ULONG                       pageCount;
    ULONG_PTR                   poolMemory;
    ULONG_PTR                   poolEnd;
    ULONG                       index;
    ULONG                       isochEndpointSize;
    ULONG                       combinedEndpointSize;
    ULONG                       transferDescriptorsCount;
    POHCD_TRANSFER_DESCRIPTOR   transferDescriptor;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_InitPool."));

    //
    //  Figure out how much memory is needed.
    //
    isochEndpointSize = OHCD_ISOCH_ENDPOINT_SIZE(pResourceRequirements->IsochMaxBuffers);
    combinedEndpointSize = isochEndpointSize+sizeof(OHCD_ENDPOINT);
    ASSERT(0==isochEndpointSize%16);
    ASSERT(0==(combinedEndpointSize)%32);
    ASSERT(0==sizeof(OHCI_HCCA)%32);
    ASSERT(32==sizeof(OHCD_TRANSFER_DESCRIPTOR));

    if(pResourceRequirements->EndpointCount < pResourceRequirements->IsochEndpointCount)
    {
        pResourceRequirements->EndpointCount = pResourceRequirements->IsochEndpointCount;
    }

    poolSize = sizeof(OHCI_HCCA)*HCD_MAX_HOST_CONTROLLERS +
               pResourceRequirements->IsochEndpointCount*isochEndpointSize +
               pResourceRequirements->EndpointCount * sizeof(OHCD_ENDPOINT) +
               pResourceRequirements->TDCount * sizeof(OHCD_TRANSFER_DESCRIPTOR);

    USB_DBG_TRACE_PRINT(("Required Pool Size = %d bytes.", poolSize));
    //
    //  Figure out how many pages are needed.
    //  (divide by PAGE_SIZE, but make sure that it rounds up, not down)
    //
    pageCount = (poolSize + PAGE_SIZE - 1)/PAGE_SIZE;

    //
    //  Alignment issues may require 16 bytes of dead space
    //  at the end of each page. Make sure we have it just in case.
    if(pageCount*PAGE_SIZE < (pageCount*16+poolSize))
    {
        pageCount++;
    }

    USB_DBG_TRACE_PRINT(("Low-level XPP uses %d pages.", pageCount));
    USB_DBG_TRACE_PRINT(("Max EndpointCount = %d.", pResourceRequirements->EndpointCount));
    USB_DBG_TRACE_PRINT(("Max IsochEndpointCount = %d.", pResourceRequirements->IsochEndpointCount));
    
    //
    //  Allocate PageCount pages of memory.
    //
    poolSize = pageCount*PAGE_SIZE;
#ifdef DVTSNOOPBUG
    OHCD_PoolCreateDoubleBufferPool();
    poolMemory = (ULONG_PTR)MmAllocateContiguousMemoryEx(poolSize, 0, MAXULONG_PTR, 0, PAGE_READWRITE|PAGE_NOCACHE);
    __asm wbinvd; //flush cache
#else
    poolMemory = (ULONG_PTR)MmAllocateContiguousMemory(poolSize);
#endif //DVTSNOOPBUG
   
    RIP_ON_NOT_TRUE_WITH_MESSAGE(poolMemory, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    
    //
    //  Lock it all down.
    //
    MmLockUnlockBufferPages((PVOID)poolMemory, poolSize, FALSE);

    //
    //  Record the difference between the virtual and physical addresses.
    //  (use this for quick conversion.)
    OHCD_GlobalPool.VirtualToPhysical = poolMemory - MmGetPhysicalAddress((PVOID)poolMemory);

    //
    //  Initialize page
    //
    RtlZeroMemory((PVOID)poolMemory, poolSize);

    //**
    //**  Carve up the pool into HCCA's, isoch endpoints, endpoints, and TDs.
    //**  
    poolEnd = poolMemory + poolSize;
    
    //
    // HCCA
    //
    for(index=0; index < HCD_MAX_HOST_CONTROLLERS; index++)
    {
        OHCD_GlobalPool.Hcca[index] = (POHCI_HCCA)poolMemory;
        poolMemory += sizeof(OHCI_HCCA);
        ASSERT(poolEnd > poolMemory);
    }

    //
    //  OHCD_ISOCH_ENDPOINT
    //  (allocate an OHCD_ENDPOINT with each OHCD_ISOCH_ENDPOINT
    //   to keep the alignment requirements.)
    //
    
    index = 0;  //we want index initialized, outside the conditionally compiled
                //isochronous code.
    OHCD_GlobalPool.FreeEndpoints = NULL;
#ifdef OHCD_ISOCHRONOUS_SUPPORTED
    OHCD_GlobalPool.IsochMaxBuffers = pResourceRequirements->IsochMaxBuffers;
    OHCD_GlobalPool.IsochFreeEndpoints = 0;
    for(; index < pResourceRequirements->IsochEndpointCount; index++)
    {
        // An isoch endpoint is 48 bytes long +
        // an integer multiple of 64 bytes, yet the hardware requires 32 byte alignment.
        // So these cannot be densly packet.  To achieve better packing we intersperse
        // regular endpoints which are 48 bytes long, but require only 16 byte alignment.
    
            
        // allocate an isoch endpoint            
        *((PULONG_PTR)(poolMemory)) = OHCD_GlobalPool.IsochFreeEndpoints;
        OHCD_GlobalPool.IsochFreeEndpoints = (ULONG_PTR)(poolMemory);
        poolMemory += isochEndpointSize;
        ASSERT(poolEnd > poolMemory);
        // allocate an endpoint
        ((POHCD_ENDPOINT)(poolMemory))->Next = OHCD_GlobalPool.FreeEndpoints;
        OHCD_GlobalPool.FreeEndpoints = (POHCD_ENDPOINT)(poolMemory);
        poolMemory += sizeof(OHCD_ENDPOINT);
        ASSERT(poolEnd > poolMemory);
    }
#endif //OHCD_ISOCHRONOUS_SUPPORTED
    
    //
    // OHCD_ENDPOINT - don't reset index, since it already 
    //                 records how many were allocated with
    //                 OHCD_ISOCH_ENDPOINTs.
    //
    for(; index < pResourceRequirements->EndpointCount; index++)
    {
        // allocate an endpoint
        ((POHCD_ENDPOINT)(poolMemory))->Next = OHCD_GlobalPool.FreeEndpoints;
        OHCD_GlobalPool.FreeEndpoints = (POHCD_ENDPOINT)(poolMemory);
        poolMemory += sizeof(OHCD_ENDPOINT);
        ASSERT(poolEnd > poolMemory);
    }

    //
    //  OHCD_TRANSFER_DESCRIPTOR - we can always use extras, so
    //                             allocate until the end of the pool.
    //
    transferDescriptorsCount = 0;
    OHCD_GlobalPool.FreeTDs = NULL;
    OHCD_GlobalPool.FirstTD = (POHCD_TRANSFER_DESCRIPTOR)poolMemory;
    while((poolMemory + sizeof(OHCD_TRANSFER_DESCRIPTOR)) <= poolEnd)
    {
        transferDescriptor = (POHCD_TRANSFER_DESCRIPTOR)poolMemory;
        transferDescriptor->PhysicalAddress = OHCD_PoolGetPhysicalAddress(transferDescriptor);
        OHCD_PoolFreeTD(transferDescriptor);
        poolMemory += sizeof(OHCD_TRANSFER_DESCRIPTOR);
        transferDescriptorsCount++;
    }
    OHCD_GlobalPool.LastTD = transferDescriptor;
    OHCD_GlobalPool.LostDoneHeadCount = 0;
    OHCD_GlobalPool.LostMinimumDoneListLength = 1000; //init to a large value.
    
    //
    //  If this assert fails we under-allocated.  Hitting this is a pretty serious
    //  bug in the pool initialization code.
    //
    ASSERT(transferDescriptorsCount >= pResourceRequirements->TDCount);

    //
    //  Record the quotas in the pool
    //
    OHCD_GlobalPool.ControlQuota = pResourceRequirements->ControlTDQuota;
    OHCD_GlobalPool.BulkQuota = pResourceRequirements->BulkTDQuota;

    //
    //  At this point, the memory should be carved up.
    //  Figure out how many extra TD's we got out of it
    //  and apply it to the TD quotas.  
    //
    if(transferDescriptorsCount > pResourceRequirements->TDCount)
    {
       UCHAR extraTDs = transferDescriptorsCount - pResourceRequirements->TDCount;
       // If there is a bulk quota, apply half of the extra TD's to it.
       if(OHCD_GlobalPool.BulkQuota)
       {
           OHCD_GlobalPool.BulkQuota += extraTDs/2;
           extraTDs -= extraTDs/2;
       }
       // Apply the remaining extra TD's tp the control TD quota
       OHCD_GlobalPool.ControlQuota += extraTDs;
       pResourceRequirements->TDCount = transferDescriptorsCount;
    }
    
    USB_DBG_TRACE_PRINT(("TDCount = %d.", pResourceRequirements->TDCount));
    USB_DBG_TRACE_PRINT(("ControlTDQuota = %d.", OHCD_GlobalPool.ControlQuota));
    USB_DBG_TRACE_PRINT(("BulkTDQuota = %d.", OHCD_GlobalPool.BulkQuota));
    OHCD_GlobalPool.ControlQuotaRemaining = OHCD_GlobalPool.ControlQuota;
    OHCD_GlobalPool.BulkQuotaRemaining = OHCD_GlobalPool.BulkQuota;

    USB_DBG_EXIT_PRINT(("Exiting OHCD_TDPoolInit."));
}

#ifdef SILVER

ULONG
FASTCALL
OHCD_fPoolFindLostDoneHead(
    POHCD_DEVICE_EXTENSION DeviceExtension
    )
/*++
    Routine Description:
        Compaq's original OpenHCI design (code named Hydra) had a serious bug
    where it would sometimes lose the done head.  This flaw was subsequently
    propogated to a number of chips based off that design.  nVidia claims that
    this bug was in the original MCPX design for xbox, but that it was fixed
    even before the first silicon.  In the meantime, we need to support it on
    the pre-DVT development kits using the Opti Chipset, some of which seem
    to suffer from the flaw.

        The code walks the TD pool and figures out which one is the head
    of our missing done list.  The implementation is taken from the Windows 2000
    code base.  However, this code base has one little catch.  A single global
    pool is used for both host controllers  (The first version of MCPX for XBox
    has two controllers.  In fact, launch titles will only use one, but we need
    to support two for the development kits - even after going to DVT - and in 
    the future we may decide to support the second host controller for shipping
    games - who knows).  The solution is to stamp the TD's with the host controller
    number, and erase the stamp when freeing the TD's (see above).  This is
    equivalent to the InUse flag in the Win2k implementation, except we have
    more than one bit of actual information in it.

    BUGBUG: WARNING!!!: THIS CODE FAILS AT THIS TIME IF THE LOST LIST CONTAINS ANY
    ISOCHRONOUS TDS, AS THESE TDS ARE NOT IN THE POOL!!!  (This was entered as 
    bug #4463.  The bug was resolved as "won't fix", since this code does not execute
    on MCPX, the bug is extremely rare and it is not critical to support isoch on the
    pre-DVT boxes.)

    The algorithm for searching is as follows:

    1) Find the tails of the lists.  There are two lists: HcDoneHead points to the
    head of a private list that the HC is building (the hardware presumably doesn't
    lose this one) and Hcca.DoneHead (the one that is lost).  The tail TD of both of
    these lists look the same: the NextTD member is NULL, and the HostControllerNumber
    is the same as the HostControllerNumber in the DeviceExtension.  We saw to both
    of these conditions in OHCD_PoolFreeTD by initializing these 0xFFFFFFFF and 0xFF,
    and by setting HostControllerNumber in OHCD_PoolAllocateTD.  So NextTD might get
    changed to a valid pointer (but not NULL), when an URB is programmed, but only
    the HostController changes NexTD to NULL.

    2) a snap shot of HcDoneHead is taken.

    3) After finding the tails, the lists are built up by repeatedly walking the pool
    looking for TD's that point to the heads of the two lists.  If one is found it
    is the new head.

    4) Each time a new head is found (including before the first iteration),
    it is compared to the snap shot of HcDoneHead taken in step 2).  If it
    matches HcDoneHead, we can throw away that list and just keep building the
    other list, which must be the lost one.

    5) The first time through the whole pool that we find no changes, we can
    be sure that we got the whole missing list.
    
--*/
{
    UCHAR HostControllerNumber = (UCHAR)DeviceExtension->HostControllerNumber;
    POHCD_TRANSFER_DESCRIPTOR   Td;
    ULONG                       TdList1 = 0;
    ULONG                       TdList1Length = 0;
    ULONG                       TdList2 = 0;
    ULONG                       TdList2Length = 0;
    ULONG                       HcDoneHead = 0;
    BOOLEAN                     updated;

    USB_DBG_WARN_PRINT(("Lost DoneHead %d time(s).", ++OHCD_GlobalPool.LostDoneHeadCount));

    //
    // Scan the TD pool looking for TDs with a NULL NextTD pointer.
    // A TD should only have NULL NextTD pointer if it is the tail of
    // a done TD list.  There might be two such lists:  the list of TDs
    // that were completed the last time the HC should have updated the
    // HCCA->HccaDoneHead, and the list of TDs that have completed since
    // then.
    //

    for (Td = OHCD_GlobalPool.FirstTD; Td <= OHCD_GlobalPool.LastTD; Td++)
    {
        if (Td->HostControllerNumber == HostControllerNumber)
        {
            if (0 == Td->HcTransferDescriptor.NextTD)
            {
                // This TD has a NULL NextTD pointer.  Save it as the
                // tail of either TdList1 or TdList2.
                //
                if (0 == TdList1)
                {
                    TdList1 = Td->PhysicalAddress;
                    TdList1Length++;
                }
                else
                {
                    // We expect to find at most two TDs with NULL
                    // NextTD pointers.
                    //
                    ASSERT(0 == TdList2);

                    TdList2 = Td->PhysicalAddress;
                    TdList2Length++;
                }
            }
        }
    }


    if (0 == TdList1)
    {
        USB_DBG_WARN_PRINT(("Lost DoneHead not found."));
        return 0;
    }

    if (TdList2 != 0)
    {
        // There are two lists of completed TDs.  One list should be
        // pointed to by HCCA->HccaDoneHead, and the other list should be
        // pointed to by HC->HcDoneHead.  Read HC->HcDoneHead so we can
        // determine which list is pointed to (or should have been pointed
        // to) by HCCA->HccaDoneHead and which list is pointed to by
        // HC->HcDoneHead.
        //
        HcDoneHead = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcDoneHead);

        // If HC->HcDoneHead is NULL, then something is does not match our
        // expectations.
        //
        ASSERT(HcDoneHead != 0);
    }

    do
    {
        updated = FALSE;

        if (HcDoneHead)
        {
            if (HcDoneHead == TdList1)
            {
                // TdList1 is pointed to by HC->HcDoneHead.  Toss TdList1
                // and keep TdList2
                //
                TdList1 = TdList2;
                TdList1Length = TdList2Length;
                TdList2 = 0;
            }
            else if (HcDoneHead == TdList2)
            {
                // TdList2 is pointed to by HC->HcDoneHead.  Toss TdList2
                // and keep TdList1
                //
                TdList2 = 0;
            }
        }

        //
        // Scan the TD pool looking for TDs with NextTD pointers that
        // point to the head of either TdList1 or TdList2.  If such a TD
        // is found, it becomes the new head of the appropriate list, and
        // loop around at least one more time.  If no such TD is found, then
        // the current heads of the lists must be the true heads and we can
        // quit looping.
        //

        for (Td = OHCD_GlobalPool.FirstTD; Td <= OHCD_GlobalPool.LastTD; Td++)
        {
            if(
                (Td->HostControllerNumber == HostControllerNumber) &&
                (Td->HcTransferDescriptor.NextTD != 0)
            )
            {
               if (Td->HcTransferDescriptor.NextTD == TdList1)
               {
                    TdList1 = Td->PhysicalAddress;
                    TdList1Length++;
                    updated = TRUE;
               }
               else if (Td->HcTransferDescriptor.NextTD == TdList2)
               {
                    TdList2 = Td->PhysicalAddress;
                    TdList2Length++;
                    updated = TRUE;
                }
            }
        }
    } while (updated);

    //For logging purposes keep the minimum list length
    if(TdList1Length < OHCD_GlobalPool.LostMinimumDoneListLength)
    {
        OHCD_GlobalPool.LostMinimumDoneListLength = TdList1Length;
        USB_DBG_WARN_PRINT(("New LostMinimumDoneListLength %d .", OHCD_GlobalPool.LostMinimumDoneListLength));
    }

    ASSERT(TdList1 != 0);
    ASSERT(TdList2 == 0);

    return TdList1;
}

#endif //SILVER

/**
*** Another type of pool type workaround.  This workaround is for a broken a NV2A on the first
*** silicon revision.  It should be fixed on the next revision, but unfortunately we need a
*** workaround to get through the next several weeks.
***
*** All transfers need to be executed to\from uncached memory.  A big sweeping fix is to double
*** buffer all transfers.  This code manages that.
***
*** During initialization of the pool, OHCD_PoolCreateDoubleBufferPool is called.  It allocates
*** a pool and creates two free lists, one for large buffer and one for small buffers.
***
*** OHCD_PoolStartDoubleBufferTransfer is called whenever an URB is about to be programmed.
*** It pops a buffer off the correctfree list and assigns it to the URB.  On a write, it also copies
*** the data over.
***
*** OHCD_PoolEndDoubleBufferTransfer is called whenever a transfer completes.  On a read, it first
*** copies over the bytes read to the original buffer.  Then it places the double buffer back on
*** the correct free list and restores the original buffer in the URB.
***
*** It is asserted that POOL_DOUBLE_BUFFER_SIZE and POOL_DOUBLE_BUFFER_COUNT are large enough.
***
**/  

#ifdef DVTSNOOPBUG

//These values should allocate 3 4k pages.
#define POOL_LARGE_DOUBLE_BUFFER_SIZE  1024
#define POOL_LARGE_DOUBLE_BUFFER_COUNT 9
#define POOL_SMALL_DOUBLE_BUFFER_SIZE  64
#define POOL_SMALL_DOUBLE_BUFFER_COUNT 27

typedef struct _OHCD_POOL_UNCACHED_BUFFER *POHCD_POOL_UNCACHED_BUFFER;
typedef struct _OHCD_POOL_UNCACHED_BUFFER
{
  PVOID                         UserBuffer;
  union
  {
    POHCD_POOL_UNCACHED_BUFFER  *PoolHead;
    POHCD_POOL_UNCACHED_BUFFER  NextFree;
  };
  CHAR                          Buffer[0];
} OHCD_POOL_UNCACHED_BUFFER;

POHCD_POOL_UNCACHED_BUFFER OHCD_PoolSmallDoubleBufferFreeList = NULL;
POHCD_POOL_UNCACHED_BUFFER OHCD_PoolLargeDoubleBufferFreeList = NULL;

VOID OHCD_PoolCreateDoubleBufferPool()
{
    ULONG     poolSize;
    ULONG_PTR poolMemory;
    POHCD_POOL_UNCACHED_BUFFER bufferPtr;
    ULONG largeBufferSize = sizeof(OHCD_POOL_UNCACHED_BUFFER)+POOL_LARGE_DOUBLE_BUFFER_SIZE;
    ULONG smallBufferSize = sizeof(OHCD_POOL_UNCACHED_BUFFER)+POOL_SMALL_DOUBLE_BUFFER_SIZE;
    int i;

    //Allocate the memory
    poolSize = largeBufferSize*POOL_LARGE_DOUBLE_BUFFER_COUNT+
               smallBufferSize*POOL_SMALL_DOUBLE_BUFFER_COUNT;
    //round up to a full page
    if(poolSize%PAGE_SIZE) poolSize += (PAGE_SIZE-(poolSize%PAGE_SIZE));
    poolMemory = (ULONG_PTR)MmAllocateContiguousMemoryEx(
                                poolSize, 0, MAXULONG_PTR, 0, PAGE_READWRITE|PAGE_NOCACHE);    
    ASSERT(poolMemory);

    // Create the large buffer free list
    bufferPtr = (POHCD_POOL_UNCACHED_BUFFER)poolMemory;
    for(i=0; i < POOL_LARGE_DOUBLE_BUFFER_COUNT; i++)
    {
        bufferPtr->NextFree = OHCD_PoolLargeDoubleBufferFreeList;
        OHCD_PoolLargeDoubleBufferFreeList = bufferPtr;
        bufferPtr = (POHCD_POOL_UNCACHED_BUFFER)(((ULONG_PTR)bufferPtr)+largeBufferSize);
    }

    // Create the small buffer free list
    for(i=0; i < POOL_SMALL_DOUBLE_BUFFER_COUNT; i++)
    {
        bufferPtr->NextFree = OHCD_PoolSmallDoubleBufferFreeList;
        OHCD_PoolSmallDoubleBufferFreeList = bufferPtr;
        bufferPtr = (POHCD_POOL_UNCACHED_BUFFER)(((ULONG_PTR)bufferPtr)+smallBufferSize);
    }
}

VOID OHCD_PoolStartDoubleBufferTransfer(PURB Urb)
{
    POHCD_POOL_UNCACHED_BUFFER uncachedBuffer;
    ULONG                      transferLength = Urb->CommonTransfer.TransferBufferLength;
    
    ASSERT(0 != transferLength);
    ASSERT(0 != Urb->CommonTransfer.TransferBuffer);
    ASSERT(POOL_LARGE_DOUBLE_BUFFER_SIZE >= transferLength);

    //Grab a buffer from a free list
    if(transferLength > POOL_SMALL_DOUBLE_BUFFER_SIZE)
    {
        uncachedBuffer = OHCD_PoolLargeDoubleBufferFreeList;
        ASSERT(uncachedBuffer); //increase POOL_DOUBLE_BUFFER_COUNT if this is hit
        OHCD_PoolLargeDoubleBufferFreeList = uncachedBuffer->NextFree;
        uncachedBuffer->PoolHead = &OHCD_PoolLargeDoubleBufferFreeList;
    } else
    {
        uncachedBuffer = OHCD_PoolSmallDoubleBufferFreeList;
        ASSERT(uncachedBuffer); //increase POOL_DOUBLE_BUFFER_COUNT if this is hit
        OHCD_PoolSmallDoubleBufferFreeList = uncachedBuffer->NextFree;
        uncachedBuffer->PoolHead = &OHCD_PoolSmallDoubleBufferFreeList;
    }
    
    //swap the original buffer for the uncached buffer.
    uncachedBuffer->UserBuffer = Urb->CommonTransfer.TransferBuffer;
    Urb->CommonTransfer.TransferBuffer = uncachedBuffer->Buffer;

    //if it is a write copy the data to the uncached buffer
    if(USB_TRANSFER_DIRECTION_OUT == Urb->CommonTransfer.TransferDirection)
    {
       RtlCopyMemory(uncachedBuffer->Buffer, uncachedBuffer->UserBuffer, transferLength);
    }

}

VOID OHCD_PoolEndDoubleBufferTransfer(PURB Urb)
{
    
    POHCD_POOL_UNCACHED_BUFFER uncachedBuffer = CONTAINING_RECORD(
                                                  Urb->CommonTransfer.TransferBuffer,
                                                  OHCD_POOL_UNCACHED_BUFFER,
                                                  Buffer
                                                  );
    POHCD_POOL_UNCACHED_BUFFER *poolHead = uncachedBuffer->PoolHead;

    //if it was a read, copy the data to the user buffer
    if(USB_TRANSFER_DIRECTION_IN == Urb->CommonTransfer.TransferDirection)
    {
        ULONG transferLength = Urb->CommonTransfer.TransferBufferLength;
        ASSERT(uncachedBuffer);
        ASSERT(uncachedBuffer->UserBuffer);
        ASSERT(transferLength <= Urb->CommonTransfer.Hca.HcdOriginalLength);
        if(transferLength)
        {
            //
            //  The wierdness that follows is to due to the fact that one may
            //  DMA into PAGE_READONLY memory, but not write to under CPU control.
            //  The workaround here is to detect PAGE_READONLY memory, switch it
            //  to PAGE_READWRITE, perform the copy and then switch it back.
            //
            PVOID userBuffer = uncachedBuffer->UserBuffer;
            ULONG oldProtect = MmQueryAddressProtect(userBuffer);
            if(PAGE_READONLY == ((PAGE_READONLY | PAGE_READWRITE)&oldProtect))
            {
                ULONG newProtect = oldProtect;
                newProtect &= ~PAGE_READONLY; //clear readonly
                newProtect |= PAGE_READWRITE; //set readwrite
	            MmSetAddressProtect(userBuffer, transferLength, newProtect);
	            RtlCopyMemory(
                 userBuffer,
                 uncachedBuffer->Buffer,
                 transferLength
                 );   
	            MmSetAddressProtect(userBuffer, transferLength, oldProtect);
            } else
            {
                RtlCopyMemory(
                 userBuffer,
                 uncachedBuffer->Buffer,
                 transferLength
                 );   
            }
        }
    }

    //swap the original buffer for the uncached buffer.
    Urb->CommonTransfer.TransferBuffer = uncachedBuffer->UserBuffer;

    //return the uncached buffer to the free list
    uncachedBuffer->NextFree = *poolHead;
    *poolHead = uncachedBuffer;
}

#endif //DVTSNOOPBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\ohci.h ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    ohci.h

Abstract:

    OpenHCI Version 1.0a defined registers and data structures
    Some comments included.  See OpenHCI specification for more details.
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-13-00 created by Mitchell Dernis (mitchd)

--*/
#ifndef __OCHI_H__
#define __OCHI_H__

//
//  Program interface code for PCI configuration space.
//  Couldn't find it in OpenHCI or UniversalHCI specification.
//  I figure it out by looking at the Win2k usb.inf file.
//
#define OHCI_PCI_PROGRAM_INTERFACE 0x10

//
//  Endpoint Control
//
typedef union _OHCI_ENDPOINT_CONTROL
{
    ULONG ul;
    struct {
        ULONG   FunctionAddress:7;      //Address of function (or hub) containing endpoint
        ULONG   EndpointAddress:4;      //Address of endpoint within function (or hub)
        ULONG   Direction:2;            //00b - 11b = read from TD, 01b = OUT, 10b = IN
        ULONG   Speed:1;                //0 = full speed, 1 = low speed
        ULONG   Skip:1;                 //When set, HC skips this Endpoint in the schedule
        ULONG   Format:1;               //0 = Control, Bulk or Interrupt, 1=Isochronous
        ULONG   MaximumPacketSize:11;   //Maximum bytes in a single packet
        ULONG   FutureSoftwareUse:5;    //Preserved by HC, available for driver use.
    };
} OHCI_ENDPOINT_CONTROL, *POHCI_ENDPOINT_CONTROL;

//
//  Structure OHCI_ENDPOINT_DESCRIPTOR
//  This structure is used to represent an endpoint in the USB schedule on OHCI controllers.
//  (DO NOT CONFUSE WITH USB_ENDPOINT_DESCRIPTOR DEFINED IN USB SPECIFICATION)
//
//  Comments:
//
//  Must be 4 DWORDs (16 bytes) long.
//
//  When TailP = HeadP the list contains no TD that the HC can process.
//
//
typedef struct _OHCI_ENDPOINT_DESCRIPTOR
{
    //First DWORD
    OHCI_ENDPOINT_CONTROL Control;  //see OHCI_ENDPOINT_CONTROL

    //Second DWORD
    ULONG   TailP;                  //Points to last TD for Endpoint.  Pointer should be
                                    //paragraph(16 bytes) aligned.  4 lsb are ignored.
    
    //Third DWORD
    ULONG   HeadPHaltCarry;         //Point to first TD for Endpoint. Pointer should be
                                    //paragraph(16 bytes) aligned.  2 lsb are used though
                                    //for Halt and toggleCarry fields.  Bits 3, 4 must be zero.
                                    //Therefore, use access macros.  WRITE_HEADP/READ_HEADP,
                                    //SET_HALTED/CLEAR_HALTED/GET_HALTED, and SET_TOGGLECARRY/
                                    //CLEAR_TOGGLECARRY/GET_TOGGLECARRY defined below.

    //Fourth DWORD
    ULONG   NextED;                 //Points to next endpoint.  Pointer should be
                                    //paragraph(16 bytes) aligned.  4 lsb are ignored.

} OHCI_ENDPOINT_DESCRIPTOR, *POHCI_ENDPOINT_DESCRIPTOR;

//
//  Macros for access to HeadPHaltCarry element of OHCI_ENDPOINT_DESCRIPTOR
//
#define WRITE_HEADP(_endpoint_descriptor_pointer_, _HeadP_)\
            (_endpoint_descriptor_pointer_)->HeadPHaltCarry = (_HeadP_ & 0xFFFFFFF0) | \
            ((_endpoint_descriptor_pointer_)->HeadPHaltCarry & 0x0000000F);
#define READ_HEADP(_endpoint_descriptor_pointer_) ((_endpoint_descriptor_pointer_)->HeadPHaltCarry & 0xFFFFFFF0)

#define SET_HALTED(_endpoint_descriptor_pointer_) ((_endpoint_descriptor_pointer_)->HeadPHaltCarry |= 0x00000001)
#define CLEAR_HALTED(_endpoint_descriptor_pointer_) ((_endpoint_descriptor_pointer_)->HeadPHaltCarry &= ~0x00000001)
#define GET_HALTED(_endpoint_descriptor_pointer_) \
            (((_endpoint_descriptor_pointer_)->HeadPHaltCarry & 0x00000001) ? TRUE : FALSE)


#define SET_TOGGLECARRY(_endpoint_descriptor_pointer_) ((_endpoint_descriptor_pointer_)->HeadPHaltCarry |= 0x00000002)
#define CLEAR_TOGGLECARRY(_endpoint_descriptor_pointer_) ((_endpoint_descriptor_pointer_)->HeadPHaltCarry &= ~0x00000002)
#define GET_TOGGLECARRY(_endpoint_descriptor_pointer_) \
            (((_endpoint_descriptor_pointer_)->HeadPHaltCarry & 0x00000002) ? TRUE : FALSE)


//
//  Structure OHCI_TRANSFER_DESCRIPTOR
//  This structure is used to represent bulk, interrupt and control transfers
//  descriptors in the USB schedule on OHCI controllers.
//
//  Must be 4 DWORDs (16 bytes) long.
//
typedef struct _OHCI_TRANSFER_DESCRIPTOR *POHCI_TRANSFER_DESCRIPTOR;
typedef struct _OHCI_TRANSFER_DESCRIPTOR
{
    //First DWORD
    ULONG FutureSoftwareUse1:16;    //Preserved by HC, available for driver use.
    ULONG Format:1;                 //Preserved by HC, XBOX OHCD driver defined analog to format set in ED
    ULONG FutureSoftwareUse2:1;     //Preserved by HC, available for driver use.
    ULONG BufferRounding:1;         //If clear, than short packets generate an error.
    ULONG Direction_PID:2;          //00b = SETUP, 01b = OUT, 10b = IN, 11b = Reserved
    ULONG DelayInterrupt:3;         //Time (in frames) before interrupt must generated after
                                    //this is TD is completed.  111b = No Interrupt
    ULONG DataToggle:2;             //Used for DATA0\DATA1 toggling.  MSb = 0 indicates
                                    //that toggleCarry in ED should be used.  MSb = 1 indicates
                                    //that LSb should be used.
    ULONG ErrorCount:2;             //Error count on attempts to process TD.  After 3, TD is
                                    //retired as a failure with the ConditionCode set. Endpoint
                                    //is halted.
    ULONG ConditionCode:4;          //Status of TD

    //Second DWORD
    ULONG CurrentBufferPointer;     //Pointer to current location in data buffer which receives
                                    //or sends data.

    //Third DWORD
    //  When a TD is handed over to the HC NextTD has a correct physical address.
    //  However, after dequeueing a TD from the DoneQueue, we use NextTDVirtual
    //  so that the driver may easily traverse the list.
    //
    union
    {
        ULONG                       NextTD;         //Pointer to next Transfer Desciptor.  Must be paragraph
        POHCI_TRANSFER_DESCRIPTOR   NextTDVirtual;  //aligned, i.e. bits 0-3 must be 0. We also
    };

    //Fourth DWORD
    ULONG BufferEnd;                //BufferEnd - used for 2 page scatter\gather on long packets.
                                    //see OHCI specification.
} OHCI_TRANSFER_DESCRIPTOR;


//
//  Macros for OHCI_TRANSFER_DESCRIPTOR.Direction_PID
//
#define OHCI_TD_DIRECTION_PID_SETUP         0
#define OHCI_TD_DIRECTION_PID_OUT           1
#define OHCI_TD_DIRECTION_PID_IN            2


//
// Macros for OHCI_TRANSFER_DESCRIPTOR.DelayInterrupt;
//
#define OHCI_TD_DELAY_INTERRUPT_0_MS        0   // Interrupt at end of frame TD is completed
#define OHCI_TD_DELAY_INTERRUPT_1_MS        1   // Interrupt within 1 frame of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_2_MS        2   // Interrupt within 2 frames of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_3_MS        3   // Interrupt within 3 frame of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_4_MS        4   // Interrupt within 3 frame of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_5_MS        5   // Interrupt within 3 frame of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_6_MS        6   // Interrupt within 3 frame of TD compeletion
#define OHCI_TD_DELAY_INTERRUPT_NONE        7   // Do not Interrupt upon completion of TD


//
// Macros for OHCI_TRANSFER_DESCRIPTOR.DataToggle
//
#define OHCI_TD_TOGGLE_FROM_ED          0   // Get the toggle from the ED 
#define OHCI_TD_TOGGLE_DATA_MASK        1   // Mask used for toggling the lsb.
#define OHCI_TD_TOGGLE_DATA0            2   // DATA0 and MSb is set, so it will not use
                                            // endpoint toggle carry.
#define OHCI_TD_TOGGLE_DATA1            3   // DATA1 and MSb is set, so it will not use
                                            // endpoint toggle carry.


//
//  Condition Code definitions for both general and isochronous transfers
//
#define OHCI_CC_NO_ERROR                0x0 //Completed without detected error
#define OHCI_CC_CRC                     0x1 //CRC error
#define OHCI_CC_BIT_STUFFING            0x2 //Bit-stuffing error
#define OHCI_CC_DATA_TOGGLE_MISMATCH    0x3 //DATA0\DATA1 mismatched
#define OHCI_CC_STALL                   0x4 //Stall 
#define OHCI_CC_DEVICE_NOT_RESPONDING   0x5 //Device screwed up handshake
#define OHCI_CC_PID_CHECK_FAILURE       0x6 //Send PID was not valid for endpoint
#define OHCI_CC_UNEXPECTED_PID          0x7 //Receive PID was not valid for endpoint
#define OHCI_CC_DATA_OVERRUN            0x8 //Endpoint returned more data than MaximumPacketSize
#define OHCI_CC_DATA_UNDERRUN           0x9 //Endpoint returned short packet (only if BufferRounding = 0)
#define OHCI_CC_RESERVED1               0xA //Reserved
#define OHCI_CC_RESERVED2               0xB //Reserved
#define OHCI_CC_BUFFER_OVERRUN          0xC //During an IN, HC received data faster than it could
                                            //write it with DMA.
#define OHCI_CC_BUFFER_UNDERRUN         0xD //During an OUT, HC could not fetch data fast enough
                                            //through DMA.
#define OHCI_CC_NOT_ACCESSED            0xE //Either of these may be set by driver before TD
#define OHCI_CC_NOT_ACCESSED2           0xF //is inserted in schedule


//
//  A little 'coincidence' in the way USBD_STATUS_XXXX codes are defined.
//  we can convert very easily.
//
#define OHCI_CC_TO_USBD_STATUS(_ConditionCode_)  ((ULONG)_ConditionCode_ | 0xC0000000)

//
//  Structure OHCI_ISOCHRONOUS_TRANSFER_DESCRIPTOR
//  This structure is used to represent isochronous transfers
//  in the USB schedule on OHCI controllers.
//
//  Must be 8 DWORDs (32 bytes) long.
//
typedef struct _OHCI_ISOCHRONOUS_TRANSFER_DESCRIPTOR
{
    //DWORD 0
    ULONG   StartingFrame:16;       //Describes which frame transfer should start in.
    ULONG   Format:1;               //Preserved by HC, XBOX driver defined analog to format set in ED
    ULONG   FutureSoftwareUse:4;    //Preserved by HC, available for driver use.
    ULONG   DelayInterrupt:3;       //Time (in frames) before interrupt must generated after
                                    //this is TD is completed.  111b = No Interrupt
    ULONG   FrameCount:3;           //One less than count of Data Packets (one data packet = one frame)
    ULONG   FutureSoftwareUse2:1;   //Preserved by HC, available for driver use.
    ULONG   ConditionCode:4;        //Status of TD
    
    //DWORD 1
    ULONG   BufferPage0;            //Pointer to current location in data buffer which receives
                                    //or sends data.
    //DWORD 2
    ULONG   NextTD;                 //Pointer to next Transfer Desciptor.  Must be paragraph
                                    //aligned, i.e. bits 0-3 must be 0.

    //DWORD 3
    ULONG   BufferEnd;              //BufferEnd - used for 2 page scatter\gather on long packets.
                                    //see OHCI specification.

    //DWORDs 4-7
    USHORT  Offset_PSW[8];          //On input each of these is a buffer offset for
                                    //primitive scatter gather processing for each packet.
                                    //When retired, they contain the size and status
                                    //of transfers.
                                    //There are eight of these, one for each possible frame
                                    //that data can be sent in.
} OHCI_ISOCHRONOUS_TRANSFER_DESCRIPTOR, *POHCI_ISOCHRONOUS_TRANSFER_DESCRIPTOR;


//
//  Structure Represented Host Controller Communications Area(HCCA)
//
typedef struct _OHCI_HCCA
{
    ULONG   InterruptTable[32];     //Each entry points to list of Interrupt Endpoints.
                                    //These lists build the frame schedule for interrupts.
    USHORT  FrameNumber;            //Current Frame number (16 bits)
    USHORT  Pad1;                   //HC clears this when the FrameNumber is updated
    ULONG   DoneHead;               //Pointer to List of completed TDs
    UCHAR   Reserved[120];          //Scratch area for HC except for last 4 bytes which are
                                    //padding so that this is divisible by 32.
} OHCI_HCCA, *POHCI_HCCA;

//
//  Bit field for accessing the HcControl register
//
typedef union _HC_CONTROL_REGISTER
{
    ULONG   ul;
    struct
    {
        ULONG   ControlBulkServiceRatio:2;      //One less than the count of control to bulk packets services
        ULONG   PeriodicListEnable:1;           //If set, processing periodic lists is enabled
        ULONG   IsochronousEnable:1;            //If set, processing of Isochronous TD is enable if PeriodLists are.
        ULONG   ControlListEnable:1;            //If set, processing of Control Endpoints is enabled
        ULONG   BulkListEnable:1;               //If set, processing of Bulk Endpoints is enabled
        ULONG   HostControllerFunctionalState:2;//See HC_OPSTATE_USB_XXX definitions below
        ULONG   InterruptRouting:1;             //If set, interrupts are SMI routed, if clear normal bus interrupts
        ULONG   RemoteWakeupConnected:1;        //If set, HC supports remote wakeup.
        ULONG   RemoteWakeupEnabled:1;          //If set, remote wakeup is enabled.
        ULONG   Reserved:21;        
    };
} HC_CONTROL_REGISTER, *PHC_CONTROL_REGISTER;
#define HC_OPSTATE_USB_RESET        0
#define HC_OPSTATE_USB_RESUME       1
#define HC_OPSTATE_USB_OPERATIONAL  2
#define HC_OPSTATE_USB_SUSPEND      3
//
//  Bit fields are a bit inefficient.  When we are changing a 2 bit field
//  or even a bit at a time, it makes the code more readable.  However,
//  during the vary initial setup we want to go to the running state
//  while slamming a bunch of bits.  Here's what we slam.
//  
//  1) Control\Bulk Service Ratio start at 2:1
//
//  2) Periodic, Bulk, and Contorl lists are
//     enabled. Isochronous is disabled.
//
//  3) HostControllerFunctionState is UsbOperational
//  
//  4) Interrupt Routing is normal (bit clear)
//
//  5) Remote wakeup is disabled.
#define HC_CONTROL_REGISTER_START   0x000000B6

//
//  For quick reboot, we shutdown USB.  We slam it into the
//  following stopped state.
//
//  1) Control\Bulk Service Ratio 2:1
//
//  2) All list processing disabled.
//
//  3) HostControllerFunctionState is UsbReset
//
//  4) Interrupt Routing is normal (bit clear)
//
//  5) Remote wakeup is disabled.
#define HC_CONTROL_REGISTER_STOP  0x00000002

//
//  Bit field for accessing the HcCommandStatus register
//
typedef union _HC_COMMAND_STATUS
{
    ULONG   ul;
    struct {
        ULONG   HostControllerReset:1;          //Set to initiate software reset.
        ULONG   ControlListFilled:1;            //Set to indicate that a TD was added to a control ED
        ULONG   BulkListFilled:1;               //Set to indicate that a TD was added to a bulk ED
        ULONG   OwnerShipChangeRequest:1;       //Set to request control from SMM
        ULONG   Reserved:12;
        ULONG   SchedulingOverrunCount:2;       //Count of schedule overruns.
        ULONG   Reserved2:14;
    };
} HC_COMMAND_STATUS, *PHC_COMMAND_STATUS;

//
//  Macros to use insted for ControlListFilled and BulkListFilled
//
#define HCCS_ControlListFilled  0x00000002
#define HCCS_BulkListFilled     0x00000004


//
//  Macros for HcInterruptEnable and HcInterruptDisable bit fields
//
//  The HCD can write to both HcInterruptEnable and HcInterruptDisable, however, only bit
//  setting is processed not bit clearing.  To enable an interrupt, set the corresponding bit
//  in HcInterruptEnable.  To disable an interrupt write to HcInterruptDisable.  Since the
//  bit layouts are identical, there are only one set of macros.
//
#define HCINT_SchedulingOverrun     0x00000001  //Enables\Disables interrupt on scheduling overrun
#define HCINT_WritebackDoneHead     0x00000002  //Enables\Disables interrupt on Writeback of HcDoneHead
#define HCINT_StartOfFrame          0x00000004  //Enables\Disables interrupt on Start of Frame
#define HCINT_ResumeDetect          0x00000008  //Enables\Disables interrupt on Resume detect
#define HCINT_UnrecoverableError    0x00000010  //Enables\Disables interrupt on Unrecoverable Error
#define HCINT_FrameNumberOverflow   0x00000020  //Enables\Disables interrupt on HcFmNumber changes
#define HCINT_RootHubStatusChange   0x00000040  //Enables\Disables interrupt on HcRhStatus or HcRhPortStatus[n] changes
//Bunch of reserved bits
#define HCINT_OwnershipChange       0x40000000  //Enables\Disables interrupt on Ownership change
#define HCINT_MasterInterruptEnable 0x80000000  //Master switch for enabling interrupts

//
//  Bit Field structure for HcFmInterval
//
typedef union _HC_FRAME_INTERVAL
{
    ULONG   ul;
    struct{
        ULONG   FrameInterval:14;               //adjustable interval in clocks between SOF, can be used
                                                //to sync to external clock source
        ULONG   Reserved:2;                     
        ULONG   FullSpeedMaximumPacketSize:15;  //Maximum number of bits in full speed packets to send
                                                //with scheduling over flow.  Calculated by HCD at initialization.
        ULONG   FrameIntervalToggle:1;          //Toggled by HCD when FrameInterval changes.
    };
} HC_FRAME_INTERVAL, *PHC_FRAME_INTERVAL;


//
//  The frame interval is set in terms of clocks.  However, there is overhead from SOF and other
//  minutia.  Additionally, there is bit stuffing which eats on average one out of 7 bits.
//  According to OHCI we need to calculate this.
//  210 is an estimate of the overhead.  I found this formula in existing Win2k code.
//
#define OHCI_DEFAULT_FRAME_INTERVAL 0x2EDF
#define OHCI_CLOCKS_TO_BITS(_Clocks_) ((((_Clocks_) - 210) * 6)/7)

//
//  bit field structure fpr HcRhDescriptorA
//
typedef union _HC_RH_DESCRIPTOR_A
{
    ULONG ul;
    struct
    {
        //First byte
        UCHAR   NumberDownstreamPorts;          //Count of downstream ports off of root hub.

        //Second byte
        UCHAR   PowerSwitchingMode:1;           //If NoPowerSwitch is set, this determines the mode.
        UCHAR   NoPowerSwitch:1;                //0 = ports are power switchable, 1 = ports powered if HC powered.
        UCHAR   DeviceType:1;                   //Should always be 0, because Root Hub is not a compound device.
        UCHAR   OverCurrentProtectionMode:1;    //If set overcurrent is reported on per port basis.fs
        UCHAR   NoOverCurrentProtection:1;      //If set overcurrent is not reported.
        UCHAR   ReservedBits:3;

        //Third byte
        UCHAR   Reserved;

        //Fourth byte
        UCHAR   PowerOnToPowerGoodTime;         //Time HCD waits after powering hub before accessing hub.
                                                //Reported in 2 ms units.
    };
} HC_RH_DESCRIPTOR_A, *PHC_RH_DESCRIPTOR_A;

//
//  bit field structure fpr HcRhDescriptorB
//
typedef union _HC_RH_DESCRIPTOR_B
{
    ULONG ul;
    struct
    {
        USHORT  DeviceRemovable;                //Each bit is dedicated to a port.  If set indicates
                                                //that device can NOT be removed from root hub.
        USHORT  PortPowerControlMask;           //Each bit is dedicated to a port.  If set indicates
                                                //that device is only effected by per port power control.
                                                //Ignored if PowerSwitchingMode is cleared.
    };
} HC_RH_DESCRIPTOR_B, *PHC_RH_DESCRIPTOR_B;

//
//  macros and struct for HcRhStatus register
//
//  The HubStatus part represents the status if read.
//  Write a one to the corresponding bit in HubStatusChange.
//
//  However to complicate matter, the LocalPower bit can be written
//  to in HubStatus.  It has the effect of turning off power.  The corresponding
//  bit in HubStatusChange turns power on.  Guess what, reading LocalPower in the
//  HubStatusChange register always returns 0.
//
//  OverCurrentIndicator works as expected.  On read of HubStatus it returns the
//  state, it is not writeable. In HubStatusChange a read returns one if the state
//  change.   You can clear it with a write of a one to HubStatusChange.
//
//  Reading DeviceRemoteWakeup in HubStatus indicates whether a remote wakeup was signaled.
//  Writing a one to HubStatus enables remote wakeup.  Writing a one to HubStatusChange
//  disables remote wakeup.
//
#define HC_RH_STATUS_LocalPower                 0x0001
#define HC_RH_STATUS_OvercurrentIndicator       0x0002
#define HC_RH_STATUS_DeviceRemoteWakeupEnable   0x8000
typedef union _HC_RH_STATUS
{
    ULONG   ul;
    struct {
        USHORT  HubStatus;              //bit field indicating hub status
        USHORT  HubStatusChange;        //bit field for changing hub status
    };
} HC_RH_STATUS, *PHC_RH_STATUS;

//
//  Values for initializing the RootHub on Xbox
//

#define HC_RH_DESCRIPTOR_A_INIT_XBOX         0x00001200  //NoOverCurrentProtection|NoPowerSwitch
#define HC_RH_DESCRIPTOR_B_INIT_XBOX         0x00000000  
#define HC_RH_STATUS_INIT_XBOX               0x80000000  //Clears DeviceRemoteWakeupEnable

//
//  macros and struct for HcRhPortStatus,
//  !!!!Some of the bits do double duty (different on read and write)
//  so there may be more than one macro per bit!!!
//
#define HC_RH_PORT_STATUS_CurrentConnectStatus      0x0001  //Read PortStatus, 1 if device currently connected
#define HC_RH_PORT_STATUS_ClearPortEnable           0x0001  //Set PortStatus, disables  clears PortEnableStatus
                                                            //Read PortStatusChange, 1 indicates connect or disconnect
                                                            //Set PortStatusChange, clears this bit in PortStatusChange
#define HC_RH_PORT_STATUS_PortEnableStatus          0x0002  //Read PortStatus, 1 if port is enable
#define HC_RH_PORT_STATUS_SetPortEnable             0x0002  //Set PortStatus, enables device
                                                            //Read PortStatusChange, 1 indicates change in PortStatus bit
                                                            //Set PortStatusChange, clears this bit in PortStatusChange
#define HC_RH_PORT_STATUS_PortSuspendStatus         0x0004  //Read PortStatus, 1 if port is suspended
#define HC_RH_PORT_STATUS_SetPortSuspend            0x0004  //Set PortStatus suspends device
                                                            //Read PortStatusChange, 1 indicates change in PortStatus bit
                                                            //Set PortStatusChange, clears this bit in PortStatusChange
#define HC_RH_PORT_STATUS_PortOverCurrentIndicator  0x0008  //Read PortStatus, 1 if port is overcurrent detected
#define HC_RH_PORT_STATUS_ClearSuspendStatus        0x0008  //Set PortStatus resumes device
                                                            //Read PortStatusChange, 1 indicates change in PortStatus bit
                                                            //Set PortStatusChange, clears this bit in PortStatusChange
#define HC_RH_PORT_STATUS_PortResetStatus           0x0010  //Read PortStatus, 1 if port reset signal is active
#define HC_RH_PORT_STATUS_SetPortReset              0x0010  //Set PortStatus initiates reset signal
                                                            //Read PortStatusChange, 1 indicates reset signal completed (10 ms)
                                                            //Set PortStatusChange, clears this bit in PortStatusChange
#define HC_RH_PORT_STATUS_PortPowerStatus           0x0100  //Read PortStatus, 1 if port power is on
#define HC_RH_PORT_STATUS_SetPortPower              0x0100  //Set PortStatus turns power on
                                                            //There is no PortStatusChange bit
#define HC_RH_PORT_STATUS_LowSpeedDeviceAttach      0x0200  //Read PortStatus, 1 connected device is low speed.
#define HC_RH_PORT_STATUS_ClearPortPower            0x0200  //Set PortStatus, shut port power off.
                                                            //There is no PortStatusChange bit

typedef union _HC_RH_PORT_STATUS
{
    ULONG   ul;
    struct
    {
        USHORT  PortStatus;             //bit field indicating\changing port status
        USHORT  PortStatusChange;       //bit field for indicating changes in port status
    };
} HC_RH_PORT_STATUS, *PHC_RH_PORT_STATUS;

                                                            
//
// Operational Registers
//
typedef struct _OHCI_OPERATIONAL_REGISTERS
{
    //Control and Status
    ULONG               HcRevision;             //LSB is BCD revision of OpenHCI
    HC_CONTROL_REGISTER HcControl;
    HC_COMMAND_STATUS   HcCommandStatus;
    ULONG               HcInterruptStatus;      //See HCINT_Xxxx macros above
    ULONG               HcInterruptEnable;      //See HCINT_Xxxx macros above
    ULONG               HcInterruptDisable;     //See HCINT_Xxxx macros above

    //Memory Pointers
    //  All are pointers to physical memory.  Excepting HcHCCA they are paragraph (16 bytes)
    //  aligned.  HcHCCA is on 256 byte boundary at minimum, some controllers require more
    //  stringent alignmnet.  Test by writing 0xFFFFFFFF and reading back to see how many
    //  of the least signficant bits are 0.
    ULONG   HcHCCA;                 //HCCA area
    ULONG   HcPeriodCurrentED;      //Current ED being processed in (interrupt and isoch lists)
    ULONG   HcControlHeadED;        //Head of ED list for control pipes
    ULONG   HcControlCurrentED;     //Current location ED list for control pipes
    ULONG   HcBulkHeadED;           //Head of ED list for bulk pipes
    ULONG   HcBulkCurrentED;        //Current location ED list for bulk pipes
    ULONG   HcDoneHead;             //Pointer list of completed TDs.  Head of list is last completed.

    //Frame Counter
    HC_FRAME_INTERVAL   HcFmInterval;   //HC_FRAME_INTERVAL for comments
    ULONG               HcFmRemaining;  //14 bit down counter of bits remaining in current frame
                                        //high bit is a toggle, to sync with FrameInterval
    ULONG               HcFmNumber;     //16-bit Frame Counter
    ULONG               HcPeriodicStart;//14-bit value calculated by HCD to reserve enough bandwidth
                                        //for the interrupt and isoch ED list processing.  It is the number
                                        //of bits into the frame before moving to periodic processing.
    ULONG               HcLSThreshold;  //12-bit value for minimum number of bits in frame for which to
                                        //attempt transfering an 8 byte low-speed packet.

    //Root Hub
    //  Registers which are involved with with the root hub emulation
    HC_RH_DESCRIPTOR_A  HcRhDescriptorA;    
    HC_RH_DESCRIPTOR_B  HcRhDescriptorB;
    HC_RH_STATUS        HcRhStatus;
    HC_RH_PORT_STATUS   HcRhPortStatus[1];  //Variable length really, depends on count of hubs
} OHCI_OPERATIONAL_REGISTERS, *POHCI_OPERATIONAL_REGISTERS;
//
//  This is not necessarily sizeof(OHCI_OPERATIONAL_REGISTERS).
//  Rather it is the address space that it occupies in memory.
//
#define OHCI_OPERATIONAL_REGISTER_SIZE 0x1000
#endif //__OCHI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbd\usbd.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    usbd.c

Abstract:

    USBD System Driver Main Entry Points
    and Initialization

Environment:

    XBOX kernel mode only

Notes:

Revision History:

    12-28-99 created by Mitchell Dernis (mitchd)

--*/


//
//  Pull in OS headers
//
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xapidrv.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DBSU'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("USBD");


#pragma data_seg(".XPP$ClassA")
extern "C" DWORD USBD_BeginClassDescriptionTable = 0;
#pragma data_seg(".XPP$ClassZ")
extern "C" DWORD USBD_EndClassDescriptionTable = 0;
#pragma data_seg(".XPP$Data")

//  Tells the linker to merge the USB sections together
#pragma comment(linker, "/merge:.XPPCODE=XPP")
#pragma comment(linker, "/merge:.XPPRDATA=XPP")
#pragma comment(linker, "/merge:.XPPCINIT=XPP")
#pragma comment(linker, "/merge:.XPPRINIT=XPP")
#pragma comment(linker, "/merge:.XPP=XPP")
#pragma comment(linker, "/merge:.XPPDINIT=XPP")

// Tell the linker that the code section contains read/write data.
#pragma comment(linker, "/section:XPP,ERW")

//
//  Pull in usbd headers
//
#include <usbd.h>


//----------------------------------------------------------------------------------
// Globals - all of which must be initialized in DriverEntry
//----------------------------------------------------------------------------------
UCHAR  GLOBAL_HostControllerCount;

//----------------------------------------------------------------------------------------------
//  Just a simple inline new and matching delete that uses RTL_ALLOCATE_HEAP
//----------------------------------------------------------------------------------------------
#pragma warning(disable:4211)
static __inline void * __cdecl operator new(size_t memSize){return RTL_ALLOCATE_HEAP(memSize);}
static __inline void __cdecl operator delete(void *buffer){RTL_FREE_HEAP(buffer);}
#pragma warning(default:4211)

//----------------------------------------------------------------------------------
//  Top level entry points called by the I\O Manager
//----------------------------------------------------------------------------------
#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID USBD_Init(DWORD NumDeviceTypes, PXDEVICE_PREALLOC_TYPE DeviceTypes) 
/*++

Routine Description:
    
    Standard DriverEntry Routine - Let's libraries initialize globals,
    then fills out dispatch table and returns success.

Arguments:
    
    DriverObject - Pointer to DriverObject

    RegistryPath - Pointer to RegistryPath

Return Value:

    None.

--*/
{
    USB_DBG_ENTRY_PRINT(("Entering USBD_Init"));
    USB_DBG_TRACE_PRINT(("Built on %s @%s", __DATE__,__TIME__));

    IUsbInit *pUsbInit = new IUsbInit(NumDeviceTypes, DeviceTypes);

    //
    //  Walk the class drivers and call their init functions
    //
    PUSB_CLASS_DRIVER_DESCRIPTION *ppClassDriverDesc;
    ppClassDriverDesc = (PUSB_CLASS_DRIVER_DESCRIPTION *)((&USBD_BeginClassDescriptionTable)+1);
    while( (ULONG_PTR)ppClassDriverDesc < (ULONG_PTR)&USBD_EndClassDescriptionTable  )
    {
        if(*ppClassDriverDesc) (*ppClassDriverDesc)->Init(pUsbInit);
        ppClassDriverDesc++;
    }

    pUsbInit->Process();
    
    //
    //  Give the HCD a chance to initialize its globals.
    //
    HCD_DriverEntry(pUsbInit->GetHcdResourcePtr());

    //
    // Initialize the device tree
    // 
    g_DeviceTree.Init(pUsbInit->GetNodeCount(), pUsbInit->GetMaxCompositeInterfaces());

    //
    //  We are done with the IUsbInit object
    //
    delete pUsbInit;

    GLOBAL_HostControllerCount=0;
    //
    //  Call the HCD layer to enumerate the hardware.
    //
    HCD_EnumHardware();
    USB_DBG_EXIT_PRINT(("Exiting USBD_Init"));
}

VOID
USBD_NewHostController(
    IN PPCI_DEVICE_DESCRIPTOR PciDevice,
    IN ULONG HcdDeviceExtensionSize
    )
/*++

Routine Description:
    
    Called by the HCD_EnumHardware for every host controller
    it finds.

    We do the following:

    a1. Create a device. (Actually, we need only the extensions not the device objects)
    2. Initialize the USBD portion of the of the device
    3. Call HCD_NewHostController to initialize the hardware portion.

Arguments:
    
    PciDevice - PCI descriptor to pass back to the hardware initialization later.
    HcdDeviceExtensionSize - Size of HCD portion of host controller context.
   
Return Value:

    None - what good does it do to annouce failure anyway.

--*/
{
    PUSBD_HOST_CONTROLLER  hostController;

    USB_DBG_ENTRY_PRINT(("Entering USBD_NewHostController"));

    //
    //  Allocate the Host Controller
    //
    hostController = (PUSBD_HOST_CONTROLLER)RTL_ALLOCATE_HEAP(sizeof(USBD_HOST_CONTROLLER) + HcdDeviceExtensionSize);
    
    if(hostController)
    {
        //
        //  Zero out the whole memory we just allocated.  We do this for our extension
        //  and for the HCD's.
        //
        RtlZeroMemory(hostController, sizeof(USBD_HOST_CONTROLLER) + HcdDeviceExtensionSize);

        //
        //  We need to number our controllers, so the game can distinguish
        //
        hostController->ControllerNumber = ++GLOBAL_HostControllerCount;

        USB_DBG_TRACE_PRINT(("Host Controller #%d Found:", hostController->ControllerNumber));
        USB_DBG_TRACE_PRINT(("HCD extension = 0x%0.8x:", USBD_GetHCDExtension(hostController)));
        
        //
        //  Add a RootHub device for this host controller.
        //
        hostController->RootHub = g_DeviceTree.AllocDevice();
        ASSERT(hostController->RootHub);
        hostController->RootHub->m_Type = UDN_TYPE_ROOT_HUB;
        hostController->RootHub->m_FirstChild = UDN_INVALID_NODE_INDEX;
        hostController->RootHub->m_Parent = UDN_INVALID_NODE_INDEX;
        hostController->RootHub->m_Sibling = UDN_INVALID_NODE_INDEX;
		hostController->RootHub->m_HostController = hostController;
        
        //
        //  Initialize the hardware
        //
        HCD_NewHostController(USBD_GetHCDExtension(hostController), hostController->ControllerNumber, PciDevice);
    }
    USB_DBG_EXIT_PRINT(("Exiting USBD_NewHostController"));
    return;
}
#pragma code_seg(".XPPCODE")

VOID
USBD_CompleteRequest(
    IN  PURB Urb
    )
/*++

Routine Description:

    Entry point called by HCD (and a few places in USBD) to complete an URB.
    Basically, it calls the completion routine if there is one.
    
Arguments:
    
    Urb - The URB that was just completed.

Return Value:

--*/
{
    //
    //  If there is a completion routine than call it.
    //
    if(Urb->Header.CompleteProc)
    {
        USB_DBG_TRACE_PRINT(("Calling the completion routine @0x%0.8x for URB @0x%0.8x.",
                    Urb->Header.CompleteProc, Urb));
        Urb->Header.CompleteProc(Urb, Urb->Header.CompleteContext);
    }
}


USHORT
USBD_CalculateUsbBandwidth(
    IN USHORT   MaxPacketSize,
    IN UCHAR    EndpointType,
    IN BOOLEAN  LowSpeed
    )
/*++

Routine Description:

Arguments:

Return Value:

    banwidth consumed in bits/ms, returns 0 for bulk
    and control endpoints

--*/
{
    USHORT bw;

    //
    // control, iso, bulk, interrupt
    //

    ULONG overhead[4] = {
            0,
            USB_ISO_OVERHEAD_BYTES,
            0,
            USB_INTERRUPT_OVERHEAD_BYTES
          };

    ASSERT(EndpointType<4);

    //
    // Calculate bandwidth for endpoint.  We will use the
    // approximation: (overhead bytes plus MaxPacket bytes)
    // times 8 bits/byte times worst case bitstuffing overhead.
    // This gives bit times, for low speed endpoints we multiply
    // by 8 again to convert to full speed bits.
    //

    //
    // Figure out how many bits are required for the transfer.
    // (multiply by 7/6 because, in the worst case you might
    // have a bit-stuff every six bits requiring 7 bit times to
    // transmit 6 bits of data.)
    //

    // overhead(bytes) * maxpacket(bytes/ms) * 8
    //      (bits/byte) * bitstuff(7/6) = bits/ms

    bw = (USHORT)(((overhead[EndpointType]+MaxPacketSize) * 8 * 7) / 6);

    // return zero for control or bulk
    if (!overhead[EndpointType]) {
        bw = 0;
    }

    if (LowSpeed) {
        bw *= 8;
    }

    return bw;
}

PUSB_CLASS_DRIVER_DESCRIPTION USBD_FindClassDriver(PNP_CLASS_ID ClassId)
{
	PUSB_CLASS_DRIVER_DESCRIPTION *ppMatch;

    //
	//	Match only the class and class specific type.
	//  The class specific type has a slightly different meaning here.
    //  In this context ir is whether the device is interface level or
    //  device level.  Later the class driver will set it to be something
    //  which is really class specific.
    //
	ppMatch = (PUSB_CLASS_DRIVER_DESCRIPTION *)((&USBD_BeginClassDescriptionTable)+1);
    while( (ULONG_PTR)ppMatch < (ULONG_PTR)&USBD_EndClassDescriptionTable)
	{
		if(
            *ppMatch && 
            (ClassId.USB.bClass == (*ppMatch)->ClassId.USB.bClass) &&
            (ClassId.USB.bClassSpecificType == (*ppMatch)->ClassId.USB.bClassSpecificType)
        )
        {
            goto found_match;
        }
		ppMatch++;
	}
    return NULL;

found_match:

    return (*ppMatch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\transfer.c ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    transfer.c

Abstract:
    
    Implementation of functions related to queueing and processing transfer.
    However, isochronous transfers support is not in this file, see isoch.c

    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-20-00 created by Mitchell Dernis (mitchd)

--*/


//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");

//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff


//----------------------------------------------------------------------------
// Forward declaration of functions defined and used only this in this module
//----------------------------------------------------------------------------
USHORT
FASTCALL
OHCD_fGetTDsRequired(
    PURB            Urb,
    POHCD_ENDPOINT  Endpoint
    );

USBD_STATUS
FASTCALL
OHCD_fQueueInterruptTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_ENDPOINT           Endpoint,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fQueueBulkTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

USBD_STATUS
FASTCALL
OHCD_fQueueControlTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    );

VOID
FASTCALL
OHCD_fProgramTransfer(
        POHCD_DEVICE_EXTENSION  DeviceExtension,
        POHCD_ENDPOINT          Endpoint,
        PURB                    Urb
    );

ULONG
FASTCALL
OHCD_fMapTransfer(
    IN OUT  PVOID   *CurrentVa,
    IN OUT  PULONG  BytesRemaining,
    OUT     PULONG  BytesMapped
    );

//----------------------------------------------------------------------------
// Implementation of function called from other modules:
//      OHCD_fQueueTransferRequest
//----------------------------------------------------------------------------
USBD_STATUS
FASTCALL
OHCD_fQueueTransferRequest(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    PURB                    Urb
    )
/*++

Routine Description:
    
    QueueTransferRequest is the first stage of processing an asynchronous
    transfer request.  Part of the TD conservation program requires
    different queueing depending on endpoint type.  In this routine,
    we:
        1) Calculate TDs required.
        2) Dispatch to proper endpoint type determined queue routine.

Arguments:
    
    DeviceExtension - Device extension for our OHCD instance.
    HcdUrb          - Transfer URB to queue.

Return Value:

    STATUS_SUCCESS.  Otherwise we will KeBugcheck before returning.

--*/
{
    POHCD_ENDPOINT              endpoint;
    USBD_STATUS                 status;
    KIRQL                       oldIrql;
            
    USB_DBG_ENTRY_PRINT(("Entering OHCD_fQueueTransferRequest"));

    //
    //  Get the endpoint.
    //
    endpoint = (POHCD_ENDPOINT)Urb->CommonTransfer.EndpointHandle;
        
    //
    //  Figure out how many TDs this transfer requires
    //
    Urb->CommonTransfer.Hca.HcdTDCount = OHCD_fGetTDsRequired(Urb, endpoint);
        
    //
    //  Synchronize access to queues
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Class driver should be smart enough not to submit transfers
    //  while an endpoint is being closed.
    //
    ASSERT(!(OHCD_ENDPOINT_FLAG_CLOSING&endpoint->Flags));

    //
    //  We assume that it going to get queue.  Since the various
    //  queue routines may actually get programmed before returning
    //  here, we want to increment before calling them.
    //  
    endpoint->QueuedUrbCount++;
    Urb->CommonTransfer.Hca.HcdUrbFlags = OHCD_URB_FLAG_QUEUED;
    Urb->CommonTransfer.Hca.HcdUrbLink = NULL;
            
    //
    //  Queue the URB.  Each type of endpoint has its own queue
    //
    switch(endpoint->EndpointType)
    {
        case USB_ENDPOINT_TYPE_INTERRUPT:
            ASSERT(URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER==Urb->Header.Function);
            status = OHCD_fQueueInterruptTransfer(DeviceExtension, endpoint, Urb);
            break;
        case USB_ENDPOINT_TYPE_BULK:
            ASSERT(URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER==Urb->Header.Function);
            status = OHCD_fQueueBulkTransfer(DeviceExtension, Urb);
            break;
        case USB_ENDPOINT_TYPE_CONTROL:
            ASSERT(URB_FUNCTION_CONTROL_TRANSFER==Urb->Header.Function);
            status = OHCD_fQueueControlTransfer(DeviceExtension, Urb);
            break;
        default:
            //ISOCH endpoint never expected here.
            USB_DBG_ERROR_PRINT(("Unrecognized endpoint type in OHCD_fQueueTransferRequest\nClass driver is probably at fault."));
            status = USBD_STATUS_REQUEST_FAILED;
    }

    //
    //  If it didn't actually get queued than, we want to decrease 
    //  queue count.
    //
    if(USBD_ERROR(status))
    {
        Urb->CommonTransfer.Hca.HcdUrbFlags = 0;
        endpoint->QueuedUrbCount--;
    }

    //
    //  Done with queues
    //
    KeLowerIrql(oldIrql);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_fQueueTransferRequest"));
    return status;
}

USBD_STATUS
FASTCALL
OHCD_fQueueInterruptTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_ENDPOINT           Endpoint,
    IN PURB                     Urb
    )
{
    
    ASSERT_DISPATCH_LEVEL();

    //
    //  Check that this transfer is a legal transfer
    //
    if( Urb->BulkOrInterruptTransfer.Hca.HcdTDCount > OHCD_INTERRUPT_TD_QUOTA)
    {
        return USBD_STATUS_TRANSFER_TOO_LONG;
    }
    
    //
    //  Add URB to endpoints pending queue
    //
    if(Endpoint->PendingUrbTailP)
    {
        Endpoint->PendingUrbTailP->CommonTransfer.Hca.HcdUrbLink = Urb;
    }else
    {
        Endpoint->PendingUrbHeadP = Urb;
    }
    Endpoint->PendingUrbTailP = Urb;

    //
    //  Try programming this transfer
    //
    OHCD_fProgramInterruptTransfer(DeviceExtension, Endpoint);

    return USBD_STATUS_PENDING;
}


VOID
FASTCALL
OHCD_fProgramInterruptTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    POHCD_ENDPOINT          Endpoint
    )   
/*++

Routine Description:
    
    This routine is called in two places:
        1) When a new URB is placed on the queue for endpoint.
        2) When an URB completes.
    
    Interrupt endpoints queue URBs on a per endpoint basis.  Each endpoint
    has a quota of OHCD_INTERRUPT_TD_QUOTA (aside from the dummy TD).
    This routine will program all pending URBs until OHCD_INTERRUPT_TD_QUOTA
    TDs are in use.

    If an URB is encountered that requires more than OHCD_INTERRUPT_TD_QUOTA
    it is failed immediately.

Arguments:

   Endpoint - Endpoint to process.

Return Value:

   None.

--*/
{
    PURB_BULK_OR_INTERRUPT_TRANSFER urb;
    
    USB_DBG_ENTRY_PRINT(("Entry OHCD_ProgramInterruptTransfer"));

    
    ASSERT_DISPATCH_LEVEL();

    //
    //  If there are URBs waiting
    //  try to program them.
    //
    while(Endpoint->PendingUrbHeadP)
    {
        urb = &Endpoint->PendingUrbHeadP->BulkOrInterruptTransfer;
        
        //
        //  If there are not enough TDs available than break from this loop.
        //
        if( (urb->Hca.HcdTDCount + Endpoint->TDInUseCount) > OHCD_INTERRUPT_TD_QUOTA)
        {
            break;
        }

        //*
        //* There are enough TDs to proceed to program this transfer.
        //*
        
        //
        //  Remove URB from queue
        //
        Endpoint->PendingUrbHeadP = urb->Hca.HcdUrbLink;
        if(NULL == Endpoint->PendingUrbHeadP) Endpoint->PendingUrbTailP = NULL;

        //
        //  Mark the TDs as in use
        //
        Endpoint->TDInUseCount += urb->Hca.HcdTDCount;
    
        //
        //  Delegate the actual programming process off
        //  to a routine common to all endpoint types.
        //
        OHCD_fProgramTransfer(DeviceExtension, Endpoint, (PURB)urb);
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ProgramInterruptTransfer"));
}


USBD_STATUS
FASTCALL
OHCD_fQueueBulkTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Check that this transfer is a legal transfer
    //
    if( Urb->BulkOrInterruptTransfer.Hca.HcdTDCount > OHCD_PoolGetBulkQuota())
    {
        return USBD_STATUS_TRANSFER_TOO_LONG;
    }

    //
    //  Add URB to endpoints pending queue (at the tail).
    //
    if(DeviceExtension->BulkUrbHeadP)
    {
        DeviceExtension->BulkUrbTailP->CommonTransfer.Hca.HcdUrbLink = Urb;
    }else
    {
        DeviceExtension->BulkUrbHeadP = Urb;
    }
    DeviceExtension->BulkUrbTailP = Urb;

    //
    //  Try programming this transfer
    //
    OHCD_fProgramBulkTransfer(DeviceExtension);

    return USBD_STATUS_PENDING;
}

VOID
FASTCALL
OHCD_fProgramBulkTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension
    )
{
    PURB_BULK_OR_INTERRUPT_TRANSFER urb;
        
    USB_DBG_ENTRY_PRINT(("Entry OHCD_ProgramBulkTransfer"));

    
    ASSERT_DISPATCH_LEVEL();

    //
    //  If there are URBs waiting
    //  try to program them.
    //
    while(DeviceExtension->BulkUrbHeadP)
    {
        urb = &DeviceExtension->BulkUrbHeadP->BulkOrInterruptTransfer;
        
        //
        //  Draw TDs from the Bulk Quota (this does nothing other than mark that
        //  we will allocate the TDs)
        if(!OHCD_PoolDebitBulkTDQuota(urb->Hca.HcdTDCount))
        {
            break;
        }

        //*
        //* There are enough TDs to proceed to program this transfer.
        //*
        
        //
        //  Remove URB from queue
        //
        DeviceExtension->BulkUrbHeadP = urb->Hca.HcdUrbLink;
        if(NULL == DeviceExtension->BulkUrbHeadP) DeviceExtension->BulkUrbTailP = NULL;

        //
        //  Delegate the actual programming process off
        //  to a routine common to all endpoint types.
        //
        OHCD_fProgramTransfer(DeviceExtension, (POHCD_ENDPOINT)urb->EndpointHandle, (PURB)urb);
    
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ProgramBulkTransfer"));
}

USBD_STATUS
FASTCALL
OHCD_fQueueControlTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Check that this transfer is a legal transfer
    //
    if( Urb->ControlTransfer.Hca.HcdTDCount > OHCD_PoolGetControlQuota())
    {
        return USBD_STATUS_TRANSFER_TOO_LONG;
    }

    //
    //  Add URB to endpoints pending queue (at the tail)
    //
    if(DeviceExtension->ControlUrbHeadP)
    {
        DeviceExtension->ControlUrbTailP->CommonTransfer.Hca.HcdUrbLink = Urb;
    }else
    {
        DeviceExtension->ControlUrbHeadP = Urb;
    }
    DeviceExtension->ControlUrbTailP = Urb;

    //
    //  Try programming this transfer
    //
    OHCD_fProgramControlTransfer(DeviceExtension);

    return USBD_STATUS_PENDING;
}

VOID
FASTCALL
OHCD_fProgramControlTransfer(
    POHCD_DEVICE_EXTENSION  DeviceExtension
    )
{
    PURB_CONTROL_TRANSFER   urb;
        
    USB_DBG_ENTRY_PRINT(("Entry OHCD_ProgramControlTransfer"));

    
    ASSERT_DISPATCH_LEVEL();

    //
    //  If there are URBs waiting
    //  try to program them.
    //
    while(DeviceExtension->ControlUrbHeadP)
    {
        urb = &DeviceExtension->ControlUrbHeadP->ControlTransfer;
        
        //
        //  Draw TDs from the Bulk Quota (this does nothing other than mark that
        //  we will allocate the TDs)
        if(!OHCD_PoolDebitControlTDQuota(urb->Hca.HcdTDCount))
        {
            break;
        }

        //*
        //* There are enough TDs to proceed to program this transfer.
        //*
        
        //
        //  Remove URB from queue
        //
        DeviceExtension->ControlUrbHeadP = urb->Hca.HcdUrbLink;
        if(NULL == DeviceExtension->ControlUrbHeadP) DeviceExtension->ControlUrbTailP = NULL;

        //
        //  Delegate the actual programming process off
        //  to a routine common to all endpoint types.
        //
        OHCD_fProgramTransfer(DeviceExtension, (POHCD_ENDPOINT)urb->EndpointHandle, (PURB)urb);
    
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ProgramControlTransfer"));
}

//----------------------------------------------------------------------------
// Implementation of locally declared utility functions:
//
//  OHCD_GetTDsRequired
//  OHCD_AdapterControl
//----------------------------------------------------------------------------


USHORT
FASTCALL
OHCD_fGetTDsRequired(
    PURB            Urb,
    POHCD_ENDPOINT  Endpoint
    )
/*++

Routine Description:

    Local utilitiy function to calculate number of TDs required
    to transmit the data.
Arguments:

    Urb - URB for which to calculate required number of TDs

Return Value:

   Number of TDs required.

--*/
{       
        //
        //  Initialize to zero.
        //
        USHORT  numTDsRequired = 0;
        USHORT  maxPacket = (USHORT)Endpoint->HcEndpointDescriptor.Control.MaximumPacketSize;
                
        //
        //  Zero length transfers should never happen, unless it is
        //  a command on a control pipe.
        //
        ASSERT(Urb->CommonTransfer.TransferBufferLength || (USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType));
        
        if(Urb->CommonTransfer.TransferBufferLength)
        {
            //
            //  How many TD's do we need.
            //
            numTDsRequired += (USHORT)(Urb->CommonTransfer.TransferBufferLength/maxPacket);
            //
            // If it wasn't evenly divisible we need to add one.
            //
            if(Urb->CommonTransfer.TransferBufferLength%maxPacket)
            {
                numTDsRequired++;
            }
        }
        //
        //  If it is a control endpoint, there is a setup packet
        //  and a status packet.  We need a TD for each, plus the
        //  setup and status data each take up 8 bytes. We just
        //  grab a descritpor block for this.  So we need three
        //  extra blocks.
        //
        if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
        {
            numTDsRequired += 3;
        }
        return numTDsRequired;
}

VOID
FASTCALL
OHCD_fProgramTransfer(
        POHCD_DEVICE_EXTENSION  DeviceExtension,
        POHCD_ENDPOINT          Endpoint,
        PURB                    Urb
    )
/*++

Routine Description:

    This routine performs the actual work for control, interrupt, and bulk
    endpoint.  For isochronous endpoints, this routine never gets called.

Algorithm Description:

    This routine takes the form of a loop within a loop.
    The outer loop calls IoMapTransfer, which will map from
    the start of the user buffer to the end of the page.
    However, the data that can be transmitted within a single
    packet is limited to MaxPacketSize(8,16,32, or 64) which 
    is device and endpoint dependent.

    The inner loop creates these TDs.  However, it is also
    possible for a single TD to cross a page boundary, so the
    loop take into account that the first TD of page may begin
    on a previous page.

    There are a couple of other little annoyances:
        1) If it is a control transfer, we need to
        generate a TD for the setup and status packets.
        2) At the end we make sure that the endpoint is in order
        and that all the flags are set correctly.

Arguments:  

    HcdUrb - URB for which to calculate required number of TDs

Return Value:

   Number of TDs required.

--*/

{
    ULONG   maxPacketSize           = Endpoint->HcEndpointDescriptor.Control.MaximumPacketSize;
    PVOID   currentVa;
    ULONG   bytesRemaining          = Urb->CommonTransfer.TransferBufferLength;
    ULONG   bytesMapped             = 0;
    ULONG   currentPa               = 0;
    UCHAR   dataToggle              = OHCI_TD_TOGGLE_FROM_ED;
    UCHAR   hostControllerNumber    = (UCHAR)DeviceExtension->HostControllerNumber;
    ULONG   prevPageResidualPa      = 0;
    ULONG   prevPageResidualBytes   = 0;

    
    POHCD_TRANSFER_DESCRIPTOR       firstTD;
    POHCD_TRANSFER_DESCRIPTOR       previousTD = NULL;
    POHCD_TRANSFER_DESCRIPTOR       currentTD;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_ProgramTransfer."));

    //
    //  Traceout some summary stats of the URB
    //
    USB_DBG_TRACE_PRINT(("Programming DMA for URB @0x%0.8x.", Urb));
    USB_DBG_TRACE_PRINT(("  TransferBuffer        @0x%0.8x", Urb->CommonTransfer.TransferBuffer ));
    USB_DBG_TRACE_PRINT(("  TransferBufferLength  %d bytes", Urb->CommonTransfer.TransferBufferLength ));
    USB_DBG_TRACE_PRINT(("  MaximumPacketSize     %d bytes", maxPacketSize));
    USB_DBG_TRACE_PRINT(("  TDs Required          %d", Urb->CommonTransfer.Hca.HcdTDCount));
    USB_DBG_TRACE_PRINT(("  Endpoint              @0x%0.8x", Endpoint));
    USB_DBG_TRACE_PRINT(("  Control Endpoint?     %s", 
        (USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType) ? "Yes" : "No"));
    
    //
    //  We are about to program a TD that was previously queued.
    //  Adjust the counts that are kept with the Endpoint.
    //
    Endpoint->QueuedUrbCount--;
    Endpoint->ProgrammedUrbCount++;
    Urb->CommonTransfer.Hca.HcdUrbFlags &= ~OHCD_URB_FLAG_QUEUED;
    Urb->CommonTransfer.Hca.HcdUrbFlags |= OHCD_URB_FLAG_PROGRAMMED;

    //
    //  Setup the TD basics. Allocate the first TD.  However, in most cases we can
    //  recycle the dummy. Reuse the dummy at the tail for the first TD
    //
    if(Endpoint->HcEndpointDescriptor.TailP)
    {
        firstTD = 
        currentTD = OHCD_PoolTDFromPhysicalAddress(Endpoint->HcEndpointDescriptor.TailP);
    } else
    {
        //
        //  We need to allocate the head TD.
        //
        firstTD = 
        currentTD = OHCD_PoolAllocateTD(hostControllerNumber);
        
        //
        //  Endpoint sure ought to be paused
        //
        ASSERT(1==Endpoint->HcEndpointDescriptor.Control.Skip);
        //
        //  Write this newly allocated TD to the head
        //
        WRITE_HEADP(&Endpoint->HcEndpointDescriptor, firstTD->PhysicalAddress)
    }
    
    //
    //  If we are a control interface, handle the setup packet
    //
    if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
    {
        POHCD_SETUP_BUFFER SetupBuffer;
        //
        //  We need a descriptor block to hold the setup packet data
        //  and the status packet data.
        //  (we are not really using the TD as a TD, so don't stamp
        //  it with the hostControllerNumber)
        //
        SetupBuffer = (POHCD_SETUP_BUFFER) OHCD_PoolAllocateTD(0xFE-hostControllerNumber);

        //
        //  Copy over the setup bytes (8 of them).
        //  Normally I object to obfuscated code like this,
        //  but you cannot call RtlCopyMemory from DISPATCH_LEVEL, so I will
        //  use this trick I saw in the original Win2K driver.
        //
        *((PLONGLONG)SetupBuffer->Setup) = *((PLONGLONG)&Urb->ControlTransfer.SetupPacket);
        
        //
        //  We will use the firstTD for the setup packet, so allocate a new TD
        //  for the first data packet.
        //
        currentTD = OHCD_PoolAllocateTD(hostControllerNumber);
        
        //
        //  Fill out the hardware mandated fields
        //
        firstTD->HcTransferDescriptor.BufferRounding = FALSE;
        firstTD->HcTransferDescriptor.Direction_PID = OHCI_TD_DIRECTION_PID_SETUP;
        firstTD->HcTransferDescriptor.DelayInterrupt = OHCI_TD_DELAY_INTERRUPT_NONE;
        firstTD->HcTransferDescriptor.DataToggle = dataToggle = OHCI_TD_TOGGLE_DATA0;
        firstTD->HcTransferDescriptor.ErrorCount = 0;
        firstTD->HcTransferDescriptor.ConditionCode = OHCI_CC_NOT_ACCESSED;
        firstTD->HcTransferDescriptor.CurrentBufferPointer = SetupBuffer->PhysicalAddress;
        firstTD->HcTransferDescriptor.NextTD = currentTD->PhysicalAddress;
        firstTD->HcTransferDescriptor.BufferEnd = SetupBuffer->PhysicalAddress + 7;
        //
        //  Now the software fields
        //
        firstTD->Endpoint = Endpoint;
        firstTD->Flags = 0;
        firstTD->Type = OHCD_TD_TYPE_SETUP;
        firstTD->Bytes = 0;
        firstTD->Urb = Urb;
    }
    
    //
    //  Lock the buffer pagesand get the initial value for currentVa,
    //  if and only if there is a data phase.
    //
    if(bytesRemaining)
    {
        #ifdef DVTSNOOPBUG
        OHCD_PoolStartDoubleBufferTransfer(Urb);
        #endif
        MmLockUnlockBufferPages(Urb->CommonTransfer.TransferBuffer, bytesRemaining, FALSE);
        currentVa = Urb->CommonTransfer.TransferBuffer;
    }else
    {
        //
        //  It is a dataless control transfer.  Set the direction so that
        //  the status stage will be an IN.  Status is always reverse of
        //  data, so we set the direction to OUT.
        //
        Urb->ControlTransfer.TransferDirection = OHCI_TD_DIRECTION_PID_OUT;
    }

    //
    //  Now loop until we map the whole user buffer.
    //
    while(bytesRemaining)
    {
        //
        //  Get a physical address
        //
        currentPa = OHCD_fMapTransfer(
            &currentVa,
            &bytesRemaining,
            &bytesMapped
            );

        //
        //  Loop as long as: 
        //      * We have enough buffer mapped to program a whole packet.
        //      * Or it is the last packet.
        //
        while( 
                ((bytesMapped + prevPageResidualBytes) >= maxPacketSize) || 
                ( (0 != bytesMapped) && (0 == bytesRemaining) )
        )
        {
            //
            //  Fill out TD's beginning and ending buffer
            //  physical pointers, and update currentPa and bytesMapped
            //  for next iteration.
            //
            //  The first case, handles a TD that crosses a page boundary
            //  for non-contiguous physical memory.
            //
            if(prevPageResidualBytes)
            {
                ULONG   bytesFromCurrentPage;
                //
                //  Record the start of the buffer (which is from the previousPage)
                //
                currentTD->HcTransferDescriptor.CurrentBufferPointer = prevPageResidualPa;
                        
                //
                //  Find BufferEnd which is on the current page
                //
                bytesFromCurrentPage = maxPacketSize - prevPageResidualBytes;
                if(bytesMapped < bytesFromCurrentPage) bytesFromCurrentPage = bytesMapped;
                currentPa += bytesFromCurrentPage;
                bytesMapped -= bytesFromCurrentPage;
                currentTD->Bytes = (UCHAR)(prevPageResidualBytes + bytesFromCurrentPage);
                prevPageResidualBytes = 0;
                
            }
            else
            {
                //
                //  Record the start of the buffer.
                //
                currentTD->HcTransferDescriptor.CurrentBufferPointer = currentPa;
                //
                //  Find BufferEnd
                //
                if(bytesMapped < maxPacketSize)
                {
                    currentPa += bytesMapped;
                    currentTD->Bytes = (UCHAR)bytesMapped;
                    bytesMapped = 0;
                }
                else
                {
                    currentTD->Bytes = (UCHAR)maxPacketSize;
                    currentPa += maxPacketSize;
                    bytesMapped -= maxPacketSize;
                }
            }
            //
            //  Record BufferEnd.
            //
            currentTD->HcTransferDescriptor.BufferEnd =  currentPa - 1;

            //
            //  Setup the rest of the TD
            //
            currentTD->Endpoint = Endpoint;
            currentTD->Flags = 0;
            currentTD->Type = OHCD_TD_TYPE_DATA;
            currentTD->HcTransferDescriptor.BufferRounding = FALSE;
            currentTD->HcTransferDescriptor.ConditionCode = OHCI_CC_NOT_ACCESSED;
            dataToggle ^= OHCI_TD_TOGGLE_DATA_MASK;
            currentTD->HcTransferDescriptor.DataToggle = dataToggle;
            currentTD->HcTransferDescriptor.DelayInterrupt = OHCI_TD_DELAY_INTERRUPT_NONE;
            currentTD->HcTransferDescriptor.Direction_PID = Urb->ControlTransfer.TransferDirection;
            currentTD->HcTransferDescriptor.ErrorCount = 0;
            currentTD->Urb = Urb;
            
            //
            //  To continue we need to allocate another TD and initialize the
            //  basic stuff.
            //
            previousTD = currentTD;
            currentTD = OHCD_PoolAllocateTD(hostControllerNumber);
            
            //
            //  Link the new TD on to the end of the previous one
            //
            previousTD->HcTransferDescriptor.NextTD = currentTD->PhysicalAddress;

            USB_DBG_TRACE_PRINT(("Loop to assign another TD: bytesMapped(i.e. remaining from this page) = %d", bytesMapped));
        }
        //
        //  Set the previous page stuff for the next loop
        //
        prevPageResidualPa = currentPa;
        prevPageResidualBytes = bytesMapped;
    }

    //
    //  A short packet is OK on last data packet if thed
    //  caller (who submitted the URB) wants it to be OK.
    //  Notice above that the default is FALSE. Even if the caller
    //  allows short packets, the FailedTD routine must be called
    //  to handle short packets in the middle of a transfer, as the
    //  extra TD's must be cleaned from the schedule.
    //
    if(previousTD && Urb->CommonTransfer.ShortTransferOK)
    {
        previousTD->HcTransferDescriptor.BufferRounding = TRUE;
    } 

    //
    //  If it is a control endpoint,
    //  fill out the TD for the status packet.
    //
    if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
    {
        //
        //  Fill out the Hardware mandated fields
        //
        currentTD->HcTransferDescriptor.BufferRounding = FALSE;
        //
        //  Status Packet must reverse the direction of the data packets.
        //
        currentTD->HcTransferDescriptor.Direction_PID = (OHCI_TD_DIRECTION_PID_IN == Urb->CommonTransfer.TransferDirection) ?
                                                                            OHCI_TD_DIRECTION_PID_OUT : OHCI_TD_DIRECTION_PID_IN;
        currentTD->HcTransferDescriptor.DelayInterrupt = Urb->CommonTransfer.InterruptDelay;
        currentTD->HcTransferDescriptor.DataToggle = OHCI_TD_TOGGLE_DATA1;
        currentTD->HcTransferDescriptor.ErrorCount = 0;
        currentTD->HcTransferDescriptor.ConditionCode = OHCI_CC_NOT_ACCESSED;
        currentTD->HcTransferDescriptor.CurrentBufferPointer = 0;
        currentTD->HcTransferDescriptor.BufferEnd = 0;
        //
        //  Now the software fields
        //
        currentTD->Endpoint = Endpoint;
        currentTD->Flags = OHCD_TD_FLAG_LAST_TD;
        currentTD->Type = OHCD_TD_TYPE_STATUS;
        currentTD->Urb = Urb;
        currentTD->Bytes = 0;
        //
        //  We need a TD for the dummy packet
        //
        previousTD = currentTD;
        currentTD = OHCD_PoolAllocateTD(hostControllerNumber);
        previousTD->HcTransferDescriptor.NextTD = currentTD->PhysicalAddress;
    }
    else
    //
    //  Otherwise we need to signal an interrupt on the last data packet, and mark the
    //  packet as the last.
    //
    {
        previousTD->HcTransferDescriptor.DelayInterrupt = Urb->CommonTransfer.InterruptDelay;
        previousTD->Flags = OHCD_TD_FLAG_LAST_TD;
    }

    //
    //  Now fill out the dummy TD
    //
    currentTD->Type = OHCD_TD_TYPE_DUMMY;
    
    //
    //  Wipe out the transfer length, we will increment it as stuff completes
    //
    Urb->CommonTransfer.Hca.HcdOriginalLength = (USHORT)Urb->CommonTransfer.TransferBufferLength;
    Urb->CommonTransfer.TransferBufferLength = 0;

    //
    //  Update the tail pointer
    //
    Endpoint->HcEndpointDescriptor.TailP = currentTD->PhysicalAddress;
    
    //
    //  make sure that SKip bit is not set on the endpoint
    //  (unless it is supposed to be paused!)
    if(0==Endpoint->PendingPauseCount)
        Endpoint->HcEndpointDescriptor.Control.Skip = 0;
    
    //
    //  Now we need to tell the host controller that we added to the
    //  end of the TD queue if it is control or bulk
    //
    if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
    {
        WRITE_REGISTER_ULONG((PULONG)&DeviceExtension->OperationalRegisters->HcCommandStatus, HCCS_ControlListFilled);
    }
    else if(USB_ENDPOINT_TYPE_BULK == Endpoint->EndpointType)
    {
        WRITE_REGISTER_ULONG((PULONG)&DeviceExtension->OperationalRegisters->HcCommandStatus, HCCS_BulkListFilled);
    }
    
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ProgramTransfer."));
    return;
}


ULONG
FASTCALL
OHCD_fMapTransfer(
    IN OUT  PVOID   *CurrentVa,
    IN OUT  PULONG  BytesRemaining,
    OUT     PULONG  BytesMapped
    )
/*++
    This routine is used instead of IoMapTransfer.  It works directly on
    a buffer, returning one page at a time.
--*/
{
    ULONG   returnAddress;

    //
    //  Get Physical address, and figure out number
    //  of bytes to the end of the page.
    //
    returnAddress = MmGetPhysicalAddress(*CurrentVa);
    *BytesMapped = PAGE_SIZE - BYTE_OFFSET(*CurrentVa);
    //
    //  Fix up return values
    //
    if(*BytesMapped > *BytesRemaining)
    {
        *BytesMapped = *BytesRemaining;
    }
    *BytesRemaining -= *BytesMapped;
    *CurrentVa = (PVOID)((ULONG)*CurrentVa + *BytesMapped);
    
    return returnAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\schedule.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.


Module Name:

    schedule.c

Abstract:
    
    Implementation of schedule manager.

    The code in this module maintains all of the endpoint lists associated
    with transfer schedule.  Basically scheduling is only involved when a
    new endpoint is opened or closed.

    The work to be done is very different for bulk and control versus
    isochronous and interrupt.

    For bulk and control the endpoint to be open is simply placed at the head
    of a linked list.

    For interrupt and isochronous a slot must be found in the schedule with
    sufficient bandwidth and the bandwidth tables must be updated.

    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-20-00 created by Mitchell Dernis (mitchd)

--*/

//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");


//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff


#define OHCD_GET_PARENT_INTERRUPT_INDEX(_index_)    ((_index_) >> 1)
#define OHCD_GET_CHILD1_INTERRUPT_INDEX(_index_)    ((_index_) << 1)
#define OHCD_GET_CHILD2_INTERRUPT_INDEX(_index_)    (((_index_) << 1) + 1)
#define OHCD_GET_SIBLING_INTERRUPT_INDEX(_index_)   ((_index_) ^ 1)

//----------------------------------------------------------------------------
// Forward declaration of functions defined and used only this in this module
//----------------------------------------------------------------------------
VOID
FASTCALL
OHCD_HookNewEndpointToChildren(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    ULONG                   EndpointPhysicalAddress,
    UCHAR                   ParentNode
    );

ULONG 
FASTCALL
OHCD_ReverseBits(
    ULONG NumBits,
    ULONG Value
    );

//----------------------------------------------------------------------------
// Implementation of OHCD_ScheduleXXX routines:
//      OHCD_ScheduleInitialize
//      OHCD_ScheduleAddEndpointPeriodic
//      OHCD_ScheduleRemoveEndpointPeriodic
//      OHCD_ScheduleAddEndpointControlOrBulk
//      OHCD_ScheduleRemoveEndpointControlOrBulk
//----------------------------------------------------------------------------
#pragma code_seg(".XPPCINIT")
VOID
FASTCALL
OHCD_ScheduleInitialize(
    POHCD_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:
    
    Initializes the internal data structures, operational registers,
    and shared common buffer areas which set the OpenHCI USB packet
    schedule.
Arguments:
    
    DeviceExtension - Pointer to OHCD's device extension.

Return Value:

    None.

--*/
{
    ULONG                   periodicStart;
    ULONG                   hcLSThreshold;
    POHCD_ENDPOINT_SCHEDULE schedule = &DeviceExtension->Schedule;
    
    //
    //  The structure is more or less initialized by
    //  zeroing everything out.  The whole device extension
    //  should have been zeroed before this routine
    //  was called, so on MAX_DBG builds only just
    //  assert that the structure really is clean
#ifdef MAX_DBG
    for(i = 0; i < 64; i++)
    {
        //
        //  Verify that the NULL and 0 fields were wiped
        //  with the rest of the DeviceExtension
        //
        ASSERT(0 == schedule->InterruptSchedule[i].Bandwidth);
        ASSERT(0 == schedule->InterruptSchedule[i].BandwidthChildren);
        ASSERT(0 == schedule->InterruptSchedule[i].BandwidthParents);
        ASSERT(NULL == schedule->InterruptSchedule[i].EndpointHead);
        ASSERT(NULL == schedule->InterruptSchedule[i].EndpointTail);
        ASSERT(FALSE == schedule->InterruptSchedule[i].RegisterHead);
    }
    ASSERT(0 == Schedule->BulkHead);
    ASSERT(0 == Schedule->BulkTail);
    ASSERT(0 == Schedule->ControlHead);
    ASSERT(0 == Schedule->ControlTail);
#endif

    //
    //  No need to initialize the HCCA, because the initial values
    //  are all zero and that was done when the space was allocated
    //  as part of initializing DMA.
    //

    //
    //  Check the alignment requirments of HCCA
    //
    #ifndef OHCD_XBOX_HARDWARE_ONLY
    #if DBG
    {
        ULONG AlignmentCheck;
        WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcHCCA, 0xFFFFFFFF);
        AlignmentCheck = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcHCCA);
        if( (~AlignmentCheck)&((ULONG)(DeviceExtension->HCCA)) )
        {
            USB_DBG_ERROR_PRINT(("The 2nd USB host controller is not compatible with XSS as a second host controller.\
You can try swapping the USB cards.\n XSS will most likely crash if you see this message.\n"));
        }
    }
    #endif  //DBG
    #endif //OHCD_XBOX_HARDWARE_ONLY
    
    

    //
    //  Setup the schedule part of the
    //  Operational registers
    //
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcHCCA, OHCD_PoolGetPhysicalAddress(DeviceExtension->HCCA));
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcPeriodCurrentED, 0);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcControlHeadED, 0);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcControlCurrentED, 0);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcBulkHeadED, 0);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcBulkCurrentED, 0);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcDoneHead, 0);


    //
    //  save off the total bandwidth - i.e. total number of bits/frame
    //
    schedule->BandwidthTotal = (USHORT)OHCI_CLOCKS_TO_BITS(OHCI_DEFAULT_FRAME_INTERVAL);

    //
    //  Set the HcPeriodicStart to be roughly 90% of FrameInterval.
    //  A special note, HcPeriodicStart is the clocks remaining when we switch
    //  to isoch.  The silly OpenHCI specification says to set to 10%, but they mean
    //  10% gone.
    //
    periodicStart = (9*OHCI_DEFAULT_FRAME_INTERVAL + 5)/10;
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcPeriodicStart, periodicStart);
    
    //
    //  Calculate the bandwidth (bits\frame) for periodic transfers
    //
    ASSERT(0xFFFF >= periodicStart);
    schedule->BandwidthPeriodic = (USHORT)OHCI_CLOCKS_TO_BITS(periodicStart);

    //
    //  Low speed threshold is the time (in full speed clocks) of 8 byte transfer
    //  for the slowest type (interrupt) of endpoint on a low speed device.
    //
    hcLSThreshold = USBD_CalculateUsbBandwidth(8, USB_ENDPOINT_TYPE_INTERRUPT, TRUE);
    WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcLSThreshold, hcLSThreshold);
}
#pragma code_seg(".XPPCODE")

USBD_STATUS
FASTCALL
OHCD_ScheduleAddEndpointPeriodic(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Adds a periodic (interrupt or isochronous) endpoint into the interrupt schedule.

    1) Determines the nodes in the schedule with the proper rate.
    2) Determines which of the nodes with proper will most balance
    the schedule of periodic transfers.
    3) Assure that the best node, has enough bandwidth.
    4) Recomputes the bandwidth entries in the InterruptSchedule.
    5) Insert the endpoint into the InterruptSchedule.
    6) Revises the pointers in the HCCA and the physical address pointers
    of the endpoint descriptors to reflect the schedule changes.

Arguments:
    
    DeviceExtension - Pointer to OHCD's device extension.
    Endpoint        - Endpoint to add to schedule.

Return Value:

    None.

--*/
{
    POHCD_ENDPOINT_SCHEDULE schedule = &DeviceExtension->Schedule;
    UCHAR   node, nodeTemp, nodeMin, nodeMax, nodeBest;
    USHORT  bestBandwidth, nodeBandwidth;

    /*
    **  See the OpenHCI specification for a nice diagram of the schedule
    **  tree.  Note that the implementation here differs significantly
    **  then example code in the specification and from the win2k and
    **  win98 implementation.  In this those examples a static tree of
    **  endpoint descriptors is constructed that always have their skip
    **  bits set.
    **
    **  Here we have a static array of OHCD_INTERRUPT_SCHEDULE_NODE structures.
    **  Their purpose is two serve as a pointerless static binary tree
    **  for storing endpoint lists which are inserted at the same node in
    **  the schedule.  The array is static and it turns out that the tree
    **  can be traversed very easily and efficiently with bit manipulations.
    **  For example, given a pollin interval that is of a power of 2 (as
    **  more or less required by OpenHCI) it is easy to find the eligible
    **  nodes:  Node 0 is dedicated to isochronous endpoints.  Otherwise,
    **  the first eligible node index equals the polling interval.  There
    **  all nodes are eligible up to twice the polling interval minus.  i.e.
    **  if nodeMin = Polling Interval, than nodeMax = 2*nodeMin-1 or as in
    **  code you can shift left to perform the multiplication.
    **  The parent of a node (i.e. the level with shorter intervals) can be
    **  found by shifting the node index one bit to the right. The first child
    **  (i.e. longer polling intervals) requires shifting the node index one
    **  bit to the left.  The second child is one bit to the left plus one.
    **  Calculating these indices is easy and relieves a good deal of pointer
    **  storage overhead.
    **  
    **  Because we use an independent data structure rather than endpoint
    **  descriptors, we do not burden the endpoint descriptor with as
    **  much extra overhead.  Consequently, our transfer descriptors(TDs) and ED
    **  are 32 bytes long not 64.  The act of inserting an ED in the
    **  schedule is in two stages.  First we inset the Endpoint in a node
    **  in the InterruptSchedule.  Then we have to fix up the HCCA and ED 
    **  pointers to reflect the new change.
    **
    **  We treat the requested PollingInterval (from the USB Endpoint Desriptor -
    **  not to be confused with OpenHCI Endpoint Descriptor) as a maximum.
    **  Thus a requested interval of 10 ms, will end up in an 8 ms
    **  polling node.
    **/
    USB_DBG_ENTRY_PRINT(("Entering OHCD_ScheduleAddEndpointPeriodic"));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    //  1) Finding the minimum node in the polling interval which is
    //  a power of 2 and less than the requested interval
    //

    if(USB_ENDPOINT_TYPE_INTERRUPT == Endpoint->EndpointType)
    //
    //  If it is interrupt we need to find the node with the most
    //  open bandwidth
    //
    {
        for(nodeMin = 32; nodeMin > Endpoint->PollingInterval; nodeMin >>= 1);
        USB_DBG_TRACE_PRINT(("Requested Polling Interval = %d, Actual Interval = %d.", Endpoint->PollingInterval, (ULONG)nodeMin));
        nodeMax = 2*nodeMin - 1;

    
        //
        //  2) Now check the bandwidth allocation for the worst case frame
        //  which intersects each eligible node.  Note the node with the
        //  least allocated (i.e. least used up) bandwidth.  The formula for this
        //  is to add up BandwidthChildren (already calculated to be
        //  the worst case frame), Bandwidth(i.e. of this node), and the
        //  BandwidthParents.  Each of these variables are maintained across
        //  the tree when an endpoint is inserted (later in this routine)
        //  or when an endpoint is removed from the schedule.
        //
        bestBandwidth = 12000;  //Certainly larger than the available bandwidth
        for(node = nodeMin; node <= nodeMax; node++)
        {
            nodeBandwidth = schedule->InterruptSchedule[node].BandwidthChildren +
                            schedule->InterruptSchedule[node].Bandwidth +
                            schedule->InterruptSchedule[node].BandwidthParents;
            if(nodeBandwidth < bestBandwidth)
            {
                bestBandwidth = nodeBandwidth;
                nodeBest = node;
                USB_DBG_TRACE_PRINT(("Found better node: bestBandwidth = %d, nodeBest = %d.", bestBandwidth , (ULONG)nodeBest));
            }
        }
    }
    else
    //
    //  If it isochronous we know that it is node zero and we either have
    //  the bandwidth or not.
    //
    {
        bestBandwidth = schedule->InterruptSchedule[0].BandwidthChildren +
                        schedule->InterruptSchedule[0].Bandwidth;
        nodeBest = 0;
    }

    //
    //  3) Is there room for this endpoint in the best node?
    //
    if( (bestBandwidth + Endpoint->Bandwidth) > schedule->BandwidthPeriodic )
    {
        USB_DBG_ERROR_PRINT((
            "INSUFFICIENT BANDIWDTH:\n Requested Bandwidth = %d bits/ms\nBest Node = %d\nBandwidth Available = %d bits/ms\n",
            (ULONG)Endpoint->Bandwidth,
            (ULONG)nodeBest,
            (ULONG)(schedule->BandwidthPeriodic - bestBandwidth)
            ));
        return USBD_STATUS_NO_BANDWIDTH;
    }
    Endpoint->ScheduleIndex = nodeBest;

    //
    //  4) Recalculate the bandwidth tables:
    //      a) Update the bandwidth of our node
    //      b) Propogate the change to the BandwidthParents
    //      variable to all of our children.
    //      c) Propogate the change to the Bandwidth Children
    //      to our parents as long as our branch is the worst
    //      case.

    //  a) ours
    schedule->InterruptSchedule[nodeBest].Bandwidth += Endpoint->Bandwidth;

    //  b) BandwidthParents of Childern
    //  We don't need a real recursion.  Since we are a regular binary tree.
    //  We just walk the side branches and iterate in between.
    //
    if(nodeBest == 0)
    {
        //
        //  Things are different for isochronous.
        //
        nodeMin = nodeMax = 1;
    }
    else
    {
        nodeMin = OHCD_GET_CHILD1_INTERRUPT_INDEX(nodeBest);
        nodeMax = OHCD_GET_CHILD2_INTERRUPT_INDEX(nodeBest);
    }
    while(nodeMax <=64)
    {
        for(node = nodeMin; node <= nodeMax; node++)
        {
            schedule->InterruptSchedule[node].BandwidthParents += Endpoint->Bandwidth;
        }
        nodeMin = OHCD_GET_CHILD1_INTERRUPT_INDEX(nodeMin);
        nodeMax = OHCD_GET_CHILD2_INTERRUPT_INDEX(nodeMax);
    }

    //  c) BandwidthChildren to parents
    node = nodeBest;
    while(node > 1)
    {

        //
        //  make nodeTemp point our sibiling
        //
        nodeTemp = OHCD_GET_SIBLING_INTERRUPT_INDEX(node);

        //
        //  If the sibling node and its children use
        //  more bandwidth than the path we are going
        //  down than we can stop, because nothing
        //  beneath needs to change.
        //
        if( 
            (schedule->InterruptSchedule[node].BandwidthChildren
            + schedule->InterruptSchedule[node].Bandwidth)
            <=
            (schedule->InterruptSchedule[nodeTemp].BandwidthChildren
            + schedule->InterruptSchedule[nodeTemp].Bandwidth)
        ) break;

        //
        //  make nodeTemp point to the parent
        //
        nodeTemp = OHCD_GET_PARENT_INTERRUPT_INDEX(node);

        //
        //  Fix parents bandwidth
        //
        schedule->InterruptSchedule[nodeTemp].BandwidthChildren =
            schedule->InterruptSchedule[node].BandwidthChildren +
            schedule->InterruptSchedule[node].Bandwidth;

        //
        //  Ready another iteration (parent becomes new node)
        //
        node = nodeTemp;
    }
    if(node == 1)
    {
        //
        //  if node = 1, it is possible that one was changed, so 
        //  we should update o (for isochronous) which we can
        //  do safely whether it needs updating or not.
        //
        schedule->InterruptSchedule[0].BandwidthChildren =
                schedule->InterruptSchedule[1].BandwidthChildren +
                schedule->InterruptSchedule[1].Bandwidth;
    }

    //
    //  5) Insert the endpoint into the InterruptSchedule.
    //
    
    if(NULL == schedule->InterruptSchedule[nodeBest].EndpointHead)
    {
        USB_DBG_TRACE_PRINT(("Node %d is empty", (ULONG)nodeBest));
        ASSERT(NULL == schedule->InterruptSchedule[nodeBest].EndpointTail);
    
        //
        //  6-a) Hook up new endpoint physical address
        //  to next endpoint, if there is one.
        node = OHCD_GET_PARENT_INTERRUPT_INDEX(nodeBest);
        while( !schedule->InterruptSchedule[node].EndpointHead && node)
        {
            node = OHCD_GET_PARENT_INTERRUPT_INDEX(node);
        }
        if(schedule->InterruptSchedule[node].EndpointHead)
        {
            ASSERT(NULL != schedule->InterruptSchedule[node].EndpointHead);
            USB_DBG_TRACE_PRINT(("Updating new endpoint to link to head of node %d", (ULONG)node));
            Endpoint->HcEndpointDescriptor.NextED = schedule->InterruptSchedule[node].EndpointHead->PhysicalAddress;
        } else
        {
            //
            //  The endpoint memory should have been zeroed when it was allocated.
            //
            ASSERT(0==Endpoint->HcEndpointDescriptor.NextED);
        }

        //
        //  This must be after the above block so isoch works,
        //  because Node 0 is its own parent.
        //
        schedule->InterruptSchedule[nodeBest].EndpointHead = Endpoint;
        schedule->InterruptSchedule[nodeBest].EndpointTail = Endpoint;
        Endpoint->Next = NULL;
    }
    else
    {
        
        ASSERT(NULL != schedule->InterruptSchedule[nodeBest].EndpointTail);
        Endpoint->Next = schedule->InterruptSchedule[nodeBest].EndpointHead;
        schedule->InterruptSchedule[nodeBest].EndpointHead = Endpoint;
        //
        //  6-a) Hook up new endpoint physical address
        //  to next endpoint.
        Endpoint->HcEndpointDescriptor.NextED = Endpoint->Next->PhysicalAddress;
    }
    //
    //  Walk down children and ensure that new endpoint physical address
    //  is in all chains.
    //
    OHCD_HookNewEndpointToChildren(DeviceExtension, Endpoint->PhysicalAddress, nodeBest);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_ScheduleAddEndpointPeriodic"));
    return USBD_STATUS_SUCCESS;
}

VOID
FASTCALL
OHCD_ScheduleRemoveEndpointPeriodic(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Removes a periodic (interrupt or isochronous) endpoint from the interrupt schedule.

Arguments:
    
    DeviceExtension - Pointer to OHCD's device extension.
    Endpoint        - Endpoint to remove

Return Value:

    None.

--*/
{
    POHCD_ENDPOINT_SCHEDULE schedule = &DeviceExtension->Schedule;
    UCHAR node = Endpoint->ScheduleIndex;
    UCHAR nodeMin, nodeMax, nodeTemp, nodeParent;
    POHCD_ENDPOINT previousEndpoint, currentEndpoint;
    ULONG nextPhysicalAddress;
    USHORT endpointBandwidth = Endpoint->Bandwidth;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_ScheduleRemoveEndpointPeriodic"));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Find endpoint in node list and remove it
    //
    previousEndpoint = NULL;
    currentEndpoint = schedule->InterruptSchedule[node].EndpointHead;
    do
    {
        if(currentEndpoint == Endpoint) break;
        previousEndpoint = currentEndpoint;
        currentEndpoint = currentEndpoint->Next;
    } while(currentEndpoint);
    //
    //  If this assertion fails, than the endpoint 
    //  is not in the schedule.
    ASSERT(Endpoint == currentEndpoint);
    //
    //  If we were the tail, update the tail pointer.
    //
    if(NULL == currentEndpoint->Next)
    {
        schedule->InterruptSchedule[node].EndpointTail = previousEndpoint;
        //
        //  Find the physical address of the next endpoint, if there is one.
        //
        nextPhysicalAddress = 0;
        if(node)  // The tail of the node 0, never has an endpoint after it.
        {
            nodeTemp = OHCD_GET_PARENT_INTERRUPT_INDEX(node);
            while( !schedule->InterruptSchedule[nodeTemp].EndpointHead && nodeTemp)
            {
                nodeTemp = OHCD_GET_PARENT_INTERRUPT_INDEX(nodeTemp);
            }
            if(schedule->InterruptSchedule[nodeTemp].EndpointHead)
            {
                nextPhysicalAddress = schedule->InterruptSchedule[nodeTemp].EndpointHead->PhysicalAddress;
            }
        }
    } else
    {
        nextPhysicalAddress = currentEndpoint->Next->PhysicalAddress;
    }
    //
    //  If we were the head, update the pointer.
    //  
    if(NULL == previousEndpoint)
    {
        schedule->InterruptSchedule[node].EndpointHead = currentEndpoint->Next;
        //
        // recurse to update physical pointers
        //
        OHCD_HookNewEndpointToChildren(
                    DeviceExtension, 
                    nextPhysicalAddress,
                    node
                    );
    }
    else
    //
    //  We were not the head, so update the endpoint
    //  in front of us
    //
    {
        previousEndpoint->Next = currentEndpoint->Next;
        //
        //  Just update physical address of previous endpoint
        //
        previousEndpoint->HcEndpointDescriptor.NextED = nextPhysicalAddress;
    }
    
    //
    //  Recalculate the bandwidth tables:
    //      a) Update the bandwidth of our node
    //      b) Propogate the change to the BandwidthParents
    //      variable to all of our children.
    //      c) Propogate the change to the Bandwidth Children
    //      to our parents as long as our branch is the worst
    //      case.

    //  a) ours
    schedule->InterruptSchedule[node].Bandwidth -= endpointBandwidth;

    //  b) BandwidthParents of Childern
    //  We don't need a real recursion.  Since we are a regular binary tree.
    //  We just walk the side branches and iterate in between.
    //
    if(node == 0)
    {
        //
        //  Things are different for isochronous.
        //
        nodeMin = nodeMax = 1;
    }
    else
    {
        nodeMin = OHCD_GET_CHILD1_INTERRUPT_INDEX(node);
        nodeMax = OHCD_GET_CHILD2_INTERRUPT_INDEX(node);
    }
    while(nodeMax <=64)
    {
        for(nodeTemp = nodeMin; nodeTemp <= nodeMax; nodeTemp++)
        {
            schedule->InterruptSchedule[nodeTemp].BandwidthParents -= Endpoint->Bandwidth;
        }
        nodeMin = OHCD_GET_CHILD1_INTERRUPT_INDEX(nodeMin);
        nodeMax = OHCD_GET_CHILD2_INTERRUPT_INDEX(nodeMax);
    }

    //  c) BandwidthChildren to parents
    while(node > 1)
    {
        //
        //  make nodeTemp point to our sibiling
        //  make nodeParent point to our parent
        //
        nodeTemp = OHCD_GET_SIBLING_INTERRUPT_INDEX(node);
        nodeParent = OHCD_GET_PARENT_INTERRUPT_INDEX(node);

        //
        //  If the sibling node and its children use
        //  more bandwidth than the we can switch 
        //  to the sibling node.
        //
        if( 
            (schedule->InterruptSchedule[node].BandwidthChildren
            + schedule->InterruptSchedule[node].Bandwidth)
            <=
            (schedule->InterruptSchedule[nodeTemp].BandwidthChildren
            + schedule->InterruptSchedule[nodeTemp].Bandwidth)
        )
        {
            //
            //  If the sibling and its children's bandwidth is the same as recorded
            //  for the parent's child, then we can stop.
            //
            if(
                (schedule->InterruptSchedule[nodeTemp].BandwidthChildren + schedule->InterruptSchedule[nodeTemp].Bandwidth) 
                == schedule->InterruptSchedule[nodeParent].BandwidthChildren
            ) {
             break;
            } else
            //
            //  Otherwise, keep walking, but switch to using the sibilings bandwidth
            //
            {
                node = nodeTemp;
            }
        }

        //
        //  Fix parents bandwidth
        //
        schedule->InterruptSchedule[nodeParent].BandwidthChildren =
            schedule->InterruptSchedule[node].BandwidthChildren +
            schedule->InterruptSchedule[node].Bandwidth;
        //
        //  Ready another iteration (parent becomes new node)
        //
        node = nodeParent;
    }
    if(node == 1)
    {
        //
        //  if node = 1, it is possible that one was changed, so 
        //  we should update o (for isochronous) which we can
        //  do safely whether it needs updating or not.
        //
        schedule->InterruptSchedule[0].BandwidthChildren =
                schedule->InterruptSchedule[1].BandwidthChildren +
                schedule->InterruptSchedule[1].Bandwidth;
    }

    USB_DBG_EXIT_PRINT(("Exiting OHCD_ScheduleRemoveEndpointPeriodic"));
}

VOID
FASTCALL
OHCD_ScheduleAddEndpointControlOrBulk(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Adds a control or bulk endpoint to the schedule

Arguments:

    DeviceExtension - Pointer to OHCD's device extension.
    Endpoint        - Endpoint to Add

Return Value:

    None.

--*/

{
    POHCD_ENDPOINT *listHead;
    PULONG          listHeadPhysical;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Control Pipe
    //
    if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
    {
        listHead            = &DeviceExtension->Schedule.ControlHead;
        listHeadPhysical    = &DeviceExtension->OperationalRegisters->HcControlHeadED;
    }
    else
    //
    //  Bulk pipe
    //
    {
        listHead            = &DeviceExtension->Schedule.BulkHead;
        listHeadPhysical    = &DeviceExtension->OperationalRegisters->HcBulkHeadED;
    }
    //
    //  insert at head
    //
    Endpoint->Next = *listHead;
    *listHead = Endpoint;
    //
    //  Fixup physical pointers
    //
    if(NULL == Endpoint->Next)
    {
        Endpoint->HcEndpointDescriptor.NextED = 0;
    }
    else
    {
        Endpoint->HcEndpointDescriptor.NextED =
                    Endpoint->Next->PhysicalAddress;
    }
    *listHeadPhysical = Endpoint->PhysicalAddress;
}

VOID
FASTCALL
OHCD_ScheduleRemoveEndpointControlOrBulk(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    POHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Removes a control or bulk endpoint from the schedule.

Arguments:
    
    DeviceExtension - Pointer to OHCD's device extension.
    Endpoint        - Endpoint to remove

Return Value:

    None.

--*/
{
    POHCD_ENDPOINT *listHead;
    POHCD_ENDPOINT  previousEndpoint, currentEndpoint;
    PULONG          listHeadPhysical;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_ScheduleRemoveEndpointControlOrBulk"));

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Control Pipe
    //
    if(USB_ENDPOINT_TYPE_CONTROL == Endpoint->EndpointType)
    {
        listHead            = &DeviceExtension->Schedule.ControlHead;
        listHeadPhysical    = &DeviceExtension->OperationalRegisters->HcControlHeadED;
    }
    else
    //
    //  Bulk pipe
    //
    {
        listHead            = &DeviceExtension->Schedule.BulkHead;
        listHeadPhysical    = &DeviceExtension->OperationalRegisters->HcBulkHeadED;
    }

    //
    // Find the Endpoint in the list
    //
    previousEndpoint = NULL;
    currentEndpoint = *listHead;
    do
    {
        //stop when we find it
        if(Endpoint == currentEndpoint) break;
        previousEndpoint = currentEndpoint;
        currentEndpoint = currentEndpoint->Next;
    } while( currentEndpoint);
    ASSERT( NULL != currentEndpoint);

    //
    //  Remove from list (virtual and physical).
    //  Notice carefully that we do not change
    //  currentEndpoint->EndpointDescriptor->HcEndpointDescriptor.NextED.
    //  This way if this endpoint is being processed, nothing breaks.
    //  If we wait a frame we can safely remove it.  We do not even
    //  need to pause the endpoint!
    //
    if(previousEndpoint)
    {
        previousEndpoint->Next = currentEndpoint->Next;
        previousEndpoint->HcEndpointDescriptor.NextED =
            currentEndpoint->HcEndpointDescriptor.NextED;
    }
    else
    {
        *listHead = currentEndpoint->Next;
        *listHeadPhysical = 
            currentEndpoint->HcEndpointDescriptor.NextED;
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ScheduleRemoveEndpointControlOrBulk"));
}


//----------------------------------------------------------------------------
// Implementation of local helper routines:
//      OHCD_HookNewEndpointToChildren
//      OHCD_ReverseBits
//----------------------------------------------------------------------------

VOID
FASTCALL
OHCD_HookNewEndpointToChildren(
    POHCD_DEVICE_EXTENSION  DeviceExtension,
    ULONG                   EndpointPhysicalAddress,
    UCHAR                   ParentNode
    )
/*++

Routine Description:

    Helper function to recurse children in the schedule
    table and insert a pointer to the new endpoint.  Used
    for both inserting an endpoint and removing one.

Arguments:
    
    DeviceExtension - Pointer to OHCD's device extension.

Return Value:

    None.

--*/
{
    //USB_DBG_ENTRY_PRINT(("Entering OHCD_HookEndpointToChildren: ParentNode = %d", ParentNode));
    if(ParentNode >= 32)
    //
    //  This node is at the top of the
    //  tree, just fix up HCCA and we are done.
    //  
    {
        POHCI_HCCA  hcca;
        hcca = DeviceExtension->HCCA;
        hcca->InterruptTable[OHCD_ReverseBits(5, ParentNode - 32)] = 
            EndpointPhysicalAddress;
    }
    else
    //
    // Not at the top of the tree, we have two children,
    // deal with one at a time
    //
    {
        UCHAR nodeChild;
        UCHAR index;
        POHCD_INTERRUPT_SCHEDULE_NODE interruptSchedule;
        interruptSchedule = &DeviceExtension->Schedule.InterruptSchedule[0];
        nodeChild = OHCD_GET_CHILD2_INTERRUPT_INDEX(ParentNode);
        for(index = 0; index < 2; index ++) 
        {
            if(NULL == interruptSchedule[nodeChild].EndpointHead)
            //
            //  If this node is empty, skip it and go on to its children
            //
            {
                ASSERT(NULL == interruptSchedule[nodeChild].EndpointTail);
                //USB_DBG_TRACE_PRINT(("Node %d is empty, recursing", nodeChild));
                OHCD_HookNewEndpointToChildren(
                                    DeviceExtension,
                                    EndpointPhysicalAddress,
                                    nodeChild
                                    );
            }
            else
            //
            //  We can fix up this child.
            //
            {
                ASSERT(NULL != interruptSchedule[nodeChild].EndpointTail);
                /*USB_DBG_WARN_PRINT(("Node %d has members: Head = 0x%0.8x; Tail = 0x%0.8x",
                                            nodeChild,
                                            interruptSchedule[nodeChild].EndpointHead,
                                            interruptSchedule[nodeChild].EndpointTail));*/
                interruptSchedule[nodeChild].EndpointTail->HcEndpointDescriptor.NextED = EndpointPhysicalAddress;
            }
            nodeChild = OHCD_GET_CHILD1_INTERRUPT_INDEX(ParentNode);
            //
            //  It is possible that this is the isochronous node,
            //  if so skip the second iteration.
            if(!nodeChild) break;
        }
    }
    //USB_DBG_EXIT_PRINT(("Exiting OHCD_HookEndpointToChildren: ParentNode = %d", ParentNode));
    return;
}

ULONG 
FASTCALL
OHCD_ReverseBits(
    ULONG NumBits,
    ULONG Value)
/*++

Routine Description:

    Helper function to reverse the NumBits
    least significant bits of value (Assume
    remaining bits are 0).

Arguments:
    
    NumBits - number of bits to reverse.
    Value   - value to reverse.

Return Value:

    None.

--*/
{
    ULONG result = 0;
    ULONG index;
    for(index = 0; index < NumBits; index++)
    {
        result <<= 1;
        result += Value&1;
        Value >>= 1;
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbd\usbd.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    usbd.h

    Generated from usb.x

Abstract:

    Private Header for USBD internal modules

Environment:

    Xbox
    C++ Only

--*/

#ifndef __USB_X__
#define __USB_X__

#ifndef __cplusplus
#error "usb.h may only be included by C++ modules"
#endif

#define EXTERNUSB extern "C"

//
//	USB drivers, and XAPI code modules that rely on USB all go into 
//	the XPP section.
//
#pragma code_seg(".XPPCODE")
#pragma data_seg(".XPP$Data")
#pragma const_seg(".XPPRDATA")

#include <usb100.h>

//
// XBOX platform USB device classes
//

#define XBOX_DEVICE_CLASS_INPUT_DEVICE              0x58
#define XBOX_DEVICE_CLASS_XDCS                      0x59
#define XBOX_DEVICE_CLASS_AUDIO_DEVICE              0x78

//
// USBD status codes
//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+---------------------------+-------------------------------+
//  | S |               Status Code                                 |
//  +---+---------------------------+-------------------------------+
//
//  where
//
//      S - is the state code
//
//          00 - completed with success
//          01 - request is pending
//          10 - completed with error, endpoint not stalled
//          11 - completed with error, endpoint stalled
//
//
//      Code - is the status code
//

typedef LONG USBD_STATUS;

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define USBD_SUCCESS(Status) ((USBD_STATUS)(Status) >= 0)

//
// Generic test for pending status value.
//

#define USBD_PENDING(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for error on any status value.
//

#define USBD_ERROR(Status) ((USBD_STATUS)(Status) < 0)

//
//  Macro to ensure that error bit is set.
//
#define SET_USBD_ERROR(err)  ((err) | USBD_STATUS_ERROR)


//
// Generic test for stall on any status value.
//

#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)

#define USBD_STATUS_SUCCESS                  ((USBD_STATUS)0x00000000L)
#define USBD_STATUS_PENDING                  ((USBD_STATUS)0x40000000L)
#define USBD_STATUS_HALTED                   ((USBD_STATUS)0xC0000000L)
#define USBD_STATUS_ERROR                    ((USBD_STATUS)0x80000000L)

//
// HC status codes
// Note: these status codes have both the error and the stall bit set.
//
#define USBD_STATUS_CRC                      ((USBD_STATUS)0xC0000001L)
#define USBD_STATUS_BTSTUFF                  ((USBD_STATUS)0xC0000002L)
#define USBD_STATUS_DATA_TOGGLE_MISMATCH     ((USBD_STATUS)0xC0000003L)
#define USBD_STATUS_STALL_PID                ((USBD_STATUS)0xC0000004L)
#define USBD_STATUS_DEV_NOT_RESPONDING       ((USBD_STATUS)0xC0000005L)
#define USBD_STATUS_PID_CHECK_FAILURE        ((USBD_STATUS)0xC0000006L)
#define USBD_STATUS_UNEXPECTED_PID           ((USBD_STATUS)0xC0000007L)
#define USBD_STATUS_DATA_OVERRUN             ((USBD_STATUS)0xC0000008L)
#define USBD_STATUS_DATA_UNDERRUN            ((USBD_STATUS)0xC0000009L)
#define USBD_STATUS_RESERVED1                ((USBD_STATUS)0xC000000AL)
#define USBD_STATUS_RESERVED2                ((USBD_STATUS)0xC000000BL)
#define USBD_STATUS_BUFFER_OVERRUN           ((USBD_STATUS)0xC000000CL)
#define USBD_STATUS_BUFFER_UNDERRUN          ((USBD_STATUS)0xC000000DL)
#define USBD_STATUS_NOT_ACCESSED             ((USBD_STATUS)0xC000000EL)
#define USBD_STATUS_FIFO                     ((USBD_STATUS)0xC0000010L)

//
// HC status codes
// Note: these status codes have the error bit and not the stall bit set.
//
#define USBD_ISOCH_STATUS_CRC                      (1)
#define USBD_ISOCH_STATUS_BTSTUFF                  (2)
#define USBD_ISOCH_STATUS_DATA_TOGGLE_MISMATCH     (3)
#define USBD_ISOCH_STATUS_STALL_PID                (4)
#define USBD_ISOCH_STATUS_DEV_NOT_RESPONDING       (5)
#define USBD_ISOCH_STATUS_PID_CHECK_FAILURE        (6)
#define USBD_ISOCH_STATUS_UNEXPECTED_PID           (7)
#define USBD_ISOCH_STATUS_DATA_OVERRUN             (8)
#define USBD_ISOCH_STATUS_DATA_UNDERRUN            (9)
#define USBD_ISOCH_STATUS_RESERVED1                (A)
#define USBD_ISOCH_STATUS_RESERVED2                (B)
#define USBD_ISOCH_STATUS_BUFFER_OVERRUN           (C)
#define USBD_ISOCH_STATUS_BUFFER_UNDERRUN          (D)
#define USBD_ISOCH_STATUS_NOT_ACCESSED             (E)

//
// returned by HCD if a transfer is submitted to an endpoint that is 
// stalled
//
#define USBD_STATUS_ENDPOINT_HALTED         ((USBD_STATUS)0xC0000030L)

//
// Software status codes
// Note: the following status codes have only the error bit set
//
#define USBD_STATUS_NO_MEMORY                ((USBD_STATUS)0x80000100L)
#define USBD_STATUS_INVALID_URB_FUNCTION     ((USBD_STATUS)0x80000200L)
#define USBD_STATUS_INVALID_PARAMETER        ((USBD_STATUS)0x80000300L)
#define USBD_STATUS_UNSUPPORTED_DEVICE       ((USBD_STATUS)0x80000400L)
#define USBD_STATUS_TRANSFER_TOO_LONG        ((USBD_STATUS)0x80000500L)

//
// returned by USBD if it cannot complete a URB request, typically this 
// will be returned in the URB status field when the Irp is completed
// with a more specific NT error code in the irp.status field.
//
#define USBD_STATUS_REQUEST_FAILED           ((USBD_STATUS)0x80000600L)

#define USBD_STATUS_NO_DEVICE                ((USBD_STATUS)0x80000700L)

// returned when there is not enough bandwidth avialable
// to open a requested endpoint
#define USBD_STATUS_NO_BANDWIDTH             ((USBD_STATUS)0x80000800L)
//
// generic HC error
// 
#define USBD_STATUS_INTERNAL_HC_ERROR        ((USBD_STATUS)0x80000900L)
//
// returned when a short packet terminates the transfer
// ie USBD_SHORT_TRANSFER_OK bit not set
// 
#define USBD_STATUS_ERROR_SHORT_TRANSFER     ((USBD_STATUS)0x80000A00L)


// 
// returned if the requested start frame is not within
// USBD_ISOCH_START_FRAME_RANGE of the current USB frame, 
// note that the stall bit is set
// 
#define USBD_STATUS_BAD_START_FRAME          ((USBD_STATUS)0xC0000B00L)
//
// returned by HCD if all packets in an iso transfer complete with an error 
//
#define USBD_STATUS_ISOCH_REQUEST_FAILED     ((USBD_STATUS)0xC0000C00L)
//
// returned by HCD if an attempt is made to attach more isoch
// buffers to an endpoint than specified as the maximum when opening
// the endpoint.
//
#define USBD_STATUS_ISOCH_TOO_MANY_BUFFERS   ((USBD_STATUS)0xC0000D00L)
//
// returned by HCD if an attempt is made to start an endpoint which is
// already started.
//
#define USBD_STATUS_ISOCH_ALREADY_STARTED    ((USBD_STATUS)0xC0000E00L)
//
// returned by HCD if an attempt is made to stop an endpoint which is
// not already started.
//
#define USBD_STATUS_ISOCH_NOT_STARTED        ((USBD_STATUS)0xC0000F00L)
//
// returned by HCD if an attempt is made to start an endpoint setup for
// circular DMA with fewer than MaxAttachedBuffers,
//
#define USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS ((USBD_STATUS)0xC0001000L)
//
// This build of the usb driver does not support isochronous requests.
//
#define USBD_STATUS_ISOCH_NOT_SUPPORTED      ((USBD_STATUS)0xC0002000L)
//
// set when a transfers is completed due to an AbortPipe request from
// the client driver
//
#define USBD_STATUS_CANCELED                 ((USBD_STATUS)0xC000000FL)
#define USBD_STATUS_CANCELING                ((USBD_STATUS)0x40020000L)

//
//	Status returned by hub, when a reset completes successfully and the
//	device is low-speed.
//
#define USBD_STATUS_LOWSPEED				 ((USBD_STATUS)0x01000000L)

extern "C" {

//------------------------------------------------------------------------------------
// URB Function Codes   - High bit indicates that USBD (pre-)processes URB
//------------------------------------------------------------------------------------
//-- special bit in URB_FUNCTION codes -----------------
#define URB_FUNCTION_USBD_PROCESSED                 0x80    
#define URB_FUNCTION_ASYNCHRONOUS                   0x40
//------------------------------------------------------
#define URB_FUNCTION_CONTROL_TRANSFER               (0x00 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER     (0x01 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_OPEN_ENDPOINT                  0x02
#define URB_FUNCTION_CLOSE_ENDPOINT                 (0x03 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_ENDPOINT_STATE             0x04
#define URB_FUNCTION_SET_ENDPOINT_STATE             0x05
#define URB_FUNCTION_ABORT_ENDPOINT                 (0x06 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_FRAME_NUMBER               0x07
#define URB_FUNCTION_OPEN_DEFAULT_ENDPOINT          (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_OPEN_ENDPOINT)
#define URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT         (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_CLOSE_ENDPOINT)
#define URB_FUNCTION_RESET_PORT                     (URB_FUNCTION_USBD_PROCESSED | 0x08)
#define URB_FUNCTION_ISOCH_OPEN_ENDPOINT            0x09
#define URB_FUNCTION_ISOCH_CLOSE_ENDPOINT           (0x0A | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_ISOCH_ATTACH_BUFFER            0x0B
#define URB_FUNCTION_ISOCH_START_TRANSFER           0x0C
#define URB_FUNCTION_ISOCH_STOP_TRANSFER            0x0D

//------------------------------------------------------------------------------------
//  Values for the transfer directions
//------------------------------------------------------------------------------------
#define USB_TRANSFER_DIRECTION_OUT              0x01
#define USB_TRANSFER_DIRECTION_IN               0x02

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_GET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_HALTED              	0x01    //Set on return if endpoint is halted.
#define USB_ENDPOINT_STATE_TRANSFERS_QUEUED     0x02    //Set on return if one or more transfers are queued to endpoint.

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_SET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_CLEAR_HALT		    0x00    //Clear endpoint halt.
#define USB_ENDPOINT_STATE_KEEP_HALT		    0x01    //Do not clear enddpoint halt
#define USB_ENDPOINT_STATE_DATA_TOGGLE_RESET    0x04    //Reset data toggle. (i.e. DATA0)
#define USB_ENDPOINT_STATE_DATA_TOGGLE_SET      0x08    //Set data toggle. (i.e. DATA1), provided for testing.
//There is no USB_ENDPOINT_STATE_SET_HALT, since only the hardware may set it.

//----------------------------------------------------------------------------------------------------------------------
// Macros for the InterruptDelay variable in transfer and attach buffer URBs - this is really an OpenHCI thing,
// but gives more control to class drivers.  These are the same as OHCI_TD_DELAY_INTERRUPT_XXX
// DUE TO BUG 9512 IT IS ONLY SAFE TO USE USBD_DELAY_INTERRUPT_0_MS.  OTHERWISE, YOU MAY EXPERIENCE PROBLEMS
// WHEN CLOSING THE ENDPOINT.  SEE BUG 9512 FOR MORE DETAILS.
//----------------------------------------------------------------------------------------------------------------------
#define USBD_DELAY_INTERRUPT_0_MS        0   // Interrupt at end of frame TD is completed
#define USBD_DELAY_INTERRUPT_1_MS        1   // Interrupt within 1 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_2_MS        2   // Interrupt within 2 frames of TD compeletion
#define USBD_DELAY_INTERRUPT_3_MS        3   // Interrupt within 3 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_4_MS        4   // Interrupt within 4 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_5_MS        5   // Interrupt within 5 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_6_MS        6   // Interrupt within  frame of TD compeletion
#define USBD_DELAY_INTERRUPT_NONE        7   // Do not Interrupt upon completion of TD

//------------------------------------------------------------------------------------
// USBD Structures for class drivers
//------------------------------------------------------------------------------------
typedef union _URB *PURB;
typedef VOID (*PURB_COMPLETE_PROC)(PURB Urb, PVOID Context);

//
//  See approptate HCD header file for
//  for flags.
//
struct _URB_HCD_AREA
{
    union
    {
        USHORT  HcdTDCount;
        USHORT  HcdOriginalLength;  //While programed contains the original length
    
	};
    USHORT  HcdUrbFlags;
	PURB    HcdUrbLink;     //Used while the URB is pending
};

struct _URB_HEADER
{
    UCHAR               Length;
    UCHAR               Function;
    USBD_STATUS         Status;
    PURB_COMPLETE_PROC  CompleteProc;       // A completetion routine if the URB is not associated with an Irp
    PVOID               CompleteContext;    // Context to pass into the completion routine.
};

typedef struct _USB_CONTROL_SETUP_PACKET
{
    UCHAR   bmRequestType;
    UCHAR   bRequest;
    USHORT  wValue;
    USHORT  wIndex;
    USHORT  wLength;
} USB_CONTROL_SETUP_PACKET;

typedef struct _URB_CONTROL_TRANSFER
{
    struct _URB_HEADER          Hdr;                    
    PVOID                       EndpointHandle;
    ULONG                       TransferBufferLength;
    PVOID                       TransferBuffer;
    UCHAR                       TransferDirection;
    BOOLEAN                     ShortTransferOK;
    UCHAR                       InterruptDelay;
    UCHAR                       Padding;
    struct _URB_HCD_AREA        Hca;
    USB_CONTROL_SETUP_PACKET    SetupPacket;
} URB_CONTROL_TRANSFER, *PURB_CONTROL_TRANSFER;

typedef struct _URB_BULK_OR_INTERRUPT_TRANSFER
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   TransferBufferLength;
    PVOID                   TransferBuffer;
    UCHAR                   TransferDirection;
    BOOLEAN                 ShortTransferOK;
    UCHAR                   InterruptDelay;
    UCHAR                   Padding;
    struct _URB_HCD_AREA    Hca;   // fields for HCD use
} URB_BULK_OR_INTERRUPT_TRANSFER, *PURB_BULK_OR_INTERRUPT_TRANSFER;


typedef struct _URB_OPEN_ENDPOINT
{
    struct _URB_HEADER          Hdr;
    PVOID                       EndpointHandle;
    UCHAR                       FunctionAddress;
    UCHAR                       EndpointAddress;
    UCHAR                       EndpointType;
    UCHAR                       Interval;
    PULONG                      DataToggleBits; // Filled out by USBD
    USHORT                      MaxPacketSize;
    BOOLEAN                     LowSpeed;   //Temporary - filled out by USBD
} URB_OPEN_ENDPOINT, *PURB_OPEN_ENDPOINT;

typedef struct _URB_CLOSE_ENDPOINT
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    PURB                   HcdNextClose;   // An extra pointer which Hcd can use to link pending closes.
    PULONG                 DataToggleBits; // Filled out by USBD
} URB_CLOSE_ENDPOINT, *PURB_CLOSE_ENDPOINT;

typedef struct _URB_GET_SET_ENDPOINT_STATE
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   EndpointState;
} URB_GET_SET_ENDPOINT_STATE, *PURB_GET_SET_ENDPOINT_STATE;

typedef struct _URB_ABORT_ENDPOINT
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    PURB                    HcdNextAbort;   // An extra pointer which Hcd can use to link pending aborts.
} URB_ABORT_ENDPOINT, *PURB_ABORT_ENDPOINT;

typedef struct _URB_RESET_PORT
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    UCHAR               PortNumber;
} URB_RESET_PORT, *PURB_RESET_PORT;

typedef struct _URB_GET_FRAME_NUMBER
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    ULONG               FrameNumber;
} URB_GET_FRAME_NUMBER, *PURB_GET_FRAME_NUMBER;


//------------------------------------------------
// Isoch related URBs and related structures
//------------------------------------------------
typedef struct _USBD_ISOCH_PACKET_STATUS_WORD
{
    USHORT BytesRead:12;
    USHORT ConditionCode:4;
} USBD_ISOCH_PACKET_STATUS_WORD, *PUSBD_ISOCH_PACKET_STATUS_WORD;

typedef struct _USBD_ISOCH_TRANSFER_STATUS
{
    USBD_STATUS                     Status;
    ULONG                           FrameCount;
    USBD_ISOCH_PACKET_STATUS_WORD   PacketStatus[8];
} USBD_ISOCH_TRANSFER_STATUS, *PUSBD_ISOCH_TRANSFER_STATUS;

typedef VOID (*PFNUSBD_ISOCH_TRANSFER_COMPLETE)(PUSBD_ISOCH_TRANSFER_STATUS Status, PVOID Context);

typedef struct _USBD_ISOCH_BUFFER_DESCRIPTOR
{
    ULONG                               FrameCount;
    PVOID                               TransferBuffer;
    USHORT                              Pattern[8];
    PFNUSBD_ISOCH_TRANSFER_COMPLETE     TransferComplete;
    PVOID                               Context;
} USBD_ISOCH_BUFFER_DESCRIPTOR, *PUSBD_ISOCH_BUFFER_DESCRIPTOR;

typedef struct _URB_ISOCH_ATTACH_BUFFER
{
    struct _URB_HEADER            Hdr;
    PVOID                         EndpointHandle;
    UCHAR                         InterruptDelay;
    PUSBD_ISOCH_BUFFER_DESCRIPTOR BufferDescriptor;
} URB_ISOCH_ATTACH_BUFFER, *PURB_ISOCH_ATTACH_BUFFER;

typedef struct _URB_ISOCH_START_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    ULONG                  FrameNumber;
    ULONG                  Flags;
} URB_ISOCH_START_TRANSFER, *PURB_ISOCH_START_TRANSFER;
#define URB_FLAG_ISOCH_START_ASAP 0x0001
#define USBD_ISOCH_START_FRAME_RANGE 1024

typedef struct _URB_ISOCH_STOP_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
} URB_ISOCH_STOP_TRANSFER, *PURB_ISOCH_STOP_TRANSFER;

typedef struct _URB_ISOCH_OPEN_ENDPOINT
{
    struct _URB_HEADER              Hdr;
    PVOID                           EndpointHandle;
    UCHAR                           FunctionAddress;
    UCHAR                           EndpointAddress;
    USHORT                          MaxPacketSize;
    USHORT                          Flags;
    USHORT                          Pad;
} URB_ISOCH_OPEN_ENDPOINT, *PURB_ISOCH_OPEN_ENDPOINT;
#define URB_FLAG_ISOCH_CIRCULAR_DMA 0x0001

typedef struct _URB_CLOSE_ENDPOINT URB_ISOCH_CLOSE_ENDPOINT, *PURB_ISOCH_CLOSE_ENDPOINT;

//------------------------------------------------
// Union of all URBs
//------------------------------------------------
typedef union _URB
{
    struct _URB_HEADER              Header;
    URB_CONTROL_TRANSFER            ControlTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  BulkOrInterruptTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  CommonTransfer;
    URB_OPEN_ENDPOINT               OpenEndpoint;
    URB_CLOSE_ENDPOINT              CloseEndpoint;
    URB_GET_SET_ENDPOINT_STATE      GetSetEndpointState;
    URB_ABORT_ENDPOINT              AbortEndpoint;
    URB_RESET_PORT                  ResetPort;
    URB_GET_FRAME_NUMBER            GetFrame;
    URB_ISOCH_ATTACH_BUFFER         IsochAttachBuffer;
    URB_ISOCH_START_TRANSFER        IsochStartTransfer;
    URB_ISOCH_STOP_TRANSFER         IsochStopTransfer;
    URB_ISOCH_OPEN_ENDPOINT         IsochOpenEndpoint;
    URB_ISOCH_CLOSE_ENDPOINT        IsochCloseEndpoint;
} URB;

//------------------------------------------------------------------------------------
// Macros to build USB Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CONTROL_TRANSFER(\
                        _UrbControlTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_,\
                        _bmRequestType_,\
                        _bRequest_,\
                        _wValue_,\
                        _wIndex_,\
                        _wLength_\
    )\
    {\
        (_UrbControlTransfer_)->Hdr.Length                  =   sizeof(URB_CONTROL_TRANSFER);\
        (_UrbControlTransfer_)->Hdr.Function                =   URB_FUNCTION_CONTROL_TRANSFER;\
        (_UrbControlTransfer_)->Hdr.CompleteProc            =   (_CompleteProc_);\
        (_UrbControlTransfer_)->Hdr.CompleteContext         =   (_CompleteContext_);\
        (_UrbControlTransfer_)->EndpointHandle              =   (_EndpointHandle_);\
        (_UrbControlTransfer_)->TransferBuffer              =   (_TransferBuffer_);\
        (_UrbControlTransfer_)->TransferBufferLength        =   (_TransferBufferLength_);\
        (_UrbControlTransfer_)->TransferDirection           =   (_TransferDirection_);\
        (_UrbControlTransfer_)->ShortTransferOK             =   (_ShortTransferOK_);\
        (_UrbControlTransfer_)->InterruptDelay              =   USBD_DELAY_INTERRUPT_0_MS;\
        (_UrbControlTransfer_)->SetupPacket.bmRequestType   =   (_bmRequestType_);\
        (_UrbControlTransfer_)->SetupPacket.bRequest        =   (_bRequest_);\
        (_UrbControlTransfer_)->SetupPacket.wValue          =   (_wValue_);\
        (_UrbControlTransfer_)->SetupPacket.wIndex          =   (_wIndex_);\
        (_UrbControlTransfer_)->SetupPacket.wLength         =   (_wLength_);\
    }


#define USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(\
                        _UrbBulkOrInterruptTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_\
    )\
    {\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Length          =   sizeof(URB_BULK_OR_INTERRUPT_TRANSFER);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Function        =   URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteProc    =   (_CompleteProc_);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteContext =   (_CompleteContext_);\
        (_UrbBulkOrInterruptTransfer_)->EndpointHandle      =   (_EndpointHandle_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBuffer      =   (_TransferBuffer_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBufferLength=   (_TransferBufferLength_);\
        (_UrbBulkOrInterruptTransfer_)->TransferDirection   =   (_TransferDirection_);\
        (_UrbBulkOrInterruptTransfer_)->ShortTransferOK     =   (_ShortTransferOK_);\
        (_UrbBulkOrInterruptTransfer_)->InterruptDelay      =   USBD_DELAY_INTERRUPT_0_MS;\
    }

//
// Isoch requests
//

#define USB_BUILD_ISOCH_OPEN_ENDPOINT(\
                        _UrbIsochOpenEndpoint_,\
                        _EndpointAddress_,\
                        _MaxPacketSize_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochOpenEndpoint_)->Hdr.Length         =   sizeof(URB_ISOCH_OPEN_ENDPOINT);\
        (_UrbIsochOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_ISOCH_OPEN_ENDPOINT;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteContext=   NULL;\
        (_UrbIsochOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbIsochOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
        (_UrbIsochOpenEndpoint_)->Flags              =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_CLOSE_ENDPOINT(\
                        _UrbIsochCloseEndpoint_,\
                        _EndpointHandle_,\
						_CompleteProc_,\
						_CompleteContext_\
    )\
    {\
        (_UrbIsochCloseEndpoint_)->Hdr.Length           =   sizeof(URB_ISOCH_CLOSE_ENDPOINT);\
        (_UrbIsochCloseEndpoint_)->Hdr.Function         =   URB_FUNCTION_ISOCH_CLOSE_ENDPOINT;\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteProc     =   (_CompleteProc_);\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteContext  =   (_CompleteContext_);\
        (_UrbIsochCloseEndpoint_)->EndpointHandle       =   (_EndpointHandle_);\
    }

#define USB_BUILD_ISOCH_START_TRANSFER(\
                        _UrbIsochStartTransfer_,\
                        _EndpointHandle_,\
                        _FrameNumber_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochStartTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_START_TRANSFER);\
        (_UrbIsochStartTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_START_TRANSFER;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStartTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochStartTransfer_)->FrameNumber          =   (_FrameNumber_);\
        (_UrbIsochStartTransfer_)->Flags                =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_STOP_TRANSFER(\
                        _UrbIsochStopTransfer_,\
                        _EndpointHandle_\
    )\
    {\
        (_UrbIsochStopTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_STOP_TRANSFER);\
        (_UrbIsochStopTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_STOP_TRANSFER;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStopTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
    }


#define USB_BUILD_ISOCH_ATTACH_BUFFER(\
                        _UrbIsochAttachBuffer_,\
                        _EndpointHandle_,\
                        _InterruptDelay_,\
                        _BufferDescriptor_\
    )\
    {\
        (_UrbIsochAttachBuffer_)->Hdr.Length            =   sizeof(URB_ISOCH_ATTACH_BUFFER);\
        (_UrbIsochAttachBuffer_)->Hdr.Function          =   URB_FUNCTION_ISOCH_ATTACH_BUFFER;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteProc      =   NULL;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteContext   =   NULL;\
        (_UrbIsochAttachBuffer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochAttachBuffer_)->InterruptDelay       =   (_InterruptDelay_);\
        (_UrbIsochAttachBuffer_)->BufferDescriptor     =   (_BufferDescriptor_);\
    }

//
// Bulk or Interrupt requests
//

#define USB_BUILD_OPEN_ENDPOINT(\
                        _UrbOpenEndpoint_,\
                        _EndpointAddress_,\
                        _EndpointType_,\
                        _MaxPacketSize_,\
                        _Interval_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbOpenEndpoint_)->EndpointType       =   (_EndpointType_);\
        (_UrbOpenEndpoint_)->Interval           =   (_Interval_);\
        (_UrbOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
    }

#define USB_BUILD_CLOSE_ENDPOINT(\
                        _UrbCloseEndpoint_,\
                        _EndpointHandle_,\
                        _CompleteProc_,\
                        _CompleteContext_\
    )\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
        (_UrbCloseEndpoint_)->EndpointHandle    =   (_EndpointHandle_);\
    }

#define USB_BUILD_OPEN_DEFAULT_ENDPOINT(\
                            _UrbOpenEndpoint_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_DEFAULT_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
    }

#define USB_BUILD_CLOSE_DEFAULT_ENDPOINT(_UrbCloseEndpoint_, _CompleteProc_, _CompleteContext_)\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
    }

#define USB_BUILD_GET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_GET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_SET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_, _StateFlags_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_SET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
    (_UrbGetSetEndpointState_)->EndpointState       =   (_StateFlags_);\
}

#define USB_BUILD_ABORT_ENDPOINT(_UrbAbortEndpoint_, _EndpointHandle_, _CompleteProc_, _CompleteContext_)\
{\
    (_UrbAbortEndpoint_)->Hdr.Length          =   sizeof(URB_ABORT_ENDPOINT);\
    (_UrbAbortEndpoint_)->Hdr.Function        =   URB_FUNCTION_ABORT_ENDPOINT;\
    (_UrbAbortEndpoint_)->Hdr.CompleteProc    =   (_CompleteProc_);\
	(_UrbAbortEndpoint_)->Hdr.CompleteContext =   (_CompleteContext_);\
    (_UrbAbortEndpoint_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_RESET_PORT(_UrbResetPort_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_RESET_PORT);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_RESET_PORT;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

#define USB_BUILD_GET_FRAME(_UrbGetFrame_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_GET_FRAME);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_GET_FRAME;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

//------------------------------------------------------------------------------------
// Macros to build standard USB Command Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CLEAR_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_CLEAR_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_SET_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_GET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Configuration_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_Configuration_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = TRUE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}

#define USB_BUILD_SET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_OUT;\
    (_UrbControlTransfer_)->ShortTransferOK             = FALSE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}


#define USB_BUILD_GET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_AlternateSetting_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_AlternateSetting_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_STATUS(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _Index_,\
                _Status_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Status_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|(_Recipient_));\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_STATUS;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

#define USB_BUILD_SYNC_FRAME(\
                _UrbControlTransfer_,\
                _Endpoint_,\
                _Frame_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Frame_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|USB_COMMAND_TO_ENDPOINT);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SYNC_FRAME;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Endpoint_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

//-------------------------------------------------------------------------------------------------------------
// Get the USB status code
//-------------------------------------------------------------------------------------------------------------
#define URB_STATUS(urb) ((urb)->Header.Status)
} //end of 'extern "C"'
//------------------------------------------------------------------------------------
// bmRequestType values for commands over control pipes, belongs in usb100.h
//------------------------------------------------------------------------------------

//  Data Direction
#define USB_HOST_TO_DEVICE              0x00    
#define USB_DEVICE_TO_HOST              0x80

//  Type
#define USB_STANDARD_COMMAND            0x00
#define USB_CLASS_COMMAND               0x20
#define USB_VENDOR_COMMAND              0x40

//  Recipient
#define USB_COMMAND_TO_DEVICE           0x00
#define USB_COMMAND_TO_INTERFACE        0x01
#define USB_COMMAND_TO_ENDPOINT         0x02
#define USB_COMMAND_TO_OTHER            0x03

//------------------------------------------------------------------------------------
// The enumerator only provides the first eight bytes of the device descriptor
//------------------------------------------------------------------------------------
typedef struct _USB_DEVICE_DESCRIPTOR8 {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
} USB_DEVICE_DESCRIPTOR8, *PUSB_DEVICE_DESCRIPTOR8;
//---------------------------------------------------------------------------------------------------------------
// USB_HOST_CONTROLLER - Host Controller Configuration Selection
//---------------------------------------------------------------------------------------------------------------
#define USB_SINGLE_HOST_CONTROLLER 1
#define USB_DUAL_HOST_CONTROLLER_XDK 2
//  Select which configuragtion to use.

#ifndef USB_HOST_CONTROLLER_CONFIGURATION
#ifdef SILVER
#define USB_HOST_CONTROLLER_CONFIGURATION USB_DUAL_HOST_CONTROLLER_XDK
#else  //!SILVER
#define USB_HOST_CONTROLLER_CONFIGURATION USB_SINGLE_HOST_CONTROLLER
#endif ////!SILVER
#endif  USB_HOST_CONTROLLER_CONFIGURATION


#
//------------------------------------------------------------------------------------
//  Forward declaration of classes
//------------------------------------------------------------------------------------
class IUsbDevice;
class CDeviceTree;

//---------------------------------------------------------------------------------------------------------------
// USBD_HOST_CONTROLLER - Context of USBD by host controller.  Instead of a DEVICE_OBJECT
//---------------------------------------------------------------------------------------------------------------
#pragma warning(disable : 4200) //Turn off zero length array warning
typedef struct _USBD_HOST_CONTROLLER
{
    ULONG           ControllerNumber;   //Number of this controller.
    IUsbDevice      *RootHub;           //Root Hub
    ULONG           AddressList[4];     //128 bit bitfield of used USB addresses.
    ULONG           HcdExtension[0];    //The Host controllers extension starts here.
} USBD_HOST_CONTROLLER, *PUSBD_HOST_CONTROLLER;
#pragma warning(default : 4200) //Turn zero length array warning back on

//
//  Stuff related to the Host Controller Driver, its endpoint size and its extension
//
extern ULONG GLOBAL_HostControllerExtensionSize;
#define USBD_GetHCDExtension(_UsbdHostController_) ((PVOID)(_UsbdHostController_->HcdExtension))
#define USBD_HostControllerFromHCDExtension(_HCDExtension_)  CONTAINING_RECORD(_HCDExtension_, USBD_HOST_CONTROLLER, HcdExtension)

//---------------------------------------------------------------------------------------------------------------
//  Types of USB Device Nodes.
//      UDN_TYPE_HUB                - represents a hub device.
//      UDN_TYPE_FUNCTION           - a USB function for which bDeviceClass != 0.
//      UDN_TYPE_INTERFACE_FUNCTION - a USB function where bDeviceClass is 0, but there is only one interface.
//      UDN_TYPE_COMPOSITE_FUNCTION - a USB function where bDeviceClass is 0, and there are multiple interfaces.
//                                    a COMPOSITE_FUNCTION always has one INTERFACE child be interface.   
//      UDN_TYPE_INTERFACE          - represents an INTERFACE on a COMPOSITE_FUNCTION.
//===============================================================================================================
//  Special types not signifying a device
//      UDN_TYPE_UNUSED             - Not currently representing a device.  Node should be on the free list.
//      UDN_TYPE_PENDING_ENUM       - Device has been detected, but is in the list of nodes awaiting enumeration.
//      UDN_TYPE_ENUMERATING        - Device is currently being enumerated, but has not reached a stage of enumeration
//                                    yet where the node type is known.
//---------------------------------------------------------------------------------------------------------------
#define UDN_TYPE_ROOT_HUB           0
#define UDN_TYPE_HUB                1
#define UDN_TYPE_FUNCTION           2
#define UDN_TYPE_INTERFACE_FUNCTION 3
#define UDN_TYPE_COMPOSITE_FUNCTION 4
#define UDN_TYPE_INTERFACE          5
#define UDN_TYPE_UNUSED             0xFF    
#define UDN_TYPE_PENDING_ENUM       0xFE
#define UDN_TYPE_ENUMERATING        0xFD

//---------------------------------------------------------------------------------------------------------------
//  Device node constants
//---------------------------------------------------------------------------------------------------------------
#define UDN_INVALID_NODE_INDEX      128   // Indicates that index does not point to a valid node.

#define UDN_LOWSPEED_PORT           0x80
#define UDN_NO_CLASS_DRIVER_SUPPORT 0xFF
#define UDN_HUB_TYPE_EXTERNAL       0x01

//--------------------------------------------------------------------------------
//  Resource structure shared between USBD and OHCD
//--------------------------------------------------------------------------------
extern "C" {
#define HCD_INTERRUPT_TD_QUOTA 3
typedef struct _HCD_RESOURCE_REQUIREMENTS
{
    ULONG EndpointCount;
    ULONG IsochEndpointCount;
    ULONG TDCount;
    UCHAR ControlTDQuota;
    UCHAR BulkTDQuota;
    UCHAR IsochMaxBuffers;
} HCD_RESOURCE_REQUIREMENTS, *PHCD_RESOURCE_REQUIREMENTS;

} //end 'extern "C"'

//--------------------------------------------------------------------------------------------------------------
// Resource Requirements Structure
//--------------------------------------------------------------------------------------------------------------
typedef struct _USB_RESOURCE_REQUIREMENTS
{
    UCHAR ConnectorType;
    UCHAR MaxDevices;
    UCHAR MaxCompositeInterfaces;
    UCHAR MaxControlEndpoints;
    UCHAR MaxBulkEndpoints;
    UCHAR MaxInterruptEndpoints;
    UCHAR MaxControlTDperTransfer;
    UCHAR MaxBulkTDperTransfer;
    //Isoch
    UCHAR MaxIsochEndpoints;
    UCHAR MaxIsochMaxBuffers;
} USB_RESOURCE_REQUIREMENTS, *PUSB_RESOURCE_REQUIREMENTS;
//-------------------------------------------------------------------------------------------------
// This class is used to assist initialization.
//-------------------------------------------------------------------------------------------------
class IUsbInit
{
  public:
    ULONG GetMaxDeviceTypeCount(PXPP_DEVICE_TYPE XppDeviceType);
    VOID  RegisterResources(PUSB_RESOURCE_REQUIREMENTS pResourceRequirements);
    BOOL  UseDefaultCount();
    //c'tor
    IUsbInit(ULONG NumDeviceTypes, PXDEVICE_PREALLOC_TYPE DeviceTypes) :
      m_NumDeviceTypes(NumDeviceTypes), m_pDeviceTypes(DeviceTypes),
      m_NodeCount(0), m_MaxCompositeInterfaces(0)
      {
        RtlZeroMemory(m_Direct, sizeof(m_Direct));
        RtlZeroMemory(m_TopSlots, sizeof(m_TopSlots));
        RtlZeroMemory(m_BottomSlots, sizeof(m_BottomSlots));
        RtlZeroMemory(&m_HcdResources, sizeof(m_HcdResources));
      }

    //services for usbd to retrieve information
    void Process();
    inline UCHAR GetNodeCount() {return m_NodeCount;}
    inline UCHAR GetMaxCompositeInterfaces() {return m_MaxCompositeInterfaces;}
    inline PHCD_RESOURCE_REQUIREMENTS GetHcdResourcePtr() {return &m_HcdResources;}
  private:
    USB_RESOURCE_REQUIREMENTS m_Direct[5];
    USB_RESOURCE_REQUIREMENTS m_TopSlots[5];
    USB_RESOURCE_REQUIREMENTS m_BottomSlots[5];
    ULONG                     m_NumDeviceTypes;
    PXDEVICE_PREALLOC_TYPE    m_pDeviceTypes;
    // Fields valid after process
    UCHAR                     m_NodeCount;
    UCHAR                     m_MaxCompositeInterfaces;
    HCD_RESOURCE_REQUIREMENTS m_HcdResources;
};
//--------------------------------------------------------------------------------------------------------------
// Class Driver Static Registration 
//--------------------------------------------------------------------------------------------------------------
typedef union _PNP_CLASS_ID
{
    LONG AsLong;
    struct
    {
        UCHAR bClassSpecificType;
        UCHAR bClass;
        UCHAR bSubClass;
        UCHAR bProtocol;
    } USB;
} PNP_CLASS_ID, *PPNP_CLASS_ID;

// The high-bit of bClassSpecificType is set
// if the class driver has not indicated a class
// specific type.  Prior to calling AddDevice
// this is used to track whether this is a 
// device level or interface level class.
// 
// USB_CLASS_DRIVER_DECLARATION assumes PNP_INTERFACE_LEVEL_CLASS
// 
#define PNP_CLASS_SPECIFIC_TYPE_NOT_SET(bClassSpecificType) (bClassSpecificType&0x80)
#define PNP_DEVICE_LEVEL_CLASS    0x81
#define PNP_INTERFACE_LEVEL_CLASS 0x82

typedef
VOID
 (*PFNINIT_USB_DRIVER)(IUsbInit *UsbInit);

typedef
VOID
 (*PFNADD_USB_DEVICE)(
    IN IUsbDevice *Device
    );

typedef
VOID
 (*PFNREMOVE_USB_DEVICE)(
    IN IUsbDevice *Device
    );


typedef struct _USB_DEVICE_TYPE_DESCRIPTION
{
    PXPP_DEVICE_TYPE XppDeviceType;
} USB_DEVICE_TYPE_DESCRIPTION, *PUSB_DEVICE_TYPE_DESCRIPTION;

#define USB_CONNECTOR_TYPE_DIRECT     0  //Plugs directly into the front of xbox (or a hub port)
#define USB_CONNECTOR_TYPE_HIGH_POWER 1  //Plugs into a high power slot in gamepad
#define USB_CONNECTOR_TYPE_LOW_POWER  2  //Plugs into a high power or low power slot in gamepad

typedef struct _USB_CLASS_DRIVER_DESCRIPTION
{
    PNP_CLASS_ID                 ClassId;
    PFNINIT_USB_DRIVER           Init;
    PFNADD_USB_DEVICE            AddDevice;
    PFNREMOVE_USB_DEVICE         RemoveDevice;
    ULONG                        DeviceTypeCount;
    PXPP_DEVICE_TYPE             *DeviceTypes;
} USB_CLASS_DRIVER_DESCRIPTION, *PUSB_CLASS_DRIVER_DESCRIPTION;

#define DECLARE_XPP_TYPE(XppTypeName)\
EXTERNUSB XPP_DEVICE_TYPE XppTypeName##_TABLE = {0,0,0};

#define USB_DEVICE_TYPE_TABLE_BEGIN(ClassName)\
EXTERNUSB PXPP_DEVICE_TYPE ClassName##Types[]={

#define USB_DEVICE_TYPE_TABLE_ENTRY(XppDeviceType)\
                 (XppDeviceType)

#define USB_DEVICE_TYPE_TABLE_END() };

#define USB_CLASS_DRIVER_DECLARATION(ClassName, bClass, bSubClass, bProtocol)\
               EXTERNUSB VOID ClassName##Init(IUsbInit *UsbInit);\
               EXTERNUSB VOID ClassName##AddDevice(IUsbDevice *Device);\
               EXTERNUSB VOID ClassName##RemoveDevice(IUsbDevice *Device);\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description = {\
                    PNP_INTERFACE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DRIVER_DECLARATION_DUPLICATE(ClassName, DuplicateNumber, bClass, bSubClass, bProtocol)\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##DuplicateNumber##Description = {\
                    PNP_INTERFACE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DRIVER_DECLARATION_DEVICE_LEVEL(ClassName, bClass, bSubClass, bProtocol)\
               EXTERNUSB VOID ClassName##Init(IUsbInit *UsbInit);\
               EXTERNUSB VOID ClassName##AddDevice(IUsbDevice *Device);\
               EXTERNUSB VOID ClassName##RemoveDevice(IUsbDevice *Device);\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description = {\
                    PNP_DEVICE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DECLARATION_POINTER(ClassName)\
                EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION *ClassName##DescriptionPointer=&ClassName##Description;
#define USB_CLASS_DECLARATION_POINTER_DUPLICATE(ClassName, DuplicateNumber)\
                EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION *ClassName##DuplicateNumber##DescriptionPointer=\
                &ClassName##DuplicateNumber##Description;

#define REFERENCE_CLASS(ClassName)\
    EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description;\
    static USB_CLASS_DRIVER_DESCRIPTION *classMU = &(ClassName##Description);

//---------------------------------------------------------------------------------------------------------------
//  IUsbDevice is the main interface to the core driver
//---------------------------------------------------------------------------------------------------------------
class IUsbDevice
{
    public:
    /*  IUsbDevice methods calleable at any time by class driver*/
    USBD_STATUS SubmitRequest(PURB Urb);
    USBD_STATUS CancelRequest(PURB Urb);
    BOOLEAN IsHardwareConnected() const;
    PVOID GetExtension() const;
    PVOID SetExtension(PVOID Extension);
    UCHAR GetInterfaceNumber() const;
	void SetClassSpecificType(UCHAR ClassSpecificType);
    ULONG GetPort() const;

    /*  IUsbDevice methods related to device enumeration*/
    void AddComplete(USBD_STATUS UsbdStatus);
    void RemoveComplete();
    void DeviceNotResponding();

    /*  IUsbDevice methods calleable only at enum time*/
    const USB_DEVICE_DESCRIPTOR8 *GetDeviceDescriptor() const;
    const USB_CONFIGURATION_DESCRIPTOR *GetConfigurationDescriptor() const;
    const USB_INTERFACE_DESCRIPTOR *GetInterfaceDescriptor() const;
    const USB_ENDPOINT_DESCRIPTOR *GetEndpointDescriptor(UCHAR EndpointType, BOOLEAN Direction, UCHAR Index) const;
    
	/*  IUsbDevice methods used only by hubs */
    void DeviceConnected(UCHAR PortNumber, UCHAR RetryCount);
    void DeviceDisconnected(UCHAR PortNumber);
    void ResetComplete(USBD_STATUS UsbdStatus, PVOID Context);
    void DisableComplete(USBD_STATUS UsbdStatus, PVOID Context);

    /* static IUsbDevice methods */
    static ULONG Win32FromUsbdStatus(USBD_STATUS UsbdStatus);
	static NTSTATUS NtStatusFromUsbdStatus(USBD_STATUS UsbdStatus);
    /*  c'tor */
    IUsbDevice::IUsbDevice() : 
        m_Type(UDN_TYPE_UNUSED), m_NextFree(UDN_INVALID_NODE_INDEX),
        m_FirstChild(UDN_INVALID_NODE_INDEX), m_Sibling(UDN_INVALID_NODE_INDEX){}

    /* IUsbDevice short and sweet methods used in USBD, these are inline, but defined below due to declaration order */
    UCHAR			GetIndex() const;
    BOOLEAN			GetLowSpeed() const;
    UCHAR			GetHubPort() const;
    IUsbDevice		*GetParent() const;
    IUsbDevice		*GetFirstChild() const;
    IUsbDevice		*GetSibling() const;
    IUsbDevice		*FindChild(UCHAR PortNumber) const;
    void			InsertChild(IUsbDevice *child);
    BOOLEAN			RemoveChild(IUsbDevice *child);
    BOOLEAN			IsEnumTime() const;
    PNP_CLASS_ID    GetClassId() const;
    /* public helper function*/
    void            SetExternalPort();
	#ifndef SILVER
	void            SetExternalPortWithHub(IUsbDevice **pParentArray, UINT DeviceIndex);
	void            SetExternalPortWithoutHub(IUsbDevice **pParentArray, UINT DeviceIndex);
	#endif

    //
    //  These are not declared private as most of the code is already coded in C
    //  and manipulates this class directly.
    //
    UCHAR   m_Type;
    union
    {
        UCHAR   m_Parent;
        UCHAR   m_NextFree;
    };
    union
    {
        UCHAR   m_FirstChild;
        UCHAR   m_bInterfaceNumber;
    };
    UCHAR           m_Sibling;

    UCHAR           m_PortNumber;
    union
    {
        UCHAR   m_Address;        
        UCHAR   m_RetryCount;
    };
    UCHAR           m_MaxPacket0;
    UCHAR           m_ClassSpecificType;

    PVOID           m_DefaultEndpoint;
    PUSBD_HOST_CONTROLLER m_HostController;

    union
    {
        PUSB_CLASS_DRIVER_DESCRIPTION   m_ClassDriver;
        IUsbDevice                      *m_NextPending;
    };
    LONG            m_ExternalPort;
    union
    {
        LARGE_INTEGER  m_EarliestEnumTime;
        struct
        {
            ULONG           m_DataToggleBits;
            PVOID			m_ClassDriverExtension;
        };
    };
    
    /* IUsbDevice helpers, these are only called internally so can be private */
    private:
    USBD_STATUS OpenDefaultEndpoint(PURB Urb);
    USBD_STATUS CloseDefaultEndpoint(PURB Urb);
};
//--------------------------------------------------------------------------------
//  Hub driver must implement this method
//--------------------------------------------------------------------------------
extern VOID USBHUB_DisableResetPort(
	                    IN IUsbDevice *HubDevice,
	                    IN UCHAR PortNumber,
	                    IN PVOID Context,
                        IN BOOLEAN Disable
	                    );
//--------------------------------------------------------------------------------
//  Enum Stages, mostly for debugging really
//--------------------------------------------------------------------------------
#define USBD_ENUM_DEVICE_CONNECTED 0x80
#define USBD_ENUM_STAGE_0 0
#define USBD_ENUM_STAGE_PRE1 0x81
#define USBD_ENUM_STAGE_1 1
#define USBD_ENUM_STAGE_2 2
#define USBD_ENUM_STAGE_3 3
#define USBD_ENUM_STAGE_PRE4 0x84
#define USBD_ENUM_STAGE_4 4
#define USBD_ENUM_STAGE_5 5
#define USBD_ENUM_STAGE_6 6
#define USBD_ENUM_STAGE_ADD_COMPLETE 7
#define USBD_ENUM_STAGE_ABORT1 8
#define USBD_ENUM_STAGE_DISABLE_COMPLETE 9
#define USBD_ENUM_STAGE_ABORT2 10

//--------------------------------------------------------------------------------
//  CDeviceTree keeps track of all the devices
//--------------------------------------------------------------------------------
#define USBD_MAX_CONFIG_DESC_SIZE     80
#define USBD_DEFAULT_MAXPACKET0       8
#define USBD_CONTROL_TD_QUOTA         (USBD_MAX_CONFIG_DESC_SIZE/USBD_DEFAULT_MAXPACKET0) + 3 //the three is for SETUP, SETUP's data and STATUS
#define USBD_BASE_NODES_PER_PORT      4

class CDeviceTree
{
    public:

    //
    //  There is no defined c'tor, because there is no way
    //  to make sure that it gets called.
    //

    void Init(ULONG NodeCount, ULONG MaxCompositeInterfaces);
    IUsbDevice *AllocDevice() { 
            UCHAR nodeIndex = m_FirstFree;
            ASSERT(UDN_INVALID_NODE_INDEX != nodeIndex);
            m_FirstFree = m_Devices[nodeIndex].m_NextFree;
            m_Devices[nodeIndex].m_Parent = UDN_INVALID_NODE_INDEX;
            m_Devices[nodeIndex].m_FirstChild = UDN_INVALID_NODE_INDEX;
            m_Devices[nodeIndex].m_Sibling = UDN_INVALID_NODE_INDEX;
            m_Devices[nodeIndex].m_ClassDriverExtension = NULL;
            m_Devices[nodeIndex].m_ClassSpecificType = 0xFF;
            return m_Devices + nodeIndex;
            }
    VOID FreeDevice(IUsbDevice *usbDevice) { 
            ASSERT(usbDevice >= m_Devices);
            UCHAR nodeIndex = usbDevice - m_Devices;
            ASSERT(UDN_INVALID_NODE_INDEX > nodeIndex);
            m_Devices[nodeIndex].m_Type = UDN_TYPE_UNUSED;
            m_Devices[nodeIndex].m_NextFree = m_FirstFree;
            m_FirstFree = nodeIndex;
            }
    
    BOOLEAN                     m_InProgress;
    BOOLEAN                     m_DeviceRemoved;
    BOOLEAN                     m_RetryCount;
    UCHAR                       m_EnumStage;
    URB                         m_EnumUrb;
    KDPC                        m_EnumDpc;
    KTIMER                      m_EnumTimer;
    UCHAR                       m_TimerReason;
    UCHAR                       m_FirstFree;
    UCHAR                       m_NodeCount;
    UCHAR                       m_MaxCompositeInterfaces;
    IUsbDevice                  *m_FirstPendingEnum;
    IUsbDevice                  *m_CurrentEnum;
    USB_DEVICE_DESCRIPTOR8      m_DeviceDescriptor;
    UCHAR                       m_ConfigurationDescriptorBuffer[USBD_MAX_CONFIG_DESC_SIZE];
    PUSB_INTERFACE_DESCRIPTOR   m_InterfaceDescriptor;
    IUsbDevice                  *m_Devices;
};
extern CDeviceTree g_DeviceTree;
#define USBD_TIMER_REASON_STAGE0            0
#define USBD_TIMER_REASON_WATCHDOG          1
#define USBD_TIMER_REASON_CONTINUE_STAGE1   2
#define USBD_TIMER_REASON_CONTINUE_STAGE4   3
/**************************************************
***  Implementation of IUsbDevice inline functions
*********/
inline UCHAR
IUsbDevice::GetIndex() const
/*++
    Gets the index of this device in the global static tree.
--*/
{return (UCHAR)(this - g_DeviceTree.m_Devices);}

inline BOOLEAN
IUsbDevice::GetLowSpeed() const
/*++
    Returns true if the device is lowspeed.
    THIS WILL BE REMOVED WHEN SUPPORT FOR LOWSPEED IS DROPPED.
--*/
{return m_PortNumber & UDN_LOWSPEED_PORT ? TRUE : FALSE;}

inline UCHAR
IUsbDevice::GetHubPort() const
/*++
    Get the portnumber regardless of lowspeed or not.
--*/
{return m_PortNumber & ~UDN_LOWSPEED_PORT;}

inline IUsbDevice *
IUsbDevice::GetParent() const
/*++
    Returns a pointer to the parent.  NULL if there is no parent.
--*/
{return (UDN_INVALID_NODE_INDEX != m_Parent) ? (g_DeviceTree.m_Devices + m_Parent) : NULL;}

inline IUsbDevice *
IUsbDevice::GetFirstChild() const
/*++
    Returns a pointer to the first child.  NULL if there are no children.
--*/
{return (UDN_INVALID_NODE_INDEX != m_FirstChild) ? (g_DeviceTree.m_Devices + m_FirstChild) : NULL;}

inline IUsbDevice *
IUsbDevice::GetSibling() const
/*++
    Returns a pointer to the next sibling.  NULL if this is the last sibling.
--*/
{return (UDN_INVALID_NODE_INDEX != m_Sibling) ? (g_DeviceTree.m_Devices + m_Sibling) : NULL;}
   
//------------------------------------------------------------------------
//  Methods used across modules
//------------------------------------------------------------------------
PUSB_CLASS_DRIVER_DESCRIPTION 
USBD_FindClassDriver(
	IN PNP_CLASS_ID ClassId
	);

//------------------------------------------------
//  Needed in ISBD_Init were we initialize the
//  the DPC for timing when to start enumeration.
//------------------------------------------------
void    
USBD_DeviceEnumTimerProc(
    IN PKDPC Dpc,
    IN PVOID Unused1,
    IN PVOID Unused2,
    IN PVOID Unused3
    );

//------------------------------------------------
//  Entry Point XAPI must call
//------------------------------------------------
EXTERNUSB VOID USBD_Init(DWORD NumDeviceTypes, PXDEVICE_PREALLOC_TYPE DeviceTypes);
//--------------------------------------------------------------------------------
//  Interface between the host controller driver and usbd
//--------------------------------------------------------------------------------
extern "C" {

//
// HCD specific URBs
//
#define USBD_EP_FLAG_LOWSPEED                0x0001
#define USBD_EP_FLAG_NEVERHALT               0x0002

//
// Common transfer request definition, all transfer
// requests passed to the HCD will be mapped to this
// format.  The HCD will can use this structure to
// reference fields that are common to all transfers
// as well as fields specific to isochronous and
// control transfers.

//
// bandwidth related definitions
//

// overhead in bytes/ms

#define USB_ISO_OVERHEAD_BYTES              9
#define USB_INTERRUPT_OVERHEAD_BYTES        13

  
//-------------------------------------------------------------
// Utility procedures supported by USB System Driver
//-------------------------------------------------------------
VOID
USBD_CompleteRequest(
    IN  PURB Urb
    );

USHORT
USBD_CalculateUsbBandwidth(
    IN USHORT   MaxPacketSize,
    IN UCHAR    EndpointType,
    IN BOOLEAN  LowSpeed
    );

VOID
USBD_DeviceConnected(
    IN  PVOID    HcdExtension,
    IN  UCHAR    PortNumber
    );

VOID
USBD_DeviceDisconnected(
    IN  PVOID HcdExtension,
    IN  UCHAR PortNumber
    );

VOID
USBD_NewHostController(
    IN PPCI_DEVICE_DESCRIPTOR PciDevice,
	IN ULONG HcdDeviceExtensionSize
    );

//-------------------------------------------------------------
// Procedures which must be exported by Host Controller Driver
//-------------------------------------------------------------
VOID
HCD_DriverEntry(
    PHCD_RESOURCE_REQUIREMENTS ResourceRequirements
    );

VOID
HCD_EnumHardware();

NTSTATUS
HCD_NewHostController(
    IN PVOID  HcdExtension,
    IN UCHAR  HostControllerNumber,
    IN PPCI_DEVICE_DESCRIPTOR PciDevice
    );

USBD_STATUS
HCD_SubmitRequest(
    IN PVOID HcdExtension,
    IN PURB Urb
    );

USBD_STATUS
HCD_CancelRequest(
    IN PVOID HcdExtension,
    IN PURB  Urb
    );

typedef
VOID
(*PFNHCD_RESET_COMPLETE)(
    IN USBD_STATUS  Status,
    IN PVOID        Context
    );

VOID
HCD_ResetRootHubPort(
    IN PVOID                    HcdExtension,
    IN ULONG                    PortNumber,
    IN PFNHCD_RESET_COMPLETE    ResetCompleteProc,
    IN PVOID                    CompleteContext
    );

VOID
HCD_DisableRootHubPort(
    IN PVOID                    HcdExtension,
    IN ULONG                    PortNumber
    );

} //end 'extern "C"'

#endif //__USB_X__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbd\tree.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    tree.c

Abstract:

    This module contains the code to manage the device tree.
    
    The entry points to this module are:

        Called During DriverEntry:
            CDeviceTree::CDeviceTree

        Called by root-hubs to indicate devices hot-plug events:
            USBD_DeviceConnected
            USBD_DeviceDisconnected
        Called by hubs to indicate devices hot-plug events:
            IUsbDevice::DeviceConnected
            IUsbDevice::DeviceDisconnected
        Called by class drivers to indicate the end of initialization or cleanup:
            IUsbDevice::AddComplete
            IUsbDevice::RemoveComplete
    
Environment:

    kernel mode only

Notes:


Revision History:

    02-11-00 : create by Mitchell Dernis (mitchd)

--*/

//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xapidrv.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DBSU'
#include <debug.h>

//
//  Pull in usbd headers
//
#include <usbd.h>

DEFINE_USB_DEBUG_FUNCTIONS("USBD");

//---------------------------------------------------------------------
// Forward declarations of routines defined and used only in this module
//---------------------------------------------------------------------
VOID USBD_DeviceEnumStage0();
VOID USBD_DeviceEnumStagePre1(USBD_STATUS UsbdStatus, PVOID Context);
VOID FASTCALL USBD_fDeviceEnumStage1(IUsbDevice  *Device);
VOID USBD_DeviceEnumStage2(PURB Urb, IUsbDevice *Device);
VOID USBD_DeviceEnumStage3(PURB Urb, IUsbDevice *Device);
VOID USBD_DeviceEnumStagePre4(PURB Urb, IUsbDevice *Device);
VOID FASTCALL USBD_fDeviceEnumStage4(PURB Urb, IUsbDevice *Device);
VOID USBD_DeviceEnumStage5(PURB Urb, IUsbDevice *Device);
VOID USBD_DeviceEnumStage6(PURB Urb, IUsbDevice *Device);
VOID USBD_DeviceAbortEnum(PURB Unreferenced, IUsbDevice *Device);
VOID FASTCALL USBD_fDeviceAbortEnum2(IUsbDevice  *Device);
VOID USBD_DeviceEnumNextPending(PURB Urb, IUsbDevice *Device);
VOID USBD_CompleteDeviceDisconnected(IUsbDevice *Device);
VOID USBD_SetEnumWatchDog();
VOID USBD_ClearEnumWatchDog();

VOID FASTCALL USBD_LoadClassDriver(IUsbDevice *Device, PNP_CLASS_ID ClassId);
UCHAR FASTCALL USBD_AllocateUsbAddress(PUSBD_HOST_CONTROLLER HostController);
VOID FASTCALL USBD_FreeUsbAddress(PUSBD_HOST_CONTROLLER HostController, UCHAR DeviceAddress);

//
//  We do not include the CRT, but we need new.
//  we declare it static, so we don't conflict on linking
//  with other modules overriding new.
//
#pragma warning(disable:4211)
static __inline void * __cdecl operator new(size_t memSize){return RTL_ALLOCATE_HEAP(memSize);}
#pragma warning(default:4211)
//--------------------------------------------
// Declare device tree. (Don't worry about
// the parameter, we call the C'tor explicitely
// from driver entry with the correct value.)
//--------------------------------------------

// HACK: Call the fake default constructor to avoid having the real
//  : constructor being called twice.
//
CDeviceTree g_DeviceTree;

#pragma code_seg(".XPPCINIT")
void 
CDeviceTree::Init(ULONG NodeCount, ULONG MaxCompositeInterfaces)
/*++
Routine Description:

    All of the initialization is done in this init function, because the
    c'tor cannot be called reliably in all link environments.

Arguments:
    
    DeviceExtension - Pointer to USBD device extension.

Return Value:

    None

--*/
{
    m_InProgress = FALSE;
    m_FirstFree = 0;
    m_FirstPendingEnum = NULL;
    m_CurrentEnum = NULL;
    m_NodeCount = NodeCount;
    m_Devices = new IUsbDevice[m_NodeCount];
    m_MaxCompositeInterfaces = MaxCompositeInterfaces;

    for(char nodeIndex = 0; nodeIndex < (m_NodeCount-1); nodeIndex++)
    {
        m_Devices[nodeIndex].m_NextFree = nodeIndex+1;
    }

    KeInitializeDpc(&m_EnumDpc, USBD_DeviceEnumTimerProc, NULL);
    KeInitializeTimer(&m_EnumTimer);
}
#pragma code_seg(".XPPCODE")

VOID
USBD_DeviceConnected(
    IN  PVOID    HcdExtension,
    IN  UCHAR    PortNumber
    )
/*++
    Routine Description:
        Called by the root-hub code in the HCD.  We find
        the device for the root-hub by looking in the DeviceObject,
        and then call the IUsbDevice::DeviceConntected.
--*/
{
    //
    //  Start with a retry count of 5.
    //
    USBD_HostControllerFromHCDExtension(HcdExtension)->RootHub->DeviceConnected(PortNumber, 5);
}

VOID IUsbDevice::DeviceConnected(UCHAR PortNumber, UCHAR RetryCount)
/*++
Routine Description:

    Called by the hub driver or indirectly through USBD_DeviceConnected for the root-hub in the HCD.
    This routine should be called at DISPATCH_LEVEL.  To avoid blocking on device transfers this
    routine kicks off a cascade of routines that enumerate a device.

    1) IUsbDevice::DeviceConnected
        a) Allocate Device Node
        b) Acquire Enum Lock
            i) If not acquired, add node to enum pending list, and return.
        c) start 100ms timer, so that device can settle.
    2) USBD_DeviceEnumStage0
        a) reset port.
    3) USBD_DeviceEnumStage1
        a) open default endpoint
        b) get DeviceDescriptor (8 bytes)
    4) USBD_DeviceEnumStage2
        a) allocate address
        b) set address
    5) USBD_DeviceEnumStage3
        a) close default endpoint
    6) USBD_DeviceEnumStage4
        b) if device requires function driver
            i) load function driver
            ii) Class Driver calls IUsbDevice::AddComplete when it is done enumerating.
        c) if device requires interface driver(s)
            i) open default endpoint
            ii) get configuration descriptor
    7) USBD_DeviceEnumStage5
        a) Set the configuration
    8)  USBD_DeviceEnumStage6
        a) allocate nodes for each interfaces.
        b) load class driver for first interface found.
        c) Class Driver calls IUsbDevice::AddComplete when it is done enumerating.
    9) IUsbDevice::AddComplete
        a) if it is an interface and has more siblings, load a class driver for the next sibling.
            i) Class Driver calls IUsbDevice::AddComplete when it is done enumerating.
        b) Close the default endpoint when all the sibling drivers are loaded, cascading to USBD_DeviceEnumNextPending.
    10) USBD_DeviceEnumNextPending
        a) If there are devices pending enumeration, takes one off the pending list and goes vack to 3)

    Each of the routines ends by sending an asynchronous request down to the HCD.
    The completion routine is always the next routine in the cascade.

Arguments:
    
    PortNumber      - Port number on hub (temporarily high-bit can be set to indicate low speed)
    LowSpeed        - Set if a low speed device was detected.

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    ASSERT_DISPATCH_LEVEL();
    
    
    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceConnected"));
    USB_DBG_TRACE_PRINT(("%s device detected in Port %d of Hub 0x%0.8x", (LowSpeed) ? "LowSpeed" : "FullSpeed", PortNumber, this));
    ASSERT((UDN_TYPE_HUB == m_Type) || (UDN_TYPE_ROOT_HUB == m_Type));

    //
    //  Allocate a device.
    //
    IUsbDevice *newDevice = g_DeviceTree.AllocDevice();
    if(!newDevice)
    {
        USB_DBG_WARN_PRINT(("Number of Devices Attached, exceeds the limits of our tree!"));
        USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceConnected, tree full"));
        return;
    }

    //
    //  Initialize the couple of things we know
    //
    newDevice->m_Type = UDN_TYPE_PENDING_ENUM;
    newDevice->m_PortNumber = PortNumber;
    newDevice->m_ClassDriver = NULL;
	newDevice->m_HostController = m_HostController;
    //
    //  Plug the node into the tree.
    //
    InsertChild(newDevice);

    //
    //  Serialize Device Enumeration
    //
    if(g_DeviceTree.m_InProgress)
    {
        //*
        //* An enumeration is in progress, queue our new node
        //* onto the pending list.
        //*

        //
        //  Set the retry count in the node.
        //
        newDevice->m_RetryCount = RetryCount;
        //
        //  Record the earliest time that enumeration may start.
        //
        newDevice->m_EarliestEnumTime.QuadPart = KeQueryInterruptTime();  //Get a time stamp.
        newDevice->m_EarliestEnumTime.QuadPart += 100*1000;  //Add 100 ms for power up.

        //
        //  Add the new device to the end of the pending list.
        //
        newDevice->m_NextPending = NULL;
        if(!g_DeviceTree.m_FirstPendingEnum)
        {
            g_DeviceTree.m_FirstPendingEnum = newDevice;
        } else
        {
            IUsbDevice *lastPending = g_DeviceTree.m_FirstPendingEnum;
            while(lastPending->m_NextPending) lastPending = lastPending->m_NextPending;
            lastPending->m_NextPending = newDevice;
        }

        //
        //  It is queued, so we can do nothing more.
        //
        USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceConnected, queued pending enum node"));
        return;
    }

    //
    //  We are actually working on this node.
    //
    newDevice->m_Type = UDN_TYPE_ENUMERATING;
    //
    //  Mark the global enum block in progress.
    //  Store the node information we are working on.
    //  
    g_DeviceTree.m_InProgress = TRUE;
    g_DeviceTree.m_DeviceRemoved = FALSE;
    g_DeviceTree.m_CurrentEnum = newDevice;
    g_DeviceTree.m_RetryCount = RetryCount;
    g_DeviceTree.m_EnumStage = USBD_ENUM_DEVICE_CONNECTED;

    //
    //  Until we change it the address is 0
    //
    newDevice->m_Address = 0;

    //
    //  Give newly plugged device a change to settle, 100ms according to specification.
    //
    g_DeviceTree.m_TimerReason = USBD_TIMER_REASON_STAGE0;
    LARGE_INTEGER           waitTime;
    waitTime.QuadPart = -100*10000; //100ms wait
    KeSetTimer(&g_DeviceTree.m_EnumTimer, waitTime, &g_DeviceTree.m_EnumDpc);
}

__inline void USBD_SetEnumWatchDog()
{
    LARGE_INTEGER           waitTime;
    g_DeviceTree.m_TimerReason = USBD_TIMER_REASON_WATCHDOG;
    waitTime.QuadPart = -5000*(LONGLONG)10000; //5 seconds (long, but that is the USB 1.1 specification: section 9.2.6.4)
    KeSetTimer(&g_DeviceTree.m_EnumTimer, waitTime, &g_DeviceTree.m_EnumDpc);
}
__inline void USBD_ClearEnumWatchDog()
{
    KeCancelTimer(&g_DeviceTree.m_EnumTimer);
}
VOID   
USBD_DeviceEnumTimerProc(
    IN PKDPC Dpc,
    IN PVOID Unused1,
    IN PVOID Unused2,
    IN PVOID Unused3
    )
{
    switch(g_DeviceTree.m_TimerReason)
    {
        case USBD_TIMER_REASON_STAGE0:
            USBD_DeviceEnumStage0();
            break;
        case USBD_TIMER_REASON_WATCHDOG:
            USB_DBG_WARN_PRINT(("Enumeration Timed out"));
            HCD_CancelRequest(
                    USBD_GetHCDExtension(g_DeviceTree.m_CurrentEnum->m_HostController),
                    &g_DeviceTree.m_EnumUrb
                    );  //This should force the hung URB to complete.
            break;
        case USBD_TIMER_REASON_CONTINUE_STAGE1:
            USBD_fDeviceEnumStage1(g_DeviceTree.m_CurrentEnum);
            break;
        case USBD_TIMER_REASON_CONTINUE_STAGE4:
            USBD_fDeviceEnumStage4(&g_DeviceTree.m_EnumUrb,g_DeviceTree.m_CurrentEnum);
            break;
        
        default:
            // The reason should always be set before the timer.
            // So this is a bug in the code that set the timer if this case is hit.
            ASSERT(FALSE);
    }
}


void USBD_DeviceEnumStage0()
/*++
Routine Description:

    Zeroeth stage of device enumeration after IUsbDevice::DeviceConnected.  See IUsbDevice::DeviceConnected
    for explanation of stages.  In this routine we:
        - reset the port

Arguments:
    
    None    

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{    
    IUsbDevice  *device = g_DeviceTree.m_CurrentEnum;
    PVOID       hcdDeviceExtension = USBD_GetHCDExtension(device->m_HostController);
    
    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceEnumStage0"));
    
    //
    //  Verify that the device was not removed while we were waiting.
    //
    if(g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("Stage 0 detects device removal."));
        USBD_DeviceAbortEnum(NULL, device);
        return;
    }
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_0;
    //
    //  Reset Port - Either we need to ask HCD to do it for the RootHub,
    //               or we need to ask the USBHUB (there had better be one
    //               and only one linked to us.
    //
    IUsbDevice *parent = device->GetParent();
    if(UDN_TYPE_ROOT_HUB == parent->m_Type)
    {
        HCD_ResetRootHubPort(
                hcdDeviceExtension,
                device->GetHubPort(),
                (PFNHCD_RESET_COMPLETE)USBD_DeviceEnumStagePre1,
                (PVOID)device
                );
    }
    else
    {
        //
        //  Otherwise ask our hub driver component to handle the port reset.
        //
        USBHUB_DisableResetPort(parent, device->GetHubPort(), (PVOID)device, FALSE);
    }
    USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceEnumStage0"));
}

void IUsbDevice::ResetComplete(USBD_STATUS UsbdStatus, PVOID Context)
/*++
*   Wraps USBD_DeviceEnumStage1 for Hub Class Driver.
*   
--*/
{
    USBD_DeviceEnumStagePre1(UsbdStatus, Context);
}

VOID    
USBD_DeviceEnumStagePre1(
            USBD_STATUS UsbdStatus,
            PVOID Context
    )
/*++
    Routine Description:
        Section 9.2.6.2 stipulates a 10 ms recovery
        time after the 10 ms RESET.  This
        routine sets a 10 ms timer.
--*/
{
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_PRE1;

    
     //
    //  Check that the reset port worked, and that the
    //  device has not been ripped out between
    //  enumeration stages.
    //
    if(USBD_ERROR(UsbdStatus))
    {
        USB_DBG_WARN_PRINT(("Pre Stage 1 detects failue: UsbdStatus = 0x%0.8x", UsbdStatus));
        USBD_DeviceAbortEnum(NULL, (IUsbDevice  *)Context);
        return;
    }

    //
    //  Set the speed here.
    //
    IUsbDevice  *device = (IUsbDevice  *)Context;
    if(USBD_STATUS_LOWSPEED == UsbdStatus)
    {
        device->m_PortNumber |= UDN_LOWSPEED_PORT;
    } else
    {
        ASSERT(!(device->m_PortNumber&UDN_LOWSPEED_PORT));
    }

    //
    //  A ten millisecond wait is required after reset.
    //
    LARGE_INTEGER           waitTime;
    g_DeviceTree.m_TimerReason = USBD_TIMER_REASON_CONTINUE_STAGE1;
    waitTime.QuadPart = -10*10000; //10 ms wait
    KeSetTimer(&g_DeviceTree.m_EnumTimer, waitTime, &g_DeviceTree.m_EnumDpc);
}

void
FASTCALL
USBD_fDeviceEnumStage1(
    IUsbDevice  *Device
    )
/*++
Routine Description:

    First stage of device enumeration after IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we:
        - open the default endpoint
        - get the DeviceDescriptor

Arguments:
    
    UsbdStatus - Status of reset port.

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    PVOID  hcdDeviceExtension = USBD_GetHCDExtension(Device->m_HostController);
    
    ASSERT_DISPATCH_LEVEL();

    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceEnumStage1"));
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_1;
    if(g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_WARN_PRINT(("Stage 1 detects device removal."));
        USBD_DeviceAbortEnum(NULL, Device);
        return;
    }

    //
    //  Fill out URB for opening an endpoint
    //
    USB_BUILD_OPEN_ENDPOINT(
                &g_DeviceTree.m_EnumUrb.OpenEndpoint,
                0,  //Address is 0 - default address
                USB_ENDPOINT_TYPE_CONTROL,
                USBD_DEFAULT_MAXPACKET0,
                0,  //Interval
                );
    g_DeviceTree.m_EnumUrb.OpenEndpoint.LowSpeed = Device->GetLowSpeed();
    g_DeviceTree.m_EnumUrb.OpenEndpoint.FunctionAddress = 0;

    //
    //  This URB is required to be synchronous and not allowed to fail
    //  according to specification.  Why?
    //      * Control endpoint, so no bandwidth problems
    //      * Open endpoint does not communicate over wire.
    //
    HCD_SubmitRequest(
        hcdDeviceExtension,
        &g_DeviceTree.m_EnumUrb
        );

    //
    //  Retrieve the handle from the URB
    //
    Device->m_DefaultEndpoint = g_DeviceTree.m_EnumUrb.OpenEndpoint.EndpointHandle;
    ASSERT(Device->m_DefaultEndpoint);  //Though it is not suppose to fail under any circumstance, check in debug!

    //
    //  Now issue an asynchronous request for
    //  the device descriptor.  This will also
    //  move us on to the next stage.
    
    //
    //  Don't use USB_BUILD_GET_DESCRIPTOR macro, because
    //  it was intended for class drivers, which don't know the
    //  EndpointHandle.
    //
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Length = sizeof(URB_CONTROL_TRANSFER);
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumStage2;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteContext = (PVOID)Device;
    g_DeviceTree.m_EnumUrb.ControlTransfer.EndpointHandle = Device->m_DefaultEndpoint;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBuffer = (PVOID)&g_DeviceTree.m_DeviceDescriptor;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBufferLength = sizeof(USB_DEVICE_DESCRIPTOR8);
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferDirection = USB_TRANSFER_DIRECTION_IN;
    g_DeviceTree.m_EnumUrb.ControlTransfer.ShortTransferOK = FALSE;
    g_DeviceTree.m_EnumUrb.ControlTransfer.InterruptDelay = USBD_DELAY_INTERRUPT_0_MS;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bmRequestType = USB_DEVICE_TO_HOST;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bRequest = USB_REQUEST_GET_DESCRIPTOR;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wValue = (USB_DEVICE_DESCRIPTOR_TYPE << 8);
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wIndex = 0;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wLength = sizeof(USB_DEVICE_DESCRIPTOR8);
    
    //
    //  We don't worry about errors.  The completion
    //  routine will get called even for errors, and
    //  we will just let the next stage deal with it.
    //
    USBD_SetEnumWatchDog();
    HCD_SubmitRequest(
        hcdDeviceExtension,
        &g_DeviceTree.m_EnumUrb
        );
    
    USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceEnumStage1"));
    return;
}

VOID    
USBD_DeviceEnumStage2(
            PURB        Urb,
            IUsbDevice  *device
    )
/*++
Routine Description:

    Second stage of device enumeration fter IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we:
        - allocate address
        - set address
Arguments:
    
    Urb     - Pointer to URB (it had better be &g_DeviceTree.m_EnumUrb)
    Device  - Device (passed as the context for complete procedure)

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    ASSERT_DISPATCH_LEVEL();
    USBD_ClearEnumWatchDog();
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_2;
    //
    //  Check that the get device descriptor worked, and that the
    //  device has not been ripped out between
    //  enumeration stages.
    //
    if(USBD_ERROR(Urb->Header.Status) ||g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_WARN_PRINT(("Stage 2 detects failue: Removed = %s, UsbdStatus = 0x%0.8x", g_DeviceTree.m_DeviceRemoved ? "TRUE":"FALSE", Urb->Header.Status));
        //
        //  USBD_DeviceEnumStage3 close the default endpoint.
        //  If it sees the error or DeviceRemoved
        //  it will redirect the enumeration sequence to abort.
        //
        USBD_DeviceEnumStage3(Urb, device);
        return;
    }

    //
    //  Do some sanity checks on the descriptor, and reject
    //  the device if they fail.
    //
    if(
        (Urb->ControlTransfer.TransferBufferLength < 8) ||
        (g_DeviceTree.m_DeviceDescriptor.bMaxPacketSize0 > 64) ||
        (USB_DEVICE_DESCRIPTOR_TYPE != g_DeviceTree.m_DeviceDescriptor.bDescriptorType) ||
        ((sizeof(USB_DEVICE_DESCRIPTOR8) != g_DeviceTree.m_DeviceDescriptor.bLength) &&
         (sizeof(USB_DEVICE_DESCRIPTOR) != g_DeviceTree.m_DeviceDescriptor.bLength))
    )
    {
        USB_DBG_WARN_PRINT(("A device returned a corrupt device descriptor.  Retries are allowed."));
        Urb->Header.Status = USBD_STATUS_REQUEST_FAILED;
        USBD_DeviceEnumStage3(Urb, device);
        return;
    }
    
    //
    //  Dump the device descriptor in debug builds
    //
    USB_DBG_TRACE_PRINT(("Device Descriptor:"));

    USB_DBG_TRACE_PRINT(("   bcdUSB             = 0x%0.4x",  g_DeviceTree.m_DeviceDescriptor.bcdUSB));
    USB_DBG_TRACE_PRINT(("   bDeviceClass       = %d", (long)g_DeviceTree.m_DeviceDescriptor.bDeviceClass));
    USB_DBG_TRACE_PRINT(("   bDeviceSubClass    = %d", (long)g_DeviceTree.m_DeviceDescriptor.bDeviceSubClass));
    USB_DBG_TRACE_PRINT(("   bDeviceProtocol    = %d", (long)g_DeviceTree.m_DeviceDescriptor.bDeviceProtocol));
    USB_DBG_TRACE_PRINT(("   bMaxPacketSize0    = %d", (long)g_DeviceTree.m_DeviceDescriptor.bMaxPacketSize0));

    //
    //  Record MaxPacket0 from device descriptor
    //
    device->m_MaxPacket0 = g_DeviceTree.m_DeviceDescriptor.bMaxPacketSize0;

    //
    //  Allocate an address 
    //
    device->m_Address = USBD_AllocateUsbAddress(device->m_HostController);

    //
    //  This should never happen, because our tree
    //  supports fewer devices than we have addresses.
    //  So if we hit this ASSERT it probably means
    //  that someone didn't free an address on removal.
    //
    ASSERT(device->m_Address);


    //
    //  Set the address - No Macro for this one, because
    //                    class drivers should never do it.
    //
    //  Items commented are either correct from last transfer, or not necessary.
    //
  //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Length = sizeof(URB_CONTROL_TRANSFER);
  //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumStage3;
  //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteContext = (PVOID)deviceNode;
  //g_DeviceTree.m_EnumUrb.ControlTransfer.EndpointHandle = g_DeviceTree.m_EndpointHandle;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBuffer = NULL;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBufferLength = 0;
  //g_DeviceTree.m_EnumUrb.ControlTransfer.TransferDirection = USB_TRANSFER_DIRECTION_IN;
  //g_DeviceTree.m_EnumUrb.ControlTransfer.ShortTransferOK = FALSE;
  //g_DeviceTree.m_EnumUrb.ControlTransfer.InterruptDelay = USBD_DELAY_INTERRUPT_0_MS;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bmRequestType = USB_HOST_TO_DEVICE;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bRequest = USB_REQUEST_SET_ADDRESS;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wValue = device->m_Address;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wIndex = 0;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wLength = 0;
    
    //
    //  We don't worry about errors.  The completion
    //  routine will get called even for errors, and
    //  we will just let the next stage deal with it.
    //
    USBD_SetEnumWatchDog();
    HCD_SubmitRequest(USBD_GetHCDExtension(device->m_HostController), &g_DeviceTree.m_EnumUrb);

    USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceEnumStage2"));
    return;
}

VOID    
USBD_DeviceEnumStage3(
            PURB        Urb,
            IUsbDevice  *device
    )
/*++
Routine Description:

    Third stage of device enumeration after IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we:
        - close default endpoint

    ***
    *** BECAUSE THIS STAGE CLOSES THE DEFAULT ENDPOINT WHETHER THE PREVIOUS
    *** OPERATION FAILED OR NOT, THIS STAGE IS CALLED BY OTHER STAGES
    *** TO ABORT ENUMERATION IF THE DEFAULT ENDPOINT IS OPEN.
    ***

Arguments:
    
    Urb     - Pointer to URB (it had better be &g_DeviceTree.m_EnumUrb)
    Device  - Device (passed as the context for complete procedure)

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceEnumStage3"));
    ASSERT_DISPATCH_LEVEL();
    USBD_ClearEnumWatchDog();
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_3;
    //
    //  Check if the address was set properly, and that the
    //  device has not been ripped out between
    //  enumeration stages.
    //
    if(USBD_ERROR(Urb->Header.Status) || g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("Stage 3 detects failue: Removed = %s, UsbdStatus = 0x%0.8x", g_DeviceTree.m_DeviceRemoved ? "TRUE":"FALSE", Urb->Header.Status));
        //
        // Redirect the close the default endpoint normally done in this
        // stage, to abort enumeration instead.
        //
        g_DeviceTree.m_EnumUrb.Header.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceAbortEnum;
    }
    else
    {
        g_DeviceTree.m_EnumUrb.Header.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumStagePre4;
    }
    g_DeviceTree.m_EnumUrb.Header.Length = sizeof(URB_CLOSE_ENDPOINT);
    g_DeviceTree.m_EnumUrb.Header.Function = URB_FUNCTION_CLOSE_ENDPOINT;
    //g_DeviceTree.m_EnumUrb.Header.CompleteContext = (PVOID)device;
    //g_DeviceTree.m_EnumUrb.CloseEndpoint.EndpointHandle = g_DeviceTree.m_EndpointHandle;
    
    //
    //  We don't worry about errors.  The completion
    //  routine will get called even for errors, and
    //  we will just let the next stage deal with it.
    //  A close cannot time out.
    //
    HCD_SubmitRequest(
        USBD_GetHCDExtension(device->m_HostController),
        &g_DeviceTree.m_EnumUrb
        );

    //
    //  We can just mark the default endpoint as closed right now.
    //
    device->m_DefaultEndpoint = NULL;
    USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceEnumStage3"));    
    return;
}

VOID    
USBD_DeviceEnumStagePre4(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
    Routine Description:
        A fine point of the specification is that a device may require
        2 ms after a SET_ADDRESS request before it has to repsond to
        the new address.  In stage 2 we set the address.  In stage 3,
        we closed the endpoint.  However, testing shows that this is
        not enough time.

        So this "pre4" stage is introduced to insert an explicit
        2 ms delay before stage 4.

        USBD_TIMER_REASON_CONTINUE_STAGE4 tells the timer routine
        that it should continue with stage 4 when this times out.
--*/
{
    //
    //  Set Address take two millseconds to settle, so we
    //  set a timer before proceding to stage 4
    //
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_PRE4;
    LARGE_INTEGER           waitTime;
    g_DeviceTree.m_TimerReason = USBD_TIMER_REASON_CONTINUE_STAGE4;
    waitTime.QuadPart = -2*10000; //2ms wait
    KeSetTimer(&g_DeviceTree.m_EnumTimer, waitTime, &g_DeviceTree.m_EnumDpc);
}

VOID  
FASTCALL  
USBD_fDeviceEnumStage4(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
Routine Description:

    Fourth stage of device enumeration after IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we have two possibilities:

        Device requires a function driver:
            - Load the class driver.
            - We will complete enumeration when the function Driver
              calls IUsbDevice::AddComplete

        Device is a composite device:
            - Reopen default endpoint - with correct address and bMaxPacket0.
            - Get the Configuration descriptor and go on to stage 5

Arguments:
    
    Urb       - Pointer to URB (it had better be &g_DeviceTree.m_EnumUrb)
    Device    - Device (passed as the context for complete procedure)

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    ASSERT_DISPATCH_LEVEL();

    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceEnumStage4"));
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_4;
    //
    //  Closing an endpoint cannot fail.  So we don't need to check, but
    //  we do need to check to make sure the device has not been removed.
    //
    if(g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("Stage 4 detects device removal"));
        //
        //  The default endpoint is closed so just abort
        //
        USBD_DeviceAbortEnum(NULL, Device);
        return;
    }

    //
    //  This is a function driver
    //
    if(0 != g_DeviceTree.m_DeviceDescriptor.bDeviceClass)
    {
        //
        //  Change the node type (remembering that hubs are special)
        //
        if(USB_DEVICE_CLASS_HUB == g_DeviceTree.m_DeviceDescriptor.bDeviceClass)
        {
            Device->m_Type = UDN_TYPE_HUB;
        }
        else
        {
            Device->m_Type = UDN_TYPE_FUNCTION;
        }

        //
        // Load the class driver
        //
        PNP_CLASS_ID classId;
        classId.USB.bClass = g_DeviceTree.m_DeviceDescriptor.bDeviceClass;
        classId.USB.bSubClass = g_DeviceTree.m_DeviceDescriptor.bDeviceSubClass;
        classId.USB.bProtocol = g_DeviceTree.m_DeviceDescriptor.bDeviceProtocol;
        classId.USB.bClassSpecificType = PNP_DEVICE_LEVEL_CLASS;
        USBD_LoadClassDriver(Device, classId);
        return;
    }

    //
    //  OK, we are either a COMPOSITE_FUNCTION or INTERFACE_FUNCTION
    //  so we need to get the configuration descriptor and move on to the
    //  next stage.
    //
    
    //*
    //* Open the default endpoint, this time get the address
    //* and stuff correct.
    //*

    //
    //  Initialize the enum urb to reopen the endpoint with the correct address
    //  and the correct max packet
    USB_BUILD_OPEN_ENDPOINT(
            &g_DeviceTree.m_EnumUrb.OpenEndpoint,
            0,  //Endpoint Address is 0 - default endpoint
            USB_ENDPOINT_TYPE_CONTROL,
            g_DeviceTree.m_DeviceDescriptor.bMaxPacketSize0,
            0  //Interval
            );
    g_DeviceTree.m_EnumUrb.OpenEndpoint.LowSpeed = Device->GetLowSpeed();
    g_DeviceTree.m_EnumUrb.OpenEndpoint.FunctionAddress = Device->m_Address;

    //
    //  This URB is required to be synchronous and not allowed to fail
    //  according to specification.  Why?
    //      * Control endpoint, so no bandwidth problems
    //      * Open endpoint does not communicate over wire.
    //
    HCD_SubmitRequest(
        USBD_GetHCDExtension(Device->m_HostController),
        &g_DeviceTree.m_EnumUrb
        );
    
    //
    //  We want the default endpoint to be available to the class driver
    //  in later stages.
    //
    Device->m_DefaultEndpoint = g_DeviceTree.m_EnumUrb.OpenEndpoint.EndpointHandle; 
    ASSERT(Device->m_DefaultEndpoint);  //Though it is not suppose to fail under any circumstance, check in debug!
    
    //
    //  Now get the configuration descriptor and go on to next stage
    //
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Length = sizeof(URB_CONTROL_TRANSFER);
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumStage5;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteContext = (PVOID)Device;
    g_DeviceTree.m_EnumUrb.ControlTransfer.EndpointHandle = Device->m_DefaultEndpoint;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBuffer = (PVOID)&g_DeviceTree.m_ConfigurationDescriptorBuffer;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBufferLength = USBD_MAX_CONFIG_DESC_SIZE;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferDirection = USB_TRANSFER_DIRECTION_IN;
    g_DeviceTree.m_EnumUrb.ControlTransfer.ShortTransferOK = TRUE;
    g_DeviceTree.m_EnumUrb.ControlTransfer.InterruptDelay = USBD_DELAY_INTERRUPT_0_MS;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bmRequestType = USB_DEVICE_TO_HOST;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bRequest = USB_REQUEST_GET_DESCRIPTOR;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wValue = (USB_CONFIGURATION_DESCRIPTOR_TYPE << 8);
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wIndex = 0;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wLength = USBD_MAX_CONFIG_DESC_SIZE;
    
    //
    //  We don't worry about errors.  The completion
    //  routine will get called even for errors, and
    //  we will just let the next stage deal with it.
    //
    USBD_SetEnumWatchDog();
    HCD_SubmitRequest(
        USBD_GetHCDExtension(Device->m_HostController),
        &g_DeviceTree.m_EnumUrb
        );
    return;
}

VOID    
USBD_DeviceEnumStage5(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
Routine Description:

    Fifth stage of device enumeration after IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we:
        - set the configuration.

Arguments:
    
    Urb       - Pointer to URB (it had better be &g_DeviceTree.m_EnumUrb)
    Device    - Device (passed as the context for complete procedure)   

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    ASSERT_DISPATCH_LEVEL();
    USBD_ClearEnumWatchDog();
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_5;
    //
    //  Check if we got the configuration descriptor, and that the
    //  device has not been ripped out between enumeration stages.
    //
    if(USBD_ERROR(Urb->Header.Status) || g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("Stage 5 detects failue: Removed = %s, UsbdStatus = 0x%0.8x", g_DeviceTree.m_DeviceRemoved ? "TRUE":"FALSE", Urb->Header.Status));
        //
        //  USBD_DeviceEnumStage3 close the default endpoint.
        //  When it sees the error or DeviceRemoved,
        //  it will redirect the enumeration sequence to abort.
        //
        USBD_DeviceEnumStage3(Urb, Device);
        return;
    }
    
    //
    //  Set the configurationDescriptor.
    //
    configurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)g_DeviceTree.m_ConfigurationDescriptorBuffer;
    
    //
    //  Verify the the configurationDescriptor does not exceed the Xbox
    //  limit.
    //
    if(USBD_MAX_CONFIG_DESC_SIZE < configurationDescriptor->wTotalLength)
    {
        g_DeviceTree.m_RetryCount = 0; //Don't retry this
        USB_DBG_WARN_PRINT(("Unsupported Hardware: Configuration Descriptor Length exceeds Xbox limit(%d bytes), disabling device", USBD_MAX_CONFIG_DESC_SIZE));
        Urb->Header.Status = USBD_STATUS_UNSUPPORTED_DEVICE;
        USBD_DeviceEnumStage3(Urb, Device);
        return;
    }

    //
    //  Verify that the entire descriptor was sent.
    //
    if(configurationDescriptor->wTotalLength != Urb->ControlTransfer.TransferBufferLength)
    {
        USB_DBG_WARN_PRINT(("Device did not return entire configuration descriptor, reenumerating"));
        Urb->Header.Status = USBD_STATUS_ERROR;
        //Retries will be allowed.
        USBD_DeviceEnumStage3(Urb, Device);
        return;
    }
    
    //
    //  Now set the configuration and go on to next stage
    //
    //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Length = sizeof(URB_CONTROL_TRANSFER);
    //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;
    g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumStage6;
    //g_DeviceTree.m_EnumUrb.ControlTransfer.Hdr.CompleteContext = (PVOID)deviceNode;
    //g_DeviceTree.m_EnumUrb.ControlTransfer.EndpointHandle = GLOBAL_USBD_EnumBlock.EndpointHandle;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBuffer = NULL;
    g_DeviceTree.m_EnumUrb.ControlTransfer.TransferBufferLength = 0;
    //g_DeviceTree.m_EnumUrb.ControlTransfer.TransferDirection = USB_TRANSFER_DIRECTION_IN;
    //g_DeviceTree.m_EnumUrb.ControlTransfer.ShortTransferOK = TRUE;
    //g_DeviceTree.m_EnumUrb.ControlTransfer.InterruptDelay = USBD_DELAY_INTERRUPT_0_MS;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bmRequestType = USB_HOST_TO_DEVICE;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.bRequest = USB_REQUEST_SET_CONFIGURATION;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wValue = configurationDescriptor->bConfigurationValue;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wIndex = 0;
    g_DeviceTree.m_EnumUrb.ControlTransfer.SetupPacket.wLength = 0;
    //
    //  We don't worry about errors.  The completion
    //  routine will get called even for errors, and
    //  we will just let the next stage deal with it.
    //
    USBD_SetEnumWatchDog();
    HCD_SubmitRequest(
        USBD_GetHCDExtension(Device->m_HostController),
        &g_DeviceTree.m_EnumUrb
        );
    return;
}

VOID    
USBD_DeviceEnumStage6(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
Routine Description:

    Sixth stage of device enumeration after IUsbDevice::DeviceConnected.
    See IUsbDevice::DeviceConnected for explanation of stages.
    In this routine we have either a INTERACE_FUNCTION or COMPOSITE FUNCTION.
    
    If it is a COMPOSITE_FUNCTION we 
        - Allocate additional nodes for each of the interfaces and plug them into the tree.
        - Begin notifying the interface drivers

    If it is an INTERFACE_FUNCTION we
        - Notify the interface driver

Arguments:
    
    Urb         - Pointer to URB (it had better be &g_DeviceTree.m_EnumUrb)
    DeviceNode  - DeviceNode (passed as the context for complete procedure)

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{   
    ASSERT_DISPATCH_LEVEL();
    USBD_ClearEnumWatchDog();
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_6;
    //
    //  Check if we got the configuration descriptor, and that the
    //  device has not been ripped out between enumeration stages.
    //
    if(USBD_ERROR(Urb->Header.Status) || g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("Stage 6 detects failue: Removed = %s, UsbdStatus = 0x%0.8x", g_DeviceTree.m_DeviceRemoved ? "TRUE":"FALSE", Urb->Header.Status));
        //
        //  USBD_DeviceEnumStage3 close the default endpoint.
        //  When it sees the error or DeviceRemoved,
        //  it will redirect the enumeration sequence to abort.
        //
        USBD_DeviceEnumStage3(Urb, Device);
        return;
    }
    //
    //  After a successful set configuration clear the data toggle bits.
    //
    Device->m_DataToggleBits = 0;

    //
    //  Begin parsing the configuration descriptor
    //
    PUCHAR currentParseLocation = g_DeviceTree.m_ConfigurationDescriptorBuffer;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)g_DeviceTree.m_ConfigurationDescriptorBuffer;

    //
    //  Find the first interface, this will be needed for both
    //  UDN_TYPE_INTERFACE_FUNCTION and UDN_TYPE_COMPOSITE_FUNCTION
    //
    do
    {
        currentParseLocation += ((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bLength;
        //
        //  Check to make sure we haven't walked off the end of the conifugration descriptor,
        //  and that we are not in an endless loop.
        //
        if(
            (currentParseLocation >= (g_DeviceTree.m_ConfigurationDescriptorBuffer + USBD_MAX_CONFIG_DESC_SIZE)) ||
            (0 == ((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bLength)
        ){
            USB_DBG_WARN_PRINT(("Corrupt Configuration Descriptor."));
            g_DeviceTree.m_RetryCount = 0; //Don't retry this
            Urb->Header.Status = USBD_STATUS_UNSUPPORTED_DEVICE;
            USBD_DeviceEnumStage3(Urb, Device);
            return;
        }
    }while(((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE);
    g_DeviceTree.m_InterfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR)currentParseLocation;

    //
    //  If it has only one interface than it is an UDN_TYPE_INTERFACE_FUNCTION
    //  
    if(1 == configurationDescriptor->bNumInterfaces || 0 == g_DeviceTree.m_MaxCompositeInterfaces)
    {
        //
        //  Fill out UDN_TYPE_INTERFACE_FUNCTION specific stuff
        //
        Device->m_Type = UDN_TYPE_INTERFACE_FUNCTION;
    }
    else
    {
        IUsbDevice *interfaceDevice;
        ULONG      interfaceIndex;
        
        //
        //  Change the main device node to UDN_TYPE_COMPOSITE_FUNCTION
        //
        Device->m_Type = UDN_TYPE_COMPOSITE_FUNCTION;
        Device->m_FirstChild = UDN_INVALID_NODE_INDEX;

        //
        //  Allocates device for all of the interfaces
        //
        //
        for(interfaceIndex = 0; interfaceIndex < configurationDescriptor->bNumInterfaces; interfaceIndex++)
        {
            //
            //  Refuse to enumerate more interfaces on a composite device
            //  then any of the drivers registered for
            if(g_DeviceTree.m_MaxCompositeInterfaces <= interfaceIndex)
            {
                break;
            }

            //
            //  Allocate a device on our tree
            //
            interfaceDevice = g_DeviceTree.AllocDevice();
            if(NULL == interfaceDevice)
            {
                USB_DBG_WARN_PRINT(("Number of Devices Attached, exceeds the limits of our tree!"));
                break;
            }
            //
            //  initialize basic information from the composite device
            //
            interfaceDevice->m_Type = UDN_TYPE_INTERFACE;
            interfaceDevice->m_PortNumber = (interfaceIndex+1) | (Device->m_PortNumber & UDN_LOWSPEED_PORT);
            interfaceDevice->m_Address = Device->m_Address;
            interfaceDevice->m_DefaultEndpoint = Device->m_DefaultEndpoint;
            interfaceDevice->m_HostController = Device->m_HostController;
            interfaceDevice->m_MaxPacket0 = Device->m_MaxPacket0;

            //
            //  Plug node into the tree as a child of the composite device
            //
            Device->InsertChild(interfaceDevice);
        }
        //
        //  The parents defaultendpoint has to appear closed, so
        //  right after a child interface is complete, it can
        //  immediately open the default endpoint.
        //
        Device->m_DefaultEndpoint = NULL;
        //
        //  We are done with the UDN_TYPE_COMPOSITE_FUNCTION
        //  move on to processing its first child.
        //  
        Device = Device->GetFirstChild();
    }
    //
    //  OK set the interface.
    //
    Device->m_bInterfaceNumber = g_DeviceTree.m_InterfaceDescriptor->bInterfaceNumber;
     
    //
    // Load the class driver
    //
    PNP_CLASS_ID classId;
    classId.USB.bClass = g_DeviceTree.m_InterfaceDescriptor->bInterfaceClass;
    classId.USB.bSubClass = g_DeviceTree.m_InterfaceDescriptor->bInterfaceSubClass;
    classId.USB.bProtocol = g_DeviceTree.m_InterfaceDescriptor->bInterfaceProtocol;
    classId.USB.bClassSpecificType = PNP_INTERFACE_LEVEL_CLASS;
    USBD_LoadClassDriver(Device, classId);
    return;
}

VOID
IUsbDevice::AddComplete(
    USBD_STATUS Status
    )
/*++
Routine Description:

    Last stage of enumeration after IUsbDevice::DeviceConnected. See IUsbDevice::DeviceConnected
    for explanation of stages.
    
    This routine is called a by a class driver to when it has completed the class specific enumeration
    steps.  This routine is necessary, because the class driver may have to make asynchronous requests
    in order to complete its initialization, and therefore USBD needs to be notified when the
    class driver is done.

    The different types of devices require some special handindling.

    1) For UDN_TYPE_INTERFACE devices if there is a sibling: it load the class driver for the sibling and return.  Control
    will come back to this routine when the class driver for the sibling has completed its enumeration steps.

    2) For the last UDN_TYPE_INTERFACE of a UDN_TYPE_COMPOSITE_FUNCTION, or for UDN_TYPE_INTERFACE_FUNCTION it closes
    the default endpoint.  This function cascades to USBD_DeviceEnumNextPending.

    3) For UDN_TYPE_FUNCTION it just calls USBD_DeviceEnumNextPending directly.

Arguments:
    
    Status - Status from the class driver.  Should be one of:
    
      USBD_STATUS_SUCCESS               - Device successfully initialized.
      USBD_STATUS_UNSUPPORTED_DEVICE    - Device not supported by the class driver.

	NotifylParam - lParam to send with Add and  Notifications.

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    ASSERT_DISPATCH_LEVEL();
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_ADD_COMPLETE;
    //
    //  If the class driver rejected the device, than
    //  the there is no class driver.
    //
    if(USBD_STATUS_UNSUPPORTED_DEVICE == Status)
    {
        USB_DBG_WARN_PRINT(("Unsupported Device or Class Driver not present."));
        m_ClassDriver = NULL;
    } else
    {
        //
        //  Notify XAPI
        //
        if(0xFF != m_ClassSpecificType)
        {
            PXPP_DEVICE_TYPE deviceType = m_ClassDriver->DeviceTypes[m_ClassSpecificType];
            if(deviceType)
            {
                XdReportDeviceInsertionRemoval(deviceType, m_ExternalPort, TRUE);
            }
        }
    }
    //
    //  Check for UDN_TYPE_FUNCTION and call USBD_DeviceEnumNextPending
    //
    if(
        (m_Type == UDN_TYPE_FUNCTION) ||
        (m_Type == UDN_TYPE_HUB)
    )
    {
        //
        //  If the class driver failed it, then abort enumeration.
        //
        if(USBD_ERROR(Status))
        {
            if(!m_ClassDriver) g_DeviceTree.m_RetryCount = 0;
            USBD_DeviceAbortEnum(NULL, this);
            return;
        }
        //
        //  Functions are completely enumerated, nothing left to do,
        //  except move on to the next pending.
        //
        USBD_DeviceEnumNextPending(NULL, this);
        return;
    }

    //
    //  The composite device is the parent of theis device if of type UDN_TYPE_INTERFACE_FUNCTION,
    //  and this device's parent if UDN_TYPE_INTERFACE.  Assume it is this
    //  device for now, and the case below will change it if necessary.
    //
    IUsbDevice *compositeDevice = this;
    //
    //  Mark the default endpoint as closed, but cache the endpointhandle
    //  so we can really close it.  We do this here because it applies to
    //  the last sibling if UDN_TYPE_INTERFACE, and to UDN_TYPE_INTERFACE_FUNCTION.
    //  Normally, the UDN_TYPE_COMPOSITE node is non-NULL if any of its children
    //  are non-NULL, but during enumeration is an exception.  This is so that
    //  immediately after a ClassDriver calls AddComplete it can open the default
    //  endpoint, and there is no race condition w.r.t. its sibilings completing enumeration.
    //  So before loaded even the first interface of the composite, we set the UDN_TYPE_COMPOSITE's
    //  m_DefaultEndpoint to NULL, while setting m_DefaultEndpoint for all the children to 
    //  the same endpoint which was opened for enumeration purposes.  Now, if the first
    //  child calls AddComplete and is immediately opened before its siblings finish enumeration
    //  it can reopen the default endpoint (getting a different handle).  This code cannot step on that.
    //  So if AddComplete is called for UDN_TYPE_INTERFACE and it is the last sibling we close the
    //  handle in UDN_TYPE_INTERFACE, and totally ignore what is in its parent (which may be NULL,
    //  or may be a different endpoint handle).  Note below, that we don't get as far as closing the
    //  endpoint if this is not the last sibling. If it is called for UDN_TYPE_INTERFACE_FUNCTION
    //  then there is nothing subtle going on.
    //
    PVOID endpointHandle = m_DefaultEndpoint;
    m_DefaultEndpoint = NULL;

    //
    //  There is some difference of type UDN_TYPE_INTERFACE.
    //  a) There may be siblings that have not have drivers loaded yet.
    //  b) The compositeDevice (the one that really owns the default endpoint)
    //     is our parent, not us.
    //
    PURB_COMPLETE_PROC CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceEnumNextPending;
    if(m_Type == UDN_TYPE_INTERFACE)
    {
        IUsbDevice *Sibling = GetSibling();
        //
        //  As long as this has siblings there must be more interfaces.
        //
        if(NULL != Sibling)
        {
            //
            //  Begin parsing the configuration descriptor
            //
            PUCHAR currentParseLocation = (PUCHAR)g_DeviceTree.m_InterfaceDescriptor;
            
            //
            //  Parse to the next interface
            //
            do
            {
                currentParseLocation += ((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bLength;
                ASSERT(currentParseLocation < (g_DeviceTree.m_ConfigurationDescriptorBuffer + USBD_MAX_CONFIG_DESC_SIZE));
            }while(((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE);
            g_DeviceTree.m_InterfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR)currentParseLocation;
            //
            //  Now that we have the next interface set the siblings m_bInterfaceNumber.
            //
            Sibling->m_bInterfaceNumber = g_DeviceTree.m_InterfaceDescriptor->bInterfaceNumber;
            //
            //  Load a driver for the sibling,
            //  and return.
            //
            PNP_CLASS_ID classId;
            classId.USB.bClass = g_DeviceTree.m_InterfaceDescriptor->bInterfaceClass;
            classId.USB.bSubClass = g_DeviceTree.m_InterfaceDescriptor->bInterfaceSubClass;
            classId.USB.bProtocol = g_DeviceTree.m_InterfaceDescriptor->bInterfaceProtocol;
            classId.USB.bClassSpecificType = PNP_INTERFACE_LEVEL_CLASS;
            USBD_LoadClassDriver(Sibling, classId);
            return;
        }
        else
        {
            //
            //  The next have this routine needs to know the compositeDevice
            //  which is this device's parent.
            compositeDevice = GetParent();
        }
    } else
    {
        if(USBD_ERROR(Status))
        {
            if(!m_ClassDriver) g_DeviceTree.m_RetryCount = 0;
            CompleteProc = (PURB_COMPLETE_PROC)USBD_DeviceAbortEnum;
        }
    }

    //
    //  Close the temporary enumeration time default endpoint.
    //
    g_DeviceTree.m_EnumUrb.Header.Length = sizeof(URB_CLOSE_ENDPOINT);
    g_DeviceTree.m_EnumUrb.Header.Function = URB_FUNCTION_CLOSE_ENDPOINT;
    g_DeviceTree.m_EnumUrb.Header.CompleteProc = CompleteProc;
    g_DeviceTree.m_EnumUrb.Header.CompleteContext = (PVOID)compositeDevice;
    g_DeviceTree.m_EnumUrb.CloseEndpoint.EndpointHandle = endpointHandle;
    
    //
    //  Close endpoint is not allowed to fail.
    //
    HCD_SubmitRequest(
        USBD_GetHCDExtension(compositeDevice->m_HostController),
        &g_DeviceTree.m_EnumUrb
        );
}

VOID    
USBD_DeviceAbortEnum(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
Routine Description:
    If enumeration failed we need to stop enumerating and continue with the
    next pending device.  By the time we get to this routine, you
    can be sure that the device is closed.  We call 
--*/
{
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_ABORT1;
    if(!g_DeviceTree.m_DeviceRemoved)
    //
    //  If the device was not removed, but failed, we need to
    //  disable it before continuing.
    //
    {
        USB_DBG_WARN_PRINT(("Enumeration Failed"));
        //
        //  Disable the port before completing abort, otherwise
        //  we could have an address conflict.
        //
        IUsbDevice *parent = Device->GetParent();
        if(UDN_TYPE_ROOT_HUB == parent->m_Type)
        {
            HCD_DisableRootHubPort(USBD_GetHCDExtension(Device->m_HostController), Device->GetHubPort());
            Device->DisableComplete(USBD_STATUS_SUCCESS, (PVOID)Device);
        } else
        {
            USBHUB_DisableResetPort(parent, Device->GetHubPort(), (PVOID)Device, TRUE);
        }
        return;
    } else
    {
        //
        //  Don't retry if the device was removed.
        //
        g_DeviceTree.m_RetryCount = 0;
    }
    USBD_fDeviceAbortEnum2(Device);
}

void IUsbDevice::DisableComplete(USBD_STATUS UsbdStatus, PVOID Context)
/*++
*   Only gets called as part of abort.
*   
--*/
{
    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_DISABLE_COMPLETE;
    IUsbDevice *device = (IUsbDevice *)Context;
    //
    //  If the disable failed and the device was not removed
    //  then we cannot free the address.  We fake out
    //  USBD_fDeviceAbortEnum2 by forgetting the address, this
    //  is an address leak;
    //
    if(USBD_ERROR(UsbdStatus) && !g_DeviceTree.m_DeviceRemoved)
    {
        //This is OK as long as it is extremely rare and difficult to induce.
        USB_DBG_WARN_PRINT(("Address %d is about to leak, a device failed enumeration, and then the port disable failed.", device->m_Address));
        device->m_Address = 0; //leak the address.
    }
    //
    //  Don't retry devices that have been removed.
    //
    if(g_DeviceTree.m_DeviceRemoved)
    {
        g_DeviceTree.m_RetryCount = 0;
    }
    USBD_fDeviceAbortEnum2(device);
}

VOID FASTCALL USBD_fDeviceAbortEnum2(IUsbDevice  *Device)
/*++
*   Finish up abort
*   
--*/
{
    UCHAR retryCount = 0;
    UCHAR retryPort = 0;
    IUsbDevice *parent = NULL;

    g_DeviceTree.m_EnumStage = USBD_ENUM_STAGE_ABORT2;
    //
    //  If the device is not removed
    //
    if(!g_DeviceTree.m_DeviceRemoved)
    {
        parent = Device->GetParent();
        ASSERT(parent);
        //
        //  Now remove it from its parent's tree
        //
        parent->RemoveChild(Device);
        //
        //  Resubmit the device for enumeration if
        //  the retry count is non-zero.
        //
        if(g_DeviceTree.m_RetryCount)
        {
            retryCount = g_DeviceTree.m_RetryCount;
            retryPort = Device->GetHubPort();
        }
    }

    //
    //  If the address is non-zero free it.
    //
    if(Device->m_Address)
    {
        USBD_FreeUsbAddress(Device->m_HostController, Device->m_Address);
    }
    //
    //  Free the node
    //
    g_DeviceTree.FreeDevice(Device);

    //
    //  If we detected a need for a retry, fire it here
    //
    if(retryCount)
    {
        parent->DeviceConnected(retryPort, --retryCount);
    }

    //
    //  Continue enumeration.
    //
    g_DeviceTree.m_DeviceRemoved = FALSE;
    USBD_DeviceEnumNextPending(NULL, Device);
}

VOID    
USBD_DeviceEnumNextPending(
            PURB        Urb,
            IUsbDevice  *Device
    )
/*++
Routine Description:

    After enumeration of a device is complete, this function is called to enumerate the next
    device pendning enumeration.  If there are none it clears the InProgress flag, so that
    when a device is detected it can be enumerated.
    
    This routine is cascaded to from AddComplete, so g_DeviceTree.m_CurrentEnum
    will equal Device.  This would prevent IUsbDevice::DeviceDisconnected from completing.
    So we should also make one last check to see if the device was removed.

Arguments:
    
      Urb       - Could be NULL.  So don't use it.
      Device    - Device which was just enumerated.

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  One last check to make sure the device we were working on is not gone.
    //
    if(g_DeviceTree.m_DeviceRemoved)
    {
        USB_DBG_ENTRY_PRINT(("USBD_DeviceEnumNextPending detects device removal"));
        //
        //  We are essentially in the running stage now, so just finish off the device disconnected
        //  operation.
        USBD_CompleteDeviceDisconnected(Device);
    }
    g_DeviceTree.m_DeviceRemoved = FALSE;
    
    //
    //  If nothing else is pending, clear the InProgress flag and
    //  we are done.
    //
    if(NULL == g_DeviceTree.m_FirstPendingEnum)
    {
        g_DeviceTree.m_CurrentEnum = NULL;
        g_DeviceTree.m_InProgress = FALSE;
        return;
    }
    
    //---------------------------------------------
    // One or more devices are pending enumeration
    //---------------------------------------------
    //
    //  Pop a device off the pending list, and into current enum.
    //
    g_DeviceTree.m_CurrentEnum = g_DeviceTree.m_FirstPendingEnum;
    g_DeviceTree.m_FirstPendingEnum = g_DeviceTree.m_CurrentEnum->m_NextPending;
    g_DeviceTree.m_RetryCount =  g_DeviceTree.m_CurrentEnum->m_RetryCount;
    g_DeviceTree.m_EnumStage = USBD_ENUM_DEVICE_CONNECTED;
    g_DeviceTree.m_CurrentEnum->m_Type = UDN_TYPE_ENUMERATING;
    g_DeviceTree.m_CurrentEnum->m_ClassDriver = NULL;
    g_DeviceTree.m_CurrentEnum->m_Address = 0;
    
    
    //
    //  If it is too early to enumerate than wait until
    //  it is time, otherwise start stage 0 now.
    LARGE_INTEGER currentTime;
    currentTime.QuadPart = KeQueryInterruptTime();
    if(currentTime.QuadPart > g_DeviceTree.m_CurrentEnum->m_EarliestEnumTime.QuadPart)
    {
        USBD_DeviceEnumStage0();
    }
    else
    {

        g_DeviceTree.m_TimerReason = USBD_TIMER_REASON_STAGE0;
        KeSetTimer(&g_DeviceTree.m_EnumTimer, g_DeviceTree.m_CurrentEnum->m_EarliestEnumTime, &g_DeviceTree.m_EnumDpc);
        USB_DBG_TRACE_PRINT(("Current Tick = %d, Earliest Enum = %d", currentTime.LowPart, g_DeviceTree.m_CurrentEnum->m_EarliestEnumTime.LowPart));
    }
}


VOID
USBD_DeviceDisconnected(
    IN  PVOID HcdExtension,
    IN  UCHAR PortNumber
    )
/*++
    Routine Description:
        Called by the root-hub code in the HCD.  We find
        the device for the root-hub by looking in the DeviceObject,
        and then call the IUsbDevice::DeviceDisconntected.
--*/
{
    USBD_HostControllerFromHCDExtension(HcdExtension)->RootHub->DeviceDisconnected(PortNumber);
}

VOID IUsbDevice::DeviceDisconnected(UCHAR PortNumber)
/*++
Routine Description:

    Called by the hub driver or through USBD_DeviceDisconnected by the root-hub code in the HCD
    to report the disconnection of a USB device.  This routine must be called at DISPATCH_LEVEL.
    
    A device can be in one of three states when it is removed:
    
      1) Pending Enumeration - it is in the list of devices waiting to be enumerated.
      2) Enumerating - it is currently being enumerated.
      3) Functioning - it has completed enumeration and is being used.

    The handling depends on the state.
    
      1) Pending Enumeration:
            * Remove the device from its parents list of children.
            * Remove the device from the list of devices waiting enumeration
            * Put the device back on the free list.
            It is all done synchronously.
      2) Enumerating:
            *Remove the device from its parents list of children.
            *Mark the g_DeviceTree.m_DeviceRemoved.  The next time an enumeration stage is started it will:
                If the class driver has not been loaded:
                    * Close any open endpoints if necessary (shunting to stage 3).
                    * Call USBD_AbortEnumDevice which calls IUsbDevice::RemoveComplete.
                If the class driver(s) are loaded, it calls USBD_CompleteDeviceDisconnected
      3) Functioning:
            This routine:
                * Remove it from its parents list of children.
            USBD_CompleteDeviceDisconnected:
                * If it is a UDN_TYPE_HUB, UDN_TYPE_FUNCTION, UDN_TYPE_INTERFACE_FUNCTION, notify the class driver
                that it is gone.
                * For UDN_TYPE_COMPOSITE_FUNCTION we need to walk all of its children and notify each class driver that it
                is gone.
            Class Driver:
                * Close all endpoints.
                * The hub driver must call USBD_DeviceDisconnected (this routine) for each of its children.
                * Call IUsbDevice::RemoveComplete for the device.
                * It should notify its clients that the device is gone, and perform any additional cleanup it
                  needs to.
            IUsbDevice::RemoveComplete:
                * Finishes reclaiming the node.

Arguments:
    
    PortNumber      - Port number on hub (temporarily high-bit can be set to indicate low speed)

Return Value:

    None.

    This code returns from multiple places!

Context:
    Must be called at DISPATCH_LEVEL

--*/
{

    USB_DBG_ENTRY_PRINT(("Entering USBD_DeviceDisconnected"));
    USB_DBG_TRACE_PRINT(("Device removed from Port %d of Hub 0x%0.8x", (ULONG)GetHubPort(), this));

    ASSERT_DISPATCH_LEVEL();
    ASSERT((UDN_TYPE_HUB == m_Type) || (UDN_TYPE_ROOT_HUB == m_Type));

    //
    //  Find the node, among its parents children.
    //
    IUsbDevice *removedDevice = FindChild(PortNumber);
    if(NULL == removedDevice)
    {
        USB_DBG_TRACE_PRINT(("USBD_DeviceDisconnected called for a device which does not exist."));
        USB_DBG_TRACE_PRINT(("This will happen when an unsupported (or in some cases failed) device is removed."));
        USB_DBG_TRACE_PRINT(("It also may happen as a result of some device failures."));
        return;
    }
    //
    //  Remove the device from this hub's list of children.
    //
    RemoveChild(removedDevice);
    
    //  
    //  Handle disconnect if node is pending enumeration.
    //
    if(UDN_TYPE_PENDING_ENUM == removedDevice->m_Type)
    {
        //
        //  Remove the node from the pending list
        //  
        if(g_DeviceTree.m_FirstPendingEnum == removedDevice)
        {
            g_DeviceTree.m_FirstPendingEnum = removedDevice->m_NextPending;
        } else
        //
        //  Not the first one, so we need to walk the pending list until we find it.
        //
        {
            IUsbDevice *prevPending = g_DeviceTree.m_FirstPendingEnum;
            while(removedDevice != prevPending->m_NextPending)
            {
                prevPending = prevPending->m_NextPending;
                ASSERT(prevPending);
            }
            prevPending->m_NextPending = removedDevice->m_NextPending;
        }
        removedDevice->m_NextPending = NULL;
        //
        //  Return the node to the free list.
        //
        g_DeviceTree.FreeDevice(removedDevice);
        //
        //  The device is removed we are done
        //
        return;
    }
    
    //  
    //  Handle disconnect if node is enumerating.
    //
    if( 
        g_DeviceTree.m_InProgress &&
        (g_DeviceTree.m_CurrentEnum == removedDevice)
    )
    {
        //
        //  Just tell the enumeration code that the device
        //  it is working on is now gone.
        //
        g_DeviceTree.m_DeviceRemoved = TRUE;
        return;
    }
    
    //  
    //  Handle disconnect if node is functioning
    //
    USBD_CompleteDeviceDisconnected(removedDevice);

    USB_DBG_EXIT_PRINT(("Exiting USBD_DeviceDisonnected"));
}

VOID
USBD_CompleteDeviceDisconnected(
    IUsbDevice *Device
    )
/*++
Routine Description:
    Utility function to complete the last step of hte USBD_DeviceDisconnected routine:
    notifying the class drivers that the device has been removed.  This has been abstracted,
    because it is called in two places:
        1) End of IUsbDevice::DeviceDisconnected.
        2) From USBD_DeviceEnumNextPending.

    The latter cases arises if the device is physically removed and DeviceDeviceDisconnected is called for
    a device which has completed USBD_DeviceEnumStage6(for UDN_TYPE_COMPOSITE_FUNCTION, or UDN_TYPE_INTERFACE_FUNCTION) or
    USBD_DeviceEnumStage4(for UDN_TYPE_FUNCITON and UDN_TYPE_HUB), but the AddComplete has not yet been called
    by the class driver (or all the class drivers - in the case of UDN_TYPE_COMPOSITE_FUNCTION).
--*/
{
    if(UDN_TYPE_COMPOSITE_FUNCTION == Device->m_Type)
    {
        //
        //  Walk children (i.e. interface and notify each driver.  There is no need for serialization
        //  here so we just call them all.
        //
        IUsbDevice *child = Device->GetFirstChild();
        while(child)
        {
            //Cache the next child, because RemoveComplete,
            //removes it from the parent's list of children.
            IUsbDevice *nextChild = child->GetSibling(); 
            if(child->m_ClassDriver)
            {
                child->m_ClassDriver->RemoveDevice(child);
            } else
            {
                child->RemoveComplete();
            }
            child = nextChild;  //prepare for next interation
        }
    }
    else
    {
        if(Device->m_ClassDriver)
        {
            Device->m_ClassDriver->RemoveDevice(Device);
        } else
        {
            Device->RemoveComplete();
        }
    }
}


VOID IUsbDevice::RemoveComplete()
/*++
Routine Description:

    When a device is disconnected, USBD_DeviceDisconnected calls each of the class drivers to give
    them a chance to cleanup.  Since they may need to perform asynchronous operations to complete their
    cleanup (such as closing endpoints), completion of removal cannot proceed when the class driver returns
    from the notification.  Therefore class drivers must call this routine when they are done cleaning up.

    Likewise, if removal occurs during enumeration, enumeration eventually ends up here.  At this point, there are
    two tasks left: return the node to the free list, and free the USB address.
      
    However, UDN_TYPE_INTERFACE nodes have a little more work.  They are children of UDN_TYPE_COMPOSITE_FUNCTION.
    Since the parent UDN_TYPE_COMPOSITE_FUNCTION is needed for closing endpoints, it is still attached.  So this routine
    must remove the node from its parents' child list, and return the node to the free list.  Upon removing the
    last child, it should free the parent too.  The USB address should be freed with parent, not the children.
    
Arguments:
    
    DeviceObject    - DeviceObject of host controller for detecting hub
    DetectingHub    - Device Node for detecting hub
    PortNumber      - Port number on hub (temporarily high-bit can be set to indicate low speed)

Return Value:

    None.

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    ASSERT_DISPATCH_LEVEL();
	
   
    //
    //  Notify XAPI
    //
    if(0xFF != m_ClassSpecificType)
    {
        PXPP_DEVICE_TYPE deviceType = m_ClassDriver->DeviceTypes[m_ClassSpecificType];
        if(deviceType)
        {
            XdReportDeviceInsertionRemoval(deviceType, m_ExternalPort, FALSE);
        }
    }

    //
    //  For UDN_TYPE_INTERFACE, remove the node from its parents' child list,
    //  and free parent if no more children
    //
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        //
        //  Remove the parents list of children
        //  and free parent if no more children
        IUsbDevice *parent = GetParent();
        if(FALSE == parent->RemoveChild(this))
        {
            //
            //  Free the USB address
            //
            USBD_FreeUsbAddress(parent->m_HostController, parent->m_Address);
            //
            //  Free the device.
            //
            g_DeviceTree.FreeDevice(parent);
        }
    }
    else
    {
        //
        //  For non-UDN_TYPE_INTERFACE nodes
        //
        if(m_Address)  //we have to check in case, we were aborted before a successful SET_ADDRESS
        {
            USBD_FreeUsbAddress(m_HostController, m_Address);
        }
    }
    //
    //  Free node.
    //
    g_DeviceTree.FreeDevice(this);
    return;
}

void IUsbDevice::DeviceNotResponding()
/*++
Routine Description:

    If a device stops responding for any reason, a class driver    
Arguments:
    
    DeviceObject    - DeviceObject of host controller for detecting hub
    DetectingHub    - Device Node for detecting hub
    PortNumber      - Port number on hub (temporarily high-bit can be set to indicate low speed)

Return Value:

    None.

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    ASSERT_DISPATCH_LEVEL();
    IUsbDevice *device;
    
    //
    //  If the device is UDN_TYPE_INTERFACE, then the
    //  real node is the parent
    //
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        device = GetParent();
        ASSERT(device);
    } else
    {
        device = this;
    }
    

    //
    //  If it has a parent, it is not pending
    //  remove, so we should reenumerate it.
    //
    IUsbDevice *parent = device->GetParent();
    if(parent)
    {
        
        UCHAR   hubPort = device->GetHubPort();
        
        //
        //  Report the device as disconnected
        //
        parent->DeviceDisconnected(hubPort);

        //
        //  Report the device as connected.
        //
        parent->DeviceConnected(hubPort, 5);
    }
}

VOID
FASTCALL
USBD_LoadClassDriver(IUsbDevice *Device, PNP_CLASS_ID ClassId)
/*++
Routine Description:

    This routine is a helper function for device enumeration.  It is used three times
    so it is extracted.  It kicks off the Class Driver portion of enumeration.
    
    Given a class ID it calls the USBD_FindClassDriver.  If it finds one
    it calls the class drivers AddDevice.  Otherwise, it calls Device->AddComplete 
    with an error code.

Arguments:
    
    Device - The device for which to load a driver.
    ClassId = PnP Class ID for the driver to load.

Return Value:

    None.

Context:
    Must be called at DISPATCH_LEVEL

--*/
{
    //
    //  Sets up the external port number
    //
    Device->SetExternalPort();
    if(XDEVICE_ILLEGAL_PORT == Device->m_ExternalPort)
    {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    Device->m_ClassDriver = USBD_FindClassDriver(ClassId);

    //
    //  Call AddDevice if we found a class driver
    //
    if(Device->m_ClassDriver)
    {
        Device->m_ClassDriver->AddDevice(Device);
        //
        //  The class driver will call AddComplete, when it
        //  has completed its enumeration steps.
        //
    } else
    //
    //  We don't have a class driver, so call AddComplete
    //  with a failure code.
    //
    {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    }
    return;
}

UCHAR
FASTCALL
USBD_AllocateUsbAddress(
    IN PUSBD_HOST_CONTROLLER HostController
    )
/*++

Routine Description:


Arguments:

Return Value:

    Valid USB address (1..127) to use for this device,
    returns 0 if no device address available.

--*/
{
    UCHAR   address     = 0;
    UCHAR   dwordIndex  = 0;
    ULONG   bitMask     = 1;
    
    //
    //  The AddressList consists of four DWORDS.
    //  Together they form a 128 bit bitfield.
    //  bits that are set, are address that are
    //  taken.
    //
        
    //
    //  Search for a free address
    //
    while(++address < 128)
    {
        //
        //  If the address is available, claim it and break
        //  out of loop.
        //
        if(!(HostController->AddressList[dwordIndex] & bitMask))
        {
            HostController->AddressList[dwordIndex] |= bitMask;
            break;
        }
        bitMask <<= 1;
        if(!bitMask)
        {
            dwordIndex++;
            bitMask = 1;
        }
    }
    //
    //  Handle case of out of addresses (we fell through the loop).
    //
    //  if(address == 128) address = 0;
    address &= 0x007F;  //This is more efficient than above.

    return address;
}

VOID
FASTCALL
USBD_FreeUsbAddress(
    IN PUSBD_HOST_CONTROLLER HostController,
    IN UCHAR DeviceAddress
    )
/*++

Routine Description:


Arguments:

Return Value:

    Valid USB address (1..127) to use for this device,
    returns 0 if no device address available.

--*/
{
    UCHAR                   dwordIndex  = 0;

    //
    // Sanity check address range
    //
    ASSERT(DeviceAddress > 0 && DeviceAddress < 128);
    
    //
    //  Reduce the DeviceAddress to a dwordIndex and
    //  a bitIndex (DeviceAddress will be the bitIndex
    //  when we leave this loop.
    //
    DeviceAddress--;
    while(DeviceAddress > 31)
    {
        dwordIndex++;
        DeviceAddress -= 32;
    }
    
    //
    //  Now clear the bit
    //
    HostController->AddressList[dwordIndex] &= ~(1 << DeviceAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\roothub.c ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    RootHub.c

Abstract:
    
    This file implements the OpenHCI root hub support.  Rather than following the model
    of writing an emulation of a real hub that supports transfers, this module instead
    acts as a driver for the root-hub.  It detects and reports devices just as a hub driver
    would.  Since hub drivers do not in the XBOX world expose external interfaces, it
    is much simpler this way.

    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    02-10-00 created by Mitchell Dernis (mitchd)

--*/
//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");


__inline UCHAR RootHubPortToPortNumber(UCHAR RootHubPort)
/*++
    Routine Description:
        The root hub internally uses ports 0 to 3.  However, this
        translates to ports 1 to 4 with a normal hub. 
--*/
{
    return RootHubPort+1;
}

__inline ULONG PortNumberToRootHubPort(ULONG PortNumber)
{
    return PortNumber-1;
}

//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff


VOID
OHCD_RootHubResetDpc(
    PKDPC Dpc,
    PVOID DeviceExtensionPtr,
    PVOID Bogus1,
    PVOID Bogus2
    );

#pragma code_seg(".XPPCINIT")
VOID
FASTCALL
OHCD_RootHubInitialize(
    POHCD_DEVICE_EXTENSION      DeviceExtension
)
/*++

Routine Description:

    Reads basic info regarding the root-hub, and turns
    on the interrupts for the root-hub.

    1) Determine how many ports we have.
    2) Process initial connections.
    3) Turn on interrupts for hot-plug detection later

Arguments:

Return Value:
    
--*/               
{
    POHCI_OPERATIONAL_REGISTERS operationalRegisters = DeviceExtension->OperationalRegisters;
    POHCD_ROOT_HUB_OBJECT       rhObject = &DeviceExtension->RootHubObject;
#ifndef OHCD_XBOX_HARDWARE_ONLY
    HC_RH_DESCRIPTOR_A          rhDescriptorA;
    HC_RH_DESCRIPTOR_B          rhDescriptorB;
#endif //OHCD_XBOX_HARDWARE_ONLY    
    HC_RH_STATUS                rhStatus;
    HC_RH_PORT_STATUS           rhPortStatus;
    ULONG                       index;
    ULONG                       mask;
    OHCD_PORT_INFO              portInfo;
    KIRQL                       oldIrql;
    
    USB_DBG_ENTRY_PRINT(("Entering OHCD_RootHubInitialize"));
    
    
    //
    //  Initialize the watchdog timer and related DPC,
    //  for catching failed resets.
    //
    KeInitializeTimer(&rhObject->ResetTimeoutTimer);
    KeInitializeDpc(
        &rhObject->ResetTimeoutDPC,
        OHCD_RootHubResetDpc,
        (PVOID)DeviceExtension
        );


#ifdef OHCD_XBOX_HARDWARE_ONLY
    #if (USB_HOST_CONTROLLER_CONFIGURATION==USB_SINGLE_HOST_CONTROLLER)
    rhObject->NumberOfPorts = 4;
    #else
    rhObject->NumberOfPorts = 2;
    #endif
    USB_DBG_TRACE_PRINT(("  NumberDownstreamPorts     : %d", (ULONG)rhObject->NumberOfPorts));
#else
    //
    //  Get Information on root-hub, store number of ports.
    //
    rhDescriptorA.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorA.ul);
    rhObject->NumberOfPorts = rhDescriptorA.NumberDownstreamPorts;
    if(rhDescriptorA.NoPowerSwitch)
    {
        USB_DBG_WARN_PRINT(("USB Card Doesn't support power switching!!"));
    } else
    {
    
        //
        //  Calculate the relative PowerOnToGoodTime in 100 ns.  The negative sign is
        //  so the KeDelayExecutionThread will treat it as a relative time.
        //
        rhObject->PowerOnToGoodTime.QuadPart = -rhDescriptorA.PowerOnToPowerGoodTime*2*10000;
    
        //
        //  Build changes to write back to descriptor A
        //
        if(!rhDescriptorA.PowerSwitchingMode || !rhDescriptorA.OverCurrentProtectionMode)
        {
            USB_DBG_TRACE_PRINT(("Switch to per-port power and overcurrent protection:"));
            rhDescriptorA.PowerSwitchingMode = 1;   //  Switch the PowerSwitchingMode to Per-port
            rhDescriptorA.OverCurrentProtectionMode = 1; // Per port overcurrent protection
            WRITE_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorA.ul, rhDescriptorA.ul);
        }

        //
        //  As a diagnostic make sure that our changes were accepted
        //  we only support per-port power.
        //
        #if DBG
        rhDescriptorA.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorA.ul);
        if(!rhDescriptorA.PowerSwitchingMode || !rhDescriptorA.OverCurrentProtectionMode)
        {
            USB_DBG_ERROR_PRINT(("Root Hub didn't accept ganged -> per-port changes.  Incompatible hardware!"));
        }
        #endif
    }    


#if DBG
    if(0xFF==rhDescriptorA.PowerOnToPowerGoodTime)
    {
        //
        //  In truth, there may be other cards that require this long delay.
        //  The Entrega with the CMD chip is just the one we are worried about.
        //
        USB_DBG_WARN_PRINT(("CMD USB CARD DETECTED(requires long power-on delay)!"));
    }
#endif 

    USB_DBG_TRACE_PRINT(("Root Hub's Descriptor A:"));
    USB_DBG_TRACE_PRINT(("  NumberDownstreamPorts     : %d", (ULONG)rhObject->NumberOfPorts));
    USB_DBG_TRACE_PRINT(("  NoPowerSwitching          : %s", rhDescriptorA.NoPowerSwitch ? "TRUE" : "FALSE"));
    USB_DBG_TRACE_PRINT(("  PowerSwitchingMode        : %s", rhDescriptorA.PowerSwitchingMode ? "Per-Port" : "Ganged"));
    USB_DBG_TRACE_PRINT(("  DeviceType                : %s", rhDescriptorA.DeviceType ? "Compound" : "Simple"));
    USB_DBG_TRACE_PRINT(("  OverCurrentProtectionMode : %s", rhDescriptorA.OverCurrentProtectionMode ? "Per-Port" : "Overall"));
    USB_DBG_TRACE_PRINT(("  NoOverCurrentProtection   : %s", rhDescriptorA.NoOverCurrentProtection ? "TRUE" : "FALSE"));
    USB_DBG_TRACE_PRINT(("  PowerOnToPowerGoodTime    : %d ms", (ULONG)rhDescriptorA.PowerOnToPowerGoodTime*2));
#endif //OHCD_XBOX_HARDWARE_ONLY   
    
    //
    //  Display info in Descriptor B
    //
#ifndef OHCD_XBOX_HARDWARE_ONLY
    rhDescriptorB.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorB.ul);
    if(!rhDescriptorA.NoPowerSwitch)
    {
        //
        //  Make sure the PortPowerControlMask is set so that every port is per-port power.
        //
        mask = (rhObject->NumberOfPorts << 2) - 2;
        if(mask != (rhDescriptorB.PortPowerControlMask & mask))
        {
            rhDescriptorB.PortPowerControlMask |= mask;
            WRITE_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorB.ul, rhDescriptorB.ul);
            //
            //  As a diagnostic read back the changes, and make sure that they took.
            //
            #if DBG
            rhDescriptorB.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhDescriptorB.ul);
            if(mask != (rhDescriptorB.PortPowerControlMask & mask))
            {
                USB_DBG_ERROR_PRINT(("Root Hub didn't accept PortPowerControlMask changes.  Incompatible hardware!"));
            }
            #endif
        }

        #if DBG 
        USB_DBG_TRACE_PRINT(("Root Hub's Descriptor B:"));
        for(index = 1, mask = 2; index <= (int)rhObject->NumberOfPorts; index++, mask <<= 1)
        {
            USB_DBG_TRACE_PRINT(("  DeviceRemovable(%d)      : %s", index, 
                ((ULONG)rhDescriptorB.DeviceRemovable & mask)? "Not Removable" : "Removable" ));
            USB_DBG_TRACE_PRINT(("  PortPowerControlMask(%d) : %s", index, 
                ((ULONG)rhDescriptorB.PortPowerControlMask & mask)? "Per-port" : "Ganged" ));   
        }
        #endif

        //
        //  Power on ports
        //
        /*  Not necessary, everything is per-port.
        ASSERT(!rhDescriptorA.NoPowerSwitch); //We don't support cards that are always powered.
        rhStatus.HubStatus = HC_RH_STATUS_DeviceRemoteWakeupEnable; - we don't support remote wakeup.
        rhStatus.HubStatus = 0;
        rhStatus.HubStatusChange = HC_RH_STATUS_LocalPower;
        WRITE_REGISTER_ULONG(&operationalRegisters->HcRhStatus.ul, rhStatus.ul);
        */
    }
#endif //OHCD_XBOX_HARDWARE_ONLY
    //
    //  Get the hub status
    //
    rhStatus.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhStatus.ul);
    USB_DBG_TRACE_PRINT(("Root Hub's Status:"));
    USB_DBG_TRACE_PRINT(("  LocalPowerStatus          : Not Readable"));
    USB_DBG_TRACE_PRINT(("  OverCurrentIndicator      : %s", 
                (rhStatus.HubStatus &  HC_RH_STATUS_OvercurrentIndicator )? "OverCurrent" : "OK"));
    USB_DBG_TRACE_PRINT(("  DeviceRemoteWakeupEnable  : %s",
                (rhStatus.HubStatus & HC_RH_STATUS_DeviceRemoteWakeupEnable) ? "ON" : "OFF"));
    //
    //  Clear the status change bits (so that we can get future notifications)
    //  You clear bits by writing a one to them.  Writing a one to the HubStatus
    //  actually changes settings which we don't want to.  So basically
    //  we clear the HubStatus back and write the status change bits back on themselves.
    //
    rhStatus.HubStatus = 0;
    WRITE_REGISTER_ULONG(&operationalRegisters->HcRhStatus.ul, rhStatus.ul);

#ifndef OHCD_XBOX_HARDWARE_ONLY    
    //
    //  Power on each port
    //
    if(!rhDescriptorA.NoPowerSwitch)
    {
        // 7 ms delay hack for some timing challenged cards
        LARGE_INTEGER   prePowerDelayHack;
        prePowerDelayHack.QuadPart = -7*10000;
        KeDelayExecutionThread(KernelMode, FALSE, &prePowerDelayHack);

        rhPortStatus.PortStatus = HC_RH_PORT_STATUS_SetPortPower;
        rhPortStatus.PortStatusChange = 0x0000;
        for(index=0; index < (int)rhObject->NumberOfPorts; index++)
        {
            WRITE_REGISTER_ULONG(&operationalRegisters->HcRhPortStatus[index].ul, rhPortStatus.ul);
        }
        //
        //  Wait the PowerOnToGoodTime
        //
        KeDelayExecutionThread(KernelMode, FALSE, &rhObject->PowerOnToGoodTime);
    }    
#endif //OHCD_XBOX_HARDWARE_ONLY

    //
    //  Retrieve the status of each port
    //
    RtlZeroMemory((PVOID)&portInfo, sizeof(OHCD_PORT_INFO));
    for(index=0, mask = 1; index < (int)rhObject->NumberOfPorts; index++, mask <<=1)
    {
        rhPortStatus.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhPortStatus[index].ul);
    
        //
        //  Traceouts, so we can see what is happening
        //
        USB_DBG_TRACE_PRINT(("Status of Port %d:", index+1));
        USB_DBG_TRACE_PRINT(("  CurrentConnectStatus      : %s",  
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_CurrentConnectStatus) ? "Connected" : "Disconnected"));
        USB_DBG_TRACE_PRINT(("  PortEnableStatus          : %s",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_PortEnableStatus) ? "Enabled" : "Disabled"));
        USB_DBG_TRACE_PRINT(("  PortSuspendStatus         : %s",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_PortSuspendStatus) ? "Suspended" : "Not Suspended"));
        USB_DBG_TRACE_PRINT(("  PortOverCurrentIndicator  : %s",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_PortOverCurrentIndicator) ? "OverCurrent" : "OK"));
        USB_DBG_TRACE_PRINT(("  PortResetStatus           : %s",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_PortResetStatus) ? "Reset Signal Active" : "Reset Signal Not Active"));
        USB_DBG_TRACE_PRINT(("  PortPowerStatus           : %s",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_PortPowerStatus) ? "Power On" : "Power Off"));
        USB_DBG_TRACE_PRINT(("  LowSpeedDeviceAttached    : %s\n",
            (rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_LowSpeedDeviceAttach) ? "LowSpeed" : "FullSpeed"));

        //
        //  We are looking just for connected status.
        //
        if(rhPortStatus.PortStatus  & HC_RH_PORT_STATUS_CurrentConnectStatus)
        {
            portInfo.PortsConnected |= mask;
            portInfo.PortsConnectionChanged |= mask;
        }

        //
        //  Clear the status change bits
        //
        rhPortStatus.PortStatus = 0;
        WRITE_REGISTER_ULONG(&operationalRegisters->HcRhPortStatus[index].ul, rhPortStatus.ul);
    }

    //
    //  Start interrupt processing for root-hub.
    //
    WRITE_REGISTER_ULONG(&operationalRegisters->HcInterruptEnable, HCINT_RootHubStatusChange);

    //
    //  Now we will call a common routine to process any devices we found.
    //  Since it is also called from the DPC for the ISR it expects to be 
    //  DISPATCH_LEVEL.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();
    OHCD_RootHubProcessHotPlug(DeviceExtension, &portInfo);
    KeLowerIrql(oldIrql);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_RootHubInitialize"));
}

#pragma code_seg(".XPPCODE")

VOID
FASTCALL
OHCD_RootHubProcessInterrupt(
    POHCD_DEVICE_EXTENSION      DeviceExtension
)
/*++

Routine Description:

    Process interrupts destined for the Root Hub.
    This routine is called LEVEL_DISPATCH from within
    the IsrDPC.
    
Arguments:

Return Value:
    
--*/          
{
    POHCI_OPERATIONAL_REGISTERS operationalRegisters = DeviceExtension->OperationalRegisters;
    HC_RH_STATUS                rhStatus;
    HC_RH_PORT_STATUS           rhPortStatus;
    ULONG                       index;
    ULONG                       mask;
    OHCD_PORT_INFO              portInfo;
    ULONG                       numPorts = DeviceExtension->RootHubObject.NumberOfPorts;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_RootHubProcessInterrupt"));

    //
    //  Check to see if we have an overcurrent on the hub.
    //  This is the only global (i.e. NOT per port) cause of a root hub interrupt.
    //
    rhStatus.ul = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcRhPortStatus->ul);
    if(rhStatus.HubStatusChange & HC_RH_STATUS_OvercurrentIndicator)
    {
        USB_DBG_TRACE_PRINT(("The root-hub is indicating over-current!"));
    }
    //
    //  Now retrieve the status of each port
    //
    RtlZeroMemory((PVOID)&portInfo, sizeof(OHCD_PORT_INFO));
    for(index=0, mask = 1; index < numPorts; index++, mask <<=1)
    {
        rhPortStatus.ul = READ_REGISTER_ULONG(&operationalRegisters->HcRhPortStatus[index].ul);
        //
        //  If reset status change
        //
        if(rhPortStatus.PortStatusChange & HC_RH_PORT_STATUS_PortResetStatus)
        {
            
            PFNHCD_RESET_COMPLETE   CompleteProc = DeviceExtension->RootHubObject.ResetComplete;
            PVOID                   Context = DeviceExtension->RootHubObject.ResetContext;
            
            //
            //  If the complete proc has not been called (due to a timeout)
            //  then stop the watchdog and call it now.
            //
            if(CompleteProc)
            {
                
                //
                //  Stop the reset's watchdog timer
                //
                KeCancelTimer(&DeviceExtension->RootHubObject.ResetTimeoutTimer);
                USB_DBG_TRACE_PRINT(("ResetCompleted: Port = %d, Context = 0X%0.8x", index+1, Context));

                //
                //  Call the completion routine  (setting the status according to 
                //  low speed or not).
                //
                DeviceExtension->RootHubObject.ResetComplete = NULL;
                DeviceExtension->RootHubObject.ResetContext = 0;
                CompleteProc(
                    (rhPortStatus.PortStatus & HC_RH_PORT_STATUS_LowSpeedDeviceAttach) ? 
                    USBD_STATUS_LOWSPEED : USBD_STATUS_SUCCESS,
                    Context);
            }
        }

        //
        //  If the connect status changed, we need to process it.
        //
        if(rhPortStatus.PortStatusChange & HC_RH_PORT_STATUS_CurrentConnectStatus)
        {
            //
            //  Set the connect change bit.
            //
            portInfo.PortsConnectionChanged |= mask;
            //
            //  If connected, set the connect bit.
            //
            if(rhPortStatus.PortStatus & HC_RH_PORT_STATUS_CurrentConnectStatus)
            {
                portInfo.PortsConnected |= mask;
            }
        }
        //
        //  Check for overcurrent indicators
        //
        if(rhPortStatus.PortStatusChange & HC_RH_PORT_STATUS_PortOverCurrentIndicator)
        {
            //
            //  It appears that this can just be ignored, other things will happen (like the
            //  port being disabled) that we will deal with properly.
            //
            USB_DBG_WARN_PRINT(("Port %d of the root hub is indicating over-current!", index));
        }
        //
        //  Check for automatic disabling of a port
        //
        if(rhPortStatus.PortStatusChange & HC_RH_PORT_STATUS_PortEnableStatus)
        {
            USB_DBG_TRACE_PRINT(("The root-hub disabled port %d!  Usually a remove. Usually it was removed.", index));
        }

        //
        //  Clear the status change bits, so we can get notifications of further changes
        //
        rhPortStatus.PortStatus = 0;
        WRITE_REGISTER_ULONG(&operationalRegisters->HcRhPortStatus[index].ul, rhPortStatus.ul);
    }

    //
    //  Notify USBD about hot-plug events.
    //
    OHCD_RootHubProcessHotPlug(DeviceExtension, &portInfo);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_RootHubProcessInterrupt"));
}


VOID
FASTCALL
OHCD_RootHubProcessHotPlug(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_PORT_INFO          PortInfo
)
/*++

Routine Description:

    Does the work of reporting connect and disconnect
    events to USBD and the higher driver layers.  It is
    called from two different contexts.

    1) Just a straight call from OHCD_RootHubInitialize
        to process the connected devices found initially.
    2) As a worker thread, from a work item queued by OHCD_RootProcessInterrupt
        which runs in the context of IsrDPC.

    This routine needs to operate at LEVEL_PASSIVE, because the higher level need to synchronously
    process each detected device, which may be time consuming.  The reason behind this is that a newly
    detected device reports at the default USB address (0).  Only one device reporting at address zero
    should be enabled at a time.  Once USBD sets the address, we can then move on to enabling the next
    device.

Arguments:

Return Value:
    
--*/          
{
    UCHAR portIndex = 0;
    UCHAR portMask = 1;
    USB_DBG_ENTRY_PRINT(("Entering OHCD_RootHubProcessHotPlug"));

    ASSERT_DISPATCH_LEVEL();

    //
    //  Keep walking through port indices as long as there is
    //  a change we haven't processed yet.
    //
    while(portIndex < DeviceExtension->RootHubObject.NumberOfPorts)
    {
        //
        //  If this port has change, notify USBD of the change.
        //
        if(PortInfo->PortsConnectionChanged&portMask)
        {
            //
            //  Handle new connect
            //
            if(PortInfo->PortsConnected&portMask)
            {
                //
                //  Check for rapid fire remove\add, in which
                //  case do a remove before the add.
                //
                if(DeviceExtension->RootHubObject.DeviceDetectedBitmap&portMask)
                {
                    USBD_DeviceDisconnected(
                        (PVOID)DeviceExtension,
                        RootHubPortToPortNumber(portIndex)
                        );
                    USB_DBG_WARN_PRINT(("Remove and Add in one interrupt."));
                } else
                {
                    DeviceExtension->RootHubObject.DeviceDetectedBitmap |= portMask; //record that this
                                                                                     //port has a device.
                }
                //
                //  Report the device to USBD.  That is all we must do.
                //  (USBD expects a base of 1 for port numbers)
                USBD_DeviceConnected( (PVOID)DeviceExtension, RootHubPortToPortNumber(portIndex));
            }
            else
            //
            //  Handle Disconnect
            //
            {
                //
                //  Check for rapid fire add\remove, only call device connected
                //  if we called device connected at some point.
                //
                if(DeviceExtension->RootHubObject.DeviceDetectedBitmap&portMask)
                {
                    //
                    //  Tell USBD, which will synchronously cleanup
                    //
                    //  (USBD expects a base of 1 for port numbers)
                    DeviceExtension->RootHubObject.DeviceDetectedBitmap &= ~portMask;
                    USBD_DeviceDisconnected(
                        (PVOID)DeviceExtension,
                        RootHubPortToPortNumber(portIndex)
                        );
                } else
                {
                    USB_DBG_TRACE_PRINT(("Add and Remove in one interrupt."));
                }
            }
        }
        //
        //  Move on to next port
        //
        portIndex++;
        portMask <<= 1;
    }
    
    USB_DBG_EXIT_PRINT(("Exiting OHCD_RootHubProcessHotPlug"));
}


VOID
HCD_ResetRootHubPort(
    IN PVOID                    HcdDeviceExtension,
    IN ULONG                    PortNumber,
    IN PFNHCD_RESET_COMPLETE    ResetCompleteProc,
    IN PVOID                    CompleteContext
    )
/*++

Routine Description:

    Resets a port on the root hub.  Only one reset is allowed at a time.
    
Arguments:
    HcdDeviceExtension  - our device extension (must cast)
    PortNumber          - number of port to reset (0 based)
Return Value:
    
--*/
{
    POHCD_DEVICE_EXTENSION  deviceExtension = (POHCD_DEVICE_EXTENSION)HcdDeviceExtension;
    HC_RH_PORT_STATUS       rhPortStatus;
    LARGE_INTEGER           resetTimeOut;

    USB_DBG_TRACE_PRINT(("HCD_ResetRootHubPort: Port = %d, Context = 0X%0.8x", PortNumber, CompleteContext));
    //
    //  Convert port number to root hub port number
    //
    PortNumber=PortNumberToRootHubPort(PortNumber);

    //
    //  Validate Range
    //
    ASSERT(deviceExtension->RootHubObject.NumberOfPorts > PortNumber);
    
    //
    //  There should not be a reset currently pending.
    //
    ASSERT(NULL == deviceExtension->RootHubObject.ResetComplete);
    
    //
    //  Record the completion information.
    //
    deviceExtension->RootHubObject.ResetComplete = ResetCompleteProc;
    deviceExtension->RootHubObject.ResetContext = CompleteContext;
    
    //
    //  Reset the port
    //
    rhPortStatus.PortStatus = HC_RH_PORT_STATUS_SetPortReset;
    WRITE_REGISTER_ULONG(
        &deviceExtension->OperationalRegisters->HcRhPortStatus[PortNumber].ul,
        rhPortStatus.ul
        );

    //
    //  Set a watchdog timer.  Resets have been known to fail.
    //
    resetTimeOut.QuadPart = -10000 * 100; //allow 100 ms, it should take only 10 ms according to spec.
                                           //20 ms wasn't long enough for some cards.
    KeSetTimer(
        &deviceExtension->RootHubObject.ResetTimeoutTimer,
        resetTimeOut,
        &deviceExtension->RootHubObject.ResetTimeoutDPC
        );
}

VOID
HCD_DisableRootHubPort(
    IN PVOID                    HcdExtension,
    IN ULONG                    PortNumber
    )
{
    POHCD_DEVICE_EXTENSION deviceExtension = (POHCD_DEVICE_EXTENSION)HcdExtension;
    HC_RH_PORT_STATUS       rhPortStatus;
    //
    //  Convert port number to root hub port number
    //
    PortNumber=PortNumberToRootHubPort(PortNumber);
    //
    //  Validate Range
    //
    ASSERT(deviceExtension->RootHubObject.NumberOfPorts > PortNumber);
    //
    //  Disable the port
    //
    rhPortStatus.PortStatus = HC_RH_PORT_STATUS_ClearPortEnable;
    WRITE_REGISTER_ULONG(
        &deviceExtension->OperationalRegisters->HcRhPortStatus[PortNumber].ul,
        rhPortStatus.ul
        );
}


VOID
OHCD_RootHubResetDpc(
    PKDPC Dpc,
    PVOID DeviceExtensionPtr,
    PVOID Bogus1,
    PVOID Bogus2
    )
{
    POHCD_DEVICE_EXTENSION deviceExtension = (POHCD_DEVICE_EXTENSION) DeviceExtensionPtr;
    PFNHCD_RESET_COMPLETE   CompleteProc = deviceExtension->RootHubObject.ResetComplete;
    PVOID                   Context = deviceExtension->RootHubObject.ResetContext;

    if(CompleteProc)
    {
        //
        //  This is usually nothing, but a device that was removed during the reset.
        //
        //  It has been found in the past to be indicative of other serious problems, though.
        //  Like the host being locked up because of bad register values.
        //
        USB_DBG_WARN_PRINT(("A port reset timed out on the root hub!"));

        //
        //  Call the completion routine with the bad news,
        //  it is up to the caller to recover.
        //
        USB_DBG_WARN_PRINT(("Reset Timed Out: Context = 0X%0.8x",  Context));
        deviceExtension->RootHubObject.ResetComplete = NULL;
        deviceExtension->RootHubObject.ResetContext = NULL;
        CompleteProc(USBD_STATUS_REQUEST_FAILED, Context);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbd\usbdev.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    usbdev.cpp

Abstract:

    This module contains the implementation of IUsbDevice
    except for the routine involved with device enumeration.
    
Environment:

    XBOX kernel.

Notes:
  

Revision History:
    
    03-24-00: Create (mitchd)
    06-12-00: renamed to usbdev and changed to implement in c++.

--*/

//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xapidrv.h>
//#include <xapidrv.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DBSU'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("USBD");


//
//  Pull in remaining usb headers
//
#include <usbd.h>

VOID
USBD_SubmitSynchronousRequestComplete(
    IN PURB     Urb,
    IN PKEVENT  Event
    )
/*++
Routine Description:

    Completion routine used by USBD_STATUS IUsbDevice::SubmitRequest,
    when blocking on an asynchronous request.

 Arguments:

    Urb     - URB that completed.
    Event   - Pointer to event that caller is blocking on.

Return Value:

    USBD_STATUS_SUCCESS - Or wide variety of possible errors.
    The possible errors for each URB can be found where the URB
    functions are defined.

--*/
{
    UNREFERENCED_PARAMETER(Urb);
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return;
}


USBD_STATUS IUsbDevice::SubmitRequest(PURB Urb)
/*++
Routine Description:

    Class drivers call this function to submit URBs to the HCD.
    This routine picks off the URBs that it handles or preprocesses
    and then passes the URBs down to the HCD if necessary.

Arguments:

  Urb             -   URB to handle

Return Value:

    USBD_STATUS_SUCCESS - Or wide variety of possible errors.
    The possible errors for each URB can be found where the URB
    functions are defined.

--*/
{
    BOOLEAN block = FALSE;
    USBD_STATUS usbdStatus;
    KEVENT SyncEvent;
    BOOLEAN submitRequestHere = TRUE;
    //
    //  Check if this is an aynschrnous request and we need
    //  to block until done.
    //
    if(
        (Urb->Header.Function&URB_FUNCTION_ASYNCHRONOUS) &&
        (NULL == Urb->Header.CompleteProc)
    )
    {
        block = TRUE;
        ASSERT_LESS_THAN_DISPATCH_LEVEL();
        //
        //  Initialize an event, and setup completion
        //  routine that will set the event.
        //
        
        KeInitializeEvent(&SyncEvent, NotificationEvent, FALSE);
        Urb->Header.CompleteProc = (PURB_COMPLETE_PROC)USBD_SubmitSynchronousRequestComplete;
        Urb->Header.CompleteContext = (PVOID)&SyncEvent;
    }
    //
    //  There are couple of URBs we need to preprocess
    //
    switch(Urb->Header.Function)
    {
        case URB_FUNCTION_OPEN_DEFAULT_ENDPOINT:
            submitRequestHere = FALSE;
            usbdStatus = OpenDefaultEndpoint(Urb);
            break;
        case URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT:
            submitRequestHere = FALSE;
            usbdStatus = CloseDefaultEndpoint(Urb);
            break;
        case URB_FUNCTION_OPEN_ENDPOINT:
            Urb->OpenEndpoint.FunctionAddress = m_Address;
            Urb->OpenEndpoint.DataToggleBits = &m_DataToggleBits;
            Urb->OpenEndpoint.LowSpeed = GetLowSpeed();
            break;
        case URB_FUNCTION_CLOSE_ENDPOINT:
            Urb->CloseEndpoint.DataToggleBits = &m_DataToggleBits;
            break;
        case URB_FUNCTION_ISOCH_OPEN_ENDPOINT:
            Urb->IsochOpenEndpoint.FunctionAddress = m_Address;
            break;
        //case URB_FUNCTION_RESET_PORT:
        case URB_FUNCTION_CONTROL_TRANSFER:
            //
            //  Resolve the endpoint handle for the default endpoint.
            //
            if(NULL == Urb->ControlTransfer.EndpointHandle)
            {
                ASSERT(m_DefaultEndpoint);
                Urb->ControlTransfer.EndpointHandle = m_DefaultEndpoint;
            }
            //
            //  If this is a set configuration, clear the cached toggle
            //  bits.
            //
            if(USB_REQUEST_SET_CONFIGURATION == Urb->ControlTransfer.SetupPacket.bRequest)
            {
                m_DataToggleBits = 0;
            }
            break;
    }
    //
    //  Pass URB on to HCD  (Open and close default endpoint, do it
    //  before getting here).
    if(submitRequestHere)
    {
        usbdStatus = HCD_SubmitRequest(USBD_GetHCDExtension(m_HostController), Urb);

    }
    //
    //  Check if we need to wait.
    //
    if(block)
    {
        if(USBD_PENDING(usbdStatus))
        {
            KeWaitForSingleObject(&SyncEvent, Executive, KernelMode, FALSE, NULL);
            usbdStatus = Urb->Header.Status;
        }
        Urb->Header.CompleteProc = NULL;
        Urb->Header.CompleteContext = NULL;
    }
    return usbdStatus;
}

USBD_STATUS IUsbDevice::CancelRequest(PURB Urb)
{
    return HCD_CancelRequest(USBD_GetHCDExtension(m_HostController), Urb);
}


PVOID IUsbDevice::GetExtension() const
/*++
Routine Description:
    Retrieves the value of a the class driver defined
    extension.
Return Value:
    Previously set class driver extension.
--*/
{
    return m_ClassDriverExtension;
}
PVOID IUsbDevice::SetExtension(PVOID Extension)
/*++
Routine Description:
    Allows a the class driver to set an extension.
Return Value:
    Previous value for class driver extension.
--*/
{
    PVOID temp = m_ClassDriverExtension;
    m_ClassDriverExtension = Extension;
    return temp;
}

BOOLEAN IUsbDevice::IsHardwareConnected() const
/*++
Routine Description:

    Retrieves whether the hardware is still connected.
    
    The implmentation depends on the fact that the very first
    step when getting DeviceDisconnected call from the HUB
    is to orphan the device node.

Return Value:

    Previously set class driver extension.

--*/
{
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        return (GetParent()->GetParent()) ? TRUE : FALSE;
    } else
    {
        return GetParent() ? TRUE : FALSE;
    }
}

UCHAR IUsbDevice::GetInterfaceNumber() const
/*++
Routine Description:
    Returns the interface number for a device
Return Value:
    The interface number that was originally
    in the interface descriptor.
--*/
{
    ASSERT((UDN_TYPE_INTERFACE == m_Type) || (UDN_TYPE_INTERFACE_FUNCTION == m_Type));
    return this->m_bInterfaceNumber;
}

void IUsbDevice::SetClassSpecificType(UCHAR ClassSpecificType)
/*++
Routine Description:
	Class driver calls this to set the class specific byte in the USB_DEVICE_TYPE
	returned for this device.
Return Value:
    none.
--*/
{
	m_ClassSpecificType = ClassSpecificType;
}

ULONG IUsbDevice::Win32FromUsbdStatus(USBD_STATUS UsbdStatus)
/*++
Routine Description:
    Returns a Win32 error code (NOT NT_STATUS) given a USBD_STATUS code.
Comment:
    This makes good sense because XID exposes an API directly,
    we may need to provide a separate function to convert to NT_STATUS
    for class drivers with layers above them.
--*/
{
    switch(UsbdStatus)
    {
        case USBD_STATUS_SUCCESS:
            return ERROR_SUCCESS;
        case USBD_STATUS_PENDING:
            return ERROR_IO_PENDING;
        case USBD_STATUS_ERROR:
        case USBD_STATUS_HALTED:
        case USBD_STATUS_CRC:
        case USBD_STATUS_BTSTUFF:
        case USBD_STATUS_DATA_TOGGLE_MISMATCH:
        case USBD_STATUS_STALL_PID:
        case USBD_STATUS_DEV_NOT_RESPONDING:
        case USBD_STATUS_PID_CHECK_FAILURE:
        case USBD_STATUS_UNEXPECTED_PID:
        case USBD_STATUS_DATA_OVERRUN:
        case USBD_STATUS_DATA_UNDERRUN:
        case USBD_STATUS_RESERVED1:
        case USBD_STATUS_RESERVED2:
        case USBD_STATUS_BUFFER_OVERRUN:
        case USBD_STATUS_BUFFER_UNDERRUN:
        case USBD_STATUS_NOT_ACCESSED:
        case USBD_STATUS_FIFO:
            return ERROR_IO_DEVICE;
        case USBD_STATUS_NO_MEMORY:
            return ERROR_OUTOFMEMORY;
        case USBD_STATUS_NO_BANDWIDTH:
            return ERROR_NO_SYSTEM_RESOURCES;
        case USBD_STATUS_CANCELED:
            return ERROR_CANCELLED;
        default:
            return ERROR_GEN_FAILURE;
    }
}

NTSTATUS IUsbDevice::NtStatusFromUsbdStatus(USBD_STATUS UsbdStatus)
/*++
Routine Description:
    Returns a NTSTATUS error code given a USBD_STATUS code.
Comment:
--*/
{
    switch(UsbdStatus)
    {
        case USBD_STATUS_SUCCESS:
            return STATUS_SUCCESS;
        case USBD_STATUS_PENDING:
            return STATUS_PENDING;
        case USBD_STATUS_ERROR:
        case USBD_STATUS_HALTED:
        case USBD_STATUS_CRC:
        case USBD_STATUS_BTSTUFF:
        case USBD_STATUS_DATA_TOGGLE_MISMATCH:
        case USBD_STATUS_STALL_PID:
        case USBD_STATUS_DEV_NOT_RESPONDING:
        case USBD_STATUS_PID_CHECK_FAILURE:
        case USBD_STATUS_UNEXPECTED_PID:
        case USBD_STATUS_DATA_OVERRUN:
        case USBD_STATUS_DATA_UNDERRUN:
        case USBD_STATUS_RESERVED1:
        case USBD_STATUS_RESERVED2:
        case USBD_STATUS_BUFFER_OVERRUN:
        case USBD_STATUS_BUFFER_UNDERRUN:
        case USBD_STATUS_NOT_ACCESSED:
        case USBD_STATUS_FIFO:
            return STATUS_IO_DEVICE_ERROR;
        case USBD_STATUS_NO_BANDWIDTH:
        case USBD_STATUS_NO_MEMORY:
            return STATUS_INSUFFICIENT_RESOURCES;
        case USBD_STATUS_CANCELED:
            return STATUS_CANCELLED;
        default:
            return STATUS_UNSUCCESSFUL;
    }
}

const USB_DEVICE_DESCRIPTOR8 *IUsbDevice::GetDeviceDescriptor() const
/*++
Routine Description:
    Provides Class Driver with access to first eight bytes of device descriptor.
--*/
{
    ASSERT(IsEnumTime());
    return &g_DeviceTree.m_DeviceDescriptor;
}

const USB_CONFIGURATION_DESCRIPTOR *IUsbDevice::GetConfigurationDescriptor() const
/*++
Routine Description:
    Provides Class Driver with access to Configuration descriptor.
    Only available to Interface Class Drivers at enum time.
--*/
{
    ASSERT(IsEnumTime());
    ASSERT((UDN_TYPE_INTERFACE == m_Type)||(UDN_TYPE_INTERFACE_FUNCTION == m_Type));
    return (PUSB_CONFIGURATION_DESCRIPTOR)g_DeviceTree.m_ConfigurationDescriptorBuffer;
}

const USB_INTERFACE_DESCRIPTOR *IUsbDevice::GetInterfaceDescriptor() const
/*++
Routine Description:
    Provides Class Driver with access to Configuration descriptor.
    Only available to Interface Class Drivers at enum time.
--*/
{
    ASSERT(IsEnumTime());
    ASSERT((UDN_TYPE_INTERFACE == m_Type)||(UDN_TYPE_INTERFACE_FUNCTION == m_Type));
    return g_DeviceTree.m_InterfaceDescriptor;
}


const USB_ENDPOINT_DESCRIPTOR *IUsbDevice::GetEndpointDescriptor(UCHAR EndpointType, BOOLEAN InDirection, UCHAR Index) const
/*++
Routine Description:
    Searches the class drivers interface for an endpoint.
    Only available to Interface Class Drivers at enum time.
Arguments:
    EndpointType - from usb100.h one of:
                    USB_ENDPOINT_TYPE_CONTROL
                    USB_ENDPOINT_TYPE_ISOCHRONOUS
                    USB_ENDPOINT_TYPE_BULK
                    USB_ENDPOINT_TYPE_INTERRUPT
    Direction - True if the endpoint direction is in.  Ignored for USB_ENDPOINT_TYPE_CONTROL.
    Index - Zero based index to endpoint of that type and direction.
    e.g. Find the first bulk-out endpoint: GetEndpointDescriptor(USB_ENDPOINT_TYPE_BULK, FALSE, 0).
         Find the second bulk-out endpoint: GetEndpointDescriptor(USB_ENDPOINT_TYPE_BULK, FALSE, 1).
Return Value:
    Pointer to endpoint descriptor for matching endpoint.
    NULL if endpoint not found.
--*/
{
    ASSERT(IsEnumTime());
    ASSERT((UDN_TYPE_INTERFACE == m_Type)||(UDN_TYPE_INTERFACE_FUNCTION == m_Type));

    PUCHAR currentParseLocation = (PUCHAR)g_DeviceTree.m_InterfaceDescriptor;
    PUCHAR endOfCongifuration = g_DeviceTree.m_ConfigurationDescriptorBuffer + 
            ((PUSB_CONFIGURATION_DESCRIPTOR)g_DeviceTree.m_ConfigurationDescriptorBuffer)->wTotalLength;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor = NULL;
    do
    {
        if(0==((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bLength) break;
        currentParseLocation += ((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bLength;
        if(currentParseLocation >= endOfCongifuration) break;
        
        if(((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE)
        {
            PUSB_ENDPOINT_DESCRIPTOR temp = (PUSB_ENDPOINT_DESCRIPTOR)currentParseLocation;
            if((temp->bmAttributes&USB_ENDPOINT_TYPE_MASK) == EndpointType)
            {
                if( 
                    (EndpointType != USB_ENDPOINT_TYPE_CONTROL) &&
					//When comparing BOOLEANs, compare their logical NOT's
                    (!USB_ENDPOINT_DIRECTION_IN(temp->bEndpointAddress) == !InDirection) 
                ){
                    if(0 == Index--)
                    {
                        endpointDescriptor = temp;
                        break;
                    }
                }
            }
        }   
    } while(((PUSB_COMMON_DESCRIPTOR)currentParseLocation)->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE);
    return endpointDescriptor;
}

ULONG IUsbDevice::GetPort() const
{
    return m_ExternalPort;
}

USBD_STATUS IUsbDevice::OpenDefaultEndpoint(PURB Urb)
/*++
Routine Description:

    Default endpoints are owned by USBD not by the class
    drivers.  However, USBD only uses the default endpoint
    during enumeration and then closes it.  If a class driver
    needs to send commands over the default endpoint is must
    send an URB_FUNCTION_OPEN_DEFAULT_ENDPOINT, which ends
    up in this routine.

    For UDN_TYPE_INTERFACE, there is one default endpoint
    shared between multiple interfaces (i.e. class drivers).
    The default endpoint may be open for the parent ofd type
    UDN_TYPE_COMPOSITE_FUNCTION, and therefore for at least one
    of the siblings.  In this case, we can handle the URB competely
    here.  If it is not open for the parent we need to open the
    default endpoint for the parent first.

    For UDN_TYPE_INTERFACE_FUNCTION, UDN_TYPE_FUNCTION, and
    UDN_TYPE_HUB the default endpoint is not shared.  We just
    need to copy some info out of the node into the URB before
    passing it down.

    Fortunately, OpenDefaultEndpoint is inherently synchronous so
    we can do post-processing without blocking.

    This routine does not use preallocating, because it
    should never be called during enumeration.
    
Arguments:
    
    Urb             -   URB to handle

Return Value:

    USBD_STATUS_SUCCESS
    USBD_STATUS_NO_MEMORY - If there is not enough memory for the endpoint.

--*/
{
    USBD_STATUS status;
    IUsbDevice *parent=NULL;
    //
    //  If this assertion is hit, someone is trying to open
    //  a default endpoint that is already open.
    //
    ASSERT(NULL == m_DefaultEndpoint);

    //
    //  Handle UDN_TYPE_INTERFACE.
    //
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        parent = GetParent();
        ASSERT(parent);
        if(parent->m_DefaultEndpoint)
        {
            //
            //  The parent was open just copy the endpoint handle.
            //
            m_DefaultEndpoint = parent->m_DefaultEndpoint;
            USB_DBG_TRACE_PRINT(("Open Default endpoint for UDN_TYPE_INTERFACE already open using parent's"));
            //
            //  Even inherently synchronous URBs need completion
            //
            Urb->Header.Status = USBD_STATUS_SUCCESS;
            USBD_CompleteRequest(Urb);
            return USBD_STATUS_SUCCESS;
        }
    }

    //
    //  We actually need to open an endpoint, which means we need
    //  to finish filling out the URB with stuff from the node.
    //
    Urb->OpenEndpoint.FunctionAddress = m_Address;
    Urb->OpenEndpoint.EndpointAddress = 0;
    Urb->OpenEndpoint.EndpointType = USB_ENDPOINT_TYPE_CONTROL;
    Urb->OpenEndpoint.MaxPacketSize = m_MaxPacket0;
    Urb->OpenEndpoint.LowSpeed = GetLowSpeed();
    Urb->OpenEndpoint.Hdr.Function = URB_FUNCTION_OPEN_ENDPOINT;
    Urb->OpenEndpoint.DataToggleBits = NULL;

    //
    //  Pass URB on to HCD
    //
    status = HCD_SubmitRequest(USBD_GetHCDExtension(m_HostController), Urb);
    
    //
    //  If the endpoint successfully opened, store away the handle.
    //
    if(USBD_SUCCESS(status))
    {
        m_DefaultEndpoint = Urb->OpenEndpoint.EndpointHandle;
        if(parent)
        {
             parent->m_DefaultEndpoint = Urb->OpenEndpoint.EndpointHandle;
        }
        ASSERT(m_DefaultEndpoint);
    } else
    {
        ASSERT(FALSE);
    }

    //
    //  Don't show caller default endpoint.
    //
    Urb->OpenEndpoint.EndpointHandle = NULL;
    //
    //  HCD completed the URB so we shouldn't.
    //
    return status;
}


USBD_STATUS IUsbDevice::CloseDefaultEndpoint(PURB Urb)
/*++
Routine Description:

    This routine is called in response to URB_CLOSE_DEFAULT_ENDPOINT and it
    undoes IUsbDevice::OpenDefaultEndpoint.
    
Arguments:
    
    Urb             -   URB to handle

Return Value:

    USBD_STATUS_SUCCESS or USBD_STATUS_PENDING

--*/
{
    //
    //  Mark the default endpoint close, but cache the handle
    //  in a local variable.
    //
    PVOID endpoint = m_DefaultEndpoint;
    m_DefaultEndpoint = NULL;
    //
    //  Handle UDN_TYPE_INTERFACE.
    //
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        IUsbDevice *sibling;
        //
        //  Now see if any of the siblings still have the endpoint open.
        //  If even one has it open, we can complete the URB
        //  and exit.
        //
        sibling = GetParent()->GetFirstChild();
        while(sibling)
        {
            //
            //  We don't check for NULL.  Why?  Look at the note in IUsbDevice::AddComplete.
            //
            if(sibling->m_DefaultEndpoint == endpoint)
            {
                Urb->Header.Status = USBD_STATUS_SUCCESS;
                USBD_CompleteRequest(Urb);
                return USBD_STATUS_SUCCESS;
            }
            //
            //  Try next sibling
            //
            sibling = sibling->GetSibling();
        }
        //
        // If we made it through the loop then close
        // endpoint for real
        //
        GetParent()->m_DefaultEndpoint = NULL;
    }

    //
    //  Munge URB and pass on to HCD
    //
    Urb->CloseEndpoint.Hdr.Function = URB_FUNCTION_CLOSE_ENDPOINT;
    Urb->CloseEndpoint.EndpointHandle = endpoint;
    Urb->OpenEndpoint.DataToggleBits = NULL;
    return HCD_SubmitRequest(USBD_GetHCDExtension(m_HostController), Urb);
}

IUsbDevice *IUsbDevice::FindChild(UCHAR PortNumber) const
/*++
    Returns a pointer to a child device given its port number.  NULL if not found.
--*/
{
    
    //  This should only be called for hubs, root_hubs and composite devices.
    ASSERT( (UDN_TYPE_HUB == m_Type) || (UDN_TYPE_ROOT_HUB == m_Type) || (UDN_TYPE_COMPOSITE_FUNCTION == m_Type));

    IUsbDevice *device = GetFirstChild();
    while( device && (device->m_PortNumber & ~UDN_LOWSPEED_PORT) != (PortNumber & ~UDN_LOWSPEED_PORT))
    {
        device = device->GetSibling();
    }
    return device;
}

void IUsbDevice::InsertChild(IUsbDevice *child)
/*++
    Inserts a device as a child of this device.
    It is important to make it the last child,
    because FindChild finds the first matching
    child.  If there is a remove and a reinsert
    between enumeration stages, there could be
    two matching children, one pending removal.
    So it is imporant to add from the opposite end
    as removal (i.e. finding , since we remove
    what we find).
--*/
{
    //  This should only be called for hubs, root_hubs and composite devices.
    ASSERT( (UDN_TYPE_HUB == m_Type) || (UDN_TYPE_ROOT_HUB == m_Type) || (UDN_TYPE_COMPOSITE_FUNCTION == m_Type));
    ASSERT(child >= g_DeviceTree.m_Devices);
    //
    //  Get the nodeIndex and debug assert that it is valid
    //
    UCHAR nodeIndex = child - g_DeviceTree.m_Devices;
    ASSERT(UDN_INVALID_NODE_INDEX > nodeIndex);

    //
    // We know the childs parent and sibling now, so fill it in.
    //
    child->m_Sibling = UDN_INVALID_NODE_INDEX;
    child->m_Parent = this - g_DeviceTree.m_Devices;
	

    IUsbDevice *existingChild = GetFirstChild();
    
	if(!existingChild)
    //
    //  If there are no children, then it is the first.
    //
    {
        m_FirstChild = nodeIndex;
    } else
    //
    //  Otherwise, we need to insert at the end
    //
    {
        //
        //	Make sure we are not inserting the child twice
        //
        ASSERT(existingChild!=child);
        
        //
        //  walk to the end.
        //
        while(UDN_INVALID_NODE_INDEX != existingChild->m_Sibling)
        {
            existingChild = existingChild->GetSibling();
            //
            //	Make sure we are not inserting the child twice
            //
            ASSERT(existingChild!=child);
        }
        //
        //  attach to the end
        //
        existingChild->m_Sibling = nodeIndex;
    }
}


BOOLEAN IUsbDevice::RemoveChild(IUsbDevice *child)
/*++
    Removes a device from the list of children.
    Returns TRUE if the are still more children.
--*/
{
    //  This should only be called for hubs, root_hubs and composite devices.
    ASSERT( (UDN_TYPE_HUB == m_Type) || (UDN_TYPE_ROOT_HUB == m_Type) || (UDN_TYPE_COMPOSITE_FUNCTION == m_Type));

    IUsbDevice *prevChild = GetFirstChild();
    BOOLEAN moreChildren = TRUE;
    if(prevChild == child)
    {
        m_FirstChild = child->m_Sibling;
        if(m_FirstChild == UDN_INVALID_NODE_INDEX) moreChildren = FALSE;
    } else
    {
        
        while(prevChild && (prevChild->GetSibling() != child))
        {                                   
            prevChild = prevChild->GetSibling();
        }
        ASSERT(prevChild);
        if(prevChild)
        {
            prevChild->m_Sibling = child->m_Sibling;
        }
    }
    child->m_Sibling = UDN_INVALID_NODE_INDEX;
    child->m_Parent = UDN_INVALID_NODE_INDEX;
    return moreChildren;
}
 
PNP_CLASS_ID IUsbDevice::GetClassId() const
{
	PNP_CLASS_ID classId;
	if(0xFF != m_ClassSpecificType)
	{
		classId.AsLong = m_ClassDriver->ClassId.AsLong;
		classId.USB.bClassSpecificType = m_ClassSpecificType;
	} else {
		classId.AsLong = -1;
	}
	return classId;
}


BOOLEAN IUsbDevice::IsEnumTime() const
/*++
    Test to see if this device is currently being enumerated.
    This routine gets called in DEBUG mode for lots of calls
    to IUsbDevice from the ClassDriver.  It is also used
    in the retail build to decide whether or not to use a pre-allocated
    an endpoint on open.
--*/
{
    //
    //  If you are not at DISPATCH_LEVEL you could
    //  leave EnumTime whenever, so effectively it
    //  is not EnumTime.
    //
    if(DISPATCH_LEVEL != KeGetCurrentIrql()) return FALSE;
    //
    // If nobody is being enumerated than we are not
    // being enumerated.
    //
    if(!g_DeviceTree.m_InProgress) return FALSE;
    
    //
    //  If we are UDN_TYPE_INTERFACE, then really it
    //  is our parent being enumerated.  We are than at enum
    //  time if:
    //  a) Our default endpoint non-NULL and different from
    //     our parents.
    //  b) Our previous sibling default endpoint is NULL or the same
    //      same as our parents.
    //  This condition implies that our parent is g_DeviceTree.m_CurrentEnum
    //  we will double check this in debug builds only.
    //
    //  We will decline to check b), because it is tough, and it would
    //  imply that a class driver got a handle to us prior to receiving
    //  AddDevice.  This driver doesn't call IsEnumTime for its own
    //  purposes anyway.
    //
    if(UDN_TYPE_INTERFACE == m_Type)
    {
        ASSERT(GetParent()); //Serious error for UDN_TYPE_INTERFACE not to have a parent.
        if( 
            (NULL == m_DefaultEndpoint) ||
            (GetParent()->m_DefaultEndpoint == m_DefaultEndpoint)
        ) return FALSE;
        ASSERT(g_DeviceTree.m_CurrentEnum == GetParent());
        return TRUE;
    }

    //
    //  So we are not of type UDN_TYPE_INTERFACE, which means
    //  that we are at EnumTime iff we are g_DeviceTree.m_CurrentEnum.
    //
    if(g_DeviceTree.m_CurrentEnum != this) return FALSE;
    return TRUE;
}


#ifndef SILVER  //SetExternalPort for BLACK builds

#define MAX_TREE_INDEX 5
void IUsbDevice::SetExternalPort()
/*++
  This routine calculates the external port number which includes
  the slot.

  0-3 is for a direct connect device or a top slot, and 16-19 if for a device
  that connects through the bottom slot.
--*/
{
    //
    //  Build Parent Device Array
    //
    IUsbDevice *pParentArrayBuffer[MAX_TREE_INDEX+1];
    IUsbDevice **pParentArray;
    UINT parentIndex = MAX_TREE_INDEX;
    UINT deviceIndex;
    pParentArrayBuffer[MAX_TREE_INDEX] = this;
    do
    {
        parentIndex--;
        ASSERT(parentIndex >= 0);
        pParentArrayBuffer[parentIndex] = pParentArrayBuffer[parentIndex+1]->GetParent();
    } while(UDN_TYPE_ROOT_HUB != pParentArrayBuffer[parentIndex]->m_Type);
    
    //
    //  Adjust pParentArray so that index 0 is the root hub
    //  and deviceIndex is the device itself.
    //
    pParentArray = pParentArrayBuffer + parentIndex;
    deviceIndex = MAX_TREE_INDEX - parentIndex;

    // This should not be possible
    ASSERT(0!=deviceIndex);

    //
    //  Call the appropriate configuration routine
    //
    if(XBOX_HW_FLAG_INTERNAL_USB_HUB & XboxHardwareInfo->Flags)
    {
        SetExternalPortWithHub(pParentArray, deviceIndex);
    } else
    {
        SetExternalPortWithoutHub(pParentArray, deviceIndex);
    }
}    


void IUsbDevice::SetExternalPortWithHub(IUsbDevice **pParentArray, UINT DeviceIndex)
{
    
    //
    //  We expect the device at index 1 to be a hub.
    //  Otherwise, someone is screwing with the configuration.
    //
    if(UDN_TYPE_HUB!=pParentArray[1]->m_Type)
    {
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }

    //
    //  That first hub must be plugged into port 1 of the 
    //  root hub.
    //
    if(1!=pParentArray[1]->GetHubPort())
    {
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }

    //If this is the internal hub we are done,
    if(1==DeviceIndex)
    {
        m_ExternalPort = 0;
        return;
    }

    //
    //  Otherwise, we can call the SetExternalPortWithoutHub
    //  after splicing the internal hub out of the topology.
    //
    pParentArray[1] = pParentArray[0];
    SetExternalPortWithoutHub(pParentArray+1, DeviceIndex-1);
}

void IUsbDevice::SetExternalPortWithoutHub(IUsbDevice **pParentArray, UINT DeviceIndex)
{
    //
    //  In general the port is the hub port that the device at index 1
    //  is plugged into. 
    //
    m_ExternalPort = (pParentArray[1]->GetHubPort()-1);
    if(m_ExternalPort >= XGetPortCount())
    {
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }
    // A board layout problem on the motherboard (and on the daughter
    // hub to work around a USB drive level issue on the MCP rev B01)
    // requires us to swap ports 0 and 1 with ports 2 and 3. We can
    // do this by XOR with 2.  This assumes that there is no port 5.
    //
    m_ExternalPort ^= 2;

    //
    //  If the device is a hub, its parent must be the root hub.
    //
    if(UDN_TYPE_HUB==pParentArray[DeviceIndex]->m_Type)
    {
        if(1 == DeviceIndex) return;
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }

    //
    //  If the device index is not plugged directly into the box
    //  (equivalent to the DeviceIndex being greater than 1)
    //  then the slot is determined by the HubPort that the device at
    //  DeviceIndex 2 is inserted into.  Port 1 is direct connect, port 2
    //  is top slot and port 3 is bottom slot.  Only port 3 changes m_ExternalPort
    //  (We need to reject anything plugged into another slot.)
    //
    if(DeviceIndex>1)
    {
        ULONG SlotPort = (pParentArray[2]->GetHubPort())-1;
        //
        //  Adjust m_ExternalPort with the slot information
        //
        if(SlotPort > 3)
        {
            m_ExternalPort = XDEVICE_ILLEGAL_PORT;    
        } else if(SlotPort == 2)
        {
            m_ExternalPort += 16;
        }
    }
    return;
}

#else  //SetExternalPort for SILVER builds
void IUsbDevice::SetExternalPort() 
/*++
   This routine calculates the external port number.  The external
   port number is 0-3 for devices that plug directly in to XBOX.
   This corresponds to the labels 1 through 4 on the outside of
   the box.  If the device is in the bottom slot of a game controller
   16 is added to the external port number.

   This code supports three configuration based on #define's
   
   USB_HOST_CONTROLLER_CONFIGURATION is to one of four
   values.

   USB_SINGLE_HOST_CONTROLLER
        Ports one to four on thre root host, become external ports 0-3.
        If externa; port four check for external hub, thus the external
        port could be greater.

   USB_DUAL_HOST_CONTROLLER_XDK
        The first Host Controllers' ports one and two, become external ports
        0 and 1.  The second Host Controllers' ports one and two
        become external ports 2 and 3.

        If external port three check for external hub, thus
        external port could be greater.

--*/
{
    //
    //  Build list of device.
    //
    IUsbDevice *pParentArrayBuffer[5];
    IUsbDevice **pParentArray;
    int parentIndex = 4;
    pParentArrayBuffer[4] = this;
    do
    {
        parentIndex--;
        ASSERT(parentIndex >= 0);
        pParentArrayBuffer[parentIndex] = pParentArrayBuffer[parentIndex+1]->GetParent();
    } while(UDN_TYPE_ROOT_HUB != pParentArrayBuffer[parentIndex]->m_Type);
    
    //
    //  Adjust pParentArray so that index 0, is the Root Hub
    //

    //pParentArray = &pParentArrayBuffer[parentIndex];
    pParentArray = pParentArrayBuffer + parentIndex;
    int maxIndex = 4 - parentIndex;
    
    //
    //  If the index is less than two, this is
    //  a hub, or some strange configuration
    //

    if(maxIndex < 1) return;
    
    //
    //  USB_SINGLE_HOST_CONTROLLER
    //

    #if (USB_HOST_CONTROLLER_CONFIGURATION==USB_SINGLE_HOST_CONTROLLER)
    ASSERT(1==pParentArray[0]->m_HostController->ControllerNumber); //It should always be host controller 1
    m_ExternalPort = pParentArray[1]->GetHubPort()-1;
    #endif //(USB_HOST_CONTROLLER_CONFIGURATION = USB_SINGLE_HOST_CONTROLLER)

    //
    //  USB_DUAL_HOST_CONTROLLER_XDK
    //

    #if (USB_HOST_CONTROLLER_CONFIGURATION==USB_DUAL_HOST_CONTROLLER_XDK)
    m_ExternalPort = pParentArray[1]->GetHubPort()-1;
    if(2==pParentArray[0]->m_HostController->ControllerNumber)
    {
        m_ExternalPort += 2;
    }
    #endif //(USBD_HOST_CONTROLLER_CONFIGURATION = USB_DUAL_HOST_CONTROLLER_XDK)

    int functionIndex = 2;

    //
    //  At this point the external port should be 0-3, (or 4 if it is a dual
    //  host controller for DVT) if not it is in an illegal port.
    //
    if(m_ExternalPort > 3)
    {
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }
    
    //
    //  Deal with the possiblity of an external hub
    //
    if(
        (UDN_TYPE_HUB == pParentArray[1]->m_Type) &&
        (UDN_HUB_TYPE_EXTERNAL == pParentArray[1]->m_ClassSpecificType)
    )
    {
        if(3 == m_ExternalPort)
        {
            //
            //  If there are no more nodes, we are being
            //  called on the external hub, we are done.
            //

            if(maxIndex < 2)  return;
            m_ExternalPort = pParentArray[2]->GetHubPort()+2;
            functionIndex = 3;
        } else
        {
            m_ExternalPort = XDEVICE_ILLEGAL_PORT;
            return;
        }
    }
    
    //
    //  Exclude functions directly
    //  connected to the box.
    //
    #ifndef USB_ENABLE_DIRECT_CONNECT
    if(UDN_TYPE_ROOT_HUB == pParentArray[functionIndex-1]->m_Type)
    {
        m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        return;
    }
    if(UDN_TYPE_COMPOSITE_FUNCTION == pParentArray[functionIndex-1]->m_Type)
    {
        if(UDN_TYPE_ROOT_HUB == pParentArray[functionIndex-2]->m_Type)
        {
            m_ExternalPort = XDEVICE_ILLEGAL_PORT;
        }
        return;
    }
    #endif

    //
    //  We may be evaluating the parent of 
    //  a function, or a device plugged
    //  directly into the box.
    //

    if(functionIndex > maxIndex)
    {
        return;
    }
    
    //
    //  Check for bottom slot (or illegal slot)
    //
    BOOLEAN fBottomSlot = FALSE;
    //
    //  If the parent is a hub, then the slot is our port number
    //  1 or 2 = top, 3 = bottom, > 3 is illegal.
    if(UDN_TYPE_HUB == pParentArray[functionIndex-1]->m_Type)
    {
        if(pParentArray[functionIndex]->GetHubPort() == 3)
        {
            fBottomSlot = TRUE;
        } else if(pParentArray[functionIndex]->GetHubPort() > 3)
        {
           m_ExternalPort = XDEVICE_ILLEGAL_PORT;
           return;
        }
    }

    //
    //  If the parent is a composite, e.g. Hawk, then the slot
    //  is based on our parent port.
    //
    else if(UDN_TYPE_COMPOSITE_FUNCTION == pParentArray[functionIndex-1]->m_Type)
    {
        if(UDN_TYPE_HUB == pParentArray[functionIndex-2]->m_Type)
        {
            if(pParentArray[functionIndex-1]->GetHubPort() == 3)
            {
                fBottomSlot = TRUE;
            } else if(pParentArray[functionIndex-1]->GetHubPort() > 3)
            {
                m_ExternalPort = XDEVICE_ILLEGAL_PORT;
                return;
            }
        }
    }

    if(fBottomSlot)
    {
        m_ExternalPort += 16;
    }
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbd\usbinit.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved. 

Module Name:

    usbinit.cpp

Abstract:

    Implementation of IUsbInit.  This class is passed to class drivers to collect
    resource information during initialization.

Environment:

    XBOX kernel mode only

Notes:

Revision History:

    01-10-01 created by Mitchell Dernis (mitchd)

--*/


//
//  Pull in OS headers
//
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xapidrv.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DBSU'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("USBD");

//
//  Pull in usbd headers
//
#include <usbd.h>

#pragma code_seg(".XPPCINIT")
#pragma data_seg(".XPPDINIT")
#pragma const_seg(".XPPRINIT")


ULONG IUsbInit::GetMaxDeviceTypeCount(PXPP_DEVICE_TYPE XppDeviceType)
{
    ULONG ulIndex;
    
    //
    //  Return XGetPortCount(), if m_pDeviceTypes is NULL.
    //
    if(NULL == m_pDeviceTypes)
    {
        return 0;
    }
    //
    //  Otherwise, find the device type.
    //
    for(ulIndex = 0; ulIndex < m_NumDeviceTypes; ulIndex++)
    {
        if( m_pDeviceTypes[ulIndex].DeviceType == XppDeviceType)
        {
            ULONG ulResult = m_pDeviceTypes[ulIndex].dwPreallocCount;
            #if DBG
            if(0==ulResult)
            {
                XDebugPrint(XDBG_WARNING, "XInitDevices", "A device type was explictly listed requesting 0 open instances.\n\
This forces the linkage of the supporting driver library.  Ommitting the device\ntype from the list is always better practice.");
            }
            #endif
            return ulResult;
        }
    }
    //
    //  If the device type was not registered, then we support 0.
    //  (Don't spew here, this could happen because one device
    //  supported by a given driver is in the list, but others are not.)
    return 0;
}

BOOL IUsbInit::UseDefaultCount()
{
    return m_pDeviceTypes ? FALSE : TRUE;
}

//
//  It is inline, because we just want something more robust
//  than a MAX macro which has a number of problems.
//  It is static because we don't want code generated for it
//
inline static void SetToMax(UCHAR& dest, UCHAR src) {if(src > dest) dest = src;}

void IUsbInit::RegisterResources(PUSB_RESOURCE_REQUIREMENTS pResourceRequirements)
/*++
  Routine Description:  
    Called by each driver for each type of connector it supports.  It is up to each
    driver to figure the maximum number of devices it can support in each slot type.
    If a driver supports composite devices (such as audio) it should add the resources
    of the composites together and register once.

    If a driver supports multiple device types (not composites) it should register them separately.
    If the devices have the same connector type, the driver may choose to register only the worst
    case device.
--*/
{
    PUSB_RESOURCE_REQUIREMENTS pConnectorResourceList;
    ULONG ulMaxDevices = pResourceRequirements->MaxDevices;
    ULONG ulMaxPorts = XGetPortCount();
    //
    //  Choose which list to reserve resource from
    //
    switch(pResourceRequirements->ConnectorType)
    {
        case  USB_CONNECTOR_TYPE_DIRECT:
            // Direct 
            pConnectorResourceList = m_Direct;
            break;
        case  USB_CONNECTOR_TYPE_HIGH_POWER:
            pConnectorResourceList = m_TopSlots;
            break;
        case  USB_CONNECTOR_TYPE_LOW_POWER:
            //
            //  Low power devices have their resource allocated first against
            //  the bottom slots
            //
            pConnectorResourceList = m_BottomSlots;
            // Low Power can go in top slots two, see
            // below for way we use the 0th index.
            SetToMax(
                m_TopSlots[0].MaxCompositeInterfaces,
                pResourceRequirements->MaxCompositeInterfaces
                );
            //
            //  If the device count exceeds the bottom slots, apply the rest
            //  towards the top-slots.  The easiest way is to change the
            //  connector type to high-power and call ourselves.
            //
            if(pResourceRequirements->MaxDevices > ulMaxPorts)
            {
                pResourceRequirements->MaxDevices -= (UCHAR)ulMaxPorts;
                pResourceRequirements->ConnectorType = USB_CONNECTOR_TYPE_HIGH_POWER;
                RegisterResources(pResourceRequirements);
                pResourceRequirements->MaxDevices += (UCHAR)ulMaxPorts;
                pResourceRequirements->ConnectorType = USB_CONNECTOR_TYPE_LOW_POWER;
                ulMaxDevices -= ulMaxPorts;
            }
            break;
    }
    //
    //  Composite Interface require nodes whether or not the device is opened.
    //  So we just use the 0th slot of the given type to track it, we are
    //  going to multiply by the number of ports anyway during Process.
    //
    SetToMax(
        pConnectorResourceList[0].MaxCompositeInterfaces,
        pResourceRequirements->MaxCompositeInterfaces
        );

    ASSERT(ulMaxDevices <= ulMaxPorts);

    // Some variables for walk the resource table.
    ULONG ulTempSlotIndex;
    ULONG ulDeviceCount;
    ULONG ulSlotIndex;
    //
    //  Record Control Endpoint Resources
    //
    ulSlotIndex = 0;
    ulDeviceCount = ulMaxDevices;
    while(ulDeviceCount && (ulSlotIndex < ulMaxPorts))
    {
        if(pConnectorResourceList[ulSlotIndex].MaxControlEndpoints > pResourceRequirements->MaxControlEndpoints)
        {
            //Increment the slot index and continue trying to place the resources somewhere.
            ulSlotIndex++;
            continue;
        } else
        {
            //Shift the resources to the right
            for(ulTempSlotIndex = ulMaxPorts; ulTempSlotIndex > ulSlotIndex; ulTempSlotIndex--)
            {
                pConnectorResourceList[ulTempSlotIndex].MaxControlEndpoints = pConnectorResourceList[ulTempSlotIndex-1].MaxControlEndpoints;
            }
            // Record the new resources
            pConnectorResourceList[ulSlotIndex].MaxControlEndpoints = pResourceRequirements->MaxControlEndpoints;
            ulSlotIndex++;
            ulDeviceCount--;
        }
    }
    //
    //  Record Bulk Endpoint Resources
    //
    ulSlotIndex = 0;
    ulDeviceCount = ulMaxDevices;
    while(ulDeviceCount && (ulSlotIndex < ulMaxPorts))
    {
        if(pConnectorResourceList[ulSlotIndex].MaxBulkEndpoints > pResourceRequirements->MaxBulkEndpoints)
        {
            //Increment the slot index and continue trying to place the resources somewhere.
            ulSlotIndex++;
            continue;
        } else
        {
            //Shift the resources to the right
            for(ulTempSlotIndex = ulMaxPorts; ulTempSlotIndex > ulSlotIndex; ulTempSlotIndex--)
            {
                pConnectorResourceList[ulTempSlotIndex].MaxBulkEndpoints = pConnectorResourceList[ulTempSlotIndex-1].MaxBulkEndpoints;
            }
            // Record the new resources
            pConnectorResourceList[ulSlotIndex].MaxBulkEndpoints = pResourceRequirements->MaxBulkEndpoints;
            ulSlotIndex++;
            ulDeviceCount--;
        }
    }
    //
    //  Record Interrupt Endpoint Resources
    //
    ulSlotIndex = 0;
    ulDeviceCount = ulMaxDevices;
    while(ulDeviceCount && (ulSlotIndex < ulMaxPorts))
    {
        if(pConnectorResourceList[ulSlotIndex].MaxInterruptEndpoints > pResourceRequirements->MaxInterruptEndpoints)
        {
            //Increment the slot index and continue trying to place the resources somewhere.
            ulSlotIndex++;
            continue;
        } else
        {
            //Shift the resources to the right
            for(ulTempSlotIndex = ulMaxPorts; ulTempSlotIndex > ulSlotIndex; ulTempSlotIndex--)
            {
                pConnectorResourceList[ulTempSlotIndex].MaxInterruptEndpoints = pConnectorResourceList[ulTempSlotIndex-1].MaxInterruptEndpoints;
            }
            // Record the new resources
            pConnectorResourceList[ulSlotIndex].MaxInterruptEndpoints = pResourceRequirements->MaxInterruptEndpoints;
            ulSlotIndex++;
            ulDeviceCount--;
        }
    }
    //
    //  Record Isochronous Endpoint Resources
    //
    ulSlotIndex = 0;
    ulDeviceCount = ulMaxDevices;
    while(ulDeviceCount && (ulSlotIndex < ulMaxPorts))
    {
        if(pConnectorResourceList[ulSlotIndex].MaxIsochEndpoints > pResourceRequirements->MaxIsochEndpoints)
        {
            //Increment the slot index and continue trying to place the resources somewhere.
            ulSlotIndex++;
            continue;
        } else
        {
            //Shift the resources to the right
            for(ulTempSlotIndex = ulMaxPorts; ulTempSlotIndex > ulSlotIndex; ulTempSlotIndex--)
            {
                pConnectorResourceList[ulTempSlotIndex].MaxIsochEndpoints = pConnectorResourceList[ulTempSlotIndex-1].MaxIsochEndpoints;
            }
            // Record the new resources
            pConnectorResourceList[ulSlotIndex].MaxIsochEndpoints = pResourceRequirements->MaxIsochEndpoints;
            ulSlotIndex++;
            ulDeviceCount--;
        }
    }

    //
    //  These are max'd across all connector types and all slots.  Unlike the other fields
    //  that are later summed across the connector types and slots.
    SetToMax(m_HcdResources.ControlTDQuota, pResourceRequirements->MaxControlEndpoints);
    SetToMax(m_HcdResources.BulkTDQuota, pResourceRequirements->MaxBulkTDperTransfer);
    SetToMax(m_HcdResources.IsochMaxBuffers, pResourceRequirements->MaxIsochMaxBuffers);
    //We keep track MaxComposite Interfaces, both per slot, and the global
    
    return;
}

VOID
IUsbInit::Process()
/*
    This routine takes all the table information, and boils it down to the information
    that USBD needs.
*/
{
    ULONG ulMaxPorts = XGetPortCount();
    ULONG ulControlEndpoints = 0;
    ULONG ulBulkEndpoints = 0;
    ULONG ulInterruptEndpoints = 0;
    
    // The members should all be 0 from the c'tor:
    
    
    //
    //  Figure the base number of nodes based on how
    //  many devices may be pending enumeration at once.
    //  This number to USBD_BASE_NODES_PER_PORT per port.
    //  This is four, one for the hub, one for "direct connect"
    //  and one for each slot.  It assumes there are no composites
    //  composites are figured in below.
    //
    m_NodeCount = USBD_BASE_NODES_PER_PORT*ulMaxPorts;

    //  Add two nodes: one for a host controller and one for
    //  an internal hub.  Alternatively, on SILVER we support
    //  two host controllers but no internal hub.
    //
    //  Also add a slop node.  This is for when a device stops
    //  responding and needs to be reenumerated on a full bus.
    //  Due to timing constraints only one slop node should ever
    //  be needed.
    //
    m_NodeCount += 3;
    
    //
    //  Now add nodes for the number of composites that can be found
    //  while enumerating a devices that is potentially not support.
    //
    m_NodeCount += 
        (m_Direct[0].MaxCompositeInterfaces +
         m_BottomSlots[0].MaxCompositeInterfaces +
         m_TopSlots[0].MaxCompositeInterfaces) * ulMaxPorts;

    //
    //  We also need nodes for composite interfaces of unsupported
    //  devices while they are enumerated, but before they are rejected.
    //
    SetToMax(m_MaxCompositeInterfaces,m_Direct[0].MaxCompositeInterfaces);
    SetToMax(m_MaxCompositeInterfaces,m_BottomSlots[0].MaxCompositeInterfaces);
    SetToMax(m_MaxCompositeInterfaces,m_TopSlots[0].MaxCompositeInterfaces);
    m_NodeCount += m_MaxCompositeInterfaces;

    //
    //  Add up the info that gets add across connector types and slots
    //
    for(ULONG ulSlotIndex = 0;  ulSlotIndex < ulMaxPorts; ulSlotIndex++)
    {
        //
        //  Sum the Interrupt endpoints by type  
        //
        ulInterruptEndpoints += m_Direct[ulSlotIndex].MaxInterruptEndpoints;
        ulInterruptEndpoints += m_BottomSlots[ulSlotIndex].MaxInterruptEndpoints;
        ulInterruptEndpoints += m_TopSlots[ulSlotIndex].MaxInterruptEndpoints;

        //
        //  Sum the Control endpoints by type  
        //
        ulControlEndpoints += m_Direct[ulSlotIndex].MaxControlEndpoints;
        ulControlEndpoints += m_BottomSlots[ulSlotIndex].MaxControlEndpoints;
        ulControlEndpoints += m_TopSlots[ulSlotIndex].MaxControlEndpoints;

        //
        //  Sum the Bulk endpoints by type  
        //
        ulBulkEndpoints += m_Direct[ulSlotIndex].MaxBulkEndpoints;
        ulBulkEndpoints += m_BottomSlots[ulSlotIndex].MaxBulkEndpoints;
        ulBulkEndpoints += m_TopSlots[ulSlotIndex].MaxBulkEndpoints;

        //
        //  Sum the Isoch endpoints by type
        //
        m_HcdResources.IsochEndpointCount += m_Direct[ulSlotIndex].MaxIsochEndpoints;
        m_HcdResources.IsochEndpointCount += m_BottomSlots[ulSlotIndex].MaxIsochEndpoints;
        m_HcdResources.IsochEndpointCount += m_TopSlots[ulSlotIndex].MaxIsochEndpoints;
    }

    //
    //  The hub driver is a special case.  It would be a different slot type,
    //  but instead it does not register, we just hard code it's resources.
    //  (The control qouta is less than enumerations, so don't worry about it.)
    //
    ulInterruptEndpoints += ulMaxPorts+1; //1 Interrupt EP per hub, one hub per port, plus an internal hub
    ulControlEndpoints += ulMaxPorts+1; //1 Control EP per hub, one hub per port, plus an internal hub

    //
    //  An extra control endpoint is needed for enumeration
    //  USBD also has a control TD quota
    ulControlEndpoints += 1;
    SetToMax(m_HcdResources.ControlTDQuota, USBD_CONTROL_TD_QUOTA);

    //
    //  add the control and bulk endpoints,
    //  we will add in the interrupt below.
    //
    m_HcdResources.EndpointCount = ulControlEndpoints + ulBulkEndpoints;

    //
    //  TD Count is the control quota plus the bulk quota plus
    //  one for each control and bulk endpoint, and USBD_INTERRUPT_TD_QUOTA
    //  times the number of interrupt endpoints.
    //
    m_HcdResources.TDCount = m_HcdResources.ControlTDQuota + m_HcdResources.BulkTDQuota +
                             m_HcdResources.EndpointCount +
                             (HCD_INTERRUPT_TD_QUOTA * ulInterruptEndpoints);

    //
    //  Now add in the interrupt endpoint.  Note that the isoch endpoint
    //  count is not included, ever.  Isoch endpoints are allocated differently.
    //
    m_HcdResources.EndpointCount += ulInterruptEndpoints;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbhub\hub.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    hub.cpp

Abstract:
	
	Basic entry point implementation of the USB HUB driver.
    
	
Environment:

	Designed for XBOX.

Notes:

Revision History:

    03-02-00 created by Mitchell Dernis (mitchd)

--*/


//
//	Pull in OS headers
//
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <usb.h>
#include <xdbg.h>

//
//	Setup the debug information for this file (see ..\inc\debug.h)
//
//#define PROMOTE_TRACE_TO_WARN //define this to get more spew in this module only

#define	MODULE_POOL_TAG			 'HBSU'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("USBHUB");

//
//	Pull in public usb headers
//
#include <usb.h>
//
//	Pull in hub headers
//
#include "hub.h"


//------------------------------------------------------------------------------
//  Declare USBHUB types and class.
//------------------------------------------------------------------------------
USB_DEVICE_TYPE_TABLE_BEGIN(USBHUB_)
USB_DEVICE_TYPE_TABLE_ENTRY(NULL)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION_DEVICE_LEVEL(USBHUB_, USB_DEVICE_CLASS_HUB, 0, 0)
#pragma data_seg(".XPP$ClassHub")
USB_CLASS_DECLARATION_POINTER(USBHUB_)
#pragma data_seg(".XPP$Data")

USBHUB_INFO						 GLOBAL_HubInfo;
USBHUB_ENUM_BLOCK				 GLOBAL_HubEnum;

#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID USBHUB_Init(IUsbInit *)
{
	
	//
	//	Initialize global structures
	//
	GLOBAL_HubInfo.NodeCount = USBHUB_MAXIMUM_HUB_COUNT;
	GLOBAL_HubInfo.NodesInUse = 0;
	KeInitializeTimer(&GLOBAL_HubEnum.WatchdogTimer);
}
#pragma code_seg(".XPPCODE")

VOID
USBHUB_WatchdogTimerProc(PKDPC Dpc, PVOID pvHubDevice, PVOID, PVOID)
{
    USB_DBG_WARN_PRINT(("Watchdog timer proc hit."));
    IUsbDevice *hubDevice = (IUsbDevice *)pvHubDevice;
    PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)hubDevice->GetExtension();
    switch(GLOBAL_HubEnum.WatchdogReason)
    {
        case USBHUB_WATCHDOG_REASON_ENUM:
            hubDevice->CancelRequest(&hubNode->Urb);
            break;
        case USBHUB_WATCHDOG_REASON_RESET_PORT:
            hubDevice->ResetComplete(USBD_STATUS_REQUEST_FAILED, GLOBAL_HubEnum.ResetContext);
            break;
        case USBHUB_WATCHDOG_REASON_DISABLE_PORT:
            hubDevice->DisableComplete(USBD_STATUS_REQUEST_FAILED, GLOBAL_HubEnum.ResetContext);
            break;
    }
    
}
__inline void USBHUB_SetEnumWatchdog(DWORD dwReason)
{
    LARGE_INTEGER wait;
    if(USBHUB_WATCHDOG_REASON_ENUM == dwReason)
    {
        wait.QuadPart = -5000*10000; //5 seconds for most commands
    } else
    {
        wait.QuadPart = -500*10000; //500 ms for disabling or reseting a port 
    }
    GLOBAL_HubEnum.WatchdogReason = dwReason;
    KeSetTimer(&GLOBAL_HubEnum.WatchdogTimer, wait, &GLOBAL_HubEnum.WatchdogTimerDpc);
}
__inline void USBHUB_ClearEnumWatchdog()
{
    KeCancelTimer(&GLOBAL_HubEnum.WatchdogTimer);
}

EXTERNUSB VOID
USBHUB_AddDevice(
	IN IUsbDevice *HubDevice
	)
{
	ULONG						nodeIndex = 0;
	PUSBHUB_DEVICE_NODE			hubNode;
	if(GLOBAL_HubInfo.NodesInUse < GLOBAL_HubInfo.NodeCount)
	{
		//
		//	Find a free node, and claim it.
		//
		while(GLOBAL_HubInfo.Nodes[nodeIndex].InUse) nodeIndex++;
		GLOBAL_HubInfo.NodesInUse++;
		hubNode = &GLOBAL_HubInfo.Nodes[nodeIndex];
		//
		//	Attach the node to our hubDevice
		//
		HubDevice->SetExtension((PVOID)hubNode);

		//
		//	Initialize what we can about the device.
		//
		hubNode->InUse = TRUE;
        hubNode->NotResponding = FALSE;
		hubNode->RemovePending = FALSE;
		hubNode->PortConnectedBitmap = 0;
        hubNode->ErrorCount = 0;

		//
		//	Open the default endpoint, this cannot fail, because we
		//	are at enum time.
		//
		USB_BUILD_OPEN_DEFAULT_ENDPOINT((PURB_OPEN_ENDPOINT)&hubNode->Urb);
		HubDevice->SubmitRequest(&hubNode->Urb);
				
		//
		//	Now get the configuration descriptor. We are guaranteed to get 
		//	only one enumeration request at a time, so we can just assume
		//	that all of our shared enumeration resources are available.
		//
		USB_BUILD_GET_DESCRIPTOR(
				(PURB_CONTROL_TRANSFER)&hubNode->Urb,
				USB_CONFIGURATION_DESCRIPTOR_TYPE,
				0,
				0,
				GLOBAL_HubEnum.EnumBuffer,
				sizeof(GLOBAL_HubEnum.EnumBuffer),
				(PURB_COMPLETE_PROC)USBHUB_EnumHubStage1,
				(PVOID)HubDevice
				);
        KeInitializeDpc(&GLOBAL_HubEnum.WatchdogTimerDpc, USBHUB_WatchdogTimerProc, HubDevice);

        USBHUB_SetEnumWatchdog(USBHUB_WATCHDOG_REASON_ENUM);
  		HubDevice->SubmitRequest(&hubNode->Urb);
	}
	else
	{
        ASSERT(FALSE);
		//
		//	Out of nodes so we cannot support the device
		//  (allow a retry though)
        //
		HubDevice->AddComplete(USBD_STATUS_NO_MEMORY);
	}
}

VOID
USBHUB_EnumHubStage1(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
{
	USBD_STATUS status;
	PUSBHUB_DEVICE_NODE	 hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	USBHUB_ClearEnumWatchdog();
	//
	//	It is possible that get configuration descriptor failed.
	//
	if(USBD_ERROR(Urb->Header.Status))
	{
		USBHUB_RemoveHubStage2(Urb, HubDevice);
        return;
	}
	//
	//	We need the following descriptors from the configuration:
	//		Endpoint Descriptor for Status Change Endpoint:
	//
	//
	PUSB_COMMON_DESCRIPTOR		commonDescriptor = (PUSB_COMMON_DESCRIPTOR)(GLOBAL_HubEnum.EnumBuffer);
	PUSB_ENDPOINT_DESCRIPTOR	endpointDescriptor;
	ULONG						enumBufferOffset = 0;
	do
	{
		enumBufferOffset += commonDescriptor->bLength;
		ASSERT(enumBufferOffset < sizeof(GLOBAL_HubEnum.EnumBuffer));
		commonDescriptor = (PUSB_COMMON_DESCRIPTOR)(GLOBAL_HubEnum.EnumBuffer + enumBufferOffset);
	}while(commonDescriptor->bDescriptorType != USB_ENDPOINT_DESCRIPTOR_TYPE);
	endpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR)commonDescriptor;
	
	if(endpointDescriptor->wMaxPacketSize <= 4)
	{
		hubNode->InterruptEndpointMaxPacket = (UCHAR) endpointDescriptor->wMaxPacketSize;
	} else
	{
		hubNode->InterruptEndpointMaxPacket = 4;
	}
    
    hubNode->InterruptEndpointAddress = endpointDescriptor->bEndpointAddress;
	
    //
	//	Now try to open the interrupt endpoint
	//	(this could fail due to limited bandwidth)
	//
	USB_BUILD_OPEN_ENDPOINT(
		(PURB_OPEN_ENDPOINT)Urb,
		endpointDescriptor->bEndpointAddress,
		endpointDescriptor->bmAttributes&USB_ENDPOINT_TYPE_MASK,
		hubNode->InterruptEndpointMaxPacket,
		//endpointDescriptor->bInterval
		(UCHAR)16
		);
	status = HubDevice->SubmitRequest(Urb);
	//
	//	If the open failed abort the enumeration, we cannot support the hub.
	//
	if(USBD_ERROR(status))
	{
		USBHUB_RemoveHubStage2(Urb, HubDevice);
	}
	else
	{
		//
		//	Save the interrupt handle
		//
		hubNode->InterruptEndpointHandle = Urb->OpenEndpoint.EndpointHandle;
        ASSERT(hubNode->InterruptEndpointHandle);
		//
		//	Configure the device.
		//
		USB_BUILD_SET_CONFIGURATION(
				(PURB_CONTROL_TRANSFER)Urb,
				1,
				(PURB_COMPLETE_PROC)USBHUB_EnumHubStage2,
				(PVOID)HubDevice
				);

        USBHUB_SetEnumWatchdog(USBHUB_WATCHDOG_REASON_ENUM);
		HubDevice->SubmitRequest(Urb);
	}
	return;
}

VOID
USBHUB_EnumHubStage2(
	PURB    Urb,
	IUsbDevice	*HubDevice
	)
{
	USBHUB_ClearEnumWatchdog();
    if(USBD_ERROR(Urb->Header.Status))
	{
		USBHUB_RemoveHubStage1(HubDevice);
        return;
	}
	
	//
	//	Get the Hub descriptor
	//
	USB_BUILD_CONTROL_TRANSFER(
		(PURB_CONTROL_TRANSFER)Urb,
		NULL,
		GLOBAL_HubEnum.EnumBuffer,				//The middle was initialized in stage 1
		sizeof(USB_HUB_DESCRIPTOR),
		USB_TRANSFER_DIRECTION_IN,
		(PURB_COMPLETE_PROC)USBHUB_EnumHubComplete,
		(PVOID)HubDevice,
		TRUE,
		USB_DEVICE_TO_HOST | USB_CLASS_COMMAND,
		USB_REQUEST_GET_DESCRIPTOR,
		USB_HUB_DESCRIPTOR_TYPE << 8,
		0,
		sizeof(USB_HUB_DESCRIPTOR)
		);

    USBHUB_SetEnumWatchdog(USBHUB_WATCHDOG_REASON_ENUM);

	HubDevice->SubmitRequest(Urb);
}

VOID
USBHUB_EnumHubComplete(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	 hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	PUSB_HUB_DESCRIPTOR  hubDescriptor;

    USBHUB_ClearEnumWatchdog();
	if(USBD_ERROR(Urb->Header.Status))
	{
		USBHUB_RemoveHubStage1(HubDevice);
        return;
	}
	//
	//	Strip the info we need out of the hub descriptor.
	//
	hubDescriptor = (PUSB_HUB_DESCRIPTOR)GLOBAL_HubEnum.EnumBuffer;
	hubNode->PortCount = hubDescriptor->bNumberOfPorts;
	//
	//	Assert that the hub does not have too many ports.
	//
	ASSERT(7 >= hubNode->PortCount);
	//
	//	We support only 7 ports on a hub!
	//
	if(hubNode->PortCount > 7) hubNode->PortCount = 7;
	USB_DBG_TRACE_PRINT(("Detected Hub with %d ports", hubNode->PortCount));
	//
	//	AddComplete.  What does this mean?
	//	1) That we are done with EnumArgs passed into us at USBHUB_AddHub.
	//	2) That we are done with our global enumeration resources, and thus
	//	   are ready to accept enumeration requests for additional hubs.
	//	3) We are ready to accept remove requests for this device.
	//
	HubDevice->AddComplete(USBD_STATUS_SUCCESS);

	//
	//	However, we still need to power on the ports
	//	and detect any devices that may be attached.
	//	Our normal port status change code will handle this.
	//	Basically we just indicate that the status of all the
	//	ports have changed and go out and enumerate.
	//
	hubNode->PortProcessIndex = 1;
	USB_DBG_TRACE_PRINT(("Powering port 1"));
	USB_BUILD_CONTROL_TRANSFER(
				(PURB_CONTROL_TRANSFER)&hubNode->Urb,
				NULL,
				NULL,
				0,
				0,
				(PURB_COMPLETE_PROC)USBHUB_PoweringPorts,
				(PVOID)HubDevice,
				FALSE,
				USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
				USB_REQUEST_SET_FEATURE,
				USBHUB_FEATURE_PORT_POWER,
				hubNode->PortProcessIndex,
				0
				);
	HubDevice->SubmitRequest(&hubNode->Urb);
}	

VOID
USBHUB_PoweringPorts(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	 hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	
	if(USBD_ERROR(Urb->Header.Status))
	{
		USB_DBG_WARN_PRINT(("Error Powering Port."));
		//
		//	Move on to next port.
		//
	}
	
	if(hubNode->PortProcessIndex == hubNode->PortCount)
	{
		USB_DBG_TRACE_PRINT(("Done powering ports, submit change notification request."));
		//
		//	All ports are powered, submit a change notification
		//	Urb, that should kick everything off.
		//
		hubNode->PortProcessIndex = 0;
		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
				(PURB_BULK_OR_INTERRUPT_TRANSFER)&hubNode->Urb,
				hubNode->InterruptEndpointHandle,
				hubNode->RequestBuffer,
				hubNode->InterruptEndpointMaxPacket,
				USB_TRANSFER_DIRECTION_IN,
				(PURB_COMPLETE_PROC)USBHUB_ChangeNotifyComplete,
				(PVOID)HubDevice,
				TRUE
				);
	} else
	//
	//	Update the port number and re-submit the URB to power the next port
	//
	{
		USB_DBG_TRACE_PRINT(("Powering port %d", hubNode->PortProcessIndex+1));
		Urb->ControlTransfer.SetupPacket.wIndex = ++hubNode->PortProcessIndex;
	}
	HubDevice->SubmitRequest(&hubNode->Urb);
}

VOID
USBHUB_ChangeNotifyComplete(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
/*++
Routine Description:
	This is the completion routine for transfers over the
	interrupt endpoint.  USB Hubs uses the interrupt endpoint
	to notify the driver that either the status of the hub or
	one of its hosts has changed.  The number of valid bits
	depends on the number of ports.  See Figure 11-14 in USB
	Specification Revision 1.1 for details.

	Here we copy the valid bits (we only support up to 7 ports)
	into PortStatusChangeBitmap before starting the kicking
	off the processing of changes.
Parameters:
	Urb			- URB that was just completed.
	HubNode		- HubNode of hub we are handling.
--*/
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}
	//
	//	If the URB is successful we need to start
	//	processing whatever happened.
	//
	if(USBD_SUCCESS(Urb->Header.Status))
	{
		hubNode->ErrorCount = 0;
        UCHAR Mask = (1 << (hubNode->PortCount+1))-1;
		hubNode->PortStatusChangeBitmap = hubNode->RequestBuffer[0]&Mask;
		USBHUB_PortStatusChange1(HubDevice);
		return;
    }

	//
	//	Increment the error count.
	//  With three failures in a row
    //  we report the device as not resonding.
    //
    if(3 < ++hubNode->ErrorCount)
    {
        hubNode->NotResponding = TRUE;
        HubDevice->DeviceNotResponding();
        return;
    }

    //
    //  Clear the endpoint halt
    // 
    USB_BUILD_CLEAR_FEATURE(
        (PURB_CONTROL_TRANSFER)Urb,
        USB_COMMAND_TO_ENDPOINT,
        USB_FEATURE_ENDPOINT_STALL,
        hubNode->InterruptEndpointAddress,
        (PURB_COMPLETE_PROC)USBHUB_ClearInterruptStallComplete,
        HubDevice
        );
    HubDevice->SubmitRequest(Urb);
}

VOID
USBHUB_ClearInterruptStallComplete(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
/*++
    After a notification fails on the interrupt endpoint (via a stall)
    the stall must be cleared before it can be retried.  The first
    step sending a (CLEAR_FEATURE(STALL)) is an asynchronous wire
    transfer this is the completion routine.

    We then instruct the USB core stack to clear the halt, and
    resubmitt the interrupt request.
--*/
{
    PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}
 
    //
    //  If we cannot clear the halt, then just
    //  report the device as not responding.
    //
    if(USBD_ERROR(Urb->Header.Status))
    {
        hubNode->NotResponding = TRUE;
        HubDevice->DeviceNotResponding();
        return;
    }
	
    //
    //  Build and submit URB to reset the endpoint state
    //  (This synchronous and cannot fail with valid parameters).
    //
    USB_BUILD_SET_ENDPOINT_STATE( 
        (PURB_GET_SET_ENDPOINT_STATE)Urb,
        hubNode->InterruptEndpointHandle,
        USB_ENDPOINT_STATE_CLEAR_HALT | USB_ENDPOINT_STATE_DATA_TOGGLE_RESET
        );
    HubDevice->SubmitRequest(Urb);
    
    //
    //  Resubmit the interrupt request
    //

    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
		&Urb->BulkOrInterruptTransfer,
		hubNode->InterruptEndpointHandle,
		hubNode->RequestBuffer,
		hubNode->InterruptEndpointMaxPacket,
		USB_TRANSFER_DIRECTION_IN,
		(PURB_COMPLETE_PROC)USBHUB_ChangeNotifyComplete,
		(PVOID)HubDevice,
		TRUE
		);
    HubDevice->SubmitRequest(Urb);
}

VOID
USBHUB_PortStatusChange1(
		IUsbDevice	*HubDevice
	)
/*++

Routine Description:
	This is the first in a series of routines that process
	status changes to hub or its ports.  The processing is a 
	loop (we can only handle one port at a time).  In this stage,
	we isolate one of the changed elements (either the hub itself,
	or a port on the hub) and start the processing.  After
	we are done processing that change we come back here to get
	status for the next one.
Arguments:
	HubNode - The node for the hub we need to process.

--*/
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	UCHAR mask = 1;
	//
	//	Find the the first bit set in 
	//	PortStatusChangeBitmap, note bit 0 means the hub status
	//	has changed.  This is why there are portcount + 1, valid bits.
	//
	USB_DBG_TRACE_PRINT(("Looking for ports with changed status"));
	for(
		hubNode->PortProcessIndex=0;
		hubNode->PortProcessIndex <= hubNode->PortCount;
		hubNode->PortProcessIndex++, mask <<= 1
	)
	{
		if(hubNode->PortStatusChangeBitmap & mask)
		{
			USB_DBG_TRACE_PRINT(("Port %d has changed status", hubNode->PortProcessIndex));
			//
			//	Clear the bit and break.
			//
			hubNode->PortStatusChangeBitmap &= ~mask;
			break;
		}
	}

	//*
	//*	Three cases follow:
	//*		1) PortProcessIndex is greater than port count: all changes
	//*			are processed, so we build the URB as a request for
	//*			change notification on the interrupt-in endpoint.
	//*
	//*		2) PortProcessIndex is 0:  the status of the hub itself
	//*			has changed.  We build a request to get the
	//*			status of the hub.
	//*
	//*		3) PortProcessIndex is between 1 and the port count, inclusive. (Basically,
	//*			not case 1 or 2.)  We build a request to get the status of the
	//*			port.
	//*
	//*		In all three cases we have build an URB.  We then submit it, and return.

	//
	//	1) No more changes
	//
	if(hubNode->PortProcessIndex > hubNode->PortCount)
	{
		USB_DBG_TRACE_PRINT(("All port changes are processed, submitting URB on change notification endpoint"));
		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
				(PURB_BULK_OR_INTERRUPT_TRANSFER)&hubNode->Urb,
				hubNode->InterruptEndpointHandle,
				hubNode->RequestBuffer,
				hubNode->InterruptEndpointMaxPacket,
				USB_TRANSFER_DIRECTION_IN,
				(PURB_COMPLETE_PROC)USBHUB_ChangeNotifyComplete,
				(PVOID)HubDevice,
				TRUE
				);
	
	}
	//
	//	2) Hub status changed
	//
	else if(0==hubNode->PortProcessIndex)
	{
		USB_DBG_TRACE_PRINT(("Hub status has changed.  Querying for hub status."));
		USB_BUILD_CONTROL_TRANSFER(
			(PURB_CONTROL_TRANSFER)&hubNode->Urb,
			NULL,
			hubNode->RequestBuffer,
			4,
			USB_TRANSFER_DIRECTION_IN,
			(PURB_COMPLETE_PROC)USBHUB_HubStatusChange,
			(PVOID)HubDevice,
			FALSE,
			USB_DEVICE_TO_HOST | USB_CLASS_COMMAND | USB_COMMAND_TO_DEVICE,
			USB_REQUEST_GET_STATUS,
			0,
			0,
			4
			);	
		
	} 
	//
	//	2) Port status changed
	//
	else
	{
		USB_DBG_TRACE_PRINT(("Port %d status has changed.  Querying for port status.", hubNode->PortProcessIndex));
		USB_BUILD_CONTROL_TRANSFER(
			(PURB_CONTROL_TRANSFER)&hubNode->Urb,
			NULL,
			hubNode->RequestBuffer,
			4,
			USB_TRANSFER_DIRECTION_IN,
			(PURB_COMPLETE_PROC)USBHUB_PortStatusChange2,
			(PVOID)HubDevice,
			FALSE,
			USB_DEVICE_TO_HOST | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
			USB_REQUEST_GET_STATUS,
			0,
			hubNode->PortProcessIndex,
			4
			);
	}
	
	//
	//	Submit the request that we have built
	//
	HubDevice->SubmitRequest(&hubNode->Urb);
}

VOID
USBHUB_PortStatusChange2(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
/*++

Routine Description:
	Stage two of processing a change to a hub.  The Urb to get
	the status of the port should now have completed.
Arguments:
	Urb		- URB that was submitted to get status.
	HubNode - The node for the hub we need to process.
--*/
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}
	//
	//	If the URB is successful we need to start
	//	processing whatever happened.
	//
	if(USBD_SUCCESS(Urb->Header.Status))
	{
        hubNode->ErrorCount = 0;
		//
		//	One or more flags are set
		//
		USBHUB_PortProcessChange(HubDevice);
	}else
	{
		//
		//	Deal with the error case.
		//
        if(3 < ++hubNode->ErrorCount)
        {
            hubNode->NotResponding = TRUE;
            HubDevice->DeviceNotResponding();
        } else
        {
            //
            //  Resubmit the request.
            //
            Urb->ControlTransfer.TransferBufferLength = 4;
            HubDevice->SubmitRequest(Urb);
        }
	}
}

VOID
USBHUB_HubStatusChange(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	USHORT FeatureToClear;
	
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}

    //
    //	Deal with the error case.
	//
    if(USBD_ERROR(Urb->Header.Status))
    {
        if(3 < ++hubNode->ErrorCount)
        {
            hubNode->NotResponding = TRUE;
            HubDevice->DeviceNotResponding();
    
        } else
        {
            //
            //  Resubmit the request.
            //
            Urb->ControlTransfer.TransferBufferLength = 4;
            HubDevice->SubmitRequest(Urb);
        }
        return;
    } 
    
    hubNode->ErrorCount = 0;

	//
	//	The status of the whole hub changed
	//
	if(hubNode->PortStatus.StatusChange&USBHUB_C_HUB_STATUS_LOCAL_POWER)
	{
		FeatureToClear = USBHUB_FEATURE_C_HUB_LOCAL_POWER;
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_HUB_STATUS_LOCAL_POWER;
	} else if(hubNode->PortStatus.StatusChange&USBHUB_C_HUB_STATUS_OVER_CURRENT)
	{
		FeatureToClear = USBHUB_FEATURE_C_HUB_OVER_CURRENT;
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_HUB_STATUS_OVER_CURRENT;
	} else
	{
		USB_DBG_WARN_PRINT(("HubStatusChange called when there was none."));
		USBHUB_PortStatusChange1(HubDevice);
		return;
	}
	//
	//	Build the clear feature request, and send it
	//
	USB_BUILD_CONTROL_TRANSFER(
		(PURB_CONTROL_TRANSFER)&hubNode->Urb,
		NULL,
		NULL,
		0,
		0,
		(PURB_COMPLETE_PROC)USBHUB_ClearHubFeatureComplete,
		(PVOID)HubDevice,
		FALSE,
		USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_DEVICE,
		USB_REQUEST_CLEAR_FEATURE,
		FeatureToClear,
		0,
		0
		);
	HubDevice->SubmitRequest(&hubNode->Urb);
}

VOID
USBHUB_ClearHubFeatureComplete(
			PURB	Urb,
			IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}
    
    //
    //	Deal with the error case.
	//
    if(USBD_ERROR(Urb->Header.Status))
    {
        if(3 < ++hubNode->ErrorCount)
        {
            hubNode->NotResponding = TRUE;
            HubDevice->DeviceNotResponding();
    
        } else
        {
            //
            //  Resubmit the request.
            //
            Urb->ControlTransfer.TransferBufferLength = 4;
            HubDevice->SubmitRequest(Urb);
        }
        return;
    } 
    hubNode->ErrorCount = 0;

	USBHUB_PortStatusChange1(HubDevice);
}

VOID
USBHUB_PortProcessChange(
	IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	USHORT FeatureToClear;
	//
	//	Check for a reset port that completed.
	//
	if(hubNode->PortStatus.StatusChange&USBHUB_C_PORT_STATUS_RESET)
	{
		USB_DBG_TRACE_PRINT(("Port reset completed"));
		//
		//	We can signal that the reset is completed
		//	successfully.
		//
        if(
            (USBHUB_WATCHDOG_REASON_RESET_PORT == GLOBAL_HubEnum.WatchdogReason) &&
            (GLOBAL_HubEnum.ResetContext)
        )
        {
            USBD_STATUS status = USBD_STATUS_SUCCESS;
            USBHUB_ClearEnumWatchdog();
            //
            //  Under exterme hot-plug conditions, the
            //  port can be disabled even before we
            //  realise that the reset was complete.
            //  Just say that the reset failed.
            //
            if(
                !(hubNode->PortStatus.Status & USBHUB_PORT_STATUS_ENABLE) ||
                (hubNode->PortStatus.Status & USBHUB_PORT_STATUS_RESET)
            )
            {
				USB_DBG_WARN_PRINT(("Reset Completed, but port not enabled, failing port reset!"));
                status = USBD_STATUS_REQUEST_FAILED;
            } else
            {
                //
                //  Check for low-speed
                //
                if(hubNode->PortStatus.Status&USBHUB_PORT_STATUS_LOW_SPEED)
                {
                    status = USBD_STATUS_LOWSPEED;
                }
            }
            PVOID Context = GLOBAL_HubEnum.ResetContext;
            GLOBAL_HubEnum.ResetContext = NULL;
            HubDevice->ResetComplete(status, Context);
            USB_DBG_TRACE_PRINT(("Returned from notifying port reset"));
        }
		//
		//	Clear the change status
		//
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_RESET;
		FeatureToClear = USBHUB_FEATURE_C_PORT_RESET;
	}
	//
	//	Check for a change in the connection status
	//
	else if(hubNode->PortStatus.StatusChange&USBHUB_C_PORT_STATUS_CONNECTION)
	{
		UCHAR PortNumber = hubNode->PortProcessIndex;
		UCHAR PortMask = 1 << (PortNumber-1);
		//
		//	Is it a connect or a disconnect?
		//
		if(hubNode->PortStatus.Status&USBHUB_PORT_STATUS_CONNECTION)
		{
            
            if(hubNode->PortConnectedBitmap&PortMask)
		    {
			   USB_DBG_WARN_PRINT(("Remove and Add in One Notification."));
               HubDevice->DeviceDisconnected(PortNumber);
		    }
            //
            //  We used to just report DeviceConnected here.
            //  Now do this RelatchPortSpeed thing which works
            //  around a bug in the TI chipset.  It keeps the
            //  state machine going, so we just return afterwards.
            //
            USBHUB_RelatchPortSpeed(HubDevice);
            return;
		}else
		{
			if(hubNode->PortConnectedBitmap&PortMask)
			{
				hubNode->PortConnectedBitmap &= ~PortMask;
    			HubDevice->DeviceDisconnected(PortNumber);
			}
		}
		//
		//	Clear the change status
		//
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_CONNECTION;
		FeatureToClear = USBHUB_FEATURE_C_PORT_CONNECTION;
	}
	//
	//	Check for a change in the enable status
	//
	else if(hubNode->PortStatus.StatusChange&USBHUB_C_PORT_STATUS_ENABLE)
	{
        //
        //  Nothing to do.
        //
		
        //
		//	Clear the change status
		//
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_ENABLE;
		FeatureToClear = USBHUB_FEATURE_C_PORT_ENABLE;
	}
	//
	//	Check for a change in the suspend status
	//
	else if(hubNode->PortStatus.StatusChange&USBHUB_C_PORT_STATUS_SUSPEND)
	{
		//
		//	Clear the change status
		//
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_SUSPEND;
		FeatureToClear = USBHUB_FEATURE_C_PORT_SUSPEND;
		USB_DBG_WARN_PRINT(("Unexpected changed in suspend status, Xbox does not suspend devices."));
	}
	else if(hubNode->PortStatus.StatusChange&USBHUB_C_PORT_STATUS_OVER_CURRENT)
	{
		//
		//	Clear the change status
		//
		hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_OVER_CURRENT;
		FeatureToClear = USBHUB_FEATURE_C_PORT_OVER_CURRENT;
		USB_DBG_WARN_PRINT(("Overcurrent detected on port %d", hubNode->PortProcessIndex));
	} else
	{
		USB_DBG_WARN_PRINT(("Port change bitmask not recognized (0x%0.8x)  Ignoring it.", hubNode->PortStatus.StatusChange));
		hubNode->PortStatus.StatusChange = 0;  //NULL this out so we don't get called back.
		USBHUB_ClearPortFeatureComplete(&hubNode->Urb, HubDevice);
		return;
	}

	//
	//	Build the clear feature request
	//
	
	USB_DBG_TRACE_PRINT(("Clearing the feature %d.", FeatureToClear));
	USB_BUILD_CONTROL_TRANSFER(
		(PURB_CONTROL_TRANSFER)&hubNode->Urb,
		NULL,
		NULL,
		0,
		0,
		(PURB_COMPLETE_PROC)USBHUB_ClearPortFeatureComplete,
		(PVOID)HubDevice,
		FALSE,
		USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
		USB_REQUEST_CLEAR_FEATURE,
		FeatureToClear,
		hubNode->PortProcessIndex,
		0
		);
	HubDevice->SubmitRequest(&hubNode->Urb);
}

VOID
USBHUB_ClearPortFeatureComplete(
	PURB	Urb,
	IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	//
	//	Check for pending removal
	//
	if(hubNode->RemovePending)
	{
		//
		//	The removal was waiting for this URB to complete 
		//	so start the removal process.
		//
		USBHUB_RemoveHubStage1(HubDevice);
		return;
	}
	//
	//	Other changes to process on this port?
	//
	if(hubNode->PortStatus.StatusChange)
	{
		USB_DBG_TRACE_PRINT(("Other status bits on this port changed."));
		USBHUB_PortProcessChange(HubDevice);
	} else
	//
	//	Loop back and process other ports that may have changed.
	//
	{
		USB_DBG_TRACE_PRINT(("Done with this port, check others."));
		USBHUB_PortStatusChange1(HubDevice);
	}
}

EXTERNUSB VOID
USBHUB_RemoveDevice(
	IN IUsbDevice *HubDevice
	)
{
	ULONG				portBit;
	UCHAR				portIndex;
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	
	ASSERT_DISPATCH_LEVEL();
	
	
	ASSERT(hubNode);
		
	//
	//	Mark the removed flag.
	//
	hubNode->RemovePending = TRUE;
	
	//
	//	Report any devices that were connected
	//	to the hub, as disconnected.
	//
	portBit = 1;
	portIndex = 1;
	do
	{
		if(hubNode->PortConnectedBitmap & portBit)
		{
			HubDevice->DeviceDisconnected(portIndex);
			hubNode->PortConnectedBitmap &= ~portBit;
		}
		portBit <<= 1;
	}while( ++portIndex <= hubNode->PortCount );

    //
    //  If the hub was reported as not responding, then
    //  we there is no outstanding I/O.  We can just start the
    //  close procedure.
    //
    if(hubNode->NotResponding)
    {
        USBHUB_RemoveHubStage1(HubDevice);
    }
}


VOID
USBHUB_RemoveHubStage1(
	IN IUsbDevice *HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	USB_DBG_ENTRY_PRINT(("Entering USBHUB_RemoveHubStage1"));
	ASSERT_DISPATCH_LEVEL();
	//
	//	Close the interrupt endpoint
	//
	USB_BUILD_CLOSE_ENDPOINT(
					(PURB_CLOSE_ENDPOINT)&hubNode->Urb,
					hubNode->InterruptEndpointHandle,
					(PURB_COMPLETE_PROC)USBHUB_RemoveHubStage2,
					(PVOID)HubDevice
					);
	HubDevice->SubmitRequest(&hubNode->Urb);
}

VOID
USBHUB_RemoveHubStage2(
	PURB	Urb,
	IUsbDevice	*HubDevice
	)
{
	USB_DBG_ENTRY_PRINT(("Entering USBHUB_RemoveHubStage2"));
	ASSERT_DISPATCH_LEVEL();
	//
	//	Close the default endpoint
	//
	USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
							(PURB_CLOSE_ENDPOINT)Urb,
							(PURB_COMPLETE_PROC)USBHUB_RemoveHubComplete,
							(PVOID)HubDevice
							);
	HubDevice->SubmitRequest(Urb);
}

VOID
USBHUB_RemoveHubComplete(
	PURB	Urb,
	IUsbDevice	*HubDevice
	)
{
	PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
	ASSERT_DISPATCH_LEVEL();
	USB_DBG_ENTRY_PRINT(("Entering USBHUB_RemoveHubComplete"));
	//
	//	Free the hubNode
	//
	HubDevice->SetExtension(NULL);
	hubNode->InUse = FALSE;
	GLOBAL_HubInfo.NodesInUse--;
	//
	//	Notify our bus driver that we are done processing
	//	remove, or that we have aborted an Add.
	//
	if(hubNode->RemovePending)
	{
		HubDevice->RemoveComplete();
	}else
	{
        //
        //  Fail, but allow retry. (Remove ASSERT)
        //
        USB_DBG_WARN_PRINT(("Abort Enumeration, allow retry."));
        HubDevice->AddComplete(USBD_STATUS_NO_MEMORY);
	}
}

	
VOID
USBHUB_DisableResetPort(
	IN IUsbDevice *HubDevice,
	IN UCHAR	PortNumber,
	IN PVOID	Context,
    IN BOOLEAN  Disable
	)
{
	PUSBHUB_DEVICE_NODE hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
    UCHAR bRequest = USB_REQUEST_SET_FEATURE;
    USHORT wValue = USBHUB_FEATURE_PORT_RESET;
    DWORD dwReason = USBHUB_WATCHDOG_REASON_RESET_PORT;
    PURB_COMPLETE_PROC CompleteProc = (PURB_COMPLETE_PROC)USBHUB_ResetComplete;
	
	//
	//	If we didn't find the hub, or if the port number is invalid
	//	call the complete routine with an error, then return.
	//
	
	if( !hubNode || (hubNode->PortCount < PortNumber) )
	{
		USB_DBG_ERROR_PRINT(("Reset failed due to invalid parameter.", hubNode));
		HubDevice->ResetComplete(USBD_STATUS_INVALID_PARAMETER, Context);
		return;
	}

	//
	//	Save of the completion information.
	// (We can only handle one reset or disable at a time)
	GLOBAL_HubEnum.ResetContext = Context;

	//
	//	Build and send an URB for reseting a port.
	//
    if(Disable)
    {
        bRequest = USB_REQUEST_CLEAR_FEATURE;
        wValue = USBHUB_FEATURE_PORT_ENABLE;
        CompleteProc = (PURB_COMPLETE_PROC)USBHUB_DisableComplete;
        dwReason = USBHUB_WATCHDOG_REASON_DISABLE_PORT;
        USB_DBG_TRACE_PRINT(("Disabling Port %d.", PortNumber));
    }   
    else
    {
        USB_DBG_TRACE_PRINT(("Reseting Port %d.", PortNumber));
    }
	USB_BUILD_CONTROL_TRANSFER(
		(PURB_CONTROL_TRANSFER)&GLOBAL_HubEnum.ResetUrb,
		NULL,
		NULL,
		0,
		0,
		CompleteProc,
		(PVOID)HubDevice,
		FALSE,
		USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
		bRequest,
		wValue,
		PortNumber,
		0
		);
    
    //
    //  Set the watchdog so that disable and\or reset don't
    //  hang.  This could happen if the hub is removed.
    //
    USBHUB_SetEnumWatchdog(dwReason);
	HubDevice->SubmitRequest(&GLOBAL_HubEnum.ResetUrb);
}

VOID
USBHUB_ResetComplete(
	IN PURB    Urb,
	IN IUsbDevice *HubDevice
	)
{
	//
	//	If the set feature reset transmission failed, notify
	//	completion procedure.
	//
	if(USBD_ERROR(Urb->Header.Status))
	{
		USBHUB_ClearEnumWatchdog();
        USB_DBG_TRACE_PRINT(("Port %d Reset failed.", Urb->ControlTransfer.SetupPacket.wIndex));
		HubDevice->ResetComplete(Urb->Header.Status, GLOBAL_HubEnum.ResetContext);
	}
	//
	//	Otherwise we are waiting for the port status to change.
	//	Nothing to do.
}

VOID
USBHUB_DisableComplete(
	IN PURB    Urb,
	IN IUsbDevice *HubDevice
	)
{
    //
    //  Pass the status to disable
    //
    USBHUB_ClearEnumWatchdog();
	HubDevice->DisableComplete(Urb->Header.Status, GLOBAL_HubEnum.ResetContext);
}


//
// HACK: For TI hub, but we apply it to all hubs, since it does no harm.
//
VOID
USBHUB_RelatchPortSpeed(
    IUsbDevice *HubDevice
    )
/*++
 Routine Description:
   Sends a CLEAR_PORT_FEATURE(FEATURE_PORT_ENABLE) to "disable" the hub when a
   new device is connected.  This is a very strange thing to do, but works
   around a bug in the TI hub chip.  In short, the TI hub debounces the full-speed
   \low-speed of a newly inserted device poorly.  It will (often enough) latch in
   low-speed when a full-speed device is connected.  TI claims that sending a disable
   command will cause the speed bit to relatch, and that fixes the problem.

   This is better than the previous work-around at it only introduces an extra
   millisecond delay (as opposed to a 120 ms retry) and should prevent any
   wierd errors.  We don't know what 3rd party devices will do if someone speaks
   low-speed to them.
--*/
{
    PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
    USB_BUILD_CONTROL_TRANSFER(
	    (PURB_CONTROL_TRANSFER)&hubNode->Urb,
		NULL,
		NULL,
		0,
		0,
		(PURB_COMPLETE_PROC)USBHUB_RelatchPortSpeedComplete,
		(PVOID)HubDevice,
		FALSE,
		USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
		USB_REQUEST_CLEAR_FEATURE,
		USBHUB_FEATURE_PORT_ENABLE,
		hubNode->PortProcessIndex,
		0
		);
	HubDevice->SubmitRequest(&hubNode->Urb);
}


VOID
USBHUB_RelatchPortSpeedComplete(
    IN PURB    Urb,
    IUsbDevice *HubDevice
    )
/*++
  Routine Description:
   Completion routine for USBHUB_RelatchPortSpeed.

   Actually, tells USBD about the new device.
--*/
{

    PUSBHUB_DEVICE_NODE	hubNode = (PUSBHUB_DEVICE_NODE)HubDevice->GetExtension();
    hubNode->PortStatus.StatusChange &= ~USBHUB_C_PORT_STATUS_CONNECTION;
    UCHAR ucPortMask = 1 << (hubNode->PortProcessIndex-1);

    HubDevice->DeviceConnected(hubNode->PortProcessIndex, 5);
    hubNode->PortConnectedBitmap |= ucPortMask;
    
    USB_DBG_TRACE_PRINT(("Clearing the feature %d.", FeatureToClear));
	USB_BUILD_CONTROL_TRANSFER(
		(PURB_CONTROL_TRANSFER)&hubNode->Urb,
		NULL,
		NULL,
		0,
		0,
		(PURB_COMPLETE_PROC)USBHUB_ClearPortFeatureComplete,
		(PVOID)HubDevice,
		FALSE,
		USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
		USB_REQUEST_CLEAR_FEATURE,
		USBHUB_FEATURE_C_PORT_CONNECTION,
		hubNode->PortProcessIndex,
		0
		);
	HubDevice->SubmitRequest(&hubNode->Urb);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbtest\hubtest.cpp ===
#include <usbtest.h>
extern "C" 
{
#include "ohcd.h"
}
#include "hub.h"


BOOL IsDeviceAttached(IUsbDevice *pHub, UCHAR uHubPort)
{
    UCHAR ucConnectedPorts;
    if(UDN_TYPE_ROOT_HUB==pHub->m_Type)
    {
        POHCD_DEVICE_EXTENSION deviceExtension;
        deviceExtension = (POHCD_DEVICE_EXTENSION)
                           USBD_GetHCDExtension(pHub->m_HostController);
        ucConnectedPorts = deviceExtension->RootHubObject.DeviceDetectedBitmap;
    } else
    {
        ASSERT(UDN_TYPE_HUB==pHub->m_Type);
        PUSBHUB_DEVICE_NODE pUsbHub;
        pUsbHub = (PUSBHUB_DEVICE_NODE)pHub->GetExtension();
        ucConnectedPorts = pUsbHub->PortConnectedBitmap;
    }
    if(ucConnectedPorts&(1<<(uHubPort-1)))
    {
        return TRUE;
    }
    return FALSE;
}


VOID
DisableHubPortSync(
	IN IUsbDevice *pHub,
	IN UCHAR	PortNumber
	)
{
    if(UDN_TYPE_ROOT_HUB==pHub->m_Type)
    {
        POHCD_DEVICE_EXTENSION deviceExtension = (POHCD_DEVICE_EXTENSION)
                                                 USBD_GetHCDExtension(pHub->m_HostController);
        HCD_DisableRootHubPort(
            USBD_GetHCDExtension(pHub->m_HostController),
            PortNumber
            );
    } else
    {
        URB Urb;
        USB_BUILD_CONTROL_TRANSFER(
		    &Urb.ControlTransfer,
		    NULL,
		    NULL,
		    0,
		    0,
		    NULL, //Make the call synchronously
		    NULL,
		    FALSE,
		    USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_OTHER,
		    USB_REQUEST_CLEAR_FEATURE,
		    USBHUB_FEATURE_PORT_ENABLE,
		    PortNumber,
		    0
		    );
        pHub->SubmitRequest(&Urb);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbhub\hub.h ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    hub.h

Abstract:

    Structures and functions used by the usbhub driver
	
Environment:

	Designed for XBOX.

Notes:

Revision History:

    02-22-00 created by Mitchell Dernis (mitchd)

--*/

#ifndef __HUB_H__
#define __HUB_H__


#define USB_HUB_DESCRIPTOR_TYPE		0x29

//
//	USB HUB SPECIFIC FEATURES
//
#define	USBHUB_FEATURE_C_HUB_LOCAL_POWER		0
#define	USBHUB_FEATURE_C_HUB_OVER_CURRENT		1
#define	USBHUB_FEATURE_PORT_CONNECTION			0
#define	USBHUB_FEATURE_PORT_ENABLE				1
#define	USBHUB_FEATURE_PORT_SUSPEND				2
#define	USBHUB_FEATURE_PORT_OVER_CURRENT		3
#define	USBHUB_FEATURE_PORT_RESET				4
#define	USBHUB_FEATURE_PORT_POWER				8
#define	USBHUB_FEATURE_C_PORT_CONNECTION		16
#define	USBHUB_FEATURE_C_PORT_ENABLE			17
#define	USBHUB_FEATURE_C_PORT_SUSPEND			18
#define	USBHUB_FEATURE_C_PORT_OVER_CURRENT		19
#define	USBHUB_FEATURE_C_PORT_RESET				20

//
//	Bit mask for checking the hub status
//
#define USBHUB_HUB_STATUS_LOCAL_POWER		0x0001
#define USBHUB_HUB_STATUS_OVER_CURRENT		0x0002

//
//	Bit mask for checking the hub status change
//
#define USBHUB_C_HUB_STATUS_LOCAL_POWER		0x0001
#define USBHUB_C_HUB_STATUS_OVER_CURRENT	0x0002

//
//	Bit mask for checking the port status
//	
#define USBHUB_PORT_STATUS_CONNECTION		0x0001
#define USBHUB_PORT_STATUS_ENABLE			0x0002
#define USBHUB_PORT_STATUS_SUSPEND			0x0004
#define USBHUB_PORT_STATUS_OVER_CURRENT		0x0008
#define USBHUB_PORT_STATUS_RESET			0x0010
#define USBHUB_PORT_STATUS_POWER			0x0100
#define USBHUB_PORT_STATUS_LOW_SPEED		0x0200


//
//	Bit mask for checking the port status change
//	
#define USBHUB_C_PORT_STATUS_CONNECTION		0x0001
#define USBHUB_C_PORT_STATUS_ENABLE			0x0002
#define USBHUB_C_PORT_STATUS_SUSPEND		0x0004
#define USBHUB_C_PORT_STATUS_OVER_CURRENT	0x0008
#define USBHUB_C_PORT_STATUS_RESET			0x0010

//
//	Device Node for a hub
//
typedef struct _USBHUB_DEVICE_NODE
{
	//
	//	First byte is various status bits.
	//
	UCHAR			InUse:1;
	UCHAR			RemovePending:1;
	UCHAR			PoweringPorts:1;
    UCHAR			NotResponding:1;
	UCHAR			Padding:4;
	UCHAR			InterruptEndpointAddress;
	UCHAR			PortCount;
	UCHAR			PortProcessIndex;		//Port currently being processed.
	UCHAR			PortStatusChangeBitmap; //Bitmap of ports whose status has changed
	UCHAR			PortConnectedBitmap;	//Bitmap of ports that are connected
    UCHAR           ErrorCount;
	UCHAR			InterruptEndpointMaxPacket;
	
	URB				Urb;
	
	//
	//	Memory buffer for the URB.  We use a union to format it.
	//
	union
	{
		UCHAR			RequestBuffer[4];
		struct {
			USHORT		Status;
			USHORT		StatusChange;
		}				PortStatus;
	};
	PVOID			InterruptEndpointHandle;
} USBHUB_DEVICE_NODE, *PUSBHUB_DEVICE_NODE;

#define USBHUB_MAXIMUM_HUB_COUNT 6 //Need an extra slop node, in case a reset is done

typedef	struct _USBHUB_INFO
{
	USHORT				NodeCount;
	USHORT				NodesInUse;
	USBHUB_DEVICE_NODE	Nodes[USBHUB_MAXIMUM_HUB_COUNT];
	PUCHAR				EndpointMemory;
} USBHUB_INFO, *PUSBHUB_INFO;

typedef struct _USBHUB_ENUM_BLOCK
{
	UCHAR						EnumBuffer[48];
	//
	//	Resets are not done by the enumeration routine in particular, but USBD guarantees
	//	the serialization of resets across all host controllers.  We are therefore safe
	//	sticking these variables in a global context.
	URB							ResetUrb;
	PVOID						ResetContext;
    KTIMER                      WatchdogTimer;
    KDPC                        WatchdogTimerDpc;
    ULONG                       WatchdogReason;
} USBHUB_ENUM_BLOCK, *PUSBHUB_ENUM_BLOCK;

#define USBHUB_WATCHDOG_REASON_ENUM         0
#define USBHUB_WATCHDOG_REASON_RESET_PORT   1
#define USBHUB_WATCHDOG_REASON_DISABLE_PORT 2

extern USBHUB_INFO			GLOBAL_HubInfo;
extern USBHUB_ENUM_BLOCK	GLOBAL_HubEnum;


//----------------------------------------------------------
//	Entry points from external modules
//----------------------------------------------------------
VOID
USBHUB_AddHub(
	IN IUsbDevice *HubDevice,
	IN PVOID Context
	);

VOID
USBHUB_RemoveHub(
	IN IUsbDevice *HubDevice
	);

VOID
USBHUB_DisableResetPort(
	IN IUsbDevice *HubDevice,
	IN UCHAR	PortNumber,
	IN PVOID	Context,
    IN BOOLEAN  Disable
	);



//----------------------------------------------------------
//	Procedures implemented in hub.c
//----------------------------------------------------------

VOID
USBHUB_EnumHubStage1(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_EnumHubStage2(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_EnumHubComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_PoweringPorts(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_ChangeNotifyComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_ClearInterruptStallComplete(
    PURB	Urb,
	IUsbDevice	*HubDevice
	);

VOID
USBHUB_PortStatusChange1(
	IN IUsbDevice *HubDevice
	);

VOID
USBHUB_PortStatusChange2(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_PortProcessChange(
	IN IUsbDevice *HubDevice
	);

VOID
USBHUB_HubStatusChange(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_ClearHubFeatureComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_ClearPortFeatureComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_RemoveHubStage1(
	IN IUsbDevice *HubDevice
	);

VOID
USBHUB_RemoveHubStage2(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_RemoveHubComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_ResetComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_DisableComplete(
	PURB	Urb,
	IUsbDevice *HubDevice
	);

VOID
USBHUB_RelatchPortSpeed(
    IUsbDevice *HubDevice
    );

VOID
USBHUB_RelatchPortSpeedComplete(
    IN PURB    Urb,
    IUsbDevice *HubDevice
    );

#endif	//__HUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbsamp\usbsamp.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    usbsamp.cpp

Abstract:

    This module implements a sample USB class driver.

--*/

#define _NTOS_
#include <ntddk.h>
#include <xtl.h>
#include <usb.h>
#include "hiddefs.h"
#include "usbsamp.h"

//
// Declare the structure used by the USB enumeration code to internally track
// devices of this type.
//

DECLARE_XPP_TYPE(XDEVICE_TYPE_SAMPLE)

//
// Create the table of device types that this class driver supports.
//

USB_DEVICE_TYPE_TABLE_BEGIN(Sample)
    USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_SAMPLE)
USB_DEVICE_TYPE_TABLE_END()

//
// Create the structure that binds the USB class, subclass, and protocol codes
// to this class driver.
//

USB_CLASS_DRIVER_DECLARATION(Sample, USB_DEVICE_CLASS_HUMAN_INTERFACE, 0xFF, 0xFF)

//
// Register the class driver with the USB core driver by placing a pointer to
// the above structure in the .XPP$Class section.
//

#pragma data_seg(".XPP$ClassSample")
USB_CLASS_DECLARATION_POINTER(Sample)
#pragma data_seg(".XPP$Data")

//
// During device enumeration, an URB may be required.  Because device
// enumeration is serialized, only one URB is required.  Allocate this as a
// global.
//

URB SampleEnumerationUrb;

//
// Stores all of the per-port instance data related to a device.  Allocate the
// maximum number of devices as a global.
//

typedef struct _SAMPLE_DEVICE_STATE {
    IUsbDevice *Device;
    BOOLEAN DeviceAttached : 1;
    BOOLEAN DeviceReady : 1;
    BOOLEAN DeviceOpened : 1;
    BOOLEAN DeviceRemoved : 1;
    BOOLEAN DefaultEndpointOpened : 1;
    BOOLEAN ClosingEndpoints : 1;
    BOOLEAN RemoveDevicePending : 1;
    BOOLEAN CloseDevicePending : 1;
    UCHAR InterruptEndpointAddress;
    UCHAR InterfaceNumber;
    PVOID InterruptEndpointHandle;
    URB CloseEndpointUrb;
    KEVENT CloseEndpointEvent;
    CRITICAL_SECTION CriticalSection;
} SAMPLE_DEVICE_STATE, *PSAMPLE_DEVICE_STATE;

SAMPLE_DEVICE_STATE SampleDeviceState[XGetPortCount()];

//
// Local support.
//

VOID
SampleSetProtocolComplete(
    PURB Urb,
    PVOID Context
    );

VOID
SampleCloseEndpointsAsync(
    PSAMPLE_DEVICE_STATE DeviceState
    );

VOID
SampleInit(
    IUsbInit *UsbInit
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver to initialize the class
    driver.  This routine can allocate resources for the expected number of
    devices (either statically known or dynamically determined from the values
    from XInitDevices) and register resource requirements with the core USB
    driver.

Arguments:

    UsbInit - Specifies a virtual table of functions that can be used to control
        the behavior of this class driver.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PSAMPLE_DEVICE_STATE DeviceState;

    DbgPrint("SAMPLE: SampleInit called.\n");

    for (dwPort = 0; dwPort < XGetPortCount(); dwPort++) {

        DeviceState = &SampleDeviceState[dwPort];

        //
        // Initialize the event used to synchronize the closing of endpoints.
        //

        KeInitializeEvent(&DeviceState->CloseEndpointEvent,
            NotificationEvent, FALSE);

        //
        // Initialize the critical section used to synchronize passive level API
        // code.
        //

        InitializeCriticalSection(&DeviceState->CriticalSection);
    }

}

VOID
SampleAddDevice(
    IUsbDevice *Device
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver during enumeration time when
    a device has been added that is supported by this class driver.

Arguments:

    Device - Specifies a virtual table of functions that can be used to control
        the behavior of the device.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PSAMPLE_DEVICE_STATE DeviceState;
    const USB_DEVICE_DESCRIPTOR8 *DeviceDescriptor;
    const USB_CONFIGURATION_DESCRIPTOR *ConfigurationDescriptor;
    const USB_INTERFACE_DESCRIPTOR *InterfaceDescriptor;
    const USB_ENDPOINT_DESCRIPTOR *EndpointDescriptor;

    DbgPrint("SAMPLE: SampleAddDevice called.\n");

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Verify that the device is attached to a legal port number.  Note that if
    // the device were plugged into the bottom slot of a hub, then the port
    // number will exceed XGetPortCount() and we'll ignore the device.
    //

    dwPort = Device->GetPort();

    if (dwPort >= XGetPortCount()) {
        DbgPrint("SAMPLE: Illegal port number.\n");
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    DeviceState = &SampleDeviceState[dwPort];

    //
    // Verify that we haven't already seen a device attached.
    //

    if (DeviceState->DeviceAttached) {
        DbgPrint("SAMPLE: Device already attached.\n");
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    ASSERT(!DeviceState->DeviceReady);

    //
    // Dump the contents of the device descriptor.
    //

    DeviceDescriptor = Device->GetDeviceDescriptor();

    DbgPrint("Device Descriptor\n");
    DbgPrint("\tbLength=%02x\n", DeviceDescriptor->bLength);
    DbgPrint("\tbDescriptorType=%02x\n", DeviceDescriptor->bDescriptorType);
    DbgPrint("\tbcdUSB=%04x\n", DeviceDescriptor->bcdUSB);
    DbgPrint("\tbDeviceClass=%02x\n", DeviceDescriptor->bDeviceClass);
    DbgPrint("\tbDeviceSubClass=%02x\n", DeviceDescriptor->bDeviceSubClass);
    DbgPrint("\tbDeviceProtocol=%02x\n", DeviceDescriptor->bDeviceProtocol);
    DbgPrint("\tbMaxPacketSize0=%02x\n", DeviceDescriptor->bMaxPacketSize0);
    DbgPrint("\n");

    //
    // Dump the contents of the configuration descriptor.
    //

    ConfigurationDescriptor = Device->GetConfigurationDescriptor();

    DbgPrint("Configuration Descriptor\n");
    DbgPrint("\tbLength=%02x\n", ConfigurationDescriptor->bLength);
    DbgPrint("\tbDescriptorType=%02x\n", ConfigurationDescriptor->bDescriptorType);
    DbgPrint("\twTotalLength=%04x\n", ConfigurationDescriptor->wTotalLength);
    DbgPrint("\tbNumInterfaces=%02x\n", ConfigurationDescriptor->bNumInterfaces);
    DbgPrint("\tbConfigurationValue=%02x\n", ConfigurationDescriptor->bConfigurationValue);
    DbgPrint("\tiConfiguration=%02x\n", ConfigurationDescriptor->iConfiguration);
    DbgPrint("\tbmAttributes=%02x\n", ConfigurationDescriptor->bmAttributes);
    DbgPrint("\tMaxPower=%02x\n", ConfigurationDescriptor->MaxPower);
    DbgPrint("\n");

    //
    // Dump the contents of the interface descriptor.
    //

    InterfaceDescriptor = Device->GetInterfaceDescriptor();

    DbgPrint("Interface Descriptor\n");
    DbgPrint("\tbLength=%02x\n", InterfaceDescriptor->bLength);
    DbgPrint("\tbDescriptorType=%02x\n", InterfaceDescriptor->bDescriptorType);
    DbgPrint("\tbInterfaceNumber=%02x\n", InterfaceDescriptor->bInterfaceNumber);
    DbgPrint("\tbAlternateSetting=%02x\n", InterfaceDescriptor->bAlternateSetting);
    DbgPrint("\tbNumEndpoints=%02x\n", InterfaceDescriptor->bNumEndpoints);
    DbgPrint("\tbInterfaceClass=%02x\n", InterfaceDescriptor->bInterfaceClass);
    DbgPrint("\tbInterfaceSubClass=%02x\n", InterfaceDescriptor->bInterfaceSubClass);
    DbgPrint("\tbInterfaceProtocol=%02x\n", InterfaceDescriptor->bInterfaceProtocol);
    DbgPrint("\tiInterface=%02x\n", InterfaceDescriptor->iInterface);
    DbgPrint("\n");

    //
    // Dump the contents of the endpoint descriptor.
    //

    EndpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_INTERRUPT,
        TRUE, 0);

    if (EndpointDescriptor == NULL) {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    DbgPrint("Endpoint Descriptor\n");
    DbgPrint("\tbLength=%02x\n", EndpointDescriptor->bLength);
    DbgPrint("\tbDescriptorType=%02x\n", EndpointDescriptor->bDescriptorType);
    DbgPrint("\tbEndpointAddress=%02x\n", EndpointDescriptor->bEndpointAddress);
    DbgPrint("\tbmAttributes=%02x\n", EndpointDescriptor->bmAttributes);
    DbgPrint("\twMaxPacketSize=%02x\n", EndpointDescriptor->wMaxPacketSize);
    DbgPrint("\tbInterval=%02x\n", EndpointDescriptor->bInterval);
    DbgPrint("\n");

    //
    // Verify that the device supports the mouse boot protocol.
    //

    if ((InterfaceDescriptor->bInterfaceSubClass != HID_SUBCLASS_BOOT) ||
        (InterfaceDescriptor->bInterfaceProtocol != HID_PROTOCOL_MOUSE)) {
        DbgPrint("SAMPLE: Device is not a mouse.\n");
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    // Remember that a device is physically attached.
    //

    DeviceState->DeviceAttached = TRUE;

    //
    // Store information about the device in our globals.
    //

    DeviceState->Device = Device;
    DeviceState->InterfaceNumber = Device->GetInterfaceNumber();
    DeviceState->InterruptEndpointAddress =
        EndpointDescriptor->bEndpointAddress;

    //
    // The USB enumeration code has the default endpoint open for a class driver
    // to use until the AddComplete routine is invoked.  After AddComplete has
    // been called, then the class driver must open the default endpoint itself.
    //
    // For a mouse device, we need to switch to the boot protocol, so do that
    // now while the default endpoint is open.
    //

    USB_BUILD_CONTROL_TRANSFER(&SampleEnumerationUrb.ControlTransfer,
                               NULL,
                               NULL,
                               0,
                               0,
                               SampleSetProtocolComplete,
                               DeviceState,
                               TRUE,
                               USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
                               HID_REQUEST_SET_PROTOCOL,
                               HID_SET_PROTOCOL_BOOT,
                               DeviceState->InterfaceNumber,
                               0);

    Device->SubmitRequest(&SampleEnumerationUrb);

    //
    // The USB enumeration code is blocked until we call AddComplete on our
    // device, but other processing will continue while the above request is in
    // progress.
    //
}

VOID
SampleSetProtocolComplete(
    PURB Urb,
    PVOID Context
    )
/*++

Routine Description:

    This routine is invoked after the URB has completed to set the protocol of
    the HID device.

Arguments:

    Urb - Specifies the pointer to the URB that has completed.

    Context - Specifies the context supplied to URB_BUILD_CONTROL_TRANSFER.

Return Value:

    None.

--*/
{
    PSAMPLE_DEVICE_STATE DeviceState;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DeviceState = (PSAMPLE_DEVICE_STATE)Context;

    //
    // Check if an error occurred while setting the protocol.  If so, fail to
    // attach the device and forward the error to the USB enumeration code.
    //

    if (USBD_ERROR(Urb->Header.Status)) {
        DeviceState->DeviceAttached = FALSE;
        DeviceState->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    // Remember that the device is now ready to be used.
    //

    DeviceState->DeviceReady = TRUE;

    //
    // Notify the USB enumeration code that we have successfully added the
    // device.
    //
    // Note that after this call has completed, the default endpoint is no
    // longer open and we must manually open it if required.
    //

    DeviceState->Device->AddComplete(USBD_STATUS_SUCCESS);
}

VOID
SampleRemoveDevice(
    IUsbDevice *Device
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver during enumeration time when
    a device has been removed that had successfully been added before.

Arguments:

    Device - Specifies a virtual table of functions that can be used to control
        the behavior of the device.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PSAMPLE_DEVICE_STATE DeviceState;

    DbgPrint("SAMPLE: SampleRemoveDevice called.\n");

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    dwPort = Device->GetPort();

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &SampleDeviceState[dwPort];

    ASSERT(DeviceState->DeviceAttached);
    ASSERT(DeviceState->Device == Device);

    //
    // Remember that we're in the middle of a device removal.
    //

    DeviceState->RemoveDevicePending = TRUE;

    //
    // Close all of the open endpoints.  When this operation completes, the
    // remove device process will be completed.
    //

    SampleCloseEndpointsAsync(DeviceState);
}

USBD_STATUS
SampleOpenEndpoints(
    PSAMPLE_DEVICE_STATE DeviceState
    )
/*++

Routine Description:

    This routine opens all of the endpoints for the device.

Arguments:

    DeviceState - Specifies the device whose endpoints are to be opened.

Return Value:

    USBD status code.

--*/
{
    URB OpenUrb;
    USBD_STATUS UsbdStatus;

    //
    // Open the default endpoint.
    //

    USB_BUILD_OPEN_DEFAULT_ENDPOINT(&OpenUrb.OpenEndpoint);

    UsbdStatus = DeviceState->Device->SubmitRequest(&OpenUrb);

    if (USBD_SUCCESS(UsbdStatus)) {

        DeviceState->DefaultEndpointOpened = TRUE;

        //
        // Open the "interrupt in" endpoint.
        //

        USB_BUILD_OPEN_ENDPOINT(&OpenUrb.OpenEndpoint,
                                DeviceState->InterruptEndpointAddress,
                                USB_ENDPOINT_TYPE_INTERRUPT,
                                sizeof(HID_BOOT_MOUSE_REPORT),
                                10);

        UsbdStatus = DeviceState->Device->SubmitRequest(&OpenUrb);

        if (USBD_SUCCESS(UsbdStatus)) {
            DeviceState->InterruptEndpointHandle =
                OpenUrb.OpenEndpoint.EndpointHandle;
        }
    }

    return UsbdStatus;
}

VOID
SampleCloseEndpointsComplete(
    PURB Urb,
    PVOID Context
    )
/*++

Routine Description:

    This routine is invoked after the URB has completed to close an endpoint.

Arguments:

    Urb - Specifies the pointer to the URB that has completed.

    Context - Specifies the context supplied to URB_BUILD_CONTROL_TRANSFER.

Return Value:

    None.

--*/
{
    PSAMPLE_DEVICE_STATE DeviceState;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DeviceState = (PSAMPLE_DEVICE_STATE)Context;

    if (DeviceState->DefaultEndpointOpened) {

        //
        // Close the default endpoint.
        //

        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&Urb->CloseEndpoint,
                                         SampleCloseEndpointsComplete,
                                         DeviceState);

        DeviceState->DefaultEndpointOpened = FALSE;

    } else if (DeviceState->InterruptEndpointHandle != NULL) {

        //
        // Close the "interrupt in" endpoint.
        //

        USB_BUILD_CLOSE_ENDPOINT(&Urb->CloseEndpoint,
                                 DeviceState->InterruptEndpointHandle,
                                 SampleCloseEndpointsComplete,
                                 DeviceState);

        DeviceState->InterruptEndpointHandle = NULL;

    } else {

        //
        // All endpoints are closed.  Signal the close endpoint event in case a
        // thread is waiting for the close endpoint to complete.
        //

        KeSetEvent(&DeviceState->CloseEndpointEvent, IO_NO_INCREMENT,
            FALSE);
        DeviceState->ClosingEndpoints = FALSE;

        //
        // If the device has been removed, then complete the device removal
        // process by notifying the USB enumeration code.
        //

        if (DeviceState->RemoveDevicePending) {

            DeviceState->RemoveDevicePending = FALSE;
            DeviceState->DeviceAttached = FALSE;
            DeviceState->DeviceReady = FALSE;
            DeviceState->DeviceRemoved = TRUE;

            DeviceState->Device->RemoveComplete();
        }

        return;
    }

    //
    // There's at least one endpoint still open.  If an endpoint is open, then
    // we must still think the device is logically attached and connected to
    // this device extension.
    //

    ASSERT(DeviceState->DeviceAttached);

    //
    // Submit the close request and wait for the USB driver to close the
    // endpoint.
    //

    DeviceState->Device->SubmitRequest(Urb);
}

VOID
SampleCloseEndpointsAsync(
    PSAMPLE_DEVICE_STATE DeviceState
    )
/*++

Routine Description:

    This routine asynchronously closes all of the open endpoints.

Arguments:

    DeviceState - Specifies the device whose endpoints are to be closed.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If we haven't already started closing endpoints, then kick off the
    // process.
    //

    if (!DeviceState->ClosingEndpoints) {

        //
        // Clear the close endpoint event used for synchronous close operations.
        //

        KeClearEvent(&DeviceState->CloseEndpointEvent);
        DeviceState->ClosingEndpoints = TRUE;

        //
        // Enter the close endpoints state machine.
        //

        SampleCloseEndpointsComplete(&DeviceState->CloseEndpointUrb,
            DeviceState);
    }
}

VOID
SampleCloseEndpoints(
    PSAMPLE_DEVICE_STATE DeviceState
    )
/*++

Routine Description:

    This routine synchronously closes all of the open endpoints.

Arguments:

    DeviceState - Specifies the device whose endpoints are to be opened.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Asynchronously close all of the open endpoints.  When all of the
    // endpoints are closed, the close endpoint event is signaled.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    SampleCloseEndpointsAsync(DeviceState);

    KeLowerIrql(OldIrql);

    //
    // Block until the endpoints have been closed.
    //

    KeWaitForSingleObject(&DeviceState->CloseEndpointEvent, Executive,
        KernelMode, FALSE, NULL);
}

DWORD
SampleOpenDevice(
    DWORD dwPort
    )
/*++

Routine Description:

    This routine is invoked by application code to open a device that has been
    successfully enumerated (in particular, XGetDevices reports that the device
    is present).

Arguments:

    dwPort - Specifies the port number of the device to be opened.

Return Value:

    Status of operation.

--*/
{
    PSAMPLE_DEVICE_STATE DeviceState;
    KIRQL OldIrql;
    USBD_STATUS UsbdStatus;

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &SampleDeviceState[dwPort];

    //
    // Synchronize passive level access to this device's state.
    //

    EnterCriticalSection(&DeviceState->CriticalSection);

    //
    // If the device has already been opened, then bail out now.

    if (DeviceState->DeviceOpened) {
        LeaveCriticalSection(&DeviceState->CriticalSection);
        return ERROR_SHARING_VIOLATION;
    }

    //
    // Synchronize access to our globals with the AddDevice and RemoveDevice
    // entrypoints by raising the IRQL to DPC level.  While running at this
    // raised IRQL, thread preemption is disabled.  Only interupt service
    // routines are allowed to run.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // Reset the flag that indicates that the device has been removed while the
    // device was open or was in the process of opening.
    //

    DeviceState->DeviceRemoved = FALSE;

    //
    // If the device is not ready for use, then bail out now.
    //

    if (!DeviceState->DeviceReady) {
        KeLowerIrql(OldIrql);
        LeaveCriticalSection(&DeviceState->CriticalSection);
        return ERROR_DEVICE_NOT_CONNECTED;
    }

    //
    // Open the device's endpoints.  Note that if this routine fails, some of
    // the endpoints may have been opened, so we need to close these endpoints.
    //

    UsbdStatus = SampleOpenEndpoints(DeviceState);

    if (!USBD_SUCCESS(UsbdStatus)) {
        KeLowerIrql(OldIrql);
        SampleCloseEndpoints(DeviceState);
        LeaveCriticalSection(&DeviceState->CriticalSection);
        return IUsbDevice::Win32FromUsbdStatus(UsbdStatus);
    }

    //
    // Remember that the device is now open.
    //

    DeviceState->DeviceOpened = TRUE;

    KeLowerIrql(OldIrql);

    LeaveCriticalSection(&DeviceState->CriticalSection);

    return ERROR_SUCCESS;
}

VOID
SampleSignalEventComplete(
    PURB Urb,
    PVOID Context
    )
/*++

Routine Description:

    This routine is invoked after a generic URB has completed.

Arguments:

    Urb - Specifies the pointer to the URB that has completed.

    Context - Specifies the context supplied to the URB builder macro.

Return Value:

    None.

--*/
{
    //
    // Wake up the thread waiting for the URB to complete.
    //

    KeSetEvent((PKEVENT)Context, EVENT_INCREMENT, FALSE);
}

DWORD
SampleReadButtons(
    DWORD dwPort,
    LPBYTE lpbButtons
    )
/*++

Routine Description:

    This routine is invoked by application code to read the button state.

Arguments:

    dwPort - Specifies the port number of the device to be read from.

    lpbButtons - Specifies the location to receive the button state.

Return Value:

    Status of operation.

--*/
{
    PSAMPLE_DEVICE_STATE DeviceState;
    KIRQL OldIrql;
    KEVENT Event;
    URB Urb;
    HID_BOOT_MOUSE_REPORT BootMouseReport;

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &SampleDeviceState[dwPort];

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // If the device hasn't been opened, if the device is in the process of
    // being removed, or if the device has already been removed, then fail the
    // request.
    //

    if (!DeviceState->DeviceOpened || DeviceState->RemoveDevicePending ||
        DeviceState->DeviceRemoved) {
        KeLowerIrql(OldIrql);
        return ERROR_DEVICE_NOT_CONNECTED;
    }

    //
    // Initialize the event used to wait for the below URB to complete.
    //

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Build an URB to do a control transfer from the default endpoint.  Read
    // the input report from the mouse interface.
    //

    USB_BUILD_CONTROL_TRANSFER(&Urb.ControlTransfer,
                               NULL,
                               &BootMouseReport,
                               sizeof(HID_BOOT_MOUSE_REPORT),
                               USB_TRANSFER_DIRECTION_IN,
                               SampleSignalEventComplete,
                               &Event,
                               TRUE,
                               USB_DEVICE_TO_HOST | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
                               HID_REQUEST_GET_REPORT,
                               MAKEWORD(0, 1),
                               DeviceState->InterfaceNumber,
                               sizeof(HID_BOOT_MOUSE_REPORT));

    DeviceState->Device->SubmitRequest(&Urb);

    //
    // Wait for the URB to complete.  This must be done at lowered IRQL.
    //

    KeLowerIrql(OldIrql);
    KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

    //
    // Check the URB for any errors.
    //

    if (USBD_ERROR(Urb.Header.Status)) {
        return IUsbDevice::Win32FromUsbdStatus(Urb.Header.Status);
    }

    //
    // The input report was successfullly read from the mouse, so return the
    // button state to the caller.
    //

    *lpbButtons = BootMouseReport.Buttons;

    return ERROR_SUCCESS;
}

VOID
SampleCloseDevice(
    DWORD dwPort
    )
/*++

Routine Description:

    This routine is invoked by application code to close a device that had been
    successfully opened.

Arguments:

    dwPort - Specifies the port number of the device to be closed.

Return Value:

    None.

--*/
{
    PSAMPLE_DEVICE_STATE DeviceState;
    KIRQL OldIrql;

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &SampleDeviceState[dwPort];

    //
    // Synchronize passive level access to this device's state.
    //

    EnterCriticalSection(&DeviceState->CriticalSection);

    //
    // If the device hasn't been opened, then bail out now.
    //

    if (!DeviceState->DeviceOpened) {
        LeaveCriticalSection(&DeviceState->CriticalSection);
        return;
    }

    //
    // Close the device's endpoints.
    //

    SampleCloseEndpoints(DeviceState);

    //
    // Synchronize access to our globals with the AddDevice and RemoveDevice
    // entrypoints by raising the IRQL to DPC level.  While running at this
    // raised IRQL, thread preemption is disabled.  Only interupt service
    // routines are allowed to run.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // Remember that the device is now closed.
    //

    DeviceState->DeviceOpened = FALSE;

    KeLowerIrql(OldIrql);

    LeaveCriticalSection(&DeviceState->CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbsamp\usbsamp.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    usbsamp.h

Abstract:

    This module contains the public interface for a sample USB class driver.

--*/

#ifndef _USBSAMP_
#define _USBSAMP_

#ifdef __cplusplus
extern "C" {
#endif

extern XPP_DEVICE_TYPE XDEVICE_TYPE_SAMPLE_TABLE;
#define XDEVICE_TYPE_SAMPLE (&XDEVICE_TYPE_SAMPLE_TABLE)

DWORD
WINAPI
SampleOpenDevice(
    DWORD dwPort
    );

DWORD
WINAPI
SampleReadButtons(
    DWORD dwPort,
    LPBYTE lpbButtons
    );

VOID
WINAPI
SampleCloseDevice(
    DWORD dwPort
    );

#ifdef __cplusplus
}
#endif

#endif  // USBSAMP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbtest\usbtest.cpp ===
#include <usbtest.h>


IUsbDevice *
GetParentInterface(
    IUsbDevice *pUsbDevice
    )
/*++
  Routine Description:
    Gets the parent of a USB device.  Returns parent of
    device.  
--*/
{
    IUsbDevice *pParent;
    pParent = &g_DeviceTree.m_Devices[pUsbDevice->m_Parent];
    return pParent;
}

UCHAR 
GetHubPort(
    IUsbDevice *pUsbDevice
    )
/*++
  Routine Description:
    Gets the hub port in the parent.
--*/
{
    return pUsbDevice->m_PortNumber;
}

void ResetDevice(IUsbDevice *Device, UCHAR MaxRetries)
/*++
  Routine Description:
    Resets a device forcing a reenumeration, just like
    DeviceNotResponding, but allows retries to be set.
--*/
{
    IUsbDevice *device;
    
    //
    //  If the device is UDN_TYPE_INTERFACE, then the
    //  real node is the parent
    //
    if(UDN_TYPE_INTERFACE == Device->m_Type)
    {
        device = Device->GetParent();
        ASSERT(device);
    } else
    {
        device = Device;
    }

    //
    //  If it has a parent, it is not pending
    //  remove, so we should reenumerate it.
    //
    IUsbDevice *parent = device->GetParent();
    if(parent)
    {
        
        UCHAR   hubPort = device->GetHubPort();
        
        //
        //  Report the device as disconnected
        //
        parent->DeviceDisconnected(hubPort);

        //
        //  Report the device as connected.
        //
        parent->DeviceConnected(hubPort, MaxRetries);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbsamp\hiddefs.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    hiddefs.h

Abstract:

    This module contains the definitions and structures for interfacing with
    Human Interface Devices (HID).

--*/

#ifndef _HIDDEFS_
#define _HIDDEFS_

#include <pshpack1.h>

//
// HID interface subclass codes.
//

#define HID_SUBCLASS_NONE                           0x00
#define HID_SUBCLASS_BOOT                           0x01

//
// HID interface protocol codes.
//

#define HID_PROTOCOL_NONE                           0x00
#define HID_PROTOCOL_KEYBOARD                       0x01
#define HID_PROTOCOL_MOUSE                          0x02

//
// HID class specific request codes.
//

#define HID_REQUEST_GET_REPORT                      0x01
#define HID_REQUEST_GET_IDLE                        0x02
#define HID_REQUEST_GET_PROTOCOL                    0x03
#define HID_REQUEST_SET_REPORT                      0x09
#define HID_REQUEST_SET_IDLE                        0x0A
#define HID_REQUEST_SET_PROTOCOL                    0x0B

//
// HID_REQUEST_SET_PROTOCOL request codes.
//

#define HID_SET_PROTOCOL_BOOT                       0x00
#define HID_SET_PROTOCOL_REPORT                     0x01

//
// Structure for a report generated by a mouse in boot protocol mode.
//

typedef struct _HID_BOOT_MOUSE_REPORT {
    union {
        struct {
            UCHAR Button1 : 1;
            UCHAR Button2 : 1;
            UCHAR Button3 : 1;
            UCHAR DeviceSpecific1 : 5;
        };
        UCHAR Buttons;
    };
    UCHAR DisplacementX;
    UCHAR DisplacementY;
    UCHAR DeviceSpecific2[5];
} HID_BOOT_MOUSE_REPORT, *PHID_BOOT_MOUSE_REPORT;

#include <poppack.h>

#endif  // HIDDEFS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbtest\usbtest.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    USBTEST.H

Abstract:

    USBTEST.LIB

    Header file for USB Test Utility Methods

    This header declares all the methods exported
    from USBTEST.LIB

Environment:

    kernel mode

Revision History:

    05-04-2001 : mitchd
    

--*/

//*****************************************************************************
// Includes
//*****************************************************************************
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xdbg.h>
#include <usbd.h>


IUsbDevice *GetXidDeviceInterface(PXPP_DEVICE_TYPE XppDeviceType, DWORD dwPort, DWORD dwSlot);
/*
    Walks a XID handle to get the underlying IUsbDevice.
    If the XID device is not connected (stranded handle)
    then it return NULL.
*/

IUsbDevice *GetParentInterface(IUsbDevice *pUsbDevice);
/*
    Gets the parent of a USB device.  Returns parent of
    device.  
*/

UCHAR GetHubPort(IUsbDevice *pUsbDevice);
/*
    Gets the hub port from an IUsbDevice, so that
    IsDeviceAttached can be called.
*/

BOOL IsDeviceAttached(IUsbDevice *pHub, UCHAR uHubPort);
/*
    Returns TRUE if the hub thinks a device is attached to 
    the port.   This is the real port of the hub.
*/

VOID
DisableHubPortSync(
	IN IUsbDevice *pHub,
	IN UCHAR	PortNumber
	);
/*++
  Routine Description:
   Disables a port on hub.  Transparently handles root hub
   versus real hub.  This does not use the hub driver.
   This routine is not safe in an actual hot-plug situation.
   It is good for forcing the reenumeration of devices.

   On like reset device is doesn't suffer from the address
   recycling problem, so you can hit multiple devices
   at once with it.

   Additionally, it tests the ability of class drivers to
   detect and recover from devices that stop responding.
--*/

void ResetDevice(IUsbDevice *Device, UCHAR MaxRetries);
/*++
  Routine Description:
    Resets a device forcing a reenumeration, just like
    DeviceNotResponding, but allows retries to be set.
--*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\usbtest\xidtest.cpp ===
#include <usbtest.h>
#include "xid.h"

PXID_DEVICE_NODE
FASTCALL
XID_fFindNode(
    IN PXID_TYPE_INFORMATION TypeInformation,
    IN ULONG  Port
    );


IUsbDevice *GetXidDeviceInterface(PXPP_DEVICE_TYPE XppDeviceType, DWORD dwPort, DWORD dwSlot)
{
    UCHAR xidType;
    PXID_TYPE_INFORMATION xidTypeInformation;

    xidTypeInformation = GetTypeInformation(XppDeviceType);

    if(xidTypeInformation)
    {
        xidType = XID_DEVTYPE_GAMECONTROLLER;
        PXID_DEVICE_NODE xidNode = XID_fFindNode(xidTypeInformation, (dwSlot != XDEVICE_BOTTOM_SLOT) ? dwPort : dwPort +16);
        if(xidNode)
        {
            return xidNode->Device;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xdcs\xdcs_old.h ===
#ifndef __XDCS_H__
#define __XDCS_H__
/*++

Copyright (c) Microsoft Corporation

Module Name:

    XDCS.H

Abstract:

    Header file exposed to the private clients of the XDCS device.

    Client API:

      XGetDvdPlaybackLibraryInfo

Usage:

    Sometime after calling XInitDevices (you do not need to specify the XDCS device
    in the list of required devcies), call XGetDvdLibraryInfoPointer to get a pointer
    to the global XDCS_DVD_LIBRARY_INFORMATION.  This information is updated asynchronously
    by the driver.  Since DWORD read\writes are atomic, the client may poll dwStatus.
    
    When dwStatus is XDCS_STATUS_ACCEPTED the dwVersion and szName fields can be considered valid.

    Rather than polling, the client may wait on hStatusChangeEvent.  This event is set
    whenever the status changes.  This way other threads will run more efficiently while
    waiting for an accepted or rejected status.  It is an auto reset event.

    szName and dwVersion are only valid when dwStatus is XDCS_STATUS_ACCEPTED.  The file returned
    is the uncompressed version (there will be a compressed version stored somwhere too.)

    dwPercentComplete and dwTimeRemaining can be polled to display a progress bar, while the status
    is XDCS_STATUS_VERIFYING or XDCS_DOWNLOADING.

    The status will return to XDCS_STATUS_NO_DONGLE whenever the device is removed.  The filename
    may or may not change, if and when another device is inserted.  The filename will probably
    be a derivative of the library version.  I expect to probably maintain up to three different
    versions on the harddisk at a time.

    If there is more than one device present, it will always use the first one found, which is kind of
    random.

Library:
    
    You must explictly link XDCS.LIB to use this library.
    
Environment:

    Xbox

Revision History:
    
    02-22-01 : Mitchell Dernis(mitchd) - created

--*/

#define XDCS_STATUS_INIT         0
#define XDCS_STATUS_NO_DONGLE    1
#define XDCS_STATUS_VERIFYING    2
#define XDCS_STATUS_DOWNLOADING  3 // (including the decompress time)
#define XDCS_STATUS_ACCEPTED     4
#define XDCS_STATUS_REJECTED     5

typedef struct _XDCS_DVD_LIBRARY_INFORMATION
{
    DWORD   dwStatus;              //status of the DVD library
    DWORD   dwPercentComplete;     //percent complete if dwStatus is XDCS_STATUS_VERIFYING or XDCS_STATUS_DOWNLOADING
    DWORD   dwTimeRemaining;       //time remaining (ms) for verify or download (guess)
    HANDLE  hStatusChangeEvent;    //handle to event which is signaled whenever dwStatus is updated.
    DWORD   dwCodeLength;          //length of the code stored in ROM   
    WORD    bcdVersion;            //msb = major version, lsb = minor version each byte is bcd. 0x0110 = version 01.10
    CHAR    szName[MAX_PATH];      //filename of code library
} XDCS_DVD_LIBRARY_INFORMATION, *PXDCS_DVD_LIBRARY_INFORMATION;

PXDCS_DVD_LIBRARY_INFORMATION XGetDvdLibraryInfoPointer();


#endif //__XDCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xdcs\xdcspold.h ===
#ifndef __XDCSP_H__
#define __XDCSP_H__
/*++

Copyright (c) Microsoft Corporation

Module Name:

    XDCSP.H

Abstract:

    Private Header file XDCS device driver.
   
Environment:

    Xbox

Revision History:
    
    02-23-01 : Mitchell Dernis(mitchd) - created

--*/

#include <xdcs.h>

//***************************************
// XDCS constants and structures from the
// XDCS specification
//***************************************
#define USB_DEVICE_CLASS_XDCS 0x59

#define XDCS_REQUEST_GET_ROM_FILE_INFO  1
#define XDCS_REQUEST_GET_ROM_FILE_BLOCK 2
#define XDCS_BLOCK_LENGTH               1024 //1k blocks

#include <pshpack1.h>
typedef struct _XDCS_ROM_INFORMATION
{
    USHORT bcdCodeVersion;
    ULONG  dwCodeLength;
} XDCS_ROM_INFORMATION, *PXDCS_ROM_INFORMATION;
#include <poppack.h>

//****************************************
// Internally useful constants
//****************************************
#define XDCS_NUM_BLOCKS_TO_VERIFY 3           //Number of blocks to verify against
                                              //against a dongle
#define XDCS_CONTROL_TD_QUOTA     (3+1024/64) //1k transfer with 64 byte fifo
#define XDCS_MAX_PORTS            4           //The maximum number of ports supported
#define XDCS_FLAG_CONNECTED       0x01        //set if the device is conneceted
#define XDCS_FLAG_IN_USE          0x02        //set if the device is currently being
                                              //accessed by the 
#define XDCS_MAX_TRIES            3           //number of times we try an XDCS before
                                              //reporting it as not responding

#define XDCS_DVD_LIB_NAME         "t:\\testdvdlib.cab"
//****************************************
// Definitions for the buffers
//****************************************
#define XDCS_BUFFER_COUNT   3
#define XDCS_BUFFER_START   0
#define XDCS_BUFFER_FILE    1
#define XDCS_BUFFER_DEVICE  2
#define XDCS_BUFFER_DONE    3
#define DEFAULT_URB XDCS_Globals.Buffers[0].Urb

//****************************************
// Internally useful macros
//****************************************
#define SET_FLAG(variable, flag)  ((variable) |= (flag))
#define CLEAR_FLAG(variable, flag)  ((variable) &= ~(flag))
#define TEST_FLAG(variable, flag)  ((variable)&(flag))
#define TEST_ANY_FLAG(variable, flag)  ((variable)&(flag))
#define TEST_ALL_FLAGS(variable, flag)  ((flag)==((variable)&(flag)))

//****************************************
// Internal data structures
//****************************************

/*++
    XDCS_DEVICE - Represents the state of
    one of the device ports and the device
    plugged into if, any.
--*/
typedef struct _XDCS_DEVICE
{
    UCHAR       bFlags;
    UCHAR       bInterfaceNumber;
    USHORT      Pad;
    IUsbDevice *Device;
} XDCS_DEVICE, *PXDCS_DEVICE;

/*++
    XDCS_DOWNLOAD_BUFFER - During download of the code
    this structure is ping-ponged between reading the code
    from the device and writing it to file.

    There are XDCS_BUFFER_COUNT of these in the globals structure
    so that multiple requests can be outstanding at a time.

    Members of some of the instance of this structure are borrowed
    in a few places, just to be careful about using memory.
--*/
typedef struct _XDCS_DOWNLOAD_BUFFER
{
    DWORD  dwStage;
    union
    {
        URB        Urb;
        OVERLAPPED Overlapped;
    };
    CHAR  buffer[XDCS_BLOCK_LENGTH]; //For download
    
} XDCS_DOWNLOAD_BUFFER, *PXDCS_DOWNLOAD_BUFFER;

/*++
    XDCS_GLOBALS - this structure binds all the globals into
    a single structure.
--*/
typedef struct _XDCS_GLOBALS
{
    //LibrayInfo is the portion that the client can read at will
    XDCS_DVD_LIBRARY_INFORMATION LibraryInfo;

    //Additional information about the library, which is useful to 
    //cache, but the client doesn't need to see it
    DWORD                        dwLastBlockLength;
    DWORD                        dwBlockCount;

    //Keep track of devices, and which one (if any has been used
    //to verify the library)
    PXDCS_DEVICE                 CurrentDevice;
    XDCS_DEVICE                  Devices[XDCS_MAX_PORTS];

    //Event to waken worker thread
    KEVENT                       ThreadEvent;

    //Utility memory for doing the download
    HANDLE                       BufferEvents[XDCS_BUFFER_COUNT];
    XDCS_DOWNLOAD_BUFFER         Buffers[XDCS_BUFFER_COUNT];
} XDCS_GLOBALS, *PXDCS_GLOBALS;

#endif //__XDCSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xid\typeinfo.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    input.c

Abstract:
    
    Tables with information concerning the currently supported
    set of XID devices.
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    08-01-00 created by Mitchell Dernis (mitchd)

--*/
//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIH'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("INPUT");


//
//  Pull in public usb headers
//
#include <usb.h>

//
//  Pull in xid headers
//
#include "xid.h"


//----------------------------------------------
//  Game Controller Reports
//----------------------------------------------
#define XID_DEFAULT_MAX_GAMEPAD        4
XINPUT_GAMEPAD       GamepadDefaults ={0, //All the digital buttons (including DPAD) up.
                                       0,0,0,0,0,0,0,0,   //All the analog buttons up
                                       0,0,       //The Left Thumbstick centered
                                       0,0        //The Right Thumbstick centered
                                       };
XID_REPORT_TYPE_INFO GameInputReportInfoList[1] = {sizeof(XINPUT_GAMEPAD),(PVOID)&GamepadDefaults};
XINPUT_RUMBLE        RumbleDefaults = {0};  //The motors are off by default
XID_REPORT_TYPE_INFO GameOutputReportInfoList[1] = {sizeof(XINPUT_RUMBLE),(PVOID)&RumbleDefaults};
XINPUT_POLLING_PARAMETERS GameDefaultPolling = {TRUE,FALSE,0,8,0,0}; //AutoPoll On, control-OUT,
                                                                     //8 ms Input Poll Interval,
                                                                     

//----------------------------------------------
//  Keyboard Reports
//----------------------------------------------
#define XID_DEFAULT_MAX_KEYBOARD          1
XINPUT_KEYBOARD      KeyboardDefaults ={0, //All modified keys up
                                       0, //Reserved byte is zero
                                       0,0,0,0,0,0 //No keys down
                                       };
XID_REPORT_TYPE_INFO KeyboardReportInfoList[1] = {sizeof(XINPUT_KEYBOARD),(PVOID)&KeyboardDefaults};
XINPUT_KEYBOARD_LEDS KeyboardLEDDefaults = {0};  //All light off by default
XID_REPORT_TYPE_INFO KeyboardLEDReportInfoList[1] = {sizeof(XINPUT_KEYBOARD_LEDS),(PVOID)&KeyboardLEDDefaults};
XINPUT_POLLING_PARAMETERS KeyboardDefaultPolling = {TRUE,FALSE,0,16,0,0}; //AutoPoll On, SET_REPORT for out,
                                                                          //16 ms Input Poll Interval,

//----------------------------------------------
//  IR Remote Reports
//----------------------------------------------
#define XID_DEFAULT_MAX_IRREMOTE          1
XINPUT_IR_REMOTE     IrRemoteDefaults = {0,0};
XID_REPORT_TYPE_INFO IrRemoteReportInfoList[1] = {sizeof(XINPUT_IR_REMOTE),(PVOID)&IrRemoteDefaults};
XINPUT_POLLING_PARAMETERS IrRemoteDefaultPolling = {TRUE,FALSE,0,16,0,0};  //AutoPoll On, Interrupt-OUT,
                                                                           //16 ms Input Poll Interval

//----------------------------------------------
// Type information list
//----------------------------------------------
XID_TYPE_INFORMATION XID_TypeInformationList[XID_DEVTYPE_COUNT] = {
    // Game Controllers
    {XID_DEFAULT_MAX_GAMEPAD, XID_DEVSUBTYPE_MAX_GAME, XID_INPUT_REPORT_ID_MAX_GAME, XID_OUTPUT_REPORT_ID_MAX_GAME,
    GameInputReportInfoList, GameOutputReportInfoList, &GameDefaultPolling, XID_ProcessGamepadData, 0}
    //Keyboard
    ,{XID_DEFAULT_MAX_KEYBOARD, XID_DEVSUBTYPE_MAX_KEYBOARD, XID_INPUT_REPORT_ID_MAX_KEYBOARD, XID_OUTPUT_REPORT_ID_MAX_KEYBOARD,
    KeyboardReportInfoList, KeyboardLEDReportInfoList, &KeyboardDefaultPolling, XID_ProcessNewKeyboardData,
    XID_BSF_NO_CAPABILITIES|XID_BSF_NO_OUTPUT_HEADER}
    // IR Remote
    ,{XID_DEFAULT_MAX_IRREMOTE, XID_DEVSUBTYPE_MAX_IRREMOTE, XID_INPUT_REPORT_ID_MAX_IRREMOTE, XID_OUTPUT_REPORT_ID_MAX_IRREMOTE,
    IrRemoteReportInfoList, NULL, &IrRemoteDefaultPolling, XID_ProcessIRRemoteData, 0}
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xdcs\xdcs.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    XDCS2.CPP 

Abstract:

    CHANGED THE API COMPLETELY FROM THE ORIGINAL XDCS

    This source file implements the major entry points to the Xbox DVD Code Server
    driver (XDCS).  XDCS is a USB interface based device that contains the DVD playback
    code library.  The code resides in ROM on the device.
   

    The entire implementation is in this file.

    Client API:

      XDCSGetInformation     - Gets information about the code on the device
      XDCSDownloadCode       - Downloads the code synchronously
      XDCSDownloadCodeAsync  - Downloads the code asynchronously

    Entries required by the USB core stack:

      XDCS_Init
      XDCS_AddDevice
      XDCS_RemoveDevice

Environment:

    Xbox USB class driver.

Revision History:
    
    03-30-01 : Mitchell Dernis(mitchd) - created

Implementation and Use Overview:
    
    Totally different API from the original XDCS
   
--*/

//*****************************************************************************
// Headers
//*****************************************************************************

// Xbox Kernel Service Headers
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>

// Xbox System Software Headers
#include <xtl.h>
#include <xboxp.h>

// Useful Debug definitions
#define MODULE_POOL_TAG  'SCDX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("XDCS");

// Xbox USB Class driver header
#include <usb.h>

// XDCS specific header



//*****************************************************************************
// XDCS constants and structures from the XDCS specification
//*****************************************************************************
#define XDCS_REQUEST_GET_ROM_FILE_INFO  1
#define XDCS_REQUEST_GET_ROM_FILE_BLOCK 2
#define XDCS_BLOCK_LENGTH               1024       //1k blocks
#define XDCS_BLOCK_SHIFT                10         //bit shift to divide by 1k
#define XDCS_CONTROL_TD_QUOTA     (2*(3+1024/64))  //2 1k transfers with 64 byte fifo
#define XDCS_MAX_PORTS            4                //The maximum number of ports supported
#define XDCS_REQUEST_TIMEOUT        (-10000*200)   //200 ms timeout
#define XDCS_MAX_TRIES                  4

//*****************************************************************************
//  Declare XDCS types and class.
//*****************************************************************************
DECLARE_XPP_TYPE(XDEVICE_TYPE_DVD_CODE_SERVER)
USB_DEVICE_TYPE_TABLE_BEGIN(XDCS_)
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_DVD_CODE_SERVER)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION(XDCS_, XBOX_DEVICE_CLASS_XDCS, 0, 0)
#pragma data_seg(".XPP$ClassXdcs")
USB_CLASS_DECLARATION_POINTER(XDCS_)
#pragma data_seg(".XPP$Data")

//*****************************************************************************
// Declare Local Structures
//*****************************************************************************

typedef struct _XDCS_DEVICE
{
    UCHAR                       bFlags;
    UCHAR                       bInterfaceNumber;
    USHORT                      usInstance;         //Update whenever a device is removed
    IUsbDevice                  *Device;
    XDCS_DVD_CODE_INFORMATION   CodeInformation;
} XDCS_DEVICE, *PXDCS_DEVICE;

#define XDCS_DEVICE_FLAG_CONNECTED    0x01
#define XDCS_DEVICE_FLAG_INUSE        0x02
#define XDCS_DEVICE_FLAG_ENUMERATING  0x04

#define MAKE_DWORD_INSTANCE(usInstance, dwPort) (((usInstance) << 16)|(dwPort))
#define PORT_FROM_DWORD_INSTANCE(dwInstance) (0x0000FFFF&(dwInstance))
#define USHORT_INSTANCE_FROM_DWORD_INSTANCE(dwInstance) ((USHORT)(((dwInstance)&0xFFFF0000)>>16))

typedef struct _XDCS_GLOBALS
{
    // Single set of resources for data transfer
    ULONG                        ulGlobalFlags;
    ULONG                        Urb1LastLength;  //*** DO NOT REORDER
    URB                          Urb1;            //*** SEE 
    ULONG                        Urb2LastLength;  //*** #define XDCS_URB_LAST_LEN
    URB                          Urb2;            //*** BELOW
    URB                          UrbEnum;
    ULONG                        BytesSubmitted;
    ULONG                        RetryCount;
    USBD_STATUS                  UsbdStatus;                        
    KTIMER                       WatchDogTimer;
    KDPC                         WatchDogTimerDpc;
    PXDCS_ASYNC_DOWNLOAD_REQUEST CurrentDownloadRequest;
    // Track attached devices
    XDCS_DEVICE   Devices[XDCS_MAX_PORTS];
} XDCS_GLOBALS, *PXDCS_GLOBALS;

#define XDCS_GLOBAL_FLAG_TRANSFER_IN_PROGRESS       0x00000001
#define XDCS_GLOBAL_FLAG_URB1_OUTSTANDING           0x00000002
#define XDCS_GLOBAL_FLAG_URB2_OUTSTANDING           0x00000004
#define XDCS_GLOBAL_FLAG_ENUM_URB_OUTSTANDING       0x00000008
#define XDCS_GLOBAL_FLAG_DOWNLOAD_URBS_OUTSTANDING  (XDCS_GLOBAL_FLAG_URB1_OUTSTANDING|\
                                                     XDCS_GLOBAL_FLAG_URB2_OUTSTANDING)
#define XDCS_GLOBAL_FLAG_URBS_OUTSTANDING           (XDCS_GLOBAL_FLAG_URB1_OUTSTANDING|\
                                                     XDCS_GLOBAL_FLAG_ENUM_URB_OUTSTANDING|\
                                                     XDCS_GLOBAL_FLAG_URB2_OUTSTANDING)
#define XDCS_GLOBAL_FLAG_WATCHDOG_RUNNING           0x00000010

//
//  Takes advantage that Urb1LastLength is stored
//  right before Urb1 and Urb2LastLength is stored
//  right before Urb2.
//
#define XDCS_URB_LAST_LEN(Urb) (*((PULONG)(Urb)-1))

//****************************************
// Internally useful macros
//****************************************
#define SET_FLAG(variable, flag)  ((variable) |= (flag))
#define CLEAR_FLAG(variable, flag)  ((variable) &= ~(flag))
#define TEST_FLAG(variable, flag)  ((variable)&(flag))
#define TEST_ANY_FLAG(variable, flag)  ((variable)&(flag))
#define TEST_ALL_FLAGS(variable, flag)  ((flag)==((variable)&(flag)))

//*****************************************************************************
// Really cool inline template function for walking buffers.
//*****************************************************************************
template <class T>
inline T *AdvancePtr(T *pT, ULONG cb)
{
    return (T *)(((ULONG)pT) + cb);
}


//*****************************************************************************
// Declare Globals
//*****************************************************************************
USB_RESOURCE_REQUIREMENTS XDCS_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_DIRECT, 1, 2, 1, 0, 0, XDCS_CONTROL_TD_QUOTA, 0, 0, 0};
XDCS_GLOBALS XDCS_Globals = {0};

//*****************************************************************************
// Forward Declaration of Local Functions
//*****************************************************************************
#if DBG
#define LOCALFUNC
#else
//Compiler may be able to optimize static functions better.
#define LOCALFUNC static
#endif 
LOCALFUNC VOID XDCS_AddComplete(PURB Urb, PXDCS_DEVICE XdcsDevice);
LOCALFUNC VOID XDCS_DownloadStateMachine(PURB Urb, PXDCS_DEVICE XdcsDevice);
LOCALFUNC BOOL XDCS_BuildAndSubmitDownloadRequest(PURB Urb,PXDCS_DEVICE XdcsDevice);
LOCALFUNC VOID XDCS_CompleteDownload(PURB Urb, PXDCS_DEVICE XdcsDevice);
LOCALFUNC VOID XDCS_WatchDogTimeout (PKDPC Dpc,PVOID,PVOID,PVOID);
LOCALFUNC VOID XDCS_StartExtendWatchdog();
LOCALFUNC VOID XDCS_StopWatchdog();    

//*****************************************************************************
// Implementation of USB Required Entry Points:
//  XDCS_Init,
//  XDCS_AddDevice,
//  XDCS_RemoveDevice
//*****************************************************************************
#pragma code_seg(".XPPCINIT")

EXTERNUSB VOID XDCS_Init(IUsbInit *pUsbInit)
/*++
    Routine Description:

        Called by the USB core stack when XDCS is linked in to the application.
        Initialize our globals, register our driver resource requirements.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XDCS_Init"));

    //Init the timer and timer dpc
    KeInitializeDpc(&XDCS_Globals.WatchDogTimerDpc, XDCS_WatchDogTimeout, NULL);
    KeInitializeTimer(&XDCS_Globals.WatchDogTimer);

    // register resources
    pUsbInit->RegisterResources(&XDCS_gResourceRequirements);

    USB_DBG_EXIT_PRINT(("Exiting XDCS_Init"));
    return;
}
#pragma code_seg(".XPPCODE")

EXTERNUSB VOID XDCS_AddDevice(IN IUsbDevice *Device)
/*++

    Routine Description:
    
      1) Records that the device is present and relevant info that
         it may need later.
      2) Gets the ROM info

    Arguments:
        Device - Interface to USB core stack for device.

    Notes:
        AddDevice routines are always called at DPC level.
--*/
{
    PXDCS_DEVICE xdcsDevice;
    ULONG ulPort;

    USB_DBG_ENTRY_PRINT(("XDCS_AddDevice(Device=0x%0.8x)", Device));
    
    //Get and check the port. (It should only work direct connect).
    ulPort = Device->GetPort();
    if(ulPort >= XDCS_MAX_PORTS)
    {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }
    
    xdcsDevice = &XDCS_Globals.Devices[ulPort];
    
    //This device should not already be marked as connected
    ASSERT(!TEST_FLAG(xdcsDevice->bFlags,XDCS_DEVICE_FLAG_CONNECTED));
    xdcsDevice->bInterfaceNumber = Device->GetInterfaceNumber();
    Device->SetExtension((PVOID)xdcsDevice);
    xdcsDevice->Device = Device;
    SET_FLAG(xdcsDevice->bFlags, XDCS_DEVICE_FLAG_ENUMERATING);

    //  Build and submit the XDCS_REQUEST_GET_ROM_FILE_INFO request
    USB_BUILD_CONTROL_TRANSFER(
        &XDCS_Globals.UrbEnum.ControlTransfer,
        NULL,
        (PVOID)&xdcsDevice->CodeInformation,         //right into the user's buffer
        sizeof(XDCS_DVD_CODE_INFORMATION),
        USB_TRANSFER_DIRECTION_IN,
        (PURB_COMPLETE_PROC)XDCS_AddComplete,
        (PVOID)xdcsDevice,
        FALSE,
        USB_DEVICE_TO_HOST|USB_VENDOR_COMMAND|USB_COMMAND_TO_INTERFACE,
        XDCS_REQUEST_GET_ROM_FILE_INFO,
        0,
        xdcsDevice->bInterfaceNumber,
        sizeof(XDCS_DVD_CODE_INFORMATION)
        );

    SET_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_ENUM_URB_OUTSTANDING);
    XDCS_StartExtendWatchdog();

    //Don't worry about errors the completion routine will handle.
    xdcsDevice->Device->SubmitRequest(&XDCS_Globals.UrbEnum);
    
    USB_DBG_EXIT_PRINT(("ExitingXDCS_AddDevice"));
    return;
}

LOCALFUNC VOID XDCS_AddComplete(PURB Urb, PXDCS_DEVICE XdcsDevice)
{

    CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_ENUM_URB_OUTSTANDING);
    CLEAR_FLAG(XdcsDevice->bFlags, XDCS_DEVICE_FLAG_ENUMERATING);
    XDCS_StopWatchdog();

    if(USBD_SUCCESS(Urb->Header.Status))
    {
        //Mark the device as connected
        SET_FLAG(XdcsDevice->bFlags,XDCS_DEVICE_FLAG_CONNECTED);
        //Complete the Add.
        XdcsDevice->Device->SetClassSpecificType(0);
        XdcsDevice->Device->AddComplete(USBD_STATUS_SUCCESS);
    } else
    {
        XdcsDevice->Device->AddComplete(Urb->Header.Status);
    }
}


EXTERNUSB VOID
XDCS_RemoveDevice (
    IN IUsbDevice *Device
    )
/*++
    Routine Description:
       
      1) Records the removal.
      2) If the device is not in use, it and completes the remove.

    Arguments:
        Device - Interface to USB core stack for device that is to be
                 removed.
    Notes:
        RemoveDevice routines are always called at DPC level.
--*/
{
    USB_DBG_ENTRY_PRINT(("XDCS_RemoveDevice(Device=0x%0.8x)", Device));
    PXDCS_DEVICE xdcsDevice = (PXDCS_DEVICE) Device->GetExtension();

    //Mark the device as not connected.
    CLEAR_FLAG(xdcsDevice->bFlags,XDCS_DEVICE_FLAG_CONNECTED);
    
    //Increment the instance counter - so when it is
    //plugged back in it is different.
    xdcsDevice->usInstance++;

    //If the device is not in use, complete the removal.
    //Otherwise, who ever is using it will complete the removal
    //after they clean up.
    if(!TEST_FLAG(xdcsDevice->bFlags,XDCS_DEVICE_FLAG_INUSE))
    {
       xdcsDevice->Device = NULL;
       Device->SetExtension(NULL);
       Device->RemoveComplete();
    }

    USB_DBG_EXIT_PRINT(("exiting XDCS_RemoveDevice"));
    return;
}

DWORD
WINAPI
XDCSGetInformation(
    IN  DWORD dwPort,
    OUT PDWORD pdwDeviceInstance,
    OUT PXDCS_DVD_CODE_INFORMATION pDvdCodeInformation
    )
{

    PXDCS_DEVICE xdcsDevice;
    KIRQL oldIrql;
    DWORD dwError = ERROR_SUCCESS;

    // Validate parameters
    RIP_ON_NOT_TRUE("XDCSGetInformation", (dwPort < XDCS_MAX_PORTS));
    RIP_ON_NOT_TRUE("XDCSGetInformation", (NULL != pdwDeviceInstance));
    RIP_ON_NOT_TRUE("XDCSGetInformation", (NULL != pDvdCodeInformation));
    
    //Get the requested device.
    xdcsDevice = &XDCS_Globals.Devices[dwPort];
    
    //Synchronize access
    oldIrql = KeRaiseIrqlToDpcLevel();

    // Make sure the device is connected
    if(!TEST_FLAG(xdcsDevice->bFlags, XDCS_DEVICE_FLAG_CONNECTED))
    {
        dwError = ERROR_DEVICE_NOT_CONNECTED;
    }
    else
    {
        RtlCopyMemory(pDvdCodeInformation, &xdcsDevice->CodeInformation, sizeof(XDCS_DVD_CODE_INFORMATION));
        *pdwDeviceInstance = MAKE_DWORD_INSTANCE(xdcsDevice->usInstance, dwPort);
    }
    
    //Done synchronizing
    KeLowerIrql(oldIrql);

    return dwError;

}

DWORD
WINAPI
XDCSDownloadCode(
    DWORD   dwDeviceInstance,
    PVOID   pvBuffer,
    ULONG   ulOffset,
    ULONG   ulLength,
    PULONG  pulBytesRead
    )
{
    XDCS_ASYNC_DOWNLOAD_REQUEST asyncRequest;

    //
    //  Need an event to signal when done
    //
    asyncRequest.hCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(NULL == asyncRequest.hCompleteEvent)
    {
        return GetLastError();
    }

    //
    //  Fill out rest of async request
    //
    asyncRequest.dwDeviceInstance = dwDeviceInstance;
    asyncRequest.pvBuffer = pvBuffer;
    asyncRequest.ulOffset = ulOffset;
    asyncRequest.ulLength = ulLength;
    
    //
    //  Submit async request
    //
    XDCSDownloadCodeAsync(&asyncRequest);
    
    //
    //  Wait for the request to complete
    //
    WaitForSingleObject(asyncRequest.hCompleteEvent, INFINITE);

    //
    //  Copy byte read
    //
    *pulBytesRead = asyncRequest.ulBytesRead;

    //
    //  Return the status
    //
    return asyncRequest.ulStatus;
}

__inline BOOL SleepIfBusy(DWORD dwError)
{
    if(ERROR_BUSY == dwError)
    {
        Sleep(10);
        return TRUE;
    }
    return FALSE;
}

DWORD
WINAPI
XDCSDownloadCodeAsync(
    IN OUT PXDCS_ASYNC_DOWNLOAD_REQUEST pXDCSDownloadRequest
    )
{
    DWORD dwPort = PORT_FROM_DWORD_INSTANCE(pXDCSDownloadRequest->dwDeviceInstance);
    PXDCS_DEVICE xdcsDevice = &XDCS_Globals.Devices[dwPort];
    DWORD dwError;
    KIRQL oldIrql;
    
    
    //
    //  Loop until we managed to get capture the 
    //  transfer resources, poor man's mutex, but
    //  there should not be any contention for this.
    do
    {
        dwError = ERROR_SUCCESS;
        
        //Synchronize access
        oldIrql = KeRaiseIrqlToDpcLevel();
    
        //
        //  Check instance to make sure that the caller is getting
        //  what it thinks it is getting.  As long as the client
        //  got the instance from us, this is sufficient to check that
        //  the device is actually connected, unless the device has been
        //  added and removed 65536 times since they called us last.
        //
        if( xdcsDevice->usInstance != USHORT_INSTANCE_FROM_DWORD_INSTANCE(pXDCSDownloadRequest->dwDeviceInstance))
        {
            dwError = ERROR_DEVICE_NOT_CONNECTED;
        } else if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_TRANSFER_IN_PROGRESS))
        {
            dwError = ERROR_BUSY;
#if DBG        
        } else if(pXDCSDownloadRequest->ulOffset%XDCS_BLOCK_LENGTH)
        {
            KeLowerIrql(oldIrql);
            RIP("XDCSDownloadCode\\XDCSDownloadCodeAsync, Offset must be 1 kbyte aligned.");
            oldIrql = KeRaiseIrqlToDpcLevel();
        } else if(
            (pXDCSDownloadRequest->ulOffset+pXDCSDownloadRequest->ulLength) > 
            xdcsDevice->CodeInformation.dwCodeLength
          )
        {
            KeLowerIrql(oldIrql);
            RIP("XDCSDownloadCode\\XDCSDownloadCodeAsync, Transfer request is beyond data length");
            oldIrql = KeRaiseIrqlToDpcLevel();
#endif
        } else
        {
            //
            //  Claim the transfer resources
            //
            SET_FLAG(xdcsDevice->bFlags, XDCS_DEVICE_FLAG_INUSE);
            SET_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_TRANSFER_IN_PROGRESS);
            XDCS_Globals.CurrentDownloadRequest = pXDCSDownloadRequest;
            
            //
            //  Open the default endpoint
            //
            USB_BUILD_OPEN_DEFAULT_ENDPOINT(&XDCS_Globals.Urb1.OpenEndpoint);
            xdcsDevice->Device->SubmitRequest(&XDCS_Globals.Urb1);
        
            //
            //  Start Download
            //
            XDCS_DownloadStateMachine(NULL, xdcsDevice);
            dwError = ERROR_IO_PENDING;
        }
        KeLowerIrql(oldIrql);

    }while (SleepIfBusy(dwError));
    
    return dwError;
}

LOCALFUNC
VOID
XDCS_DownloadStateMachine(
    PURB Urb,
    PXDCS_DEVICE XdcsDevice
    )
{
    //
    //  Check if this is the first call.
    //
    if(NULL==Urb)
    {
        XDCS_Globals.UsbdStatus = USBD_STATUS_SUCCESS;
        XDCS_Globals.BytesSubmitted = 0;
        XDCS_Globals.CurrentDownloadRequest->ulStatus = ERROR_IO_PENDING;
        XDCS_Globals.CurrentDownloadRequest->ulBytesRead = 0;
        XDCS_Globals.RetryCount = 0;
        SET_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_DOWNLOAD_URBS_OUTSTANDING);
        XDCS_BuildAndSubmitDownloadRequest(&XDCS_Globals.Urb1, XdcsDevice);
        XDCS_BuildAndSubmitDownloadRequest(&XDCS_Globals.Urb2, XdcsDevice);
    } else
    //
    //  This is an URB completing
    //
    {
        BOOL fDone = FALSE;
        if(USBD_SUCCESS(Urb->Header.Status))
        {
            XDCS_Globals.RetryCount = 0;
            XDCS_Globals.CurrentDownloadRequest->ulBytesRead += Urb->ControlTransfer.TransferBufferLength;
            //
            // Resubmit the URB if there is more to transfer
            //
            fDone = XDCS_BuildAndSubmitDownloadRequest(Urb, XdcsDevice);
        }else if( (XDCS_Globals.RetryCount++ < XDCS_MAX_TRIES) && TEST_FLAG(XdcsDevice->bFlags, XDCS_DEVICE_FLAG_CONNECTED) )
        //
        //  Check the retry count and make sure the device is still connected.
        //  If we have retries left, just resubmit, but remember to reset
        //  the length, this is an IN\OUT parameter.
        //
        {
          XDCS_StartExtendWatchdog(); //Pet watchdog
          Urb->CommonTransfer.TransferBufferLength = XDCS_URB_LAST_LEN(Urb);
          XdcsDevice->Device->SubmitRequest(Urb);
        } else
        //
        //  Failed and the device is not connected or the retry count is exceeded.
        //
        {
            //
            //  Record the error if it is the first
            //
            if(USBD_SUCCESS(XDCS_Globals.UsbdStatus))
            {
              XDCS_Globals.UsbdStatus = Urb->Header.Status;
            }
            //
            //  If the twin URB is outstanding, cancel it.  If it is not oustanding
            //  mark that we are done.
            //
            if( &XDCS_Globals.Urb1 == Urb)
            {
                CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB1_OUTSTANDING);
                if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB2_OUTSTANDING))
                {
                    XdcsDevice->Device->CancelRequest(&XDCS_Globals.Urb2);
                } else
                {
                    fDone = TRUE;
                }
            } else
            {
                CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB2_OUTSTANDING);
                if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB1_OUTSTANDING))
                {
                    XdcsDevice->Device->CancelRequest(&XDCS_Globals.Urb1);
                } else
                {
                    fDone = TRUE;
                }
            }
        }
        //
        //  If the transfer is done, close down the endpoint.
        //
        if(fDone)
        {
            XDCS_StopWatchdog();
            USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
                &XDCS_Globals.Urb1.CloseEndpoint,
                (PURB_COMPLETE_PROC)XDCS_CompleteDownload,
                (PVOID)XdcsDevice
                );
            XdcsDevice->Device->SubmitRequest(&XDCS_Globals.Urb1);
        }
    }
}

LOCALFUNC
BOOL
XDCS_BuildAndSubmitDownloadRequest(
    PURB Urb,
    PXDCS_DEVICE XdcsDevice
    )
{
    //
    //  If there are more byte to submit, do it.
    //
    if(XDCS_Globals.BytesSubmitted < XDCS_Globals.CurrentDownloadRequest->ulLength)
    {
        //Calculate the transfer length for this command
        ULONG ulTransferSize = XDCS_Globals.CurrentDownloadRequest->ulLength - XDCS_Globals.BytesSubmitted;
        if(ulTransferSize > XDCS_BLOCK_LENGTH) ulTransferSize = XDCS_BLOCK_LENGTH;
        
        //
        //  Store the length in case we need to retry
        //
        XDCS_URB_LAST_LEN(Urb) = ulTransferSize;

        USBD_STATUS usbdStatus;
        USB_BUILD_CONTROL_TRANSFER(
                &Urb->ControlTransfer,
                NULL,
                AdvancePtr(XDCS_Globals.CurrentDownloadRequest->pvBuffer, XDCS_Globals.BytesSubmitted),
                ulTransferSize,
                USB_TRANSFER_DIRECTION_IN,
                (PURB_COMPLETE_PROC)XDCS_DownloadStateMachine,
                (PVOID)XdcsDevice,
                FALSE,
                USB_DEVICE_TO_HOST|USB_VENDOR_COMMAND|USB_COMMAND_TO_INTERFACE,
                XDCS_REQUEST_GET_ROM_FILE_BLOCK,
                (WORD)((XDCS_Globals.CurrentDownloadRequest->ulOffset + XDCS_Globals.BytesSubmitted)>>XDCS_BLOCK_SHIFT),
                (WORD)XdcsDevice->bInterfaceNumber,
                (WORD)ulTransferSize
                );
        XDCS_Globals.BytesSubmitted += ulTransferSize;
        XDCS_StartExtendWatchdog();
        usbdStatus = XdcsDevice->Device->SubmitRequest(Urb);
        return FALSE;
    }

    //
    //  If there are no more requests to submit then clear the appropriate
    //  XDCS_GLOBAL_FLAG_URB?_OUTSTANDING flag.
    //
    if( &XDCS_Globals.Urb1 == Urb)
    {
        CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB1_OUTSTANDING);
    } else
    {
        CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB2_OUTSTANDING);
    }

    return 
      TEST_ANY_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_DOWNLOAD_URBS_OUTSTANDING) ?
      FALSE : TRUE;

}

LOCALFUNC
VOID 
XDCS_CompleteDownload(
    PURB Urb,
    PXDCS_DEVICE XdcsDevice
    )
{
    //
    //  Set the status and signal the hEvent.
    //
    XDCS_Globals.CurrentDownloadRequest->ulStatus = IUsbDevice::Win32FromUsbdStatus(XDCS_Globals.UsbdStatus);
    if(XDCS_Globals.CurrentDownloadRequest->hCompleteEvent)
        SetEvent(XDCS_Globals.CurrentDownloadRequest->hCompleteEvent);

    //
    //  Release the shared resources
    //
    XDCS_Globals.CurrentDownloadRequest = NULL;
    CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_TRANSFER_IN_PROGRESS);

    //
    //  Clear the in use flag
    //
    CLEAR_FLAG(XdcsDevice->bFlags, XDCS_DEVICE_FLAG_INUSE);
    //
    //  Check if the device was removed while we were using it.  If it was
    //  need to complete the remove.
    //
    if(!TEST_FLAG(XdcsDevice->bFlags, XDCS_DEVICE_FLAG_CONNECTED))
    {
       XdcsDevice->Device->SetExtension(NULL);
       XdcsDevice->Device->RemoveComplete();
       XdcsDevice->Device = NULL;
    }
}


LOCALFUNC
VOID
XDCS_WatchDogTimeout (
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
    Routine Description:
        
        This is the DPC routine for the XDCS watchdog timer.  It protects
        against hung requests, NAK forever.
        
        Whenever it fires it cancels all outstanding URBs.

--*/
{

    USB_DBG_WARN_PRINT(("XDCS timed out."));

    CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_WATCHDOG_RUNNING);
    
    PXDCS_DEVICE xdcsDevice = NULL;
    if(XDCS_Globals.CurrentDownloadRequest)
    {
        xdcsDevice = &XDCS_Globals.Devices[
                        PORT_FROM_DWORD_INSTANCE(XDCS_Globals.CurrentDownloadRequest->dwDeviceInstance)
                        ];

        if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB1_OUTSTANDING))
        {
            xdcsDevice->Device->CancelRequest(&XDCS_Globals.Urb1);
        }
        if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URB2_OUTSTANDING))
        {
            xdcsDevice->Device->CancelRequest(&XDCS_Globals.Urb2);
        }
    }

    if(TEST_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_ENUM_URB_OUTSTANDING))
    {
        for(DWORD dwPort=0; dwPort<XDCS_MAX_PORTS; dwPort++)
        {
            if( TEST_FLAG(XDCS_Globals.Devices[dwPort].bFlags, XDCS_DEVICE_FLAG_ENUMERATING) )
            {
                XDCS_Globals.Devices[dwPort].Device->CancelRequest(&XDCS_Globals.UrbEnum);
                break;
            }
        }
    }
        
}

LOCALFUNC 
VOID 
XDCS_StartExtendWatchdog()
{
    LARGE_INTEGER timeout;
    timeout.QuadPart = XDCS_REQUEST_TIMEOUT;
    SET_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_WATCHDOG_RUNNING);
    KeSetTimer(&XDCS_Globals.WatchDogTimer, timeout, &XDCS_Globals.WatchDogTimerDpc);
}

LOCALFUNC VOID XDCS_StopWatchdog()
{
    if(!TEST_ANY_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_URBS_OUTSTANDING))
    {
        KeCancelTimer(&XDCS_Globals.WatchDogTimer);
        CLEAR_FLAG(XDCS_Globals.ulGlobalFlags, XDCS_GLOBAL_FLAG_WATCHDOG_RUNNING);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xid\xid.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    xid.cpp

Abstract:
    
    Basic entry point implementation of the XID driver.
    
    
Environment:

    Designed for XBOX.

Notes:

    
    
Revision History:

    02-21-00 created by Mitchell Dernis (mitchd)

--*/
#define XID_IMPLEMENTATION

//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("XID");

//
//  Pull in public usb headers
//
#include <usb.h>
//
//  Pull in xid headers
//
#include "xid.h"

//------------------------------------------------------------------------------
//  Declare XID's global variables.
//------------------------------------------------------------------------------
XID_GLOBALS XID_Globals;

//------------------------------------------------------------------------------
//  Forward declaration of locally defined functions
//------------------------------------------------------------------------------
VOID
XID_WatchdogTimerProc(
    PKDPC,
    PVOID,
    PVOID,
    PVOID
    );

VOID
XID_EnumStage1(
    PURB Urb,
    PXID_DEVICE_NODE XidNode
    );

VOID
FASTCALL
XID_fRemoveDeviceComplete(
    IN PXID_DEVICE_NODE XidNode
    );

PXID_DEVICE_NODE
FASTCALL
XID_fFindNode(
    IN UCHAR  Type,
    IN ULONG  Port
    );

USBD_STATUS
FASTCALL
XID_fOpenEndpoints(
    PXID_OPEN_DEVICE OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    );

VOID
FASTCALL
XID_fCloseEndpoints(
    PXID_OPEN_DEVICE OpenDevice
    );

VOID 
XID_CloseEndpointStateMachine(
    PURB_CLOSE_ENDPOINT CloseUrb,
    PXID_OPEN_DEVICE OpenDevice
    );

VOID
XID_NewInterruptData(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    );

VOID
XID_ClearInputStallComplete(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    );

VOID
XID_OutputComplete(
    PURB                      Urb,
    PXINPUT_FEEDBACK_INTERNAL  OutputReport
    );

VOID
FASTCALL
XID_fOutputComplete1(
    PURB Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    );

VOID
XID_ClearOutputStallComplete(
    PURB                     Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    );

VOID XID_EnumLegacy1(PURB Urb, PXID_DEVICE_NODE XidNode);
//VOID XID_EnumLegacy2(PURB Urb, PXID_DEVICE_NODE XidNode);
VOID XID_EnumKeyboard(PURB Urb, PXID_DEVICE_NODE XidNode);
VOID XID_EnumKeyboardComplete(PURB Urb, PXID_DEVICE_NODE XidNode);
PXID_KEYBOARD_SERVICES XID_pKeyboardServices = NULL;

//------------------------------------------------------------------------------
//  Declare XID types and class.
//------------------------------------------------------------------------------
DECLARE_XPP_TYPE(XDEVICE_TYPE_GAMEPAD)
DECLARE_XPP_TYPE(XDEVICE_TYPE_DEBUG_KEYBOARD)
DECLARE_XPP_TYPE(XDEVICE_TYPE_IR_REMOTE)

#ifndef XDEVICE_TYPE_DEBUG_KEYBOARD
#define XDEVICE_TYPE_DEBUG_KEYBOARD (&XDEVICE_TYPE_DEBUG_KEYBOARD_TABLE)
#endif

USB_DEVICE_TYPE_TABLE_BEGIN(XID_)
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_GAMEPAD),
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_DEBUG_KEYBOARD),
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_IR_REMOTE)
USB_DEVICE_TYPE_TABLE_END()

USB_CLASS_DRIVER_DECLARATION(XID_, USB_DEVICE_CLASS_HUMAN_INTERFACE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(XID_, 1, XBOX_DEVICE_CLASS_INPUT_DEVICE, 0xFF, 0xFF)

#pragma data_seg(".XPP$ClassXID")
USB_CLASS_DECLARATION_POINTER(XID_)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(XID_, 1)
#pragma data_seg(".XPP$Data")


USB_RESOURCE_REQUIREMENTS XID_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_DIRECT, 0, 0, 1, 0, 2, 10, 0, 0, 0};

#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID XID_Init(IUsbInit *UsbInit)
/*++
    Routine Description:
        Called at boot.  Registers with usbpnp.sys.  Intializes
        globals.
--*/
{
    ULONG handleCount;
    ULONG index;
    //
    //  Verify that XOUTPUT_SIZE_OF_INTERNAL_HEADER is defined correctly
    //  in input.h
    //
    C_ASSERT(sizeof(XINPUT_FEEDBACK_HEADER_INTERNAL) == XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE);

    //Sentry to protect against double init.  This happens because we support XID and HID
    //class as the interface class.  This support is here to stay.
    static BOOL fInitialized = FALSE;
    if(fInitialized) return;
    fInitialized = TRUE;

    //
    //  Figure out how many nodes we need
    //
    XID_Globals.DeviceNodeCount = XGetPortCount()*XID_MAX_DEVICE_PER_PORT;

    //
    //  Based on the user's registration figure out how many handles we need.
    //
    
    if(!UsbInit->UseDefaultCount())
    {
        handleCount = XID_TypeInformationList[XID_DEVTYPE_GAMECONTROLLER].bRemainingHandles = 
                            UsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_GAMEPAD);
        
        RIP_ON_NOT_TRUE_WITH_MESSAGE(handleCount <= XGetPortCount(), "XInitDevices: requested more XDEVICE_TYPE_GAMEPAD than available ports.");

        handleCount +=
            XID_TypeInformationList[XID_DEVTYPE_KEYBOARD].bRemainingHandles = 
                UsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_DEBUG_KEYBOARD);
        RIP_ON_NOT_TRUE_WITH_MESSAGE(XID_TypeInformationList[XID_DEVTYPE_KEYBOARD].bRemainingHandles <= XGetPortCount(), 
                                                "XInitDevices: requested more XDEVICE_TYPE_DEBUG_KEYBOARD than available ports.");
        handleCount +=
            XID_TypeInformationList[XID_DEVTYPE_IRREMOTE].bRemainingHandles = 
                UsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_IR_REMOTE);
        RIP_ON_NOT_TRUE_WITH_MESSAGE(XID_TypeInformationList[XID_DEVTYPE_IRREMOTE].bRemainingHandles <= XGetPortCount(), 
                                                "XInitDevices: requested more XDEVICE_TYPE_IR_REMOTE than available ports.");
    } else
    {
        handleCount = XID_TypeInformationList[XID_DEVTYPE_GAMECONTROLLER].bRemainingHandles;
        handleCount += XID_TypeInformationList[XID_DEVTYPE_KEYBOARD].bRemainingHandles;
        handleCount += XID_TypeInformationList[XID_DEVTYPE_IRREMOTE].bRemainingHandles;
    }

    //
    //  This could happen, because some device types could be mutually
    //  exclusive, occupying the same slot.
    //
    if(handleCount > XID_Globals.DeviceNodeCount)
    {
        handleCount = XID_Globals.DeviceNodeCount;
    }

    //
    //  Allocate a block for device nodes and handles
    //  
    ULONG allocSize = sizeof(XID_DEVICE_NODE)*XID_Globals.DeviceNodeCount + sizeof(XID_OPEN_DEVICE)*handleCount;
    ULONG_PTR memory = (ULONG_PTR) RTL_ALLOCATE_HEAP(allocSize);
    ASSERT(memory);
    
    //
    //  Create a free list of handles
    //
    XID_Globals.DeviceHandles = NULL;
    PXID_OPEN_DEVICE openDevices = (PXID_OPEN_DEVICE) memory;
    for(index=0; index < handleCount; index++)
    {
        XID_FreeHandle(openDevices++);
    }

    //
    //  Initialize the open device nodes
    //
    XID_Globals.DeviceNodes = (PXID_DEVICE_NODE)openDevices;
    XID_Globals.DeviceNodeInUseCount = 0;
    for(index = 0; index < XID_Globals.DeviceNodeCount; index++)
    {
        XID_Globals.DeviceNodes[index].InUse = FALSE;
    }

    //
    //  Register our resources
    //
    XID_gResourceRequirements.MaxDevices = handleCount;
    UsbInit->RegisterResources(&XID_gResourceRequirements);

    //
    //  Initialize other globals.
    //
    KeInitializeTimer(&XID_Globals.EnumWatchdogTimer);
	return;
}
#pragma code_seg(".XPPCODE")

__inline void XID_SetEnumWatchdog()
/*++
    Routine Description:
        Called to start a 5 second watchdog timer on transfers
        during device enumeration.
--*/
{
    LARGE_INTEGER wait;
    wait.QuadPart = -50000000;
    KeSetTimer(&XID_Globals.EnumWatchdogTimer,wait,&XID_Globals.EnumWatchdogTimerDpc);
}

__inline void XID_ClearEnumWatchdog()
/*++
    Routine Description:
        Called to cancel a 5 second watchdog timer when a transfer during
        enumeration completes.
--*/
{
    KeCancelTimer(&XID_Globals.EnumWatchdogTimer);
}

VOID XID_WatchdogTimerProc(PKDPC, PVOID pvDevice, PVOID, PVOID)
/*++
    Routine Description:
        DPC routine called if a 5 second watchdog timer expires protecting
        asynchronous transfers during enumeration.  The routine forces completion
        of the URB by canceling it.  This will cause enumeration to fail,
        but avoids hanging USB device enumeration system wide.
--*/
{
    IUsbDevice *device = (IUsbDevice *)pvDevice;
    USB_DBG_ERROR_PRINT(("Enumeration Watchdog Timer has expired.\n"));
    device->CancelRequest(&XID_Globals.EnumUrb);
}

EXTERNUSB VOID
XID_AddDevice(
    IN IUsbDevice *Device
    )
/*++
    Routine Description:
        This routine is registered as the AddDevice routine for new XID devices.
        It performs the following tasks:
            1) Allocates a XidNode from the static pool of nodes.
            2) Begins the XID enumeration provcess.
        Enumeration is continued in XID_EnumStage1.
--*/
{
    UCHAR                          nodeIndex = 0;
    PXID_DEVICE_NODE               xidNode;
    const USB_ENDPOINT_DESCRIPTOR *endpointDescriptor;
	        
    USB_DBG_ENTRY_PRINT(("Entering XID_AddDevice.\n"));
    if(XID_Globals.DeviceNodeInUseCount < XID_Globals.DeviceNodeCount)
    {
        //
        //  Find a free node, and claim it.
        //
        while(XID_Globals.DeviceNodes[nodeIndex].InUse) nodeIndex++;
        XID_Globals.DeviceNodeInUseCount++;
        XID_Globals.EnumNode = nodeIndex;
        xidNode = XID_Globals.DeviceNodes + nodeIndex;
		Device->SetExtension((PVOID)xidNode);
		xidNode->Device = Device;

        //
        //  Initialize what we can about the device.
        //
        xidNode->InUse = TRUE;
        xidNode->Ready = FALSE;
        xidNode->PendingRemove = FALSE;
        xidNode->Opened = FALSE;
        xidNode->InterfaceNumber = Device->GetInterfaceNumber();
        xidNode->OpenDevice = NULL;
        
    	//
		//	Get the interrupt-in endpoint descriptor  (NOT OPTIONAL).
		//
		endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_INTERRUPT, TRUE, 0);
		ASSERT(endpointDescriptor);
        xidNode->EndpointAddressIn = endpointDescriptor->bEndpointAddress;
        xidNode->MaxPacketIn = (UCHAR)endpointDescriptor->wMaxPacketSize;
		
		//
		//	Get the interrupt-out endpoint (OPTIONAL)
		//
		endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_INTERRUPT, FALSE, 0);
		if(endpointDescriptor)
		{
			xidNode->EndpointAddressOut = endpointDescriptor->bEndpointAddress;
			xidNode->MaxPacketOut = (UCHAR)endpointDescriptor->wMaxPacketSize;
		} else
		{
            xidNode->EndpointAddressOut = 0;
			xidNode->MaxPacketOut = 0;
		}
        //
        //  Get XID Descriptor
        //
        USB_BUILD_CONTROL_TRANSFER(
            (PURB_CONTROL_TRANSFER)&XID_Globals.EnumUrb,
            NULL, //Default endpoint
            (PVOID)&XID_Globals.EnumDeviceDescriptor,
            sizeof(XID_DESCRIPTOR),
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_EnumStage1,
            (PVOID)xidNode,
            TRUE,
            (USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE),
            USB_REQUEST_GET_DESCRIPTOR,
            XID_DESCRIPTOR_TYPE,
            xidNode->InterfaceNumber,
            sizeof(XID_DESCRIPTOR)
            );
        //
        //  Reinitialize the watchdog DPC, so that the context is our device
        //
        KeInitializeDpc(&XID_Globals.EnumWatchdogTimerDpc, XID_WatchdogTimerProc, (PVOID)Device);
        XID_SetEnumWatchdog();
        Device->SubmitRequest(&XID_Globals.EnumUrb);
    }
    else
    {
        //
        //  Out of nodes so we cannot support the device
        //  (allow retry)
        //
        ASSERT(FALSE);
        Device->AddComplete(USBD_STATUS_NO_MEMORY);
    }
    USB_DBG_EXIT_PRINT(("Exiting XID_AddDevice.\n"));
}

VOID
XID_EnumStage1(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
    Routine Description:
        Completion routine for obtaining the XID descriptor started
        in AddDevice.
        
        If retriving the XID_DESCRIPTOR failed,
--*/
{
    XID_ClearEnumWatchdog();
    //
    //  Getting the XID Descriptor may have failed.  This probably
    //  means it is a legacy device.
    //
    if(USBD_ERROR(Urb->Header.Status))
    {
        USB_DBG_EXIT_PRINT(("Couldn't get XID descriptor, could be a HID keyboard.\n"));
        XID_EnumLegacy1(Urb, XidNode);
        return;
    }

    //
    //  Copy the necessary info out of the Xid Descriptor
    //
    XidNode->Type = XID_Globals.EnumXidDescriptor.bType-1;
    XidNode->SubType = XID_Globals.EnumXidDescriptor.bSubType;
    XidNode->bMaxInputReportSize = XID_Globals.EnumXidDescriptor.bMaxInputReportSize;
    XidNode->bMaxOutputReportSize = XID_Globals.EnumXidDescriptor.bMaxOutputReportSize;
    
    //
    //  Check a number of items to determine if we can support the device.
    //      1) The type must be one known at compile time
    //      2) The report size must be at least as large as the XID_REPORT_HEADER.
    //      3) The maximum report size must not be larger than our buffer (XID_MAXIMUM_REPORT_SIZE)
    //         this is a limit on the extensibility of XID.
    //      4) For performance and resource management reasons we enforce that
    //         the entire report fit in a single interrupt-IN packet (there is
    //         no such requirement on the control pipe).
    //      5) Same for output, but only if interrupt OUT is supported.
    //
    if(
        (XID_DEVTYPE_COUNT <= XidNode->Type) ||
        (XID_REPORT_HEADER > XID_Globals.EnumXidDescriptor.bMaxInputReportSize) ||
        (XID_MAXIMUM_REPORT_SIZE < XID_Globals.EnumXidDescriptor.bMaxInputReportSize) ||
        (XidNode->bMaxInputReportSize > XidNode->MaxPacketIn) ||
        (XidNode->EndpointAddressOut && (XidNode->bMaxOutputReportSize > XidNode->MaxPacketOut))
    )
    {
        USB_DBG_WARN_PRINT(("Unsupported XID Device"));
        XidNode->Device->SetExtension(NULL);
        XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    	XidNode->Device=NULL;
        XidNode->InUse = FALSE;
        XID_Globals.DeviceNodeInUseCount--;
        return;
    }

    //
    //  Set the class specific type and call AddComplete.
    //

    XidNode->Device->SetClassSpecificType(XidNode->Type);
    XidNode->Device->AddComplete(USBD_STATUS_SUCCESS);
    XidNode->Ready = TRUE;
}

EXTERNUSB VOID
XID_RemoveDevice(
    IUsbDevice *Device
    )
/*++
    Routine Description:
        Called by usbd when a device is removed.  It kicks off out
        remove sequence.
--*/
{
    PXID_DEVICE_NODE xidNode = (PXID_DEVICE_NODE)Device->GetExtension();
    ASSERT(NULL != xidNode);
    
	ASSERT_DISPATCH_LEVEL();
    //
    //  Mark the Node remove pending.
    //
    xidNode->PendingRemove = TRUE;
    //
    //  If there is an open handle
    //  kick off a close.
    //
    if(xidNode->OpenDevice)
    {
        //
        // Notify keyboard services of device removal.
        //
        #ifdef DEBUG_KEYBOARD
        if((XID_DEVTYPE_KEYBOARD==xidNode->Type) && XID_pKeyboardServices)
        {
          XID_pKeyboardServices->pfnRemove(xidNode->OpenDevice);
        }
        #endif DEBUG_KEYBOARD
        XID_fCloseEndpoints(xidNode->OpenDevice);
    } else
    //
    //  Otherwise, we can wrap up the remove.
    //
    {
        XID_fRemoveDeviceComplete(xidNode);        
    }
}

VOID
FASTCALL
XID_fRemoveDeviceComplete(
    IN PXID_DEVICE_NODE XidNode
    )
/*++
    Routine Description:
        This routine is called by XID_DereferenceNode, when
        the reference count on a XID node goes to zero.
        At that time, it is certain that all open endpoints
        are closed, and all outstanding I/O is complete.
--*/
{
    ASSERT_DISPATCH_LEVEL();
    //
    //  We are really done
    //
    USB_DBG_TRACE_PRINT(("Freeing node(0x%0.8x) nodeIndex = %d\n", XidNode, XidNode - XID_Globals.DeviceNodes));
    ASSERT(XidNode->PendingRemove);
	XidNode->Device->SetExtension(NULL);
	XidNode->Device->RemoveComplete();
	XidNode->Device=NULL;
    XidNode->InUse = FALSE;
    XID_Globals.DeviceNodeInUseCount--;
    return;
}

PXID_DEVICE_NODE
FASTCALL
XID_fFindNode(
    IN UCHAR  Type,
    IN ULONG  Port
    )
/*++
    Routine Description:
        Finds a XID node that corresponds to the type and port (port includes port and slot).
        Will only return nodes that are ready to be open.
    Return Value:
        If a suitable node is found, it is returned.  Otherwise, NULL is returned.
    Environement:
        Assumes DISPATCH_LEVEL.
--*/
{
    UCHAR xidNodeIndex;
    PXID_DEVICE_NODE xidNode = NULL;
    //
    //  Brute force search of all the nodes.
    //
    for(xidNodeIndex = 0; xidNodeIndex < XID_Globals.DeviceNodeCount; xidNodeIndex++)
    {
        if(
            XID_Globals.DeviceNodes[xidNodeIndex].InUse &&
            (XID_Globals.DeviceNodes[xidNodeIndex].Device->GetPort() == Port) &&
            (XID_Globals.DeviceNodes[xidNodeIndex].Type == Type) &&
            XID_Globals.DeviceNodes[xidNodeIndex].Ready &&
            !XID_Globals.DeviceNodes[xidNodeIndex].PendingRemove
        ){
            xidNode =  XID_Globals.DeviceNodes + xidNodeIndex;
        }
    }
    return xidNode;
}

DWORD
FASTCALL
XID_fOpenDevice(
    UCHAR            XidType,
    ULONG            Port,
    PXID_OPEN_DEVICE *OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    )
/*++
    Given a XidTy creates an OpenDevice,
    initializes the OpenDevice and opens
    the endpoints so the device can be used.
--*/
{
    
    USBD_STATUS         status;
    PXID_OPEN_DEVICE    openDevice;
    PXID_DEVICE_NODE    xidNode;
    KIRQL               oldIrql;
    DWORD               errorCode = ERROR_SUCCESS;
    BOOL                partiallyOpen = FALSE;

    //
    // By default we want to return NULL.
    //
    *OpenDevice = NULL;

    //
    //  Must be done at high Irql
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Find the node
    //
    xidNode = XID_fFindNode(XidType, Port);
    if(!xidNode)
    {
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_open_device;
    }

    //
    //  Make sure that it is not already open
    //
    if(xidNode->OpenDevice)
    {
        errorCode = ERROR_SHARING_VIOLATION;
        goto exit_open_device;
    }

    
    if(0==XID_TypeInformationList[XidType].bRemainingHandles)
    {
        errorCode = ERROR_OUTOFMEMORY;
        goto exit_open_device;        
    }
    
    //
    //  Allocate memory for the device handle
    //
    
    XID_TypeInformationList[XidType].bRemainingHandles--;
    openDevice = XID_AllocateHandle();
    
    //
    //  Initialize the basic stuff
    //
    RtlZeroMemory(openDevice, sizeof(XID_OPEN_DEVICE));
    openDevice->XidNode = xidNode;
    openDevice->Type = XidType;
    openDevice->AutoPoll = PollingParameters->fAutoPoll ? TRUE : FALSE;
    
    //
    //  Tie the xidNode to our handle.
    //
    xidNode->OpenDevice = openDevice;

    //
    //  Any failure after here, requires closing the device.
    //
    partiallyOpen = TRUE;

    //
    //  Open the endpoints
    //

    status = XID_fOpenEndpoints(openDevice, PollingParameters);

    //
    //  If the endpoints were successfully opened
    //  then setup the initial state.
    //
    if(USBD_SUCCESS(status))
    {
        //
        //  Initialize the Report and the Report for URB
        //  with the default values;
        //
        RtlCopyMemory(
            (PVOID)(openDevice->ReportForUrb+XID_REPORT_HEADER),
            XID_TypeInformationList[xidNode->Type].pInputReportInfoList[0].pDefaultValues,
            XID_TypeInformationList[xidNode->Type].pInputReportInfoList[0].bCurrentSize
            );
        RtlCopyMemory(
            (PVOID)openDevice->Report,
            (PVOID)(openDevice->ReportForUrb+XID_REPORT_HEADER),
            sizeof(openDevice->Report)
            );

        //
        //  Initialize an event for synchronization
        //
        KEVENT   event;
        KeInitializeEvent(&event, SynchronizationEvent, FALSE);
    
        //
        //  Build a control transfer
        //
        WORD wReportTypeAndId = 0x0100;
        ULONG ulBufferSize = xidNode->bMaxInputReportSize;
        USB_BUILD_CONTROL_TRANSFER(
            &openDevice->Urb.ControlTransfer,
            NULL, //Default endpoint
            openDevice->ReportForUrb,
            ulBufferSize,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_SyncComplete, //do it synchronously
            &event,  //the context is the event.
            TRUE,
            (USB_DEVICE_TO_HOST | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE),
            XID_COMMAND_GET_REPORT,
            wReportTypeAndId, //Input report 0
            xidNode->InterfaceNumber,
            ulBufferSize
            );

        //
        //  Submit the request
        //
        xidNode->Device->SubmitRequest(&openDevice->Urb);
    
        //
        //  Lower IRQL, and wait for transfer to complete.
        //  Then restore Irql to DPC level
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  During the transfer the device may have been removed,
        //  if so we should check to make sure that the device is
        //  still with us.  There are two cases here: the device is
        //  totally gone, the device is still pending remove.
        //
    
        if(NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_open_device;
        } 

        //
        //  Process the GET_REPORT results, if it succeeded
        //
        if(USBD_SUCCESS(openDevice->Urb.Header.Status))
        {
            XID_TypeInformationList[xidNode->Type].pfnProcessNewData(openDevice);
        } 
#if DBG
        else
        //
        // Issue warning if GET_REPORT failed.
        //
	    { 
           if(USBD_STATUS_STALL_PID == openDevice->Urb.Header.Status)
           {
		       USB_DBG_WARN_PRINT(("Device in port %d (0 based) does not support GET_REPORT\n", Port));
           }
        }
#endif

        //
        // Notify keyboard services of new open device.
        //
        if((XID_DEVTYPE_KEYBOARD==openDevice->Type) && XID_pKeyboardServices)
        {
          XID_pKeyboardServices->pfnOpen(openDevice);
        }

        //
        //  Prepare the URB for the interrupt-in endpoint.
        //
        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
            (PURB_BULK_OR_INTERRUPT_TRANSFER)&openDevice->Urb,
            openDevice->InterruptInEndpointHandle,
            openDevice->ReportForUrb,
            xidNode->bMaxInputReportSize,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_NewInterruptData,
            (PVOID)openDevice,
            TRUE
            );

        //
        //  If autopoll is set, start polling
        //
        if(openDevice->AutoPoll)
        {
          xidNode->Device->SubmitRequest(&openDevice->Urb);
        }

        
        //
        //  If we are here, the device was successfully opened.
        //  copy the handle, and mark partiallyOpen as FALSE
        //  as we are now fully open.
        //
        *OpenDevice = openDevice;
        partiallyOpen = FALSE;
    }  else
    {
        errorCode = IUsbDevice::Win32FromUsbdStatus(status);
    }

exit_open_device:
    
    //
    //  Done with synchronization
    //
    KeLowerIrql(oldIrql);
    
    //
    //  Partially opened devices
    //  should be closed.
    //
    if(partiallyOpen)
    {
        XID_fCloseDevice(openDevice);
    }

    return errorCode;
}

USBD_STATUS
FASTCALL
XID_fOpenEndpoints(
    IN PXID_OPEN_DEVICE OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    )
/*++
    Routine Description:
        Called from XID_OpenDevice to open the endpoints associated with the
        device.  Opening the endpoints references the XidNode until the endpoints
        are closed.
--*/
{
    
    USBD_STATUS status = USBD_STATUS_SUCCESS;
    PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;

    //
    //  Open the control endpoint
    //
    
    USB_BUILD_OPEN_DEFAULT_ENDPOINT((PURB_OPEN_ENDPOINT)&OpenDevice->Urb);
    status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
    
    //
    //  If the control endpoint is open,
    //  open the interrupt in endpoint.
    //
    if(USBD_SUCCESS(status))
    {
        OpenDevice->ControlEndpointOpen = TRUE;
        USB_BUILD_OPEN_ENDPOINT(
        (PURB_OPEN_ENDPOINT)&OpenDevice->Urb,
        xidNode->EndpointAddressIn,
        USB_ENDPOINT_TYPE_INTERRUPT,
        (USHORT)XID_MAXIMUM_REPORT_SIZE,
        PollingParameters->bInputInterval
        );
        status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
    }

    //
    //  If interrupt-IN endpoint opened, save the handle
    //  and try to open the interrupt out, if there is
    //  one.
    //
    if(USBD_SUCCESS(status))
    {
        OpenDevice->InterruptInEndpointHandle = OpenDevice->Urb.OpenEndpoint.EndpointHandle;
        ASSERT(OpenDevice->InterruptInEndpointHandle);
        if(PollingParameters->fInterruptOut && xidNode->EndpointAddressOut)
        {
            USB_BUILD_OPEN_ENDPOINT(
                (PURB_OPEN_ENDPOINT)&OpenDevice->Urb,
                xidNode->EndpointAddressOut,
                USB_ENDPOINT_TYPE_INTERRUPT,
                (USHORT)XID_MAXIMUM_REPORT_SIZE,
                PollingParameters->bOutputInterval
                );
		    status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
        
            if(USBD_SUCCESS(status))
            {
                OpenDevice->InterruptOutEndpointHandle = 
                        OpenDevice->Urb.OpenEndpoint.EndpointHandle;
                ASSERT(OpenDevice->InterruptOutEndpointHandle);
            }
        }
    }

    //
    //  return the status
    //
    return status;
}


VOID
FASTCALL
XID_fCloseDevice(
    IN PXID_OPEN_DEVICE OpenDevice
    )
/*++
   Routine Description:
        Closes an open or paritally open device.
        Always does the right thing.

        This routine assumes that OpenDevice is valid.
--*/
{
    ASSERT_LESS_THAN_DISPATCH_LEVEL();
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  If we are still attached to 
    //  a xidnode, then we need to close the
    //  endpoints.
    //
    if(OpenDevice->XidNode)
    {
        //
        // Notify keyboard services of device closing.
        //
        #ifdef DEBUG_KEYBOARD
        if((XID_DEVTYPE_KEYBOARD==OpenDevice->Type) && XID_pKeyboardServices)
        {
           XID_pKeyboardServices->pfnClose(OpenDevice);
        }
        #endif DEBUG_KEYBOARD

        //
        //  Setup event to synchronize close
        //
        KEVENT event;
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        OpenDevice->CloseEvent = &event;
        
        //
        //  Mark close pending as true
        //
        OpenDevice->ClosePending = TRUE;

        //
        //  Kick off close endpoint state
        //  machine.
        //
        XID_fCloseEndpoints(OpenDevice);

        //
        //  Wait for close endpoint state machine
        //  to do its job.
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    } else
    {
        KeLowerIrql(oldIrql);
    }

    //
    //  Everything is cleaned up, just free the memory.
    //
    XID_TypeInformationList[OpenDevice->Type].bRemainingHandles++;
    XID_FreeHandle(OpenDevice);
}


VOID
FASTCALL
XID_fCloseEndpoints(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
    Routine Description:
        This routine closes the endpoints associated with an OpenDevice handle.
--*/
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Guard against rentry
    //
    if(OpenDevice->EndpointsPendingClose)
    {
        return; 
    }

    // kill the Alamo DPC timer, if it is running
    #ifdef  ALAMO_RAW_DATA_HACK
    if(OpenDevice->XidNode->AlamoHack) KeCancelTimer(&OpenDevice->AlamoPollTimer);
    #endif  //ALAMO_RAW_DATA_HACK


    OpenDevice->EndpointsPendingClose = TRUE;

    //
    //  Start endpoint state machine.
    //

    XID_CloseEndpointStateMachine(&OpenDevice->CloseUrb, OpenDevice);
}

VOID 
XID_CloseEndpointStateMachine(
    PURB_CLOSE_ENDPOINT CloseUrb,
    PXID_OPEN_DEVICE OpenDevice
    )
{
    
    IUsbDevice *device = OpenDevice->XidNode->Device;

    //
    // If the control endpoint is open
    // build an URB to close it.
    //
    if(OpenDevice->ControlEndpointOpen)
    {
        //
        //  Close the default endpoint
        //
        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
                        CloseUrb,
                        (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
                        (PVOID)OpenDevice
                        );
        OpenDevice->ControlEndpointOpen = FALSE;
    } else if(OpenDevice->InterruptInEndpointHandle)
    //
    //  If the interrupt in endpoint needs to be closed
    //  build an URB to close it.
    //
    {
        USB_BUILD_CLOSE_ENDPOINT(
            CloseUrb,
            OpenDevice->InterruptInEndpointHandle,
            (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
            (PVOID)OpenDevice
            );
        OpenDevice->InterruptInEndpointHandle = NULL;
    } else if(OpenDevice->InterruptOutEndpointHandle)
    //
    //  If the interrupt in endpoint needs to be closed
    //  build an URB to close it.
    //
    {
        USB_BUILD_CLOSE_ENDPOINT(
            CloseUrb,
            OpenDevice->InterruptOutEndpointHandle,
            (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
            (PVOID)OpenDevice
            );
        OpenDevice->InterruptOutEndpointHandle = NULL;
    } else
    //
    //  Everything is closed, handle the reason
    //  we close the endpoints (either pending close
    //  or pending remove).
    //
    {
        PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;
        //
        //  We should only be here if either a close pending
        //  or if a remove is pending.
        //
        ASSERT(OpenDevice->ClosePending || xidNode->PendingRemove);

        //
        //  In either case, we need to sever the xidNode
        //  and the openDevice.
        //
        xidNode->OpenDevice = NULL;
        OpenDevice->XidNode = NULL;

        //
        //  If there is a pending remove,
        //  we need to call remove complete.
        //
        if(xidNode->PendingRemove)
        {
            XID_fRemoveDeviceComplete(xidNode);
        }

        //
        //  If there is a pending close,
        //  signal the close event.
        //
        if(OpenDevice->ClosePending)
        {
            //
            //  Signal the close event
            //
            ASSERT(OpenDevice->CloseEvent);
            KeSetEvent(OpenDevice->CloseEvent, IO_NO_INCREMENT, FALSE);
        }

        return;
    }
   
    //
    //  submit the next request
    //
    device->SubmitRequest((PURB)CloseUrb);
}
   

VOID
XID_NewInterruptData(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    )
/*++
    Routine Description:
        This is the completion routine for new input data.

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        So we can safely process the I/O.  However,
        before resubmitting any I/O requests, we
        should verify that a close or remove is not
        pending.
--*/
{
    ASSERT_DISPATCH_LEVEL();
    
    PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;

    //
    //  If the device has been closed or is pending
    //  remove, there is nothing to do.
    //
    if(OpenDevice->ClosePending || xidNode->PendingRemove)
    {
        return;  
    }

    //
    //  If the URB was completed successfully, then
    //  process the data.
    //
    if(USBD_SUCCESS(Urb->Header.Status))
    {
        //
        //  Debug only check that the device is not returning short packets
        //
        #if DBG
        if( Urb->BulkOrInterruptTransfer.TransferBufferLength < xidNode->bMaxInputReportSize)
        {
            USB_DBG_TRACE_PRINT(("An input device returned a short packet(expected %d, received %d).",
                xidNode->bMaxInputReportSize,
                Urb->BulkOrInterruptTransfer.TransferBufferLength
                ));
        }
        if( Urb->BulkOrInterruptTransfer.TransferBufferLength > xidNode->bMaxInputReportSize)
        {
            USB_DBG_ERROR_PRINT(("Packet came back larger than maximum allowed."));
            Urb->BulkOrInterruptTransfer.TransferBufferLength = xidNode->bMaxInputReportSize;
        }
        #endif

        //
        //  Process the new data
        //
        XID_TypeInformationList[xidNode->Type].pfnProcessNewData(OpenDevice);
        
        OpenDevice->PacketNumber++;
        OpenDevice->OutstandingPoll = 0;
        
        //
        //  Resubmit the URB if autopoll, reset the transfer
        //  length, in case the last transfer came up short.
        //
        Urb->BulkOrInterruptTransfer.TransferBufferLength = xidNode->bMaxInputReportSize;
        
        //
        //  If this is not an auto-poll device, we are done
        //
        if(!OpenDevice->AutoPoll)
        {
            return;
        }
    } else
    {
        //
        //  Print out the error.
        //
        #if DBG
        if(
            (USBD_STATUS_CANCELED != Urb->Header.Status) &&
            (USBD_ISOCH_STATUS_DEV_NOT_RESPONDING != Urb->Header.Status) //99% of the time indicates device is gone
        )
        {
            USB_DBG_WARN_PRINT(("An input device poll failed. Status = 0x%0.8x\n", Urb->Header.Status));
        }
        #endif
        //
        //  Alter the URB so that it clears the endpoint halt.
        //
        USB_BUILD_CLEAR_FEATURE(
                (PURB_CONTROL_TRANSFER)Urb,
                USB_COMMAND_TO_ENDPOINT,
                USB_FEATURE_ENDPOINT_STALL,
                xidNode->EndpointAddressIn,
                (PURB_COMPLETE_PROC)XID_ClearInputStallComplete,
                OpenDevice
                );
    }
    
    //
    //  Resubmit the URB
    //
    xidNode->Device->SubmitRequest(Urb);
}

VOID
XID_ClearInputStallComplete(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    )
/*++
    Routine Description:
        This is the completion routine for sendinf a
        CLEAR_FEATURE(ENDPOINT_HALT).

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        We should check to see if a close or remove is
        pending before trying to finish the endpoint
        reset, or submitting an input URB.
--*/
{
    PXID_DEVICE_NODE    xidNode = OpenDevice->XidNode;
    USBD_STATUS         status;
    
    //
    //  Don't do anything if a remove or close is pending.
    //
    if(xidNode->PendingRemove || OpenDevice->ClosePending)
    {
        return;
    }
    //
    //  If the CLEAR_FEATURE succeeded,
    //  reset the endpoint state, and try to resubmit
    //  the I/O.
    //
    if(USBD_SUCCESS(Urb->Header.Status))
    {
	    //
        //  Build URB to reset the endpoint state
        //
        USB_BUILD_SET_ENDPOINT_STATE( 
            (PURB_GET_SET_ENDPOINT_STATE)Urb,
            OpenDevice->InterruptInEndpointHandle,
            USB_ENDPOINT_STATE_CLEAR_HALT | USB_ENDPOINT_STATE_DATA_TOGGLE_RESET
            );
	    status = xidNode->Device->SubmitRequest(Urb);
        ASSERT(USBD_SUCCESS(status));

        USB_DBG_WARN_PRINT(("Reset endpoint, resume polling.\n"));
	    //
        //  Build URB to resume polling
        //
        #ifdef ALAMO_RAW_DATA_HACK
        if(xidNode->AlamoHack) XID_AlamoStartPoll(OpenDevice);
        else {
        #endif

        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
                    (PURB_BULK_OR_INTERRUPT_TRANSFER)&OpenDevice->Urb,
                    OpenDevice->InterruptInEndpointHandle,
                    OpenDevice->ReportForUrb,
                    xidNode->bMaxInputReportSize,
                    USB_TRANSFER_DIRECTION_IN,
                    (PURB_COMPLETE_PROC)XID_NewInterruptData,
                    (PVOID)OpenDevice,
                    TRUE
                    );
	    xidNode->Device->SubmitRequest(Urb);
        #ifdef ALAMO_RAW_DATA_HACK
        }
        #endif

    }  else
    {
        USB_DBG_WARN_PRINT(("Failed to clear halt. Report device as not responding.  Status = 0x%0.8x\n", Urb->Header.Status));
        xidNode->Device->DeviceNotResponding();
    }
}

void
FASTCALL
XID_ProcessGamepadData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   Processing of gamepad data.  Basically, it copies the data
   from the buffer that is ping-ponged to the hardware, to the one
   that is always available for copying from XInputGetState.

   Then it checks to see if anything changes and hits XAutoPowerDownResetTimer
--*/
{
    XINPUT_GAMEPAD *pGamePad = (XINPUT_GAMEPAD *)OpenDevice->Report;
    if(OpenDevice->Urb.CommonTransfer.TransferBufferLength >= XID_REPORT_HEADER)
    {
        RtlCopyMemory(
          (PVOID)pGamePad,
          (PVOID)(OpenDevice->ReportForUrb+XID_REPORT_HEADER),
          OpenDevice->Urb.ControlTransfer.TransferBufferLength-XID_REPORT_HEADER
          );

        //
        //  XAutoPowerDownResetTimer if necessary, too much jitter the thumbsticks
        //  means we check all the other controls to see if any of them are pressed.
        //
        if(
            pGamePad->wButtons& (XINPUT_GAMEPAD_DPAD_UP|XINPUT_GAMEPAD_DPAD_DOWN|XINPUT_GAMEPAD_DPAD_LEFT|
                                 XINPUT_GAMEPAD_DPAD_RIGHT|XINPUT_GAMEPAD_START|XINPUT_GAMEPAD_BACK)
          )
        {
            XAutoPowerDownResetTimer();
        } else
        {
            for(int i = XINPUT_GAMEPAD_A; i <= XINPUT_GAMEPAD_RIGHT_TRIGGER; i++)
            {
                if(pGamePad->bAnalogButtons[i])
                {
                  XAutoPowerDownResetTimer();
                  break;
                }
            }
        }

    }
}

void
FASTCALL
XID_ProcessIRRemoteData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   IRREM XID processing of new data.  Copies the data
   from the buffer that is ping-ponged to the hardware, 
   then it hits XAutoPowerDownResetTimer.
--*/
{
    RtlCopyMemory(
        (PVOID)OpenDevice->Report,
        (PVOID)(OpenDevice->ReportForUrb+XID_REPORT_HEADER),
        OpenDevice->Urb.ControlTransfer.TransferBufferLength-XID_REPORT_HEADER
        );
    XAutoPowerDownResetTimer();
}

void
FASTCALL
XID_ProcessNewKeyboardData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   Keyboard processing is slightly different.  It doesn't have a XID_REPORT_HEADER
--*/
{
  RtlCopyMemory(OpenDevice->Report, OpenDevice->ReportForUrb, sizeof(XINPUT_KEYBOARD));
  if(XID_pKeyboardServices)
  {
    XID_pKeyboardServices->pfnNewData((PVOID)OpenDevice, (PXINPUT_KEYBOARD)OpenDevice->Report);
    XAutoPowerDownResetTimer();
  }
}

DWORD
FASTCALL
XID_fSendDeviceReport(
        IN      PXID_OPEN_DEVICE           OpenDevice,
        IN      PXINPUT_FEEDBACK_INTERNAL  OutputReport
        )
{
    PVOID               rawOutputBuffer;
    USBD_STATUS         usbStatus;
    PXID_DEVICE_NODE    xidNode = OpenDevice->XidNode;
    KIRQL               oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Check to make sure the device has not been removed
    //
    if(NULL==xidNode || xidNode->PendingRemove)
    {
        OutputReport->dwStatus = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_send_device_report;
    }
    //
    //  If bMaxOutputReportSize is zero, the device doesn't support output.
    //
    if(0 == xidNode->bMaxOutputReportSize)
    {
        OutputReport->dwStatus = ERROR_NOT_SUPPORTED;
        goto exit_send_device_report;
    }

    //
    //  Increase the reference count on the completion event
    //  if there is one.
    //
    if(OutputReport->hEvent)
    {
        NTSTATUS status = ObReferenceObjectByHandle(
                            OutputReport->hEvent,
                            ExEventObjectType,
                            (PHANDLE)&OutputReport->Internal.CompletionEvent
                            );
        //
        //  If the following assertion fails the event handle is invalid.
        //  This does not prevent the I/O, but we cannot set the event.
        //  We assert, and NULL out both the hEvent and the pointer
        //  we would have obtained from ObReferenceObjectByHandle
        //
        //ASSERT(NT_SUCCESS(status));
        if(!NT_SUCCESS(status))
        {
            USB_DBG_ERROR_PRINT(("ERROR: pFeedback->Header.hEvent (0x%0.8x) is invalid.\n"
                                 "hEvent should be NULL or a valid Event handle.\n"
                                 "Event cannot be signaled at completion.\n", OutputReport->hEvent));
            OutputReport->hEvent = NULL;
            OutputReport->Internal.CompletionEvent = NULL;    
        }
    } else
    {
        OutputReport->Internal.CompletionEvent = NULL;
    }

    //
    //  Constrain the size if needed.
    //
    if(xidNode->bMaxOutputReportSize < OutputReport->Internal.bSize)
    {
        OutputReport->Internal.bSize = xidNode->bMaxOutputReportSize;
    }

    //
    //  Legacy devices (notably keyboard) does not have a XID_REPORT_HEADER.
    //
    if(XID_TypeInformationList[xidNode->Type].ulFlags&XID_BSF_NO_OUTPUT_HEADER)
    {
        rawOutputBuffer = (PVOID)(&OutputReport->Internal.bReportId + XID_REPORT_HEADER);
    } else
    //
    //  Otherwise rawBuffer starts at the bReportId of the internal header
    //
    {
        rawOutputBuffer = (PVOID)&OutputReport->Internal.bReportId;
    }

    //
    //  Build the URB  (use the interrupt Out pipe if there is
    //  one, otherwise use the default pipe with SET_REPORT).
    //
    if(OpenDevice->InterruptOutEndpointHandle)
    {
        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
                &OutputReport->Internal.Urb.BulkOrInterruptTransfer,
                OpenDevice->InterruptOutEndpointHandle,
                rawOutputBuffer,
                OutputReport->Internal.bSize,
                USB_TRANSFER_DIRECTION_OUT,
                (PURB_COMPLETE_PROC)XID_OutputComplete,
                (PVOID)OutputReport,
                FALSE
                );
    } else
    {
        USB_BUILD_CONTROL_TRANSFER(
            &OutputReport->Internal.Urb.ControlTransfer,
            NULL,
            rawOutputBuffer,
            OutputReport->Internal.bSize,
            USB_TRANSFER_DIRECTION_OUT,
            (PURB_COMPLETE_PROC)XID_OutputComplete,
            (PVOID)OutputReport,
            FALSE,
            (USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE),
            XID_COMMAND_SET_REPORT,
            0x0200 | OutputReport->Internal.bReportId,
            xidNode->InterfaceNumber,
            (WORD)OutputReport->Internal.bSize
            );
    }

    //
    //  Submit the request
    //
    OutputReport->Internal.OpenDevice = OpenDevice;
    usbStatus = xidNode->Device->SubmitRequest(&OutputReport->Internal.Urb);
    OutputReport->dwStatus = IUsbDevice::Win32FromUsbdStatus(usbStatus);

exit_send_device_report:
    
    KeLowerIrql(oldIrql);
    return OutputReport->dwStatus;
}

VOID
XID_OutputComplete(
    PURB                      Urb,
    PXINPUT_FEEDBACK_INTERNAL  OutputReport
    )
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Check to see if the device has been removed
    //
    PXID_OPEN_DEVICE openDevice = OutputReport->Internal.OpenDevice;
    PXID_DEVICE_NODE xidNode = openDevice->XidNode;

    //
    //  If the device has been removed or closed
    //  set the error to USBD_STATUS_NO_DEVICE
    //
    if(openDevice->ClosePending || xidNode->PendingRemove)
    {
        Urb->Header.Status = USBD_STATUS_NO_DEVICE;
    }
    
    //
    //  If the interrupt-Out endpoint is stalled we have to clear the stall,
    //  prior to copying the status and signalling an event.
    //
    if(
        (Urb->Header.Status == USBD_STATUS_STALL_PID) &&
        (Urb->Header.Function == URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER)
        )
    {
        //
        //  Print out the error.
        //
        USB_DBG_WARN_PRINT(("The interrupt-Out endpoint stalled, reseting.\n", Urb->Header.Status));
        //
        //  Alter the URB so that it clears the endpoint halt.
        //
        USB_BUILD_CLEAR_FEATURE(
            (PURB_CONTROL_TRANSFER)Urb,
            USB_COMMAND_TO_ENDPOINT,
            USB_FEATURE_ENDPOINT_STALL,
            xidNode->EndpointAddressOut,
            (PURB_COMPLETE_PROC)XID_ClearOutputStallComplete,
            OutputReport
            );
        //
        //  Submit the request to clean the stall.
        //
        xidNode->Device->SubmitRequest(Urb);
    } else
    //
    //  If the endpoint is not stalled (or it was a control endpoint which does not need clearing)
    //  go ahead and complete the output.
    //
    {
        XID_fOutputComplete1(Urb, OutputReport);
    }
}

VOID
FASTCALL
XID_fOutputComplete1(
    PURB Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    )
{
    PKEVENT event = OutputReport->Internal.CompletionEvent;

    //
    //  Copy and convert the status.
    //
    OutputReport->dwStatus = IUsbDevice::Win32FromUsbdStatus(Urb->Header.Status);

    //
    //  If the call provided a completion event, set it
    //  and then dereference it.
    //  
    if(event)
    {
        KeSetEvent(event, IO_NO_INCREMENT, FALSE);
        ObDereferenceObject(event);
    }
}


VOID
XID_ClearOutputStallComplete(
    PURB                     Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    )
/*++
    Routine Description:
        This is the completion routine for sendinf a
        CLEAR_FEATURE(ENDPOINT_HALT).

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        We should check to see if a close or remove is
        pending before trying to finish the endpoint
        reset, or submitting an input URB.
--*/
{
    PXID_OPEN_DEVICE    openDevice = OutputReport->Internal.OpenDevice;
    PXID_DEVICE_NODE    xidNode = openDevice->XidNode;
    USBD_STATUS         status = Urb->Header.Status;
    
    //
    //  If the device has been removed or closed
    //  set the error to USBD_STATUS_NO_DEVICE
    //
    if(openDevice->ClosePending || xidNode->PendingRemove)
    {
        Urb->Header.Status = USBD_STATUS_NO_DEVICE;
    } else 
    {
        if(USBD_SUCCESS(status))
        {
            //
            //  Build and submit URB to reset the endpoint state
            //
            USB_BUILD_SET_ENDPOINT_STATE( 
                (PURB_GET_SET_ENDPOINT_STATE)Urb,
                openDevice->InterruptOutEndpointHandle,
                USB_ENDPOINT_STATE_CLEAR_HALT | USB_ENDPOINT_STATE_DATA_TOGGLE_RESET
                );
	        xidNode->Device->SubmitRequest(Urb);
        } else
        {
            USB_DBG_ERROR_PRINT(("Attempt to clear endpoint stall result in status: 0x%0.8x.\n", status));
        }
        Urb->Header.Status = USBD_STATUS_STALL_PID;
    }    
   
    XID_fOutputComplete1(Urb, OutputReport);
}

VOID
XID_SyncComplete(
    PURB /*UnreferencedUrb*/,
    PKEVENT SyncEvent
    )
//
//  Used to make an asyncronous call, synchronous.
//
{
    KeSetEvent(SyncEvent, IO_NO_INCREMENT, FALSE);
}


//****
//****  Legacy Hardware Enumeration (right now the 
//****  Microsoft Natrual Keyboard Pro is the only supported
//****  legacy device).  Use of this device is limited for
//****  use as a development aid.  However, this is a policy
//****  decision, not a technical one.  Basically, we
//****  will always enumerate  a Natural Keyboard Pro,
//****  however several required methods for using it
//****  require lining xdbg.lib, which is not allowed for
//****  shipping titles.
//****  

#define VID_MICROSOFT               0x045E
#define PID_NATURAL_KEYBOARD_PRO    0x001D

VOID
XID_EnumLegacy1(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    Gets the full device descriptor.  The gives us access to the
    VID and PID so we can support a particular device.

  Comment:
    The commented out code below allows the support of any known
    protocol device (i.e. any boot keyboard).  This was scratched
    and replaced with VID\PID detection of the Microsoft
    Natural Keyboard Pro just for support reasons.  The other code
    should work on a wide variety of keyboards.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumLegacy1.\n"));
    
    //
    //  First see if it is a known protocol device. (a.k.a. keyboard or
    //  mouse, but we don't support mouse at this point)
    //
    const USB_INTERFACE_DESCRIPTOR *interfaceDescriptor;
    interfaceDescriptor = XidNode->Device->GetInterfaceDescriptor();
    if(
        (USB_DEVICE_CLASS_HUMAN_INTERFACE == interfaceDescriptor->bInterfaceClass) &&
        (HID_KEYBOARD_PROTOCOL == interfaceDescriptor->bInterfaceProtocol)
    )
    {   
        //
        //  Switch to the boot protcol
        //
        
        USB_BUILD_CONTROL_TRANSFER(
            &XID_Globals.EnumUrb.ControlTransfer,
            NULL,
            NULL,
            0,
            0,
            (PURB_COMPLETE_PROC)XID_EnumKeyboard,
            (PVOID)XidNode,
            TRUE,
            USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
            HID_SET_PROTOCOL,
            HID_BOOT_PROTOCOL,
            XidNode->InterfaceNumber,
            0);

    }
#if NEVER
    //
    //  Check for legacy devices that we support via the VID\PID\FW,
    //  currently there are none, so this if #if NEVER.
    else
    {
        //
        //  Get the full device descriptor.
        //  The core driver never bothers to get
        //  more than the first 8 bytes.
        //
        USB_BUILD_GET_DESCRIPTOR(
            &XID_Globals.EnumUrb.ControlTransfer,
            USB_DEVICE_DESCRIPTOR_TYPE,
            0,
            0,
            (PVOID)&XID_Globals.EnumDeviceDescriptor,
            sizeof(USB_DEVICE_DESCRIPTOR),
            (PURB_COMPLETE_PROC)XID_EnumLegacy2,
            (PVOID)XidNode
            );
    }
#else
    else
    {
        //
        //  The device is not supported, free the node.
        //
        XidNode->Device->SetExtension(NULL);
        XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        XidNode->Device=NULL;
        XidNode->InUse = FALSE;
        XID_Globals.DeviceNodeInUseCount--;
        return;
    }
#endif

    XID_SetEnumWatchdog();
	XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
}

#if NEVER
//
//  This routine process enumeration of devices based on VID\PID, currently
//  we have none, so the routine is #if NEVER
//
VOID
XID_EnumLegacy2(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    Completion routine for XID_EnumLegacy1.  At this point we can check the
    VID PID and decide whether or not to support the device.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumLegacy2.\n"));
    XID_ClearEnumWatchdog();
    
    //
    //  Check for legacy devices that we support
    //

    //
    //  Natural Keyboard Pro Support (NOT NEEDED, it is a standard boot keyboard)
    //  left as an example of what to do.
    //
    if(
        (VID_MICROSOFT == XID_Globals.EnumDeviceDescriptor.idVendor) &&
        (PID_NATURAL_KEYBOARD_PRO == XID_Globals.EnumDeviceDescriptor.idProduct)
    )
    {
        const USB_INTERFACE_DESCRIPTOR *interfaceDescriptor;
        interfaceDescriptor = XidNode->Device->GetInterfaceDescriptor();
        //
        //  Only the keyboard interface of this is device is supported
        //  (it has more than one interface)
        if(
            (USB_DEVICE_CLASS_HUMAN_INTERFACE == interfaceDescriptor->bInterfaceClass) &&
            (HID_KEYBOARD_PROTOCOL == interfaceDescriptor->bInterfaceProtocol)
        )
        {
            //
            //  Switch to the boot protcol
            //
            USB_BUILD_CONTROL_TRANSFER(
                &Urb->ControlTransfer,
                NULL,
                NULL,
                0,
                0,
                (PURB_COMPLETE_PROC)XID_EnumKeyboard,
                (PVOID)XidNode,
                TRUE,
                USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
                HID_SET_PROTOCOL,
                HID_BOOT_PROTOCOL,
                XidNode->InterfaceNumber,
                0);
                XID_SetEnumWatchdog();
	            XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
            //
            //  Keyboard has more enum steps
            //
            return;
        }
    }

    //
    //  IF the device is not supported, free the node.
    //
    XidNode->Device->SetExtension(NULL);
    XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    XidNode->Device=NULL;
    XidNode->InUse = FALSE;
    XID_Globals.DeviceNodeInUseCount--;
}
#endif

VOID
XID_EnumKeyboard(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    After a keyboard is found there are still more steps.  In particular,
    we must switch to the boot protocol.  XID_EnumLegacy2 did that, and this
    is the completion routine.

    Now we must set the idle rate to infinite.  Infinite should be the default
    for boot protocol keyboards, but this is for good measure.
--*/
{
    XID_ClearEnumWatchdog();
    //
    //  Switch the idle rate to infinite
    //
    USB_BUILD_CONTROL_TRANSFER(
        &XID_Globals.EnumUrb.ControlTransfer,
        NULL,
        NULL,
        0,
        0,
        (PURB_COMPLETE_PROC)XID_EnumKeyboardComplete,
        (PVOID)XidNode,
        TRUE,
        USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
        HID_SET_IDLE,
        HID_IDLE_INFINITE,
        XidNode->InterfaceNumber,
        0);
    XID_SetEnumWatchdog();
	XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
}

VOID
XID_EnumKeyboardComplete(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    We are done with enumeration steps for enumerating a keyboard
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumKeyboardComplete.\n"));
    XID_ClearEnumWatchdog();
    XidNode->Type = XID_DEVTYPE_KEYBOARD;
    XidNode->SubType = XINPUT_DEVSUBTYPE_KBD_STANDARD;
    XidNode->bMaxInputReportSize = sizeof(XINPUT_KEYBOARD);
    XidNode->bMaxOutputReportSize = sizeof(XINPUT_KEYBOARD_LEDS);
    XidNode->Device->SetClassSpecificType(XidNode->Type);
    XidNode->Device->AddComplete(USBD_STATUS_SUCCESS);
    XidNode->Ready = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xdcs\xdcs_old.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    XDCS.CPP

Abstract:

    This source file implements the major entry points to the Xbox DVD Code Server
    driver (XDCS).  XDCS is a USB interface based device that contains the DVD playback
    code library.  The code resides in ROM on the device.
    
    Basically, this driver maintains the current version of the library, including: downloading
    the library and saving it to a file, verifying the presence of the dongle, and providing the
    validated library file and version info to the client.  This driver is currently private and
    the only intended client is the XDash application.


    The entire implementation is in this file.

    Client API:

      XGetDvdLibraryInfoPointer

    Entries required by the USB core stack:

      XDCS_Init
      XDCS_AddDevice
      XDCS_RemoveDevice

Environment:

    Xbox USB class driver.

Revision History:
    
    02-22-01 : Mitchell Dernis(mitchd) - created

Implementation and Use Overview:

    1) The driver must be linked explicitly as it is not a publically support device.

    2) XDCS devices are not enumerable by clients.  There is no public device type name.  
    
    3) The first XDCS device to be enumerated (i.e. XDCS_AddDevice is called) is the device used.

    4) During XInitDevices, a configuration file is read from the harddisk (or created if not present)
       with information about the DVD library currently on the harddisk, including: version number, and
       the filename, and length.  This information is read into a global data structure.  Other fields
       indicate whether or not the library has been verified against the device, and the status of
       enumeration, download and verification, etc.

    5) Calling XGetDvdPlaybackLibraryInfo returns a pointer (to be consider read only by the client)
       to the global library information structure.

    6) When ever the persistant fields of the library info change, the file is updated.

    7) The library status goes the through the following stages:
        a) XDCS_STATUS_INIT        - stays in the state for up to 2 seconds after XInitDevices.
        b) XDCS_STATUS_NO_DONGLE   - there is no dongle present.  The user should insert one.
        c) XDCS_STATUS_VERIFYING   - dongle found and the library on the harddisk is being verified against
                                     the code on the device.
        d) XDCS_STATUS_DOWNLOADING - dongle found and is being downloaded (either there is no code on the
                                     harddisk or the version is different).
        e) XDCS_STATUS_ACCEPTED   - dongle found and the code has been verified against the code on the dongle
                                     or it has been newly downloaded.
        f) XDCS_STATUS_REJECTED    - dongle found, BUT the code did not match the code on the harddisk despite
                                     being the same version, and the code could not be successfully downloaded.

    8) There are two progress fields:  percent complete and time remaining.  The percent complete is increments of 
        1%.  The timing remaing is a guess in milliseconds.  Initially the guess is based on the original dongle,
        but it dynamically updates taking into account how much has already been transfered, and how long it has taken.

    9) There is a status change event.  It is has an automatic reset property.  The event is set every time the status
       field is changed.  It is optional.

    10) The filename and code version are used internally at all times, the client should only consider these fields valid
        when the status is XDCS_STATUS_ACCEPTED.

--*/

//*****************************************************************************
// Headers
//*****************************************************************************

// Xbox Kernel Service Headers
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>

// Xbox System Software Headers
#include <xtl.h>

// Useful Debug definitions
#define MODULE_POOL_TAG  'SCDX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("XDCS");

// Xbox USB Class driver header
#include <usb.h>

// XDCS specific header
#include "xdcsp.h"


//*****************************************************************************
// For debugging the download code
//*****************************************************************************
#if DBG
    struct XDCS_STAGE_LOG
    {
        DWORD  dwStage;
        DWORD  dwBufferIndex;
    };
    
    DWORD XDCS_StageLogEntries;
    XDCS_STAGE_LOG XDCS_StageLog[100];
#define XDCS_INIT_STAGE_LOG() (XDCS_StageLogEntries = 0)
#define XDCS_LOG(dwBufferIndex)\
    {\
    XDCS_StageLog[XDCS_StageLogEntries].dwStage = XDCS_Globals.Buffers[dwBufferIndex].dwStage;\
    XDCS_StageLog[XDCS_StageLogEntries].dwBufferIndex = dwBufferIndex;\
    XDCS_StageLogEntries++;\
    }
#else 
    #define XDCS_INIT_STAGE_LOG()
    #define XDCS_LOG(dwBufferIndex)
#endif

//*****************************************************************************
//  Declare XDCS types and class.
//*****************************************************************************
USB_DEVICE_TYPE_TABLE_BEGIN(XDCS_)
USB_DEVICE_TYPE_TABLE_ENTRY(NULL)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION(XDCS_, USB_DEVICE_CLASS_XDCS, 0, 0)
#pragma data_seg(".XPP$ClassXdcs")
USB_CLASS_DECLARATION_POINTER(XDCS_)
#pragma data_seg(".XPP$Data")

//*****************************************************************************
// Declare Globals
//*****************************************************************************
USB_RESOURCE_REQUIREMENTS XDCS_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_DIRECT, 1, 2, 1, 0, 0, XDCS_CONTROL_TD_QUOTA, 0, 0, 0};

XDCS_GLOBALS XDCS_Globals = {0};

// LOCALFUNC is a useful tag so that functions defined at file scope can be
// declared static in release builds (conserves global namespace, and perhaps
// allows better optimization), but non-static in debug for ease of debugging.
#if DBG
#define LOCALFUNC
#else 
#define LOCALFUNC static
#endif

//*****************************************************************************
// Declare Locally Used and Defined methods
//*****************************************************************************
__inline VOID XDCS_ChangeStatus(DWORD dwStatus);
LOCALFUNC VOID FASTCALL XDCS_fCompleteRemove(PXDCS_DEVICE XdcsDevice);
DWORD WINAPI XDCS_WorkThread(LPVOID);
LOCALFUNC BOOL FASTCALL XDCS_fVerifyFile();
LOCALFUNC BOOL FASTCALL XDCS_fDownloadFile();
VOID XDCS_SignalComplete(PURB, PVOID pEvent);
LOCALFUNC VOID FASTCALL XDCS_fCreateBufferEvents();
LOCALFUNC DWORD FASTCALL XDCS_fRandomBlock(DWORD BlockCount);


//*****************************************************************************
// Implementation of API
//*****************************************************************************
PXDCS_DVD_LIBRARY_INFORMATION XGetDvdLibraryInfoPointer()
{
    return &XDCS_Globals.LibraryInfo;
}

//*****************************************************************************
// Implementation of USB Required Entry Points:
//  XDCS_Init,
//  XDCS_AddDevice,
//  XDCS_RemoveDevice
//*****************************************************************************
#pragma code_seg(".XPPCINIT")

EXTERNUSB VOID XDCS_Init(IUsbInit *pUsbInit)
/*++
    Routine Description:

        Called by the USB core stack when XDCS is linked in to the application.
        Initialize our globals, register our driver resource requirements, set
        a timer guess when we first detect devices.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XDCS_Init"));
    
    XDCS_Globals.LibraryInfo.dwStatus = XDCS_STATUS_INIT;
    XDCS_Globals.CurrentDevice = NULL;
    
    //Setup event handle
    XDCS_Globals.LibraryInfo.hStatusChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ASSERT(XDCS_Globals.LibraryInfo.hStatusChangeEvent);

    //Initialize the event to signal our thread.
    KeInitializeEvent(&XDCS_Globals.ThreadEvent, SynchronizationEvent, FALSE);
    
    //Create buffer events
    XDCS_fCreateBufferEvents();

    //CreateThread, we need this to the File I/O work
#if DBG
    HANDLE thread = 
#endif
    CreateThread(NULL, 65536, XDCS_WorkThread, NULL, 0, NULL);
    ASSERT(thread);

    // register resources
    pUsbInit->RegisterResources(&XDCS_gResourceRequirements);

    USB_DBG_EXIT_PRINT(("Exiting XDCS_Init"));
    return;
}
#pragma code_seg(".XPPCODE")

EXTERNUSB VOID XDCS_AddDevice(IN IUsbDevice *Device)
/*++

    Routine Description:
    
      Records that the device is present and relevant info that
      it may need later.  Then completes the add.

      If there is currently no device in use (i.e. backing a
      library that was downloaded from the device or checked
      against the device), then we download the code library or
      check a library already on the harddisk.

    Arguments:
        Device - Interface to USB core stack for device.

    Notes:
        AddDevice routines are always called at DPC level.
--*/
{
    PXDCS_DEVICE xdcsDevice;
    ULONG ulPort;

    USB_DBG_ENTRY_PRINT(("XDCS_AddDevice(Device=0x%0.8x)", Device));
    
    //Get and check the port. (It should only work direct connect).
    ulPort = Device->GetPort();
    if(ulPort >= XDCS_MAX_PORTS)
    {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }
    
    xdcsDevice = &XDCS_Globals.Devices[ulPort];
    
    //This device should not already be marked as connected
    ASSERT(!TEST_FLAG(xdcsDevice->bFlags,XDCS_FLAG_CONNECTED));

    //Mark the device as connected
    SET_FLAG(xdcsDevice->bFlags,XDCS_FLAG_CONNECTED);
    xdcsDevice->bInterfaceNumber = Device->GetInterfaceNumber();
    Device->SetExtension((PVOID)xdcsDevice);
    xdcsDevice->Device = Device;
    
    //Complete the Add - this allows enumeration to continue, it
    //also has a couple of implications.
    // 1) The default endpoint is no longer opened when this returns
    // 2) A remove call can come for this device, as soon as we
    //    return from this routine.  (Not before, as we are at DPC
    //    the whole time.)
    Device->AddComplete(USBD_STATUS_SUCCESS);

    // 
    // If there is not currently a current device, make this
    // the current device.
    //
    if(!XDCS_Globals.CurrentDevice)
    {
        XDCS_Globals.CurrentDevice = xdcsDevice;
        KeSetEvent(&XDCS_Globals.ThreadEvent, IO_NO_INCREMENT, FALSE);
    }

    USB_DBG_EXIT_PRINT(("ExitingXDCS_AddDevice"));
    return;
}

EXTERNUSB VOID
XDCS_RemoveDevice (
    IN IUsbDevice *Device
    )
/*++
    Routine Description:
       
      Records the removal, and completes the remove.
      
      If the status of the DVD code is XDCS_STATUS_ACCEPTED and the device that was removed, is the device
      the code was verified against then the status is changed to XDCS_STATUS_NO_DEVICE.  If other devices
      are present, then verification may take place against another device.

    Arguments:
        Device - Interface to USB core stack for device that is to be
                 removed.
    Notes:
        RemoveDevice routines are always called at DPC level.
--*/
{
    USB_DBG_ENTRY_PRINT(("XDCS_RemoveDevice(Device=0x%0.8x)", Device));
    PXDCS_DEVICE xdcsDevice = (PXDCS_DEVICE) Device->GetExtension();

    //Mark the device as not connected.
    CLEAR_FLAG(xdcsDevice->bFlags,XDCS_FLAG_CONNECTED);

    //If the device is not in use (i.e. currently be accessed by our
    //worker thread, then we are done.  The worker thread will see
    //that the connected flag has been cleared, and will finish the removal.
    if(!TEST_FLAG(xdcsDevice->bFlags,XDCS_FLAG_IN_USE))
    {
       XDCS_fCompleteRemove(xdcsDevice);
    }

    USB_DBG_EXIT_PRINT(("exiting XDCS_RemoveDevice"));
    return;
}


//*****************************************************************************
// Implementation of Local Methods:
//  XDCS_ChangeStatus,
//*****************************************************************************

__inline VOID XDCS_ChangeStatus(DWORD dwStatus)
/*++
  Routine Description:
    Utility function that ensures that the status change event is signaled
    whenever the status is changed.
--*/
{
    XDCS_Globals.LibraryInfo.dwStatus = dwStatus;
    SetEvent(XDCS_Globals.LibraryInfo.hStatusChangeEvent);
}


LOCALFUNC
VOID
FASTCALL
XDCS_fCompleteRemove(
    PXDCS_DEVICE XdcsDevice
    )
/*++
    Routine Description:

      Calls IUsbDevice::RemoveComplete for the device.  All endpoints
      have to be closed (and there can be no outstanding traffic), so
      this routine is called either from XDCS_RemoveDevice (if the
      device was not being used when it was removed_, or it is called
      from the worker thread, when it is done trying to talk to the device.

      After calling remove complete, it checks to see if the removed device
      was the current device (i.e. the code library was downloaded or verified
      from this device).  If it was the current device, the status is changed
      to XDCS_STATUS_NO_DONGLE and a search is done for a new current device.

--*/
{
    //
    // We can complete the removal
    //
    XdcsDevice->Device->SetExtension(NULL);
    XdcsDevice->Device->RemoveComplete();
    XdcsDevice->Device = NULL;
    
    //
    // If the device just removed was the one backing
    // the DVD code library, we must change the status to not connected
    // then we can search for another and try and validate
    // the code library against it (or download a new one from another
    // device).
    //
    if(XDCS_Globals.CurrentDevice == XdcsDevice)
    {
        XDCS_Globals.CurrentDevice = NULL;
        XDCS_ChangeStatus(XDCS_STATUS_NO_DONGLE);
        //
        //Search for a connected XDCS, and reestablish a code library
        //
        for(ULONG index = 0; index < XDCS_MAX_PORTS; index++)
        {
            if(TEST_FLAG(XDCS_Globals.Devices[index].bFlags,XDCS_FLAG_CONNECTED))
            {
                //
                //  We found one, set it as the current device and signal
                //  the thread event to awaken our worker.
                //
                XDCS_Globals.CurrentDevice = &XDCS_Globals.Devices[index];
                KeSetEvent(&XDCS_Globals.ThreadEvent, IO_NO_INCREMENT, FALSE);
              
            }
        }
    }
}

DWORD 
WINAPI
XDCS_WorkThread(LPVOID)
/*++

  Routine Description:

    This routine is a worker thread for the XDCS driver.
    It sleeps until signalled, by XDCS_AddDevice (or in
    some circumstance as a result of XDCS_RemoveDevice).

    When woken up it looks XDCS_Globals.CurrentDevice and
    finds and verifies a Dvd playback code library against
    the ROM, or if necessary downloads the code
    XDCS_Globals.CurrentDevice.  When it is done, it goes
    back to sleep.

--*/
{
    
    XDCS_ROM_INFORMATION      romInfo;
    DWORD                     dwReason;
    LARGE_INTEGER             liWait;
    PLARGE_INTEGER            pInitialWait = &liWait;
    USBD_STATUS               usbdStatus;
    KIRQL                     oldIrql;
    BOOL                      fSuccess;
    ULONG                     ulRetry=0;

    USB_DBG_ENTRY_PRINT(("Entering XDCS_WorkThread"));
    //leave up to 2 seconds in XDCS_STATUS_INIT
    liWait.QuadPart = -10000*1000*2;

    // Thread loops forever and cannot be terminated
    while(1)
    {
        //
        // Wait until signaled to process XDCS device
        //
        dwReason = KeWaitForSingleObject(
                        &XDCS_Globals.ThreadEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        pInitialWait
                        );
        //
        //  The first time through, we may timeout
        //  at which time the library status must
        //  be changed from XDCS_STATUS_INIT to 
        //  XDCS_STATUS_NO_DONGLE
        //
        pInitialWait = NULL;
        if(WAIT_TIMEOUT==dwReason)
        {
          XDCS_ChangeStatus(XDCS_STATUS_NO_DONGLE);
          continue;
        }

        //
        //  Synchronize with XDCS_AddDevice and
        //  XDCS_RemoveDevice
        //
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  If the current device is still connected mark it in use, so that
        //  it doesn't get removed while we are mucking with it.
        //
        if(TEST_FLAG(XDCS_Globals.CurrentDevice->bFlags,XDCS_FLAG_CONNECTED))
        {
            SET_FLAG(XDCS_Globals.CurrentDevice->bFlags,XDCS_FLAG_IN_USE);
        } else
        {
            XDCS_fCompleteRemove(XDCS_Globals.CurrentDevice);
            KeLowerIrql(oldIrql);
            continue;
        }

        //
        //  Open the default endpoint
        //  Open is not allowed to fail, we don't even check
        //
        USB_BUILD_OPEN_DEFAULT_ENDPOINT(&DEFAULT_URB.OpenEndpoint);
        XDCS_Globals.CurrentDevice->Device->SubmitRequest(&DEFAULT_URB);
        
        //
        //  Build the XDCS_REQUEST_GET_ROM_FILE_INFO request
        //  (notice that this is synchronous)
        //
        USB_BUILD_CONTROL_TRANSFER(
            &DEFAULT_URB.ControlTransfer,
            NULL,
            (PVOID)&romInfo,
            sizeof(XDCS_ROM_INFORMATION),
            USB_TRANSFER_DIRECTION_IN,
            NULL,
            NULL,
            FALSE,
            USB_DEVICE_TO_HOST|USB_VENDOR_COMMAND|USB_COMMAND_TO_INTERFACE,
            XDCS_REQUEST_GET_ROM_FILE_INFO,
            0,
            XDCS_Globals.CurrentDevice->bInterfaceNumber,
            sizeof(XDCS_ROM_INFORMATION)
            );

        //
        //  Submit it (must be done at passive level), and the check for errors.
        //
        KeLowerIrql(oldIrql);
        usbdStatus = XDCS_Globals.CurrentDevice->Device->SubmitRequest(&DEFAULT_URB);
        if(USBD_SUCCESS(usbdStatus))
        {
            //
            //  Set the version and filename based on the rom version
            //
            XDCS_Globals.LibraryInfo.bcdVersion = romInfo.bcdCodeVersion;
            XDCS_Globals.LibraryInfo.dwCodeLength = romInfo.dwCodeLength;
            
            
            /*
             * Don't do this!  As per Chris's request we will use only one filename for all versions.
             * This way files don't accumulate when you start plugging in dongles of different versions.
             *
            
            wsprintfA(
                XDCS_Globals.LibraryInfo.szName,
                "y:\\DvdLib_v%x.%0.2x.cab", 
                (ULONG)((romInfo.bcdCodeVersion&0xff00)>>8),
                (ULONG)(romInfo.bcdCodeVersion&0x00ff)
                );
             *
             * If this does get put back, we have to make sure that there is some code, to 
             * manage this files and make sure that not more or two or three ever accumulate.
             *
             */
            RtlZeroMemory(&XDCS_Globals.LibraryInfo.szName, sizeof(XDCS_Globals.LibraryInfo.szName));
            wsprintfA(XDCS_Globals.LibraryInfo.szName, XDCS_DVD_LIB_NAME);

            //
            //  Calculate the blockCount, and the length of the last block.
            //
            XDCS_Globals.dwBlockCount = XDCS_Globals.LibraryInfo.dwCodeLength/XDCS_BLOCK_LENGTH;
            XDCS_Globals.dwLastBlockLength = XDCS_Globals.LibraryInfo.dwCodeLength%XDCS_BLOCK_LENGTH;
            if(XDCS_Globals.dwLastBlockLength)
            {
                XDCS_Globals.dwBlockCount++;
            } else
            {
                XDCS_Globals.dwLastBlockLength = XDCS_BLOCK_LENGTH;
            }

            //
            //  Try to the verify the file (whether or not the file
            //  is there).
            //
            fSuccess = XDCS_fVerifyFile();
            if(!fSuccess)
            {
                //
                //  Since we couldn't verify the file
                //  just try to download it.
                //
                fSuccess = XDCS_fDownloadFile();
            }
        } else
        {
            fSuccess = FALSE;
        }
        //
        //  Build and Submit the close URB
        //
        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
            &DEFAULT_URB.CloseEndpoint,
            NULL,
            NULL
            )
        XDCS_Globals.CurrentDevice->Device->SubmitRequest(&DEFAULT_URB);

        //
        // Synchronize with XDCS_AddDevice and XDCS_RemoveDevice
        // again.
        //
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  Turn off the in use flag
        //
        //
        CLEAR_FLAG(XDCS_Globals.CurrentDevice->bFlags,XDCS_FLAG_IN_USE);
        //Check to see if the device is still connected
        if(TEST_FLAG(XDCS_Globals.CurrentDevice->bFlags,XDCS_FLAG_CONNECTED))
        {
            //
            // The device is connected, but it failed, we need a remedy
            // the simplest thing is to try again.
            //
            if(!fSuccess)
            {
                //
                // If exceeded the try count, report the device as not responding.
                // When the device is removed, prior to being reset, an attempt
                // will be made to try another device if present.
                //
                if(++ulRetry > XDCS_MAX_TRIES)
                {
                    XDCS_Globals.CurrentDevice->Device->DeviceNotResponding();
                    ulRetry = 0;
                } else
                //
                //  The reset was not exceeded, so just set our thread event
                //  so we don't stop at the wait when it loops through again.
                //
                {
                    //Set the event, and going through the loop will 
                    KeSetEvent(&XDCS_Globals.ThreadEvent, IO_NO_INCREMENT, FALSE);
                }
            } else
            {
                //We succeeded, so just 0 out the retry count.
                ulRetry = 0;
            }
        } else
        {
            //
            // The device was removed, while we were try to process it.
            // Whether it succeeded or not remove complete, will handle it.
            //
            XDCS_fCompleteRemove(XDCS_Globals.CurrentDevice);
        }
        KeLowerIrql(oldIrql);
    }
    return 0;
}

LOCALFUNC BOOL FASTCALL XDCS_fVerifyFile()
{
    
    HANDLE hFile;
    BOOL   fResult;
    //
    //  Trying opening the file
    //
    hFile = CreateFile(
        XDCS_Globals.LibraryInfo.szName,    
        GENERIC_READ,                       
        0,                                  
        NULL,                              
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    
    //
    //  If the file doesn't exist, then we fail
    //  (We sure hope it didn't fail for other reasons.)
    if(INVALID_HANDLE_VALUE == hFile)
    {
        return FALSE;
    }
    
    //
    //  Get the size of the file, and check it against
    //  the size we are expecting.
    //
    if(XDCS_Globals.LibraryInfo.dwCodeLength != GetFileSize(hFile, NULL))
    {
        CloseHandle(hFile);
        return FALSE;
    }

    //From here on, assume success, until we fail
    fResult = TRUE;

    //
    //  Switch the status to verifying
    //  
    XDCS_Globals.LibraryInfo.dwPercentComplete = 0;
    XDCS_ChangeStatus(XDCS_STATUS_VERIFYING);

    //
    //  Now go through and check a few random blocks.
    //
    DWORD dwBlockIndex;
    DWORD dwOffset;
    DWORD dwSize, dwBytesRead;

    int  loop;
    for(loop=0; loop<XDCS_NUM_BLOCKS_TO_VERIFY; loop++)
    {
        // Choose a random block
        dwBlockIndex = XDCS_fRandomBlock(XDCS_Globals.dwBlockCount);
        
        //Figure out the offset and size
        dwOffset = dwBlockIndex * XDCS_BLOCK_LENGTH;
        dwSize = (dwBlockIndex == XDCS_Globals.dwBlockCount-1) ?
                                XDCS_Globals.dwLastBlockLength : XDCS_BLOCK_LENGTH;

        //Zero the buffers, so there is no memory of what was read in the past
        RtlZeroMemory(XDCS_Globals.Buffers[0].buffer, dwSize);
        RtlZeroMemory(XDCS_Globals.Buffers[1].buffer, dwSize);

        // Read the file into the first buffer
        SetFilePointer(hFile, dwOffset, NULL, FILE_BEGIN);
        if(ReadFile(hFile, XDCS_Globals.Buffers[0].buffer, dwSize, &dwBytesRead, NULL))
        {
            USBD_STATUS usbdStatus;
            //Read from the ROM into the second buffer.
            USB_BUILD_CONTROL_TRANSFER(
                &DEFAULT_URB.ControlTransfer,
                NULL,
                (PVOID)XDCS_Globals.Buffers[1].buffer,
                dwSize,
                USB_TRANSFER_DIRECTION_IN,
                NULL, //synchronous
                NULL,
                FALSE,
                USB_DEVICE_TO_HOST|USB_VENDOR_COMMAND|USB_COMMAND_TO_INTERFACE,
                XDCS_REQUEST_GET_ROM_FILE_BLOCK,
                (WORD)dwBlockIndex,
                (WORD)XDCS_Globals.CurrentDevice->bInterfaceNumber,
                (WORD)dwSize
                );
            usbdStatus = XDCS_Globals.CurrentDevice->Device->SubmitRequest(&DEFAULT_URB);
            //
            //  If the device read failed, break the loop
            //
            if(USBD_ERROR(usbdStatus))
            {
                fResult = FALSE;
                break;
            }
            //
            //  If a byte compare fails, mark it and break the loop.
            //
            if(dwSize != RtlCompareMemory(XDCS_Globals.Buffers[0].buffer, XDCS_Globals.Buffers[1].buffer, dwSize))
            {
                fResult = FALSE;
                break;
            }
        } else
        //
        //  If the read file failed, just break the loop
        //
        {
            fResult = FALSE;
            break;
        }
        //
        //  Update the percent complete
        //
        XDCS_Globals.LibraryInfo.dwPercentComplete = ((loop+1)*100)/XDCS_NUM_BLOCKS_TO_VERIFY;
    }
    
    //
    //  If we made it this far, we at least managed to open
    //  the file,  so close it now, before we do anything.
    //
    CloseHandle(hFile);
    
    //
    //  If we made to here and fResult is TRUE, then the device is OK,
    //  otherwise it failed somehwere.
    //
    if(fResult)
    {
        XDCS_ChangeStatus(XDCS_STATUS_ACCEPTED);
    } else
    {
        XDCS_ChangeStatus(XDCS_STATUS_REJECTED);
    }

    return fResult;
}

LOCALFUNC BOOL FASTCALL XDCS_fDownloadFile()
/*++
  Routine Description:

    Reads from the device and writes to disk.
--*/
{
    DWORD dwBufferIndex = 0;
    DWORD dwNextBlock = 0;
    DWORD dwWriteBytesCompleted = 0;
    DWORD dwReason;
    HANDLE hFile;
    PXDCS_DOWNLOAD_BUFFER pBuffer;
    BOOL  fDone = FALSE;
    BOOL  fSuccess = TRUE; //assume success, until failure
    DWORD dwOffset;
    DWORD dwSize;
    
    //  Open the file to write
    hFile = CreateFile( 
              XDCS_Globals.LibraryInfo.szName,
              GENERIC_WRITE,
              0,
              NULL,
              CREATE_ALWAYS,
              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN,
              NULL);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        XDCS_ChangeStatus(XDCS_STATUS_REJECTED);
        return FALSE;
    }

    // Use SetFilePointer and SetEndOfFile to presize the file
    SetFilePointer(hFile, XDCS_Globals.LibraryInfo.dwCodeLength, NULL, FILE_BEGIN);
    SetEndOfFile(hFile);
    
    //
    //  Place every buffer in the start state, and signal
    //  all the events.
    //
    for(dwBufferIndex=0; dwBufferIndex < XDCS_BUFFER_COUNT; dwBufferIndex++)
    {
        XDCS_Globals.Buffers[dwBufferIndex].dwStage = XDCS_BUFFER_START;
        SetEvent(XDCS_Globals.BufferEvents[dwBufferIndex]);
    }

    XDCS_INIT_STAGE_LOG();

    //
    //  Switch the status to verifying
    //  
    XDCS_Globals.LibraryInfo.dwPercentComplete = 0;
    XDCS_ChangeStatus(XDCS_STATUS_DOWNLOADING);

    //
    //  Loop until done
    //
    while(!fDone)
    {
        //Wait for any of the buffer events to fire
        dwReason = WaitForMultipleObjects(
                        XDCS_BUFFER_COUNT,
                        XDCS_Globals.BufferEvents,
                        FALSE,
                        200);

        //Check for a timeout error condition
        if(WAIT_TIMEOUT == dwReason)
        {
            USB_DBG_ERROR_PRINT(("XDCS_fDownloadFile: Timeout, suggests a device hang."));
            fSuccess = FALSE;
            break; //break out of the while loop
        }

        //Otherwise it must be one of the events, set the dwBufferIndex
        //based on which event fired.
        dwBufferIndex = dwReason - WAIT_OBJECT_0;
        ASSERT(dwBufferIndex < XDCS_BUFFER_COUNT);
        pBuffer = &XDCS_Globals.Buffers[dwBufferIndex];
        XDCS_LOG(dwBufferIndex);

        // How we handle the event condition depends on which
        // stage the buffer was at, so switch on the stage
        switch(pBuffer->dwStage)
        {
            default:
                ASSERT(FALSE);
                fSuccess = FALSE; //assume something failed
                fDone = TRUE; //break out of the while loop
                break; //break out of the switch
            case XDCS_BUFFER_FILE:
            // We just finished writing to file
              {
                DWORD dwBytesTransferred;
                fSuccess = GetOverlappedResult(
                               hFile,
                               &pBuffer->Overlapped,
                               &dwBytesTransferred,
                               TRUE);
                if(!fSuccess)
                {
                    USB_DBG_ERROR_PRINT(("XDCS_fDownloadFile: GetOverlappedResult failed with %d.", GetLastError()));
                    fDone = TRUE; //leave the while loop
                    break; //leave the switch statement
                }
                
                //
                //  Update bytes written and progress
                //
                dwWriteBytesCompleted += dwBytesTransferred;
                XDCS_Globals.LibraryInfo.dwPercentComplete = 
                    (100*dwWriteBytesCompleted)/XDCS_Globals.LibraryInfo.dwCodeLength;
                //if done, then break out of the switch statement
                if(dwWriteBytesCompleted == XDCS_Globals.LibraryInfo.dwCodeLength)
                {
                    fDone = TRUE;
                    break;
                }
              }
              //fall through to next case by design
            case XDCS_BUFFER_START:
              //Have not started using the buffer yet(this case), or
              //a file write completed and the buffer is free agains
              //(the case above fell through)

              // if there are remaining blocks to
              // process, build the URB and submit it
              if(dwNextBlock < XDCS_Globals.dwBlockCount)
              {
                
                USB_BUILD_CONTROL_TRANSFER(
                    &pBuffer->Urb.ControlTransfer,
                    NULL,
                    pBuffer->buffer,
                    XDCS_BLOCK_LENGTH,
                    USB_TRANSFER_DIRECTION_IN,
                    XDCS_SignalComplete, 
                    (PVOID)XDCS_Globals.BufferEvents[dwBufferIndex],
                    FALSE,
                    USB_DEVICE_TO_HOST|USB_VENDOR_COMMAND|USB_COMMAND_TO_INTERFACE,
                    XDCS_REQUEST_GET_ROM_FILE_BLOCK,
                    (WORD)dwNextBlock,
                    (WORD)XDCS_Globals.CurrentDevice->bInterfaceNumber,
                    (WORD)XDCS_BLOCK_LENGTH
                    );
                dwNextBlock++;
                pBuffer->dwStage = XDCS_BUFFER_DEVICE;
                XDCS_Globals.CurrentDevice->Device->SubmitRequest(&pBuffer->Urb);
              } else
              {
                pBuffer->dwStage = XDCS_BUFFER_DONE;
              }
              break;
            case XDCS_BUFFER_DEVICE:
              //Just completed reading into a buffer, let's write it out
              {
                //Calculate the offset (pulling it out of the original setup packet.
                dwOffset = pBuffer->Urb.ControlTransfer.SetupPacket.wValue * XDCS_BLOCK_LENGTH;
                //Pull the size out of the number of bytes actually read
                dwSize = pBuffer->Urb.ControlTransfer.TransferBufferLength;
                
                //Check the status of the URB
                if(USBD_ERROR(pBuffer->Urb.Header.Status))
                {
                    USB_DBG_ERROR_PRINT(("XDCS_fDownloadFile: Device read failed, with USBD_STATUS 0x%0.8x.",
                            pBuffer->Urb.Header.Status));
                    fSuccess= FALSE;
                    fDone = TRUE;
                    break;
                }
                //Now we are going to write to the OVERLAPPED structure, which effectively
                //destroys the URB.
                pBuffer->Overlapped.Offset = dwOffset;
                pBuffer->Overlapped.OffsetHigh = 0;
                pBuffer->Overlapped.hEvent = XDCS_Globals.BufferEvents[dwBufferIndex];
                pBuffer->dwStage = XDCS_BUFFER_FILE;
                if(!WriteFile(hFile, pBuffer->buffer, dwSize, NULL, &pBuffer->Overlapped))
                {
                    USB_DBG_WARN_PRINT(("XDCS_fDownloadFile: WriteFile failed with error %d.", GetLastError()));
                    fDone = TRUE;
                }
              }
              break;
        };
    }
    // Close the file handle
    CloseHandle(hFile);


    if(fSuccess)
    {
        XDCS_ChangeStatus(XDCS_STATUS_ACCEPTED);
    } else
    {
        XDCS_ChangeStatus(XDCS_STATUS_REJECTED);
    }
    return fSuccess;
}

VOID XDCS_SignalComplete(PURB, PVOID pEvent)
{
    HANDLE hEvent = (HANDLE)pEvent;
    SetEvent(hEvent);
}

LOCALFUNC VOID FASTCALL XDCS_fCreateBufferEvents()
{
    DWORD dwBufferIndex;
    //
    //  Initialize the buffers into their starting state.
    //
    for(dwBufferIndex=0; dwBufferIndex < XDCS_BUFFER_COUNT; dwBufferIndex++)
    {
        XDCS_Globals.BufferEvents[dwBufferIndex] = CreateEvent(NULL, FALSE, FALSE, NULL);
        ASSERT(XDCS_Globals.BufferEvents);
    }
}

LOCALFUNC DWORD FASTCALL XDCS_fRandomBlock(DWORD BlockCount)
/*++
  Routine Description:
    This is a specialized random number generater.  It uses the system time
    as a seed to get a random block number.  It is used by XDCS_fVerifyFile
    to choose the blocks to compare.
--*/
{
    LARGE_INTEGER systemTime;
    static ULONG seed = 0;

    //Get a seed if we do not already have one
    if(0==seed)
    {
        //Start with the system time.  The units are 100's of nanoseconds
        //since some published date.  However, it is only updated on timer
        //ticks that occur about every millisecond.
        KeQuerySystemTime(&systemTime);

        //Divide by 10000 (converting to milliseconds, means every digit is
        //significant.  Casting to long effectively takes the date mod about
        //a month.
        seed = (ULONG)(systemTime.QuadPart/10000); 
    }
    
    //The linear equation below, was copied out of some other code, copied
    //out of a book, etc.  It purportely takes a pretty good random seed
    //and can turn it into a pretty good random sequence.
    seed = 1664525 * seed + 1013904223;
    
    //Taking the mod ought to be OK since the range of our number is 
    //very small compared to the whole range (about 1 millionth)
    return (seed%BlockCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xid\xid.h ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    xid.h

Abstract:

    Structures and functions used through the XID driver.
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    02-22-00 created by Mitchell Dernis (mitchd)

--*/

#ifndef __XID_H__
#define __XID_H__

//-----------------------------------------------
// Byte align all the structures
//-----------------------------------------------
#include <PSHPACK1.H>

//------------------------------------------------------------
// Define pointers to the various types declared in this file.
// This breaks some declaration order dependencies.
//------------------------------------------------------------
typedef struct _XID_TYPE_INFORMATION    *PXID_TYPE_INFORMATION;
typedef struct _XID_DESCRIPTOR          *PXID_DESCRIPTOR;
typedef struct _XID_DEVICE_NODE         *PXID_DEVICE_NODE;
typedef struct _XINPUT_FEEDBACK_HEADER_INTERNAL *PXINPUT_FEEDBACK_HEADER_INTERNAL;
typedef struct _XINPUT_FEEDBACK_INTERNAL *PXINPUT_FEEDBACK_INTERNAL;
typedef struct _XID_OPEN_DEVICE         *PXID_OPEN_DEVICE;
typedef struct _XID_GLOBALS             *PXID_GLOBALS;

//-----------------------------------------------
// Constants for legacy devices - keyboards
//-----------------------------------------------
#define HID_KEYBOARD_PROTOCOL 0x01
#define HID_SET_PROTOCOL      0x0B
#define HID_BOOT_PROTOCOL     0x00
#define HID_SET_IDLE          0x0A
#define HID_IDLE_INFINITE     0x00

//--------------------------------------------------
//  XINPUT_KEYBOARD is not defined in public headers
//  since we ripped out low-level support
//--------------------------------------------------
typedef struct _XINPUT_KEYBOARD
{
    BYTE Modifiers;
    BYTE Reserved;
    BYTE Keys[6];
} XINPUT_KEYBOARD, *PXINPUT_KEYBOARD;
typedef struct _XINPUT_KEYBOARD_LEDS
{
    BYTE LedStates;
} XINPUT_KEYBOARD_LEDS, *PXINPUT_KEYBOARD_LEDS;

//-----------------------------------------------
// Constants defined in the XID specification
//-----------------------------------------------
#define XID_COMMAND_GET_CAPABILITIES    0x01
#define XID_COMMAND_GET_REPORT          0x01
#define XID_COMMAND_SET_REPORT          0x09
#define XID_MAXIMUM_REPORT_SIZE         32
#define XID_DESCRIPTOR_TYPE             0x4200
#define XID_REPORT_TYPE_INPUT           0x01
#define XID_REPORT_TYPE_OUTPUT          0x02
#define XID_IS_INPUT_REPORT(wReportId)  ((wReportId >> 8) == XID_REPORT_TYPE_INPUT)
#define XID_GET_REPORT_ID(wReportId)    (wReportId&0xFF)
#define XID_REPORT_HEADER               0x02 //The Report ID and Size is the header.

//------------------------------------------------
// Private constants related to device types and
// and subtypes.
//------------------------------------------------
#define  XID_DEVTYPE_COUNT                3

//Game Controllers
#define  XID_DEVTYPE_GAMECONTROLLER        0
#define  XID_DEVSUBTYPE_MAX_GAME           1
#define  XID_INPUT_REPORT_ID_MAX_GAME      0
#define  XID_OUTPUT_REPORT_ID_MAX_GAME     0

//Keyboard
#define  XID_DEVTYPE_KEYBOARD              1
#define  XID_DEVSUBTYPE_MAX_KEYBOARD       1
#define  XID_INPUT_REPORT_ID_MAX_KEYBOARD  0
#define  XID_OUTPUT_REPORT_ID_MAX_KEYBOARD 0

//IR Remote
#define  XID_DEVTYPE_IRREMOTE              2
#define  XID_DEVSUBTYPE_MAX_IRREMOTE       1
#define  XID_INPUT_REPORT_ID_MAX_IRREMOTE  0
#define  XID_OUTPUT_REPORT_ID_MAX_IRREMOTE 0

//  Right now we have a device that plugs directly into the box,
//  So it is only physically possible to have two devices per port.
//  If we add a high power device, this should be two.
//  If we add a low power device, this should be three.
//
#define XID_MAX_DEVICE_PER_PORT           1

//-----------------------------------------------------------------------
// Structures for the device information table
//-----------------------------------------------------------------------
typedef void (FASTCALL *PFN_PROCESS_NEWDATA)(PXID_OPEN_DEVICE OpenDevice);

typedef struct _XID_REPORT_TYPE_INFO
{
    BYTE    bCurrentSize;   //Not including bReportId and bSize
    PVOID   pDefaultValues;
} XID_REPORT_TYPE_INFO, *PXID_REPORT_TYPE_INFO;

typedef struct _XID_TYPE_INFORMATION
{
    BYTE                       bRemainingHandles;
    BYTE                       bMaxSubType;
    BYTE                       bMaxInputReportId;
    BYTE                       bMaxOutputReportId;
    PXID_REPORT_TYPE_INFO      pInputReportInfoList;
    PXID_REPORT_TYPE_INFO      pOutputReportInfoList;
    PXINPUT_POLLING_PARAMETERS DefaultPollingParameters;
    PFN_PROCESS_NEWDATA        pfnProcessNewData;
    ULONG                      ulFlags;
} XID_TYPE_INFORMATION;
#define XID_BSF_NO_CAPABILITIES  0x00000001
#define XID_BSF_NO_OUTPUT_HEADER 0x00000002

//----------------------------------------------------------------------
//  Declare the table for the type information.
//----------------------------------------------------------------------
extern XID_TYPE_INFORMATION XID_TypeInformationList[XID_DEVTYPE_COUNT];

//----------------------------------------------------------------------
//  This the XID Descriptor has defined in the XID Specification
//----------------------------------------------------------------------
typedef struct _XID_DESCRIPTOR
{
    UCHAR   bLength;
    UCHAR   bDescriptorType;
    USHORT  bcdXid;
    UCHAR   bType;
    UCHAR   bSubType;
    UCHAR   bMaxInputReportSize;
    UCHAR   bMaxOutputReportSize;
    USHORT  wAlternateProductIds[4];
} XID_DESCRIPTOR; 

//----------------------------------------------------------------------
//  Service Table For Extended Keyboard API
//    In order to separate the extended keyboard API from the core
//    Xbox API, the extended API registers itself with a pointer to
//    this Service Table.
//----------------------------------------------------------------------
typedef void (*PFNKEYBOARD_OPENED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_CLOSED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_REMOVED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_NEWDATA)(HANDLE hDevice, XINPUT_KEYBOARD *pPacket);
typedef struct _XID_KEYBOARD_SERVICES
{
    PFNKEYBOARD_OPENED   pfnOpen;
    PFNKEYBOARD_CLOSED   pfnClose;
    PFNKEYBOARD_REMOVED  pfnRemove;
    PFNKEYBOARD_NEWDATA  pfnNewData;
} XID_KEYBOARD_SERVICES, *PXID_KEYBOARD_SERVICES;
extern PXID_KEYBOARD_SERVICES XID_pKeyboardServices;

//----------------------------------------------------------------------
//  This structure represents a device node.
//----------------------------------------------------------------------
typedef struct _XID_DEVICE_NODE
{
    IUsbDevice              *Device;
       
    UCHAR                   InUse:1;
    UCHAR                   PendingRemove:1;
    UCHAR                   Opened:1;
    UCHAR                   Ready:1;
    UCHAR                   Padding:4;
    UCHAR                   InterfaceNumber;
    UCHAR                   MaxPacketIn;        //MaxPacket is a WORD, but per specification cannot exceed 64.
    UCHAR                   MaxPacketOut;       //MaxPacket is a WORD, but per specification cannot exceed 64.
    UCHAR                   EndpointAddressIn;
    UCHAR                   EndpointAddressOut;
    UCHAR                   Type;
    UCHAR                   SubType;
    UCHAR                   bMaxInputReportSize;
    UCHAR                   bMaxOutputReportSize;
    PXID_OPEN_DEVICE        OpenDevice;
} XID_DEVICE_NODE;
#define XID_INVALID_NODE_INDEX  0xFF

//----------------------------------------------------------------------
//  Structures for output.  These are the internal equivalent
//  of XOUTPUT_HEADER and XOUTPUT_REPORT.
//----------------------------------------------------------------------
typedef struct _XINPUT_FEEDBACK_HEADER_INTERNAL
{
    PXID_OPEN_DEVICE        OpenDevice;
    PKEVENT                 CompletionEvent;        
    URB                     Urb;
    BYTE                    bReportId;
    BYTE                    bSize;
} XINPUT_FEEDBACK_HEADER_INTERNAL;

typedef struct _XINPUT_FEEDBACK_INTERNAL
{
    DWORD                   dwStatus;
    HANDLE                  hEvent;
    XINPUT_FEEDBACK_HEADER_INTERNAL Internal;
} XINPUT_FEEDBACK_INTERNAL;

typedef struct _XID_OPEN_DEVICE
{
    PXID_DEVICE_NODE    XidNode;
    LONG                OutstandingPoll;
    ULONG               PacketNumber;
    PVOID               InterruptInEndpointHandle;
    PVOID               InterruptOutEndpointHandle;
    UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
    UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
    URB                 Urb;
    URB_CLOSE_ENDPOINT  CloseUrb;
    PKEVENT             CloseEvent;
    UCHAR               ClosePending:1;
    UCHAR               ControlEndpointOpen:1;
    UCHAR               EndpointsPendingClose:1;
    UCHAR               AutoPoll:1;
    UCHAR               Pad:4;
    UCHAR               Type;
    PXID_OPEN_DEVICE    NextOpenDevice;
} XID_OPEN_DEVICE;
#include <POPPACK.H>

//------------------------------------------------------------
//  A structure for the global variables.
//  The only exceptions are a few data tables.
//------------------------------------------------------------
typedef struct _XID_GLOBALS
{
    USHORT                  DeviceNodeCount;
    USHORT                  DeviceNodeInUseCount;
    PXID_DEVICE_NODE        DeviceNodes;
    PXID_OPEN_DEVICE        DeviceHandles;
    //
    //  Data used for enumeration
    //
    union
    {
        XID_DESCRIPTOR          EnumXidDescriptor;
        USB_DEVICE_DESCRIPTOR   EnumDeviceDescriptor;
    };
    URB                         EnumUrb;
    UCHAR                       EnumNode;
    KTIMER                      EnumWatchdogTimer;
    KDPC                        EnumWatchdogTimerDpc;
} XID_GLOBALS;
extern XID_GLOBALS XID_Globals;

//--------------------------------------------------------------------------------------
//  Functions called from input.cpp
//--------------------------------------------------------------------------------------
DWORD
FASTCALL
XID_fOpenDevice(
    UCHAR            XidType,
    ULONG            Port,
    PXID_OPEN_DEVICE *OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    );

VOID
FASTCALL
XID_fCloseDevice(
    IN PXID_OPEN_DEVICE OpenDevice
    );


DWORD
FASTCALL
XID_fSendDeviceReport(
        IN      PXID_OPEN_DEVICE           OpenDevice,
        IN      PXINPUT_FEEDBACK_INTERNAL   OutputReport
        );

VOID
XID_SyncComplete(
    PURB /*UnreferencedUrb*/,
    PKEVENT SyncEvent
    );

__inline 
PXID_OPEN_DEVICE 
XID_AllocateHandle()
{
    PXID_OPEN_DEVICE retVal = XID_Globals.DeviceHandles;
    ASSERT(retVal); //if hit we under allocated somehow.
    XID_Globals.DeviceHandles = retVal->NextOpenDevice;
    return retVal;
}

__inline 
VOID
XID_FreeHandle(PXID_OPEN_DEVICE DeviceHandle)
{
    DeviceHandle->NextOpenDevice = XID_Globals.DeviceHandles;
    XID_Globals.DeviceHandles = DeviceHandle;
}

//--------------------------------------------------------------------------------------
//  Type Specific Functions
//--------------------------------------------------------------------------------------
void
FASTCALL
XID_ProcessGamepadData(
    PXID_OPEN_DEVICE OpenDevice
    );

void
FASTCALL
XID_ProcessIRRemoteData(
    PXID_OPEN_DEVICE OpenDevice
    );

void
FASTCALL
XID_ProcessNewKeyboardData(
    PXID_OPEN_DEVICE OpenDevice
    );

#endif  //__XID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xkbd\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xidex\xid.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    xid.cpp

Abstract:
    
    Basic entry point implementation of the XID driver.
    
    
Environment:

    Designed for XBOX.

Notes:

    
    
Revision History:

    02-21-00 created by Mitchell Dernis (mitchd)

--*/
#define XID_IMPLEMENTATION

//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("XID");

//
//  Pull in public usb headers
//
#include <usb.h>
//
//  Pull in xid headers
//
#include "xid.h"

//------------------------------------------------------------------------------
//  Declare XID's global variables.
//------------------------------------------------------------------------------
XID_GLOBALS XID_Globals;

//------------------------------------------------------------------------------
//  Forward declaration of locally defined functions
//------------------------------------------------------------------------------
VOID
XID_WatchdogTimerProc(
    PKDPC,
    PVOID,
    PVOID,
    PVOID
    );

VOID
XID_EnumStage1(
    PURB Urb,
    PXID_DEVICE_NODE XidNode
    );

VOID
FASTCALL
XID_fRemoveDeviceComplete(
    IN PXID_DEVICE_NODE XidNode
    );

PXID_DEVICE_NODE
FASTCALL
XID_fFindNode(
    IN PXID_TYPE_INFORMATION TypeInformation,
    IN ULONG  Port
    );

USBD_STATUS
FASTCALL
XID_fOpenEndpoints(
    PXID_OPEN_DEVICE OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    );

VOID
FASTCALL
XID_fCloseEndpoints(
    PXID_OPEN_DEVICE OpenDevice
    );

VOID 
XID_CloseEndpointStateMachine(
    PURB_CLOSE_ENDPOINT CloseUrb,
    PXID_OPEN_DEVICE OpenDevice
    );

VOID
XID_NewInterruptData(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    );

VOID
XID_ClearInputStallComplete(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    );

VOID
XID_OutputComplete(
    PURB                      Urb,
    PXINPUT_FEEDBACK_INTERNAL  OutputReport
    );

VOID
FASTCALL
XID_fOutputComplete1(
    PURB Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    );

VOID
XID_ClearOutputStallComplete(
    PURB                     Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    );

VOID XID_EnumLegacy1(PURB Urb, PXID_DEVICE_NODE XidNode);
//VOID XID_EnumLegacy2(PURB Urb, PXID_DEVICE_NODE XidNode);
VOID XID_EnumKeyboard(PURB Urb, PXID_DEVICE_NODE XidNode);
VOID XID_EnumKeyboardComplete(PURB Urb, PXID_DEVICE_NODE XidNode);
PXID_KEYBOARD_SERVICES XID_pKeyboardServices = NULL;

//------------------------------------------------------------------------------
//  Declare XID types and class.
//------------------------------------------------------------------------------

// Normally you would use macros for the device type table.
// However, our types are dynamic, so we just want no types,
// during init, we can enumerate our types and then update the tables.
// USBD won't touch this entry until the first device is AddComplete.
#define XID_Types NULL
USB_CLASS_DRIVER_DECLARATION(XID_, XBOX_DEVICE_CLASS_INPUT_DEVICE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(XID_, 1, USB_DEVICE_CLASS_HUMAN_INTERFACE, 0xFF, 0xFF)
#undef XID_Types

#pragma data_seg(".XPP$ClassXID")
USB_CLASS_DECLARATION_POINTER(XID_)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(XID_, 1)
#pragma data_seg(".XPP$Data")

USB_RESOURCE_REQUIREMENTS XID_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_DIRECT, 0, 0, 1, 0, 2, 10, 0, 0, 0};

#define DEVICE_TYPE_STACK_SIZE 20
#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID XID_Init(IUsbInit *UsbInit)
/*++
    Routine Description:
        Called at boot.  Registers with usbpnp.sys.  Intializes
        globals.
--*/
{
    ULONG handleCount = 0;
    ULONG index;
    
    PXPP_DEVICE_TYPE  devicesTypes[DEVICE_TYPE_STACK_SIZE];
    BOOL fUseDefaultCount;
    PXID_TYPE_INFORMATION *ppTypeInformation;
    DWORD dwTypeIndex = 0;
    
    //
    //  Verify that XOUTPUT_SIZE_OF_INTERNAL_HEADER is defined correctly
    //  in input.h
    //
    C_ASSERT(sizeof(XINPUT_FEEDBACK_HEADER_INTERNAL) == XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE);

    //Sentry to protect against double init.  This happens because we support XID and HID
    //class as the interface class.  This support is here to stay.
    static BOOL fInitialized = FALSE;
    if(fInitialized) return;
    fInitialized = TRUE;

    //
    //  Figure out how many nodes we need
    //
    XID_Globals.DeviceNodeCount = XGetPortCount()*XID_MAX_DEVICE_PER_PORT;

    //
    //  Walk the Device Type Table (and properly register each type)
    //
    fUseDefaultCount = UsbInit->UseDefaultCount();
    ppTypeInformation = (PXID_TYPE_INFORMATION *)((&XID_BeginTypeDescriptionTable)+1);
    while( (ULONG_PTR)ppTypeInformation < (ULONG_PTR)&XID_EndTypeDescriptionTable )
    {
        if(*ppTypeInformation)
        {
            // Recorder the XPP type in the temporary table.
            ASSERT(dwTypeIndex < DEVICE_TYPE_STACK_SIZE);
            devicesTypes[dwTypeIndex++] = (*ppTypeInformation)->XppType;

            // Count how many  handles we need, and record the user's
            // XInitDevices choice for count
            if(!fUseDefaultCount)
            {
                (*ppTypeInformation)->bRemainingHandles = 
                    UsbInit->GetMaxDeviceTypeCount((*ppTypeInformation)->XppType);
                RIP_ON_NOT_TRUE_WITH_MESSAGE(
                    (*ppTypeInformation)->bRemainingHandles <= XGetPortCount(),
                    "XInitDevices: requested more XDEVICE_TYPE_GAMEPAD than available ports.");
            }
            handleCount += (*ppTypeInformation)->bRemainingHandles;
        }
        ppTypeInformation++;
    }
    
    //
    //  In any case, we don't need more handles than we have device nodes.
    //
    if(handleCount > XID_Globals.DeviceNodeCount)
    {
        handleCount = XID_Globals.DeviceNodeCount;
    }

    //
    //  Allocate a block for the device type table, device nodes and handles
    //  
    ULONG allocSize = sizeof(PXPP_DEVICE_TYPE)*dwTypeIndex +
                      sizeof(XID_DEVICE_NODE)*XID_Globals.DeviceNodeCount +
                      sizeof(XID_OPEN_DEVICE)*handleCount;
    ULONG_PTR memory = (ULONG_PTR) RTL_ALLOCATE_HEAP(allocSize);
    ASSERT(memory);

    //
    //  Fix our device type table
    //
    XID_Description.DeviceTypeCount = dwTypeIndex;
    XID_Description.DeviceTypes = (PXPP_DEVICE_TYPE *)memory;
    XID_1Description.DeviceTypeCount = dwTypeIndex;  //The duplicate entry, for HID
    XID_1Description.DeviceTypes = (PXPP_DEVICE_TYPE *)memory;
    memory += (sizeof(PXPP_DEVICE_TYPE)*dwTypeIndex);
    memcpy(XID_Description.DeviceTypes, devicesTypes, sizeof(PXPP_DEVICE_TYPE)*dwTypeIndex);
    
    
    //
    //  Create a free list of handles
    //
    XID_Globals.DeviceHandles = NULL;
    PXID_OPEN_DEVICE openDevices = (PXID_OPEN_DEVICE) memory;
    for(index=0; index < handleCount; index++)
    {
        XID_FreeHandle(openDevices++);
    }

    //
    //  Initialize the open device nodes
    //
    XID_Globals.DeviceNodes = (PXID_DEVICE_NODE)openDevices;
    XID_Globals.DeviceNodeInUseCount = 0;
    for(index = 0; index < XID_Globals.DeviceNodeCount; index++)
    {
        XID_Globals.DeviceNodes[index].InUse = FALSE;
    }

    //
    //  Register our resources
    //
    XID_gResourceRequirements.MaxDevices = handleCount;
    UsbInit->RegisterResources(&XID_gResourceRequirements);

    //
    //  Initialize other globals.
    //
    KeInitializeTimer(&XID_Globals.EnumWatchdogTimer);
	return;
}
#pragma code_seg(".XPPCODE")

__inline void XID_SetEnumWatchdog()
/*++
    Routine Description:
        Called to start a 5 second watchdog timer on transfers
        during device enumeration.
--*/
{
    LARGE_INTEGER wait;
    wait.QuadPart = -50000000;
    KeSetTimer(&XID_Globals.EnumWatchdogTimer,wait,&XID_Globals.EnumWatchdogTimerDpc);
}

__inline void XID_ClearEnumWatchdog()
/*++
    Routine Description:
        Called to cancel a 5 second watchdog timer when a transfer during
        enumeration completes.
--*/
{
    KeCancelTimer(&XID_Globals.EnumWatchdogTimer);
}

VOID XID_WatchdogTimerProc(PKDPC, PVOID pvDevice, PVOID, PVOID)
/*++
    Routine Description:
        DPC routine called if a 5 second watchdog timer expires protecting
        asynchronous transfers during enumeration.  The routine forces completion
        of the URB by canceling it.  This will cause enumeration to fail,
        but avoids hanging USB device enumeration system wide.
--*/
{
    IUsbDevice *device = (IUsbDevice *)pvDevice;
    USB_DBG_ERROR_PRINT(("Enumeration Watchdog Timer has expired.\n"));
    device->CancelRequest(&XID_Globals.EnumUrb);
}

EXTERNUSB VOID
XID_AddDevice(
    IN IUsbDevice *Device
    )
/*++
    Routine Description:
        This routine is registered as the AddDevice routine for new XID devices.
        It performs the following tasks:
            1) Allocates a XidNode from the static pool of nodes.
            2) Begins the XID enumeration provcess.
        Enumeration is continued in XID_EnumStage1.
--*/
{
    UCHAR                          nodeIndex = 0;
    PXID_DEVICE_NODE               xidNode;
    const USB_ENDPOINT_DESCRIPTOR *endpointDescriptor;
	        
    USB_DBG_ENTRY_PRINT(("Entering XID_AddDevice.\n"));
    if(XID_Globals.DeviceNodeInUseCount < XID_Globals.DeviceNodeCount)
    {
        //
        //  Find a free node, and claim it.
        //
        while(XID_Globals.DeviceNodes[nodeIndex].InUse) nodeIndex++;
        XID_Globals.DeviceNodeInUseCount++;
        XID_Globals.EnumNode = nodeIndex;
        xidNode = XID_Globals.DeviceNodes + nodeIndex;
		Device->SetExtension((PVOID)xidNode);
		xidNode->Device = Device;

        //
        //  Initialize what we can about the device.
        //
        xidNode->InUse = TRUE;
        xidNode->Ready = FALSE;
        xidNode->PendingRemove = FALSE;
        xidNode->Opened = FALSE;
        xidNode->InterfaceNumber = Device->GetInterfaceNumber();
        xidNode->OpenDevice = NULL;
        
    	//
		//	Get the interrupt-in endpoint descriptor  (NOT OPTIONAL).
		//
		endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_INTERRUPT, TRUE, 0);
		ASSERT(endpointDescriptor);
        xidNode->EndpointAddressIn = endpointDescriptor->bEndpointAddress;
        xidNode->MaxPacketIn = (UCHAR)endpointDescriptor->wMaxPacketSize;
		
		//
		//	Get the interrupt-out endpoint (OPTIONAL)
		//
		endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_INTERRUPT, FALSE, 0);
		if(endpointDescriptor)
		{
			xidNode->EndpointAddressOut = endpointDescriptor->bEndpointAddress;
			xidNode->MaxPacketOut = (UCHAR)endpointDescriptor->wMaxPacketSize;
		} else
		{
            xidNode->EndpointAddressOut = 0;
			xidNode->MaxPacketOut = 0;
		}
        //
        //  Get XID Descriptor
        //
        USB_BUILD_CONTROL_TRANSFER(
            (PURB_CONTROL_TRANSFER)&XID_Globals.EnumUrb,
            NULL, //Default endpoint
            (PVOID)&XID_Globals.EnumDeviceDescriptor,
            sizeof(XID_DESCRIPTOR),
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_EnumStage1,
            (PVOID)xidNode,
            TRUE,
            (USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE),
            USB_REQUEST_GET_DESCRIPTOR,
            XID_DESCRIPTOR_TYPE,
            xidNode->InterfaceNumber,
            sizeof(XID_DESCRIPTOR)
            );
        //
        //  Reinitialize the watchdog DPC, so that the context is our device
        //
        KeInitializeDpc(&XID_Globals.EnumWatchdogTimerDpc, XID_WatchdogTimerProc, (PVOID)Device);
        XID_SetEnumWatchdog();
        Device->SubmitRequest(&XID_Globals.EnumUrb);
    }
    else
    {
        //
        //  Out of nodes so we cannot support the device
        //  (allow retry)
        //
        ASSERT(FALSE);
        Device->AddComplete(USBD_STATUS_NO_MEMORY);
    }
    USB_DBG_EXIT_PRINT(("Exiting XID_AddDevice.\n"));
}

VOID
XID_EnumStage1(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
    Routine Description:
        Completion routine for obtaining the XID descriptor started
        in AddDevice.
        
        If retriving the XID_DESCRIPTOR failed,
--*/
{
    XID_ClearEnumWatchdog();
    //
    //  Getting the XID Descriptor may have failed.  This probably
    //  means it is a legacy device.
    //
    if(USBD_ERROR(Urb->Header.Status))
    {
        USB_DBG_EXIT_PRINT(("Couldn't get XID descriptor, could be a HID keyboard.\n"));
        XID_EnumLegacy1(Urb, XidNode);
        return;
    }

    //
    //  Copy the necessary info out of the Xid Descriptor
    //
    XidNode->TypeInformation = GetTypeInformation(XID_Globals.EnumXidDescriptor.bType, &XidNode->TypeIndex);
    XidNode->SubType = XID_Globals.EnumXidDescriptor.bSubType;
    XidNode->bMaxInputReportSize = XID_Globals.EnumXidDescriptor.bMaxInputReportSize;
    XidNode->bMaxOutputReportSize = XID_Globals.EnumXidDescriptor.bMaxOutputReportSize;
    
    //
    //  Check a number of items to determine if we can support the device.
    //      1) The type must be one known at compile time
    //      2) The report size must be at least as large as the XID_REPORT_HEADER.
    //      3) The maximum report size must not be larger than our buffer (XID_MAXIMUM_REPORT_SIZE)
    //         this is a limit on the extensibility of XID.
    //      4) For performance and resource management reasons we enforce that
    //         the entire report fit in a single interrupt-IN packet (there is
    //         no such requirement on the control pipe).
    //      5) Same for output, but only if interrupt OUT is supported.
    //
    if(
        (!XidNode->TypeInformation) ||
        (XID_REPORT_HEADER > XID_Globals.EnumXidDescriptor.bMaxInputReportSize) ||
        (XID_MAXIMUM_REPORT_SIZE < XID_Globals.EnumXidDescriptor.bMaxInputReportSize) ||
        (XidNode->bMaxInputReportSize > XidNode->MaxPacketIn) ||
        (XidNode->EndpointAddressOut && (XidNode->bMaxOutputReportSize > XidNode->MaxPacketOut))
    )
    {
        USB_DBG_WARN_PRINT(("Unsupported XID Device"));
        XidNode->Device->SetExtension(NULL);
        XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    	XidNode->Device=NULL;
        XidNode->InUse = FALSE;
        XID_Globals.DeviceNodeInUseCount--;
        return;
    }

    //
    //  Set the class specific type and call AddComplete.
    //

    XidNode->Device->SetClassSpecificType(XidNode->TypeIndex);
    XidNode->Device->AddComplete(USBD_STATUS_SUCCESS);
    XidNode->Ready = TRUE;
}

EXTERNUSB VOID
XID_RemoveDevice(
    IUsbDevice *Device
    )
/*++
    Routine Description:
        Called by usbd when a device is removed.  It kicks off out
        remove sequence.
--*/
{
    PXID_DEVICE_NODE xidNode = (PXID_DEVICE_NODE)Device->GetExtension();
    ASSERT(NULL != xidNode);
    
	ASSERT_DISPATCH_LEVEL();
    //
    //  Mark the Node remove pending.
    //
    xidNode->PendingRemove = TRUE;
    //
    //  If there is an open handle
    //  kick off a close.
    //
    if(xidNode->OpenDevice)
    {
        //
        // Notify keyboard services of device removal.
        //
        #ifdef DEBUG_KEYBOARD
        if((XDEVICE_TYPE_DEBUG_KEYBOARD==xidNode->TypeInformation->XppType) && XID_pKeyboardServices)
        {
          XID_pKeyboardServices->pfnRemove(xidNode->OpenDevice);
        }
        #endif DEBUG_KEYBOARD
        XID_fCloseEndpoints(xidNode->OpenDevice);
    } else
    //
    //  Otherwise, we can wrap up the remove.
    //
    {
        XID_fRemoveDeviceComplete(xidNode);        
    }
}

VOID
FASTCALL
XID_fRemoveDeviceComplete(
    IN PXID_DEVICE_NODE XidNode
    )
/*++
    Routine Description:
        This routine is called by XID_DereferenceNode, when
        the reference count on a XID node goes to zero.
        At that time, it is certain that all open endpoints
        are closed, and all outstanding I/O is complete.
--*/
{
    ASSERT_DISPATCH_LEVEL();
    //
    //  We are really done
    //
    USB_DBG_TRACE_PRINT(("Freeing node(0x%0.8x) nodeIndex = %d\n", XidNode, XidNode - XID_Globals.DeviceNodes));
    ASSERT(XidNode->PendingRemove);
	XidNode->Device->SetExtension(NULL);
	XidNode->Device->RemoveComplete();
	XidNode->Device=NULL;
    XidNode->InUse = FALSE;
    XID_Globals.DeviceNodeInUseCount--;
    return;
}

PXID_DEVICE_NODE
FASTCALL
XID_fFindNode(
    IN PXID_TYPE_INFORMATION TypeInformation,
    IN ULONG  Port
    )
/*++
    Routine Description:
        Finds a XID node that corresponds to the type and port (port includes port and slot).
        Will only return nodes that are ready to be open.
    Return Value:
        If a suitable node is found, it is returned.  Otherwise, NULL is returned.
    Environement:
        Assumes DISPATCH_LEVEL.
--*/
{
    UCHAR xidNodeIndex;
    PXID_DEVICE_NODE xidNode = NULL;
    //
    //  Brute force search of all the nodes.
    //
    for(xidNodeIndex = 0; xidNodeIndex < XID_Globals.DeviceNodeCount; xidNodeIndex++)
    {
        if(
            XID_Globals.DeviceNodes[xidNodeIndex].InUse &&
            (XID_Globals.DeviceNodes[xidNodeIndex].Device->GetPort() == Port) &&
            (XID_Globals.DeviceNodes[xidNodeIndex].TypeInformation == TypeInformation) &&
            XID_Globals.DeviceNodes[xidNodeIndex].Ready &&
            !XID_Globals.DeviceNodes[xidNodeIndex].PendingRemove
        ){
            xidNode =  XID_Globals.DeviceNodes + xidNodeIndex;
        }
    }
    return xidNode;
}

DWORD
FASTCALL
XID_fOpenDevice(
    PXID_TYPE_INFORMATION TypeInformation,
    ULONG                 Port,
    PXID_OPEN_DEVICE      *OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    )
/*++
    Given a XidTy creates an OpenDevice,
    initializes the OpenDevice and opens
    the endpoints so the device can be used.
--*/
{
    
    USBD_STATUS         status;
    PXID_OPEN_DEVICE    openDevice;
    PXID_DEVICE_NODE    xidNode;
    KIRQL               oldIrql;
    DWORD               errorCode = ERROR_SUCCESS;
    BOOL                partiallyOpen = FALSE;

    //
    // By default we want to return NULL.
    //
    *OpenDevice = NULL;

    //
    //  Must be done at high Irql
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Find the node
    //
    xidNode = XID_fFindNode(TypeInformation, Port);
    if(!xidNode)
    {
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_open_device;
    }

    //
    //  Make sure that it is not already open
    //
    if(xidNode->OpenDevice)
    {
        errorCode = ERROR_SHARING_VIOLATION;
        goto exit_open_device;
    }

    
    if(0==TypeInformation->bRemainingHandles)
    {
        errorCode = ERROR_OUTOFMEMORY;
        goto exit_open_device;        
    }
    
    //
    //  Allocate memory for the device handle
    //
    
    TypeInformation->bRemainingHandles--;
    openDevice = XID_AllocateHandle();
    
    //
    //  Initialize the basic stuff
    //
    RtlZeroMemory(openDevice, sizeof(XID_OPEN_DEVICE));
    openDevice->XidNode = xidNode;
    openDevice->TypeInformation = TypeInformation;
    openDevice->AutoPoll = PollingParameters->fAutoPoll ? TRUE : FALSE;
    
    //
    //  Tie the xidNode to our handle.
    //
    xidNode->OpenDevice = openDevice;

    //
    //  Any failure after here, requires closing the device.
    //
    partiallyOpen = TRUE;

    //
    //  Open the endpoints
    //

    status = XID_fOpenEndpoints(openDevice, PollingParameters);

    //
    //  If the endpoints were successfully opened
    //  then setup the initial state.
    //
    if(USBD_SUCCESS(status))
    {
        //
        //  Initialize the Report and the Report for URB
        //  with the default values;
        //
        RtlCopyMemory(
            (PVOID)(openDevice->ReportForUrb+XID_REPORT_HEADER),
            TypeInformation->pInputReportInfoList[0].pDefaultValues,
            TypeInformation->pInputReportInfoList[0].bCurrentSize
            );
        RtlCopyMemory(
            (PVOID)openDevice->Report,
            (PVOID)(openDevice->ReportForUrb+XID_REPORT_HEADER),
            sizeof(openDevice->Report)
            );

        //
        //  Initialize an event for synchronization
        //
        KEVENT   event;
        KeInitializeEvent(&event, SynchronizationEvent, FALSE);
    
        //
        //  Build a control transfer
        //
        WORD wReportTypeAndId = 0x0100;
        ULONG ulBufferSize = xidNode->bMaxInputReportSize;
        USB_BUILD_CONTROL_TRANSFER(
            &openDevice->Urb.ControlTransfer,
            NULL, //Default endpoint
            openDevice->ReportForUrb,
            ulBufferSize,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_SyncComplete, //do it synchronously
            &event,  //the context is the event.
            TRUE,
            (USB_DEVICE_TO_HOST | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE),
            XID_COMMAND_GET_REPORT,
            wReportTypeAndId, //Input report 0
            xidNode->InterfaceNumber,
            ulBufferSize
            );

        //
        //  Submit the request
        //
        xidNode->Device->SubmitRequest(&openDevice->Urb);
    
        //
        //  Lower IRQL, and wait for transfer to complete.
        //  Then restore Irql to DPC level
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  During the transfer the device may have been removed,
        //  if so we should check to make sure that the device is
        //  still with us.  There are two cases here: the device is
        //  totally gone, the device is still pending remove.
        //
    
        if(NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_open_device;
        } 

        //
        //  Process the GET_REPORT results, if it succeeded
        //
        if(USBD_SUCCESS(openDevice->Urb.Header.Status))
        {
            TypeInformation->pfnProcessNewData(openDevice);
        } 
#if DBG
        else
        //
        // Issue warning if GET_REPORT failed.
        //
	    { 
           if(USBD_STATUS_STALL_PID == openDevice->Urb.Header.Status)
           {
		       USB_DBG_WARN_PRINT(("Device in port %d (0 based) does not support GET_REPORT\n", Port));
           }
        }
#endif

        //
        // Notify keyboard services of new open device.
        //
        if((XDEVICE_TYPE_DEBUG_KEYBOARD==TypeInformation->XppType) && XID_pKeyboardServices)
        {
          XID_pKeyboardServices->pfnOpen(openDevice);
        }

        //
        //  Prepare the URB for the interrupt-in endpoint.
        //
        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
            (PURB_BULK_OR_INTERRUPT_TRANSFER)&openDevice->Urb,
            openDevice->InterruptInEndpointHandle,
            openDevice->ReportForUrb,
            xidNode->bMaxInputReportSize,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)XID_NewInterruptData,
            (PVOID)openDevice,
            TRUE
            );

        //
        //  If autopoll is set, start polling
        //
        if(openDevice->AutoPoll)
        {
          xidNode->Device->SubmitRequest(&openDevice->Urb);
        }

        
        //
        //  If we are here, the device was successfully opened.
        //  copy the handle, and mark partiallyOpen as FALSE
        //  as we are now fully open.
        //
        *OpenDevice = openDevice;
        partiallyOpen = FALSE;
    }  else
    {
        errorCode = IUsbDevice::Win32FromUsbdStatus(status);
    }

exit_open_device:
    
    //
    //  Done with synchronization
    //
    KeLowerIrql(oldIrql);
    
    //
    //  Partially opened devices
    //  should be closed.
    //
    if(partiallyOpen)
    {
        XID_fCloseDevice(openDevice);
    }

    return errorCode;
}

USBD_STATUS
FASTCALL
XID_fOpenEndpoints(
    IN PXID_OPEN_DEVICE OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    )
/*++
    Routine Description:
        Called from XID_OpenDevice to open the endpoints associated with the
        device.  Opening the endpoints references the XidNode until the endpoints
        are closed.
--*/
{
    
    USBD_STATUS status = USBD_STATUS_SUCCESS;
    PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;

    //
    //  Open the control endpoint
    //
    
    USB_BUILD_OPEN_DEFAULT_ENDPOINT((PURB_OPEN_ENDPOINT)&OpenDevice->Urb);
    status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
    
    //
    //  If the control endpoint is open,
    //  open the interrupt in endpoint.
    //
    if(USBD_SUCCESS(status))
    {
        OpenDevice->ControlEndpointOpen = TRUE;
        USB_BUILD_OPEN_ENDPOINT(
        (PURB_OPEN_ENDPOINT)&OpenDevice->Urb,
        xidNode->EndpointAddressIn,
        USB_ENDPOINT_TYPE_INTERRUPT,
        (USHORT)XID_MAXIMUM_REPORT_SIZE,
        PollingParameters->bInputInterval
        );
        status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
    }

    //
    //  If interrupt-IN endpoint opened, save the handle
    //  and try to open the interrupt out, if there is
    //  one.
    //
    if(USBD_SUCCESS(status))
    {
        OpenDevice->InterruptInEndpointHandle = OpenDevice->Urb.OpenEndpoint.EndpointHandle;
        ASSERT(OpenDevice->InterruptInEndpointHandle);
        if(PollingParameters->fInterruptOut && xidNode->EndpointAddressOut)
        {
            USB_BUILD_OPEN_ENDPOINT(
                (PURB_OPEN_ENDPOINT)&OpenDevice->Urb,
                xidNode->EndpointAddressOut,
                USB_ENDPOINT_TYPE_INTERRUPT,
                (USHORT)XID_MAXIMUM_REPORT_SIZE,
                PollingParameters->bOutputInterval
                );
		    status = xidNode->Device->SubmitRequest(&OpenDevice->Urb);
        
            if(USBD_SUCCESS(status))
            {
                OpenDevice->InterruptOutEndpointHandle = 
                        OpenDevice->Urb.OpenEndpoint.EndpointHandle;
                ASSERT(OpenDevice->InterruptOutEndpointHandle);
            }
        }
    }

    //
    //  return the status
    //
    return status;
}


VOID
FASTCALL
XID_fCloseDevice(
    IN PXID_OPEN_DEVICE OpenDevice
    )
/*++
   Routine Description:
        Closes an open or paritally open device.
        Always does the right thing.

        This routine assumes that OpenDevice is valid.
--*/
{
    ASSERT_LESS_THAN_DISPATCH_LEVEL();
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  If we are still attached to 
    //  a xidnode, then we need to close the
    //  endpoints.
    //
    if(OpenDevice->XidNode)
    {
        //
        // Notify keyboard services of device closing.
        //
        #ifdef DEBUG_KEYBOARD
        
        if((XDEVICE_TYPE_DEBUG_KEYBOARD==OpenDevice->TypeInformation->XppType) && XID_pKeyboardServices)
        {
           XID_pKeyboardServices->pfnClose(OpenDevice);
        }
        #endif DEBUG_KEYBOARD

        //
        //  Setup event to synchronize close
        //
        KEVENT event;
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        OpenDevice->CloseEvent = &event;
        
        //
        //  Mark close pending as true
        //
        OpenDevice->ClosePending = TRUE;

        //
        //  Kick off close endpoint state
        //  machine.
        //
        XID_fCloseEndpoints(OpenDevice);

        //
        //  Wait for close endpoint state machine
        //  to do its job.
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    } else
    {
        KeLowerIrql(oldIrql);
    }

    //
    //  Everything is cleaned up, just free the memory.
    //
    OpenDevice->TypeInformation->bRemainingHandles++;
    XID_FreeHandle(OpenDevice);
}


VOID
FASTCALL
XID_fCloseEndpoints(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
    Routine Description:
        This routine closes the endpoints associated with an OpenDevice handle.
--*/
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Guard against rentry
    //
    if(OpenDevice->EndpointsPendingClose)
    {
        return; 
    }

    // kill the Alamo DPC timer, if it is running
    #ifdef  ALAMO_RAW_DATA_HACK
    if(OpenDevice->XidNode->AlamoHack) KeCancelTimer(&OpenDevice->AlamoPollTimer);
    #endif  //ALAMO_RAW_DATA_HACK


    OpenDevice->EndpointsPendingClose = TRUE;

    //
    //  Start endpoint state machine.
    //

    XID_CloseEndpointStateMachine(&OpenDevice->CloseUrb, OpenDevice);
}

VOID 
XID_CloseEndpointStateMachine(
    PURB_CLOSE_ENDPOINT CloseUrb,
    PXID_OPEN_DEVICE OpenDevice
    )
{
    
    IUsbDevice *device = OpenDevice->XidNode->Device;

    //
    // If the control endpoint is open
    // build an URB to close it.
    //
    if(OpenDevice->ControlEndpointOpen)
    {
        //
        //  Close the default endpoint
        //
        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
                        CloseUrb,
                        (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
                        (PVOID)OpenDevice
                        );
        OpenDevice->ControlEndpointOpen = FALSE;
    } else if(OpenDevice->InterruptInEndpointHandle)
    //
    //  If the interrupt in endpoint needs to be closed
    //  build an URB to close it.
    //
    {
        USB_BUILD_CLOSE_ENDPOINT(
            CloseUrb,
            OpenDevice->InterruptInEndpointHandle,
            (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
            (PVOID)OpenDevice
            );
        OpenDevice->InterruptInEndpointHandle = NULL;
    } else if(OpenDevice->InterruptOutEndpointHandle)
    //
    //  If the interrupt in endpoint needs to be closed
    //  build an URB to close it.
    //
    {
        USB_BUILD_CLOSE_ENDPOINT(
            CloseUrb,
            OpenDevice->InterruptOutEndpointHandle,
            (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
            (PVOID)OpenDevice
            );
        OpenDevice->InterruptOutEndpointHandle = NULL;
    } else
    //
    //  Everything is closed, handle the reason
    //  we close the endpoints (either pending close
    //  or pending remove).
    //
    {
        PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;
        //
        //  We should only be here if either a close pending
        //  or if a remove is pending.
        //
        ASSERT(OpenDevice->ClosePending || xidNode->PendingRemove);

        //
        //  In either case, we need to sever the xidNode
        //  and the openDevice.
        //
        xidNode->OpenDevice = NULL;
        OpenDevice->XidNode = NULL;

        //
        //  If there is a pending remove,
        //  we need to call remove complete.
        //
        if(xidNode->PendingRemove)
        {
            XID_fRemoveDeviceComplete(xidNode);
        }

        //
        //  If there is a pending close,
        //  signal the close event.
        //
        if(OpenDevice->ClosePending)
        {
            //
            //  Signal the close event
            //
            ASSERT(OpenDevice->CloseEvent);
            KeSetEvent(OpenDevice->CloseEvent, IO_NO_INCREMENT, FALSE);
        }

        return;
    }
   
    //
    //  submit the next request
    //
    device->SubmitRequest((PURB)CloseUrb);
}
   

VOID
XID_NewInterruptData(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    )
/*++
    Routine Description:
        This is the completion routine for new input data.

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        So we can safely process the I/O.  However,
        before resubmitting any I/O requests, we
        should verify that a close or remove is not
        pending.
--*/
{
    ASSERT_DISPATCH_LEVEL();
    
    PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;

    //
    //  If the device has been closed or is pending
    //  remove, there is nothing to do.
    //
    if(OpenDevice->ClosePending || xidNode->PendingRemove)
    {
        return;  
    }

    //
    //  If the URB was completed successfully, then
    //  process the data.
    //
    if(USBD_SUCCESS(Urb->Header.Status))
    {
        //
        //  Debug only check that the device is not returning short packets
        //
        #if DBG
        if( Urb->BulkOrInterruptTransfer.TransferBufferLength < xidNode->bMaxInputReportSize)
        {
            USB_DBG_TRACE_PRINT(("An input device returned a short packet(expected %d, received %d).",
                xidNode->bMaxInputReportSize,
                Urb->BulkOrInterruptTransfer.TransferBufferLength
                ));
        }
        if( Urb->BulkOrInterruptTransfer.TransferBufferLength > xidNode->bMaxInputReportSize)
        {
            USB_DBG_ERROR_PRINT(("Packet came back larger than maximum allowed."));
            Urb->BulkOrInterruptTransfer.TransferBufferLength = xidNode->bMaxInputReportSize;
        }
        #endif

        //
        //  Process the new data
        //
        xidNode->TypeInformation->pfnProcessNewData(OpenDevice);
        
        OpenDevice->PacketNumber++;
        OpenDevice->OutstandingPoll = 0;
        
        //
        //  Resubmit the URB if autopoll, reset the transfer
        //  length, in case the last transfer came up short.
        //
        Urb->BulkOrInterruptTransfer.TransferBufferLength = xidNode->bMaxInputReportSize;
        
        //
        //  If this is not an auto-poll device, we are done
        //
        if(!OpenDevice->AutoPoll)
        {
            return;
        }
    } else
    {
        //
        //  Print out the error.
        //
        #if DBG
        if(
            (USBD_STATUS_CANCELED != Urb->Header.Status) &&
            (USBD_ISOCH_STATUS_DEV_NOT_RESPONDING != Urb->Header.Status) //99% of the time indicates device is gone
        )
        {
            USB_DBG_WARN_PRINT(("An input device poll failed. Status = 0x%0.8x\n", Urb->Header.Status));
        }
        #endif
        //
        //  Alter the URB so that it clears the endpoint halt.
        //
        USB_BUILD_CLEAR_FEATURE(
                (PURB_CONTROL_TRANSFER)Urb,
                USB_COMMAND_TO_ENDPOINT,
                USB_FEATURE_ENDPOINT_STALL,
                xidNode->EndpointAddressIn,
                (PURB_COMPLETE_PROC)XID_ClearInputStallComplete,
                OpenDevice
                );
    }
    
    //
    //  Resubmit the URB
    //
    xidNode->Device->SubmitRequest(Urb);
}

VOID
XID_ClearInputStallComplete(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    )
/*++
    Routine Description:
        This is the completion routine for sendinf a
        CLEAR_FEATURE(ENDPOINT_HALT).

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        We should check to see if a close or remove is
        pending before trying to finish the endpoint
        reset, or submitting an input URB.
--*/
{
    PXID_DEVICE_NODE    xidNode = OpenDevice->XidNode;
    USBD_STATUS         status;
    
    //
    //  Don't do anything if a remove or close is pending.
    //
    if(xidNode->PendingRemove || OpenDevice->ClosePending)
    {
        return;
    }
    //
    //  If the CLEAR_FEATURE succeeded,
    //  reset the endpoint state, and try to resubmit
    //  the I/O.
    //
    if(USBD_SUCCESS(Urb->Header.Status))
    {
	    //
        //  Build URB to reset the endpoint state
        //
        USB_BUILD_SET_ENDPOINT_STATE( 
            (PURB_GET_SET_ENDPOINT_STATE)Urb,
            OpenDevice->InterruptInEndpointHandle,
            USB_ENDPOINT_STATE_CLEAR_HALT | USB_ENDPOINT_STATE_DATA_TOGGLE_RESET
            );
	    status = xidNode->Device->SubmitRequest(Urb);
        ASSERT(USBD_SUCCESS(status));

        USB_DBG_WARN_PRINT(("Reset endpoint, resume polling.\n"));
	    //
        //  Build URB to resume polling
        //
        #ifdef ALAMO_RAW_DATA_HACK
        if(xidNode->AlamoHack) XID_AlamoStartPoll(OpenDevice);
        else {
        #endif

        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
                    (PURB_BULK_OR_INTERRUPT_TRANSFER)&OpenDevice->Urb,
                    OpenDevice->InterruptInEndpointHandle,
                    OpenDevice->ReportForUrb,
                    xidNode->bMaxInputReportSize,
                    USB_TRANSFER_DIRECTION_IN,
                    (PURB_COMPLETE_PROC)XID_NewInterruptData,
                    (PVOID)OpenDevice,
                    TRUE
                    );
	    xidNode->Device->SubmitRequest(Urb);
        #ifdef ALAMO_RAW_DATA_HACK
        }
        #endif

    }  else
    {
        USB_DBG_WARN_PRINT(("Failed to clear halt. Report device as not responding.  Status = 0x%0.8x\n", Urb->Header.Status));
        xidNode->Device->DeviceNotResponding();
    }
}

void
FASTCALL
XID_ProcessGamepadData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   Processing of gamepad data.  Basically, it copies the data
   from the buffer that is ping-ponged to the hardware, to the one
   that is always available for copying from XInputGetState.

   Then it checks to see if anything changes and hits XAutoPowerDownResetTimer
--*/
{
    XINPUT_GAMEPAD *pGamePad = (XINPUT_GAMEPAD *)OpenDevice->Report;
    if(OpenDevice->Urb.CommonTransfer.TransferBufferLength >= XID_REPORT_HEADER)
    {
        RtlCopyMemory(
          (PVOID)pGamePad,
          (PVOID)(OpenDevice->ReportForUrb+XID_REPORT_HEADER),
          OpenDevice->Urb.ControlTransfer.TransferBufferLength-XID_REPORT_HEADER
          );

        //
        //  XAutoPowerDownResetTimer if necessary, too much jitter the thumbsticks
        //  means we check all the other controls to see if any of them are pressed.
        //
        if(
            pGamePad->wButtons& (XINPUT_GAMEPAD_DPAD_UP|XINPUT_GAMEPAD_DPAD_DOWN|XINPUT_GAMEPAD_DPAD_LEFT|
                                 XINPUT_GAMEPAD_DPAD_RIGHT|XINPUT_GAMEPAD_START|XINPUT_GAMEPAD_BACK)
          )
        {
            XAutoPowerDownResetTimer();
        } else
        {
            for(int i = XINPUT_GAMEPAD_A; i <= XINPUT_GAMEPAD_RIGHT_TRIGGER; i++)
            {
                if(pGamePad->bAnalogButtons[i])
                {
                  XAutoPowerDownResetTimer();
                  break;
                }
            }
        }
    }
}

void
FASTCALL
XID_ProcessIRRemoteData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   IRREM XID processing of new data.  Copies the data
   from the buffer that is ping-ponged to the hardware, 
   then it hits XAutoPowerDownResetTimer.
--*/
{
    RtlCopyMemory(
        (PVOID)OpenDevice->Report,
        (PVOID)(OpenDevice->ReportForUrb+XID_REPORT_HEADER),
        OpenDevice->Urb.ControlTransfer.TransferBufferLength-XID_REPORT_HEADER
        );
    XAutoPowerDownResetTimer();
}

void
FASTCALL
XID_ProcessNewKeyboardData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   Keyboard processing is slightly different.  It doesn't have a XID_REPORT_HEADER
--*/
{
  RtlCopyMemory(OpenDevice->Report, OpenDevice->ReportForUrb, sizeof(XINPUT_KEYBOARD));
  if(XID_pKeyboardServices)
  {
    XID_pKeyboardServices->pfnNewData((PVOID)OpenDevice, (PXINPUT_KEYBOARD)OpenDevice->Report);
    XAutoPowerDownResetTimer();
  }
}

DWORD
FASTCALL
XID_fSendDeviceReport(
        IN      PXID_OPEN_DEVICE           OpenDevice,
        IN      PXINPUT_FEEDBACK_INTERNAL  OutputReport
        )
{
    PVOID               rawOutputBuffer;
    USBD_STATUS         usbStatus;
    PXID_DEVICE_NODE    xidNode = OpenDevice->XidNode;
    KIRQL               oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Check to make sure the device has not been removed
    //
    if(NULL==xidNode || xidNode->PendingRemove)
    {
        OutputReport->dwStatus = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_send_device_report;
    }
    //
    //  If bMaxOutputReportSize is zero, the device doesn't support output.
    //
    if(0 == xidNode->bMaxOutputReportSize)
    {
        OutputReport->dwStatus = ERROR_NOT_SUPPORTED;
        goto exit_send_device_report;
    }

    //
    //  Increase the reference count on the completion event
    //  if there is one.
    //
    if(OutputReport->hEvent)
    {
        NTSTATUS status = ObReferenceObjectByHandle(
                            OutputReport->hEvent,
                            ExEventObjectType,
                            (PHANDLE)&OutputReport->Internal.CompletionEvent
                            );
        //
        //  If the following assertion fails the event handle is invalid.
        //  This does not prevent the I/O, but we cannot set the event.
        //  We assert, and NULL out both the hEvent and the pointer
        //  we would have obtained from ObReferenceObjectByHandle
        //
        //ASSERT(NT_SUCCESS(status));
        if(!NT_SUCCESS(status))
        {
            USB_DBG_ERROR_PRINT(("ERROR: pFeedback->Header.hEvent (0x%0.8x) is invalid.\n"
                                 "hEvent should be NULL or a valid Event handle.\n"
                                 "Event cannot be signaled at completion.\n", OutputReport->hEvent));
            OutputReport->hEvent = NULL;
            OutputReport->Internal.CompletionEvent = NULL;    
        }
    } else
    {
        OutputReport->Internal.CompletionEvent = NULL;
    }

    //
    //  Constrain the size if needed.
    //
    if(xidNode->bMaxOutputReportSize < OutputReport->Internal.bSize)
    {
        OutputReport->Internal.bSize = xidNode->bMaxOutputReportSize;
    }

    //
    //  Legacy devices (notably keyboard) does not have a XID_REPORT_HEADER.
    //
    if(xidNode->TypeInformation->ulFlags&XID_BSF_NO_OUTPUT_HEADER)
    {
        rawOutputBuffer = (PVOID)(&OutputReport->Internal.bReportId + XID_REPORT_HEADER);
    } else
    //
    //  Otherwise rawBuffer starts at the bReportId of the internal header
    //
    {
        rawOutputBuffer = (PVOID)&OutputReport->Internal.bReportId;
    }

    //
    //  Build the URB  (use the interrupt Out pipe if there is
    //  one, otherwise use the default pipe with SET_REPORT).
    //
    if(OpenDevice->InterruptOutEndpointHandle)
    {
        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
                &OutputReport->Internal.Urb.BulkOrInterruptTransfer,
                OpenDevice->InterruptOutEndpointHandle,
                rawOutputBuffer,
                OutputReport->Internal.bSize,
                USB_TRANSFER_DIRECTION_OUT,
                (PURB_COMPLETE_PROC)XID_OutputComplete,
                (PVOID)OutputReport,
                FALSE
                );
    } else
    {
        USB_BUILD_CONTROL_TRANSFER(
            &OutputReport->Internal.Urb.ControlTransfer,
            NULL,
            rawOutputBuffer,
            OutputReport->Internal.bSize,
            USB_TRANSFER_DIRECTION_OUT,
            (PURB_COMPLETE_PROC)XID_OutputComplete,
            (PVOID)OutputReport,
            FALSE,
            (USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE),
            XID_COMMAND_SET_REPORT,
            0x0200 | OutputReport->Internal.bReportId,
            xidNode->InterfaceNumber,
            (WORD)OutputReport->Internal.bSize
            );
    }

    //
    //  Submit the request
    //
    OutputReport->Internal.OpenDevice = OpenDevice;
    usbStatus = xidNode->Device->SubmitRequest(&OutputReport->Internal.Urb);
    OutputReport->dwStatus = IUsbDevice::Win32FromUsbdStatus(usbStatus);

exit_send_device_report:
    
    KeLowerIrql(oldIrql);
    return OutputReport->dwStatus;
}

VOID
XID_OutputComplete(
    PURB                      Urb,
    PXINPUT_FEEDBACK_INTERNAL  OutputReport
    )
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Check to see if the device has been removed
    //
    PXID_OPEN_DEVICE openDevice = OutputReport->Internal.OpenDevice;
    PXID_DEVICE_NODE xidNode = openDevice->XidNode;

    //
    //  If the device has been removed or closed
    //  set the error to USBD_STATUS_NO_DEVICE
    //
    if(openDevice->ClosePending || xidNode->PendingRemove)
    {
        Urb->Header.Status = USBD_STATUS_NO_DEVICE;
    }
    
    //
    //  If the interrupt-Out endpoint is stalled we have to clear the stall,
    //  prior to copying the status and signalling an event.
    //
    if(
        (Urb->Header.Status == USBD_STATUS_STALL_PID) &&
        (Urb->Header.Function == URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER)
        )
    {
        //
        //  Print out the error.
        //
        USB_DBG_WARN_PRINT(("The interrupt-Out endpoint stalled, reseting.\n", Urb->Header.Status));
        //
        //  Alter the URB so that it clears the endpoint halt.
        //
        USB_BUILD_CLEAR_FEATURE(
            (PURB_CONTROL_TRANSFER)Urb,
            USB_COMMAND_TO_ENDPOINT,
            USB_FEATURE_ENDPOINT_STALL,
            xidNode->EndpointAddressOut,
            (PURB_COMPLETE_PROC)XID_ClearOutputStallComplete,
            OutputReport
            );
        //
        //  Submit the request to clean the stall.
        //
        xidNode->Device->SubmitRequest(Urb);
    } else
    //
    //  If the endpoint is not stalled (or it was a control endpoint which does not need clearing)
    //  go ahead and complete the output.
    //
    {
        XID_fOutputComplete1(Urb, OutputReport);
    }
}

VOID
FASTCALL
XID_fOutputComplete1(
    PURB Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    )
{
    PKEVENT event = OutputReport->Internal.CompletionEvent;

    //
    //  Copy and convert the status.
    //
    OutputReport->dwStatus = IUsbDevice::Win32FromUsbdStatus(Urb->Header.Status);

    //
    //  If the call provided a completion event, set it
    //  and then dereference it.
    //  
    if(event)
    {
        KeSetEvent(event, IO_NO_INCREMENT, FALSE);
        ObDereferenceObject(event);
    }
}


VOID
XID_ClearOutputStallComplete(
    PURB                     Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    )
/*++
    Routine Description:
        This is the completion routine for sendinf a
        CLEAR_FEATURE(ENDPOINT_HALT).

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        We should check to see if a close or remove is
        pending before trying to finish the endpoint
        reset, or submitting an input URB.
--*/
{
    PXID_OPEN_DEVICE    openDevice = OutputReport->Internal.OpenDevice;
    PXID_DEVICE_NODE    xidNode = openDevice->XidNode;
    USBD_STATUS         status = Urb->Header.Status;
    
    //
    //  If the device has been removed or closed
    //  set the error to USBD_STATUS_NO_DEVICE
    //
    if(openDevice->ClosePending || xidNode->PendingRemove)
    {
        Urb->Header.Status = USBD_STATUS_NO_DEVICE;
    } else 
    {
        if(USBD_SUCCESS(status))
        {
            //
            //  Build and submit URB to reset the endpoint state
            //
            USB_BUILD_SET_ENDPOINT_STATE( 
                (PURB_GET_SET_ENDPOINT_STATE)Urb,
                openDevice->InterruptOutEndpointHandle,
                USB_ENDPOINT_STATE_CLEAR_HALT | USB_ENDPOINT_STATE_DATA_TOGGLE_RESET
                );
	        xidNode->Device->SubmitRequest(Urb);
        } else
        {
            USB_DBG_ERROR_PRINT(("Attempt to clear endpoint stall result in status: 0x%0.8x.\n", status));
        }
        Urb->Header.Status = USBD_STATUS_STALL_PID;
    }    
   
    XID_fOutputComplete1(Urb, OutputReport);
}

VOID
XID_SyncComplete(
    PURB /*UnreferencedUrb*/,
    PKEVENT SyncEvent
    )
//
//  Used to make an asyncronous call, synchronous.
//
{
    KeSetEvent(SyncEvent, IO_NO_INCREMENT, FALSE);
}


//****
//****  Legacy Hardware Enumeration (right now the 
//****  Microsoft Natrual Keyboard Pro is the only supported
//****  legacy device).  Use of this device is limited for
//****  use as a development aid.  However, this is a policy
//****  decision, not a technical one.  Basically, we
//****  will always enumerate  a Natural Keyboard Pro,
//****  however several required methods for using it
//****  require lining xdbg.lib, which is not allowed for
//****  shipping titles.
//****  

#define VID_MICROSOFT               0x045E
#define PID_NATURAL_KEYBOARD_PRO    0x001D

VOID
XID_EnumLegacy1(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    Gets the full device descriptor.  The gives us access to the
    VID and PID so we can support a particular device.

  Comment:
    The commented out code below allows the support of any known
    protocol device (i.e. any boot keyboard).  This was scratched
    and replaced with VID\PID detection of the Microsoft
    Natural Keyboard Pro just for support reasons.  The other code
    should work on a wide variety of keyboards.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumLegacy1.\n"));
    
    //
    //  First see if it is a known protocol device. (a.k.a. keyboard or
    //  mouse, but we don't support mouse at this point)
    //
    const USB_INTERFACE_DESCRIPTOR *interfaceDescriptor;
    interfaceDescriptor = XidNode->Device->GetInterfaceDescriptor();
    if(
        (USB_DEVICE_CLASS_HUMAN_INTERFACE == interfaceDescriptor->bInterfaceClass) &&
        (HID_KEYBOARD_PROTOCOL == interfaceDescriptor->bInterfaceProtocol)
    )
    {   
        //
        //  Switch to the boot protcol
        //
        
        USB_BUILD_CONTROL_TRANSFER(
            &XID_Globals.EnumUrb.ControlTransfer,
            NULL,
            NULL,
            0,
            0,
            (PURB_COMPLETE_PROC)XID_EnumKeyboard,
            (PVOID)XidNode,
            TRUE,
            USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
            HID_SET_PROTOCOL,
            HID_BOOT_PROTOCOL,
            XidNode->InterfaceNumber,
            0);

    }
#if NEVER
    //
    //  Check for legacy devices that we support via the VID\PID\FW,
    //  currently there are none, so this if #if NEVER.
    else
    {
        //
        //  Get the full device descriptor.
        //  The core driver never bothers to get
        //  more than the first 8 bytes.
        //
        USB_BUILD_GET_DESCRIPTOR(
            &XID_Globals.EnumUrb.ControlTransfer,
            USB_DEVICE_DESCRIPTOR_TYPE,
            0,
            0,
            (PVOID)&XID_Globals.EnumDeviceDescriptor,
            sizeof(USB_DEVICE_DESCRIPTOR),
            (PURB_COMPLETE_PROC)XID_EnumLegacy2,
            (PVOID)XidNode
            );
    }
#else
    else
    {
        //
        //  The device is not supported, free the node.
        //
        XidNode->Device->SetExtension(NULL);
        XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        XidNode->Device=NULL;
        XidNode->InUse = FALSE;
        XID_Globals.DeviceNodeInUseCount--;
        return;
    }
#endif

    XID_SetEnumWatchdog();
	XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
}

#if NEVER
//
//  This routine process enumeration of devices based on VID\PID, currently
//  we have none, so the routine is #if NEVER
//
VOID
XID_EnumLegacy2(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    Completion routine for XID_EnumLegacy1.  At this point we can check the
    VID PID and decide whether or not to support the device.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumLegacy2.\n"));
    XID_ClearEnumWatchdog();
    
    //
    //  Check for legacy devices that we support
    //

    //
    //  Natural Keyboard Pro Support (NOT NEEDED, it is a standard boot keyboard)
    //  left as an example of what to do.
    //
    if(
        (VID_MICROSOFT == XID_Globals.EnumDeviceDescriptor.idVendor) &&
        (PID_NATURAL_KEYBOARD_PRO == XID_Globals.EnumDeviceDescriptor.idProduct)
    )
    {
        const USB_INTERFACE_DESCRIPTOR *interfaceDescriptor;
        interfaceDescriptor = XidNode->Device->GetInterfaceDescriptor();
        //
        //  Only the keyboard interface of this is device is supported
        //  (it has more than one interface)
        if(
            (USB_DEVICE_CLASS_HUMAN_INTERFACE == interfaceDescriptor->bInterfaceClass) &&
            (HID_KEYBOARD_PROTOCOL == interfaceDescriptor->bInterfaceProtocol)
        )
        {
            //
            //  Switch to the boot protcol
            //
            USB_BUILD_CONTROL_TRANSFER(
                &Urb->ControlTransfer,
                NULL,
                NULL,
                0,
                0,
                (PURB_COMPLETE_PROC)XID_EnumKeyboard,
                (PVOID)XidNode,
                TRUE,
                USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
                HID_SET_PROTOCOL,
                HID_BOOT_PROTOCOL,
                XidNode->InterfaceNumber,
                0);
                XID_SetEnumWatchdog();
	            XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
            //
            //  Keyboard has more enum steps
            //
            return;
        }
    }

    //
    //  IF the device is not supported, free the node.
    //
    XidNode->Device->SetExtension(NULL);
    XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    XidNode->Device=NULL;
    XidNode->InUse = FALSE;
    XID_Globals.DeviceNodeInUseCount--;
}
#endif

VOID
XID_EnumKeyboard(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    After a keyboard is found there are still more steps.  In particular,
    we must switch to the boot protocol.  XID_EnumLegacy2 did that, and this
    is the completion routine.

    Now we must set the idle rate to infinite.  Infinite should be the default
    for boot protocol keyboards, but this is for good measure.
--*/
{
    XID_ClearEnumWatchdog();
    //
    //  Switch the idle rate to infinite
    //
    USB_BUILD_CONTROL_TRANSFER(
        &XID_Globals.EnumUrb.ControlTransfer,
        NULL,
        NULL,
        0,
        0,
        (PURB_COMPLETE_PROC)XID_EnumKeyboardComplete,
        (PVOID)XidNode,
        TRUE,
        USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
        HID_SET_IDLE,
        HID_IDLE_INFINITE,
        XidNode->InterfaceNumber,
        0);
    XID_SetEnumWatchdog();
	XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
}

VOID
XID_EnumKeyboardComplete(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    We are done with enumeration steps for enumerating a keyboard
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumKeyboardComplete.\n"));
    XID_ClearEnumWatchdog();

    // Since keyboards are legacy, we hardcode the type.
    XidNode->TypeInformation = GetTypeInformation(XID_DEVTYPE_KEYBOARD, &XidNode->TypeIndex);

    if(!XidNode->TypeInformation)
    {
        USB_DBG_WARN_PRINT(("No keyboard support in this build."));
        XidNode->Device->SetExtension(NULL);
        XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    	XidNode->Device=NULL;
        XidNode->InUse = FALSE;
        XID_Globals.DeviceNodeInUseCount--;
        return;
    }
    
    XidNode->SubType = XINPUT_DEVSUBTYPE_KBD_STANDARD;
    XidNode->bMaxInputReportSize = sizeof(XINPUT_KEYBOARD);
    XidNode->bMaxOutputReportSize = sizeof(XINPUT_KEYBOARD_LEDS);
    XidNode->Device->SetClassSpecificType(XidNode->TypeIndex);
    XidNode->Device->AddComplete(USBD_STATUS_SUCCESS);
    XidNode->Ready = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xidex\xidinp.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    input.c

Abstract:
    
    Implementation of the Input API
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    03-07-00 created by Mitchell Dernis (mitchd)
    12-06-00 changed synchronization scheme
--*/

//
//  Pull in OS headers
//
#define _XAPI_
#define _KERNEL32_ //since we are linked to XAPI for now.
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>
#include <xapidrv.h>
#include <xdbg.h>
#include <stdio.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("INPUT");

//
//  Pull in public usb headers
//
#include <usb.h>

//
//  Pull in xid headers
//
#include "xid.h"

//--------------------------------------------------------------
//  Handle Verification
//--------------------------------------------------------------
#if DBG //Debug version verifies handles.
#define XID_VERIFY_HANDLES 
#endif
#ifdef XID_VERIFY_HANDLES

PXID_OPEN_DEVICE XID_OpenDeviceList = NULL;
VOID XidInsertHandle(PXID_OPEN_DEVICE OpenDevice);
VOID XidRemoveHandle(PXID_OPEN_DEVICE OpenDevice);
VOID XidCheckHandle(PCHAR ApiName, PXID_OPEN_DEVICE OpenDevice);

#define XID_INSERT_HANDLE(OpenDevice) XidInsertHandle(OpenDevice)
#define XID_REMOVE_HANDLE(OpenDevice) XidRemoveHandle(OpenDevice)
#define XID_CHECK_HANDLE(ApiName, OpenDevice) XidCheckHandle(ApiName, OpenDevice)

#else

#define XID_INSERT_HANDLE(OpenDevice) do{}while(0)
#define XID_REMOVE_HANDLE(OpenDevice) do{}while(0)
#define XID_CHECK_HANDLE(ApiName,OpenDevice) do{}while(0)
    
#endif

//--------------------------------------------------------------
//  Implementation
//--------------------------------------------------------------
XBOXAPI
HANDLE
WINAPI
XInputOpen(
    IN PXPP_DEVICE_TYPE XppDeviceType,
    IN DWORD dwPort,
    IN DWORD dwSlot,
    IN PXINPUT_POLLING_PARAMETERS pPollingParameters OPTIONAL
    )
/*++
    Routine Description:
        Public API to open a handle to an input device.
  
    Arguments:
        XppDeviceType       - device type to open.
        dwPort              - Port of device to open.
        dwSlot              - Slot of device to open.
        pPollingParameters  - [optional] polling parameters to use with device.

    Return Value:
        On success, handle to be used to access device.
        On failure, NULL.  Call GetLastError for specific error code.
        
          ERROR_SHARING_VIOLATION    - attempt to open more than one handle to a single device.
          ERROR_OUTOFMEMORY          - there was not enough memory to open the handle.
          ERROR_INVALID_PARAMETER    - the device type was not known.
          ERROR_DEVICE_NOT_CONNECTED - a device was not found of the given type in the specified
                                       port and slot.
          ERROR_IO_DEVICE            - an error occured talking to the device.

--*/
{
    DWORD              errorCode;
    PXID_OPEN_DEVICE   openDevice = NULL;

    ASSERT_LESS_THAN_DISPATCH_LEVEL();

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XInputOpen: XInitDevices must be called first!");
    
    XID_TYPE_INFORMATION *typeInformation = GetTypeInformation(XppDeviceType);

    if(!typeInformation)
    {
        RIP("XInputOpen: XppDeviceType is not a valid type for the XInputXXX API\n");
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    //  RIP port and slot parameters
    //
    RIP_ON_NOT_TRUE(XInputOpen, dwPort<XGetPortCount());

    // At this time all XID devices are only direct connect, so this RIP applies.
    // In the future, we may want to add a slot type parameter to the type table.
    RIP_ON_NOT_TRUE(XInputOpen, (dwSlot == XDEVICE_NO_SLOT));
       
    //
    //  If the polling parameters are NULL, look up the defaults based on type.
    //
    if(NULL == pPollingParameters)
    {
        pPollingParameters = typeInformation->DefaultPollingParameters;
    }
    
    //
    //  Open the device
    //
    errorCode = XID_fOpenDevice(
                        typeInformation,
                        (dwSlot != XDEVICE_BOTTOM_SLOT) ? dwPort : dwPort +16,
                        &openDevice,
                        pPollingParameters
                        );

    //
    //  If the open failed, set the error code.
    //
    if(NULL==openDevice)
    {
        SetLastError(errorCode);
    }
    else
    {
        //
        //  Insert the handle into the list of 
        //  valid handles.
        //
        XID_INSERT_HANDLE(openDevice);
    }
    return (HANDLE)openDevice;
}  

XBOXAPI
void
WINAPI
XInputClose(
    IN HANDLE hDevice
    )
/*++

    Routine Description:
        Public API to close a handle to an input device.
  
    Arguments:
        XppDeviceType       - device type to open.
        dwPort              - Port of device to open.
        dwSlot              - Slot of device to open.
        pPollingParameters  - [optional] polling parameters to use with device.

    Return Value:
        None    
    Remarks:
        Close can block for several milliseconds while resources are being cleaned up.
        
        It is the callers responsibility not to use a handle after XInputClose has been
        called.  It is particularly risky with multiple threads.
            * No other call to an XInputXXX API using the handle should be started after
              XInputClose has been called, even if XInputClose has not yet returned.
            * XInputClose must not be called until all other XInputXXX API's using the handle
              have returned.
        In debug builds, an attempt is made to detect these conditions and RIP, however, the
        RIP's are not full-proof, and under some circumstances, may miss such a condition.
        If these rules are violated the result is undefined, in many cases this will lead to
        memory corruption and system crash.

        One should normally wait for asynchronous I/O (started with XInputSetState) to complete
        before calling XInputClose, however, it is not an error to call XInputClose with 
        asynchronous I/O pending.  The result is that pending I/O is guaranteed to complete,
        usually with status set to ERROR_CANCELLED, before XInputClose returns.

--*/
{
    PXID_OPEN_DEVICE openDevice = (PXID_OPEN_DEVICE)hDevice;
    ASSERT_LESS_THAN_DISPATCH_LEVEL();
    XID_REMOVE_HANDLE(openDevice);
    XID_fCloseDevice(openDevice);
    return;
}

XBOXAPI
DWORD
WINAPI
XInputGetCapabilities(
    IN HANDLE hDevice,
    OUT PXINPUT_CAPABILITIES pCapabilities
    )
/*++
    Routine Description:
        Public API to retrieve capabilities from a device.
    Arguments:
        hDevice - handle to device for which to get capabilities.
        pCapabilities - pointer to buffer to get capabilities.
    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - if the device is no longer connected.
        ERROR_IO_DEVICE - problem communicating with the device.
    Remarks:
        This routine blocks while the device is queried.  This can take
        a few milliseconds.
--*/
{
    PCHAR                  pReportBuffer;
    ULONG                  length;
    URB_CONTROL_TRANSFER   urb;
    KEVENT                 event;
    KIRQL                  oldIrql;
    PXID_DEVICE_NODE       xidNode;
    DWORD                  errorCode = ERROR_SUCCESS;
    PXID_OPEN_DEVICE       openDevice = (PXID_OPEN_DEVICE)hDevice;

    ASSERT_LESS_THAN_DISPATCH_LEVEL();

    //
    //  Raise Irql for synchronization
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputGetCapabilities", openDevice);
 
    //
    //  Make sure device is connected
    //
    xidNode = openDevice->XidNode;
    if( NULL == xidNode || xidNode->PendingRemove)
    {   
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_input_get_caps;
    }

    //
    //  Zero the whole output buffer
    //
    RtlZeroMemory(pCapabilities, sizeof(XINPUT_CAPABILITIES));

    //
    //  Fill in the subtype, that doesn't depend on the report being queried
    //  so even if this fails with invalid parameter, we can check it.
    //
    pCapabilities->SubType = xidNode->SubType;
    
    //
    //  Make sure that the device supports GET_CAPABILITIES.
    //  This check is primarily for legacy devices, in particular
    //  legacy keyboards.
    //
    if(xidNode->TypeInformation->ulFlags&XID_BSF_NO_CAPABILITIES)
    {
        errorCode = ERROR_ACCESS_DENIED;
    }
    else
    {
        //
        //  Get the output portion
        //
        pReportBuffer = (PCHAR)&pCapabilities->Out;
        length = xidNode->TypeInformation->pOutputReportInfoList[0].bCurrentSize;

        //
        //  Build the URB
        //
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        USB_BUILD_CONTROL_TRANSFER(
                &urb,
                NULL,
                (PVOID)(pReportBuffer-2),
                length+2,
                USB_TRANSFER_DIRECTION_IN,
                (PURB_COMPLETE_PROC)XID_SyncComplete,
                &event,
                TRUE,
                USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE,
                XID_COMMAND_GET_CAPABILITIES,
                0x0200,
                xidNode->InterfaceNumber,
                length+2
                );

        //
        //  Submit the request.
        //
        xidNode->Device->SubmitRequest((PURB)&urb);
    
        //
        //  Wait for transfer to complete
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  Recheck the handle (should not have been closed)
        //
        XID_CHECK_HANDLE("XInputGetCapabilities", openDevice);

        //
        //  Make sure the device wasn't removed
        //  in the interm. 
        //  
        if( NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_input_get_caps;
        }

        //
        //  Check for error
        //
        if(USBD_ERROR(urb.Hdr.Status))
        {
            errorCode = IUsbDevice::Win32FromUsbdStatus(urb.Hdr.Status);
            goto exit_input_get_caps;
        }

        //
        //  Now get the input portion
        //
        pReportBuffer = (PCHAR)&pCapabilities->In;
        length = xidNode->TypeInformation->pInputReportInfoList[0].bCurrentSize;

        //
        //  Build the URB
        //
        USB_BUILD_CONTROL_TRANSFER(
                &urb,
                NULL,
                (PVOID)(pReportBuffer-2),
                length+2,
                USB_TRANSFER_DIRECTION_IN,
                (PURB_COMPLETE_PROC)XID_SyncComplete,
                &event,
                TRUE,
                USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE,
                XID_COMMAND_GET_CAPABILITIES,
                0x0100,
                xidNode->InterfaceNumber,
                length+2
                );
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        xidNode->Device->SubmitRequest((PURB)&urb);

        //
        //  Wait for transfer to complete
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  Make sure the device wasn't removed
        //  in the interm.
        //
        if( NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_input_get_caps;
        }

        //
        //  Check for error
        //
        if(USBD_ERROR(urb.Hdr.Status))
        {
            errorCode = IUsbDevice::Win32FromUsbdStatus(urb.Hdr.Status);
            goto exit_input_get_caps;
        }
    }

exit_input_get_caps:
    //Bug 2578, make sure nobody tries to falsely divine information
    //from the reserved field.
    pCapabilities->Reserved = 0;
    KeLowerIrql(oldIrql);
    return errorCode;
}

XBOXAPI
DWORD
WINAPI
XInputGetState(
    IN HANDLE hDevice,
    OUT PXINPUT_STATE  pState
    )
/*++
    Routine Description:
        Public API for retrieving the latest known state of the
        device.  This routine does not actually perform I/O it
        just copies the latest known state into the caller's buffer.

        
    Arguments:
        hDevice - handle of device to get state for.
        pState  - buffer to receive state.

    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - device no longer connected (buffer is still copied).
--*/
{
    PXID_OPEN_DEVICE    openDevice = (PXID_OPEN_DEVICE) hDevice;
    DWORD               errorCode = ERROR_SUCCESS;
    KIRQL               oldIrql;
    ULONG               length;
    
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputGetState", openDevice);

    //
    //  Don't allow keyboards to work
    //
#ifdef DEBUG_KEYBOARD
    if(XDEVICE_TYPE_DEBUG_KEYBOARD == openDevice->TypeInformation->XppType)
    {
        KeLowerIrql(oldIrql);
        RIP("XInputGetState does not work for keyboards.");
        return ERROR_INVALID_PARAMETER;
    }
#endif //DEBUG_KEYBOARD

    //
    //  If the device is not connected, mark it, but copy the
    //  data anyway.
    //
    if(NULL == openDevice->XidNode || openDevice->XidNode->PendingRemove)
    {
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
    }
    
    //
    //  Copy packet number
    //
    pState->dwPacketNumber = openDevice->PacketNumber;
    
    //
    //  Copy the size indicated in the capatibility table.
    //
    length = openDevice->TypeInformation->pInputReportInfoList[0].bCurrentSize;
    
    //
    //  Copy the latest report (We are using GameReport, but we could
    //                          use any member of the union of report types)
    RtlCopyMemory( (PVOID)&pState->Gamepad, (PVOID)openDevice->Report, length);
    
    
    KeLowerIrql(oldIrql);
    return errorCode;
}

XBOXAPI
DWORD
WINAPI
XInputSetState(
    IN HANDLE hDevice,
    OUT PXINPUT_FEEDBACK pFeedback
    )
/*++
    Routine Description:
        Public API for sending data to the device.
        THIS IS ASYNCHRONOUS!!!
    
    Arguments:
        hDevice - handle of device to send data to.
        pFeedback - feedback data to send

    Return Value:
        ERROR_IO_PENDING - on sucess.
        ERROR_DEVICE_NOT_CONNECTED - the device is no longer connected,

    Remarks:
        Calling XInputSetState programs output to the device.  This output could a few to many
        milliseconds to complete depending on the pPollingParameters passed to XInputOpen.
        During this time XAPI owns pFeedback, the caller should consider it read only.

        There are two options for synchronization:
            
        1) If the caller sets pFeedback->Header.hEvent to a valid event handle, it will
           be signaled when the I/O completes, otherwise hEvent should be NULL.
        2) The caller may poll pFeedback->Header.dwStatus.  This will be ERROR_IO_PENDING
           when XInputSetState returns, it will change to ERROR_SUCCESS or another (non-pending)
           error code when the transfer completes, successfully or otherwuse.

        Calling XInputClose before the I/O complete cancels the I/O.  pFeedback->Header.hEvent
        (if a valid event) will be signaled before XInputClose returns,and pFeedback->Header.dwStatus
        will change to ERROR_CANCELLED.

--*/
{
    PXID_OPEN_DEVICE         openDevice = (PXID_OPEN_DEVICE) hDevice;
    PXINPUT_FEEDBACK_INTERNAL feedback = (PXINPUT_FEEDBACK_INTERNAL)pFeedback;
    
    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputSetState", openDevice);

    //
    //  Don't allow keyboards to work
    //
#ifdef DEBUG_KEYBOARD
    if(XDEVICE_TYPE_DEBUG_KEYBOARD == openDevice->TypeInformation->XppType)
    {
        RIP("XInputSetState does not work for keyboards.");
        return ERROR_INVALID_PARAMETER;
    }
#endif //DEBUG_KEYBOARD

    //
    //  Check Handle the report ID, before
    //  passing down.
    //
    feedback->Internal.bReportId = 0;
    feedback->Internal.bSize = openDevice->TypeInformation->pOutputReportInfoList[0].bCurrentSize + XID_REPORT_HEADER;
    return XID_fSendDeviceReport(openDevice, feedback);
}


XBOXAPI
DWORD
WINAPI
XInputPoll(
        IN HANDLE hDevice
        )
/*++
    Routine Description:
        Public API for manually polling an input device.
    
    Arguments:
        hDevice - handle of device to poll.
    
    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - if the device is no longer connected.

    Remarks:
        This API only needs to be called if XInputOpen was called with
        pPollingParameter->fAutoPoll set to FALSE.  Otherwise, it is
        a no-op.

        XInputGetState should be updated to return the latest state of the device
        no later than (pPollingParameter->bInputInterval + 1) ms, after XInputPoll
        is called.

--*/
{
    DWORD               errorCode = ERROR_SUCCESS;    
    PXID_OPEN_DEVICE    openDevice = (PXID_OPEN_DEVICE)hDevice;
    PXID_DEVICE_NODE    xidNode;
    KIRQL               oldIrql = KeRaiseIrqlToDpcLevel();
    
    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputPoll", openDevice);

    //
    //  Make sure device is connected
    //
    xidNode = openDevice->XidNode;
    if(NULL == xidNode || xidNode->PendingRemove)
    {   
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
    } else
    {
        if(!openDevice->AutoPoll)
        {
            if(!openDevice->OutstandingPoll)
            {   
                openDevice->OutstandingPoll = 1;
                #ifdef ALAMO_RAW_DATA_HACK
                if(xidNode->AlamoHack) XID_AlamoStartPoll(openDevice);
                else {
                #endif
                openDevice->Urb.BulkOrInterruptTransfer.TransferBufferLength = 
                                            openDevice->XidNode->bMaxInputReportSize;
                openDevice->XidNode->Device->SubmitRequest(&openDevice->Urb);  
                #ifdef ALAMO_RAW_DATA_HACK
                }
                #endif
            }
        }
    }

    KeLowerIrql(oldIrql);
    return errorCode;
}


//---------------------------------------------------------------------
//  Debug routine that keep track of open handles, and generate
//  RIP's when they are not valid.
//---------------------------------------------------------------------
#ifdef XID_VERIFY_HANDLES

VOID XidInsertHandle(PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    OpenDevice->NextOpenDevice = XID_OpenDeviceList;
    XID_OpenDeviceList = OpenDevice;
    KeLowerIrql(oldIrql);
}

VOID XidRemoveHandle(PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    PXID_OPEN_DEVICE previousDevice = NULL;
    PXID_OPEN_DEVICE device = XID_OpenDeviceList;
    BOOL found = FALSE;
    while(device)
    {
        if(device == OpenDevice)
        {
            if(previousDevice)
            {
                previousDevice->NextOpenDevice = device->NextOpenDevice;
            } else
            {
                XID_OpenDeviceList = device->NextOpenDevice;
            }
            found = TRUE;
            break;
        }
        previousDevice = device;
        device = device->NextOpenDevice;
    }
    KeLowerIrql(oldIrql);
    
    if(!found)
    {
        RIP("XInputClose: Invalid Handle\n");
    }

    return;    
}

VOID XidCheckHandle(CHAR *ApiName, PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    PXID_OPEN_DEVICE device = XID_OpenDeviceList;
    BOOL found = FALSE;
    while(device)
    {
        if(device == OpenDevice)
        {
            found = TRUE;
            break;
        }
        device = device->NextOpenDevice;
    }
    
    //
    //  BUG 9292 - cannot RIP at DISPATCH_LEVEL.  This hangs the machine when debugging
    //             with VC.  We were lowering IRQL to oldIrql before the RIP, but since
    //             this routine is usually called at DISPATCH_LEVEL, this is not good enough.
    //             Note that since this routine is NEVER called from a true DPC, it is always
    //             possible to explictly lower IRQL to PASSIVE_LEVEL.  We only want to do this
    //             though when we are going to RIP.  In that case, the system is already hosed
    //             and we do not lose any sleep over completely hosing it.
    //
    if(!found)
    {
        KeLowerIrql(PASSIVE_LEVEL);
        CHAR buffer[255];
        sprintf(buffer, "%s: Invalid Handle(0x%0.8x)\n", ApiName, OpenDevice);
        RIP(buffer);
        KIRQL dummyIrql;
        KeRaiseIrql(oldIrql, &dummyIrql);  // A feeble attempt to keep the system running after the RIP.
    } else
    {
        KeLowerIrql(oldIrql);
    }

    return;
}

#endif //XID_VERIFY_HANDLES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xidex\typeinfo.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    input.c

Abstract:
    
    Tables with information concerning the currently supported
    set of XID devices.
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    08-01-00 created by Mitchell Dernis (mitchd)

--*/
//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIH'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("INPUT");

//
//  Pull in public usb headers
//
#include <usb.h>

//
//  Pull in xid headers
//
#include "xid.h"

//This will create a table of subtypes that we can find to walk
#pragma data_seg(".XID$A")
extern "C" DWORD XID_BeginTypeDescriptionTable = 0;
#pragma data_seg(".XID$ZZZ")
extern "C" DWORD XID_EndTypeDescriptionTable = 0;
#pragma data_seg(".XPP$Data")
#pragma code_seg(".XPPCODE")

//  Tells the linker to merge the USB sections together
#pragma comment(linker, "/merge:.XID=.XPP")

//----------------------------------------------
// Functions to walk the type tables.
//----------------------------------------------

PXID_TYPE_INFORMATION FASTCALL GetTypeInformation(UCHAR XidType, UCHAR *TypeIndex)
{
    *TypeIndex = 0;
    UCHAR ucTypeIndex = 0;
    PXID_TYPE_INFORMATION *ppTypeInformation;
    ppTypeInformation = (PXID_TYPE_INFORMATION *)((&XID_BeginTypeDescriptionTable)+1);
    while( (ULONG_PTR)ppTypeInformation < (ULONG_PTR)&XID_EndTypeDescriptionTable )
    {
        if(*ppTypeInformation)
        {
            if((*ppTypeInformation)->ucType == XidType)
            {
                *TypeIndex = ucTypeIndex;
                return *ppTypeInformation;
            }
            ucTypeIndex++;
        }
        ppTypeInformation++;
    }
    return NULL;
}

PXID_TYPE_INFORMATION FASTCALL GetTypeInformation(PXPP_DEVICE_TYPE XppType)
{
    PXID_TYPE_INFORMATION *ppTypeInformation;
    ppTypeInformation = (PXID_TYPE_INFORMATION *)((&XID_BeginTypeDescriptionTable)+1);
    while( (ULONG_PTR)ppTypeInformation < (ULONG_PTR)&XID_EndTypeDescriptionTable )
    {
        if(*ppTypeInformation && ((*ppTypeInformation)->XppType == XppType))
        {
            return *ppTypeInformation;
        }
        ppTypeInformation++;
    }
    return NULL;
}

/****
*****   Type Table Entries for the standard types.
****/

//----------------------------------------------
//  Game Controller Reports
//----------------------------------------------
//#define  XID_DEVTYPE_GAMECONTROLLER      1 - defined in xid.h
#define  XID_DEVSUBTYPE_MAX_GAME           1
#define  XID_INPUT_REPORT_ID_MAX_GAME      0
#define  XID_OUTPUT_REPORT_ID_MAX_GAME     0
#define XID_DEFAULT_MAX_GAMEPAD        4

DECLARE_XPP_TYPE(XDEVICE_TYPE_GAMEPAD)
XINPUT_GAMEPAD       GamepadDefaults ={0, //All the digital buttons (including DPAD) up.
                                       0,0,0,0,0,0,0,0,   //All the analog buttons up
                                       0,0,       //The Left Thumbstick centered
                                       0,0        //The Right Thumbstick centered
                                       };

XID_REPORT_TYPE_INFO GameInputReportInfoList[1] = {sizeof(XINPUT_GAMEPAD),(PVOID)&GamepadDefaults};
XINPUT_RUMBLE        RumbleDefaults = {0};  //The motors are off by default
XID_REPORT_TYPE_INFO GameOutputReportInfoList[1] = {sizeof(XINPUT_RUMBLE),(PVOID)&RumbleDefaults};
XINPUT_POLLING_PARAMETERS GameDefaultPolling = {TRUE,FALSE,0,8,0,0}; //AutoPoll On, control-OUT,

XID_TYPE_INFORMATION  GamepadTypeInfo = 
 {XID_DEVTYPE_GAMECONTROLLER, XID_DEFAULT_MAX_GAMEPAD, XID_INPUT_REPORT_ID_MAX_GAME, XID_OUTPUT_REPORT_ID_MAX_GAME,
 XDEVICE_TYPE_GAMEPAD, GameInputReportInfoList, GameOutputReportInfoList, &GameDefaultPolling, XID_ProcessGamepadData, 0};
     
#pragma data_seg(".XID$Gamepad")
extern "C" ULONG_PTR GamepadTypeInfoENTRY = (ULONG_PTR)&GamepadTypeInfo;
#pragma data_seg(".XPP$Data")

//----------------------------------------------
//  Keyboard Reports
//----------------------------------------------
//#define  XID_DEVTYPE_KEYBOARD            2 - defined in xid.h
#define  XID_DEVSUBTYPE_MAX_KEYBOARD       1
#define  XID_INPUT_REPORT_ID_MAX_KEYBOARD  0
#define  XID_OUTPUT_REPORT_ID_MAX_KEYBOARD 0
#define  XID_DEFAULT_MAX_KEYBOARD          1

DECLARE_XPP_TYPE(XDEVICE_TYPE_DEBUG_KEYBOARD)
XINPUT_KEYBOARD      KeyboardDefaults ={0, //All modified keys up
                                       0, //Reserved byte is zero
                                       0,0,0,0,0,0 //No keys down
                                       };

XID_REPORT_TYPE_INFO KeyboardReportInfoList[1] = {sizeof(XINPUT_KEYBOARD),(PVOID)&KeyboardDefaults};
XINPUT_KEYBOARD_LEDS KeyboardLEDDefaults = {0};  //All light off by default
XID_REPORT_TYPE_INFO KeyboardLEDReportInfoList[1] = {sizeof(XINPUT_KEYBOARD_LEDS),(PVOID)&KeyboardLEDDefaults};
XINPUT_POLLING_PARAMETERS KeyboardDefaultPolling = {TRUE,FALSE,0,16,0,0}; //AutoPoll On, SET_REPORT for out,

XID_TYPE_INFORMATION  KeyboardTypeInfo = 
 {XID_DEVTYPE_KEYBOARD, XID_DEFAULT_MAX_KEYBOARD, XID_INPUT_REPORT_ID_MAX_KEYBOARD, XID_OUTPUT_REPORT_ID_MAX_KEYBOARD,
 XDEVICE_TYPE_DEBUG_KEYBOARD, KeyboardReportInfoList, KeyboardLEDReportInfoList, &KeyboardDefaultPolling, XID_ProcessNewKeyboardData,
 XID_BSF_NO_CAPABILITIES|XID_BSF_NO_OUTPUT_HEADER};

#pragma data_seg(".XID$Keyboard")
extern "C" ULONG_PTR KeyboardTypeInfoENTRY = (ULONG_PTR)&KeyboardTypeInfo;
#pragma data_seg(".XPP$Data")

//----------------------------------------------
//  IR Remote Reports
//----------------------------------------------
#define  XID_DEVTYPE_IRREMOTE              3
#define  XID_DEVSUBTYPE_MAX_IRREMOTE       1
#define  XID_INPUT_REPORT_ID_MAX_IRREMOTE  0
#define  XID_OUTPUT_REPORT_ID_MAX_IRREMOTE 0
#define XID_DEFAULT_MAX_IRREMOTE           1

DECLARE_XPP_TYPE(XDEVICE_TYPE_IR_REMOTE)
XINPUT_IR_REMOTE     IrRemoteDefaults = {0,0};
XID_REPORT_TYPE_INFO IrRemoteReportInfoList[1] = {sizeof(XINPUT_IR_REMOTE),(PVOID)&IrRemoteDefaults};
XINPUT_POLLING_PARAMETERS IrRemoteDefaultPolling = {TRUE,FALSE,0,16,0,0};  //AutoPoll On, Interrupt-OUT, 16 ms Input Poll Interval

XID_TYPE_INFORMATION  IrRemoteTypeInfo =
 {XID_DEVTYPE_IRREMOTE, XID_DEFAULT_MAX_IRREMOTE, XID_INPUT_REPORT_ID_MAX_IRREMOTE, XID_OUTPUT_REPORT_ID_MAX_IRREMOTE,
 XDEVICE_TYPE_IR_REMOTE, IrRemoteReportInfoList, NULL, &IrRemoteDefaultPolling, XID_ProcessIRRemoteData, 0};

#pragma data_seg(".XID$IrRemote")
extern "C" ULONG_PTR IrRemoteTypeInfoENTRY = (ULONG_PTR)&IrRemoteTypeInfo;
#pragma data_seg(".XPP$Data")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xkbd\kbd.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    kbd.cpp

Abstract:

    High-level Xbox keyboard support


Environment:

    Designed for XBOX.

Notes:

    
    
Revision History:

    12-20-00 created by Mitchell Dernis (mitchd)

--*/

//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>

//Nothing in here matters, if we don't have keyboard support enabled.
#include <kbd.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DBK'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("KBD");

//
//  Pull in public usb headers
//
#include <usb.h>
//
//  Pull in xid headers
//
#include "xid.h"
#include <xboxverp.h>

#pragma data_seg(".XBLD$V")
#if DBG
USHORT XKbdBuildNumberD[8] = { 'KX', 'DB', 'D', 0,
    VER_PRODUCTVERSION | 0x8000
#else
USHORT XKbdBuildNumber[8] = { 'KX', 'DB', 0, 0,
    VER_PRODUCTVERSION
#endif
};
#pragma data_seg(".XPP$Data")


//--------------------------------------------------------------------
//  Local Structure Definitions
//--------------------------------------------------------------------
typedef struct _XID_KEYBOARD_INSTANCE
{
    HANDLE                  hDevice;
    XINPUT_KEYBOARD         LastPacket;
    XINPUT_KEYBOARD_LEDS    KeyboardLeds;
    XINPUT_DEBUG_KEYSTROKE  *KeyQueue;
    ULONG                   QueueReadPos;
    ULONG                   QueueWritePos;
    XINPUT_DEBUG_KEYSTROKE  RepeatKeystroke;
    DWORD                   LastRepeatTick;
} XID_KEYBOARD_INSTANCE, *PXID_KEYBOARD_INSTANCE;

typedef struct _XID_KEYBOARD_STATE
{
#ifdef  SINGLE_KEYBOARD_ONLY
    XID_KEYBOARD_INSTANCE       Keyboards[1];
#else
    XID_KEYBOARD_INSTANCE       Keyboards[5];
#endif
    XINPUT_DEBUG_KEYQUEUE_PARAMETERS  QueueParameters;
} XID_KEYBOARD_STATE, *PXID_KEYBOARD_STATE;

XID_KEYBOARD_STATE XID_KeyboardState = {0};

//--------------------------------------------------------------------
// Keyboard Services Service Table for XID
//--------------------------------------------------------------------
void XID_KeyboardOpen(HANDLE hDevice);
void XID_KeyboardClose(HANDLE hDevice);
void XID_KeyboardRemove(HANDLE hDevice);
void XID_KeyboardNewData(HANDLE hDevice, XINPUT_KEYBOARD *pPacket);

XID_KEYBOARD_SERVICES XID_KeyboardServices =
{
    XID_KeyboardOpen,
    XID_KeyboardClose,
    XID_KeyboardRemove,
    XID_KeyboardNewData
};

//--------------------------------------------------------------------
// Local Utility Functions
//--------------------------------------------------------------------
BOOL XID_KeyboardInitQueue(int iInstance, DWORD dwQueueLength);
void XID_KeyboardReset(int iInstance);
void XID_KeyboardUpdate(int iInstance, XINPUT_KEYBOARD *pPacket);
XINPUT_DEBUG_KEYSTROKE *XID_KeyboardQueueGetWritePos(int iQueueIndex);
XINPUT_DEBUG_KEYSTROKE *XID_KeyboardQueueIncrementWritePos(int iQueueIndex);
VOID XID_KeyboardQueueHidKeystroke(UCHAR HidUsage, UCHAR Flags, PXINPUT_DEBUG_KEYSTROKE pKeystroke);
/*--------------------------------------------------------------------
 *  HID to VK_ convertion table.
 *----------------------------------------------
 *  HID_USAGE_INDEX_KEYBOARD_NOEVENT to 
 *  HID_USAGE_INDEX_KEYBOARD_UNDEFINED are not
 *  real keys, but so don't need convertion.
 *----------------------------------------------
 *  HID_USAGE_INDEX_KEYBOARD_aA to
 *  HID_USAGE_INDEX_KEYBOARD_zZ are
 *  not converted by lookup but rather by
 *  by adding (VK_A-HID_USAGE_INDEX_KEYBOARD_aA)
 *  to the HID usage.
 *
 *  NOTE: localization, may require a couple of
 *  substitutions in this range.
 *----------------------------------------------
 *  HID_USAGE_INDEX_KEYBOARD_ONE to 
 *  HID_USAGE_INDEX_KEYBOARD_NINE are
 *  not converted by lookeup but rather by
 *  adding (VK_1-HID_USAGE_INDEX_KEYBOARD_ONE)
 *  to the HID usage.
 *  (0 is last in HID, first in ASCII, so
 *  is just part of the lookup table)
 *----------------------------------------------
 **/

UCHAR HidToVK_Table[] =
{
/*HID_USAGE_INDEX_KEYBOARD_ZERO*/           '0',
/*HID_USAGE_INDEX_KEYBOARD_RETURN*/         VK_RETURN,
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE*/         VK_ESCAPE,
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE*/      VK_BACK,
/*HID_USAGE_INDEX_KEYBOARD_TAB*/            VK_TAB,
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR*/       VK_SPACE,
/*HID_USAGE_INDEX_KEYBOARD_MINUS*/          VK_OEM_MINUS,
/*HID_USAGE_INDEX_KEYBOARD_EQUALS*/         VK_OEM_PLUS,
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE*/     VK_OEM_4,
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE*/    VK_OEM_6,
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH*/      VK_OEM_5,
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE*/   VK_OEM_3,
/*HID_USAGE_INDEX_KEYBOARD_COLON*/          VK_OEM_1,
/*HID_USAGE_INDEX_KEYBOARD_QUOTE*/          VK_OEM_7,
/*HID_USAGE_INDEX_KEYBOARD_TILDE*/          VK_OEM_3,
/*HID_USAGE_INDEX_KEYBOARD_COMMA*/          VK_OEM_COMMA,
/*HID_USAGE_INDEX_KEYBOARD_PERIOD*/         VK_OEM_PERIOD,
/*HID_USAGE_INDEX_KEYBOARD_QUESTION*/       VK_OEM_2,
/*HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK*/      VK_CAPITAL,
/*HID_USAGE_INDEX_KEYBOARD_F1*/             VK_F1,
/*HID_USAGE_INDEX_KEYBOARD_F2*/             VK_F2,
/*HID_USAGE_INDEX_KEYBOARD_F3*/             VK_F3,
/*HID_USAGE_INDEX_KEYBOARD_F4*/             VK_F4,
/*HID_USAGE_INDEX_KEYBOARD_F5*/             VK_F5,
/*HID_USAGE_INDEX_KEYBOARD_F6*/             VK_F6,
/*HID_USAGE_INDEX_KEYBOARD_F7*/             VK_F7,
/*HID_USAGE_INDEX_KEYBOARD_F8*/             VK_F8,
/*HID_USAGE_INDEX_KEYBOARD_F9*/             VK_F9,
/*HID_USAGE_INDEX_KEYBOARD_F10*/            VK_F10,
/*HID_USAGE_INDEX_KEYBOARD_F11*/            VK_F11,
/*HID_USAGE_INDEX_KEYBOARD_F12*/            VK_F12,
/*HID_USAGE_INDEX_KEYBOARD_PRINT_SCREEN*/   VK_PRINT,
/*HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK*/    VK_SCROLL,
/*HID_USAGE_INDEX_KEYBOARD_PAUSE*/          VK_PAUSE,
/*HID_USAGE_INDEX_KEYBOARD_INSERT*/         VK_INSERT,
/*HID_USAGE_INDEX_KEYBOARD_HOME*/           VK_HOME,
/*HID_USAGE_INDEX_KEYBOARD_PAGE_UP*/        VK_PRIOR,
/*HID_USAGE_INDEX_KEYBOARD_DELETE*/         VK_DELETE,
/*HID_USAGE_INDEX_KEYBOARD_END*/            VK_END,
/*HID_USAGE_INDEX_KEYBOARD_PAGE_DOWN*/      VK_NEXT,
/*HID_USAGE_INDEX_KEYBOARD_RIGHT_ARROW*/    VK_RIGHT,
/*HID_USAGE_INDEX_KEYBOARD_LEFT_ARROW*/     VK_LEFT,
/*HID_USAGE_INDEX_KEYBOARD_DOWN_ARROW*/     VK_DOWN,
/*HID_USAGE_INDEX_KEYBOARD_UP_ARROW*/       VK_UP,
/*HID_USAGE_INDEX_KEYPAD_NUM_LOCK*/         VK_NUMLOCK,
/*HID_USAGE_INDEX_KEYPAD_BACKSLASH*/        VK_DIVIDE,
/*HID_USAGE_INDEX_KEYPAD_ASTERICK*/         VK_MULTIPLY,
/*HID_USAGE_INDEX_KEYPAD_MINUS*/            VK_SUBTRACT,
/*HID_USAGE_INDEX_KEYPAD_PLUS*/             VK_ADD,
/*HID_USAGE_INDEX_KEYPAD_ENTER*/            VK_SEPARATOR,
/*HID_USAGE_INDEX_KEYPAD_ONE*/              VK_NUMPAD1,
/*HID_USAGE_INDEX_KEYPAD_TWO*/              VK_NUMPAD2,
/*HID_USAGE_INDEX_KEYPAD_THREE*/            VK_NUMPAD3,
/*HID_USAGE_INDEX_KEYPAD_FOUR*/             VK_NUMPAD4,
/*HID_USAGE_INDEX_KEYPAD_FIVE*/             VK_NUMPAD5,
/*HID_USAGE_INDEX_KEYPAD_SIX*/              VK_NUMPAD6,
/*HID_USAGE_INDEX_KEYPAD_SEVEN*/            VK_NUMPAD7,
/*HID_USAGE_INDEX_KEYPAD_EIGHT*/            VK_NUMPAD8,
/*HID_USAGE_INDEX_KEYPAD_NINE*/             VK_NUMPAD9,
/*HID_USAGE_INDEX_KEYPAD_ZERO*/             VK_NUMPAD0,
/*HID_USAGE_INDEX_KEYPAD_DECIMAL*/          VK_DECIMAL,
/*HID_USAGE_INDEX_KEYBOARD_NON_US_BACKSLASH*/ VK_OEM_5,
/*HID_USAGE_INDEX_KEYBOARD_APPLICATION*/    VK_APPS,
/*HID_USAGE_INDEX_KEYBOARD_POWER*/          VK_SLEEP,
/*HID_USAGE_INDEX_KEYPAD_EQUALS*/           VK_OEM_NEC_EQUAL,    
/*HID_USAGE_INDEX_KEYBOARD_F13*/            VK_F13,
/*HID_USAGE_INDEX_KEYBOARD_F14*/            VK_F14,     
/*HID_USAGE_INDEX_KEYBOARD_F15*/            VK_F15,    
/*HID_USAGE_INDEX_KEYBOARD_F16*/            VK_F16,    
/*HID_USAGE_INDEX_KEYBOARD_F17*/            VK_F17,    
/*HID_USAGE_INDEX_KEYBOARD_F18*/            VK_F18,    
/*HID_USAGE_INDEX_KEYBOARD_F19*/            VK_F19,    
/*HID_USAGE_INDEX_KEYBOARD_F20*/            VK_F20,    
/*HID_USAGE_INDEX_KEYBOARD_F21*/            VK_F21,    
/*HID_USAGE_INDEX_KEYBOARD_F22*/            VK_F22,    
/*HID_USAGE_INDEX_KEYBOARD_F23*/            VK_F23,    
/*HID_USAGE_INDEX_KEYBOARD_F24*/            VK_F24,    
/*HID_USAGE_INDEX_KEYBOARD_EXECUTE*/        VK_EXECUTE,
/*HID_USAGE_INDEX_KEYBOARD_HELP*/           VK_HELP,
/*HID_USAGE_INDEX_KEYBOARD_MENU*/           VK_MENU,
/*HID_USAGE_INDEX_KEYBOARD_SELECT*/         VK_SELECT,
/*HID_USAGE_INDEX_KEYBOARD_STOP*/           VK_BROWSER_STOP,
/*HID_USAGE_INDEX_KEYBOARD_AGAIN*/          0,
/*HID_USAGE_INDEX_KEYBOARD_UNDO*/           0,
/*HID_USAGE_INDEX_KEYBOARD_CUT*/            0,
/*HID_USAGE_INDEX_KEYBOARD_COPY*/           0,
/*HID_USAGE_INDEX_KEYBOARD_PASTE*/          0,
/*HID_USAGE_INDEX_KEYBOARD_FIND*/           VK_BROWSER_SEARCH,
/*HID_USAGE_INDEX_KEYBOARD_MUTE*/           VK_VOLUME_MUTE,
/*HID_USAGE_INDEX_KEYBOARD_VOLUME_UP*/      VK_VOLUME_UP,
/*HID_USAGE_INDEX_KEYBOARD_VOLUME_DOWN*/    VK_VOLUME_DOWN,
/*HID_USAGE_INDEX_KEYBOARD_LOCKING_CAPS*/   0,
/*HID_USAGE_INDEX_KEYBOARD_LOCKING_NUM*/    0,
/*HID_USAGE_INDEX_KEYBOARD_LOCKING_SCROLL*/ 0,
/*HID_USAGE_INDEX_KEYPAD_COMMA*/            VK_DECIMAL, //Brazillian keyboards have comma instead of period
/*HID_USAGE_INDEX_KEYPAD_EQUALS_AS400*/     VK_OEM_NEC_EQUAL,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL1*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL2*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL3*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL4*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL5*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL6*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL7*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL8*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL9*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_LANG1*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG2*/          VK_HANJA,
/*HID_USAGE_INDEX_KEYBOARD_LANG3*/          VK_KANA,
/*HID_USAGE_INDEX_KEYBOARD_LANG4*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG5*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG6*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG7*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG8*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG9*/          0
};

UCHAR HidModifierToVK_Table[] =
{
/*HID_USAGE_INDEX_KEYBOARD_LCTRL*/  VK_LCONTROL,
/*HID_USAGE_INDEX_KEYBOARD_LSHFT*/  VK_LSHIFT,
/*HID_USAGE_INDEX_KEYBOARD_LALT*/   VK_LMENU,
/*HID_USAGE_INDEX_KEYBOARD_LGUI*/   VK_LWIN,
/*HID_USAGE_INDEX_KEYBOARD_RCTRL*/  VK_RCONTROL,
/*HID_USAGE_INDEX_KEYBOARD_RSHFT*/  VK_RSHIFT,
/*HID_USAGE_INDEX_KEYBOARD_RALT*/   VK_RMENU,
/*HID_USAGE_INDEX_KEYBOARD_RGUI*/   VK_RWIN
};

UCHAR HidSymToAscii_Table[] =
{
/*HID_USAGE_INDEX_KEYBOARD_ZERO*/           '0',
/*HID_USAGE_INDEX_KEYBOARD_RETURN*/         '\n',
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE*/         27,
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE*/      '\b',
/*HID_USAGE_INDEX_KEYBOARD_TAB*/            '\t',
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR*/       ' ',
/*HID_USAGE_INDEX_KEYBOARD_MINUS*/          '-',
/*HID_USAGE_INDEX_KEYBOARD_EQUALS*/         '=',
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE*/     '[',
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE*/    ']',
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH*/      '\\',
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE*/   '~',
/*HID_USAGE_INDEX_KEYBOARD_COLON*/          ';',
/*HID_USAGE_INDEX_KEYBOARD_QUOTE*/          '\'',
/*HID_USAGE_INDEX_KEYBOARD_TILDE*/          '`',
/*HID_USAGE_INDEX_KEYBOARD_COMMA*/          ',',
/*HID_USAGE_INDEX_KEYBOARD_PERIOD*/         '.',
/*HID_USAGE_INDEX_KEYBOARD_QUESTION*/       '/'
};

UCHAR HidSymToAsciiShift_Table[] =
{
/*HID_USAGE_INDEX_KEYBOARD_ONE*/            '!',
/*HID_USAGE_INDEX_KEYBOARD_TWO*/            '@',
/*HID_USAGE_INDEX_KEYBOARD_THREE*/          '#',
/*HID_USAGE_INDEX_KEYBOARD_FOUR*/           '$',
/*HID_USAGE_INDEX_KEYBOARD_FIVE*/           '%',
/*HID_USAGE_INDEX_KEYBOARD_SIX*/            '^',
/*HID_USAGE_INDEX_KEYBOARD_SEVEN*/          '&',
/*HID_USAGE_INDEX_KEYBOARD_EIGHT*/          '*',
/*HID_USAGE_INDEX_KEYBOARD_NINE*/           '(',
/*HID_USAGE_INDEX_KEYBOARD_ZERO*/           ')',
/*HID_USAGE_INDEX_KEYBOARD_RETURN*/         '\n',
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE*/         27,
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE*/      '\b',
/*HID_USAGE_INDEX_KEYBOARD_TAB*/            '\t',
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR*/       ' ',
/*HID_USAGE_INDEX_KEYBOARD_MINUS*/          '_',
/*HID_USAGE_INDEX_KEYBOARD_EQUALS*/         '+',
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE*/     '{',
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE*/    '}',
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH*/      '|',
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE*/   '~',
/*HID_USAGE_INDEX_KEYBOARD_COLON*/          ':',
/*HID_USAGE_INDEX_KEYBOARD_QUOTE*/          '\"',
/*HID_USAGE_INDEX_KEYBOARD_TILDE*/          '~',
/*HID_USAGE_INDEX_KEYBOARD_COMMA*/          '<',
/*HID_USAGE_INDEX_KEYBOARD_PERIOD*/         '>',
/*HID_USAGE_INDEX_KEYBOARD_QUESTION*/       '?'
};

UCHAR HidNumPadToAscii[] =
{
/*HID_USAGE_INDEX_KEYPAD_BACKSLASH*/        '/',
/*HID_USAGE_INDEX_KEYPAD_ASTERICK*/         '*',
/*HID_USAGE_INDEX_KEYPAD_MINUS*/            '-',
/*HID_USAGE_INDEX_KEYPAD_PLUS*/             '+',
/*HID_USAGE_INDEX_KEYPAD_ENTER*/            '\n',
/*HID_USAGE_INDEX_KEYPAD_ONE*/              0,
/*HID_USAGE_INDEX_KEYPAD_TWO*/              0,
/*HID_USAGE_INDEX_KEYPAD_THREE*/            0,
/*HID_USAGE_INDEX_KEYPAD_FOUR*/             0,
/*HID_USAGE_INDEX_KEYPAD_FIVE*/             0,
/*HID_USAGE_INDEX_KEYPAD_SIX*/              0,
/*HID_USAGE_INDEX_KEYPAD_SEVEN*/            0,
/*HID_USAGE_INDEX_KEYPAD_EIGHT*/            0,
/*HID_USAGE_INDEX_KEYPAD_NINE*/             0,
/*HID_USAGE_INDEX_KEYPAD_ZERO*/             0,
/*HID_USAGE_INDEX_KEYPAD_DECIMAL*/          127
};


UCHAR HidNumPadShiftToAscii[] =
{
/*HID_USAGE_INDEX_KEYPAD_BACKSLASH*/        '/',
/*HID_USAGE_INDEX_KEYPAD_ASTERICK*/         '*',
/*HID_USAGE_INDEX_KEYPAD_MINUS*/            '-',
/*HID_USAGE_INDEX_KEYPAD_PLUS*/             '+',
/*HID_USAGE_INDEX_KEYPAD_ENTER*/            '\n',
/*HID_USAGE_INDEX_KEYPAD_ONE*/              '1',
/*HID_USAGE_INDEX_KEYPAD_TWO*/              '2',
/*HID_USAGE_INDEX_KEYPAD_THREE*/            '3',
/*HID_USAGE_INDEX_KEYPAD_FOUR*/             '4',
/*HID_USAGE_INDEX_KEYPAD_FIVE*/             '5',
/*HID_USAGE_INDEX_KEYPAD_SIX*/              '6',
/*HID_USAGE_INDEX_KEYPAD_SEVEN*/            '7',
/*HID_USAGE_INDEX_KEYPAD_EIGHT*/            '8',
/*HID_USAGE_INDEX_KEYPAD_NINE*/             '9',
/*HID_USAGE_INDEX_KEYPAD_ZERO*/             '0',
/*HID_USAGE_INDEX_KEYPAD_DECIMAL*/          '.'
};

XBOXAPI
DWORD
WINAPI
XInputDebugInitKeyboardQueue(
    IN PXINPUT_DEBUG_KEYQUEUE_PARAMETERS pParameters OPTIONAL
    )
{
    BOOL fSuccess = TRUE;
    //
    // Store the parameters
    //
    if(pParameters)
    {
        RtlCopyMemory(&XID_KeyboardState.QueueParameters, pParameters, sizeof(XINPUT_DEBUG_KEYQUEUE_PARAMETERS));
    } else
    {
        XID_KeyboardState.QueueParameters.dwFlags = XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN |
                                                    XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT;
        XID_KeyboardState.QueueParameters.dwQueueSize = 40;
        XID_KeyboardState.QueueParameters.dwRepeatDelay = 400;
        XID_KeyboardState.QueueParameters.dwRepeatInterval = 100;
    }

    //
    //  Allocate Queue(s)
    //
    DWORD dwQueueLength = XID_KeyboardState.QueueParameters.dwQueueSize * sizeof(XINPUT_DEBUG_KEYSTROKE);
#ifdef  SINGLE_KEYBOARD_ONLY
    fSuccess = XID_KeyboardInitQueue(0, dwQueueLength);
#else
    if(XID_KeyboardState.QueueParameters.dwFlags & XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE)
    {
        fSuccess = XID_KeyboardInitQueue(0, dwQueueLength);
    } else
    {
        int i;
        for(i=0; i<4;i++)
        {
            fSuccess = XID_KeyboardInitQueue(i,dwQueueLength);
            if(!fSuccess)
            {
                while(--i >= 0)
                {
                    ExFreePool(XID_KeyboardState.Keyboards[i].KeyQueue);
                    XID_KeyboardState.Keyboards[i].KeyQueue = NULL;
                }
                return ERROR_OUTOFMEMORY;
            }
        }
    }
#endif

    if(fSuccess)
    {
        //
        //  Setup the Hook
        //
        XID_pKeyboardServices = &XID_KeyboardServices;
        return ERROR_SUCCESS;
    }
    return ERROR_OUTOFMEMORY;
}

XBOXAPI
DWORD
WINAPI
XInputDebugGetKeystroke(
#ifndef  SINGLE_KEYBOARD_ONLY
    IN HANDLE hDevice,
#endif // SINGLE_KEYBOARD_ONLY
    OUT PXINPUT_DEBUG_KEYSTROKE pKeystroke
    )
{

#ifdef  SINGLE_KEYBOARD_ONLY
    const int iQueueIndex=0;
#else
    int iQueueIndex = 0;
#endif
 
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwReadPos;
    KIRQL oldIrql;
    DWORD dwTickCount = 0;

    oldIrql = KeRaiseIrqlToDpcLevel();

#ifndef  SINGLE_KEYBOARD_ONLY
    if(hDevice == NULL)
    {
        if(!(XID_KeyboardState.QueueParameters.dwFlags&XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE))
        {
            KeLowerIrql(oldIrql);
            RIP("XInputDebugGetKeystroke: hDevice may only be NULL, if XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE was set.");
            oldIrql = KeRaiseIrqlToDpcLevel();
        }
    } else
    {
        for(iQueueIndex=0; iQueueIndex<4; iQueueIndex++)
        {
            if(hDevice == XID_KeyboardState.Keyboards[iQueueIndex].hDevice)
            {
                break;
            }
        }
    }
    if(4==iQueueIndex)
    {
       KeLowerIrql(oldIrql);
       RIP("XInputDebugGetKeystroke: hDevice is not valid.");
       return ERROR_INVALID_HANDLE;
    }
#endif //SINGLE_KEYBOARD_ONLY    

    dwTickCount = GetTickCount();
    if(dwTickCount == 0) dwTickCount = 1;
    dwReadPos = XID_KeyboardState.Keyboards[iQueueIndex].QueueReadPos;
    if( dwReadPos == XID_KeyboardState.Keyboards[iQueueIndex].QueueWritePos)
    {
        //
        //  Handle Repeat Count
        //
        DWORD dwTickCountDiff = dwTickCount - XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick;
        if(dwTickCountDiff > 2000) dwTickCountDiff = 0;
        if(
            (XID_KeyboardState.QueueParameters.dwFlags&XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT) &&
            XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick && 
            (dwTickCountDiff > XID_KeyboardState.QueueParameters.dwRepeatInterval)
        )
        {
            RtlCopyMemory(
                pKeystroke,
                &XID_KeyboardState.Keyboards[iQueueIndex].RepeatKeystroke,
                sizeof(XINPUT_DEBUG_KEYSTROKE)
                );
            XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick = dwTickCount;
        } else
        {
            dwError = ERROR_HANDLE_EOF;
        }
        goto ExitXInputGetKeyStroke;
    }
    
    RtlCopyMemory(
        pKeystroke,
        &XID_KeyboardState.Keyboards[iQueueIndex].KeyQueue[dwReadPos],
        sizeof(XINPUT_DEBUG_KEYSTROKE)
        );

    if(
        (XID_KeyboardState.QueueParameters.dwFlags&XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT)&&
        !(pKeystroke->Flags&XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP)
    )
    {
        RtlCopyMemory(
            &XID_KeyboardState.Keyboards[iQueueIndex].RepeatKeystroke,
            &XID_KeyboardState.Keyboards[iQueueIndex].KeyQueue[dwReadPos],
            sizeof(XINPUT_DEBUG_KEYSTROKE)
            );
        XID_KeyboardState.Keyboards[iQueueIndex].RepeatKeystroke.Flags |= XINPUT_DEBUG_KEYSTROKE_FLAG_REPEAT;
        dwTickCount += XID_KeyboardState.QueueParameters.dwRepeatDelay - XID_KeyboardState.QueueParameters.dwRepeatInterval;
        XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick = dwTickCount;
    }

    XID_KeyboardState.Keyboards[iQueueIndex].QueueReadPos = 
        (dwReadPos + 1)%XID_KeyboardState.QueueParameters.dwQueueSize;

ExitXInputGetKeyStroke:
    KeLowerIrql(oldIrql);
    return dwError;
}

void XID_KeyboardOpen(HANDLE hDevice)
{
#ifdef  SINGLE_KEYBOARD_ONLY
    if(NULL == XID_KeyboardState.Keyboards[0].hDevice)
    {
      XID_KeyboardState.Keyboards[0].hDevice = hDevice;
      XID_KeyboardReset(0);
    }
#else  // !SINGLE_KEYBOARD_ONLY
    //
    //  Find an empty keyboard instance
    //
    int i;
    for(i=0; i<4; i++)
    {
        if(NULL == XID_KeyboardState.Keyboards[i].hDevice)
        {
            XID_KeyboardState.Keyboards[i].hDevice = hDevice;
            XID_KeyboardReset(i);
            break;
        }
    }
#endif //SINGLE_KEYBOARD_ONLY
}

void XID_KeyboardClose(HANDLE hDevice)
{
#ifdef  SINGLE_KEYBOARD_ONLY
    if(hDevice == XID_KeyboardState.Keyboards[0].hDevice)
    {
        XID_KeyboardState.Keyboards[0].hDevice = NULL;
    }
#else
    int i;
    for(i=0; i<4; i++)
    {
        if(hDevice == XID_KeyboardState.Keyboards[i].hDevice)
        {
            XID_KeyboardState.Keyboards[i].hDevice = NULL;
            XID_KeyboardReset(i);
            break;
        }
    }
#endif //SINGLE_KEYBOARD_ONLY
}

void XID_KeyboardRemove(HANDLE hDevice)
{
    XID_KeyboardClose(hDevice);
}

void XID_KeyboardNewData(HANDLE hDevice, XINPUT_KEYBOARD *pPacket)
{
#ifdef  SINGLE_KEYBOARD_ONLY
    if(hDevice == XID_KeyboardState.Keyboards[0].hDevice)
    {
        XID_KeyboardUpdate(0, pPacket);
    }
#else
    int  i;
    for(i=0; i<4; i++)
    {
        if(hDevice == XID_KeyboardState.Keyboards[i].hDevice)
        {
            XID_KeyboardUpdate(i, pPacket);
            break;
        }
    }
#endif //SINGLE_KEYBOARD_ONLY
}

BOOL XID_KeyboardInitQueue(int iInstance, DWORD dwQueueLength)
{
    XID_KeyboardState.Keyboards[iInstance].KeyQueue = (PXINPUT_DEBUG_KEYSTROKE)ExAllocatePoolWithTag(
                                                                                    dwQueueLength,
                                                                                    'drbk'
                                                                                    );
    if(XID_KeyboardState.Keyboards[iInstance].KeyQueue)
    {
        XID_KeyboardState.Keyboards[iInstance].QueueReadPos = 0;
        XID_KeyboardState.Keyboards[iInstance].QueueWritePos = 0;
        XID_KeyboardState.Keyboards[iInstance].LastRepeatTick =0;
        return TRUE;
    } else
    {
        return FALSE;
    }
}

void XID_KeyboardReset(int iInstance)
{
    XID_KeyboardState.Keyboards[iInstance].KeyboardLeds.LedStates = 0;
    RtlZeroMemory(&XID_KeyboardState.Keyboards[iInstance].LastPacket,sizeof(XINPUT_KEYBOARD));
}


void XID_KeyboardUpdate(int iInstance, XINPUT_KEYBOARD *pPacket)
{
   
    BYTE oldModifiers;
    BYTE newModifiers;
    XINPUT_KEYBOARD DownKeys;
    XINPUT_KEYBOARD UpKeys;
    int index, iNewKeyIndex, iOldKeyIndex;
    UCHAR keyStrokeFlags;
    //
    //  Assume key queue is per keyboard, until we know differently.
    //
    int iQueueIndex = iInstance;


    //**
    //**    Figure out which keys were pressed and released.
    //**    A good deal of the following code is for the
    //**    special case of a mixing all keyboards into a 
    //**    single queue.
    //**
    
    //
    //  Calculate the old and new state of the modifiers across all combined queues
    //
#ifndef  SINGLE_KEYBOARD_ONLY
    if(XID_KeyboardState.QueueParameters.dwFlags&XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE)
    {
        iQueueIndex = 0;    //Change the queue to 0 since this is one queue
        oldModifiers = 0;
        newModifiers = 0;
        for(index = 0; index < 4; index++)
        {
            if(XID_KeyboardState.Keyboards[index].hDevice)
            {
                oldModifiers |= XID_KeyboardState.Keyboards[index].LastPacket.Modifiers;
                if((iInstance != index))
                {
                    newModifiers |= XID_KeyboardState.Keyboards[index].LastPacket.Modifiers;
                } else
                {
                    newModifiers |= pPacket->Modifiers;
                }
            }
        }
    } else
#endif //SINGLE_KEYBOARD_ONLY
    //
    //  Queues are not combined so do just this keyboard
    //
    {
        oldModifiers = XID_KeyboardState.Keyboards[iInstance].LastPacket.Modifiers;
        newModifiers = pPacket->Modifiers;
    }
    //
    //  Calculate the modifiers pressed and released
    //
    UpKeys.Modifiers = oldModifiers & ~newModifiers;
    DownKeys.Modifiers = ~oldModifiers & newModifiers;
    //
    //  Shut off key repeat if modifiers changed
    //
    if(oldModifiers != newModifiers)
    {
        XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick = 0;
    }
    
    //
    //  Calculate keys that went down (for this keyboard only)
    //
    for(iNewKeyIndex = 0; iNewKeyIndex<6; iNewKeyIndex++)
    {
        BOOL fAddKey = FALSE;
        UCHAR NewKey = pPacket->Keys[iNewKeyIndex];
        if(NewKey > HID_USAGE_INDEX_KEYBOARD_UNDEFINED)
        {
            fAddKey = TRUE;
            for(iOldKeyIndex = 0; iOldKeyIndex<6; iOldKeyIndex++)
            {
                if(NewKey == XID_KeyboardState.Keyboards[iInstance].LastPacket.Keys[iOldKeyIndex])
                {
                    fAddKey = FALSE;
                    break;
                }
            }
        }
        if(fAddKey)
        {
            XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick = 0;
            DownKeys.Keys[iNewKeyIndex] = NewKey;
        } else
        {
            DownKeys.Keys[iNewKeyIndex] = 0;
        }
    }

    //
    //  Calculate keys that went up (for this keyboard only)
    //
    for(iOldKeyIndex = 0; iOldKeyIndex<6; iOldKeyIndex++)
    {
        UCHAR OldKey = XID_KeyboardState.Keyboards[iInstance].LastPacket.Keys[iOldKeyIndex];
        BOOL fAddKey = FALSE;
        if(OldKey > HID_USAGE_INDEX_KEYBOARD_UNDEFINED)
        {
            fAddKey = TRUE;
            for(iNewKeyIndex = 0; iNewKeyIndex<6; iNewKeyIndex++)
            {
                if(OldKey == pPacket->Keys[iNewKeyIndex])
                {
                    fAddKey = FALSE;
                    break;
                }
            }
        }
        if(fAddKey)
        {
            XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick = 0;
            UpKeys.Keys[iOldKeyIndex] = OldKey;
        } else
        {
            UpKeys.Keys[iOldKeyIndex] = 0;
        }
    }

    //
    //  Now check up and down keys against other keyboards
    //  (if single queue).  Basically, a key cannot have gone up or down
    //  if it is down on another keyboard.
    //
#ifndef  SINGLE_KEYBOARD_ONLY
    if(XID_KeyboardState.QueueParameters.dwFlags&XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE)
    {
        for(index = 0; index < 4; index++)
        {
            if(XID_KeyboardState.Keyboards[index].hDevice && (iInstance != index))
            {   
                for(iNewKeyIndex = 0; iNewKeyIndex<6; iNewKeyIndex++)
                {
                    for(iOldKeyIndex = 0; iOldKeyIndex<6; iOldKeyIndex++)
                    {
                        UCHAR OldKey = XID_KeyboardState.Keyboards[index].LastPacket.Keys[iOldKeyIndex];
                        if(UpKeys.Keys[iNewKeyIndex]==OldKey)
                        {
                            UpKeys.Keys[iNewKeyIndex]=0;
                        }
                        if(DownKeys.Keys[iNewKeyIndex]==OldKey)
                        {
                            DownKeys.Keys[iNewKeyIndex]=0;
                        }
                    }
                }
            }
        }
    }
#endif //SINGLE_KEYBOARD_ONLY

    //
    //  Copy the packet into the last packet
    //
    RtlCopyMemory(&XID_KeyboardState.Keyboards[iInstance].LastPacket, pPacket, sizeof(XINPUT_KEYBOARD));

    //**
    //**  Calculate the new CapsLock, NumLock and ScrollLock states.
    //**    (The only left to do is the lock key checking.)
    
    BOOL fLedStateChange = FALSE;
    for(index =0; index < 6; index++)
    {
        switch(DownKeys.Keys[index])
        {
            case HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK:
                XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates ^= HID_KEYBOARDLED_MASK_SCROLL_LOCK;
                fLedStateChange = TRUE;
                break;
            case HID_USAGE_INDEX_KEYPAD_NUM_LOCK:
                XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates ^= HID_KEYBOARDLED_MASK_NUM_LOCK;
                fLedStateChange = TRUE;
                break;
            case HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK:
                XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates ^= HID_KEYBOARDLED_MASK_CAPS_LOCK;
                fLedStateChange = TRUE;
                break;
        }
    }
    //
    //  Kick off LED update state machine.
    //
    if(fLedStateChange)
    {
        //TODO SOMETIME WAY IN FUTURE, NOT PLANNED ANYTIME BEFORE INITIAL XBOX LAUNCH.   
    }

    //**
    //**  Queue Events
    //**
    XINPUT_DEBUG_KEYSTROKE *pKeystrokeBuffer = XID_KeyboardQueueGetWritePos(iQueueIndex);
    // Set the Ctrl, Shift and Alt Flags
    keyStrokeFlags = (newModifiers | (newModifiers >> 4)) & 0x07;
    //Add in the Lock flags
    if(HID_KEYBOARDLED_MASK_SCROLL_LOCK&XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates) 
            keyStrokeFlags |= XINPUT_DEBUG_KEYSTROKE_FLAG_SCROLLLOCK;
    if(HID_KEYBOARDLED_MASK_NUM_LOCK&XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates) 
            keyStrokeFlags |= XINPUT_DEBUG_KEYSTROKE_FLAG_NUMLOCK;
    if(HID_KEYBOARDLED_MASK_CAPS_LOCK&XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates) 
            keyStrokeFlags |= XINPUT_DEBUG_KEYSTROKE_FLAG_CAPSLOCK;

    // Stuff Modifier events in queue
    if(!(XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY&XID_KeyboardState.QueueParameters.dwFlags))
    {
        int i,mask;
        BOOL fSet;
        for(i = 0, mask=1; i < 8; i++, mask<<=1)
        {
            fSet = FALSE;
            // UpKeys
            if(XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP&XID_KeyboardState.QueueParameters.dwFlags)
            {
                if(UpKeys.Modifiers&mask)
                {
                    pKeystrokeBuffer->Flags = XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP;
                    fSet = TRUE;
                }
            }
            // DownKeys
            if(XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN&XID_KeyboardState.QueueParameters.dwFlags)
            {
                if(DownKeys.Modifiers&mask)
                {
                    pKeystrokeBuffer->Flags = 0;
                    fSet = TRUE;
                }
            }
            if(fSet)
            {
                pKeystrokeBuffer->Flags |= keyStrokeFlags;
                pKeystrokeBuffer->VirtualKey = HidModifierToVK_Table[i];
                pKeystrokeBuffer->Ascii = 0;
                pKeystrokeBuffer = XID_KeyboardQueueIncrementWritePos(iQueueIndex);
            }
        }
    }

    //
    //  Place normal key up in queue
    //
    if(XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP&XID_KeyboardState.QueueParameters.dwFlags)
    {
        for(iNewKeyIndex=0; iNewKeyIndex<6; iNewKeyIndex++)
        {
            if(UpKeys.Keys[iNewKeyIndex] > HID_USAGE_INDEX_KEYBOARD_UNDEFINED)
            {
                XID_KeyboardQueueHidKeystroke(
                    UpKeys.Keys[iNewKeyIndex],
                    XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP|keyStrokeFlags,
                    pKeystrokeBuffer
                    );
                if( 
                    !(XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY&XID_KeyboardState.QueueParameters.dwFlags) ||
                    (pKeystrokeBuffer->Ascii)
                )
                {
                    pKeystrokeBuffer = XID_KeyboardQueueIncrementWritePos(iQueueIndex);
                }
            }
        }
    }
    //**
    //**  Place key down events in 
    //**
    if(XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN&XID_KeyboardState.QueueParameters.dwFlags)
    {
        for(iNewKeyIndex=0; iNewKeyIndex<6; iNewKeyIndex++)
        {
            if(DownKeys.Keys[iNewKeyIndex] > HID_USAGE_INDEX_KEYBOARD_UNDEFINED)
            {
                XID_KeyboardQueueHidKeystroke(
                    DownKeys.Keys[iNewKeyIndex],
                    keyStrokeFlags,
                    pKeystrokeBuffer
                    );
                if( 
                    !(XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY&XID_KeyboardState.QueueParameters.dwFlags) ||
                    (pKeystrokeBuffer->Ascii)
                )
                {
                    pKeystrokeBuffer = XID_KeyboardQueueIncrementWritePos(iQueueIndex);
                }
            }
        }
    }
}

XINPUT_DEBUG_KEYSTROKE *XID_KeyboardQueueGetWritePos(int iQueueIndex)
{
    return &XID_KeyboardState.Keyboards[iQueueIndex].KeyQueue[XID_KeyboardState.Keyboards[iQueueIndex].QueueWritePos];
}

XINPUT_DEBUG_KEYSTROKE *XID_KeyboardQueueIncrementWritePos(int iQueueIndex)
{
    //
    //  Get write position and increment it.
    //
    ULONG ulWritePos = XID_KeyboardState.Keyboards[iQueueIndex].QueueWritePos;
    ulWritePos = (ulWritePos+1)%XID_KeyboardState.QueueParameters.dwQueueSize;
    
    //
    //  Check for a full queue, and just don't increment.
    //
    if(XID_KeyboardState.Keyboards[iQueueIndex].QueueReadPos==ulWritePos)
    {
        ulWritePos = XID_KeyboardState.Keyboards[iQueueIndex].QueueWritePos;
    }else
    {
        XID_KeyboardState.Keyboards[iQueueIndex].QueueWritePos = ulWritePos;
    }
    
    //
    //  Return the next open keystroke position
    //
    return &XID_KeyboardState.Keyboards[iQueueIndex].KeyQueue[ulWritePos];    
}

VOID XID_KeyboardQueueHidKeystroke(UCHAR HidUsage, UCHAR Flags, PXINPUT_DEBUG_KEYSTROKE pKeystroke)
{
    UCHAR Shift = (XINPUT_DEBUG_KEYSTROKE_FLAG_SHIFT&Flags) ? 1 : 0;
    UCHAR CapsLock = (XINPUT_DEBUG_KEYSTROKE_FLAG_CAPSLOCK&Flags) ? 1 : 0;
    UCHAR NumLock = (XINPUT_DEBUG_KEYSTROKE_FLAG_NUMLOCK&Flags) ? 1 : 0;
    ASSERT(HidUsage > HID_USAGE_INDEX_KEYBOARD_UNDEFINED);
    pKeystroke->Flags = Flags;
    pKeystroke->Ascii = 0;
    //
    //  Check for A to Z range
    //  The VK_A and VK_Z are not defined, but are the same as 'A' to 'Z'.
    //  For ASCII we do the following:
    //      If alt is down the ASCII is 0 regardless of anything else.
    //      If ctrl is down and not shift, then it ^A to ^Z which is a
    //       contiguous ASCII range from 1 to 26.
    //      If CapsLock XOR Shift it is 'A' to 'Z', otherwise it is 'a' to 'z'.
    //       (Unfortunately there is no logical XOR operator)
    if( 
        (HidUsage >= HID_USAGE_INDEX_KEYBOARD_aA) &&
        (HidUsage <= HID_USAGE_INDEX_KEYBOARD_zZ)
    ){
        pKeystroke->VirtualKey = HidUsage + ('A' - HID_USAGE_INDEX_KEYBOARD_aA);
        //
        //  Figure out the ASCII
        //
         if(!(XINPUT_DEBUG_KEYSTROKE_FLAG_ALT & Flags))
        {
            if(XINPUT_DEBUG_KEYSTROKE_FLAG_CTRL & Flags)
            {
                if(!Shift)
                {
                    // Control
                    pKeystroke->Ascii = HidUsage - (HID_USAGE_INDEX_KEYBOARD_aA - 1);
                }
            }else
            {
                if(Shift^CapsLock)
                {
                    pKeystroke->Ascii = HidUsage + ('A' - HID_USAGE_INDEX_KEYBOARD_aA);
                } else
                {
                    pKeystroke->Ascii = HidUsage + ('a' - HID_USAGE_INDEX_KEYBOARD_aA);
                }
            }
        }
    }
    //
    //  check 1-9 range
    //
    else if(
        (HidUsage >= HID_USAGE_INDEX_KEYBOARD_ONE) &&
        (HidUsage <= HID_USAGE_INDEX_KEYBOARD_NINE)
    )
    {
        pKeystroke->VirtualKey = HidUsage + ('1' - HID_USAGE_INDEX_KEYBOARD_ONE);
        if(Shift)
        {
            pKeystroke->Ascii = HidSymToAsciiShift_Table[HidUsage-HID_USAGE_INDEX_KEYBOARD_ONE];
        } else
        {
            pKeystroke->Ascii = pKeystroke->VirtualKey;
        }
        
    } else
    //
    //  Use the lookup table to get the Virtual Key.
    //
    //  There are special ranges that require additional lookup
    //  for ASCII.  The numpad keys have wo tables, a (shifted xor numlock) table
    //  and two symbol lookup table, shifted only (caps lock doesn't effect it).
    //
    {
        pKeystroke->VirtualKey = HidToVK_Table[HidUsage-HID_USAGE_INDEX_KEYBOARD_ZERO];
        if(HidUsage <= HID_USAGE_INDEX_KEYBOARD_QUESTION)
        {
            if(Shift)
            {
                pKeystroke->Ascii = HidSymToAsciiShift_Table[HidUsage-HID_USAGE_INDEX_KEYBOARD_ONE];
            } else
            {
                pKeystroke->Ascii = HidSymToAscii_Table[HidUsage-HID_USAGE_INDEX_KEYBOARD_ZERO];
            }
        }  else if(
                (HidUsage >= HID_USAGE_INDEX_KEYPAD_BACKSLASH) &&
                (HidUsage <= HID_USAGE_INDEX_KEYPAD_DECIMAL)
            )
        {
            if(Shift^NumLock)
            {
                pKeystroke->Ascii = HidNumPadShiftToAscii[HidUsage-HID_USAGE_INDEX_KEYPAD_BACKSLASH];
            } else
            {
                pKeystroke->Ascii = HidNumPadToAscii[HidUsage-HID_USAGE_INDEX_KEYPAD_BACKSLASH];
            }
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xid\xidinp.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    input.c

Abstract:
    
    Implementation of the Input API
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    03-07-00 created by Mitchell Dernis (mitchd)
    12-06-00 changed synchronization scheme
--*/

//
//  Pull in OS headers
//
#define _XAPI_
#define _KERNEL32_ //since we are linked to XAPI for now.
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>
#include <xapidrv.h>
#include <xdbg.h>
#include <stdio.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("INPUT");

//
//  Pull in public usb headers
//
#include <usb.h>

//
//  Pull in xid headers
//
#include "xid.h"

//--------------------------------------------------------------
//  Handle Verification
//--------------------------------------------------------------
#if DBG //Debug version verifies handles.
#define XID_VERIFY_HANDLES 
#endif
#ifdef XID_VERIFY_HANDLES

PXID_OPEN_DEVICE XID_OpenDeviceList = NULL;
VOID XidInsertHandle(PXID_OPEN_DEVICE OpenDevice);
VOID XidRemoveHandle(PXID_OPEN_DEVICE OpenDevice);
VOID XidCheckHandle(PCHAR ApiName, PXID_OPEN_DEVICE OpenDevice);

#define XID_INSERT_HANDLE(OpenDevice) XidInsertHandle(OpenDevice)
#define XID_REMOVE_HANDLE(OpenDevice) XidRemoveHandle(OpenDevice)
#define XID_CHECK_HANDLE(ApiName, OpenDevice) XidCheckHandle(ApiName, OpenDevice)

#else

#define XID_INSERT_HANDLE(OpenDevice) do{}while(0)
#define XID_REMOVE_HANDLE(OpenDevice) do{}while(0)
#define XID_CHECK_HANDLE(ApiName,OpenDevice) do{}while(0)
    
#endif

//--------------------------------------------------------------
//  Implementation
//--------------------------------------------------------------
XBOXAPI
HANDLE
WINAPI
XInputOpen(
    IN PXPP_DEVICE_TYPE XppDeviceType,
    IN DWORD dwPort,
    IN DWORD dwSlot,
    IN PXINPUT_POLLING_PARAMETERS pPollingParameters OPTIONAL
    )
/*++
    Routine Description:
        Public API to open a handle to an input device.
  
    Arguments:
        XppDeviceType       - device type to open.
        dwPort              - Port of device to open.
        dwSlot              - Slot of device to open.
        pPollingParameters  - [optional] polling parameters to use with device.

    Return Value:
        On success, handle to be used to access device.
        On failure, NULL.  Call GetLastError for specific error code.
        
          ERROR_SHARING_VIOLATION    - attempt to open more than one handle to a single device.
          ERROR_OUTOFMEMORY          - there was not enough memory to open the handle.
          ERROR_INVALID_PARAMETER    - the device type was not known.
          ERROR_DEVICE_NOT_CONNECTED - a device was not found of the given type in the specified
                                       port and slot.
          ERROR_IO_DEVICE            - an error occured talking to the device.

--*/
{
    UCHAR              xidType;
    DWORD              errorCode;
    PXID_OPEN_DEVICE   openDevice = NULL;

    ASSERT_LESS_THAN_DISPATCH_LEVEL();

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XInputOpen: XInitDevices must be called first!");
    
    //
    //  Convert the XppDeviceType to a XID type
    //
    if(XDEVICE_TYPE_GAMEPAD == XppDeviceType)
    {
        xidType = XID_DEVTYPE_GAMECONTROLLER;
    } else
#ifdef DEBUG_KEYBOARD
    if(XDEVICE_TYPE_DEBUG_KEYBOARD == XppDeviceType)
    {
        xidType = XID_DEVTYPE_KEYBOARD;
    } else
#endif //DEBUG_KEYBOARD
    if(XDEVICE_TYPE_IR_REMOTE == XppDeviceType)
    {
        xidType = XID_DEVTYPE_IRREMOTE;
    } else
    {        
        RIP("XInputOpen: XppDeviceType is not a valid type for the XInputXXX API\n");
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    //  RIP port and slot parameters
    //
    RIP_ON_NOT_TRUE(XInputOpen, dwPort<XGetPortCount());

    #if DBG
    switch(xidType)
    {
        
        case XID_DEVTYPE_GAMECONTROLLER:
        case XID_DEVTYPE_KEYBOARD:
        case XID_DEVTYPE_IRREMOTE:
            //
            //  The only valid value for Game Controllers is XDEVICE_NO_SLOT.
            //
            RIP_ON_NOT_TRUE(XInputOpen, (dwSlot == XDEVICE_NO_SLOT));
            break;
        default:
            //
            //  If this is reached it is a bug in XInputOpen.  It means the non-debug only
            //  code above that turns a XppDeviceType into a XidType is broken, or
            //  this switch statement does not contain all of the XidTypes.
            //
            ASSERT(FALSE);
    };
    #endif
       
    //
    //  If the polling parameters are NULL, look up the defaults based on type.
    //
    if(NULL == pPollingParameters)
    {
        pPollingParameters = XID_TypeInformationList[xidType].DefaultPollingParameters;
    }
    
    //
    //  Open the device
    //
    errorCode = XID_fOpenDevice(
                        xidType,
                        (dwSlot != XDEVICE_BOTTOM_SLOT) ? dwPort : dwPort +16,
                        &openDevice,
                        pPollingParameters
                        );

    //
    //  If the open failed, set the error code.
    //
    if(NULL==openDevice)
    {
        SetLastError(errorCode);
    }
    else
    {
        //
        //  Insert the handle into the list of 
        //  valid handles.
        //
        XID_INSERT_HANDLE(openDevice);
    }
    return (HANDLE)openDevice;
}  

XBOXAPI
void
WINAPI
XInputClose(
    IN HANDLE hDevice
    )
/*++

    Routine Description:
        Public API to close a handle to an input device.
  
    Arguments:
        XppDeviceType       - device type to open.
        dwPort              - Port of device to open.
        dwSlot              - Slot of device to open.
        pPollingParameters  - [optional] polling parameters to use with device.

    Return Value:
        None    
    Remarks:
        Close can block for several milliseconds while resources are being cleaned up.
        
        It is the callers responsibility not to use a handle after XInputClose has been
        called.  It is particularly risky with multiple threads.
            * No other call to an XInputXXX API using the handle should be started after
              XInputClose has been called, even if XInputClose has not yet returned.
            * XInputClose must not be called until all other XInputXXX API's using the handle
              have returned.
        In debug builds, an attempt is made to detect these conditions and RIP, however, the
        RIP's are not full-proof, and under some circumstances, may miss such a condition.
        If these rules are violated the result is undefined, in many cases this will lead to
        memory corruption and system crash.

        One should normally wait for asynchronous I/O (started with XInputSetState) to complete
        before calling XInputClose, however, it is not an error to call XInputClose with 
        asynchronous I/O pending.  The result is that pending I/O is guaranteed to complete,
        usually with status set to ERROR_CANCELLED, before XInputClose returns.

--*/
{
    PXID_OPEN_DEVICE openDevice = (PXID_OPEN_DEVICE)hDevice;
    ASSERT_LESS_THAN_DISPATCH_LEVEL();
    XID_REMOVE_HANDLE(openDevice);
    XID_fCloseDevice(openDevice);
    return;
}

XBOXAPI
DWORD
WINAPI
XInputGetCapabilities(
    IN HANDLE hDevice,
    OUT PXINPUT_CAPABILITIES pCapabilities
    )
/*++
    Routine Description:
        Public API to retrieve capabilities from a device.
    Arguments:
        hDevice - handle to device for which to get capabilities.
        pCapabilities - pointer to buffer to get capabilities.
    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - if the device is no longer connected.
        ERROR_IO_DEVICE - problem communicating with the device.
    Remarks:
        This routine blocks while the device is queried.  This can take
        a few milliseconds.
--*/
{
    PCHAR                  pReportBuffer;
    ULONG                  length;
    URB_CONTROL_TRANSFER   urb;
    KEVENT                 event;
    KIRQL                  oldIrql;
    PXID_DEVICE_NODE       xidNode;
    DWORD                  errorCode = ERROR_SUCCESS;
    PXID_OPEN_DEVICE       openDevice = (PXID_OPEN_DEVICE)hDevice;

    ASSERT_LESS_THAN_DISPATCH_LEVEL();

    //
    //  Raise Irql for synchronization
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputGetCapabilities", openDevice);
 
    //
    //  Make sure device is connected
    //
    xidNode = openDevice->XidNode;
    if( NULL == xidNode || xidNode->PendingRemove)
    {   
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_input_get_caps;
    }

    //
    //  Zero the whole output buffer
    //
    RtlZeroMemory(pCapabilities, sizeof(XINPUT_CAPABILITIES));

    //
    //  Fill in the subtype, that doesn't depend on the report being queried
    //  so even if this fails with invalid parameter, we can check it.
    //
    pCapabilities->SubType = xidNode->SubType;
    
    //
    //  Make sure that the device supports GET_CAPABILITIES.
    //  This check is primarily for legacy devices, in particular
    //  legacy keyboards.
    //
    if(XID_TypeInformationList[xidNode->Type].ulFlags&XID_BSF_NO_CAPABILITIES)
    {
        errorCode = ERROR_ACCESS_DENIED;
    }
    else
    {
        //
        //  Get the output portion
        //
        pReportBuffer = (PCHAR)&pCapabilities->Out;
        length = XID_TypeInformationList[xidNode->Type].pOutputReportInfoList[0].bCurrentSize;

        //
        //  Build the URB
        //
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        USB_BUILD_CONTROL_TRANSFER(
                &urb,
                NULL,
                (PVOID)(pReportBuffer-2),
                length+2,
                USB_TRANSFER_DIRECTION_IN,
                (PURB_COMPLETE_PROC)XID_SyncComplete,
                &event,
                TRUE,
                USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE,
                XID_COMMAND_GET_CAPABILITIES,
                0x0200,
                xidNode->InterfaceNumber,
                length+2
                );

        //
        //  Submit the request.
        //
        xidNode->Device->SubmitRequest((PURB)&urb);
    
        //
        //  Wait for transfer to complete
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  Recheck the handle (should not have been closed)
        //
        XID_CHECK_HANDLE("XInputGetCapabilities", openDevice);

        //
        //  Make sure the device wasn't removed
        //  in the interm. 
        //  
        if( NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_input_get_caps;
        }

        //
        //  Check for error
        //
        if(USBD_ERROR(urb.Hdr.Status))
        {
            errorCode = IUsbDevice::Win32FromUsbdStatus(urb.Hdr.Status);
            goto exit_input_get_caps;
        }

        //
        //  Now get the input portion
        //
        pReportBuffer = (PCHAR)&pCapabilities->In;
        length = XID_TypeInformationList[xidNode->Type].pInputReportInfoList[0].bCurrentSize;

        //
        //  Build the URB
        //
        USB_BUILD_CONTROL_TRANSFER(
                &urb,
                NULL,
                (PVOID)(pReportBuffer-2),
                length+2,
                USB_TRANSFER_DIRECTION_IN,
                (PURB_COMPLETE_PROC)XID_SyncComplete,
                &event,
                TRUE,
                USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE,
                XID_COMMAND_GET_CAPABILITIES,
                0x0100,
                xidNode->InterfaceNumber,
                length+2
                );
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        xidNode->Device->SubmitRequest((PURB)&urb);

        //
        //  Wait for transfer to complete
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  Make sure the device wasn't removed
        //  in the interm.
        //
        if( NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_input_get_caps;
        }

        //
        //  Check for error
        //
        if(USBD_ERROR(urb.Hdr.Status))
        {
            errorCode = IUsbDevice::Win32FromUsbdStatus(urb.Hdr.Status);
            goto exit_input_get_caps;
        }
    }

exit_input_get_caps:
    //Bug 2578, make sure nobody tries to falsely divine information
    //from the reserved field.
    pCapabilities->Reserved = 0;
    KeLowerIrql(oldIrql);
    return errorCode;
}

XBOXAPI
DWORD
WINAPI
XInputGetState(
    IN HANDLE hDevice,
    OUT PXINPUT_STATE  pState
    )
/*++
    Routine Description:
        Public API for retrieving the latest known state of the
        device.  This routine does not actually perform I/O it
        just copies the latest known state into the caller's buffer.

        
    Arguments:
        hDevice - handle of device to get state for.
        pState  - buffer to receive state.

    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - device no longer connected (buffer is still copied).
--*/
{
    PXID_OPEN_DEVICE    openDevice = (PXID_OPEN_DEVICE) hDevice;
    DWORD               errorCode = ERROR_SUCCESS;
    KIRQL               oldIrql;
    ULONG               length;
    
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputGetState", openDevice);

    //
    //  Don't allow keyboards to work
    //
#ifdef DEBUG_KEYBOARD
    if(XID_DEVTYPE_KEYBOARD == openDevice->Type)
    {
        KeLowerIrql(oldIrql);
        RIP("XInputGetState does not work for keyboards.");
        return ERROR_INVALID_PARAMETER;
    }
#endif //DEBUG_KEYBOARD

    //
    //  If the device is not connected, mark it, but copy the
    //  data anyway.
    //
    if(NULL == openDevice->XidNode || openDevice->XidNode->PendingRemove)
    {
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
    }
    
    //
    //  Copy packet number
    //
    pState->dwPacketNumber = openDevice->PacketNumber;
    
    //
    //  Copy the size indicated in the capatibility table.
    //
    length = XID_TypeInformationList[openDevice->Type].pInputReportInfoList[0].bCurrentSize;
    
    //
    //  Copy the latest report (We are using GameReport, but we could
    //                          use any member of the union of report types)
    RtlCopyMemory( (PVOID)&pState->Gamepad, (PVOID)openDevice->Report, length);
    
    
    KeLowerIrql(oldIrql);
    return errorCode;
}

XBOXAPI
DWORD
WINAPI
XInputSetState(
    IN HANDLE hDevice,
    OUT PXINPUT_FEEDBACK pFeedback
    )
/*++
    Routine Description:
        Public API for sending data to the device.
        THIS IS ASYNCHRONOUS!!!
    
    Arguments:
        hDevice - handle of device to send data to.
        pFeedback - feedback data to send

    Return Value:
        ERROR_IO_PENDING - on sucess.
        ERROR_DEVICE_NOT_CONNECTED - the device is no longer connected,

    Remarks:
        Calling XInputSetState programs output to the device.  This output could a few to many
        milliseconds to complete depending on the pPollingParameters passed to XInputOpen.
        During this time XAPI owns pFeedback, the caller should consider it read only.

        There are two options for synchronization:
            
        1) If the caller sets pFeedback->Header.hEvent to a valid event handle, it will
           be signaled when the I/O completes, otherwise hEvent should be NULL.
        2) The caller may poll pFeedback->Header.dwStatus.  This will be ERROR_IO_PENDING
           when XInputSetState returns, it will change to ERROR_SUCCESS or another (non-pending)
           error code when the transfer completes, successfully or otherwuse.

        Calling XInputClose before the I/O complete cancels the I/O.  pFeedback->Header.hEvent
        (if a valid event) will be signaled before XInputClose returns,and pFeedback->Header.dwStatus
        will change to ERROR_CANCELLED.

--*/
{
    PXID_OPEN_DEVICE         openDevice = (PXID_OPEN_DEVICE) hDevice;
    PXINPUT_FEEDBACK_INTERNAL feedback = (PXINPUT_FEEDBACK_INTERNAL)pFeedback;
    
    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputSetState", openDevice);

    //
    //  Don't allow keyboards to work
    //
#ifdef DEBUG_KEYBOARD
    if(XID_DEVTYPE_KEYBOARD == openDevice->Type)
    {
        RIP("XInputSetState does not work for keyboards.");
        return ERROR_INVALID_PARAMETER;
    }
#endif //DEBUG_KEYBOARD

    //
    //  Check Handle the report ID, before
    //  passing down.
    //
    feedback->Internal.bReportId = 0;
    feedback->Internal.bSize = XID_TypeInformationList[openDevice->Type].pOutputReportInfoList[0].bCurrentSize + XID_REPORT_HEADER;
    return XID_fSendDeviceReport(openDevice, feedback);
}


XBOXAPI
DWORD
WINAPI
XInputPoll(
        IN HANDLE hDevice
        )
/*++
    Routine Description:
        Public API for manually polling an input device.
    
    Arguments:
        hDevice - handle of device to poll.
    
    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - if the device is no longer connected.

    Remarks:
        This API only needs to be called if XInputOpen was called with
        pPollingParameter->fAutoPoll set to FALSE.  Otherwise, it is
        a no-op.

        XInputGetState should be updated to return the latest state of the device
        no later than (pPollingParameter->bInputInterval + 1) ms, after XInputPoll
        is called.

--*/
{
    DWORD               errorCode = ERROR_SUCCESS;    
    PXID_OPEN_DEVICE    openDevice = (PXID_OPEN_DEVICE)hDevice;
    PXID_DEVICE_NODE    xidNode;
    KIRQL               oldIrql = KeRaiseIrqlToDpcLevel();
    
    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputPoll", openDevice);

    //
    //  Make sure device is connected
    //
    xidNode = openDevice->XidNode;
    if(NULL == xidNode || xidNode->PendingRemove)
    {   
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
    } else
    {
        if(!openDevice->AutoPoll)
        {
            if(!openDevice->OutstandingPoll)
            {   
                openDevice->OutstandingPoll = 1;
                #ifdef ALAMO_RAW_DATA_HACK
                if(xidNode->AlamoHack) XID_AlamoStartPoll(openDevice);
                else {
                #endif
                openDevice->Urb.BulkOrInterruptTransfer.TransferBufferLength = 
                                            openDevice->XidNode->bMaxInputReportSize;
                openDevice->XidNode->Device->SubmitRequest(&openDevice->Urb);  
                #ifdef ALAMO_RAW_DATA_HACK
                }
                #endif
            }
        }
    }

    KeLowerIrql(oldIrql);
    return errorCode;
}


//---------------------------------------------------------------------
//  Debug routine that keep track of open handles, and generate
//  RIP's when they are not valid.
//---------------------------------------------------------------------
#ifdef XID_VERIFY_HANDLES

VOID XidInsertHandle(PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    OpenDevice->NextOpenDevice = XID_OpenDeviceList;
    XID_OpenDeviceList = OpenDevice;
    KeLowerIrql(oldIrql);
}

VOID XidRemoveHandle(PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    PXID_OPEN_DEVICE previousDevice = NULL;
    PXID_OPEN_DEVICE device = XID_OpenDeviceList;
    BOOL found = FALSE;
    while(device)
    {
        if(device == OpenDevice)
        {
            if(previousDevice)
            {
                previousDevice->NextOpenDevice = device->NextOpenDevice;
            } else
            {
                XID_OpenDeviceList = device->NextOpenDevice;
            }
            found = TRUE;
            break;
        }
        previousDevice = device;
        device = device->NextOpenDevice;
    }
    KeLowerIrql(oldIrql);
    
    if(!found)
    {
        RIP("XInputClose: Invalid Handle\n");
    }

    return;    
}

VOID XidCheckHandle(CHAR *ApiName, PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    PXID_OPEN_DEVICE device = XID_OpenDeviceList;
    BOOL found = FALSE;
    while(device)
    {
        if(device == OpenDevice)
        {
            found = TRUE;
            break;
        }
        device = device->NextOpenDevice;
    }
    
    //
    //  BUG 9292 - cannot RIP at DISPATCH_LEVEL.  This hangs the machine when debugging
    //             with VC.  We were lowering IRQL to oldIrql before the RIP, but since
    //             this routine is usually called at DISPATCH_LEVEL, this is not good enough.
    //             Note that since this routine is NEVER called from a true DPC, it is always
    //             possible to explictly lower IRQL to PASSIVE_LEVEL.  We only want to do this
    //             though when we are going to RIP.  In that case, the system is already hosed
    //             and we do not lose any sleep over completely hosing it.
    //
    if(!found)
    {
        KeLowerIrql(PASSIVE_LEVEL);
        CHAR buffer[255];
        sprintf(buffer, "%s: Invalid Handle(0x%0.8x)\n", ApiName, OpenDevice);
        RIP(buffer);
        KIRQL dummyIrql;
        KeRaiseIrql(oldIrql, &dummyIrql);  // A feeble attempt to keep the system running after the RIP.
    } else
    {
        KeLowerIrql(oldIrql);
    }

    return;
}

#endif //XID_VERIFY_HANDLES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xidex\xid.h ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    xid.h

Abstract:

    Structures and functions used through the XID driver.
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    02-22-00 created by Mitchell Dernis (mitchd)

--*/

#ifndef __XID_H__
#define __XID_H__

//-----------------------------------------------
// Byte align all the structures
//-----------------------------------------------
#include <PSHPACK1.H>

//------------------------------------------------------------
// Define pointers to the various types declared in this file.
// This breaks some declaration order dependencies.
//------------------------------------------------------------
typedef struct _XID_TYPE_INFORMATION    *PXID_TYPE_INFORMATION;
typedef struct _XID_DESCRIPTOR          *PXID_DESCRIPTOR;
typedef struct _XID_DEVICE_NODE         *PXID_DEVICE_NODE;
typedef struct _XINPUT_FEEDBACK_HEADER_INTERNAL *PXINPUT_FEEDBACK_HEADER_INTERNAL;
typedef struct _XINPUT_FEEDBACK_INTERNAL *PXINPUT_FEEDBACK_INTERNAL;
typedef struct _XID_OPEN_DEVICE         *PXID_OPEN_DEVICE;
typedef struct _XID_GLOBALS             *PXID_GLOBALS;

//-----------------------------------------------
// Constants for legacy devices - keyboards
//-----------------------------------------------
#define HID_KEYBOARD_PROTOCOL 0x01
#define HID_SET_PROTOCOL      0x0B
#define HID_BOOT_PROTOCOL     0x00
#define HID_SET_IDLE          0x0A
#define HID_IDLE_INFINITE     0x00

//--------------------------------------------------
//  XINPUT_KEYBOARD is not defined in public headers
//  since we ripped out low-level support
//--------------------------------------------------
typedef struct _XINPUT_KEYBOARD
{
    BYTE Modifiers;
    BYTE Reserved;
    BYTE Keys[6];
} XINPUT_KEYBOARD, *PXINPUT_KEYBOARD;
typedef struct _XINPUT_KEYBOARD_LEDS
{
    BYTE LedStates;
} XINPUT_KEYBOARD_LEDS, *PXINPUT_KEYBOARD_LEDS;

//-----------------------------------------------
// Constants defined in the XID specification
//-----------------------------------------------
#define XID_COMMAND_GET_CAPABILITIES    0x01
#define XID_COMMAND_GET_REPORT          0x01
#define XID_COMMAND_SET_REPORT          0x09
#define XID_MAXIMUM_REPORT_SIZE         32
#define XID_DESCRIPTOR_TYPE             0x4200
#define XID_REPORT_TYPE_INPUT           0x01
#define XID_REPORT_TYPE_OUTPUT          0x02
#define XID_IS_INPUT_REPORT(wReportId)  ((wReportId >> 8) == XID_REPORT_TYPE_INPUT)
#define XID_GET_REPORT_ID(wReportId)    (wReportId&0xFF)
#define XID_REPORT_HEADER               0x02 //The Report ID and Size is the header.

//------------------------------------------------
// Device types that we may\need to map legacy device to.
//------------------------------------------------
#define  XID_DEVTYPE_GAMECONTROLLER        1
#define  XID_DEVTYPE_KEYBOARD              2

//  Right now we have a device that plugs directly into the box,
//  So it is only physically possible to have ine device per port.
//  If we add a high power device, this should be two.  If we add
//  a low power device, this should be three.  In the future, we can
//  expand the table to include the connector type for registration.
#define XID_MAX_DEVICE_PER_PORT           1

//-----------------------------------------------------------------------
// Structures for the device information table
//-----------------------------------------------------------------------
typedef void (FASTCALL *PFN_PROCESS_NEWDATA)(PXID_OPEN_DEVICE OpenDevice);

typedef struct _XID_REPORT_TYPE_INFO
{
    BYTE    bCurrentSize;   //Not including bReportId and bSize
    PVOID   pDefaultValues;
} XID_REPORT_TYPE_INFO, *PXID_REPORT_TYPE_INFO;

typedef struct _XID_TYPE_INFORMATION
{
    UCHAR                      ucType;
    BYTE                       bRemainingHandles;
    BYTE                       bMaxInputReportId;
    BYTE                       bMaxOutputReportId;
    PXPP_DEVICE_TYPE           XppType;
    PXID_REPORT_TYPE_INFO      pInputReportInfoList;
    PXID_REPORT_TYPE_INFO      pOutputReportInfoList;
    PXINPUT_POLLING_PARAMETERS DefaultPollingParameters;
    PFN_PROCESS_NEWDATA        pfnProcessNewData;
    ULONG                      ulFlags;
} XID_TYPE_INFORMATION;
#define XID_BSF_NO_CAPABILITIES  0x00000001
#define XID_BSF_NO_OUTPUT_HEADER 0x00000002

extern DWORD XID_BeginTypeDescriptionTable;
extern DWORD XID_EndTypeDescriptionTable;
//----------------------------------------------------------------------
//  This the XID Descriptor has defined in the XID Specification
//----------------------------------------------------------------------
typedef struct _XID_DESCRIPTOR
{
    UCHAR   bLength;
    UCHAR   bDescriptorType;
    USHORT  bcdXid;
    UCHAR   bType;
    UCHAR   bSubType;
    UCHAR   bMaxInputReportSize;
    UCHAR   bMaxOutputReportSize;
    USHORT  wAlternateProductIds[4];
} XID_DESCRIPTOR; 

//----------------------------------------------------------------------
//  Service Table For Extended Keyboard API
//    In order to separate the extended keyboard API from the core
//    Xbox API, the extended API registers itself with a pointer to
//    this Service Table.
//----------------------------------------------------------------------
typedef void (*PFNKEYBOARD_OPENED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_CLOSED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_REMOVED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_NEWDATA)(HANDLE hDevice, XINPUT_KEYBOARD *pPacket);
typedef struct _XID_KEYBOARD_SERVICES
{
    PFNKEYBOARD_OPENED   pfnOpen;
    PFNKEYBOARD_CLOSED   pfnClose;
    PFNKEYBOARD_REMOVED  pfnRemove;
    PFNKEYBOARD_NEWDATA  pfnNewData;
} XID_KEYBOARD_SERVICES, *PXID_KEYBOARD_SERVICES;
extern PXID_KEYBOARD_SERVICES XID_pKeyboardServices;

//----------------------------------------------------------------------
//  This structure represents a device node.
//----------------------------------------------------------------------
typedef struct _XID_DEVICE_NODE
{
    IUsbDevice              *Device;
       
    UCHAR                   InUse:1;
    UCHAR                   PendingRemove:1;
    UCHAR                   Opened:1;
    UCHAR                   Ready:1;
    UCHAR                   Padding:4;
    UCHAR                   InterfaceNumber;
    UCHAR                   MaxPacketIn;        //MaxPacket is a WORD, but per specification cannot exceed 64.
    UCHAR                   MaxPacketOut;       //MaxPacket is a WORD, but per specification cannot exceed 64.
    UCHAR                   EndpointAddressIn;
    UCHAR                   EndpointAddressOut;
    UCHAR                   TypeIndex;          //What we report in ClassSpecificType
    UCHAR                   SubType;
    UCHAR                   bMaxInputReportSize;
    UCHAR                   bMaxOutputReportSize;
    PXID_TYPE_INFORMATION   TypeInformation;
    PXID_OPEN_DEVICE        OpenDevice;
} XID_DEVICE_NODE;
#define XID_INVALID_NODE_INDEX  0xFF

//----------------------------------------------------------------------
//  Structures for output.  These are the internal equivalent
//  of XOUTPUT_HEADER and XOUTPUT_REPORT.
//----------------------------------------------------------------------
typedef struct _XINPUT_FEEDBACK_HEADER_INTERNAL
{
    PXID_OPEN_DEVICE        OpenDevice;
    PKEVENT                 CompletionEvent;        
    URB                     Urb;
    BYTE                    bReportId;
    BYTE                    bSize;
} XINPUT_FEEDBACK_HEADER_INTERNAL;

typedef struct _XINPUT_FEEDBACK_INTERNAL
{
    DWORD                   dwStatus;
    HANDLE                  hEvent;
    XINPUT_FEEDBACK_HEADER_INTERNAL Internal;
} XINPUT_FEEDBACK_INTERNAL;

typedef struct _XID_OPEN_DEVICE
{
    PXID_DEVICE_NODE      XidNode;
    LONG                  OutstandingPoll;
    ULONG                 PacketNumber;
    PVOID                 InterruptInEndpointHandle;
    PVOID                 InterruptOutEndpointHandle;
    UCHAR                 Report[XID_MAXIMUM_REPORT_SIZE-2];
    UCHAR                 ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
    URB                   Urb;
    URB_CLOSE_ENDPOINT    CloseUrb;
    PKEVENT               CloseEvent;
    UCHAR                 ClosePending:1;
    UCHAR                 ControlEndpointOpen:1;
    UCHAR                 EndpointsPendingClose:1;
    UCHAR                 AutoPoll:1;
    UCHAR                 Pad:4;
    PXID_TYPE_INFORMATION TypeInformation;
    PXID_OPEN_DEVICE      NextOpenDevice;
} XID_OPEN_DEVICE;
#include <POPPACK.H>

//------------------------------------------------------------
//  A structure for the global variables.
//  The only exceptions are a few data tables.
//------------------------------------------------------------
typedef struct _XID_GLOBALS
{
    USHORT                  DeviceNodeCount;
    USHORT                  DeviceNodeInUseCount;
    PXID_DEVICE_NODE        DeviceNodes;
    PXID_OPEN_DEVICE        DeviceHandles;
    //
    //  Data used for enumeration
    //
    union
    {
        XID_DESCRIPTOR          EnumXidDescriptor;
        USB_DEVICE_DESCRIPTOR   EnumDeviceDescriptor;
    };
    URB                         EnumUrb;
    UCHAR                       EnumNode;
    KTIMER                      EnumWatchdogTimer;
    KDPC                        EnumWatchdogTimerDpc;
} XID_GLOBALS;
extern XID_GLOBALS XID_Globals;

//--------------------------------------------------------------------------------------
//  Functions called from input.cpp
//--------------------------------------------------------------------------------------

PXID_TYPE_INFORMATION
FASTCALL
GetTypeInformation(
    UCHAR XidType,
    UCHAR *TypeIndex
    );

PXID_TYPE_INFORMATION 
FASTCALL
GetTypeInformation(
    PXPP_DEVICE_TYPE XppType
    );

DWORD
FASTCALL
XID_fOpenDevice(
    PXID_TYPE_INFORMATION TypeInformation,
    ULONG Port,
    PXID_OPEN_DEVICE *OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    );

VOID
FASTCALL
XID_fCloseDevice(
    IN PXID_OPEN_DEVICE OpenDevice
    );


DWORD
FASTCALL
XID_fSendDeviceReport(
        IN      PXID_OPEN_DEVICE           OpenDevice,
        IN      PXINPUT_FEEDBACK_INTERNAL   OutputReport
        );

VOID
XID_SyncComplete(
    PURB /*UnreferencedUrb*/,
    PKEVENT SyncEvent
    );

__inline 
PXID_OPEN_DEVICE 
XID_AllocateHandle()
{
    PXID_OPEN_DEVICE retVal = XID_Globals.DeviceHandles;
    ASSERT(retVal); //if hit we under allocated somehow.
    XID_Globals.DeviceHandles = retVal->NextOpenDevice;
    return retVal;
}

__inline 
VOID
XID_FreeHandle(PXID_OPEN_DEVICE DeviceHandle)
{
    DeviceHandle->NextOpenDevice = XID_Globals.DeviceHandles;
    XID_Globals.DeviceHandles = DeviceHandle;
}

//--------------------------------------------------------------------------------------
//  Type Specific Functions
//--------------------------------------------------------------------------------------
void
FASTCALL
XID_ProcessGamepadData(
    PXID_OPEN_DEVICE OpenDevice
    );

void
FASTCALL
XID_ProcessIRRemoteData(
    PXID_OPEN_DEVICE OpenDevice
    );

void
FASTCALL
XID_ProcessNewKeyboardData(
    PXID_OPEN_DEVICE OpenDevice
    );

#endif  //__XID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\cydrive\cydrive.c ===
/*
 *
 * cydrive.c
 *
 * Map C and Y drives for the debugger
 *
 */

#include "ntos.h"
#include "dm.h"

const OCHAR szADrive[] = OTEXT("\\??\\A:");
const OCHAR szCdPath[] = OTEXT("\\Device\\Cdrom0");
const OCHAR szFullPath[] = OTEXT("\\Device\\Harddisk0\\Partition1");

void DxtEntry(ULONG *pfUnload)
{
    OBJECT_STRING ostA, ostCD;
    DMDRIVE dr;

    dr.Path = ExAllocatePool(sizeof szFullPath);
    if(dr.Path) {
        dr.Drive = 'C';
        memcpy(dr.Path, szFullPath, sizeof szFullPath);
        DmTell(DMTELL_MAPDRIVE, &dr);
    }
    dr.Path = ExAllocatePool(sizeof szFullPath);
    if(dr.Path) {
        dr.Drive = 'Y';
        memcpy(dr.Path, szFullPath, sizeof szFullPath);
        dr.Path[sizeof szFullPath - 2] = '2';
        DmTell(DMTELL_MAPDRIVE, &dr);
    }

    RtlInitObjectString(&ostA, szADrive);
    RtlInitObjectString(&ostCD, szCdPath);
    IoCreateSymbolicLink(&ostA, &ostCD);
    *pfUnload = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\xkbd\kbd.h ===
#ifndef __XID_KBD_H__
#define __XID_KBD_H__

//definitions used only internally

//
//  HID Keyboard usages
//
#define HID_USAGE_INDEX_KEYBOARD_NOEVENT		0x00
#define HID_USAGE_INDEX_KEYBOARD_ROLLOVER		0x01
#define HID_USAGE_INDEX_KEYBOARD_POSTFAIL		0x02
#define HID_USAGE_INDEX_KEYBOARD_UNDEFINED		0x03
// Letters
#define HID_USAGE_INDEX_KEYBOARD_aA				0x04
#define HID_USAGE_INDEX_KEYBOARD_bB				0x05
#define HID_USAGE_INDEX_KEYBOARD_cC				0x06
#define HID_USAGE_INDEX_KEYBOARD_dD				0x07
#define HID_USAGE_INDEX_KEYBOARD_eE				0x08
#define HID_USAGE_INDEX_KEYBOARD_fF				0x09
#define HID_USAGE_INDEX_KEYBOARD_gG				0x0A
#define HID_USAGE_INDEX_KEYBOARD_hH				0x0B
#define HID_USAGE_INDEX_KEYBOARD_iI				0x0C
#define HID_USAGE_INDEX_KEYBOARD_jJ				0x0D
#define HID_USAGE_INDEX_KEYBOARD_kK				0x0E
#define HID_USAGE_INDEX_KEYBOARD_lL				0x0F
#define HID_USAGE_INDEX_KEYBOARD_mM				0x10
#define HID_USAGE_INDEX_KEYBOARD_nN				0x11
#define HID_USAGE_INDEX_KEYBOARD_oO				0x12
#define HID_USAGE_INDEX_KEYBOARD_pP				0x13
#define HID_USAGE_INDEX_KEYBOARD_qQ				0x14
#define HID_USAGE_INDEX_KEYBOARD_rR				0x15
#define HID_USAGE_INDEX_KEYBOARD_sS				0x16
#define HID_USAGE_INDEX_KEYBOARD_tT				0x17
#define HID_USAGE_INDEX_KEYBOARD_uU				0x18
#define HID_USAGE_INDEX_KEYBOARD_vV				0x19
#define HID_USAGE_INDEX_KEYBOARD_wW				0x1A
#define HID_USAGE_INDEX_KEYBOARD_xX				0x1B
#define HID_USAGE_INDEX_KEYBOARD_yY				0x1C
#define HID_USAGE_INDEX_KEYBOARD_zZ				0x1D
// Numbers
#define HID_USAGE_INDEX_KEYBOARD_ONE			0x1E
#define HID_USAGE_INDEX_KEYBOARD_TWO			0x1F
#define HID_USAGE_INDEX_KEYBOARD_THREE			0x20
#define HID_USAGE_INDEX_KEYBOARD_FOUR			0x21
#define HID_USAGE_INDEX_KEYBOARD_FIVE			0x22
#define HID_USAGE_INDEX_KEYBOARD_SIX			0x23
#define HID_USAGE_INDEX_KEYBOARD_SEVEN			0x24
#define HID_USAGE_INDEX_KEYBOARD_EIGHT			0x25
#define HID_USAGE_INDEX_KEYBOARD_NINE			0x26
#define HID_USAGE_INDEX_KEYBOARD_ZERO			0x27
//Editing Keys
#define HID_USAGE_INDEX_KEYBOARD_RETURN			0x28
#define HID_USAGE_INDEX_KEYBOARD_ESCAPE			0x29
#define HID_USAGE_INDEX_KEYBOARD_BACKSPACE		0x2A //HID spec calls this "delete(backspace)", what we later call delete HID calls "delete forward"
#define HID_USAGE_INDEX_KEYBOARD_TAB			0x2B
#define HID_USAGE_INDEX_KEYBOARD_SPACEBAR		0x2C
#define HID_USAGE_INDEX_KEYBOARD_MINUS			0x2D
#define HID_USAGE_INDEX_KEYBOARD_EQUALS			0x2E
#define HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE		0x2F
#define HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE	0x30
#define HID_USAGE_INDEX_KEYBOARD_BACKSLASH		0x31
#define HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE	0x32
#define HID_USAGE_INDEX_KEYBOARD_COLON			0x33
#define HID_USAGE_INDEX_KEYBOARD_QUOTE			0x34
#define HID_USAGE_INDEX_KEYBOARD_TILDE			0x35
#define HID_USAGE_INDEX_KEYBOARD_COMMA			0x36
#define HID_USAGE_INDEX_KEYBOARD_PERIOD			0x37
#define HID_USAGE_INDEX_KEYBOARD_QUESTION		0x38
#define HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK		0x39
// Funtion keys
#define HID_USAGE_INDEX_KEYBOARD_F1				0x3A
#define HID_USAGE_INDEX_KEYBOARD_F2				0x3B
#define HID_USAGE_INDEX_KEYBOARD_F3				0x3C
#define HID_USAGE_INDEX_KEYBOARD_F4				0x3D
#define HID_USAGE_INDEX_KEYBOARD_F5				0x3E
#define HID_USAGE_INDEX_KEYBOARD_F6				0x3F
#define HID_USAGE_INDEX_KEYBOARD_F7				0x40
#define HID_USAGE_INDEX_KEYBOARD_F8				0x41
#define HID_USAGE_INDEX_KEYBOARD_F9				0x42
#define HID_USAGE_INDEX_KEYBOARD_F10			0x43
#define HID_USAGE_INDEX_KEYBOARD_F11			0x44
#define HID_USAGE_INDEX_KEYBOARD_F12			0x45
//More Edit Keys
#define HID_USAGE_INDEX_KEYBOARD_PRINT_SCREEN	0x46
#define HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK	0x47
#define HID_USAGE_INDEX_KEYBOARD_PAUSE			0x48
#define HID_USAGE_INDEX_KEYBOARD_INSERT			0x49
#define HID_USAGE_INDEX_KEYBOARD_HOME			0x4A
#define HID_USAGE_INDEX_KEYBOARD_PAGE_UP		0x4B
#define HID_USAGE_INDEX_KEYBOARD_DELETE			0x4C	//HID spec, DELETE FORWARD, DELETE is used for backspace
#define HID_USAGE_INDEX_KEYBOARD_END			0x4D
#define HID_USAGE_INDEX_KEYBOARD_PAGE_DOWN		0x4E
#define HID_USAGE_INDEX_KEYBOARD_RIGHT_ARROW	0x4F
#define HID_USAGE_INDEX_KEYBOARD_LEFT_ARROW		0x50
#define HID_USAGE_INDEX_KEYBOARD_DOWN_ARROW		0x51
#define HID_USAGE_INDEX_KEYBOARD_UP_ARROW		0x52			
#define HID_USAGE_INDEX_KEYPAD_NUM_LOCK			0x53
#define HID_USAGE_INDEX_KEYPAD_BACKSLASH		0x54
#define HID_USAGE_INDEX_KEYPAD_ASTERICK			0x55
#define HID_USAGE_INDEX_KEYPAD_MINUS			0x56
#define HID_USAGE_INDEX_KEYPAD_PLUS				0x57
#define HID_USAGE_INDEX_KEYPAD_ENTER			0x58
#define HID_USAGE_INDEX_KEYPAD_ONE				0x59
#define HID_USAGE_INDEX_KEYPAD_TWO				0x5A
#define HID_USAGE_INDEX_KEYPAD_THREE			0x5B
#define HID_USAGE_INDEX_KEYPAD_FOUR				0x5C
#define HID_USAGE_INDEX_KEYPAD_FIVE				0x5D
#define HID_USAGE_INDEX_KEYPAD_SIX				0x5E
#define HID_USAGE_INDEX_KEYPAD_SEVEN			0x5F
#define HID_USAGE_INDEX_KEYPAD_EIGHT			0x60
#define HID_USAGE_INDEX_KEYPAD_NINE				0x61
#define HID_USAGE_INDEX_KEYPAD_ZERO				0x62
#define HID_USAGE_INDEX_KEYPAD_DECIMAL			0x63
#define HID_USAGE_INDEX_KEYBOARD_NON_US_BACKSLASH	0x64
#define HID_USAGE_INDEX_KEYBOARD_APPLICATION	0x65	//This is the Windows(R)TM Key
#define HID_USAGE_INDEX_KEYBOARD_POWER			0x66	//Not on standard 101 or 104
#define HID_USAGE_INDEX_KEYPAD_EQUALS			0x67	//Not on standard 101 or 104

//Bunch o' function keys not on supported keyboards
#define HID_USAGE_INDEX_KEYBOARD_F13			0x68
#define HID_USAGE_INDEX_KEYBOARD_F14			0x69
#define HID_USAGE_INDEX_KEYBOARD_F15			0x6A
#define HID_USAGE_INDEX_KEYBOARD_F16			0x6B
#define HID_USAGE_INDEX_KEYBOARD_F17			0x6C
#define HID_USAGE_INDEX_KEYBOARD_F18			0x6D
#define HID_USAGE_INDEX_KEYBOARD_F19			0x6E
#define HID_USAGE_INDEX_KEYBOARD_F20			0x6F
#define HID_USAGE_INDEX_KEYBOARD_F21			0x70
#define HID_USAGE_INDEX_KEYBOARD_F22			0x71
#define HID_USAGE_INDEX_KEYBOARD_F23			0x72
#define HID_USAGE_INDEX_KEYBOARD_F24			0x73
//More unsupported usages
#define HID_USAGE_INDEX_KEYBOARD_EXECUTE		0x74
#define HID_USAGE_INDEX_KEYBOARD_HELP			0x75
#define HID_USAGE_INDEX_KEYBOARD_MENU			0x76
#define HID_USAGE_INDEX_KEYBOARD_SELECT			0x77
#define HID_USAGE_INDEX_KEYBOARD_STOP			0x78
#define HID_USAGE_INDEX_KEYBOARD_AGAIN			0x79
#define HID_USAGE_INDEX_KEYBOARD_UNDO			0x7A
#define HID_USAGE_INDEX_KEYBOARD_CUT			0x7B
#define HID_USAGE_INDEX_KEYBOARD_COPY			0x7C
#define HID_USAGE_INDEX_KEYBOARD_PASTE			0x7D
#define HID_USAGE_INDEX_KEYBOARD_FIND			0x7E
#define HID_USAGE_INDEX_KEYBOARD_MUTE			0x7F
#define HID_USAGE_INDEX_KEYBOARD_VOLUME_UP		0x80
#define HID_USAGE_INDEX_KEYBOARD_VOLUME_DOWN	0x81
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_CAPS	0x82 //sent as a toggle, see HID USAGE Tables spec.
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_NUM	0x83 //sent as a toggle, see HID USAGE Tables spec.
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_SCROLL	0x84 //sent as a toggle, see HID USAGE Tables spec
//Stuff that we use on foreign keyboards, some needed, some not
#define HID_USAGE_INDEX_KEYPAD_COMMA			0x85 //According to HID usage table 1.1rc3 2/16/99, use for Brazilian keypad "."
#define HID_USAGE_INDEX_KEYPAD_EQUALS_AS400		0x86 //Only As\400, so we don't need to worry.
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL1 0x87 //Brazilian forward slash "/", and Japanese backslash slash
#define HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL2 0x88 //Picture looks like Hiragana according to Emi
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL3 0x89 //Picture looks like Yen
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL4 0x8A //Picture looks like Henkan
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL5 0x8B //Picture looks like Mu-Henkan
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL6 0x8C
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL7 0x8D //Single byte/double byte toggle
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL8 0x8E //left undefined in spec
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL9 0x8F //left undefined in spec
#define HID_USAGE_INDEX_KEYBOARD_LANG1			0x90 //Hangul/English
#define HID_USAGE_INDEX_KEYBOARD_LANG2			0x91 //Hanja conversion key
#define HID_USAGE_INDEX_KEYBOARD_LANG3			0x92 //Katakana key Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG4			0x93 //Hiragana key Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG5			0x94 //Defines the Zenkaku/Hankaku key for Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG6			0x95 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG7			0x96 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG8			0x97 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG9			0x98 //reserved for IME

// . . .
// Modifier Keys
#define HID_USAGE_INDEX_KEYBOARD_LCTRL			0xE0
#define HID_USAGE_INDEX_KEYBOARD_LSHFT			0xE1
#define HID_USAGE_INDEX_KEYBOARD_LALT			0xE2
#define HID_USAGE_INDEX_KEYBOARD_LGUI			0xE3
#define HID_USAGE_INDEX_KEYBOARD_RCTRL			0xE4
#define HID_USAGE_INDEX_KEYBOARD_RSHFT			0xE5
#define HID_USAGE_INDEX_KEYBOARD_RALT			0xE6
#define HID_USAGE_INDEX_KEYBOARD_RGUI			0xE7
// The masks are used, not the indices.
#define HID_USAGE_MASK_KEYBOARD_LCTRL			0x01
#define HID_USAGE_MASK_KEYBOARD_LSHFT			0x02
#define HID_USAGE_MASK_KEYBOARD_LALT			0x04
#define HID_USAGE_MASK_KEYBOARD_LGUI			0x08
#define HID_USAGE_MASK_KEYBOARD_RCTRL			0x10
#define HID_USAGE_MASK_KEYBOARD_RSHFT			0x20
#define HID_USAGE_MASK_KEYBOARD_RALT			0x40
#define HID_USAGE_MASK_KEYBOARD_RGUI			0x80
// Mask for the Keyboard LEDs
#define HID_KEYBOARDLED_MASK_NUM_LOCK           0x01
#define HID_KEYBOARDLED_MASK_CAPS_LOCK          0x02
#define HID_KEYBOARDLED_MASK_SCROLL_LOCK        0x04

#endif //__XID_KBD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\msvc\dxt\critsect.c ===
/*
 *
 * critsect.c
 *
 * Critical sections
 *
 */

#include "precomp.h"

void InitializeCriticalSection(LPCRITICAL_SECTION pcs)
{
    NTSTATUS st;
    RtlZeroMemory(pcs, sizeof *pcs);
    pcs->LockCount = -1;
    st = NtCreateEvent(&pcs->LockSemaphore, EVENT_ALL_ACCESS, NULL,
        SynchronizationEvent, FALSE);
    ASSERT(NT_SUCCESS(st));
}

void EnterCriticalSection(LPCRITICAL_SECTION pcs)
{
    while(InterlockedIncrement(&pcs->LockCount))
        {
        NTSTATUS st;
        if(pcs->OwningThread == KeGetCurrentThread())
            break;
        InterlockedDecrement(&pcs->LockCount);
        st = NtWaitForSingleObjectEx(pcs->LockSemaphore, UserMode, FALSE, NULL);
        ASSERT(NT_SUCCESS(st));
        }
    pcs->OwningThread = KeGetCurrentThread();
    ++pcs->RecursionCount;
}

void LeaveCriticalSection(LPCRITICAL_SECTION pcs)
{
    if(pcs->RecursionCount && pcs->OwningThread == KeGetCurrentThread())
        {
        NTSTATUS st;
        if(!--pcs->RecursionCount)
            pcs->OwningThread = NULL;
        InterlockedDecrement(&pcs->LockCount);
        st = NtPulseEvent(pcs->LockSemaphore, NULL);
        ASSERT(NT_SUCCESS(st));
        }
}

void DeleteCriticalSection(LPCRITICAL_SECTION pcs)
{
    NtClose(pcs->LockSemaphore);
    RtlZeroMemory(pcs, sizeof(LPCRITICAL_SECTION));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\msvc\dxt\dbf.h ===
/*
 *
 * dbf.h
 *
 * Debug memory functions
 *
 */

#ifndef _DBF_H
#define _DBF_H

#define MHAlloc(cb) ExAllocatePoolWithTag(PagedPool, cb, 'cvsm')
//PVOID        MHAlloc        ( size_t );
PVOID        MHRealloc      ( LPVOID, size_t );
//VOID         MHFree         ( LPVOID );
#define MHFree(pv) ExFreePoolWithTag(pv, 'cvsm');

HLLI         LLInit         ( DWORD,
                               LLF,
                               LPFNKILLNODE,
                               LPFNFCMPNODE );
HLLE         LLCreate       ( HLLI );
VOID         LLAdd          ( HLLI, HLLE );
BOOL         LLDelete       ( HLLI, HLLE );
HLLE         LLNext         ( HLLI, HLLE );
HLLE         LLFind         ( HLLI,
                               HLLE,
                               LPVOID,
                               DWORD );
PVOID        LLLock         ( HLLE );
//VOID         LLUnlock       ( HLLE );
#define LLUnlock(hlle)

#endif // _DBF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\msvc\dxt\linklist.c ===
#include "precomp.h"
#include "linklist.h"

#define LLHlliInit LLInit
#define LLHlleCreate LLCreate
#define LLAddHlleToLl LLAdd
#define LLFDeleteHlleFromLl LLDelete
#define LLHlleFindNext LLNext
#define LLHlleFindLpv LLFind
#define LLLpvFromHlle LLLock
#define BMUnlock LLUnlock

typedef PRTL_CRITICAL_SECTION PCS;
PCS PcsAllocInit(void)
{
	PCS pcs = ExAllocatePoolWithTag(PagedPool, sizeof(PCS), 'illh');
	if(pcs)
		InitializeCriticalSection(pcs);
	return pcs;
}

#define FreePcs(pcs) ExFreePoolWithTag(pcs, 'illh');
#define AcquireLockPcs(pcs) EnterCriticalSection((PCS)pcs)
#define ReleaseLockPcs(pcs) LeaveCriticalSection((PCS)pcs);

/*** LLHlliInit
*
* Purpose:
*   Create a new list with specified options
*
* Input:
*   cbUserData :    Number of bytes for user data per node.  Must be > 0.
*   llf        :    List type flags (llfNull, llfAscending, or llfDescending)
*                   (indicates wether or not list is sorted)
*   lpfnKill   :    callback to application for node deletion notification
*                   (may be NULL)
*   lpfnCmp    :    Node comparison callback.  May be NULL for non-sorted
*                   lists.  Otherwise, required.
*
* Output:
*   Either returns valid HLLI for newly created list or NULL for failure.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLI PASCAL
LLHlliInit(
DWORD           cbUserData,
LLF             llf,
LPFNKILLNODE    lpfnKill,
LPFNFCMPNODE    lpfnCmp ) {
    HLLI    hlli;
    LPLLI   lplli;

    assert( cbUserData );
    assert( llf == llfNull || lpfnCmp );

    if ( hlli = HlliAlloc() ) {
        lplli = LockHlli( hlli );
        _fmemset( lplli, 0, sizeof( LLI ) );
        lplli->pcs = PcsAllocInit();
        lplli->cbUserData = cbUserData;
        lplli->lpfnKill = lpfnKill;
        lplli->lpfnCmp = lpfnCmp;
        lplli->llf = llf;
        UnlockHlli( hlli );
    }
    return hlli;
}

/*** LLHlleCreate
*
* Purpose:
*   Allocate and initialize new node for list
*
* Input:
*   hlli     :  List to create node for.
*
* Output:
*   Returns newly created node (zero filled) if successful, otherwise
*   NULL.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLE PASCAL
LLHlleCreate(
HLLI    hlli ) {
    LPLLE   lplle;
    LPLLI   lplli;
    HLLE    hlle;
    WORD    cbNode;

    assert( hlli );
//
// Ensure that the list is OK
//
#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif
//
// Compute size of node with user data area
//
    lplli = LockHlli( hlli );
    cbNode = sizeof( LLE ) + lplli->cbUserData;
    UnlockHlli( hlli );

#ifdef DEBUGVER
//
// Debug version, we're going to stuff a "sentinel" on to the end of the
// user's data for consistency checks.
//
    cbNode += sizeof( WORD );
#endif // DEBUGVER
//
// Allocate the node
//
    if ( hlle = HlleAllocCb( cbNode ) ) {
        lplle = LockHlle( hlle );
        _fmemset( (LPV)lplle, 0, cbNode );
#ifdef DEBUGVER
//
// Stuff in the consistency check stuff
//
        *(WORD FAR *)((BYTE FAR *)lplle + cbNode - sizeof( WORD )) = WCONSIST;
        lplle->wTest = WCONSIST;
#endif // DEBUGVER
        UnlockHlle( hlle );
    }

    return hlle;
}


/*** LLFAddHlleToLl
*
* Purpose:
*   Add a new node to the end of a list.
*
* Input:
*   hlli    :   List to add node to.
*   hlle    :   Node to append to list.
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLAddHlleToLl(
HLLI    hlli,
HLLE    hlle ) {
    LPLLE   lplle;
    LPLLI   lplli;

    assert( hlli );
    assert( hlle );

    lplle = LockHlle( hlle );
    lplli = LockHlli( hlli );

    AcquireLockPcs(lplli->pcs);

    assert( lplli->llf == llfNull );
//
//  Initalize node: Since this is to be the last item in the list,
//  pNext should be null.  Also, the pPrev should point to the
//  currently last item in the list (includes NULL)
//
    lplle->hlleNext = hlleNull;
#ifdef DBLLINK
    lplle->hllePrev = lplli->hlleTail;
#endif // DBLLINK
//
//  Chalk up one more for the list
//
    lplli->chlleMac++;
//
//  If the pHead is NULL then initialize the pHead and pTail
//  (you know, like this is the only item in the list)
//
    if ( lplli->hlleHead == hlleNull ) {
        lplli->hlleHead = lplli->hlleTail = hlle;
    }
//
//  Otherwise, update the tail pointer and the pNext for the old tail
//
    else {
        HLLE    hlleT = lplli->hlleTail;

        LockHlle( hlleT )->hlleNext = hlle;
        UnlockHlle( hlleT );
        lplli->hlleTail = hlle;
    }
    UnlockHlle( hlle );

//
// Ensure that the list is OK
//
#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif


    ReleaseLockPcs(lplli->pcs);
    UnlockHlli( hlli );
}

/***
*
* Purpose:
*
* Input:
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLInsertHlleInLl(
HLLI    hlli,
HLLE    hlleNew,
DWORD   lParam ) {

    USHORT          fNeedPos = fTrue;
    LPLLI           lplli = LockHlli( hlli );
    HLLE            hlle = hlleNull;
    HLLE            hllePrev = hlleNull;
    WORD            wPos = 0;
    LPFNFCMPNODE    lpfnCmp;
    LPV             lpv;

    assert( hlli );
    AcquireLockPcs( lplli->pcs );

    lpfnCmp = lplli->lpfnCmp;
    assert( lplli->llf == llfNull || lpfnCmp );

    lpv = LLLpvFromHlle( hlleNew );

    switch( lplli->llf ) {
        case llfNull:
            hlle = LLHlleFindNext( hlli, hlle );
            while( wPos++ < LOWORD( lParam ) ) {
                hllePrev = hlle;
                hlle = LLHlleFindNext( hlli, hlle );
            }
            break;

        case llfAscending:
            while( fNeedPos && ( hlle = LLHlleFindNext( hlli, hlle ) ) ) {
                fNeedPos = lpfnCmp( LLLpvFromHlle( hlle ), lpv, lParam ) == fCmpLT;
                UnlockHlle( hlle );
                if ( fNeedPos ) {
                    hllePrev = hlle;
                }
            }
            break;

        case llfDescending:
            while( fNeedPos && ( hlle = LLHlleFindNext( hlli, hlle ) ) ) {
                fNeedPos = lpfnCmp( LLLpvFromHlle( hlle ), lpv, lParam ) == fCmpGT;
                UnlockHlle( hlle );
                if ( fNeedPos ) {
                    hllePrev = hlle;
                }
            }
            break;
    }
    LLInsertHlle( hlli, hllePrev, hlleNew, hlle );
    UnlockHlle( hlleNew );

    ReleaseLockPcs( lplli->pcs );

    UnlockHlli( hlli );
}

/*** LLFDeleteHlleIndexed
*
* Purpose:
*   Delete the ith node from a list.
*
* Input:
*   hlli    :   List containing node to delete
*   lPos    :   zero based index of node to delete.
*
* Output:
*   Return fTrue for successful deletion, else fFalse.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
BOOL PASCAL
LLFDeleteHlleIndexed(
HLLI    hlli,
DWORD   lPos ) {

    USHORT  fRet = fFalse;
    LPLLI   lplli = LockHlli( hlli );
    HLLE    hlleKill = lplli->hlleHead;
    HLLE    hllePrev = hlleNull;
    DWORD   lPosCur = 0L;

    assert( hlli );

    AcquireLockPcs( lplli->pcs );

//
//  Make sure that we're not deleting past the end of the list!
//
    if ( lPos < lplli->chlleMac ) {
//
//  Chug through the list until we find the sucker to kill!
//
        while ( lPos != lPosCur ) {
            hllePrev = hlleKill;
            hlleKill = LLHlleFindNext( hlli, hlleKill );
            ++lPosCur;
        }
        LLDeleteHlle( hlli, hllePrev, hlleKill );
        fRet = fTrue;
    }

#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif

    ReleaseLockPcs( lplli->pcs );

    UnlockHlli( hlli );
    return fRet;
}

/*** LLFDeleteLpvFromLl
*
* Purpose:
*   Delete a node from a list containing lpv data.
*
* Input:
*   hlli    :   List containing node to delete
*   hlle    :   Node to begin search for delete node at.
*   lpv     :   far pointer to comparison data.  Passed onto compare callback.
*   lParam  :   Application supplied data.  Just passed onto compare callback.
*
* Output:
*   Returns fTrue if node has been deleted, else fFalse
*
* Exceptions:
*
* Notes:
*   There must be a compare routine assiciated with this list!!!
*   For a doubly linked list, this is simple.  For singly linked
*   list, we have to go through the list to get the previous node
*   to ensure that the pointers are correct.
*
*************************************************************************/
BOOL PASCAL
LLFDeleteLpvFromLl(
HLLI    hlli,
HLLE    hlle,
LPV     lpv,
DWORD   lParam ) {

#ifdef DBLLINK
    LPLLI   lplli = LockHlli ( hlli );

    AcquireLockPcs ( lplli->pcs );

    hlle = LLHlleFindLpv( hlli, hlle, lpv, lParam );
    if ( hlle ) {
        LLDeleteHlle( hlli, LLHlleFindPrev( hlli, hlle ), hlle );
    }

#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif
    ReleaseLockPcs ( lplli->pcs );
    UnlockHlli ( hlli );
    return hlle != hlleNull;

#else // DBLLINK

    LPLLI           lplli = LockHlli( hlli );
    HLLE            hlleNext;
    LPFNFCMPNODE    lpfnCmp;

    AcquireLockPcs ( lplli->pcs );

    lpfnCmp = lplli->lpfnCmp;

    assert( lpfnCmp );
//
//  We're goint to delete the first occurance AFTER the one specified!
//
    hlleNext = LLHlleFindNext( hlli, hlle );
//
// Look up the data in the list
//
    while( hlleNext &&
        lpfnCmp( LLLpvFromHlle( hlleNext ), lpv, lParam ) != fCmpEQ ) {
        UnlockHlle( hlleNext );
        hlle = hlleNext;
        hlleNext = LLHlleFindNext( hlli, hlleNext );
    }
//
// if hlleNext is non-null then we've found something to delete!!!
//
    if ( hlleNext ) {
        LLDeleteHlle( hlli, hlle, hlleNext );
    }
#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif

    ReleaseLockPcs ( lplli->pcs );

    UnlockHlli( hlli );
    return hlleNext != hlleNull;

#endif // DBLLINK
}

/*** LLHlleFindNext
*
* Purpose:
*   Get the next node in a list.
*
* Input:
*   hlli   :    List to search in.
*   hlle   : Place to begin.  If NULL, then return hlleHead.
*
* Output:
*   Returns a handle to the next item in the list.  hlleNull is returned
*   if the end of the list has been reached.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLE PASCAL
LLHlleFindNext(
HLLI    hlli,
HLLE    hlle ) {
    HLLE        hlleRet;

//
//  if hlle is non-null, return the next handle
//
    if ( hlle ) {
        hlleRet = LockHlle( hlle )->hlleNext;
        UnlockHlle( hlle );
    }
//
//  otherwise, we want the beginning of the list, so return the "head"
//
    else {
        LPLLI   lplli;

        lplli = LockHlli ( hlli );
        AcquireLockPcs ( lplli->pcs );
        hlleRet = lplli->hlleHead;
        ReleaseLockPcs ( lplli->pcs );
        UnlockHlli( hlli );
        }

    return hlleRet;
}

/*** LLHlleFindPrev
*
* Purpose:
*   Get the previous node in a list.  DOUBLY LINKED LIBRARY ONLY!!!
*
* Input:
*   hlli    :   List to search in.
*   hlle    :   Place to beging search at.  If hlleNull, the return the
*               last node in the list.
*
* Output:
*   Return a handle to the previous node in the list, hlleNull if the
*   beginning of the list has been hit.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
#ifdef DBLLINK
HLLE PASCAL
LLHlleFindPrev(
HLLI    hlli,
HLLE    hlle ) {
    HLLE    hlleRet;

//
//  if hlle is non-null, return the next handle
//
    if ( hlle ) {
        hlleRet = LockHlle( hlle )->hllePrev;
        UnlockHlle( hlle );
    }
//
//  otherwise, we want the beginning of the list, so return the "head"
//
    else {
        LPLLI   lplli;

        lplli = LockHlli ( hlli );
        AcquireLockPcs ( lplli->pcs );
        hlleRet = lplli->hlleTail;
        ReleaseLockPcs ( lplli->pcs );
        UnlockHlli( hlli );
    }

    return hlleRet;
}
#endif // DBLLINK

/***  LLChlleDestroyList
*
* Purpose:
*   Free all memory associated with a specified list.  Completely
*   destroys the list.  Must call HlliInit() to add new items to list.
*
* Input:
*   hlli    :   List to destroy
*
* Output:
*   Returns number of nodes destroyed in list.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
DWORD PASCAL
LLChlleDestroyLl(
HLLI    hlli ) {
    DWORD   cRet = 0;
    LPLLI   lplli;

    assert( hlli );

    lplli = LockHlli ( hlli );
    AcquireLockPcs ( lplli->pcs );

    while ( LLChlleInLl( hlli ) != 0 ) {
        LLFDeleteHlleIndexed( hlli, 0 );
        ++cRet;
    }

    ReleaseLockPcs ( lplli->pcs );
    FreePcs ( lplli->pcs );
    FreeHlli( hlli );

    return cRet;
}

/*** LLHlleFindLpv
*
* Purpose:
*   Locate a node in a list containing specific data.
*
* Input:
*   hlli    :   List to search in.
*   hlle    :   Starting place to begin search.  If NULL, start at
*               beginning of list.
*  lpv     :    Data passed on to compare callback for match.
*  lParam  :    Application supplied data.  Just passed on to callback.
*
* Output:
*   Returns handle to node meeting compare criteria or NULL if not found.
*
* Exceptions:
*
* Notes:
*   Requires that list has a callback function.
*
*************************************************************************/
HLLE PASCAL
LLHlleFindLpv(
HLLI    hlli,
HLLE    hlle,
LPV lpvFind,
DWORD   lParam ) {

    HLLE    hlleRet = hlleNull;
    LPLLI   lplli = LockHlli( hlli );
    LPLLE   lplle;

    AcquireLockPcs ( lplli->pcs );

    assert( hlli );
    assert( lplli->lpfnCmp );

    hlle = LLHlleFindNext( hlli, hlle );

    while ( hlle != hlleNull && hlleRet == hlleNull ) {
        lplle = LockHlle( hlle );
        if ( lplli->lpfnCmp( (LPV)lplle->rgw, lpvFind, lParam ) == fCmpEQ ) {
            hlleRet = hlle;
        }
        UnlockHlle( hlle );
        hlle = LLHlleFindNext( hlli, hlle );
    }

    ReleaseLockPcs ( lplli->pcs );
    UnlockHlli( hlli );

    return hlleRet;
}

/*** LLFCheckHlli
*
* Purpose:
*   Consistency check for a list.
*
* Input:
&   hlli      : List to check.
*
* Output:
*   Returns non-null if list is OK, otherwise failure is indicated.
*
* Exceptions:
*
* Notes:
*   This is a debug only function.  We will zip through the entire list
*   and check the head and tail words of EACH node for our magic WCONSIST
*   value.  If either one is not correct, someone trashed a node.  We also
*   check to see that the last node in the list is actually hlleTail for the
*   list.
*
*************************************************************************/
#ifdef DEBUGVER
BOOL PASCAL
LLFCheckHlli(
HLLI    hlli ) {
    LPLLI   lplli = LockHlli( hlli );
    LPLLE   lplle;
    HLLE    hlle = hlleNull;
    WORD    cbOffSet = sizeof( LLE ) + lplli->cbUserData;
    ULONG	fRet;
    HLLE    hlleLast = LLHlleFindNext( hlli, hlleNull );

    fRet = lplli->cbUserData; // && lplli->lpfnCmp && lplli->lpfnKill;
    if ( lplli->chlleMac ) {
        fRet = fRet && lplli->hlleHead && lplli->hlleTail;
    }
    else {
        fRet = fRet && !lplli->hlleHead && !lplli->hlleTail;
    }
    while( fRet && ( hlle = LLHlleFindNext( hlli, hlle ) ) ) {
        lplle = LockHlle( hlle );
        fRet = ( lplle->wTest == WCONSIST &&
            *((WORD FAR *)( (BYTE FAR *)lplle + cbOffSet )) == WCONSIST );
        hlleLast = hlle;
        UnlockHlle( hlle );
    }
    if ( fRet ) {
        fRet = hlleLast == lplli->hlleTail;
    }
    UnlockHlli( hlli );
    assert( fRet );
    return fRet;
}
#endif // DEBUGVER

/*** LLInsertHlle
*
* Purpose:
*   INTERNAL utility function to insert a node into a specified place
*   in the list.  This will update the pointers and head/tail information
*   for the list.
*
* Input:
*   hlli       :    List to insert node into.
*   hllePrev   :    Node which will appear right before the inserted one.
*   hlle       :    Our newly created node.
*   hlleNext   :   The node which will be immediately after the new one.
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLInsertHlle(
HLLI    hlli,
HLLE    hllePrev,
HLLE    hlle,
HLLE    hlleNext ) {

    LPLLE   lplle;
    LPLLI   lplli;

//
// Note that we don't need to acquire critical sections here since the
//  higher level routines do that.
//
    lplli = LockHlli( hlli );
    lplle = LockHlle( hlle );
//
//  If there is a previous node, update its hnext
//
    if ( hllePrev ) {
        LockHlle( hllePrev )->hlleNext = hlle;
        UnlockHlle( hllePrev );
    }
//
// Otherwise, update the head
//
    else {
        lplli->hlleHead = hlle;
    }
//
// Set the hNext for the new node
//
    lplle->hlleNext = hlleNext;
//
// We're adding to the end of the list, update the hlleTail
//
    if ( hlleNext == hlleNull ) {
        lplli->hlleTail = hlle;
    }
//
//  If there is a next, update its hPrev
//
#ifdef DBLLINK
    else {
        LockHlle( hlleNext )->hllePrev = hlle;
        UnlockHlle( hlleNext );
    }
//
// Set the hPrev for the new node
//
    lplle->hllePrev = hllePrev;
#endif // DBLLINK
//
// Increment the number of items on the list
//
    ++lplli->chlleMac;
    UnlockHlle( hlle );
    UnlockHlli( hlli );
}

/*** LLFDeleteHlleFromLl
*
* Purpose:
*   Delete a specified hlle.  Update head/tail and node pointers.
*
* Input:
*   hlli      : List containing node to delete.
*   hlle      : The node to destroy.
*
* Output:
*   None.
*
* Exceptions:
*
* Notes:
*   For doubly linked list, we could just use the hllePrev handle,
*  but there's no guarantee that the node is in the list specified.  So
*   We do a look up just to make sure.
*
*************************************************************************/
BOOL PASCAL
LLFDeleteHlleFromLl(
HLLI    hlli,
HLLE    hlle ) {
    HLLE    hllePrev = hlleNull;
    HLLE    hlleCur = hlleNull;
    USHORT  fRet;
    LPLLI   lplli;

    assert( hlli );

    //
    // REVIEW:PERFORMANCE don't need to lock hlli down on non NT versions
    //
    lplli = LockHlli ( hlli );
    AcquireLockPcs ( lplli->pcs );

    assert( hlle );
    while( ( hlleCur = LLHlleFindNext( hlli, hlleCur ) ) && hlleCur != hlle ) {
        hllePrev = hlleCur;
    }
    if ( fRet = ( hlle == hlleCur ) ) {
        LLDeleteHlle( hlli, hllePrev, hlle );
    }

    ReleaseLockPcs ( lplli->pcs );
    UnlockHlli ( hlli );

    return fRet;
}

/*** LLDeleteHlle
*
* Purpose:
*   INTERNAL utility routine to delete a node.  Update head/tail and
*   node pointers.
*
* Input:
*   hlli      : List containing node to delete.
*   hllePrev  : Node immediately preceding node to be deleted in the list.
*   hlle      : The node to destroy.
*
* Output:
*   None.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLDeleteHlle(
HLLI    hlli,
HLLE    hllePrev,
HLLE    hlle ) {

    LPLLI   lplli = LockHlli( hlli );
    HLLE    hlleNext = LLHlleFindNext( hlli, hlle );
//
//  If there is a previous node, update its hnext
//
    if ( hllePrev ) {
        LockHlle( hllePrev )->hlleNext = hlleNext;
        UnlockHlle( hllePrev );
    }
//
// Otherwise, update the head
//
    else {
        lplli->hlleHead = hlleNext;
    }
//
// We're adding to the end of the list, update the hlleTail
//
    if ( hlleNext == hlleNull ) {
        lplli->hlleTail = hllePrev;
    }
//
//  If there is a next, update its hPrev
//
#ifdef DBLLINK
    else {
        LockHlle( hlleNext )->hllePrev = hllePrev;
        UnlockHlle( hlleNext );
    }
#endif // DBLLINK
//
//  Let the app free up its own mess for the data from this node
//
    if ( lplli->lpfnKill ) {
        lplli->lpfnKill( (LPV)LockHlle( hlle )->rgw );
        UnlockHlle( hlle );
    }
    FreeHlle( hlle );
//
// Decrement the number of items on the list
//
    --lplli->chlleMac;
    UnlockHlli( hlli );
}

/*** LLChlleInLl
*
* Purpose:
*   Return the number of nodes in a list
*
* Input:
*   hlli   :    List to get count for
*
* Output:
*   Number of nodes in the list.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
DWORD PASCAL
LLChlleInLl(
HLLI    hlli ) {

    DWORD   lRet;
    LPLLI   lplli;

    assert( hlli );

    lplli = LockHlli ( hlli );
    AcquireLockPcs ( lplli->pcs );

    lRet = lplli->chlleMac;

    ReleaseLockPcs ( lplli->pcs );
    UnlockHlli( hlli );
    return lRet;
}

/*** LLLpvFromHlle
*
* Purpose:
*   Get a FAR pointer to the user data of a node.  This locks the node
*   down.  It is the application's responsibility to unlock it!
*
* Input:
*   hlle    :   Node to get data for.
*
* Output:
*   A FAR pointer to the data.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
LPV PASCAL
LLLpvFromHlle(
HLLE    hlle ) {
    if (hlle == hlleNull) {
        return NULL;
    }
    else {
        return (LPV)( LockHlle( hlle )->rgw );
    }
}

/*** LLHlleGetLast
*
* Purpose:
*   Get the last node in the specified list.
*
* Input:
*   hlli    :   List to look up last item in.
*
* Output:
*   handle to the last item, or NULL if empty list.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLE PASCAL
LLHlleGetLast(
HLLI    hlli ) {
    HLLE    hlleRet;
    LPLLI   lplli;

    assert( hlli );

    lplli = LockHlli ( hlli );

    AcquireLockPcs ( lplli->pcs );

    hlleRet = lplli->hlleTail;

    ReleaseLockPcs ( lplli->pcs );
    UnlockHlli( hlli );
    return hlleRet;
}


/*** LLHlleAddToHeadOfLI
*
* Purpose:
*   Add a new node to the head of a list.
*
* Input:
*   hlli    :   List to add node to.
*   hlle    :   Node to append to list.
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL LLHlleAddToHeadOfLI( HLLI   hlli, HLLE  hlle ) {

    LPLLE   lplle;
    LPLLI   lplli;

    assert( hlli );
    assert( hlle );

    lplli = LockHlli( hlli );
    AcquireLockPcs ( lplli->pcs );

    lplle = LockHlle( hlle );
    assert( lplli->llf == llfNull );

    lplle->hlleNext = lplli->hlleHead;

    //  If the pHead is NULL then initialize the pTail
    //  (you know, like this is the only item in the list)
    if ( lplli->hlleHead == hlleNull ) {
        lplli->hlleTail = hlle;
    }
    lplli->hlleHead = hlle;
#ifdef DBLLINK
    lplle->hllePrev = hlleNull;
#endif // DBLLINK

    //  Chalk up one more for the list
    lplli->chlleMac++;

    // Ensure that the list is OK
    UnlockHlle( hlle );

#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif

    ReleaseLockPcs ( lplli->pcs );

    UnlockHlli( hlli );

}

/*** LLFRemoveHlleFromLl
*
* Purpose:
*   Remove a specified hlle.    Update head/tail and node pointers.
*
* Input:
*   hlli      : List containing node to remove.
*   hlle      : The node to remove.
*
* Output:
*   None.
*
* Exceptions:
*
* Notes:
*   For doubly linked list, we could just use the hllePrev handle,
*  but there's no guarantee that the node is in the list specified.  So
*   We do a look up just to make sure.
*
*************************************************************************/
BOOL PASCAL LLFRemoveHlleFromLl( HLLI hlli, HLLE hlle ) {

    HLLE    hllePrev = hlleNull;
    HLLE    hlleCur = hlleNull;
    USHORT  fRet;
    LPLLI   lplli;

    assert( hlli );
    assert( hlle );

    lplli = LockHlli ( hlli );

    AcquireLockPcs ( lplli->pcs );

    while( ( hlleCur = LLHlleFindNext( hlli, hlleCur ) ) && hlleCur != hlle ) {
        hllePrev = hlleCur;
    }
    if ( fRet = ( hlle == hlleCur ) ) {

        HLLE    hlleNext = LLHlleFindNext( hlli, hlle );

        //  If there is a previous node, update its hnext
        if ( hllePrev ) {
            LockHlle( hllePrev )->hlleNext = hlleNext;
            UnlockHlle( hllePrev );
        }

        // Otherwise, update the head
        else {
            lplli->hlleHead = hlleNext;
        }

        // We're adding to the end of the list, update the hlleTail
        if ( hlleNext == hlleNull ) {
            lplli->hlleTail = hllePrev;
        }

        //  If there is a next, update its hPrev
#ifdef DBLLINK
        else {
            LockHlle( hlleNext )->hllePrev = hllePrev;
            UnlockHlle( hlleNext );
        }
#endif // DBLLINK

        // Decrement the number of items on the list
        --lplli->chlleMac;
    }

#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif

    ReleaseLockPcs ( lplli->pcs );

    UnlockHlli( hlli );

    return fRet;
}

PVOID MHRealloc(LPVOID pv, size_t cbNew)
{
	PVOID pvNew = MHAlloc(cbNew);
	BOOLEAN f;
	if(pvNew) {
		ULONG cbOld = ExQueryPoolBlockSize(pv, &f);
		if(cbOld < cbNew) {
			memcpy(pvNew, pv, cbOld);
			RtlZeroMemory((LPBYTE)pvNew + cbOld, cbNew - cbOld);
		} else
			memcpy(pvNew, pv, cbNew);
	}
	MHFree(pv);
	return pvNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\msvc\dxt\api32.c ===
/*
 *
 * api.c
 *
 * Implementation of the Win32 APIs needed for winsock, on top of ntoskrnl
 *
 */

#include "precomp.h"
#include "dm.h"

void SetLastError(DWORD dwErrCode)
{
    DmGetCurrentDmtd()->LastError = dwErrCode;
}

DWORD GetLastError(void)
{
    return DmGetCurrentDmtd()->LastError;
}

void Sleep(DWORD dw)
{
    SleepEx(dw, FALSE);
}

DWORD SleepEx(DWORD dw, BOOL f)
{
    LARGE_INTEGER li;
    NTSTATUS st;

    if(dw == -1)
        {
        li.LowPart = 0;
        li.HighPart = 0x80000000;
        }
    else
        {
        li.QuadPart = UInt32x32To64(dw, 10000);
        li.QuadPart *= -1;
        }
    do
        st = KeDelayExecutionThread(UserMode, (BOOLEAN)f, &li);
    while(f && STATUS_ALERTED == st);
    return st == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

HANDLE CreateEventA(LPSECURITY_ATTRIBUTES psa, BOOL fManualReset,
    BOOL fInitState, LPCSTR lpwzName)
{
    NTSTATUS st;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;

    ASSERT(NULL == lpwzName);

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    st = NtCreateEvent(&h, EVENT_ALL_ACCESS, &oa, fManualReset ?
        NotificationEvent : SynchronizationEvent, (BOOLEAN)fInitState);
    if(NT_SUCCESS(st))
        SetLastError(0);
    else
        {
        SetLastError(RtlNtStatusToDosError(st));
        h = NULL;
        }
    return h;
}

void _ThreadStartup(PKSTART_ROUTINE StartRoutine, PVOID StartContext)
{
    DmGetCurrentDmtd()->DebugFlags |= DMFLAG_DEBUGTHREAD;
    StartRoutine(StartContext);
    PsTerminateSystemThread(STATUS_SUCCESS);
}

HANDLE CreateThread(LPSECURITY_ATTRIBUTES psa, DWORD dwStack,
    LPTHREAD_START_ROUTINE lpfn, LPVOID lpv, DWORD dwFlags, LPDWORD lpdwId)
{
    NTSTATUS st;
    HANDLE h;
    CLIENT_ID clid;

    st = PsCreateSystemThreadEx(&h, 0, dwStack, (PHANDLE)lpdwId,
		(PKSTART_ROUTINE)lpfn, lpv,
		(BOOLEAN)(dwFlags & CREATE_SUSPENDED ? TRUE : FALSE), _ThreadStartup);
    
    if(!NT_SUCCESS(st))
        {
        SetLastError(RtlNtStatusToDosError(st));
        return NULL;
        }
    
    return h;
}

BOOL CloseHandle(HANDLE h)
{
    NTSTATUS st = NtClose(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL SetEvent(HANDLE h)
{
    NTSTATUS st = NtSetEvent(h, NULL);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL ResetEvent(HANDLE h)
{
    NTSTATUS st = NtClearEvent(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

#if 0
DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lph, BOOL fWaitAll,
    DWORD dwTimeOut, BOOL fAlertable)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;
    HANDLE rgh[MAXIMUM_WAIT_OBJECTS];

    if(nCount > MAXIMUM_WAIT_OBJECTS)
    {
        SetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
        return (DWORD)-1;
    }

    RtlCopyMemory(rgh, lph, nCount * sizeof(HANDLE));
    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    do
        st = NtWaitForMultipleObjectsEx((CHAR)nCount, rgh,
            fWaitAll ? WaitAll : WaitAny, UserMode, (BOOLEAN)fAlertable, pli);
    while(st == STATUS_ALERTED && fAlertable);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}
#endif

DWORD WaitForSingleObject(HANDLE h, DWORD dwTimeOut)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;

    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    st = NtWaitForSingleObjectEx(h, UserMode, FALSE, pli);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\msvc\dxt\api322.c ===
/*
 *
 * api.c
 *
 * Implementation of the Win32 APIs needed for winsock, on top of ntoskrnl
 *
 */

#include "dmp.h"

void SetLastError(DWORD dwErrCode)
{
    DmGetCurrentDmtd()->LastError = dwErrCode;
}

DWORD GetLastError(void)
{
    return DmGetCurrentDmtd()->LastError;
}

#if 0
void DebugBreak(void)
{
    DbgBreakPoint();
}
#endif

HLOCAL LocalAlloc(UINT uFlags, SIZE_T cb)
{
    PVOID pv;

    if(uFlags & (LMEM_MOVEABLE | LMEM_DISCARDABLE))
        pv = NULL;
    else {
        pv = ExAllocatePool(PagedPool, cb + 8);
        if(pv) {
            *((DWORD *)pv)++ = 'kmem';
            *((DWORD *)pv)++ = 'dbgr';
            if(uFlags & LMEM_ZEROINIT)
                RtlZeroMemory(pv, cb);
            }
        }
    return (HLOCAL)pv;
}

HLOCAL LocalFree(HLOCAL h)
{
    HLOCAL hRet = h;
    DWORD *pdw = (DWORD *)h;
    try {
        if(h && pdw[-1] == 'dbgr' && pdw[-2] == 'kmem') {
            ExFreePool(pdw - 2);
            hRet = NULL;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }
    return hRet;
}

void Sleep(DWORD dw)
{
    SleepEx(dw, FALSE);
}

DWORD SleepEx(DWORD dw, BOOL f)
{
    LARGE_INTEGER li;
    NTSTATUS st;

    if(dw == -1)
        {
        li.LowPart = 0;
        li.HighPart = 0x80000000;
        }
    else
        {
        li.QuadPart = UInt32x32To64(dw, 10000);
        li.QuadPart *= -1;
        }
    do
        st = KeDelayExecutionThread(UserMode, (BOOLEAN)f, &li);
    while(f && STATUS_ALERTED == st);
    return st == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

HANDLE CreateEventW(LPSECURITY_ATTRIBUTES psa, BOOL fManualReset,
    BOOL fInitState, LPCWSTR lpwzName)
{
    NTSTATUS st;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;

    ASSERT(NULL == lpwzName);

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    st = NtCreateEvent(&h, EVENT_ALL_ACCESS, &oa, fManualReset ?
        NotificationEvent : SynchronizationEvent, (BOOLEAN)fInitState);
    if(NT_SUCCESS(st))
        SetLastError(0);
    else
        {
        SetLastError(RtlNtStatusToDosError(st));
        h = NULL;
        }
    return h;
}

#if 0
ULONG _DmUnhandledException(PEXCEPTION_POINTERS pep)
{
    KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
        (ULONG_PTR)pep->ExceptionRecord->ExceptionAddress, 0, 0, 0);
    return EXCEPTION_EXECUTE_HANDLER;
}

void _DmThreadStartup(PKSTART_ROUTINE StartRoutine, PVOID StartContext)
{
    DWORD dwExit;

    KeLowerIrql(0);
    if(FAllocDmThread()) {
        try {
            dwExit = (*(LPTHREAD_START_ROUTINE)StartRoutine)(StartContext);
        } except(_DmUnhandledException(GetExceptionInformation())) {
            KeBugCheck(KMODE_EXCEPTION_NOT_HANDLED);
        }
    } else
        dwExit = 0;
    
    PsTerminateSystemThread(dwExit);
}

HANDLE CreateThread(LPSECURITY_ATTRIBUTES psa, DWORD dwStack,
    LPTHREAD_START_ROUTINE lpfn, LPVOID lpv, DWORD dwFlags, LPDWORD lpdwId)
{
    NTSTATUS st;
    HANDLE h;

    st = PsCreateSystemThreadEx(&h, 0, dwStack, lpdwId, (PKSTART_ROUTINE)lpfn,
        lpv, (BOOLEAN)(dwFlags & CREATE_SUSPENDED ? TRUE : FALSE), NULL);
    
    if(!NT_SUCCESS(st))
        {
        SetLastError(RtlNtStatusToDosError(st));
        return NULL;
        }
    
    if(lpdwId)
        *lpdwId = HandleToUlong(clid.UniqueThread);
    
    return h;
}
#endif

BOOL CloseHandle(HANDLE h)
{
    NTSTATUS st = NtClose(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL SetEvent(HANDLE h)
{
    NTSTATUS st = NtSetEvent(h, NULL);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL ResetEvent(HANDLE h)
{
    NTSTATUS st = NtClearEvent(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lph, BOOL fWaitAll,
    DWORD dwTimeOut, BOOL fAlertable)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;
    HANDLE rgh[MAXIMUM_WAIT_OBJECTS];

    if(nCount > MAXIMUM_WAIT_OBJECTS)
    {
        SetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
        return (DWORD)-1;
    }

    RtlCopyMemory(rgh, lph, nCount * sizeof(HANDLE));
    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    do
        st = NtWaitForMultipleObjectsEx((CHAR)nCount, rgh,
            fWaitAll ? WaitAll : WaitAny, UserMode, (BOOLEAN)fAlertable, pli);
    while(st == STATUS_ALERTED && fAlertable);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}

DWORD WaitForSingleObject(HANDLE h, DWORD dwTimeOut)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;

    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    st = NtWaitForSingleObjectEx(h, UserMode, FALSE, pli);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}

#if 0
BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *pliDue, LONG lPer,
    PTIMERAPCROUTINE pfn, LPVOID lpArg, BOOL fResume)
{
    NTSTATUS st;

    st = NtSetTimer(hTimer, (PLARGE_INTEGER)pliDue, (PTIMER_APC_ROUTINE)pfn,
        lpArg, (BOOLEAN)fResume, lPer, NULL);

    if(!NT_SUCCESS(st))
    {
        SetLastError(RtlNtStatusToDosError(st));
        return FALSE;
    }
    if(st == STATUS_TIMER_RESUME_IGNORED)
        SetLastError(ERROR_NOT_SUPPORTED);
    else
        SetLastError(0);
    return TRUE;
}

HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES psa, BOOL fManualReset,
    LPCWSTR lpwzName)
{
    NTSTATUS st;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;

    ASSERT(NULL == lpwzName);

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    st = NtCreateTimer(&h, TIMER_ALL_ACCESS, &oa, fManualReset ?
        NotificationTimer : SynchronizationTimer);
    if(NT_SUCCESS(st))
        SetLastError(0);
    else
        {
        SetLastError(RtlNtStatusToDosError(st));
        h = NULL;
        }
    return h;
}

BOOL CancelWaitableTimer(HANDLE h)
{
    NTSTATUS st = NtCancelTimer(h, NULL);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\msvc\dxt\ctx386.h ===
/*
 *
 * ctx386.h
 *
 * Context definition for win32 x86
 *
 */

#ifndef _CTX386_h
#define _CTX386_h

typedef CONTEXT XBDMCTX;
typedef FLOATING_SAVE_AREA XBDMFLOATSAVE;

#define CONTEXT CTX86
#define _CONTEXT _CTX86
#define PCONTEXT PCTX86
#define LPCONTEXT PCONTEXT
#define FLOATING_SAVE_AREA FSAVEX86
#define _FLOATING_SAVE_AREA _FSAVEX86
#define PFLOATING_SAVE_AREA PFSAVEX86

typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[80];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

typedef struct _CONTEXT {
    DWORD ContextFlags;
    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;
    FLOATING_SAVE_AREA FloatSave;
    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;
    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;
    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;
    DWORD   EFlags;
    DWORD   Esp;
    DWORD   SegSs;
    BYTE    ExtendedRegisters[512];
} CONTEXT, *PCONTEXT;

#endif // _CTX386_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\msvc\dxt\tldxt.c ===
/*
 *
 * tldxt.c
 *
 * Transport layer for the VC debug extension
 *
 */

#include "precomp.h"

int
WINAPI
DmDllMain(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    );

VOID FAR PASCAL
DMFunc(
    DWORD cb,
    LPDBB lpdbb
    );

XOSD FAR PASCAL
DMInit(
    DMTLFUNCTYPE lpfnTl,
    LPTSTR        lpch
    );

BOOL fTlConnected;
BOOL fDMConnected;
LPVOID pvDMBuffer;
DWORD cbDMBuffer;
DWORD ibDMBuffer;
RTL_CRITICAL_SECTION csDMRequest;
RTL_CRITICAL_SECTION csEMRequest;
RTL_CRITICAL_SECTION csPacket;
KEVENT kevtReply;
KEVENT kevtRequest;
KEVENT kevtPacket;
PDM_CMDCONT g_pdmcc;
BYTE rgbSendPacketBuffer[1024];
int ibSendPacketBuffer;
BYTE rgbReceivePacketBuffer[1024];
int ibReceivePacketBuffer;
BOOL fUsingReceivePacketBuffer;

void AcquireSendPacket(void)
{
	/* We need to use the global packet buffer.  First we wait for its
	 * availability */
	EnterCriticalSection(&csPacket);
	KeWaitForSingleObject(&kevtPacket, UserRequest, KernelMode, FALSE,
		NULL);
	KeResetEvent(&kevtPacket);
	LeaveCriticalSection(&csPacket);
}

void FillPacket64(LPSTR sz, BYTE *pb, DWORD cb)
{
	WORD w = 0;
	int ibit = 0;
	while(cb--) {
		w |= *pb++ << ibit;
		ibit += 8;
		while(ibit >= 6) {
			*sz++ = (w & 0x3f) + '!';
			w >>= 6;
			ibit -= 6;
		}
	}
	if(ibit)
		*sz++ = (w & 0x3f) + '!';
	*sz = 0;
}

int GetPacket64(LPCSTR sz, BYTE *pb, DWORD cb)
{
	DWORD ib = 0;
	WORD w = 0;
	int ibit = 0;
	while(*sz) {
		w |= (*sz++ - '!') << ibit;
		ibit += 6;
		while(ibit >= 8) {
			if(++ib > cb)
				return -1;
			*pb++ = w & 0xff;
			w >>= 8;
			ibit -= 8;
		}
	}
	return ib;
}

XOSD SendTlPacket(char ch, DWORD cb, PVOID pv)
{
	XOSD xosd = xosdNone;

	if(ch != 'p') {
		/* We have an available packet, so set it up */
		char sz[512];
		sprintf(sz, "msvc!%c ", ch);

		if(cb < 256) {
			/* Short packets can be translated and sent on the notification
			 * line */
			FillPacket64(sz + 7, pv, cb);
			DmSendNotificationString(sz);
		} else {
			AcquireSendPacket();
			if(cb <= sizeof rgbSendPacketBuffer) {
				ibSendPacketBuffer = cb;
				memcpy(rgbSendPacketBuffer, pv, cb);
				sz[6] = 'g';
				DmSendNotificationString(sz);
			} else
				/* Should probably assert here */
				xosd = xosdUnknown;
		}
	} else if(g_pdmcc) {
		DPRINT(5, ("dxt: reply\n"));
		g_pdmcc->DataSize = cb;
		memcpy(g_pdmcc->Buffer, pv, cb);
		KeSetEvent(&kevtRequest, EVENT_INCREMENT, FALSE);
	} else {
		/* What are we replying to? */
		assert(FALSE);
	}
	return xosd;
}

XOSD TLFunc(TLF tlf, HPID hpid, LPARAM wParam, LPARAM lParam)
{
	XOSD xosd = xosdNone;

	switch(tlf)
	{
	case tlfSetBuffer:
		pvDMBuffer = (LPVOID)lParam;
		cbDMBuffer = wParam;
		break;
	
	case tlfRequest:
		if(!fTlConnected)
			xosd = xosdLineNotConnected;
		else {
			EnterCriticalSection(&csDMRequest);
            DPRINT(5, ("dxt: dmrequest\n"));
			SendTlPacket('q', wParam, (PVOID)lParam);
			KeWaitForSingleObject(&kevtReply, UserRequest, KernelMode, FALSE,
				NULL);
            DPRINT(5, ("dxt: got dmreply\n"));
			LeaveCriticalSection(&csDMRequest);
			/* Reply packets come back into the correct buffer, so we just
			 * need to extract the xosd and we're done */
			if(ibDMBuffer == 0)
				xosd = xosdInvalidParameter;
		}
		break;

	case tlfReply:
		if(!fTlConnected)
			xosd = xosdLineNotConnected;
		else
			xosd = SendTlPacket('p', wParam, (PVOID)lParam);
		break;

	case tlfDebugPacket:
		if(!fTlConnected)
			xosd = xosdLineNotConnected;
		else
			SendTlPacket('d', wParam, (PVOID)lParam);
		break;
	}

	return xosd;
}

HRESULT HrGetPacket(LPCSTR szCommand, PDM_CMDCONT pdmcc)
{
	HRESULT hr;
	BOOL fAllocated = FALSE;

	/* Get a buffer to stick this packet into */
	if(szCommand[6] == 'g') {
		/* Binary data coming in, so get its length and set things up */
		const char *pch = szCommand + 7;
		pdmcc->BytesRemaining = 0;
		while(*pch)
			pdmcc->BytesRemaining = 10 * pdmcc->BytesRemaining +
				(*pch++ - '0');
		if(!pdmcc->BytesRemaining)
			/* No data means no packet */
			return E_FAIL;
		if(!pdmcc->Buffer) {
			if(InterlockedExchange(&fUsingReceivePacketBuffer, TRUE)) {
				pdmcc->Buffer = ExAllocatePoolWithTag(PagedPool,
					pdmcc->BytesRemaining, 'cvsm');
				if(!pdmcc->Buffer)
					return E_OUTOFMEMORY;
				pdmcc->BufferSize = pdmcc->BytesRemaining;
				fAllocated = TRUE;
			} else {
				pdmcc->Buffer = rgbReceivePacketBuffer;
				pdmcc->BufferSize = sizeof rgbReceivePacketBuffer;
			}
		}
		if(pdmcc->BytesRemaining > pdmcc->BufferSize) {
TooBig:
			/* Too much data */
			ExFreePoolWithTag(pdmcc->Buffer, 'cvsm');
			return E_FAIL;
		}
		pdmcc->CustomData = (PVOID)pdmcc->BytesRemaining;
		hr = XBDM_READYFORBIN;
	} else {
		int ib;

		if(!pdmcc->Buffer) {
			pdmcc->BufferSize = sizeof rgbReceivePacketBuffer;
			if(InterlockedExchange(&fUsingReceivePacketBuffer, TRUE)) {
				pdmcc->Buffer = ExAllocatePoolWithTag(PagedPool,
					pdmcc->BufferSize, 'cvsm');
				if(!pdmcc->Buffer)
					return E_OUTOFMEMORY;
				fAllocated = TRUE;
			} else
				pdmcc->Buffer = rgbReceivePacketBuffer;
		}
		ib = GetPacket64(szCommand + 7, pdmcc->Buffer,
			pdmcc->BufferSize);
		if(ibReceivePacketBuffer < 0)
			goto TooBig;

		pdmcc->DataSize = ib;
		hr = XBDM_NOERR;
	}
	return hr;
}

HRESULT SendPacketData(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp)
{
	HRESULT hr;

	if(pdmcc->BytesRemaining == 0) {
		/* We're done with the send buffer now */
		KeSetEvent(&kevtPacket, EVENT_INCREMENT, FALSE);
		hr = XBDM_ENDOFLIST;
	} else if(pdmcc->Buffer == pdmcc) {
		/* We haven't sent anything yet.  We need to send the length first */
		pdmcc->Buffer = &pdmcc->BytesRemaining;
		pdmcc->DataSize = sizeof pdmcc->BytesRemaining;
		hr = XBDM_NOERR;
	} else {
		/* We've sent the length, now send the data */
		pdmcc->Buffer = pdmcc->CustomData;
		pdmcc->DataSize = pdmcc->BytesRemaining;
		pdmcc->BytesRemaining = 0;
		hr = XBDM_NOERR;
	}
	return hr;
}

HRESULT HrDeliverPacket(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp,
	BOOL fCanBinSend)
{
	HRESULT hr;
	int cbTextMax;

	/* Now what do we do with the reply packet?  The theory is that anything
	 * less than 256 bytes is best sent text-encoded in the response, and that
	 * anything bigger than that should be sent in a binary response.  If we
	 * can't send a binary response, we'll send as text if it will fit into the
	 * text buffer */
	cbTextMax = (cchResp - 8) * 3 / 4;
	if(fCanBinSend && cbTextMax > 256)
		cbTextMax = 256;
	if(pdmcc->DataSize < (DWORD)cbTextMax) {
		if(pdmcc->DataSize == 0) {
			/* Huh? */
			_asm int 3
		}
		szResp[0] = 'p';
		FillPacket64(szResp + 1, pdmcc->Buffer, pdmcc->DataSize);
		if(pdmcc->Buffer = rgbSendPacketBuffer)
			/* We're done with the send buffer now */
			KeSetEvent(&kevtPacket, EVENT_INCREMENT, FALSE);
		hr = XBDM_NOERR;
	} else if(fCanBinSend) {
		/* We're able to send a binary response, so we'll do so */
		pdmcc->HandlingFunction = SendPacketData;
		pdmcc->BytesRemaining = pdmcc->DataSize;
		pdmcc->CustomData = pdmcc->Buffer;
		pdmcc->Buffer = pdmcc;
		hr = XBDM_BINRESPONSE;
	} else {
		/* We need to advertise that the response is available as a
		 * get-packet */
		szResp[0] = 'g';
		szResp[1] = 0;
		hr = XBDM_NOERR;
	}
	return hr;
}

HRESULT HrDoRequest(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp,
	BOOL fCanBinSend)
{
	BYTE *pbRequest = pdmcc->Buffer;
	DWORD cbRequest = pdmcc->DataSize;
	int cbTextMax;

	/* Prepare to receive the reply and do the action */
	EnterCriticalSection(&csEMRequest);
	g_pdmcc = pdmcc;
	AcquireSendPacket();
	pdmcc->Buffer = rgbSendPacketBuffer;
	pdmcc->BufferSize = sizeof rgbSendPacketBuffer;
	pdmcc->DataSize = 0;
	DPRINT(5, ("dxt: request\n"));
	DMFunc(cbRequest, (LPDBB)pbRequest);
	/* Wait for the reply to come through before continuing */
	KeWaitForSingleObject(&kevtRequest, UserRequest, KernelMode, FALSE,
		NULL);
	DPRINT(5, ("dxt: got reply\n"));
	g_pdmcc = NULL;
	LeaveCriticalSection(&csEMRequest);
	/* OK, we have our response data.  Send it now if we can, or mark
	 * it available for later.  In either case, we're done with the
	 * receive buffer so we can accept another request */
	if(pbRequest != rgbReceivePacketBuffer)
		ExFreePoolWithTag(pbRequest, 'cvsm');
	fUsingReceivePacketBuffer = FALSE;
	return HrDeliverPacket(pdmcc, szResp, cchResp, fCanBinSend);
}

void DoReply(PDM_CMDCONT pdmcc)
{
	ibDMBuffer = pdmcc->DataSize;
    DPRINT(5, ("dxt: dmreply\n"));
	KeSetEvent(&kevtReply, EVENT_INCREMENT, FALSE);
}

BOOL FHandleIncomingData(PDM_CMDCONT pdmcc)
{
	if(!pdmcc->DataSize) {
		/* We've lost our socket, so we'll discard what we've got and clean
		 * up */
		pdmcc->Buffer = (LPBYTE)pdmcc->Buffer + pdmcc->BytesRemaining -
			(DWORD)pdmcc->CustomData;
		if(pdmcc->Buffer != rgbReceivePacketBuffer)
			ExFreePoolWithTag(pdmcc->Buffer, 'cvsm');
		return FALSE;
	}
	pdmcc->Buffer = (LPBYTE)pdmcc->Buffer + pdmcc->DataSize;
	pdmcc->BytesRemaining -= pdmcc->DataSize;
	if(pdmcc->BytesRemaining == 0) {
		/* Restore the buffer pointer */
		pdmcc->Buffer = (LPBYTE)pdmcc->Buffer - (DWORD)pdmcc->CustomData;
		pdmcc->DataSize = (DWORD)pdmcc->CustomData;
	}
	return TRUE;
}

HRESULT HandleRequest(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp)
{
	if(!FHandleIncomingData(pdmcc) || pdmcc->BytesRemaining != 0)
		return XBDM_NOERR;
	return HrDoRequest(pdmcc, szResp, cchResp, FALSE);
}

HRESULT HandleReply(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp)
{
	if(!FHandleIncomingData(pdmcc) || pdmcc->BytesRemaining != 0)
		return XBDM_NOERR;
	DoReply(pdmcc);
	return XBDM_NOERR;
}

HRESULT HandleDebugPacket(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp)
{
	if(!FHandleIncomingData(pdmcc) || pdmcc->BytesRemaining != 0)
		return XBDM_NOERR;
	DMFunc(pdmcc->DataSize, pdmcc->Buffer);
	return XBDM_NOERR;
}

HRESULT HrMsvcCmdProcessor(LPCSTR szCommand, LPSTR szResp, DWORD cchResp,
	PDM_CMDCONT pdmcc)
{
	XOSD xosd;
	HRESULT hr;

	switch(szCommand[5]) {
	case 'c':
		/* tlfConnect */
		if(fTlConnected)
			/* Can't connect twice */
			hr = E_FAIL;
		else {
			fTlConnected = TRUE;
			hr = XBDM_DEDICATED;
		}
		break;

	case 'l':
		/* tlfLoadDM */
		if(!fTlConnected)
			xosd = xosdLineNotConnected;
		else if(fDMConnected)
			xosd = xosdNone;
		else
			xosd = DMInit(TLFunc, NULL) ? xosdUnknown : xosdNone;
		hr = 0;
		break;

	case 'q':
		/* tlfRequest */
		if(!fTlConnected) {
			sprintf(szResp, "x%d", xosdLineNotConnected);
			hr = XBDM_NOERR;
		} else {
			pdmcc->HandlingFunction = HandleRequest;
			pdmcc->Buffer = NULL;
			/* First get the incoming packet */
			hr = HrGetPacket(szCommand, pdmcc);
			if(hr == XBDM_NOERR)
				hr = HrDoRequest(pdmcc, szResp, cchResp, TRUE);
		}
		break;

	case 'p':
		/* tlfReply */
		if(!fTlConnected) {
			sprintf(szResp, "x%d", xosdLineNotConnected);
			hr = XBDM_NOERR;
		} else {
			pdmcc->HandlingFunction = HandleReply;
			pdmcc->Buffer = pvDMBuffer;
			pdmcc->BufferSize = cbDMBuffer;
			hr = HrGetPacket(szCommand, pdmcc);
			if(hr == XBDM_NOERR)
				DoReply(pdmcc);
		}
		break;

	case 'd':
		/* tlfDebugPacket */
		if(!fTlConnected) {
			sprintf(szResp, "x%d", xosdLineNotConnected);
			hr = XBDM_NOERR;
		} else {
			pdmcc->HandlingFunction = HandleDebugPacket;
			pdmcc->Buffer = NULL;
			hr = HrGetPacket(szCommand, pdmcc);
			if(hr == XBDM_NOERR)
				DMFunc(pdmcc->DataSize, pdmcc->Buffer);
		}
		break;

	case 'g':
		/* not a tlf -- need to get the available debug packet */
		if(!fTlConnected) {
			sprintf(szResp, "x%d", xosdLineNotConnected);
			hr = XBDM_NOERR;
		} else if(!kevtPacket.Header.SignalState)
			/* No packet available */
			hr = E_FAIL;
		else {
			pdmcc->Buffer = rgbSendPacketBuffer;
			pdmcc->DataSize = ibSendPacketBuffer;
			hr = HrDeliverPacket(pdmcc, szResp, cchResp, TRUE);
		}
		break;

	default:
		hr = XBDM_INVALIDCMD;
		break;
	}

	if(!hr) {
		sprintf(szResp, "x%d", xosd);
		hr = XBDM_NOERR;
	}
	return hr;
}

void DxtEntry(ULONG unused1, ULONG unused2, ULONG unused3)
{
	/* Set up some things */
	InitializeCriticalSection(&csDMRequest);
	InitializeCriticalSection(&csEMRequest);
	InitializeCriticalSection(&csPacket);
	KeInitializeEvent(&kevtReply, SynchronizationEvent, FALSE);
	KeInitializeEvent(&kevtRequest, SynchronizationEvent, FALSE);
	KeInitializeEvent(&kevtPacket, NotificationEvent, TRUE);

	/* Register our command processor */
	DmRegisterCommandProcessor("MSVC", HrMsvcCmdProcessor);

	/* Send a DLL init to the DM */
	DmDllMain(NULL, DLL_PROCESS_ATTACH, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\msvc\dxt\linklist.h ===
//////////////////////////////////////////////////////////////////////
//
//  PRIVATE header file for linklist utility
//
//////////////////////////////////////////////////////////////////////
//
//  A Linked List Entry
//
typedef struct _lle
    {
#ifdef DEBUGVER
    WORD            wTest;      // consistency check
#endif
    HLLE            hlleNext;
#ifdef DBLLINK
    HLLE            hllePrev;
#endif // DBLLINK
    WORD            rgw[0];     // Variable length data
    } LLE;
typedef LLE *       PLLE;
typedef LLE FAR *   LPLLE;
//
// Linked List Information
//
typedef struct _lli
    {
    HLLE            hlleHead;
    HLLE            hlleTail;
    DWORD           chlleMac;
    void *          pcs;                // pointer to critical section object
    DWORD           cbUserData;         // How big the user data is
    LLF             llf;                // LinkList Flags
    LPFNKILLNODE    lpfnKill;           // Callback for deletion of node
    LPFNFCMPNODE    lpfnCmp;            // Callback for node comparison
    } LLI;
typedef LLI *       PLLI;
typedef LLI FAR *   LPLLI;
//
//  Some NICE nulls (for clean code)
//
#define hlliNull    (HLLI)NULL
#define hlleNull    (HLLE)NULL
//
// These help keep the code clean
//
#define LockHlle(hlle)      ((LPLLE)LockHmem(hlle))
#define LockHlli(hlli)      ((LPLLI)LockHmem(hlli))
#define HlliAlloc()         ((HLLI)AllocHmem(sizeof(LLI)))
#define HlleAllocCb(cb)     ((HLLE)AllocHmem(cb))
#define FreeHlli(hlli)      FreeHmem(hlli)
#define FreeHlle(hlle)      FreeHmem(hlle)
#define UnlockHlli(hlli)	UnlockHmem(hlli)
#define UnlockHlle(hlle)	UnlockHmem(hlle)

//
//  PRIVATE INTERNAL ROUTINES
//
void PASCAL LLInsertHlle( HLLI, HLLE, HLLE, HLLE );
void PASCAL LLDeleteHlle( HLLI, HLLE, HLLE );
DWORD PASCAL LLChlleInLl( HLLI );

//
// Some debug stuff
//
#ifdef DEBUGVER
#define WCONSIST        (WORD)0xabcd
#endif // DEBUGVER

#define AllocHmem(cb) ExAllocatePoolWithTag(PagedPool, cb, 'illh')
#define FreeHmem(pv) ExFreePoolWithTag(pv, 'illh')
#define LockHmem(pv) (pv)
#define UnlockHmem(pv)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\msvc\wintl\resource.h ===
// item ID values for setup dialog

#define IDNAME  101
#define IDPW    103
#define IDFORCE 104
#define IDC_CHECK_SELF_DEBUG        105

#define IDS_ERR_STARTUP				100
#define IDS_ERR_CONNECT				101
#define IDS_ERR_NOT_FOUND			102
#define IDS_ERR_RESOLVE				103
#define IDS_ERR_GENERIC				104
#define IDS_ERR_VERSION				105
#define IDS_ERR_PASSWORD			106
#define IDS_ERR_SOCKET				107
#define IDS_ERR_SETTINGS			108
#define IDS_ERR_SERVER_IN_USE		111

#define IDS_ERR_CANNOT_INITIALIZE   121
#define IDS_ERR_CANNOT_CONNECT      122
#define IDS_ERR_NOT_AUTHORIZED      123

#define IDS_HELP					109	
#define IDS_MSGBOX_TITLE			110	


//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by DM.RC
//
#define IDS_STATUS_DLL_NOT_FOUND			1
//#define IDS_tstRunnable						2
//#define IDS_tstStopped						3
//#define IDS_tstRunning						4
//#define IDS_tstExiting						5
//#define IDS_tstDead							6
// These strings are currently hard-coded in PROCEM.C
//#define IDS_DBG_CONTROL_C					7
//#define IDS_DBG_CONTROL_BREAK 				8
//#define IDS_EXCEPTION_DATATYPE_MISALIGNMENT 9
//#define IDS_EXCEPTION_ACCESS_VIOLATION		10
//#define IDS_EXCEPTION_IN_PAGE_ERROR			11
//#define IDS_STATUS_ILLEGAL_INSTRUCTION		12
//#define IDS_EXCEPTION_ARRAY_BOUNDS_EXCEEDED 13	
//#define IDS_EXCEPTION_FLT_DENORMAL_OPERAND	14
//#define IDS_EXCEPTION_FLT_DIVIDE_BY_ZERO	15
//#define IDS_EXCEPTION_FLT_INEXACT_RESULT	16
//#define IDS_EXCEPTION_FLT_INVALID_OPERATION 17
//#define IDS_EXCEPTION_FLT_OVERFLOW			18
//#define IDS_EXCEPTION_FLT_STACK_CHECK		19
//#define IDS_EXCEPTION_FLT_UNDERFLOW			20
//#define IDS_STATUS_NO_MEMORY				21
//#define IDS_STATUS_NONCONTINUABLE_EXCEPTION 22
//#define IDS_STATUS_INVALID_DISPOSITION		23
//#define IDS_EXCEPTION_INT_DIVIDE_BY_ZERO	24
//#define IDS_EXCEPTION_INT_OVERFLOW			25
//#define IDS_EXCEPTION_PRIV_INSTRUCTION		26
//#define IDS_STATUS_STACK_OVERFLOW			27
//#define IDS_STATUS_DLL_INIT_FAILED			28
//#define IDS_EXCEPTION_MSC_THROW				29
//#define IDS_EXCEPTION_UNKNOWN				30
//#define IDS_pstRunning						31
//#define IDS_pstStopped						32
//#define IDS_pstExited						33
//#define IDS_pstDead							34
// end of PROCEM.C strings
#define IDS_CANT_TRACE						35
#define IDS_CannotEnableORPC				36
#define IDS_FILE_NOT_FOUND					37
#define IDS_PATH_NOT_FOUND					38
#define IDS_INVALID_HANDLE					39
#define IDS_INVALID_DRIVE					40
#define IDS_INVALID_PARAMETER				41
#define IDS_INVALID_NAME					42
#define IDS_BAD_PATHNAME					43
#define IDS_FILENAME_EXCED_RANGE			44
#define IDS_OUTOFMEMORY						45
#define IDS_NOT_ENOUGH_MEMORY				46
#define IDS_ACCESS_DENIED					47
#define IDS_SHARING_VIOLATION				48
#define IDS_OPEN_FAILED						49
#define IDS_BAD_FORMAT						50
#define IDS_CHILD_NOT_COMPLETE				51
#define IDS_INVALID_MODULETYPE				52
#define IDS_INVALID_EXE_SIGNATURE			53
#define IDS_EXE_MARKED_INVALID				54
#define IDS_BAD_EXE_FORMAT					55
#define IDS_DIRECTORY						56
#define IDS_UNKNOWN_ERROR					57
#define IDS_COULD_NOT_LOAD_DEBUGGEE			58
#define IDS_EXECUTE_FAILED					59
#define IDS_EXECUTE_OK						60
#define IDS_NTError							61
#define IDS_UnknownExe						62
#define IDS_NOSQLDEBUG						63
#define	IDS_BREAK_FAILED					64
#define IDS_DEADLOCK						65
#define IDS_NO_THREAD						66

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           130
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\api32.c ===
/*
 *
 * api.c
 *
 * Implementation of the Win32 APIs needed for winsock, on top of ntoskrnl
 *
 */

#include "dmp.h"

BOOL QueryPerformanceCounter(PLARGE_INTEGER pli)
{
    *pli = KeQueryPerformanceCounter();
    return TRUE;
}

BOOL QueryPerformanceFrequency(PLARGE_INTEGER pli)
{
    *pli = KeQueryPerformanceFrequency();
    return TRUE;
}

void SetLastError(DWORD dwErrCode)
{
    DmGetCurrentDmtd()->LastError = dwErrCode;
}

DWORD GetLastError(void)
{
    return DmGetCurrentDmtd()->LastError;
}

#if 0
void DebugBreak(void)
{
    DbgBreakPoint();
}
#endif

HLOCAL LocalAlloc(UINT uFlags, SIZE_T cb)
{
    PVOID pv;

    if(uFlags & (LMEM_MOVEABLE | LMEM_DISCARDABLE))
        pv = NULL;
    else {
        pv = DmAllocatePool(cb + 8);
        if(pv) {
            *((DWORD *)pv)++ = 'kmem';
            *((DWORD *)pv)++ = 'dbgr';
            if(uFlags & LMEM_ZEROINIT)
                RtlZeroMemory(pv, cb);
            }
        }
    return (HLOCAL)pv;
}

HLOCAL LocalFree(HLOCAL h)
{
    HLOCAL hRet = h;
    DWORD *pdw = (DWORD *)h;
    try {
        if(h && pdw[-1] == 'dbgr' && pdw[-2] == 'kmem') {
            DmFreePool(pdw - 2);
            hRet = NULL;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }
    return hRet;
}

void Sleep(DWORD dw)
{
    SleepEx(dw, FALSE);
}

DWORD SleepEx(DWORD dw, BOOL f)
{
    LARGE_INTEGER li;
    NTSTATUS st;

    if(dw == -1)
        {
        li.LowPart = 0;
        li.HighPart = 0x80000000;
        }
    else
        {
        li.QuadPart = UInt32x32To64(dw, 10000);
        li.QuadPart *= -1;
        }
    do
        st = KeDelayExecutionThread(UserMode, (BOOLEAN)f, &li);
    while(f && STATUS_ALERTED == st);
    return st == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

HANDLE CreateEvent(LPSECURITY_ATTRIBUTES psa, BOOL fManualReset,
    BOOL fInitState, PCOSTR lpwzName)
{
    NTSTATUS st;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;

    ASSERT(NULL == lpwzName);

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    st = NtCreateEvent(&h, &oa, fManualReset ?
        NotificationEvent : SynchronizationEvent, (BOOLEAN)fInitState);
    if(NT_SUCCESS(st))
        SetLastError(0);
    else
        {
        SetLastError(RtlNtStatusToDosError(st));
        h = NULL;
        }
    return h;
}

ULONG _DmUnhandledException(PEXCEPTION_POINTERS pep)
{
    KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
        (ULONG_PTR)pep->ExceptionRecord->ExceptionAddress, 0, 0, 0);
    return EXCEPTION_EXECUTE_HANDLER;
}

void _DmThreadStartup(PKSTART_ROUTINE StartRoutine, PVOID StartContext)
{
    DWORD dwExit;

    KeLowerIrql(0);
    try {
        dwExit = (*(LPTHREAD_START_ROUTINE)StartRoutine)(StartContext);
    } except(_DmUnhandledException(GetExceptionInformation())) {
        KeBugCheck(KMODE_EXCEPTION_NOT_HANDLED);
    }
    
    PsTerminateSystemThread(dwExit);
}

HANDLE CreateThread(LPSECURITY_ATTRIBUTES psa, DWORD dwStack,
    LPTHREAD_START_ROUTINE lpfn, LPVOID lpv, DWORD dwFlags, LPDWORD lpdwId)
{
    NTSTATUS st;
    HANDLE h;

    st = PsCreateSystemThreadEx(&h, 0, dwStack, 0, (PHANDLE)lpdwId,
		(PKSTART_ROUTINE)lpfn, lpv, (BOOLEAN)(dwFlags & CREATE_SUSPENDED ?
		TRUE : FALSE), TRUE, _DmThreadStartup);
    
    if(!NT_SUCCESS(st))
        {
        SetLastError(RtlNtStatusToDosError(st));
        return NULL;
        }
    
    return h;
}

BOOL CloseHandle(HANDLE h)
{
    NTSTATUS st = NtClose(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL SetEvent(HANDLE h)
{
    NTSTATUS st = NtSetEvent(h, NULL);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL ResetEvent(HANDLE h)
{
    NTSTATUS st = NtClearEvent(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lph, BOOL fWaitAll,
    DWORD dwTimeOut, BOOL fAlertable)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;
    HANDLE rgh[MAXIMUM_WAIT_OBJECTS];

    if(nCount > MAXIMUM_WAIT_OBJECTS)
    {
        SetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
        return (DWORD)-1;
    }

    RtlCopyMemory(rgh, lph, nCount * sizeof(HANDLE));
    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    do
        st = NtWaitForMultipleObjectsEx((CHAR)nCount, rgh,
            fWaitAll ? WaitAll : WaitAny, UserMode, (BOOLEAN)fAlertable, pli);
    while(st == STATUS_ALERTED && fAlertable);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}

DWORD WaitForSingleObject(HANDLE h, DWORD dwTimeOut)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;

    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    st = NtWaitForSingleObjectEx(h, UserMode, FALSE, pli);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}

//
// The functions below are copied from xapi\k32\debug.c and are needed
// by xnet for debug spew...  let's keep them in sync!
//

#if 0
#if DBG

#include <xdbg.h>

ULONG XDebugOutLevel = XDBG_WARNING;
ULONG XDebugBrkLevel = XDBG_ERROR;

PSTR XDebugLevels[] =
{
    "!!!",
    "ERR",
    "WRN",
    "TRC",
    "ENT",
    "EXT"
};

VOID
XDBGAPI
vXDebugPrint(ULONG Level, PCHAR Module, PCHAR Format, va_list arglist)
{
    CHAR string[MAX_PATH];

    if (Level <= XDebugOutLevel)
    {
        _vsnprintf(string, sizeof(string), Format, arglist);
        DbgPrint("%s[%s]: %s\n", (Level <= XDBG_EXIT) ? XDebugLevels[Level] : "???", Module, string);
        if (Level <= XDebugBrkLevel)
        {
            _asm { int 3 };
        }
    }
}

VOID
XDBGAPIV
XDebugPrint(ULONG Level, PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(Level, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugError(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_ERROR, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugWarning(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_WARNING, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugTrace(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_TRACE, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugEntry(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_ENTRY, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugExit(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_EXIT, Module, Format, arglist);
    va_end(arglist);
}

#endif // DBG
#endif // 0

#if 0
BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *pliDue, LONG lPer,
    PTIMERAPCROUTINE pfn, LPVOID lpArg, BOOL fResume)
{
    NTSTATUS st;

    st = NtSetTimer(hTimer, (PLARGE_INTEGER)pliDue, (PTIMER_APC_ROUTINE)pfn,
        lpArg, (BOOLEAN)fResume, lPer, NULL);

    if(!NT_SUCCESS(st))
    {
        SetLastError(RtlNtStatusToDosError(st));
        return FALSE;
    }
    if(st == STATUS_TIMER_RESUME_IGNORED)
        SetLastError(ERROR_NOT_SUPPORTED);
    else
        SetLastError(0);
    return TRUE;
}

HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES psa, BOOL fManualReset,
    LPCWSTR lpwzName)
{
    NTSTATUS st;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;

    ASSERT(NULL == lpwzName);

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    st = NtCreateTimer(&h, &oa, fManualReset ?
        NotificationTimer : SynchronizationTimer);
    if(NT_SUCCESS(st))
        SetLastError(0);
    else
        {
        SetLastError(RtlNtStatusToDosError(st));
        h = NULL;
        }
    return h;
}

BOOL CancelWaitableTimer(HANDLE h)
{
    NTSTATUS st = NtCancelTimer(h, NULL);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\crc.c ===
#include "dmp.h"

const unsigned long CrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

unsigned long
Crc32(
    unsigned long InitialCrc,
    const void *Buffer,
    unsigned long Bytes
    )
{
    unsigned long Crc = InitialCrc;
    const unsigned char *p = (unsigned char *)Buffer;
    unsigned long Count = Bytes;

    while ( Count-- ) {
        Crc = ( Crc >> 8 ) ^ CrcTable32[ ((unsigned char)(Crc)) ^ *p++ ];
    }

    return Crc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\msvc\wintl\tlxbox.cpp ===
/*
 *
 * tlxbox.cpp
 *
 * VC-Xbox transport
 *
 */

#include "precomp.h"
#include "tlutil.h"

HINSTANCE hInstance;
LPDBF lpdbf;
TLCALLBACKTYPE lpfnTlCallback;

#if DBG
    DEBUG_VERSION ('T', 'L', "TCP/IP Transport for Xbox");
#else
    RELEASE_VERSION ('T', 'L', "TCP/IP Transport for Xbox");
#endif

HPID g_hpid;
PDM_CONNECTION pdconMain;
PDM_CONNECTION pdconPoll;
BYTE *pbEMBuffer;
DWORD cbEMBuffer;
DWORD ibEMBuffer;
BYTE rgbReceiveBuffer[1024];
int ibReceiveBuffer;

BOOL WINAPI
DllMain(
    HINSTANCE   hInst,
    ULONG       uReason,
    LPVOID      lpReserved
    )
{

    switch (uReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls (hInst);
            hInstance = hInst;
        break;

        case DLL_PROCESS_DETACH:
            hInstance = NULL;
        break;

    }

    return TRUE;
}

LPAVS
DBGVersionCheck(
    )
{
    return &Avs;
}

void FillPacket64(LPSTR sz, BYTE *pb, DWORD cb)
{
	WORD w = 0;
	int ibit = 0;
	while(cb--) {
		w |= *pb++ << ibit;
		ibit += 8;
		while(ibit >= 6) {
			*sz++ = (w & 0x3f) + '!';
			w >>= 6;
			ibit -= 6;
		}
	}
	if(ibit)
		*sz++ = (w & 0x3f) + '!';
	*sz = 0;
}

int GetPacket64(LPCSTR sz, BYTE *pb, DWORD cb)
{
	DWORD ib = 0;
	WORD w = 0;
	int ibit = 0;
	while(*sz) {
		w |= (*sz++ - '!') << ibit;
		ibit += 6;
		while(ibit >= 8) {
			if(++ib > cb)
				return -1;
			*pb++ = w & 0xff;
			w >>= 8;
			ibit -= 8;
		}
	}
	assert(!w);
	return ib;
}

XOSD XosdSendTlPacket(PDM_CONNECTION s, char ch, DWORD cb, PVOID pv, BOOL fReply)
{
	HRESULT hr;
	char sz[512];
	DWORD cch = sizeof sz;
	XOSD xosd;
	BYTE *pbRet;
	DWORD *pcbRet;
	DWORD cbMax;

	if(fReply) {
		pbRet = pbEMBuffer;
		pcbRet = &ibEMBuffer;
		cbMax = cbEMBuffer;
	} else {
		pbRet = rgbReceiveBuffer;
		pcbRet = (DWORD *)&ibReceiveBuffer;
		cbMax = sizeof rgbReceiveBuffer;
	}

	sprintf(sz, "msvc!%c ", ch);
	if(ch == '0') {
		/* We're not actually sending a packet, we're going to send a
		 * command.  We're doing it through here so we can get the xosd
		 * return */
		hr = DmSendCommand(s, (LPCSTR)pv, sz, &cch);
	} else if(pv) {
		/* First we're going to send.  We follow the logic that 256 bytes is
		 * the breakeven between encoded and binary */
		if(cb > 256) {
			int cbT;

			sprintf(sz + 6, "g%d", cb);
			hr = DmSendCommand(s, sz, NULL, 0);
			if(FAILED(hr))
				return xosdGeneral;
			assert(hr == XBDM_READYFORBIN);
			if(FAILED(DmSendBinary(s, pv, cb)))
				return xosdGeneral;
			hr = DmReceiveStatusResponse(s, sz, &cch);
		} else {
			FillPacket64(sz + 7, (LPBYTE)pv, cb);
			hr = DmSendCommand(s, sz, sz, &cch);
		}
	} else
		/* No packet; we're going to do a get */
		hr = DmSendCommand(s, "msvc!g", sz, &cch);

	if(FAILED(hr))
		xosd = xosdGeneral;
	else if(hr == XBDM_BINRESPONSE) {
		/* We got a packet coming back */
		BYTE *pb = (BYTE *)pcbRet;
		DWORD cb = sizeof(DWORD);
		int i;

		/* First we read the data size, then we read the data */
		for(i = 0; i < 2; ++i) {
			if(FAILED(DmReceiveBinary(s, pb, cb, NULL)))
				return xosdGeneral;

			/* Got the data size, so set up for the data */
			if(!i) {
				pb = pbRet;
				cb = *pcbRet;
				assert(cb <= cbMax);
			}
		}
		xosd = xosdNone;
	} else {
		int i;

		/* We got back a valid response */
		switch(sz[5]) {
		case 'p':
			/* We have a packet in the reply */
			i = GetPacket64(sz + 6, pbRet, cbMax);
			if(i < 0) {
				assert(false);
				*pcbRet = cbMax;
			} else
				*pcbRet = i;
			xosd = xosdNone;
			break;
		case 'g':
			/* The packet is there for the taking */
			xosd = XosdSendTlPacket(s, 'g', cb, pv, fReply);
			break;
		case 'x':
			/* No packet, but an xosd */
			if(!sscanf(sz + 6, "%d", &i))
				xosd = xosdUnknown;
			else
				xosd = i;
			break;
		}
	}

	return xosd;
}

DWORD Notify(LPCSTR sz)
{
	if(sz[6] == 'g') {
		if(!pdconPoll || XosdSendTlPacket(pdconPoll, 'g', 0, NULL, TRUE) !=
				xosdNone)
			/* Can't get the packet */
			return 0;
	} else {
		ibReceiveBuffer = GetPacket64(sz + 7, rgbReceiveBuffer, sizeof
			rgbReceiveBuffer);
		assert(ibReceiveBuffer >= 0);
	}

	/* Do we care what kind of packet this is? */
	lpfnTlCallback(g_hpid, ibReceiveBuffer, (LPARAM)rgbReceiveBuffer);
	return 0;
}

XOSD WINAPI
TLFunc(
    TLF     wCommand,
    HPID    hpid,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
	XOSD xosd = xosdNone;
	char szHostName[256];
	HRESULT hr;
	WSADATA wsad;

	switch(wCommand) {
	case tlfInit:
		lpdbf = (LPDBF)wParam;
		lpfnTlCallback = (TLCALLBACKTYPE)lParam;
		break;
		
	case tlfDestroy:
		break;

	case tlfGetVersion:
		memcpy((PVOID)lParam, &Avs, sizeof Avs);
		break;

	case tlfConnect:
		if(hpid == NULL)
			/* Just snooping around */
			return xosdNone;

		_asm int 3
		assert(!pdconMain);
		assert(g_hpid == NULL);
		g_hpid = hpid;

		/* Find the Xbox */
		if(GetHostName(mptUnknown, szHostName, sizeof szHostName,
				lpdbf->lpfnGetSet))
			DmSetXboxName(szHostName);

		/* Make sure we'll be able to receive notifications */
		if(FAILED(DmNotify(DM_PERSISTENT, NULL)))
			return xosdCannotConnect;
		if(FAILED(DmRegisterNotificationProcessor("msvc", Notify)))
			return xosdUnknown;

		/* Connect two sockets -- one for requests, and one to get reply
		 * packets */
		if(FAILED(DmOpenConnection(&pdconMain)))
			return xosdCannotConnect;
		if(FAILED(DmSendCommand(pdconMain, "kd disable", NULL, 0)) ||
			FAILED(DmSendCommand(pdconMain, "msvc!c", NULL, 0)) ||
			FAILED(DmOpenConnection(&pdconPoll)))
		{
			DmCloseConnection(pdconMain);
			return xosdCannotConnect;
		}

		/* We're connected now */
		break;

	case tlfDisconnect:
		DmNotify(0, NULL);
		if(pdconMain) {
			DmCloseConnection(pdconMain);
			pdconMain = NULL;
		}
		if(pdconPoll) {
			DmCloseConnection(pdconPoll);
			pdconPoll = NULL;
		}
		g_hpid = NULL;
		break;

	case tlfLoadDM:
		if(FAILED(DmSendCommand(pdconMain, "msvc!l", NULL, 0)))
			xosd = xosdGeneral;
		break;

	case tlfSetBuffer:
		pbEMBuffer = (LPBYTE)lParam;
		cbEMBuffer = wParam;
		break;

	case tlfRequest:
		xosd = XosdSendTlPacket(pdconMain, 'q', wParam, (LPVOID)lParam, TRUE);
		break;

	case tlfReply:
		xosd = XosdSendTlPacket(pdconPoll, 'p', wParam, (LPVOID)lParam, FALSE);
		break;

	case tlfDebugPacket:
		xosd = XosdSendTlPacket(pdconMain, 'd', wParam, (LPVOID)lParam, FALSE);
		break;

	default:
		assert(FALSE);
		xosd = xosdUnknown;
		break;
	}

	return xosd;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmbreak.c ===
/*
 *
 * dmbreak.c
 *
 * Breakpoint management
 *
 */

#include "dmp.h"

#define MAX_BPL_BREAKS 128
#define DMBP_ENABLED 1
#define DMBP_NOENABLE 2

typedef struct _BPL {
	int cBreaks;
	BYTE *rgpbBreaks[MAX_BPL_BREAKS];
	BYTE rgbInstrs[MAX_BPL_BREAKS];
	BYTE rgbFlags[MAX_BPL_BREAKS];
	struct _BPL *pbplNext;
} BPL;

BPL *pbplRoot;
BPL *pbplScratch;
RTL_CRITICAL_SECTION csBplScratch;
RTL_CRITICAL_SECTION csHwBps;
BPL *pbplTrace;
int iBreakTrace;
BOOL fHaltAllThreads;
DWORD dwExecState;
struct _HWBP {
	PVOID pvAddr;
	WORD wType;
	WORD wSize;
} rghwbp[4];

void InitBreakpoints(void)
{
	InitializeCriticalSection(&csBplScratch);
	InitializeCriticalSection(&csHwBps);
	DwExchangeDr6(0);
}

void DoEnableBreak(BPL *pbpl, int iBreak)
{
	KIRQL irqlSav;
	HARDWARE_PTE pte;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(!(pbpl->rgbFlags[iBreak] & (DMBP_ENABLED | DMBP_NOENABLE)) &&
			MmDbgWriteCheck(pbpl->rgpbBreaks[iBreak], &pte)) {
		pbpl->rgbInstrs[iBreak] = *pbpl->rgpbBreaks[iBreak];
		*pbpl->rgpbBreaks[iBreak] = 0xcc;
		pbpl->rgbFlags[iBreak] |= DMBP_ENABLED;
		MmDbgReleaseAddress(pbpl->rgpbBreaks[iBreak], &pte);
	}
	KeLowerIrql(irqlSav);
}

void DoDisableBreak(BPL *pbpl, int iBreak)
{
	KIRQL irqlSav;
	HARDWARE_PTE pte;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(pbpl->rgbFlags[iBreak] & DMBP_ENABLED &&
			MmDbgWriteCheck(pbpl->rgpbBreaks[iBreak], &pte)) {
		*pbpl->rgpbBreaks[iBreak] = pbpl->rgbInstrs[iBreak];
		MmDbgReleaseAddress(pbpl->rgpbBreaks[iBreak], &pte);
	}
	pbpl->rgbFlags[iBreak] &= ~DMBP_ENABLED;
	KeLowerIrql(irqlSav);
}

void DoSyncBreak(BPL *pbpl, int iBreak)
{
	KIRQL irqlSav;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(pbpl->rgbFlags[iBreak] & DMBP_ENABLED &&
			!(MmDbgReadCheck(pbpl->rgpbBreaks[iBreak]) ||
			*pbpl->rgpbBreaks[iBreak] != 0xcc))
		pbpl->rgbFlags[iBreak] &= ~DMBP_ENABLED;
	KeLowerIrql(irqlSav);
}

BOOL FFindBreak(BYTE *pbAddr, BPL **ppbplRet, int *piBreak, BOOL fAllocNew)
{
	BPL **ppbpl;
	BPL *pbpl;
	int iMic, iMac, i;
	BOOL fRet = TRUE;
	KIRQL irqlSav;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(!pbplRoot) {
		*ppbplRet = NULL;
		if(!fAllocNew)
			goto retfalse;
		pbplRoot = pbplScratch;
		pbplScratch = NULL;
		if(!pbplRoot)
			goto retfalse;
		RtlZeroMemory(pbplRoot, sizeof(BPL));
	}

	/* Find which BPL this goes in */
	for(ppbpl = &pbplRoot; pbpl = *ppbpl, pbpl->pbplNext;) {
		ppbpl = &pbpl->pbplNext;
		if(pbAddr >= pbpl->rgpbBreaks[0] && pbAddr < (*ppbpl)->rgpbBreaks[0])
			break;
	}

	*ppbplRet = pbpl;

	/* See if we can find the breakpoint */
again:
	iMic = 0;
	iMac = pbpl->cBreaks;
	while(iMic < iMac) {
		i = (iMic + iMac) / 2;
		if(pbAddr < pbpl->rgpbBreaks[i])
			iMac = i;
		else if(pbAddr > pbpl->rgpbBreaks[i])
			iMic = i + 1;
		else {
			*piBreak = i;
			break;
		}
	}
	if(iMic == iMac) {
		/* No such breakpoint, but if we've been requested to allocate space
		 * we need to ensure there is space */
		if(pbpl->cBreaks == MAX_BPL_BREAKS && fAllocNew) {
			BPL *pbplNew = pbplScratch;
			pbplScratch = NULL;
			if(!pbplNew) {
				*ppbplRet = NULL;
				goto retfalse;
			}
			pbplNew->cBreaks = pbpl->cBreaks / 2;
			pbpl->cBreaks -= pbplNew->cBreaks;
			memcpy(pbplNew->rgpbBreaks, &pbpl->rgpbBreaks[pbpl->cBreaks],
				pbplNew->cBreaks * sizeof (BYTE *));
			memcpy(pbplNew->rgbInstrs, &pbpl->rgbInstrs[pbpl->cBreaks],
				pbplNew->cBreaks);
			memcpy(pbplNew->rgbFlags, &pbpl->rgbFlags[pbpl->cBreaks],
				pbplNew->cBreaks);
			pbplNew->pbplNext = pbpl->pbplNext;
			pbpl->pbplNext = pbplNew;
			if(pbAddr >= pbplNew->rgpbBreaks[0])
				pbpl = pbplNew;
			goto again;
		}
		*piBreak = iMic;
retfalse:
		fRet = FALSE;
	}
	KeLowerIrql(irqlSav);
	return fRet;
}

BOOL FIsBreakpoint(BYTE *pbAddr)
{
	BPL *pbpl;
	int iBreak;

	return(FFindBreak(pbAddr, &pbpl, &iBreak, FALSE));
}

BOOL FGetNextBreakpoint(BYTE **ppb)
{
	BPL *pbpl;
	int iBreak;
	BYTE *pb = *ppb + 1;
	KIRQL irqlSav;
	BOOL fRet;

	/* Find where this breakpoint would go and return whatever is there */
	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	FFindBreak(pb, &pbpl, &iBreak, FALSE);
	if(pbpl && iBreak == pbpl->cBreaks) {
		pbpl = pbpl->pbplNext;
		iBreak = 0;
	}
	if(pbpl) {
		*ppb = pbpl->rgpbBreaks[iBreak];
		fRet = TRUE;
	} else
		fRet = FALSE;
	KeLowerIrql(irqlSav);
	return fRet;
}

void EnableBreakpointsInRange(PBYTE pbMin, PBYTE pbMax, BOOL fForce)
{
    KIRQL irqlSav;
    BPL *pbpl;
    int iBreak;
    DWORD dwMask = fForce ? ~DMBP_ENABLED : -1;

    /* If fForce is set, we'll assume that any breakpoints that were previously
     * set in this range have been overwritten by something else, and that
     * we should consider them already disabled */

    KeRaiseIrql(HIGH_LEVEL, &irqlSav);
    /* Find the first breakpoint in our range */
    FFindBreak(pbMin, &pbpl, &iBreak, FALSE);
    while(pbpl && iBreak == pbpl->cBreaks) {
        pbpl = pbpl->pbplNext;
        iBreak = 0;
    }
    while(pbpl && pbpl->rgpbBreaks[iBreak] < pbMax) {
        pbpl->rgbFlags[iBreak] &= dwMask;
        DoEnableBreak(pbpl, iBreak++);
        while(pbpl && iBreak == pbpl->cBreaks) {
            pbpl = pbpl->pbplNext;
            iBreak = 0;
        }
    }
    KeLowerIrql(irqlSav);
}

void DisableBreakpointsInRange(PBYTE pbMin, PBYTE pbMax)
{
    KIRQL irqlSav;
    BPL *pbpl;
    int iBreak;

    KeRaiseIrql(HIGH_LEVEL, &irqlSav);
    /* Find the first breakpoint in our range */
    FFindBreak(pbMin, &pbpl, &iBreak, FALSE);
    while(pbpl && iBreak == pbpl->cBreaks) {
        pbpl = pbpl->pbplNext;
        iBreak = 0;
    }
    while(pbpl && pbpl->rgpbBreaks[iBreak] < pbMax) {
        DoDisableBreak(pbpl, iBreak++);
        while(pbpl && iBreak == pbpl->cBreaks) {
            pbpl = pbpl->pbplNext;
            iBreak = 0;
        }
    }
    KeLowerIrql(irqlSav);
}

BOOL FGetMemory(BYTE *pbAddr, BYTE *pbValue)
{
	BOOL fRet = TRUE;
	BOOL fBP;
	BPL *pbpl;
	int iBreak;
	KIRQL irqlSav;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	fBP = FFindBreak(pbAddr, &pbpl, &iBreak, FALSE) &&
		(pbpl->rgbFlags[iBreak] & DMBP_ENABLED);
	if(fBP)
		*pbValue = pbpl->rgbInstrs[iBreak];
	else if(MmDbgReadCheck(pbAddr))
		*pbValue = *pbAddr;
	else
		fRet = FALSE;
	KeLowerIrql(irqlSav);
	return fRet;
}

BOOL FSetMemory(BYTE *pbAddr, BYTE bValue)
{
	BOOL fRet = TRUE;
	BOOL fBP;
	BPL *pbpl;
	int iBreak;
	KIRQL irqlSav;
	HARDWARE_PTE pte;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	fBP = FFindBreak(pbAddr, &pbpl, &iBreak, FALSE) &&
		(pbpl->rgbFlags[iBreak] & DMBP_ENABLED);
	if(fBP)
		pbpl->rgbInstrs[iBreak] = bValue;
	else if(MmDbgWriteCheck(pbAddr, &pte)) {
		*pbAddr = bValue;
		MmDbgReleaseAddress(pbAddr, &pte);
	} else
		fRet = FALSE;
	KeLowerIrql(irqlSav);
	return fRet;
}

BOOL FAddBreakpoint(BYTE *pbAddr)
{
	BPL *pbpl;
	int iBreak;
	int iT;
	BOOL fRet = FALSE;
	KIRQL irqlSav;

	/* If we need a new BPL during the course of execution, we won't be able
	 * to allocate one since we're at a high irql.  Allocate it early so we
	 * have it when we need it */
	RtlEnterCriticalSection(&csBplScratch);
	if(!pbplScratch)
		pbplScratch = DmAllocatePool(sizeof(BPL));

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(FFindBreak(pbAddr, &pbpl, &iBreak, TRUE)) {
		DoEnableBreak(pbpl, iBreak);
		/* Already got a breakpoint there */
		goto rettrue;
	}

	if(!pbpl) {
		/* Can't add one */
		goto retfalse;
	}

	ASSERT(pbpl->cBreaks < MAX_BPL_BREAKS);

	for(iT = pbpl->cBreaks++; iT-- > iBreak; ) {
		pbpl->rgpbBreaks[iT + 1] = pbpl->rgpbBreaks[iT];
		pbpl->rgbInstrs[iT + 1] = pbpl->rgbInstrs[iT];
		pbpl->rgbFlags[iT + 1] = pbpl->rgbFlags[iT];
	}

    /* BUGBUG -- we add the breakpoint regardless of whether or not there's
     * actually any code there.  The assumption is that if the section is not
     * loaded, we'll just mark this guy disabled when the section loads and
     * then reenable the breakpoint, forcing the int 3 into memory.  The
     * problem is that we might be going through this initial enable code
     * after the section is loaded but before we got notified.  In that case,
     * we'll lose the original instruction and be stuck with an int 3.  For
     * now, I'm going to ignore that problem as it seems highly infrequent */

	pbpl->rgpbBreaks[iBreak] = pbAddr;
	pbpl->rgbFlags[iBreak] = 0;
	DoEnableBreak(pbpl, iBreak);
rettrue:
	fRet = TRUE;
retfalse:
	KeLowerIrql(irqlSav);
	RtlLeaveCriticalSection(&csBplScratch);
	return fRet;
}

HRESULT DmSetBreakpoint(PVOID pbAddr)
{
	return FAddBreakpoint(pbAddr) ? XBDM_NOERR : E_FAIL;
}

BOOL FRemoveBreakpoint(BYTE *pbAddr)
{
	KIRQL irqlSav;
	BOOL fRet;
	BPL *pbpl;
	int iBreak;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(FFindBreak(pbAddr, &pbpl, &iBreak, FALSE)) {
		DoDisableBreak(pbpl, iBreak);
		for(--pbpl->cBreaks; iBreak < pbpl->cBreaks; ++iBreak) {
			pbpl->rgpbBreaks[iBreak] = pbpl->rgpbBreaks[iBreak + 1];
			pbpl->rgbInstrs[iBreak] = pbpl->rgbInstrs[iBreak + 1];
			pbpl->rgbFlags[iBreak] = pbpl->rgbFlags[iBreak + 1];
		}
		fRet = TRUE;
	} else
		fRet = FALSE;
	KeLowerIrql(irqlSav);
	return fRet;
}

HRESULT DmRemoveBreakpoint(PVOID pbAddr)
{
    return FRemoveBreakpoint(pbAddr) ? XBDM_NOERR : E_FAIL;
}

void RemoveAllBreakpoints(void)
{
	KIRQL irqlSav;
	BPL *pbpl;
	int iBreak;

	/* Remove int 3 breakpoints */
	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	for(pbpl = pbplRoot; pbpl; pbpl = pbpl->pbplNext) {
		for(iBreak = 0; iBreak < pbpl->cBreaks; ++iBreak)
			DoDisableBreak(pbpl, iBreak);
		pbpl->cBreaks = 0;
	}
	KeLowerIrql(irqlSav);

	/* Remove hardware breakpoints */
	for(iBreak = 0; iBreak < 4; ++iBreak)
		SetDreg(iBreak, NULL, 0, 0, FALSE);
}

void DisableBreakpoint(BYTE *pbAddr)
{
	BPL *pbpl;
	int iBreak;

	if(FFindBreak(pbAddr, &pbpl, &iBreak, FALSE))
		DoDisableBreak(pbpl, iBreak);
}

void SetHwbp(int ihwbp)
{
	BYTE bLen;
	BYTE bRw;

	if(rghwbp[ihwbp].wType == DMBREAK_NONE)
		SetDreg(ihwbp, NULL, 0, 0, FALSE);
	else {
		bLen = rghwbp[ihwbp].wSize - 1;
		switch(rghwbp[ihwbp].wType) {
		case DMBREAK_READWRITE:
			bRw = 3;
			break;
		case DMBREAK_WRITE:
			bRw = 1;
			break;
		case DMBREAK_EXECUTE:
			bRw = 0;
			bLen = 0;
			break;
		}
		/* Default to one-byte if size is invalid */
		if(bLen == 2 || bLen > 3)
			bLen = 0;
		SetDreg(ihwbp, rghwbp[ihwbp].pvAddr, bRw, bLen, TRUE);
	}
}

void SyncHwbps(void)
{
	int ihwbp;

    EnterCriticalSection(&csHwBps);
	for(ihwbp = 0; ihwbp < 4; ++ihwbp)
		if(rghwbp[ihwbp].wType != DMBREAK_NONE)
			SetHwbp(ihwbp);
    LeaveCriticalSection(&csHwBps);
}

HRESULT DmSetDataBreakpoint(BYTE *pbAddr, DWORD dwType, DWORD dwSize)
{
	int ihwbp;
    HRESULT hr = XBDM_NOERR;

    /* Validate the size */
	if(dwType != DMBREAK_NONE && !(dwSize == 1 || dwSize == 2 || dwSize == 4))
		return E_INVALIDARG;

    EnterCriticalSection(&csHwBps);
	/* First see whether this address/type combo is already used */
	for(ihwbp = 0; ihwbp < 4; ++ihwbp) {
		if(rghwbp[ihwbp].pvAddr == pbAddr) {
			/* If the type is none, we're going to clear this out */
			if(dwType == DMBREAK_NONE) {
				rghwbp[ihwbp].wType = DMBREAK_NONE;
				SetHwbp(ihwbp);
            } else if(rghwbp[ihwbp].wType == dwType)
                goto done;
		}
	}

	/* If we're clearing, then we've done our job */
    if(dwType == DMBREAK_NONE)
        goto done;

	/* Now find an unused slot */
	for(ihwbp = 0; ihwbp < 4; ++ihwbp) {
		if(rghwbp[ihwbp].wType == DMBREAK_NONE) {
			rghwbp[ihwbp].pvAddr = pbAddr;
			rghwbp[ihwbp].wType = (WORD)dwType;
			rghwbp[ihwbp].wSize = (WORD)dwSize;
			SetHwbp(ihwbp);
            goto done;
		}
	}

	hr = E_OUTOFMEMORY;
done:
    LeaveCriticalSection(&csHwBps);
    return hr;
}

HRESULT DmIsBreakpoint(PVOID pvAddr, LPDWORD pdwType)
{
    /* Look for fixed BPs first */
    if(FIsBreakpoint(pvAddr))
        *pdwType = DMBREAK_FIXED;
    else {
        /* See if we can find this in the hwbp list */
        int ihwbp;

        *pdwType = DMBREAK_NONE;
        EnterCriticalSection(&csHwBps);
        for(ihwbp = 0; ihwbp < 4; ++ihwbp) {
            if(rghwbp[ihwbp].wType != DMBREAK_NONE) {
                *pdwType = rghwbp[ihwbp].wType;
                break;
            }
        }
        LeaveCriticalSection(&csHwBps);
    }

    return XBDM_NOERR;
}

BOOL FMatchDataBreak(ULONG ulDr6, PDMN_DATABREAK pdmdb)
{
	int ihwbp;

#if 0
	/* If a trace, it's not a data break */
	if(ulDr6 & 0xc000)
		return FALSE;
#endif
	/* We'll return the first data breakpoint we find */
	for(ihwbp = 0; ihwbp < 4; ++ihwbp) {
		if(ulDr6 & (1 << ihwbp) && rghwbp[ihwbp].wType != DMBREAK_NONE) {
			pdmdb->BreakType = rghwbp[ihwbp].wType;
			pdmdb->DataAddress = rghwbp[ihwbp].pvAddr;
			return TRUE;
		}
	}
	return FALSE;
}

void DoStopGo(BOOL fGo)
{
	PETHREAD pthr;
	KIRQL irql;
	PLIST_ENTRY ple;
	DMTD *pdmtd;

	irql = KeRaiseIrqlToDpcLevel();
	if((dwExecState != DMN_EXEC_START) != !fGo) {
		/* Enumerate all threads and stop or start  those which are Xapi
		 * threads and which are not already marked as stopped */
		ple = pprocSystem->ThreadListHead.Flink;
		while(ple != &pprocSystem->ThreadListHead) {
			pthr = (PETHREAD)CONTAINING_RECORD(ple, KTHREAD, ThreadListEntry);
			ple = ple->Flink;
			pdmtd = (PDMTD)pthr->DebugData;
			/* If no thread data, we ignore this thread */
			if(pdmtd) {
			/* If execution is pending, we start any thread that is stopped */
				if(dwExecState == DMN_EXEC_PENDING && (pdmtd->DebugFlags
					& DMFLAG_STOPPED) && pdmtd->DebugEvent)
				{
					KeSetEvent(pdmtd->DebugEvent, EVENT_INCREMENT, FALSE);
				} else if(pthr->Tcb.TlsData && !(pdmtd->DebugFlags &
					DMFLAG_STOPPED) && pthr != PsGetCurrentThread())
				{
					if(fGo)
						KeResumeThread(&pthr->Tcb);
					else
						KeSuspendThread(&pthr->Tcb);
				}
			}
		}
		dwExecState = fGo ? DMN_EXEC_START : DMN_EXEC_STOP;
	}
	KeLowerIrql(irql);
}

void DoContinue(PETHREAD pthr, BOOL fException)
{
	KIRQL irql;
	DMTD *pdmtd;

	irql = KeRaiseIrqlToDpcLevel();
	pdmtd = (PDMTD)pthr->DebugData;
	if(dwExecState != DMN_EXEC_PENDING && pdmtd && pdmtd->DebugFlags &
		DMFLAG_STOPPED)
	{
		/* If all threads are suspended and we're going to continue this
		 * thread, then we're going to need to suspend it as well before it's
		 * marked as running */
		if(dwExecState != DMN_EXEC_START && pthr->Tcb.TlsData)
			KeSuspendThread(&pthr->Tcb);
		if(fException)
			pdmtd->DebugFlags |= DMFLAG_EXCEPTION;
		/* This thread could stay suspended forever unless we mark it as
		 * not stopped */
		pdmtd->DebugFlags &= ~DMFLAG_STOPPED;
		KeSetEvent(pdmtd->DebugEvent, EVENT_INCREMENT, FALSE);
	}
	KeLowerIrql(irql);
}

HRESULT DmGo(void)
{
	NotifyComponents(DM_EXEC, DMN_EXEC_START);
	DoStopGo(TRUE);
	return XBDM_NOERR;
}

HRESULT DmStop(void)
{
	DoStopGo(FALSE);
	NotifyComponents(DM_EXEC, DMN_EXEC_STOP);
	return XBDM_NOERR;
}

BOOLEAN DoHalt(void)
{
	BOOLEAN fHaltNow;
	PETHREAD pthr = PsGetCurrentThread();
	BOOL fHaltAgain = FALSE;
	PLIST_ENTRY ple;
	DMTD *pdmtd = (PDMTD)pthr->DebugData;

	if(fHaltAllThreads & HF_DEFERRED) {
		/* We've come in here with deferred work to do.  We clear the
		 * deferred state and do the work */
		fHaltAllThreads &= ~HF_DEFERRED;
		fHaltAllThreads |= HF_CLEANUP;
		/* We can't tolerate coming here at the wrong irql */
		if(KeGetCurrentIrql() != PASSIVE_LEVEL)
			KeBugCheck(IRQL_NOT_LESS_OR_EQUAL);
		ProcessDfns();
	}

	fHaltNow = ((fHaltAllThreads & HF_BREAK) && pthr->Tcb.TlsData) ||
		(pdmtd && (pdmtd->DebugFlags & DMFLAG_HALTTHREAD));
	/* Only halt a thread if it's not already stopped */
	if(fHaltNow && pdmtd && (pdmtd->ExceptionContext ||
			(pdmtd->DebugFlags & DMFLAG_STOPPED)))
		fHaltNow = FALSE;
	if(!fHaltNow && !(fHaltAllThreads & HF_CLEANUP))
		return FALSE;
	fHaltAllThreads &= ~(HF_BREAK | HF_CLEANUP);
	fHaltAgain = FALSE;
	if(pdmtd)
		pdmtd->DebugFlags &= ~DMFLAG_HALTTHREAD;
	ple = pprocSystem->ThreadListHead.Flink;
	while(ple != &pprocSystem->ThreadListHead) {
		pthr = (PETHREAD)CONTAINING_RECORD(ple, KTHREAD, ThreadListEntry);
		ple = ple->Flink;
		pdmtd = (PDMTD)pthr->DebugData;
		if(pdmtd && (pdmtd->DebugFlags & DMFLAG_HALTTHREAD))
			fHaltAgain = TRUE;
	}
	KeGetCurrentPrcb()->DebugHaltThread = fHaltAgain ? DoHalt : NULL;
	return fHaltNow;
}

HRESULT DmHaltThread(DWORD tid)
{
	PETHREAD pthr;
	DMTD *pdmtd;
	BOOL fGotThread = FALSE;

	if(tid) {
		NTSTATUS st;
		st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
		if(NT_SUCCESS(st)) {
			/* We can only halt xapi threads, and we want to be able to halt
			 * any xapi thread */
			if(pthr->Tcb.TlsData) {
				fGotThread = TRUE;
				pdmtd = pthr->DebugData;
				if(pdmtd)
					pdmtd->DebugFlags |= DMFLAG_HALTTHREAD;
			}
			ObDereferenceObject(pthr);
		} else
			pthr = NULL;
	} else {
		SetupHalt(HF_BREAK);
		return XBDM_NOERR;
	}

	if(fGotThread && pdmtd) {
		KeGetCurrentPrcb()->DebugHaltThread = DoHalt;
		return XBDM_NOERR;
	}
	return fGotThread ? E_UNEXPECTED : XBDM_NOTHREAD;
}

void SetupHalt(DWORD dw)
{
	_asm {
		pushfd
		cli
		mov eax, dw
		or fHaltAllThreads, eax
		popfd
	}
	KeGetCurrentPrcb()->DebugHaltThread = DoHalt;
}

HRESULT DmContinueThread(DWORD tid, BOOL fException)
{
	NTSTATUS st;
	PETHREAD pthr;
	DMTD *pdmtd;

	if(dwExecState == DMN_EXEC_PENDING)
		return XBDM_NOTHREAD;
	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st))
		ObDereferenceObject(pthr);
	else
		return XBDM_NOTHREAD;
	pdmtd = pthr->DebugData;
	if(!pdmtd)
		return XBDM_NOTHREAD;
	if(!(pdmtd->DebugFlags & DMFLAG_STOPPED))
		return XBDM_NOTSTOPPED;
	DoContinue(pthr, fException);
	return XBDM_NOERR;
}

void PrepareToStop(void)
{
	DMTD *pdmtd = DmGetCurrentDmtd();

	/* This thread is going to stop at an exception.  We need to prepare for
	 * the stop before we can advertise it, lest somebody try to continue
	 * before we've marked the stop */
	if(!pdmtd) {
		// what now?
		ASSERT(FALSE);
		return;
	}
	if(pdmtd->DebugEvent) {
		/* Mark this thread as stopped */
		KeResetEvent(pdmtd->DebugEvent);
		pdmtd->DebugFlags |= DMFLAG_STOPPED;
		/* Stop everything */
		DmStop();
	}
}

BOOL FStopAtException(void)
{
	NTSTATUS st;
	DMTD *pdmtd = DmGetCurrentDmtd();
	BOOL fRet = TRUE;

	if(!pdmtd) {
		// what now?
		ASSERT(FALSE);
	} else if(pdmtd->DebugEvent) {
		/* Wait for the continue */
		st = KeWaitForSingleObject(pdmtd->DebugEvent, UserRequest, UserMode,
			FALSE, NULL);
		ASSERT(NT_SUCCESS(st));
		fRet = pdmtd->DebugFlags & DMFLAG_EXCEPTION;
		pdmtd->DebugFlags &= ~(DMFLAG_STOPPED | DMFLAG_EXCEPTION);
		/* If we're going to do a function step, we need to set everything
		 * up */
		if((pdmtd->DebugFlags & (DMFLAG_FUNCCALL | DMFLAG_INFUNCCALL)) ==
			DMFLAG_FUNCCALL)
		{
			PFCS pfcs = pdmtd->FuncCallData;
			pdmtd->DebugFlags |= DMFLAG_INFUNCCALL;
			ASSERT(pdmtd->ExceptionContext && pfcs);
			pfcs->SavedEip = pdmtd->ExceptionContext->Eip;
			pdmtd->ExceptionContext->Eip = (ULONG)SetupFuncCall;
		}
	}
	return fRet;
}

HRESULT DmSetupFunctionCall(DWORD tid)
{
	NTSTATUS st;
	PETHREAD pthr;
	DMTD *pdmtd;
	KIRQL irqlSav;
	HRESULT hr;

	irqlSav = KeRaiseIrqlToDpcLevel();
	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st)) {
		ObDereferenceObject(pthr);
		pdmtd = pthr->DebugData;
		if(!pdmtd)
			hr = XBDM_NOTHREAD;
		else if(!pdmtd->ExceptionContext || (pdmtd->DebugFlags &
				(DMFLAG_STARTTHREAD | DMFLAG_INFUNCCALL)))
			hr = XBDM_NOTSTOPPED;
		else if(pdmtd->DebugFlags & DMFLAG_FUNCCALL)
			hr = XBDM_NOERR;
		else {
			pdmtd->FuncCallData = DmAllocatePoolWithTag(sizeof(FCS), 'cfmd');
			if(pdmtd->FuncCallData) {
				PFCS pfcs = pdmtd->FuncCallData;
				pfcs->ReportedEsp = (ULONG)&pfcs->SavedEip;
				pdmtd->DebugFlags |= DMFLAG_FUNCCALL;
				hr = XBDM_NOERR;
			} else
				hr = E_OUTOFMEMORY;
		}
	} else
		hr = XBDM_NOTHREAD;
	KeLowerIrql(irqlSav);
	return hr;
}

DWORD DwPreFuncCall(PFCS *ppfcs)
{
	DMTD *pdmtd = DmGetCurrentDmtd();

	*ppfcs = pdmtd->FuncCallData;
	pdmtd->DebugFlags &= ~(DMFLAG_FUNCCALL | DMFLAG_INFUNCCALL);

	return (BYTE *)(&(*ppfcs)->SavedEip) - (BYTE *)(*ppfcs)->ReportedEsp;
}

void PostFuncCall(PFCS pfcs)
{
	DmFreePool(pfcs);
}

void ExceptionsToKd(void)
{
	PLIST_ENTRY ple;
	DMTD *pdmtd;
	PETHREAD pthr;
	KIRQL irqlSav;

	irqlSav = KeRaiseIrqlToDpcLevel();
	ple = pprocSystem->ThreadListHead.Flink;
	while(ple != &pprocSystem->ThreadListHead) {
		pthr = (PETHREAD)CONTAINING_RECORD(ple, KTHREAD, ThreadListEntry);
		ple = ple->Flink;
		pdmtd = (PDMTD)pthr->DebugData;
		if(pdmtd) {
			if(pdmtd->ExceptionContext) {
				/* Any thread stopped on an exception gets continued to kd */
				pdmtd->DebugFlags &= ~DMFLAG_STOPPED;
				pdmtd->DebugFlags |= DMFLAG_KDEXCEPT;
				if(pdmtd->DebugEvent)
					KeSetEvent(pdmtd->DebugEvent, EVENT_INCREMENT, FALSE);
			} else if(dwExecState == DMN_EXEC_STOP && pthr->Tcb.TlsData)
				/* We implicitly resume all stopped threads */
				KeResumeThread(&pthr->Tcb);
		}
	}
	dwExecState = DMN_EXEC_START;
	KeLowerIrql(irqlSav);
	/* Notify of execution change */
	NotifyComponents(DM_EXEC, dwExecState);
}

void ResumeAfterBreakpoint(PCONTEXT pcr)
{
	BPL *pbpl;
	int iBreak;

	if(FFindBreak((BYTE *)pcr->Eip, &pbpl, &iBreak, FALSE)) {
		/* This is our breakpoint, so get the instruction back in there and
		 * execute it */
		DoDisableBreak(pbpl, iBreak);
		pcr->EFlags |= 0x100; // single step
		pbplTrace = pbpl;
		iBreakTrace = iBreak;
	} else if(MmDbgReadCheck((PVOID)pcr->Eip)) {
		if(*(BYTE *)pcr->Eip == 0xcc)
			/* Not our breakpoint, so skip the int 3 */
			++pcr->Eip;
		else if(*(BYTE *)pcr->Eip == 0xcd && *(BYTE *)(pcr->Eip + 1) == 0x03)
			/* A two byte breakpoint to skip */
			pcr->Eip += 2;
	}
}

BOOL FBreakTrace(PCONTEXT pcr)
{
	if(pbplTrace) {
		pcr->EFlags &= ~0x100;
		DoEnableBreak(pbplTrace, iBreakTrace);
		pbplTrace = NULL;
		return TRUE;
	}
	return FALSE;
}

HRESULT DmGetThreadList(LPDWORD rgdwThreads, LPDWORD pcThreads)
{
	DWORD cthr;
	KIRQL irql;
	PLIST_ENTRY ple;
	PETHREAD pthr;
	PDMTD pdmtd;
	HRESULT hr = XBDM_NOERR;

    if (!pcThreads || !rgdwThreads)
        return E_INVALIDARG;

	/* We need to disable thread switches while walking the thread list */
	irql = KeRaiseIrqlToDpcLevel();
	ple = pprocSystem->ThreadListHead.Flink;
	cthr = 0;
	/* If execution is pending, we say there are no threads */
	if(dwExecState != DMN_EXEC_PENDING) {
		while(ple != &pprocSystem->ThreadListHead && cthr < *pcThreads) {
			pthr = (PETHREAD)CONTAINING_RECORD(ple, KTHREAD, ThreadListEntry);
			ple = ple->Flink;
			pdmtd = (PDMTD)pthr->DebugData;
			/* We'll only list XAPI or stopped threads for now */
			if(pthr->Tcb.TlsData || (pdmtd && (pdmtd->DebugFlags &
					DMFLAG_STOPPED)))
				rgdwThreads[cthr++] = (DWORD)pthr->UniqueThread;
		}
		if(ple != &pprocSystem->ThreadListHead)
			/* Too many threads */
			hr = XBDM_BUFFER_TOO_SMALL;
	}
	KeLowerIrql(irql);

	*pcThreads = cthr;
	return hr;
}

HRESULT DmIsThreadStopped(DWORD tid, PDM_THREADSTOP pdmts)
{
	PDMTD pdmtd;
	NTSTATUS st;
	HRESULT hr;
	PEXCEPTION_RECORD per;
	PETHREAD pthr;

    if (!pdmts)
        return E_INVALIDARG;
    
	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st)) {
		pdmtd = pthr->DebugData;
		ObDereferenceObject(pthr);
	} else
		pdmtd = NULL;
	if(pdmtd) {
		if(pdmtd->DebugFlags & DMFLAG_STOPPED) {
			per = pdmtd->ExceptionRecord;
			/* We set the reason to none unless we can find a better reason */
			pdmts->NotifiedReason = DM_NONE;
			if(per) {
				switch(per->ExceptionCode) {
				case STATUS_BREAKPOINT:
					switch(per->ExceptionInformation[0]) {
					case BREAKPOINT_BREAK:
						pdmts->NotifiedReason = DM_BREAK;
						pdmts->u.Break.Address =
							(PVOID)pdmtd->ExceptionContext->Eip;
						pdmts->u.Break.ThreadId = tid;
						break;
					case BREAKPOINT_RTLASSERT:
						pdmts->NotifiedReason = DM_ASSERT;
						goto Debugstr;
					case BREAKPOINT_RIP:
						pdmts->NotifiedReason = DM_RIP;
						goto Debugstr;
					case BREAKPOINT_PRINT:
						pdmts->NotifiedReason = DM_DEBUGSTR;
Debugstr:
						pdmts->u.DebugStr.ThreadId = tid;
						pdmts->u.DebugStr.String = NULL;
						pdmts->u.DebugStr.Length = 0;
						break;
					}
					break;
				case STATUS_SINGLE_STEP:
					/* If a data breakpoint gets cleared after we take the
					 * breakpoint, we'll probably be wrong here, but that's
					 * OK */
					if(FMatchDataBreak(pdmtd->ExceptionDr6,
							&pdmts->u.DataBreak))
						pdmts->NotifiedReason = DM_DATABREAK;
					else
						pdmts->NotifiedReason = DM_SINGLESTEP;
					pdmts->u.Break.Address =
						(PVOID)pdmtd->ExceptionContext->Eip;
					pdmts->u.Break.ThreadId = tid;
					break;
				default:
					pdmts->NotifiedReason = DM_EXCEPTION;
					pdmts->u.Exception.ThreadId = tid;
					pdmts->u.Exception.Code = per->ExceptionCode;
					pdmts->u.Exception.Address = per->ExceptionAddress;
					pdmts->u.Exception.Flags = 0;
					if(per->ExceptionFlags & EXCEPTION_NONCONTINUABLE)
						pdmts->u.Exception.Flags |= DM_EXCEPT_NONCONTINUABLE;
					if(pdmtd->DebugFlags & DMFLAG_FCE)
						pdmts->u.Exception.Flags |= DM_EXCEPT_FIRSTCHANCE;
					if(per->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
						pdmts->u.Exception.Information[0] = 
							per->ExceptionInformation[0];
						pdmts->u.Exception.Information[1] = 
							per->ExceptionInformation[1];
					}
					break;
				}
			}
			hr = XBDM_NOERR;
		} else
			hr = XBDM_NOTSTOPPED;
	} else
		hr = XBDM_NOTHREAD;
	return hr;
}

#define GR(reg) (pcrRet->reg = pcr->reg)

HRESULT DmGetThreadContext(DWORD tid, PCONTEXT pcrRet)
{
	PETHREAD pthr;
	PDMTD pdmtd;
	PCONTEXT pcr;
	NTSTATUS st;
	HRESULT hr;
	KIRQL irql;
	
    if (!pcrRet)
        return E_INVALIDARG;

	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st)) {
		pdmtd = pthr->DebugData;
		ObDereferenceObject(pthr);
	} else
		pdmtd = NULL;
	irql = KeRaiseIrqlToDpcLevel();
	if(pdmtd) {
		DWORD dwFlags = pcrRet->ContextFlags;
		pcrRet->ContextFlags = 0;
		pcr = pdmtd->ExceptionContext;
		if(pcr) {
			if((dwFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
				pcrRet->ContextFlags |= CONTEXT_CONTROL;
				if(pdmtd->DebugFlags & DMFLAG_FUNCCALL)
					pcrRet->Esp = ((PFCS)pdmtd->FuncCallData)->ReportedEsp;
				else
					GR(Esp);
				GR(Ebp);
				GR(Eip);
				GR(EFlags);
				GR(SegCs);
				GR(SegSs);
			}
			if((dwFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {
				pcrRet->ContextFlags |= CONTEXT_INTEGER;
				GR(Eax);
				GR(Ebx);
				GR(Ecx);
				GR(Edx);
				GR(Edi);
				GR(Esi);
			}
			if((dwFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT ||
				(dwFlags & CONTEXT_EXTENDED_REGISTERS) ==
				CONTEXT_EXTENDED_REGISTERS)
			{
				pcrRet->ContextFlags |= CONTEXT_FLOATING_POINT |
					CONTEXT_EXTENDED_REGISTERS;
				memcpy(&pcrRet->FloatSave, &pcr->FloatSave,
					sizeof pcr->FloatSave);
			}
		} else if((dwFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
			PKSWITCHFRAME pksf;
			USHORT ulCs = 0;
			USHORT ulSs = 0;
			pksf = (PKSWITCHFRAME)pthr->Tcb.KernelStack;
			pcrRet->Esp = (DWORD)(pksf + 1);
			pcrRet->Ebp = *(DWORD *)pcrRet->Esp;
			pcrRet->Eip = pksf->RetAddr;
			pcrRet->EFlags = pksf->Eflags;
			_asm {
				mov ulCs, cs
				mov ulSs, ss
			}
			pcrRet->SegCs = ulCs;
			pcrRet->SegSs = ulSs;
			pcrRet->ContextFlags = CONTEXT_CONTROL;
		} else
			pcrRet->ContextFlags = 0;
		hr = XBDM_NOERR;
	} else
		hr = XBDM_NOTHREAD;
	KeLowerIrql(irql);
	return hr;
}

#define SR(reg) (pcr->reg = pcrIn->reg)

HRESULT DmSetThreadContext(DWORD tid, PCONTEXT pcrIn)
{
	PETHREAD pthr;
	PDMTD pdmtd;
	PCONTEXT pcr;
	NTSTATUS st;
	HRESULT hr;
	KIRQL irql;
	
    if (!pcrIn)
        return E_INVALIDARG;

	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st)) {
		pdmtd = pthr->DebugData;
		ObDereferenceObject(pthr);
	} else
		pdmtd = NULL;
	irql = KeRaiseIrqlToDpcLevel();
	if(!pdmtd)
		hr = XBDM_NOTHREAD;
	else if(!(pcr = pdmtd->ExceptionContext))
		hr = XBDM_NOTSTOPPED;
	else {
		if((pcrIn->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
			DWORD dwEflagChange = 0x100;

			if(pdmtd->DebugFlags & DMFLAG_FUNCCALL)
				((PFCS)pdmtd->FuncCallData)->ReportedEsp = pcrIn->Esp;
			else
				SR(Esp);
			SR(Ebp);
			SR(Eip);
			/* We only allow certain eflags bits to change */
			pcr->EFlags = pcr->EFlags ^ ((pcr->EFlags ^ pcrIn->EFlags) &
				dwEflagChange);
		}
		if((pcrIn->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {
			SR(Eax);
			SR(Ebx);
			SR(Ecx);
			SR(Edx);
			SR(Edi);
			SR(Esi);
		}
		if((pcrIn->ContextFlags & CONTEXT_FLOATING_POINT) ==
				CONTEXT_FLOATING_POINT ||
				(pcrIn->ContextFlags & CONTEXT_EXTENDED_REGISTERS) ==
				CONTEXT_EXTENDED_REGISTERS)
			// BUG -- sanitize cr0 and other regs
			memcpy(&pcr->FloatSave, &pcrIn->FloatSave, sizeof pcr->FloatSave);

		hr = XBDM_NOERR;
	}
	KeLowerIrql(irql);
	return hr;
}

HRESULT DmGetThreadInfo(DWORD tid, PDM_THREADINFO pdmti)
{
	PETHREAD pthr;
	NTSTATUS st;
	HRESULT hr;
	DMTD *pdmtd;

    if (!pdmti)
        return E_INVALIDARG;

	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st)) {
		pdmtd = (PDMTD)pthr->DebugData;
		pdmti->SuspendCount = pthr->Tcb.SuspendCount;
		if(dwExecState == DMN_EXEC_STOP && pthr->Tcb.TlsData && pdmtd &&
				!(pdmtd->DebugFlags & DMFLAG_STOPPED))
			/* The suspend count is artifically raised due to suspended
			 * execution */
			--pdmti->SuspendCount;
		pdmti->Priority = pthr->Tcb.Priority;
        pdmti->TlsBase = (PBYTE)pthr->Tcb.TlsData;
		ObDereferenceObject(pthr);
		hr = XBDM_NOERR;
	} else
		hr = XBDM_NOTHREAD;
	return hr;
}

HRESULT DmSetInitialBreakpoint(void)
{
	/* This is our startup breakpoint */
	if(dwExecState == DMN_EXEC_PENDING) {
		g_dmi.Flags |= DMIFLAG_BREAK;
		return XBDM_NOERR;
	}
	return E_FAIL;
}

HRESULT DmStopOn(DWORD dwFlags, BOOL fStop)
{
	{ _asm cli }
	if(fStop)
		g_grbitStopOn |= dwFlags;
	else
		g_grbitStopOn &= ~dwFlags;
	{ _asm sti }
	return XBDM_NOERR;
}

HRESULT DmReboot(DWORD dwFlags)
{
    if(!fBootWait) {
        if(dwFlags & DMBOOT_STOP)
            fBootWait = 3;
	    else if(dwFlags & DMBOOT_WAIT)
		    fBootWait = 1;
    }
    PrepareToReboot();

    if((dwFlags & DMBOOT_NODEBUG) && g_dmi.DisallowXbdm)
        *g_dmi.DisallowXbdm = TRUE;
	HalReturnToFirmware(dwFlags & DMBOOT_WARM ? HalQuickRebootRoutine :
		HalRebootRoutine);
	return XBDM_NOERR;
}

HRESULT DmSuspendThread(DWORD tid)
{
	PETHREAD pthr;
	NTSTATUS st;

	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(!NT_SUCCESS(st))
		return XBDM_NOTHREAD;
	KeSuspendThread(&pthr->Tcb);
	ObDereferenceObject(pthr);
	return XBDM_NOERR;
}

HRESULT DmResumeThread(DWORD tid)
{
	PETHREAD pthr;
	NTSTATUS st;

	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(!NT_SUCCESS(st))
		return XBDM_NOTHREAD;
	KeResumeThread(&pthr->Tcb);
	ObDereferenceObject(pthr);
	return XBDM_NOERR;
}

HRESULT DmGetXtlData(PDM_XTLDATA pdmxd)
{
    if(!g_dmxapi.XapiStarted)
        return XBDM_NOTHREAD;
    memset(pdmxd, 0, sizeof *pdmxd);
    pdmxd->LastErrorOffset = g_dmxapi.LastErrorTlsOff;
    return XBDM_NOERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmcap.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    dmcap.c

Abstract:

    This module implements routines to collect call-attributed profile (CAP)
    data for Xbox titles.

--*/

#include "dmp.h"

//
// Default profiling data buffer size is 32MB
//

#define XPROF_DEFAULT_BUFSIZE 32

#define XProfpCalcBufferSize(param) \
    ((((param) & 0xffff) ? ((param) & 0xffff) : \
        XPROF_DEFAULT_BUFSIZE) * 1024*1024)

//
// Acquire and release global access lock
//

#define XProfpLock() InterlockedCompareExchange(&DmProfileData->lock, 1, 0)
#define XProfpUnlock() (DmProfileData->lock = 0)

//
// Disable/enable interrupts
//

#define XProfpDisableInterrupts() KfRaiseIrql(HIGH_LEVEL)
#define XProfpRestoreInterrupts(irql) KfLowerIrql(irql)

BOOL DmProfileEnable;
XProfpGlobals *DmProfileData;
PSWAP_CONTEXT_NOTIFY_ROUTINE DmProfileSavedCtxSwapNotify;

__declspec(naked)
VOID
__stdcall
_CAP_Start_Profiling(
    VOID* caller,
    VOID* callee
    )
{
    /*
        ULONG* buf;

    loop:
        buf = DmProfileData->bufnext
        if buf >= DmProfileData->bufend, return
        Atomical incremnt DmProfileData->bufnext by 4 ULONGs
        if failed, goto loop

        buf[0] = timestamp-high
        buf[1] = timestamp-low
        buf[2] = caller
        buf[3] = callee

     */

    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+16]       ; DmProfileData->bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     eax, [esp+20]       ; callee
        mov     [ecx+12], eax

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret     8
    }
}

__declspec(naked)
VOID
__stdcall
_CAP_End_Profiling(
    VOID* caller
    )
{
    // Same logic as above, except the record is smaller by 1 ULONG

    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+12]       ; DmProfileData->bufnext += 3
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        bts     edx, 29             ; timestamp-high | XPROFREC_FASTCAP_END
        mov     [ecx], edx
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller
        mov     [ecx+8], eax

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret     4
    }
}

__declspec(naked)
VOID
__stdcall
_CAP_Enter_Function(
    VOID* caller
    )
{
    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+12]       ; DmProfileData->bufnext += 3
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        bts     edx, 31             ; timestamp-high | XPROFREC_CALLCAP_START
        mov     [ecx], edx
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller
        mov     [ecx+8], eax

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret     4
    }
}

__declspec(naked)
VOID
__stdcall
_CAP_Exit_Function(
    VOID* caller
    )
{
    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+12]       ; DmProfileData->bufnext += 3
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        or      edx, XPROFREC_CALLCAP_END   ; timestamp-high | XPROFREC_CALLCAP_END
        mov     [ecx], edx
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller
        mov     [ecx+8], eax

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret     4
    }
}

__declspec(naked)
VOID
__cdecl
_penter(
    VOID
    )
{
    /*
        ULONG* buf;

    loop:
        buf = DmProfileData->bufnext
        if buf >= DmProfileData->bufend, return
        Atomical incremnt DmProfileData->bufnext by 4 ULONGs
        if failed, goto loop

        buf[0] = timestamp-high
        buf[1] = timestamp-low
        buf[2] = caller
        buf[3] = ESP

     */

    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+16]       ; DmProfileData->bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        bts     edx, 30             ; timestamp-high | XPROFREC_PENTER
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+12]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     [ecx+12], esp       ; ESP

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret
    }
}

__declspec(naked)
VOID
__cdecl
_pexit(
    VOID
    )
{
    /*
        ULONG* buf;

    loop:
        buf = DmProfileData->bufnext
        if buf >= DmProfileData->bufend, return
        Atomical incremnt DmProfileData->bufnext by 4 ULONGs
        if failed, goto loop

        buf[0] = timestamp-high
        buf[1] = timestamp-low
        buf[2] = caller
        buf[3] = ESP

     */

    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+16]       ; DmProfileData->bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        or      edx, XPROFREC_PEXIT ; timestamp-high | XPROFREC_PEXIT
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+12]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     [ecx+12], esp       ; ESP

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret
    }
}

__declspec(naked)
VOID
__stdcall
DmProfileEmitControlRecord(
    ULONG type,
    ULONG param
    )
{
    // Identical to _CAP_Start_Profiling except
    // the record is marked as XPROFREC_CONTROL.

    __asm {
        push    eax
        push    ecx
        push    edx
        mov     ecx, DmProfileData
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+16]       ; DmProfileData->bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        or      edx, XPROFREC_CONTROL
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     eax, [esp+20]       ; callee
        mov     [ecx+12], eax

ret1:
        pop     edx
        pop     ecx
        pop     eax
        ret     8
    }
}

VOID
FASTCALL
DmProfileThreadSwitchNotifyCallback(
    HANDLE OldThreadId,
    HANDLE NewThreadId
    )
{
    DmProfileEmitControlRecord(XPROF_THREAD_SWITCH, (ULONG) NewThreadId);

    // Call the original notification function
    if (DmProfileSavedCtxSwapNotify) {
        (*DmProfileSavedCtxSwapNotify)(OldThreadId, NewThreadId);
    }
}

VOID
FASTCALL
DmProfileDpcDispatchNotifyCallback(
    VOID* dpcproc,
    ULONG param
    )
{
    DmProfileEmitControlRecord(XPROF_DPC_BEGIN+param, (ULONG)dpcproc);
}

NTSTATUS
DmCapControl(
    ULONG Action,
    ULONG Param
    )
{
    KIRQL irql;
    ULONG tid;
    NTSTATUS status = STATUS_SUCCESS;

    switch (Action) {
    case XPROF_START:
    case XPROF_STOP:
        if (XProfpLock() != 0) {
            // Simple-minded locking mechanism: prevent multiple threads
            // from calling start/stop/resume at the same time
            status = STATUS_DEVICE_BUSY;
            break;
        }

        tid = (ULONG) PsGetCurrentThread()->UniqueThread;

        if (Action == XPROF_START) {
            // Start a new profiling session

            //
            // Clear the existing profiling data buffer first
            //
            ULONG oldsize = XProfpCalcBufferSize(DmProfileData->start_param);
            ULONG newsize = XProfpCalcBufferSize(Param);
            ULONG* buf = DmProfileData->bufstart;

            if (buf) {
                if (!DmProfileData->bufnext_stopped) {
                    // There is already an active profiling session.
                    XProfpUnlock();
                    return STATUS_INVALID_PARAMETER;
                }

                irql = XProfpDisableInterrupts();

                DmProfileData->bufstart =
                DmProfileData->bufend =
                DmProfileData->bufnext =
                DmProfileData->bufnext_stopped = NULL;
                DmProfileData->start_type =
                DmProfileData->start_param = 0;

                *g_dmi.CtxSwapNotifyRoutine = DmProfileSavedCtxSwapNotify = NULL;
                *g_dmi.DpcDispatchNotifyRoutine = NULL;
                XProfpRestoreInterrupts(irql);

                // If the old size and the new size are the same,
                // then we'll reuse the same buffer. Otherwise,
                // we'll free the old buffer first.
                if (oldsize != newsize) {
                    MmDbgFreeMemory(buf, oldsize);
                    buf = NULL;
                }
            }

            //
            // Allocate memory for the new profiling data buffer
            //

            if (!buf) buf = (ULONG*)MmDbgAllocateMemory(newsize, PAGE_READWRITE|PAGE_WRITECOMBINE);
            if (buf == NULL) {
                status = STATUS_NO_MEMORY;
            } else {
                irql = XProfpDisableInterrupts();

                DmProfileData->bufstart = (ULONG*)buf;
                DmProfileData->bufnext = DmProfileData->bufstart;
                DmProfileData->bufend = (ULONG*)((UCHAR*)buf + newsize - XPROFREC_MAXSIZE);
                DmProfileData->start_param = Param;
                DmProfileData->start_type = Action;

                DmProfileEmitControlRecord(XPROF_START, tid);
                DmProfileSavedCtxSwapNotify = (PSWAP_CONTEXT_NOTIFY_ROUTINE)*g_dmi.CtxSwapNotifyRoutine;
                *g_dmi.CtxSwapNotifyRoutine = (PVOID)DmProfileThreadSwitchNotifyCallback;
                if (Param & XPROF_DPC_ENABLED) {
                    *g_dmi.DpcDispatchNotifyRoutine = (PVOID)DmProfileDpcDispatchNotifyCallback;
                }
                XProfpRestoreInterrupts(irql);
            }
        } else {
            // Stop the current profiling session

            if (!DmProfileData->bufstart) {
                // No profiling session
                status = STATUS_INVALID_PARAMETER;
            } else if (DmProfileData->bufnext_stopped) {
                // Profiling session already stopped
                //  do nothing
            } else {
                irql = XProfpDisableInterrupts();
                *g_dmi.CtxSwapNotifyRoutine = (PVOID)DmProfileSavedCtxSwapNotify;
                DmProfileSavedCtxSwapNotify = NULL;
                *g_dmi.DpcDispatchNotifyRoutine = NULL;

                DmProfileEmitControlRecord(XPROF_STOP, tid);

                DmProfileData->bufnext_stopped = DmProfileData->bufnext;
                DmProfileData->bufnext = DmProfileData->bufend;

                XProfpRestoreInterrupts(irql);
            }
        }

        XProfpUnlock();
        break;

    case XPROF_COMMENT:
        DmProfileEmitControlRecord(Action, Param);
        break;

    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    return status;
}

DWORD
WINAPI
DmProfileControl(
    DWORD Action,
    DWORD Parameter
    )
{
    NTSTATUS Status = DmCapControl(Action, Parameter);
    return RtlNtStatusToDosError(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmcount.h ===
/*
 *
 * dmcount.h
 *
 * performance counters
 *
 */

typedef HRESULT (*PDM_CDPROC)(DWORD, struct _PFC *, PDM_COUNTDATA);

typedef struct _PFC {
    LIST_ENTRY leUpdate;
    DWORD dwType;
    union {
        PDM_COUNTDATA pdmcd;
        PDM_COUNTPROC pfnCount;
        PDM_CDPROC pfnCountData;
        PULONG pul;
        PLARGE_INTEGER pli;
        PVOID pv;
    };
    LARGE_INTEGER rgliValues[11];
    ULONG rgulTicks[11];
    ULONG rgulFrames[11];
    int iulCur;
} PFC, *PPFC;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmcount.c ===
/*
 *
 * dmcount.c
 *
 * performance counters
 *
 */

#include "dmp.h"
#include "d3d8.h"
#include "d3d8perf.h"

OBJECT_TYPE obtCounter = { DmAllocatePoolWithTag, DmFreePool, NULL, NULL, NULL, &kevtNull, 'cpmd' };
HANDLE hCounterDir;
KTIMER tmrRefreshCounters;
KDPC dpcRefreshCounters;
HANDLE hpobGPU;

LIST_ENTRY rgleUpdateQueues[10];
int ileCur;
enum { iulCpuUse, iulCpuDpc, iulCpuIsr, iulCpuMax };
ULONG rgulSystemTimes[iulCpuMax * 2];

enum { iulMemFree, iulMemCache, iulMemImage, iulMemPool, iulMemStack,
    iulMemVM, iulMemMax };
ULONG rgulPages[iulMemMax];
const char *rgszMemCounters[] = {
    "Free Pages",
    "Cache Pages",
    "Image Pages",
    "Pool Pages",
    "Stack Pages",
    "VM Pages"
};

struct {
    ULONG cbitShift;
    LPCSTR szName;
    ULONG ulData[2];
} rggcGPU[] = {
    { 0, "% GPU" },
    { 3, "% GPU Frontend" },
    { 27, "% GPU Backend" },
};
#define cgcGPU (sizeof rggcGPU / sizeof rggcGPU[0])

const OCHAR oszCounterDir[] = OTEXT("\\DmCounters");

static HRESULT HrGetFrameCount(PLARGE_INTEGER pli, PLARGE_INTEGER unused)
{
    if(!g_dmgd.FrameCounter)
        return XBDM_COUNTUNAVAILABLE;
    pli->HighPart = 0;
    pli->LowPart = *g_dmgd.FrameCounter;
    return XBDM_NOERR;
}

BOOL FGetCounterValue(PFC *ppfc, PLARGE_INTEGER pliCount, PLARGE_INTEGER pliRate)
{
    _asm {
        pushfd
        cli
    }
    switch(ppfc->dwType >> 16) {
    case DMCOUNT_SYNC>>16:
        if(SUCCEEDED(ppfc->pfnCount(pliCount, pliRate)))
            break;
        // fall through
    case 0:
        _asm popfd
        return FALSE;
    case DMCOUNT_ASYNC32>>16:
        pliCount->HighPart = 0;
        pliCount->LowPart = *ppfc->pul;
        if(pliRate)
            pliRate->QuadPart = ppfc->pul[1];
        break;
    case DMCOUNT_ASYNC64>>16:
        *pliCount = *ppfc->pli;
        if(pliRate)
            *pliRate = ppfc->pli[1];
        break;
    }
    _asm popfd
    return TRUE;
}

void RefreshCounter(PFC *ppfc)
{
    BOOL f;
    LARGE_INTEGER liValue;
    ULONG ulTickCur;
    ULONG ulFrameCur;
    int culFill;

    /* Get the current value of this counter */
    _asm {
        pushfd
        cli
    }
    if((ppfc->dwType & DMCOUNT_COUNTTYPE) == DMCOUNT_PRATIO) {
        LARGE_INTEGER li;
        f = FGetCounterValue(ppfc, &liValue, &li);
        if(f) {
            if(li.HighPart)
                f = FALSE;
            else
                ulTickCur = li.LowPart;
        }
    } else {
        f = FGetCounterValue(ppfc, &liValue, NULL);
        ulTickCur = KeQueryTickCount();
    }
    ulFrameCur = g_dmgd.FrameCounter ? *g_dmgd.FrameCounter : 0;
    _asm popfd
    if(!f) {
        /* The value is unavailable, so we reset the counter */
        ppfc->iulCur = -1;
        return;
    }

    /* Record the data */
    if(ppfc->iulCur < 0) {
        /* This is the first time we've gotten this value, so we need to
         * populate it into all of the sample slots */
        culFill = 11;
        ppfc->iulCur = 0;
    } else
        culFill = ppfc->dwType & DMCOUNT_FREQUENCY;

    /* Record the samples into the counter, into the current slot and into the
     * number of slots that will pass by prior to the next sample */
    while(culFill--) {
        if(++ppfc->iulCur == 11)
            ppfc->iulCur = 0;
        ppfc->rgliValues[ppfc->iulCur] = liValue;
        ppfc->rgulTicks[ppfc->iulCur] = ulTickCur;
        ppfc->rgulFrames[ppfc->iulCur] = ulFrameCur;
    }
}

void CounterDpc(PKDPC pdpc, PVOID pv1, PVOID pv2, PVOID pv3)
{
    PFC *ppfc;
    PFC *ppfcNext;
    int ile;
    PKPRCB pprcb = KeGetCurrentPrcb();
    struct {
        ULONG tickIdle;
        ULONG tickDpc;
        ULONG tickIsr;
        ULONG tickTotal;
    } tmsSystem;
    MM_STATISTICS mmst;

    /* First, update the system times */
    _asm {
        pushfd
        cli
    }
    tmsSystem.tickIdle = pprcb->IdleThread->KernelTime;
    //tmsSystem.tickIsr = pprcb->InterruptTime;
    tmsSystem.tickDpc = pprcb->DpcTime;
    tmsSystem.tickTotal = KeQueryTickCount();
    _asm popfd
    rgulSystemTimes[iulCpuUse*2] = tmsSystem.tickTotal - tmsSystem.tickIdle;
    rgulSystemTimes[iulCpuUse*2+1] = tmsSystem.tickTotal;
    rgulSystemTimes[iulCpuDpc*2] = tmsSystem.tickDpc;
    rgulSystemTimes[iulCpuDpc*2+1] = tmsSystem.tickTotal;
    rgulSystemTimes[iulCpuIsr*2] = tmsSystem.tickIsr;
    rgulSystemTimes[iulCpuIsr*2+1] = tmsSystem.tickTotal;

    /* Update memory usage */
    // TODO -- point counters directly at kernel's statistics
    mmst.Length = sizeof mmst;
    MmQueryStatistics(&mmst);
    rgulPages[iulMemFree] = mmst.AvailablePages;
    rgulPages[iulMemCache] = mmst.CachePagesCommitted;
    rgulPages[iulMemImage] = mmst.ImagePagesCommitted;
    rgulPages[iulMemPool] = mmst.PoolPagesCommitted;
    rgulPages[iulMemStack] = mmst.StackPagesCommitted;
    rgulPages[iulMemVM] = mmst.VirtualMemoryBytesCommitted >> PAGE_SHIFT;

    /* Walk the list of counters to be refreshed during this cycle and update
     * them, requeueing as appropriate */
    ppfc = (PFC *)rgleUpdateQueues[ileCur].Flink;
    ASSERT((PVOID)ppfc == (PVOID)&ppfc->leUpdate);
    if(ppfc == (PFC *)&rgleUpdateQueues[ileCur])
        ppfc = NULL;
    else {
        rgleUpdateQueues[ileCur].Blink->Flink = NULL;
        InitializeListHead(&rgleUpdateQueues[ileCur]);
    }

    while(ppfc) {
        ppfcNext = (PFC *)ppfc->leUpdate.Flink;
        if(ppfc->dwType & DMCOUNT_SYNCCD)
            ppfc->pfnCountData(0, ppfc, NULL);
        else
            RefreshCounter(ppfc);
        ile = ileCur + (ppfc->dwType & DMCOUNT_FREQUENCY);
        if(ile >= 10)
            ile -= 10;
        InsertTailList(&rgleUpdateQueues[ile], &ppfc->leUpdate);
        ppfc = ppfcNext;
    }

    if(++ileCur == 10)
        ileCur = 0;
}

void InitCounters(void)
{
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING ost;
    NTSTATUS st;
    LARGE_INTEGER li;

    /* Initialize the refresh queues */
    for(ileCur = 0; ileCur < 10; ++ileCur)
        InitializeListHead(&rgleUpdateQueues[ileCur]);
    ileCur = 0;

    /* Initialize the refresh timer */
    KeInitializeDpc(&dpcRefreshCounters, CounterDpc, NULL);
    KeInitializeTimer(&tmrRefreshCounters);

    /* Start it ticking right away */
    li.HighPart = li.LowPart = -1;
    KeSetTimerEx(&tmrRefreshCounters, li, 100, &dpcRefreshCounters);

    /* Create the performance counter object directory */
    RtlInitObjectString(&ost, oszCounterDir);
    InitializeObjectAttributes(&oa, &ost, OBJ_PERMANENT, NULL, NULL);
    st = NtCreateDirectoryObject(&hCounterDir, &oa);
    if(!NT_SUCCESS(st)) {
        DbgPrint("Failed to create counter object directory!\n");
        hCounterDir = NULL;
    } else {
        int i;

        /* Register the frame counter */
        DmRegisterPerformanceCounter("Frames", DMCOUNT_FREQ100MS |
            DMCOUNT_EVENT | DMCOUNT_SYNC, HrGetFrameCount);

        /* Register the CPU counters */
        DmRegisterPerformanceCounter("% CPU:total", DMCOUNT_FREQ100MS |
            DMCOUNT_PRATIO | DMCOUNT_ASYNC32, &rgulSystemTimes[iulCpuUse*2]);
        DmRegisterPerformanceCounter("% CPU:DPC", DMCOUNT_FREQ100MS |
            DMCOUNT_PRATIO | DMCOUNT_ASYNC32, &rgulSystemTimes[iulCpuDpc*2]);
        DmRegisterPerformanceCounter("% CPU:Interrupts", DMCOUNT_FREQ100MS |
            DMCOUNT_PRATIO | DMCOUNT_ASYNC32, &rgulSystemTimes[iulCpuIsr*2]);

        /* Register the memory counters */
        for(i = 0; i < iulMemMax; ++i)
            DmRegisterPerformanceCounter(rgszMemCounters[i],
                DMCOUNT_FREQ100MS | DMCOUNT_VALUE | DMCOUNT_ASYNC32,
                &rgulPages[i]);

        /* Register the GPU counters */
        for(i = 0; i < cgcGPU; ++i)
            DmRegisterPerformanceCounter(rggcGPU[i].szName,
                DMCOUNT_FREQ100MS | DMCOUNT_PRATIO | DMCOUNT_ASYNC32,
                rggcGPU[i].ulData);
    }
}

HRESULT DmRegisterPerformanceCounter(LPCSTR szName, DWORD dwType, PVOID pv)
{
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING ost;
    NTSTATUS st;
    PFC *ppfc;
    HANDLE h;
    int ile;
    DWORD grbit;

    if(!hCounterDir)
        return E_OUTOFMEMORY;

    if (!szName)
        return E_INVALIDARG;

    ile = dwType & DMCOUNT_FREQUENCY;
    /* Do some sanity checking on the counter type */
    if(ile > DMCOUNT_FREQ1SEC)
        return XBDM_BADCOUNTTYPE;
    
    RtlInitObjectString(&ost, szName);
    InitializeObjectAttributes(&oa, &ost, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        hCounterDir, NULL);

    st = ObCreateObject(&obtCounter, &oa, sizeof(PFC), (PVOID *)&ppfc);
    if(NT_SUCCESS(st)) {
        RtlZeroMemory(ppfc, sizeof(PFC));
        st = ObInsertObject(ppfc, &oa, 0, &h);
    }
    if(NT_SUCCESS(st)) {
        ppfc->dwType = dwType;
        ppfc->pv = pv;
        ppfc->iulCur = -1;
        /* If this counter has a periodic update, we need to queue it */
        if(ile) {
            _asm {
                pushfd
                cli
            }
            ile += ileCur;
            if(ile >= 10)
                ile -= 10;
            InsertTailList(&rgleUpdateQueues[ile], &ppfc->leUpdate);
            _asm popfd
        }
        NtClose(h);
    }
    
    return NT_SUCCESS(st) ? XBDM_NOERR : HrFromStatus(st, E_FAIL);
}

HRESULT DmUnregisterPerformanceCounter(LPCSTR szName){
    HRESULT hr;
    HANDLE h;

    hr = DmOpenPerformanceCounter(szName, &h);
    if(SUCCEEDED(hr)){
        PFC *ppfc;
        NTSTATUS st = ObReferenceObjectByHandle(h, NULL, &ppfc);
        hr = NT_SUCCESS(st) ? XBDM_NOERR : HrFromStatus(st, E_FAIL);

        if(SUCCEEDED(hr)){
            int ile = ppfc->dwType & DMCOUNT_FREQUENCY;
            /* If this counter has a periodic update, we need to dequeue it */
            if(ile) {
                _asm {
                    pushfd
                    cli
                }
                RemoveEntryList(&ppfc->leUpdate);
                _asm popfd
            }
            //Mark as temporary
            ObMakeTemporaryObject(ppfc);
            // Trash type, so nobody tries to use it
            _asm {
                pushfd
                cli
            }
            ppfc->dwType = 0;
            _asm popfd
            ObDereferenceObject(ppfc); // Release reference acquired in ObReferenceObjectByHandle
        }
        NtClose(h);
    }
    return hr;
}

HRESULT DmOpenPerformanceCounter(LPCSTR szName, PHANDLE ph)
{
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING ost;
    NTSTATUS st;

    if(!hCounterDir || !szName)
        return XBDM_NOSUCHFILE;

    RtlInitObjectString(&ost, szName);
    InitializeObjectAttributes(&oa, &ost, OBJ_CASE_INSENSITIVE, hCounterDir,
        NULL);
    st = ObOpenObjectByName(&oa, &obtCounter, NULL, ph);
    return NT_SUCCESS(st) ? XBDM_NOERR : XBDM_CANNOTACCESS;
}


HRESULT DmQueryPerformanceCounterHandle(HANDLE h, DWORD dwType, PDM_COUNTDATA pdmcd)
{
    NTSTATUS st;
    PFC *ppfc;
    HRESULT hr;
    int cul = dwType & DMCOUNT_FREQUENCY;
    int grbitType;

    if (!pdmcd)
        return E_INVALIDARG;

    st = ObReferenceObjectByHandle(h, &obtCounter, (PVOID *)&ppfc);
    if(NT_SUCCESS(st)) {
        grbitType = ppfc->dwType & DMCOUNT_COUNTTYPE;
        if(ppfc->dwType & DMCOUNT_ASYNC) {
            /* Disable interrupts so nobody updates this counter while
             * we're copying it */
            _asm {
                pushfd
                cli
            }
            memcpy(pdmcd, ppfc->pdmcd, sizeof *pdmcd);
            _asm popfd
            hr = XBDM_NOERR;
        } else if(ppfc->dwType & DMCOUNT_SYNCCD) {
            /* Call this counter's data function to fill in the actual
             * data */
            hr = ppfc->pfnCountData(dwType, ppfc, pdmcd);
        } else if(((dwType ^ ppfc->dwType) & DMCOUNT_COUNTTYPE) != 0) {
            /* Types must match */
            hr = XBDM_BADCOUNTTYPE;
        } else if((dwType & DMCOUNT_COUNTSUBTYPE) == 0 && grbitType !=
            DMCOUNT_PRATIO)
        {
            /* We want this counter's raw data, so we get it */
            if(FGetCounterValue(ppfc, &pdmcd->CountValue, grbitType ==
                DMCOUNT_PRATIO ? &pdmcd->RateValue : NULL))
            {
                hr = XBDM_NOERR;
                pdmcd->CountType = grbitType;
#if 0
                /* If the counter is a percent counter, then we need to scale
                 * it */
                if((pdmcd->CountType & (DMCOUNT_EVENT | DMCOUNT_PERCENT)) ==
                    DMCOUNT_PERCENT)
                {
                    pdmcd->RateValue.LowPart = -1;
                    pdmcd->RateValue.HighPart = 0;
                }
#endif
            } else
                hr = XBDM_COUNTUNAVAILABLE;
        } else if(grbitType != DMCOUNT_VALUE) {
            int iulBase;

            /* This is an event rate counter or a progressive ratio counter.
             * We need to calculate the event count delta and the time base
             * (time or frame) delta */
            if(cul == 0)
                cul = 10;
            _asm {
                pushfd
                cli
            }
            if(ppfc->iulCur < 0)
                hr = XBDM_COUNTUNAVAILABLE;
            else {
                iulBase = ppfc->iulCur - cul;
                if(iulBase < 0)
                    iulBase += 11;
                pdmcd->CountValue.QuadPart =
                    ppfc->rgliValues[ppfc->iulCur].QuadPart -
                    ppfc->rgliValues[iulBase].QuadPart;
                if((dwType & (DMCOUNT_PERFRAME | DMCOUNT_COUNTTYPE)) ==
                    (DMCOUNT_PERFRAME | DMCOUNT_EVENT))
                {
                    pdmcd->RateValue.QuadPart =
                        ppfc->rgulFrames[ppfc->iulCur] - 
                        ppfc->rgulFrames[iulBase];
                    pdmcd->CountType = DMCOUNT_PERFRAME | DMCOUNT_EVENT;
                } else {
                    pdmcd->RateValue.QuadPart =
                        ppfc->rgulTicks[ppfc->iulCur] - 
                        ppfc->rgulTicks[iulBase];
                    if(grbitType == DMCOUNT_EVENT && !(dwType &
                        DMCOUNT_PERTICK))
                    {
                        /* The value we've fetched isn't really the number of
                         * frames per the given number of milliseconds; it's
                         * the number of frames per the given number of ticks.
                         * We need to do the conversion.  Because of all the
                         * multiplication we have to do, we try to optimize
                         * for the case where the rate is a handy multiple
                         * of milliseconds so we can avoid letting the numbers
                         * get too big */
                        ULONG ulN, ulD;
                        ulN = 10000;
                        ulD = *KeTimeIncrement;
                        if(ulD == ulN)
                            ulN = ulD = 1;
                        if(dwType & DMCOUNT_PERSEC) {
                            if(ulN != 1 && pdmcd->RateValue.LowPart % 1000 == 0)
                                pdmcd->RateValue.LowPart /= 1000;
                            else if(ulN != 1 && pdmcd->RateValue.LowPart % 100 == 0) {
                                pdmcd->RateValue.LowPart /= 100;
                                ulN *= 10;
                            } else
                                ulN *= 1000;
                            pdmcd->CountType = grbitType | DMCOUNT_PERSEC;
                        } else
                            pdmcd->CountType = grbitType | DMCOUNT_PERMSEC;
                        pdmcd->CountValue.QuadPart *= ulN;
                        pdmcd->RateValue.QuadPart *= ulD;
                    } else if(grbitType == DMCOUNT_PRATIO)
                        pdmcd->CountType = grbitType;
                    else
                        pdmcd->CountType = DMCOUNT_EVENT | DMCOUNT_PERTICK;
                }
                pdmcd->CountType |= cul;
                hr = pdmcd->RateValue.QuadPart ? XBDM_NOERR :
                    XBDM_COUNTUNAVAILABLE;
            }
            _asm popfd
        } else {
            int iul;

            /* This is a value counter moving average */
            if(cul == 0)
                /* We need a value which will always correspond to the natural
                 * refresh frequency of this counter -- we know 1 will always
                 * work */
                cul = 1;
            pdmcd->CountValue.QuadPart = 0;
            pdmcd->RateValue.QuadPart = cul;
            _asm {
                pushfd
                cli
            }
            if(ppfc->iulCur < 0)
                hr = XBDM_COUNTUNAVAILABLE;
            else {
                for(iul = ppfc->iulCur; cul--; --iul) {
                    if(iul < 0)
                        iul += 11;
                    pdmcd->CountValue.QuadPart +=
                        ppfc->rgliValues[iul].QuadPart;
                }
                pdmcd->CountType = ppfc->dwType & 0xffff;
            }
            _asm popfd
        }
        ObDereferenceObject(ppfc);
    } else
        hr = HrFromStatus(st, E_FAIL);

    return hr;
}

HRESULT DmClosePerformanceCounter(HANDLE h)
{
    NTSTATUS st = NtClose(h);
    return NT_SUCCESS(st) ? XBDM_NOERR : HrFromStatus(st, E_FAIL);
}

HRESULT DmWalkPerformanceCounters(PDM_WALK_COUNTERS *ppdmwc, PDM_COUNTINFO pdmci)
{
    NTSTATUS st;
    DWORD cch;
    struct {
        OBJECT_DIRECTORY_INFORMATION odi;
        OCHAR sz[256];
    } odi;
    HRESULT hr;
    HANDLE h;

    if(!pdmci || !ppdmwc)
        return E_INVALIDARG;

    if(!hCounterDir)
        return XBDM_ENDOFLIST;

    st = NtQueryDirectoryObject(hCounterDir, &odi, sizeof odi, *ppdmwc == 0,
        (PULONG)ppdmwc, NULL);
    switch(st) {
    case STATUS_NO_MORE_ENTRIES:
        hr = XBDM_ENDOFLIST;
        break;
    case STATUS_BUFFER_TOO_SMALL:
        hr = XBDM_BUFFER_TOO_SMALL;
        break;
    default:
        if(NT_SUCCESS(st)) {
            memcpy(pdmci->Name, odi.odi.Name.Buffer, odi.odi.Name.Length);
            pdmci->Name[odi.odi.Name.Length] = 0;
            hr = DmOpenPerformanceCounter(pdmci->Name, &h);
            if(SUCCEEDED(hr)) {
                PFC *ppfc;

                st = ObReferenceObjectByHandle(h, &obtCounter, (PVOID *)&ppfc);
                if(NT_SUCCESS(st)) {
                    /* Only the low 16 bits are returned as supported type 
                     * info */
                    pdmci->Type = ppfc->dwType & 0xFFFF;
                    NtClose(h);
                    hr = XBDM_NOERR;
                } else
                    hr = E_UNEXPECTED;
            } else
                hr = E_UNEXPECTED;
        } else
            hr = HrFromStatus(st, E_FAIL);
        break;
    }

    return hr;
}

HRESULT DmCloseCounters(PDM_WALK_COUNTERS pdmwc)
{
    return XBDM_NOERR;
}

void GPUPerf(PDMN_PROFINT pdmpi)
{
    volatile DWORD *pdw;
    DWORD misc;
    int igc;
    D3DPERF *PerfCounters = g_dmgd.PerfCounters;
    DWORD ProfileDataIndex;
    DWORD busyflags;

    pdw = (PVOID)((ULONG_PTR)*g_dmgd.RegisterBase + 0x00400700);
    misc = *pdw;

    // The NV_PGRAPH_STATUS register tells whether part of the gpu is busy/idle.
    // From initial testing on various apps, the three parts which seem to have
    // the most relevance are STATE (entire GPU), FE_3D, and COMBINER. Hold off
    // on reporting the other data until we find out what it means and whether
    // it is useful.

    if(PerfCounters)
        ProfileDataIndex = PerfCounters->m_ProfileSamples %
            (sizeof(PerfCounters->m_ProfileData) / sizeof(PerfCounters->m_ProfileData[0]));
    busyflags = 0;

    for(igc = 0; igc < cgcGPU; ++igc)
    {
        if(misc & (1 << rggcGPU[igc].cbitShift)) {
            ++rggcGPU[igc].ulData[0];
            busyflags |= 1 << rggcGPU[igc].cbitShift;
            if(PerfCounters)
                ++PerfCounters->m_ProfileBusyCounts[igc];
        }
        ++rggcGPU[igc].ulData[1];
    }

    if(PerfCounters) {
        PerfCounters->m_ProfileData[ProfileDataIndex] = (WORD)busyflags;

        // Bump up total sample count.
        PerfCounters->m_ProfileSamples++;
    }
}

HRESULT DmEnableGPUCounter(BOOL f)
{
    KIRQL irqlSav = KeRaiseIrqlToDpcLevel();
    HRESULT hr;

    if(f && !hpobGPU) {
        hr = DmStartProfile(&hpobGPU, 1, GPUPerf);
        if(FAILED(hr))
            hpobGPU = NULL;
    } else if(!f && hpobGPU) {
        hr = DmStopProfile(hpobGPU);
        if(SUCCEEDED(hr))
            hpobGPU = NULL;
    } else
        hr = XBDM_NOERR;
    KeLowerIrql(irqlSav);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmnotify.h ===
/*
 *
 * dmnotify.h
 *
 * Random stuff for notifications
 *
 */

/* Debug exception handler parameter block */
typedef struct _EXCEPTION_TRAP {
    PKTRAP_FRAME TrapFrame;
    PKEXCEPTION_FRAME ExceptionFrame;
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
    BOOLEAN SecondChance;
} EXCEPTION_TRAP, *PEXCEPTION_TRAP;

/* Extended notification handler */
typedef struct _ENH {
	char szExtName[64];
	PDM_EXT_NOTIFY_FUNCTION pfnHandler;
} ENH;

#define MAX_ENH 16

/* Function call setup */
typedef struct _FCS {
	ULONG ReportedEsp;
	ULONG ParameterData[1022];
	ULONG SavedEip;
} FCS, *PFCS;

#define HF_BREAK 1
#define HF_DEFERRED 2
#define HF_CLEANUP 4

/* Deferred Notification */
typedef struct _DFN {
	struct _DFN *pdfnNext;
	/* For now, we just do debug prints */
	DMN_DEBUGSTR dmds;
} DFN, *PDFN;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmnotify.c ===
/*
 *
 * dmnotify.c
 *
 * Debug notifications
 *
 */

#include "dmp.h"

#define MAX_NOTIFY_SOCKETS 8

SOCKET rgsockNotify[MAX_NOTIFY_SOCKETS];
PKDEBUG_ROUTINE pfnKdpTrap;
BOOL fAllowKd = TRUE;
DWORD g_grbitStopOn;
RTL_CRITICAL_SECTION csNotify;
RTL_CRITICAL_SECTION csNotifySockList;
PETHREAD pthrUsingNotifyList;
KDPC dpcBreakIn;
KEVENT evtNotifyList;

#define MAX_NOTIFY 32
typedef struct _DMN_SESSION {
	DWORD dwSig;
	PDMN_SESSION psessNext;
	DWORD dwFlags;
	PDM_NOTIFY_FUNCTION rgpfnNotify[DM_NOTIFYMAX][MAX_NOTIFY];
	int rgcfnNotify[DM_NOTIFYMAX];
	ENH *rgpenh[MAX_ENH];
} DMN_SESSION;
#define DMSESS_DEAD 0x10000
PDMN_SESSION psessFirst;
PDMN_SESSION psessFree;
BOOL fUsingSessionList;
BOOL fPruneList;

struct {
	ULONG ulAddr;
	USHORT usPort;
	DWORD dwFlags;
} rgnnPersist[MAX_NOTIFY_SOCKETS];

PDFN g_pdfnFirst;
PDFN *g_ppdfnNext;

/* double fault data */
CONTEXT ctxDF;
BYTE rgbDFStack[4096];

BOOLEAN DmTrapHandler(PKTRAP_FRAME ptf, PKEXCEPTION_FRAME pef,
	PEXCEPTION_RECORD per, PCONTEXT pcr, BOOLEAN fSecondChance);
void EnterDebuggerDpc(PKDPC, PVOID, PVOID, PVOID);
void ClockInt(PKTRAP_FRAME ptf);
void ProfInt(PKTRAP_FRAME ptf);
void __fastcall CtxSwap(DWORD, DWORD);
BOOLEAN CanDebugDF(KTSS *ptss);
ULONG TellDebugger(ULONG, PVOID);

LPCSTR rgszExec[] = {
	/* These have to go in the same order as the DMN_EXEC values */
	"stopped",
	"started",
	"rebooting",
	"pending"
};

void InitNotifications()
{
	int isock;

	InitializeCriticalSection(&csNotify);
	InitializeCriticalSection(&csNotifySockList);
	KeInitializeEvent(&evtNotifyList, NotificationEvent, TRUE);
	for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
		rgsockNotify[isock] = INVALID_SOCKET;

	g_ppdfnNext = &g_pdfnFirst;
	fAllowKd = *KdDebuggerEnabled;
	pfnKdpTrap = *g_dmi.DebugRoutine;
	*g_dmi.DebugRoutine = DmTrapHandler;
	*g_dmi.ProfIntRoutine = ProfInt;
	KeInitializeDpc(&dpcBreakIn, EnterDebuggerDpc, NULL);
	g_dmi.TellRoutine = TellDebugger;
	KeGetCurrentPrcb()->DebugDoubleFault = CanDebugDF;
}

BOOL FAddNotifySock(SOCKET s)
{
	int isock;
	int iPass;

	RtlEnterCriticalSection(&csNotifySockList);
	for(iPass = 0; iPass < 2; ++iPass) {
		for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock) {
			if(rgsockNotify[isock] == INVALID_SOCKET) {
				rgsockNotify[isock] = s;
				RtlLeaveCriticalSection(&csNotifySockList);
				return TRUE;
			}
		}
		/* Nothing yet, let's send a keepalive to all of the existing sockets
		 * to make sure they're really all in use */
		if(!iPass)
			NotifyComponents(DM_NONE, 0);
	}
	RtlLeaveCriticalSection(&csNotifySockList);
	return FALSE;
}

BOOL FConvertToNotifySock(SOCKET s)
{
	BOOL fRet = FAddNotifySock(s);
	if(s) {
		char sz[64];
		PrintSockLine(s, "205- now a notification channel");
		if(FGetNotifySz(DM_EXEC, dwExecState, sz))
			PrintSockLine(s, sz);
	}
	return fRet;
}

BOOL FPrintNotifySock(int isock, LPCSTR sz)
{
	BOOL fRet = PrintSockLine(rgsockNotify[isock], sz);
	if(!fRet && rgsockNotify[isock] != INVALID_SOCKET) {
		closesocket(rgsockNotify[isock]);
		rgsockNotify[isock] = INVALID_SOCKET;
	}
	return fRet;
}

SOCKET SockCreateNotify(ULONG ulAddr, USHORT usPort, BOOL fNonBlock)
{
	SOCKET s;
	struct sockaddr_in sin;
	BOOL f;
	char sz[64];
    LARGE_INTEGER lu;
    PLARGE_INTEGER plu;

	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(INVALID_SOCKET == s)
		goto err1;
	f = TRUE;
	if(0 != setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (PVOID)&f, sizeof f))
		goto err2;
	sin.sin_family = AF_INET;
    /* We need to pick a random port so that we don't reset the connection
     * we previously held with our peer -- if we do that, they may well miss
     * any previously sent notifications */
    KeQuerySystemTime(plu = &lu);
    _asm {
        mov ecx, plu
        rdtsc
        xor [ecx], eax
        xor [ecx+4], edx
    };
    sin.sin_port = (USHORT)(((lu.HighPart ^ lu.LowPart) & 0x3FFF) + 0x1000);
    sin.sin_port = htons(sin.sin_port);
	sin.sin_addr.s_addr = 0;
	if(0 != bind(s, (struct sockaddr *)&sin, sizeof sin))
		goto err2;
	if(0 != ioctlsocket(s, FIONBIO, &fNonBlock))
		goto err2;
	sin.sin_addr.s_addr = htonl(ulAddr);
	sin.sin_port = htons(usPort);
	if(fNonBlock) {
		/* We expect the call to connect to return EWOULDBLOCK, so we just
		 * accept that error and don't try to send the initial string */
		if(0 == connect(s, (struct sockaddr *)&sin, sizeof sin) ||
				WSAGetLastError() != WSAEWOULDBLOCK)
			goto err2;
	} else {
		if(0 != connect(s, (struct sockaddr *)&sin, sizeof sin))
			goto err2;
		if(!FGetNotifySz(DM_EXEC, dwExecState, sz) || !PrintSockLine(s, sz))
			goto err2;
	}
	return s;
err2:
	closesocket(s);
err1:
	return INVALID_SOCKET;
}

void WriteIniNotifiers(INF *pinf)
{
	int inn;
	BYTE *pb;
	char sz[128];

	for(inn = 0; inn < MAX_NOTIFY_SOCKETS; ++inn) {
		if(rgnnPersist[inn].ulAddr) {
			pb = (BYTE *)&rgnnPersist[inn].ulAddr;
			sprintf(sz, "notifyat addr=%d.%d.%d.%d port=%d%s", pb[3], pb[2],
				pb[1], pb[0], rgnnPersist[inn].usPort,
				rgnnPersist[inn].dwFlags & DM_DEBUGSESSION ? " debug" : "");
			WriteIniSz(pinf, sz);
		}
	}
}

void UnNotifyAt(ULONG ulAddr, USHORT usPort)
{
	int inn;

	for(inn = 0; inn < MAX_NOTIFY_SOCKETS; ++inn) {
		if(rgnnPersist[inn].ulAddr == ulAddr && rgnnPersist[inn].usPort ==
				usPort)
			rgnnPersist[inn].ulAddr = 0;
	}
}

BOOL FNotifyAt(ULONG ulAddr, USHORT usPort, DWORD dwFlags, BOOL fBatch)
{
	int inn;

	if(!ulAddr)
		return FALSE;
	RtlEnterCriticalSection(&csNotifySockList);
	for(inn = 0; inn < MAX_NOTIFY_SOCKETS; ++inn)
		if(rgnnPersist[inn].ulAddr == 0)
			break;
	if(inn == MAX_NOTIFY_SOCKETS) {
		RtlLeaveCriticalSection(&csNotifySockList);
		return FALSE;
	}
	rgnnPersist[inn].ulAddr = ulAddr;
	rgnnPersist[inn].usPort = usPort;
	rgnnPersist[inn].dwFlags = dwFlags;
	RtlLeaveCriticalSection(&csNotifySockList);

	if(!fBatch) {
		SOCKET s = SockCreateNotify(ulAddr, usPort, FALSE);
		if(INVALID_SOCKET == s || !FAddNotifySock(s)) {
			rgnnPersist[inn].ulAddr = 0;
			if(INVALID_SOCKET != s)
				closesocket(s);
			/* We don't want this guy bothering us on reboot */
			UnNotifyAt(ulAddr, usPort);
			return FALSE;
		} else if (dwFlags & DM_DEBUGSESSION) {
			g_fDebugging = TRUE;
			fAllowKd = FALSE;
		}
	}
	return TRUE;
}

BOOL FNotifyAtCmd(SOCKET s, LPCSTR sz, BOOL fBatch)
{
	char szAddr[20];
	ULONG ulAddr;
	DWORD dwPort;
	struct sockaddr_in sin;
	int cbAddr = sizeof sin;
	DWORD dwFlags = 0;

	if(!FGetDwParam(sz, "port", &dwPort))
		return FALSE;
	if(FGetSzParam(sz, "addr", szAddr, sizeof szAddr))
		ulAddr = UlAddrFromSz(szAddr);
	else {
		if(s == INVALID_SOCKET)
			return FALSE;
		if(0 != getpeername(s, (struct sockaddr *)&sin, &cbAddr))
			return FALSE;
		ulAddr = ntohl(sin.sin_addr.s_addr);
	}

	if(PchGetParam(sz, "drop", FALSE)) {
		/* We want to remove this address/port from the list */
		UnNotifyAt(ulAddr, (USHORT)dwPort);
		return TRUE;
	}
	if(PchGetParam(sz, "debug", FALSE))
		dwFlags |= DM_DEBUGSESSION;
	return FNotifyAt(ulAddr, (USHORT)dwPort, dwFlags, fBatch);
}

BOOL FEnsureIPReady(int nTimeout)
{
    XNADDR xnaddr;

    while(nTimeout > 0) {
        if(XNetGetDebugXnAddr(&xnaddr) != 0)
            return TRUE;
        Sleep(100);
        nTimeout -= 100;
    }
    return FALSE;
}

void EnsurePersistentSockets(void)
{
	SOCKET rgsock[MAX_NOTIFY_SOCKETS];
	int isock;
	struct timeval tv;
	BOOL f = FALSE;
	LARGE_INTEGER liTimeout;
	NTSTATUS st;

	RtlEnterCriticalSection(&csNotifySockList);
	for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock) {
		if(rgnnPersist[isock].ulAddr) {
            /* See if we can get an IP address (wait up to 10 seconds), but
             * don't error out if we can't */
            FEnsureIPReady(10000);
			/* The peer sockets are expecting the command server to be up and
			 * running as soon as they're notified, so we need to wait for
			 * the server -- but we'll only wait 30 seconds before we decide
			 * we have no network */
			liTimeout.QuadPart = -30000 * 10000;
			st = KeWaitForSingleObject(&kevtServ, UserRequest, UserMode,
				FALSE, &liTimeout);
			if(!NT_SUCCESS(st) || st == STATUS_TIMEOUT)
			{
				DbgPrint("xbdm callback: timed out waiting for server\n");
				return;
			}
			rgsock[isock] = SockCreateNotify(rgnnPersist[isock].ulAddr,
				rgnnPersist[isock].usPort, TRUE);
		} else
			rgsock[isock] = INVALID_SOCKET;
	}

	/* wait no more than 60 seconds for the sockets to come online */
	tv.tv_sec = 60;
	tv.tv_usec = 0;
	for(;;) {
		int csock = 0;
		fd_set fds;

		FD_ZERO(&fds);
		for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
			if(rgsock[isock] != INVALID_SOCKET) {
				FD_SET(rgsock[isock], &fds);
				++csock;
			}
		if(!csock)
			/* Nobody left to wait for */
			break;
		if(select(0, NULL, &fds, NULL, &tv) == 0) {
			/* The remaining sockets are not going to connect, so give up on
			 * them */
			for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
				if(rgsock[isock] != INVALID_SOCKET) {
					closesocket(rgsock[isock]);
					/* Failure now means we won't ever try this port again */
					rgnnPersist[isock].ulAddr = 0;
				}
			break;
		} else {
			/* Whichever sockets are ready need to be made nonblocking and
			 * marked as notify sockets */
			for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
				if(FD_ISSET(rgsock[isock], &fds)) {
					if(0 != ioctlsocket(rgsock[isock], FIONBIO, &f))
						/* Give up on this socket */
						closesocket(rgsock[isock]);
					else {
						/* Try to send the initial string */
						if(!PrintSockLine(rgsock[isock], "hello")) {
							/* No socket there.  Give up on this port */
							closesocket(rgsock[isock]);
							rgnnPersist[isock].ulAddr = 0;
						} else {
							FAddNotifySock(rgsock[isock]);
							if(rgnnPersist[isock].dwFlags & DM_DEBUGSESSION) {
								g_fDebugging = TRUE;
								fAllowKd = FALSE;
							}
						}
					}
					/* Don't worry about this socket anymore */
					rgsock[isock] = INVALID_SOCKET;
				}
		}
	}
	RtlLeaveCriticalSection(&csNotifySockList);
	/* With our actual list of sockets set up, we need to flush the ini file
	 * so we remember where our successes were */
	WriteIniFile();
}

void ProcessDeferredNotifications(PDFN pdfn)
{
	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	while(pdfn) {
		PDFN pdfnNext = pdfn->pdfnNext;

		NotifyComponents(DM_DEBUGSTR, (DWORD)&pdfn->dmds);
		DmFreePool(pdfn);
		pdfn = pdfnNext;
	}
}

void SendDebugStrs(DWORD dwNotification, PDMN_DEBUGSTR pdmds)
{
	int isock;
	char szCmd1[64];
	char szCmd2[32];
	int cchCmd;
	char *szNotification;
	WSABUF wsabufs[4];

	if((dwNotification & DM_NOTIFICATIONMASK) == DM_ASSERT)
		szNotification = "assert";
	else
		szNotification = "debugstr";

	sprintf(szCmd1, "%s %sthread=%d ", szNotification, dwNotification &
		DM_STOPTHREAD ? "stop ": "", pdmds->ThreadId);
	cchCmd = strlen(szCmd1);

	if(KeGetCurrentIrql() == PASSIVE_LEVEL) {
		KeEnterCriticalRegion();
		RtlEnterCriticalSection(&csNotify);
		for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock) {
			SOCKET s = rgsockNotify[isock];
			ULONG ichFirst, ichLim, ichMac;
			int cchSkip;
			char *szCrlf;
			DWORD cb, bufcnt;
			WSABUF* bufs;

			if(s == INVALID_SOCKET) continue;

			ichFirst = 0;
			while(ichFirst < pdmds->Length) {
                /* We'll only send 2k worth of data at a time */
                ichMac = ichFirst + 2048;
                if(ichMac > pdmds->Length)
                    ichMac = pdmds->Length;
				for(ichLim = ichFirst; ichLim < ichMac; ++ichLim)
					if(pdmds->String[ichLim] == '\012' ||
						pdmds->String[ichLim] == '\015')
						break;
				/* We need to figure out what's terminating this line */
				if(ichLim == ichMac) {
					cchSkip = 0;
					szCrlf = "";
				} else if(pdmds->String[ichLim] == '\015') {
					cchSkip = 1;
					szCrlf = "cr ";
				} else if(pdmds->String[ichLim] == '\012') {
					if(ichLim + 1 < pdmds->Length &&
						pdmds->String[ichLim + 1] == '\015')
					{
						cchSkip = 2;
						szCrlf = "crlf ";
					} else {
						cchSkip = 1;
						szCrlf = "lf ";
					}
				} else
					ASSERT(FALSE);

				/* We've got something to print.  Start the command */
				bufs = wsabufs;
				bufs[0].len = cchCmd;
				bufs[0].buf = szCmd1;

				/* Send our terminator */
				sprintf(szCmd2, "%sstring=", szCrlf);
				bufs[1].len = strlen(szCmd2);
				bufs[1].buf = szCmd2;

				/* Whatever we have from ichFirst to ichLim is a valid
				 * string that needs to be sent */

				bufs[2].len = ichLim - ichFirst;
				bufs[2].buf = (char*) &pdmds->String[ichFirst];

				bufs[3].len = 2;
				bufs[3].buf = "\015\012";

				bufcnt = 4;
			senddata:
				if (WSASend(s, bufs, bufcnt, &cb, 0, NULL, NULL) == SOCKET_ERROR) {
					closesocket(s);
					rgsockNotify[isock] = INVALID_SOCKET;
					break;
				}

				/* Handle the case where some data were not sent by WSASend */
				while (cb) {
					DWORD n = min(cb, bufs->len);
					cb -= n;
					bufs->buf += n;
					bufs->len -= n;
					if (bufs->len == 0)
						bufs++, bufcnt--;
				}
				if (bufcnt) goto senddata;

				ichFirst = ichLim + cchSkip;
			}
		}
		RtlLeaveCriticalSection(&csNotify);
		KeLeaveCriticalRegion();
	}
}

void GetModLoadSz(LPSTR sz, PDMN_MODLOAD pdmml)
{
	sprintf(sz, "name=\"%s\" base=0x%08x size=0x%08x check=0x%08x "
		"timestamp=0x%08x%s%s", pdmml->Name, pdmml->BaseAddress,
		pdmml->Size, pdmml->CheckSum, pdmml->TimeStamp,
		pdmml->Flags & DMN_MODFLAG_TLS ? " tls" : "",
        pdmml->Flags & DMN_MODFLAG_XBE ? " xbe" : "");
}

void GetSectLoadSz(LPSTR sz, PDMN_SECTIONLOAD pdmsl)
{
	sprintf(sz, "name=\"%s\" base=0x%08x size=0x%08x index=%d flags=%d",
		pdmsl->Name, pdmsl->BaseAddress, pdmsl->Size, pdmsl->Index,
		pdmsl->Flags);
}

BOOL FGetNotifySz(DWORD dwNotification, DWORD dwParam, LPSTR sz)
{
	char *pch;

	switch(dwNotification & DM_NOTIFICATIONMASK) {
#define pdmnbr ((PDMN_BREAK)dwParam)
	case DM_BREAK:
		sprintf(sz, "break addr=0x%08x thread=%d", pdmnbr->Address,
			pdmnbr->ThreadId);
		break;
	case DM_SINGLESTEP:
		sprintf(sz, "singlestep addr=0x%08x thread=%d", pdmnbr->Address,
			pdmnbr->ThreadId);
		break;
#undef pdmnbr
	case DM_DATABREAK:
		{
		PDMN_DATABREAK pdmdb = (PDMN_DATABREAK)dwParam;
		LPCSTR szType;
		switch(pdmdb->BreakType) {
		case DMBREAK_READWRITE:
			szType = "read";
			break;
		case DMBREAK_WRITE:
			szType = "write";
			break;
		case DMBREAK_EXECUTE:
			szType = "execute";
			break;
		default:
			return FALSE;
		}
		sprintf(sz, "data %s=0x%08x addr=0x%08x thread=%lu", szType,
			pdmdb->DataAddress, pdmdb->Address, pdmdb->ThreadId);
		}
		break;
	case DM_EXEC:
		sprintf(sz, "execution %s", rgszExec[dwParam]);
		break;
	case DM_EXCEPTION:
#define pdme ((PDMN_EXCEPTION)dwParam)
		sprintf(sz, "exception code=0x%08x thread=%d address=0x%08x",
			pdme->Code, pdme->ThreadId, pdme->Address);
		for(pch = sz; *pch; ++pch);
		if(pdme->Code == EXCEPTION_ACCESS_VIOLATION)
			sprintf(pch, " %s=0x%08x", pdme->Information[0] ? "write" : "read",
				pdme->Information[1]);
		if(pdme->Flags & DM_EXCEPT_FIRSTCHANCE)
			strcat(pch, " first");
		if(pdme->Flags & DM_EXCEPT_NONCONTINUABLE)
			strcat(pch, " noncont");
#undef pdme
		break;
	case DM_CREATETHREAD:
#define pdmct ((PDMN_CREATETHREAD)dwParam)
		sprintf(sz, "create thread=%d start=0x%08x", pdmct->ThreadId,
			pdmct->StartAddress);
#undef pdmct
		break;
	case DM_DESTROYTHREAD:
		sprintf(sz, "terminate thread=%d", dwParam);
		break;
	case DM_MODLOAD:
		strcpy(sz, "modload ");
		GetModLoadSz(sz + strlen(sz), (PDMN_MODLOAD)dwParam);
		break;
	case DM_SECTIONLOAD:
		strcpy(sz, "sectload ");
SectionStr:
		GetSectLoadSz(sz + strlen(sz), (PDMN_SECTIONLOAD)dwParam);
		break;
	case DM_SECTIONUNLOAD:
		strcpy(sz, "sectunload ");
		goto SectionStr;
#if 0
	case DM_FIBER:
#define pdmfib ((PDMN_FIBER)dwParam)
		if(pdmfib->Create)
			sprintf(sz, "fiber id=0x%08x start=0x%08x", pdmfib->FiberId,
				pdmfib->StartAddress);
		else
			sprintf(sz, "fiber id=0x%08x delete", pdmfib->FiberId);
		break;
#undef pdmfib
#endif // FIBER
	case DM_RIP:
#define pdmds ((PDMN_DEBUGSTR)dwParam)
		if(pdmds->String) {
			sprintf(sz, "rip%s thread=%lu string=%-*.*s", dwNotification &
				DM_STOPTHREAD ? " stop" : "", pdmds->ThreadId, pdmds->Length,
				pdmds->Length, pdmds->String);
			return TRUE;
		}
		sprintf(sz, "rip thread=%lu", pdmds->ThreadId);
#undef pdmds
		break;
	default:
		/* We don't know what this is */
		return FALSE;
	}
	if(dwNotification & DM_STOPTHREAD)
		strcat(sz, " stop");
	return TRUE;
}

void EnterSessionList(BOOL fWriteLock)
{
	if(fWriteLock) {
		/* We need to ensure that we have exclusive access to the list */
		KIRQL irqlSav;

		irqlSav = KfRaiseIrql(DISPATCH_LEVEL);
		KeResetEvent(&evtNotifyList);
		while(fUsingSessionList) {
			KeLowerIrql(irqlSav);
			KeWaitForSingleObject(&evtNotifyList, UserRequest, UserMode,
				FALSE, NULL);
			KfRaiseIrql(DISPATCH_LEVEL);
		}
		++fUsingSessionList;
	} else
		InterlockedIncrement(&fUsingSessionList);
}

void LeaveSessionList(void)
{
	PDMN_SESSION psess;
	PDMN_SESSION *ppsess;

	/* Try not to raise irql unless we think we need to */
	if(fPruneList && fUsingSessionList == 1) {
		KIRQL irqlSav = KfRaiseIrql(HIGH_LEVEL);
		if(0 == InterlockedDecrement(&fUsingSessionList)) {
			/* Free all of the sessions marked dead */
			ppsess = &psessFirst;
			while(*ppsess) {
				psess = *ppsess;
				if(psess->dwFlags & DMSESS_DEAD) {
					*ppsess = psess->psessNext;
					psess->dwSig = 0;
					psess->psessNext = psessFree;
					psessFree = psess;
				} else
					ppsess = &psess->psessNext;
			}
		}
		if(irqlSav <= DISPATCH_LEVEL && psessFirst) {
			/* Free the free list */
			psess = psessFree;
			psessFree = NULL;
			KeLowerIrql(DISPATCH_LEVEL);
			while(psess) {
				PDMN_SESSION psessNext = psess->psessNext;
				DmFreePool(psess);
				psess = psessNext;
			}
		}
		KfLowerIrql(irqlSav);
	} else
		InterlockedDecrement(&fUsingSessionList);
	if(KeGetCurrentIrql() <= DISPATCH_LEVEL && fUsingSessionList == 0)
		KeSetEvent(&evtNotifyList, 0, FALSE);
}

DWORD NotifyLocalComponents(DWORD dwNotification, DWORD dwParam)
{
	PDMN_SESSION psess;
	int ifn;
	DWORD dwNot = dwNotification & DM_NOTIFICATIONMASK;

	EnterSessionList(FALSE);
	for(psess = psessFirst; psess; psess = psess->psessNext) {
		if(!(psess->dwFlags & DMSESS_DEAD)) {
			ifn = psess->rgcfnNotify[dwNot];
			while(ifn--)
				(*psess->rgpfnNotify[dwNot][ifn])(dwNotification, dwParam);
		}
	}
	LeaveSessionList();
	return 0;
}

DWORD NotifyComponents(DWORD dwNotification, DWORD dwParam)
{
	int isock;
	char sz[512];
	int csockNotify;
	DWORD dwNot = dwNotification & DM_NOTIFICATIONMASK;
	KIRQL irql = KeGetCurrentIrql();

	/* We only let certain notifications go through at raised irql. */
	switch(dwNot) {
	case DM_CLOCKINT:
#if 0
	case DM_PROFINT:
#endif
		break;
	case DM_DEBUGSTR:
		if(irql == PASSIVE_LEVEL)
			break;
		if(irql <= DISPATCH_LEVEL) {
			/* Defer the print */
			PDMN_DEBUGSTR pdmds = (PDMN_DEBUGSTR)dwParam;
			PDFN pdfn;

			pdfn = DmAllocatePoolWithTag(sizeof *pdfn + pdmds->Length, 'nfdD');
			if(pdfn) {
				DWORD ef;

				pdfn->pdfnNext = NULL;
				pdfn->dmds.ThreadId = pdmds->ThreadId;
				pdfn->dmds.Length = pdmds->Length;
				pdfn->dmds.String = (PVOID)(pdfn + 1);
				memcpy(pdfn + 1, pdmds->String, pdmds->Length);
				QueueDfn(pdfn);
				SetupHalt(HF_DEFERRED);
			}
		}
		return 0;
	case DM_ASSERT:
		if(irql != PASSIVE_LEVEL)
			return 0;
		/* We need to grab the critical section now so that nobody gets a
		 * chance to interject between the assert strings and the final
		 * assert notification */
		KeEnterCriticalRegion();
		RtlEnterCriticalSection(&csNotify);
		break;
	default:
		if(irql != PASSIVE_LEVEL)
			return 0;
	}

	/* First we notify all local components */
	NotifyLocalComponents(dwNotification, dwParam);

	/* Then we notify all of the remotes */
	if(!FGetNotifySz(dwNotification, dwParam, sz)) {
		switch(dwNot) {
		case DM_ASSERT:
			SendDebugStrs(DM_ASSERT, (PDMN_DEBUGSTR)dwParam);
			sprintf(sz, "assert prompt thread=%d",
				((PDMN_DEBUGSTR)dwParam)->ThreadId);
			if(dwNotification & DM_STOPTHREAD)
				strcat(sz, " stop");
			break;
		case DM_DEBUGSTR:
			SendDebugStrs(dwNotification, (PDMN_DEBUGSTR)dwParam);
			return 0;
		case DM_NONE:
			/* This is just a keepalive event, only for the notification
			 * sockets */
			sprintf(sz, "null");
			break;
		default:
			/* We don't know what this is */
			return 0;
		}
	}
	csockNotify = 0;
	if(KeGetCurrentIrql() == PASSIVE_LEVEL) {
		/* We don't allow concurrent notifications in multiple threads */
		KeEnterCriticalRegion();
		RtlEnterCriticalSection(&csNotify);
		for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
			if(rgsockNotify[isock] != INVALID_SOCKET) {
				if(FPrintNotifySock(isock, sz))
					++csockNotify;
			}
		RtlLeaveCriticalSection(&csNotify);
		KeLeaveCriticalRegion();
	}
	if(dwNot == DM_ASSERT) {
		RtlLeaveCriticalSection(&csNotify);
		KeLeaveCriticalRegion();
	}
	return csockNotify;
}

struct TST {
	BOOL fStop;
	PKSYSTEM_ROUTINE pfn;
};

void FStartThread(struct TST *ptst, PKSTART_ROUTINE pfnStart, PVOID pvContext)
{
	DMN_CREATETHREAD dmct;
	DWORD dwNotification = DM_CREATETHREAD;
	PDMTD pdmtd = DmGetCurrentDmtd();

	/* We only notify for XAPI threads */
	if(PsGetCurrentThread()->Tcb.TlsData) {
		_asm cli
		ptst->fStop = g_dmi.Flags & DMIFLAG_BREAK;
		g_dmi.Flags &= ~DMIFLAG_BREAK;
		_asm sti
		ptst->pfn = pdmtd->SystemStartupRoutine;
		dmct.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
		dmct.StartAddress = pfnStart;
		// should we suppress the stop if we're going to break anyway?
		if(g_grbitStopOn & DMSTOP_CREATETHREAD) {
			dwNotification |= DM_STOPTHREAD;
			PrepareToStop();
		}
		NotifyComponents(dwNotification, (DWORD)&dmct);
		if(dwNotification & DM_STOPTHREAD)
			FStopAtException();
	}
	ASSERT(pdmtd);
	ASSERT(pdmtd->DebugFlags & DMFLAG_STARTTHREAD);
	pdmtd->DebugFlags &= ~DMFLAG_STARTTHREAD;
}

void EnterDebuggerDpc(PKDPC pdpc, PVOID pv1, PVOID pv2, PVOID pv3)
{
	fAllowKd = TRUE;
	/* Fool our exception handler into thinking the debugger is connected
	 * (we know it is, otherwise how would we be here) -- if something goes
	 * wrong, kd can always clean it up later */
	//*KdDebuggerNotPresent = FALSE;
	ExceptionsToKd();
}

BOOLEAN EnterDebugger(void)
{
	PLIST_ENTRY ple;
	PETHREAD pthr;
	PDMTD pdmtd;
	BOOLEAN fNoBreak = TRUE;

	ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

	/* Walk the thread list and find out whether any threads have exceptions
	 * pending.  If so, we need to schedule a DPC to forward them */
	ple = pprocSystem->ThreadListHead.Flink;
	while(ple != &pprocSystem->ThreadListHead) {
		pthr = (PETHREAD)CONTAINING_RECORD(ple, KTHREAD, ThreadListEntry);
		ple = ple->Flink;
		pdmtd = (PDMTD)pthr->DebugData;
		if(pdmtd && pdmtd->ExceptionContext)
			fNoBreak = FALSE;
	}

	if(!fNoBreak)
		KeInsertQueueDpc(&dpcBreakIn, NULL, NULL);
	return fNoBreak;
}

BOOLEAN TrapHandler(PEXCEPTION_TRAP pexc)
{
	BOOL fPassAlong = TRUE;
	BOOLEAN fRet;
	BOOL fHaveKd = fAllowKd && !*KdDebuggerNotPresent;
	DMTD *pdmtd = DmGetCurrentDmtd();
	//static int nLock = -1;
	BOOL fDebuggable;
    PEXCEPTION_RECORD per;
    PCONTEXT pcr;
	BOOL fDebuggableThread;

    per = pexc->ExceptionRecord;
    pcr = pexc->ContextRecord;

	/* We can only do any work if we haven't been reentered -- plus we don't
	 * allow any debugging of the debugger itself (except at DPC or higher),
	 * nor do we allow any debugging inside of a bugcheck */
	fDebuggableThread = KeGetCurrentThread()->TlsData != NULL ||
		(pdmtd && !(pdmtd->DebugFlags & DMFLAG_DEBUGTHREAD));
	fDebuggable = pdmtd && !pdmtd->ExceptionContext && (fDebuggableThread ||
		KeGetCurrentIrql() >= DISPATCH_LEVEL);
	if(!(g_dmi.Flags & DMIFLAG_BUGCHECK) && fDebuggable) {
		if(pdmtd) {
			pdmtd->ExceptionRecord = per;
			pdmtd->ExceptionContext = pcr;
			pdmtd->ExceptionDr6 = DwExchangeDr6(0);
			pdmtd->DebugFlags &= ~DMFLAG_KDEXCEPT;
		}

		if(per->ExceptionCode == STATUS_BREAKPOINT) {
			/* If this is a breakpoint trap, it could be one of a number of
			 * things */
			switch(per->ExceptionInformation[0]) {
			case BREAKPOINT_BREAK:
				{
				DMN_BREAK dmnbr;
				BOOL fOurBP;
				DWORD dwNotification = DM_BREAK;

				dmnbr.Address = (void *)pcr->Eip;
				dmnbr.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				fOurBP = FIsBreakpoint((BYTE *)pcr->Eip);
				/* We'll stop here for all breakpoints, with a few exceptions.
				 * If it's not our breakpoint and KD is installed, we won't
				 * stop, but let the breakpoint go along to KD.  If the irql
				 * is too high to stop, we won't bother to stop and we'll clean
				 * up after the breakpoint.  If there's nobody listening,
				 * we'll go ahead and stop, assuming that somebody may soon
				 * come along.  If the debugger is present and we're at greater
				 * than passive level, pass the breakpoint on to KD */
				fPassAlong = !fOurBP && (fHaveKd || (KeGetCurrentIrql() != PASSIVE_LEVEL && !*KdDebuggerNotPresent));
				if(!fPassAlong && KeGetCurrentIrql() == PASSIVE_LEVEL) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmnbr);
				fRet = TRUE;
				if(!fPassAlong) {
					if(KeGetCurrentIrql() == PASSIVE_LEVEL)
						FStopAtException();
					/* Pass to kd if requested.  We'll fix up the breakpoint
					 * for our breakpoints, but for breakpoints that aren't
					 * ours, we'll leave eip alone in case kd needs it */
					if(pdmtd->DebugFlags & DMFLAG_KDEXCEPT)
						fPassAlong = TRUE;
					if(fOurBP || !fPassAlong)
						ResumeAfterBreakpoint(pcr);
				}
				}
				break;
			case BREAKPOINT_PRINT:
				{
				DMN_DEBUGSTR dmds;
				DWORD dwNotification = DM_DEBUGSTR;
				BOOL fStop;

				dmds.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				dmds.Length = ((PSTRING)per->ExceptionInformation[1])->Length;
				dmds.String = ((PSTRING)per->ExceptionInformation[1])->Buffer;
				fStop = (g_grbitStopOn & DMSTOP_DEBUGSTR) &&
					KeGetCurrentIrql() ==  PASSIVE_LEVEL;
				if(fStop) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmds);
				if(fStop)
					FStopAtException();
				}
				break;

			case BREAKPOINT_RTLASSERT:
				{
				DWORD dwNotification = DM_ASSERT;
				DMN_DEBUGSTR dmds;
				DWORD dwEipSav;

				dwEipSav = pcr->Eip;
				dmds.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				dmds.Length = ((PSTRING)per->ExceptionInformation[1])->Length;
				dmds.String = ((PSTRING)per->ExceptionInformation[1])->Buffer;
				/* We stop if it's the end of the assert, and we're at lowered
				 * irql, and the assert isn't going to kd */
				fPassAlong = fHaveKd || KeGetCurrentIrql() != PASSIVE_LEVEL;
				if(!fPassAlong) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmds);
				if(!fPassAlong) {
					FStopAtException();
					if(pdmtd->DebugFlags & DMFLAG_KDEXCEPT)
						fPassAlong = TRUE;
				}
				if(!fPassAlong) {
					if(pcr->Eip == dwEipSav)
						// need to skip the breakpoint
						++pcr->Eip;
				}
				}
				fRet = TRUE;
				break;

			case BREAKPOINT_RIP:
				{
				DMN_DEBUGSTR dmds;
				DWORD dwNotification = DM_RIP;
				DWORD dwEipSav;

				dwEipSav = pcr->Eip;
				dmds.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				dmds.String = (LPSTR)per->ExceptionInformation[1];
				/* If the string contains a newline, we won't be able to send
				 * anything past it, so we consider that the end of the
				 * string */
				dmds.Length = 0;
				while(dmds.String[dmds.Length] && dmds.String[dmds.Length] !=
						'\n')
					++dmds.Length;
				fPassAlong = fHaveKd || KeGetCurrentIrql() != PASSIVE_LEVEL;
				if(!fPassAlong) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmds);
				if(!fPassAlong) {
					FStopAtException();
					if(pdmtd->DebugFlags & DMFLAG_KDEXCEPT)
						fPassAlong = TRUE;
				}
				if(!fPassAlong) {
					if(pcr->Eip == dwEipSav)
						// need to skip the breakpoint
						++pcr->Eip;
				}
				}
				fRet = TRUE;
				break;

			case BREAKPOINT_LOAD_SYMBOLS:
				{
				DMN_MODLOAD dmml;
				ANSI_STRING *pasz = (ANSI_STRING *)per->ExceptionInformation[1];
				KD_SYMBOLS_INFO *pkdsi = (KD_SYMBOLS_INFO *)per->ExceptionInformation[2];

				strncpy(dmml.Name, pasz->Buffer, pasz->Length);
				dmml.Name[pasz->Length] = 0;
				dmml.BaseAddress = pkdsi->BaseOfDll;
				dmml.Size = pkdsi->SizeOfImage;
				dmml.CheckSum = pkdsi->CheckSum;
				dmml.TimeStamp = 0;

                if (dmml.BaseAddress == XeImageHeader() ||
                    (MmDbgReadCheck(&XeImageHeader()->NtBaseOfDll) &&
                    dmml.BaseAddress == XeImageHeader()->NtBaseOfDll))
                {
                    FixupBistroImage();
                    dmml.Flags = DwXmhFlags(&dmml);
                } else {
                    dmml.Flags = 0;
                }

				NotifyComponents(DM_MODLOAD, (DWORD)&dmml);
				}
				break;

			case BREAKPOINT_LOAD_XESECTION:
				{
				DMN_SECTIONLOAD dmsl;
				PXBEIMAGE_SECTION pxsh = (PVOID)per->ExceptionInformation[1];

				DmslFromXsh(pxsh, &dmsl);
				NotifyComponents(DM_SECTIONLOAD, (DWORD)&dmsl);
				/* If any breakpoints were placed in this section, we need
				 * to enable them now */
				EnableBreakpointsInRange((PBYTE)dmsl.BaseAddress,
					(PBYTE)dmsl.BaseAddress + dmsl.Size, TRUE);
				}
				break;

			case BREAKPOINT_UNLOAD_XESECTION:
				{
				DMN_SECTIONLOAD dmsl;
				PXBEIMAGE_SECTION pxsh = (PVOID)per->ExceptionInformation[1];

				DmslFromXsh(pxsh, &dmsl);
				/* Any breakpoints that were placed in this section need to
				 * be disabled now */
				DisableBreakpointsInRange((PBYTE)dmsl.BaseAddress,
					(PBYTE)dmsl.BaseAddress + dmsl.Size);
				NotifyComponents(DM_SECTIONUNLOAD, (DWORD)&dmsl);
				}
				break;

#if 0
			case BREAKPOINT_CREATE_FIBER:
				{
				DMN_FIBER dmfib;

				dmfib.Create = TRUE;
				dmfib.FiberId = per->ExceptionInformation[1];
				dmfib.StartAddress = (PVOID)per->ExceptionInformation[2];
				NotifyComponents(DM_FIBER, (DWORD)&dmfib);
				}
				break;

			case BREAKPOINT_DELETE_FIBER:
				{
				DMN_FIBER dmfib;

				dmfib.Create = FALSE;
				dmfib.FiberId = per->ExceptionInformation[1];
				NotifyComponents(DM_FIBER, (DWORD)&dmfib);
				}
				break;
#endif
			}
		} else if(per->ExceptionCode == STATUS_SINGLE_STEP) {
			DMN_DATABREAK dmdb;

			/* Figure out whether this was a single step due to a hw breakpoint
			 * or a trace */
			if(FMatchDataBreak(pdmtd->ExceptionDr6, &dmdb)) {
				/* It's a real data breakpoint, so we need to notify for it */
				DWORD dwNotification = DM_DATABREAK;
				BOOL fStop = KeGetCurrentIrql() == PASSIVE_LEVEL;
				dmdb.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				dmdb.Address = (PVOID)pcr->Eip;
				if(fStop) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmdb);
				if(fStop)
					FStopAtException();
				fPassAlong = FALSE;
				fRet = TRUE;
			} else if(FBreakTrace(pcr)) {
				/* If this is because we're running past a breakpoint, we just
				 * patch things up and act like nothing happened */
				fPassAlong = FALSE;
				fRet = TRUE;
			} else {
				DMN_BREAK dmbr;
				DWORD dwNotification = DM_SINGLESTEP;
				BOOL fStop;

				/* We stop like it's a breakpoint unless KD is around */
				dmbr.Address = (PVOID)pcr->Eip;
				dmbr.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				fStop = pdmtd && !fHaveKd && KeGetCurrentIrql() ==
					PASSIVE_LEVEL;
				if(fStop) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmbr);
				if(fStop)
					FStopAtException();
				fPassAlong = fHaveKd || (pdmtd->DebugFlags & DMFLAG_KDEXCEPT);
				fRet = TRUE;
			}
		} else {
			BOOL fException;
			DMN_EXCEPTION dme;
			DWORD dwNotification = DM_EXCEPTION;
			BOOL fStop;

			/* Notify everybody of the exception */
			dme.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
			dme.Code = per->ExceptionCode;
			dme.Address = per->ExceptionAddress;
			dme.Flags = per->ExceptionFlags & EXCEPTION_NONCONTINUABLE ?
				DM_EXCEPT_NONCONTINUABLE : 0;
			/* Stop on first chance exceptions if we're supposed to do so, and
			 * stop on second-chance exceptions always, unless kd is supposed
			 * to see the exception */
			fStop = pdmtd && KeGetCurrentIrql() == PASSIVE_LEVEL;
			if(!pexc->SecondChance) {
				dme.Flags |= DM_EXCEPT_FIRSTCHANCE;
				if(!(g_grbitStopOn & DMSTOP_FCE))
					fStop = FALSE;
				if(pdmtd)
					pdmtd->DebugFlags |= DMFLAG_FCE;
			} else if(fHaveKd)
				fStop = FALSE;
			if(dme.Code == EXCEPTION_ACCESS_VIOLATION) {
				dme.Information[0] = per->ExceptionInformation[0];
				dme.Information[1] = per->ExceptionInformation[1];
			}
			if(fStop) {
				dwNotification |= DM_STOPTHREAD;
				PrepareToStop();
			}
			NotifyComponents(dwNotification, (DWORD)&dme);

			if(fStop)
				fException = FStopAtException();
			else
				fException = TRUE;

			/* We pass the exception along if we want to let KD see it, unless
			 * we got a continue without processing */
			fPassAlong = (fHaveKd && fException) ||
				pdmtd->DebugFlags & DMFLAG_KDEXCEPT;
			/* If this isn't going to KD, we allow further processing based on
			 * whether the continue requested it */
			fRet = !fException;
		}
		if(pdmtd) {
			pdmtd->DebugFlags &= ~DMFLAG_FCE;
			pdmtd->ExceptionContext = NULL;
			pdmtd->ExceptionRecord = NULL;
		}
    } else if((pdmtd && !fDebuggableThread) ||
        (per->ExceptionCode == STATUS_BREAKPOINT &&
        (per->ExceptionInformation[0] == BREAKPOINT_PRINT ||
        per->ExceptionInformation[0] == BREAKPOINT_KDPRINT)))
    {
        /* This can go straight down to kd, which we're already set up to
         * do, so do nothing here */
	} else if(!pdmtd) {
		/* This thread got created without thread-specific debug data and
		 * we're not in a position to try to process this exception. */
	} else if(per->ExceptionCode == STATUS_BREAKPOINT &&
			per->ExceptionInformation[0] == BREAKPOINT_BREAK) {
		/* We're reentrant on a breakpoint, so we need to skip it */
		KIRQL irqlSav;

		KeRaiseIrql(HIGH_LEVEL, &irqlSav);
		/* If the old irql was high, then we may well have reentered here,
		 * because perhaps there's a breakpoint set in the breakpoint search
		 * code.  If so, we'll just pass it down to kd (or bugcheck if there's
		 * no kd).  If we are able to search the breakpoint list, and find
		 * that this is our breakpoint, we'll try just to disable it */
		if(irqlSav < HIGH_LEVEL && FIsBreakpoint((BYTE *)pcr->Eip)) {
			DisableBreakpoint((BYTE *)pcr->Eip);
			fPassAlong = FALSE;
			fRet = TRUE;
		}
		KeLowerIrql(irqlSav);
    }

	if(fPassAlong) {
		fRet = (*pfnKdpTrap)(pexc->TrapFrame, pexc->ExceptionFrame, per, pcr,
            pexc->SecondChance);
		/* If we have data bps set, kd may have just stomped on them, so we
		 * reset all the ones we have enabled */
		SyncHwbps();
	}
	DwExchangeDr6(0);
	return fRet;
}

BOOLEAN DmTrapHandler(PKTRAP_FRAME ptf, PKEXCEPTION_FRAME pef,
	PEXCEPTION_RECORD per, PCONTEXT pcr, BOOLEAN fSecondChance)
{
    DMTD *pdmtd = DmGetCurrentDmtd();
    if(pdmtd)
        return (BOOLEAN)CallOnStack(TrapHandler, &pdmtd->ExceptionStack, &ptf);
    else
        return TrapHandler((PEXCEPTION_TRAP)&ptf);
}

void SetupKernelNotifier(DWORD dw, PDMN_SESSION psess)
{
	BOOL fInstall = FALSE;
	PVOID *ppvKernelFunc;
	PVOID pvFunc;

	switch(dw) {
	case DM_CLOCKINT:
		ppvKernelFunc = g_dmi.ClockIntRoutine;
		pvFunc = ClockInt;
		break;
#if 0
	case DM_PROFINT:
		ppvKernelFunc = g_dmi.ProfIntRoutine;
		pvFunc = ProfInt;
		break;
#endif
	case DM_THREADSWITCH:
		ppvKernelFunc = g_dmi.CtxSwapNotifyRoutine;
		pvFunc = CtxSwap;
		break;
	default:
		ppvKernelFunc = NULL;
		break;
	}

	if(ppvKernelFunc) {
		while(psess) {
			if(!(psess->dwFlags & DMSESS_DEAD) && psess->rgcfnNotify[dw])
				fInstall = TRUE;
			psess = psess->psessNext;
		}
		*ppvKernelFunc = fInstall ? pvFunc : NULL;
	}
}

HRESULT DmOpenNotificationSession(DWORD dwFlags, PDMN_SESSION *ppsess)
{
	KIRQL irqlSav;

	if (!ppsess)
		return E_INVALIDARG;

	irqlSav = KeGetCurrentIrql();
	ASSERT(irqlSav == PASSIVE_LEVEL);
	*ppsess = DmAllocatePoolWithTag(sizeof(DMN_SESSION), 'snmd');
	if(!*ppsess)
		return E_OUTOFMEMORY;
	EnterSessionList(TRUE);
	RtlZeroMemory(*ppsess, sizeof(DMN_SESSION));
	(*ppsess)->dwFlags = dwFlags;
	(*ppsess)->dwSig = 'xnot';
	(*ppsess)->psessNext = psessFirst;
	psessFirst = *ppsess;
	LeaveSessionList();
	KeLowerIrql(irqlSav);
	return XBDM_NOERR;
}

HRESULT DmCloseNotificationSession(PDMN_SESSION psess)
{
	PDMN_SESSION *ppsess;

	if (!psess || psess->dwSig != 'xnot')
		return E_INVALIDARG;

	EnterSessionList(FALSE);
	psess->dwFlags |= DMSESS_DEAD;
	fPruneList = TRUE;
	LeaveSessionList();

	return XBDM_NOERR;
}

HRESULT DmNotify(PDMN_SESSION psess, DWORD dw, PDM_NOTIFY_FUNCTION pfnHandler)
{
	HRESULT hr;
	PDMN_SESSION psessSav;
	KIRQL irqlSav;

	if (!psess || psess->dwSig != 'xnot')
		return E_INVALIDARG;

	irqlSav = KeGetCurrentIrql();
	ASSERT(irqlSav == PASSIVE_LEVEL);
	dw &= DM_NOTIFICATIONMASK;
	EnterSessionList(TRUE);
	/* Temporarily unhook the notification list */
	psessSav = psessFirst;
	psessFirst = NULL;
	if (dw == DM_NONE) {
		if(pfnHandler) {
			/* We need to remove this handler from all of the lists */
			while(++dw <= DM_NOTIFYMAX) {
				int ifn;

				for(ifn = 0; ifn < psess->rgcfnNotify[dw]; ++ifn)
					if(psess->rgpfnNotify[dw][ifn] == pfnHandler)
						psess->rgpfnNotify[dw][ifn--] =
							psess->rgpfnNotify[dw][--psess->rgcfnNotify[dw]];
				SetupKernelNotifier(dw, psessSav);
			}
		} else {
			/* We need to empty all lists */
			while(++dw <= DM_NOTIFYMAX) {
				psess->rgcfnNotify[dw] = 0;
				SetupKernelNotifier(dw, psessSav);
			}
		}
		hr = XBDM_NOERR;
	} else if(dw <= DM_NOTIFYMAX && pfnHandler) {
		int ifn;

		for(ifn = psess->rgcfnNotify[dw]; ifn--; )
			if(psess->rgpfnNotify[dw][ifn] == pfnHandler)
				break;
		if(ifn < 0) {
			if(psess->rgcfnNotify[dw] == MAX_NOTIFY) {
				hr = E_OUTOFMEMORY;
				pfnHandler = NULL;
			} else {
				psess->rgpfnNotify[dw][psess->rgcfnNotify[dw]++] = pfnHandler;
				SetupKernelNotifier(dw, psessSav);
			}
		} else
			pfnHandler = NULL;
		if(dw == DM_EXEC && pfnHandler)
			/* This is a special case and every new handler has to be
			 * immediately informed of the current state, if
			 * available */
			(*pfnHandler)(dw, dwExecState);
		hr = XBDM_NOERR;
	} else
		hr = E_INVALIDARG;
	psessFirst = psessSav;
	LeaveSessionList();
	KeLowerIrql(irqlSav);
	return hr;
}

HRESULT DmRegisterNotificationProcessor(PDMN_SESSION psess, LPCSTR sz,
	PDM_EXT_NOTIFY_FUNCTION pfn)
{
    int ich;
	int ienh;
	ENH *penh;
	HRESULT hr;
	PDMN_SESSION psessSav;
	KIRQL irqlSav;

	if (!psess || psess->dwSig != 'xnot')
		return E_INVALIDARG;
    if(pfn && !sz)
        return E_INVALIDARG;

	irqlSav = KeGetCurrentIrql();
	ASSERT(irqlSav == PASSIVE_LEVEL);
	EnterSessionList(TRUE);
	/* Temporarily unhook the notification list */
	psessSav = psessFirst;
	psessFirst = NULL;
    if(!pfn) {
        /* We're unregistering.  If we have a string, then only unhook those
         * handlers that match the string */
        if(sz)
            for(ich = 0; sz[ich]; ++ich);
        for(ienh = 0; ienh < MAX_ENH; ++ienh) {
            if(psess->rgpenh[ienh]) {
                if(sz && !FEqualRgch(psess->rgpenh[ienh]->szExtName, sz, ich))
                    continue;
                DmFreePool(psess->rgpenh[ienh]);
                psess->rgpenh[ienh] = NULL;
            }
        }
        penh = NULL;
		hr = XBDM_NOERR;
    } else {
	    /* Let's find somewhere to put it */
	    penh = DmAllocatePoolWithTag(sizeof *penh, 'hcmd');
	    if(!penh)
		    hr = E_OUTOFMEMORY;
	    else {
		    for(ienh = 0; ienh < MAX_ENH; ++ienh)
			    if(!psess->rgpenh[ienh])
				    break;
		    if(ienh < MAX_ENH) {
			    int ich;

			    for(ich = 0; sz[ich] && ich < sizeof penh->szExtName - 1; ++ich)
				    penh->szExtName[ich] = sz[ich];
			    if(sz[ich])
				    hr = E_INVALIDARG;
			    else {
				    penh->szExtName[ich] = 0;
				    penh->pfnHandler = pfn;
				    psess->rgpenh[ienh] = penh;
				    penh = NULL;
				    hr = XBDM_NOERR;
			    }
		    } else
			    hr = E_OUTOFMEMORY;
	    }
    }
	psessFirst = psessSav;
	if(penh)
		DmFreePool(penh);
	LeaveSessionList();
	KeLowerIrql(irqlSav);
	return hr;
}

DMHRAPI DmSendNotificationString(LPCSTR sz)
{
	int ich;
	int ienh;
	int isock;
	PDMN_SESSION psess;

	if (!sz)
		return E_INVALIDARG;

	/* Make sure this is directed at somebody */
	for(ich = 0; sz[ich] != '!'; ++ich)
		if(sz[ich] == ' ' || sz[ich] < ' ')
			return E_INVALIDARG;

	/* Send this to anybody who's asked for it */
	EnterSessionList(FALSE);
	for(psess = psessFirst; psess; psess = psess->psessNext) {
		if(!(psess->dwFlags & DMSESS_DEAD)) {
			for(ienh = 0; ienh < MAX_ENH; ++ienh)
				if(psess->rgpenh[ienh] && FEqualRgch(sz,
						psess->rgpenh[ienh]->szExtName, ich))
					psess->rgpenh[ienh]->pfnHandler(sz);
		}
	}
	LeaveSessionList();

	/* Now send this over the network */
	if(KeGetCurrentIrql() == PASSIVE_LEVEL) {
		KeEnterCriticalRegion();
		RtlEnterCriticalSection(&csNotify);
		for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
			if(rgsockNotify[isock] != INVALID_SOCKET)
				FPrintNotifySock(isock, sz);
		RtlLeaveCriticalSection(&csNotify);
		KeLeaveCriticalRegion();
	}
	return XBDM_NOERR;
}

void ClockInt(PKTRAP_FRAME ptf)
{
	/* Send this to local components only */
	NotifyLocalComponents(DM_CLOCKINT, 0);
}

#if 0
void ProfInt(PKTRAP_FRAME ptf)
{
	DMN_PROFINT dmpi;

	/* Send this to local components only, and only if we think we're
	 * profiling */
	if(g_dmi.Profiling) {
		dmpi.SegCs = (USHORT)ptf->SegCs;
		dmpi.EFlags = ptf->EFlags;
		dmpi.Eip = ptf->Eip;
		NotifyLocalComponents(DM_PROFINT, (DWORD)&dmpi);
	}
}
#endif

void __fastcall CtxSwap(DWORD tidOld, DWORD tidNew)
{
	DMN_THREADSWITCH dmts;

	/* Send this to local components only */
	dmts.OldThreadId = tidOld;
	dmts.NewThreadId = tidNew;
	NotifyLocalComponents(DM_THREADSWITCH, (DWORD)&dmts);
}

void PrepareToReboot(void)
{
    int isock;
    SOCKET s;

    /* Tell everybody we're rebooting */
	NotifyComponents(DM_EXEC, DMN_EXEC_REBOOT);

    /* Stop the command server and all XAPI threads */
    StopServ();
    DoStopGo(FALSE);

    /* Close all notification sockets */
    for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock) {
        s = InterlockedExchange(&rgsockNotify[isock], INVALID_SOCKET);
        if(s != INVALID_SOCKET)
            closesocket(s);
    }

    /* Clean up our state */
	WriteIniFile();
	RemoveAllBreakpoints();

    /* Wait for pending I/O to complete */
    Sleep(200);
}

void ReportDoubleFault(void)
{
	DMN_EXCEPTION dme;
	DMTD *pdmtd = DmGetCurrentDmtd();
	EXCEPTION_RECORD er;

	/* We need to advertise the context we extracted.  But if we already have
	 * a saved context, then we probably overflowed the stack while preparing
	 * to notify of some other exception.  We'll turn it into a stack overflow
	 * but we'll use the old context */
	if(!pdmtd->ExceptionContext)
		pdmtd->ExceptionContext = &ctxDF;

	/* We're going to report this as stack overflow */
	dme.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
	dme.Code = STATUS_STACK_OVERFLOW;
	dme.Address = (PVOID)pdmtd->ExceptionContext->Eip;
	dme.Flags = DM_EXCEPT_NONCONTINUABLE;

	/* We need to make sure we have an exception record around as well */
	RtlZeroMemory(&er, sizeof er);
	er.ExceptionCode = dme.Code;
	er.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
	er.ExceptionAddress = dme.Address;
	pdmtd->ExceptionRecord = &er;

	/* We don't want to be able to continue this thread, but we don't want to
	 * upset anybody who tries, so we'll just continually report this
	 * exception */
	for(;;) {
		PrepareToStop();
		NotifyComponents(DM_EXCEPTION | DM_STOPTHREAD, (DWORD)&dme);
		FStopAtException();
	}
}

BOOLEAN CanDebugDF(KTSS *ptss)
{
	/* We've only gotten here if we actually are prepared to handle the
	 * double fault, so we should be able copy out the context and set up
	 * the handler.  But if we're supposed to let kd handle reporting, then we
	 * just give it up */
	if(fAllowKd && !*KdDebuggerNotPresent)
		return FALSE;

	/* We've got to figure out whether we'll be able to do anything with this
	 * even if we can report */
	if(KeGetCurrentIrql() != PASSIVE_LEVEL || DmGetCurrentDmtd() == NULL)
		return FALSE;

	/* For now, no FP registers */
	ctxDF.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
#define GR(reg) (ctxDF.reg = ptss->reg)
	GR(Eip);
	GR(Esp);
	GR(Ebp);
	GR(EFlags);
	ctxDF.SegCs = ptss->Cs;
	ctxDF.SegSs = ptss->Ss;

	GR(Eax);
	GR(Ebx);
	GR(Ecx);
	GR(Edx);
	GR(Esi);
	GR(Edi);
#undef GR

	/* Now we set up to actually report the double fault */
	ptss->Esp = (ULONG)(rgbDFStack + (sizeof(rgbDFStack) - 1));
	ptss->Ebp = 0;
	ptss->Eip = (ULONG)ReportDoubleFault;
	return TRUE;
}

ULONG TellDebugger(ULONG ulCode, PVOID pvData)
{
	switch(ulCode)
	{
	case DMTELL_ENTERDEBUGGER:
		EnterDebugger();
		break;
	case DMTELL_REBOOT:
		PrepareToReboot();
		break;
	case DMTELL_MAPDRIVE:
#define pdr ((PDMDRIVE)pvData)
		MapDebugDrive(pdr->Drive, pdr->Path);
		break;
#undef pdr
	case DMTELL_FRAMECOUNT:
		g_dmgd.FrameCounter = pvData;
		break;
	case DMTELL_GPUPERF:
		g_dmgd.PerfCounters = pvData;
		return SUCCEEDED(DmEnableGPUCounter(pvData != NULL));
	case DMTELL_REGISTERPERFCOUNTER:
		{
			PDMREGISTERPERFCOUNTERPARAMBLOCK pB = (PDMREGISTERPERFCOUNTERPARAMBLOCK) pvData;
			return SUCCEEDED(DmRegisterPerformanceCounter(pB->szName, pB->dwType, pB->pvArg));
		}
	case DMTELL_UNREGISTERPERFCOUNTER:
		{
			return SUCCEEDED(DmUnregisterPerformanceCounter((LPCCH) pvData));
		}
    case DMTELL_SETDBGIP:
        g_ulDbgIP = (ULONG)pvData;
        // flush the data
        WriteIniFile();
        // fall through
    case DMTELL_GETDBGIP:
        return g_ulDbgIP;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmfile.c ===
/*
 *
 * dmfile.c
 *
 * Utility functions for dealing with filenames and 
 * files.
 *
 */

#include "dmp.h"

//-----------------------------------------------------------------------------------------------------
// Table for converting drive names to object manager names
//-----------------------------------------------------------------------------------------------------
const OCHAR EDRIVE_OBNAME[]=OTEXT("\\Device\\Harddisk0\\Partition1\\Devkit");
const OCHAR SDRIVE_OBNAME[]=OTEXT("\\Device\\Harddisk0\\Partition1\\TDATA");
const OCHAR VDRIVE_OBNAME[]=OTEXT("\\Device\\Harddisk0\\Partition1\\UDATA");
const OCHAR CDROM_OBNAME[]=OTEXT("\\Device\\Cdrom0");
const OCHAR CDDEVKIT_OBNAME[]=OTEXT("\\Device\\Cdrom0\\Devkit");
const OCHAR ILLEGAL_OBNAME[]=OTEXT("\\Badpath");
const OCHAR SYMLINK_OBNAME[]=OTEXT("\\??\\0:");

typedef struct _DRIVENAME_CONVERSION_ENTRY
{
    PCOSTR  ObjectName;
    ULONG   ObjectNameLength; //Without a terminating NULL
    OCHAR	DriveName;
    BOOL    Visible;
} DRIVENAME_TABLE_ENTRY, *PDRIVENAME_TABLE_ENTRY;

DRIVENAME_TABLE_ENTRY DriveNameConversionTable[] = 
{
    { EDRIVE_OBNAME, sizeof(EDRIVE_OBNAME)/sizeof(OCHAR)-1, 'E', 1 },
    { SDRIVE_OBNAME, sizeof(SDRIVE_OBNAME)/sizeof(OCHAR)-1, 'S', 1 },
    { VDRIVE_OBNAME, sizeof(VDRIVE_OBNAME)/sizeof(OCHAR)-1, 'V', 1 },
	{ CDROM_OBNAME, sizeof(CDROM_OBNAME)/sizeof(OCHAR)-1, 'A', 1, },
	// block the C and Y drives if they're mapped by the shell
    { ILLEGAL_OBNAME, sizeof(ILLEGAL_OBNAME)/sizeof(OCHAR)-1, 'C', 0 },
    { ILLEGAL_OBNAME, sizeof(ILLEGAL_OBNAME)/sizeof(OCHAR)-1, 'Y', 0 },
    // include a drive for the use of recovery
	{ CDDEVKIT_OBNAME, sizeof(CDDEVKIT_OBNAME)/sizeof(OCHAR)-1, 1,  },
    // and space for more
    { NULL, 0, 0, 0, },
    { NULL, 0, 0, 0, },
    { NULL, 0, 0, 0, },
    { NULL, 0, 0, 0, },
    { NULL, 0, 0, 0, },
};

void MapDebugDrive(OCHAR chDrive, PCOSTR szPrefix)
{
	PDRIVENAME_TABLE_ENTRY pdte;

	for(pdte = DriveNameConversionTable; pdte->ObjectName; ++pdte)
		if(pdte->DriveName == chDrive)
			break;

	/* Only fill it in if we're prior to the last entry */
	if((BYTE *)(pdte + 1) < (BYTE *)DriveNameConversionTable +
		sizeof DriveNameConversionTable)
	{
		pdte->ObjectName = szPrefix;
		if(szPrefix) {
			pdte->ObjectNameLength = ocslen(szPrefix);
			pdte->DriveName = chDrive;
            pdte->Visible = TRUE;
		} else if(pdte[1].ObjectName) {
			/* We've unmapped a drive in the middle of the table */
			PDRIVENAME_TABLE_ENTRY pdteLast;
			for(pdteLast = pdte; pdteLast[1].ObjectName; ++pdteLast);
			*pdte = *pdteLast;
			pdteLast->ObjectName = NULL;
		}
	}
}

VOID
FObNameToFileName(
    IN POBJECT_STRING objectName,
    OUT LPSTR pszFileName,
    int cchMax
    )
/*++
    Routine Description:
        Uses the conversion table to subsitute the object manager
        path with a common drive letter exposed by the debugger.
        
        This routine also converts OBJECT_STRING (OCHAR) to CHAR.
--*/
{
    PCOSTR pocSource;
    CHAR  *pcDestination = pszFileName;
    ULONG ulCount;
    PDRIVENAME_TABLE_ENTRY pDriveNameEntry = DriveNameConversionTable;

    cchMax--;  //save room for the NULL termination
    while(pDriveNameEntry->ObjectName)
    {
        if(objectName->Length >= pDriveNameEntry->ObjectNameLength * sizeof(OCHAR)) 
        {
            if(0 == _ocsnicmp(pDriveNameEntry->ObjectName, objectName->Buffer,
				pDriveNameEntry->ObjectNameLength))
            {
			   *pcDestination++ = (char)pDriveNameEntry->DriveName;
			   *pcDestination++ = ':';
			   cchMax -= 2;
               ulCount = objectName->Length-pDriveNameEntry->ObjectNameLength;
               pocSource = objectName->Buffer+pDriveNameEntry->ObjectNameLength;
               while(ulCount-- && (cchMax-- > 0)) *pcDestination++ = (CHAR)*pocSource++;
               *pcDestination = 0; //NULL terminate
               return;
            }
        }
        pDriveNameEntry++;
    }
    //
    //  If we haven't converted it, just copy it.
    //
    ulCount = objectName->Length;
    pocSource = objectName->Buffer;
    while(ulCount-- && (cchMax-- > 0)) *pcDestination++ = (CHAR)*pocSource++;
    *pcDestination = 0; //NULL terminate
    return;
}

BOOL FFileNameToObName(LPCSTR sz, OCHAR *osz, int cchMax)
{
	int ich;
	OCHAR chDrive;
	PCOSTR oszPrefix;
	PDRIVENAME_TABLE_ENTRY pdte;

    if(!sz)
        return FALSE;

	/* The file name must start with drive letter, then ':' then '\' for us
	 * to consider it valid.  If we have a filename of the form "XC:\...",
	 * we'll accept that as well */
	if(sz[0] == 'x' || sz[0] == 'X' && sz[1] != ':')
		++sz;
	if(sz[1] != ':' || sz[2] != '\\')
		return FALSE;
	chDrive = sz[0];
	if(chDrive >= 'a' && chDrive <= 'z')
		chDrive -= 'a' - 'A';
	/* Look in the table to find a map for this drive letter */
	oszPrefix = NULL;
	for(pdte = DriveNameConversionTable; pdte->ObjectName; ++pdte)
		if(chDrive == pdte->DriveName) {
			oszPrefix = pdte->ObjectName;
			chDrive = 0;
			break;
		}
	
	/* If we didn't find a match, we use DosDevices, as long as it's a valid
     * drive */
    if(!oszPrefix) {
	    if(chDrive < 'A' || chDrive > 'Z')
		    return FALSE;
		oszPrefix = SYMLINK_OBNAME;
    }

	for(ich = 0; oszPrefix[ich]; ++ich)
		osz[ich] = oszPrefix[ich];
	if(chDrive)
		osz[ich - 2] = chDrive;
	sz += 2;
	while(*sz && ich < cchMax)
		osz[ich++] = *sz++;
	osz[ich] = 0;
	return TRUE;
}


NTSTATUS
FCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPCSTR FileName,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )
/*++
    Routine Description:
        Wraps CreateFile to use ANSI names passed over the debugger protocol.

        1) Do any name conversion to the Object Manager Name.
        2) Initialize OBJECT_ATTRIBUTES structure.
        3) Call NtCreateFile
--*/
{
    OBJECT_STRING objectName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    OCHAR oszObName[MAX_OBJ_PATH+1];
    NTSTATUS status;

    if(!FFileNameToObName(FileName, oszObName, sizeof(oszObName)/sizeof(OCHAR)))
    {
        status = STATUS_NO_SUCH_FILE;
    } else
    {
	    RtlInitObjectString(&objectName, oszObName);
        InitializeObjectAttributes(
            &objectAttributes,
            &objectName,
            OBJ_CASE_INSENSITIVE,
            NULL,
		    NULL
            );
        status = NtCreateFile(
                    FileHandle,
                    DesiredAccess,
                    &objectAttributes,
                    &ioStatusBlock,
                    AllocationSize,
                    FileAttributes,
                    ShareAccess,
                    CreateDisposition,
                    CreateOptions);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmp.h ===
#ifndef _DMP_INC
#define _DMP_INC
#define WINSOCK_API_LINKAGE
#define _KERNEL32_
#define _USER32_

#define _XBDM_
#include "ntos.h"
#include "ldr.h"
#include "mi.h"
#include <xbeimage.h>
#include <xprofp.h>
#include "dm.h"
#include <ntrtl.h>
#define _XAPI_
#include <nturtl.h>
#undef _XAPI_
#include <windows.h>
#include <winsockx.h>
#include <stdio.h>
#include <xbdm.h>
#include <xbdmp.h>
#include "dmserv.h"
#include "dmnotify.h"
#include "dmcount.h"

#define MAX_OBJ_PATH 320

/* Route our pool calls into our own pool manager */
#undef ExAllocatePool
#undef ExAllocatePoolWithTag
#undef ExFreePool
#define ExAllocatePool(n, cb) DmAllocatePool(cb)
#define ExAllocatePoolWithTag(n, cb, tag) DmAllocatePoolWithTag(cb, tag)
#define ExFreePool DmFreePool

/* ini file */
typedef struct _INF {
    HANDLE h;
    BYTE *pbBuf;
    int cbBuf;
    int cbUsed;
} INF;

void WriteIniData(INF *, const BYTE *pb, int cb);
void WriteIniSz(INF *, LPCSTR);
void WriteIniNotifiers(INF *);
void WriteIniSecurity(INF *);
void WriteIniFile(void);
BOOL FStartDebugService(void);
BOOL FInitThreadDebugData(PETHREAD);
ULONG CallOnStack(PVOID, PVOID, PVOID);
void HandleCommand(int, LPCSTR);
void InitNotifications();
BOOL FNotifySock(SOCKET s);
BOOL FConvertToNotifySock(SOCKET);
BOOL PrintSockLine(SOCKET s, LPCSTR sz);
BOOL ReadSockLine(SOCKET s, char *sz, int cch);
void FillSzFromWz(char *sz, int cch, WCHAR *wz, int cwch);
PLDR_DATA_TABLE_ENTRY PldteGetModule(LPCSTR sz, BOOL fMatchExt);
void InitPool(void);
void DmExFreePool(PVOID);
void InitBreakpoints(void);
BOOL FAddBreakpoint(BYTE *);
BOOL FRemoveBreakpoint(BYTE *);
void DisableBreakpoint(PVOID);
void RemoveAllBreakpoints(void);
void EnableBreakpointsInRange(PBYTE, PBYTE, BOOL);
void DisableBreakpointsInRange(PBYTE, PBYTE);
BOOL FIsBreakpoint(BYTE *);
BOOL FGetNextBreakpoint(BYTE **);
BOOL FGetMemory(BYTE *pbAddr, BYTE *pbInstr);
BOOL FSetMemory(BYTE *pbAddr, BYTE bInstr);
DWORD NotifyComponents(DWORD, DWORD);
BOOL FGetNotifySz(DWORD dwNotification, DWORD dwParam, LPSTR sz);
void GetModLoadSz(LPSTR, PDMN_MODLOAD);
void GetSectLoadSz(LPSTR, PDMN_SECTIONLOAD);
void DmslFromXsh(PXBEIMAGE_SECTION, PDMN_SECTIONLOAD);
DWORD DwXmhFlags(PDMN_MODLOAD);
void DoStopGo(BOOL);
void DoContinue(PETHREAD, BOOL);
void PrepareToStop(void);
void PrepareToReboot(void);
void DisableAPIC(PHAL_SHUTDOWN_REGISTRATION);
void SetupHalt(DWORD);
BOOL FStopAtException(void);
void ResumeAfterBreakpoint(PCONTEXT);
void ExceptionsToKd(void);
void FixupBistroImage(void);
void SyncHwbps(void);
void SetDreg(int ireg, PVOID pv, BYTE bRw, BYTE bLen, BOOLEAN fEnable);
ULONG __fastcall DwExchangeDr6(ULONG);
void QueueDfn(PDFN);
void ProcessDfns(void);
BOOL FBreakTrace(PCONTEXT);
BOOL FMatchDataBreak(ULONG, PDMN_DATABREAK);
void DmpThreadStartup(PKSTART_ROUTINE, PVOID);
void SetupFuncCall(void);
BOOL FResolveImport(PVOID pvBase, PIMAGE_EXPORT_DIRECTORY ped, ULONG cbExports,
    LPCSTR szName, PVOID *ppvRet);
void CallDxtEntry(PVOID, BOOL *);
BOOL FFixupXbdm(PVOID pvXbdmBase, PDMINIT);
void StopServ(void);
void InitServ(void);
void InitLoader(void);
void InitCounters(void);
void InitSecurity(void);
void EnsurePersistentSockets(void);
BOOL FNotifyAt(ULONG, USHORT, DWORD, BOOL);
BOOL FNotifyAtCmd(SOCKET, LPCSTR, BOOL);
ULONG UlAddrFromSz(LPCSTR);
HRESULT HrAddUserCommand(LPCSTR, LPSTR, DWORD, PDM_CMDCONT);
DWORD DmplFromSz(LPCSTR);
void FillAccessPrivSz(LPSTR, DWORD);
void FillUserInfoSz(LPSTR, LPCSTR szName, DWORD dwPrivileges,
    PULARGE_INTEGER pluPasswd);
DWORD DmplAuthenticateUser(LPCSTR szUserName, PULARGE_INTEGER pluNonce,
    PULARGE_INTEGER pluResponse, BOOL *pfKeyXchg);
void RemoveAllUsers(void);
BOOL FFileNameToObName(LPCSTR sz, OCHAR *osz, int cchMax);
BOOL FTitleExists(LPCSTR szDir, LPCSTR szTitle, LPCSTR szCmdLine, BOOL fMapIt);
VOID FObNameToFileName(IN POBJECT_STRING objectName, OUT LPSTR pszFileName, int cchMax);
VOID MapDebugDrive(OCHAR, PCOSTR);
HRESULT HrFromStatus(NTSTATUS st, HRESULT hrDefault);
NTSTATUS
FCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPCSTR FileName,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    );

// useful line handling stuff
const char *PchGetParam(LPCSTR szLine, LPCSTR szKey, BOOL fNeedValue);
BOOL FGetSzParam(LPCSTR szLine, LPCSTR szKey, LPSTR szBuf, int cchBuf);
BOOL FGetDwParam(LPCSTR szLine, LPCSTR szKey, DWORD *pdw);
BOOL FGetQwordParam(LPCSTR szLine, LPCSTR szKey, PULARGE_INTEGER plu);
BOOL FGetNamedDwParam(LPCSTR szLine, LPCSTR szKey, DWORD *pdw, LPSTR szResp);
int CchOfWord(LPCSTR sz);
BOOL FEqualRgch(LPCSTR, LPCSTR, int);

// connection security
ULONG DmplOfConnection(PDM_CMDCONT pdmcc);
#define FConnectionPermission(pdmcc, dmpl) \
    ((DmplOfConnection(pdmcc) & (dmpl)) != 0)

// crypt
void XBCCross(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluData,
    PULARGE_INTEGER pluResult);
void XBCHashData(PULARGE_INTEGER pluHash, const BYTE *pb, ULONG cb);

void RewindDmws(PDM_WALK_MODSECT);
unsigned long Crc32(unsigned long InitialCrc, const void *Buffer, unsigned long Bytes);
HRESULT FlashKernelImage(PVOID ImageBuffer, SIZE_T ImageSize, LPSTR szResp,
    DWORD cchResp, BOOL IgnoreVersionChecking);

NTSTATUS DmCapControl(ULONG Action, ULONG Param);
HRESULT HrUpdateSystemFile(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);

extern PKPROCESS pprocSystem;
extern BOOL fAllowKd;
extern DWORD g_grbitStopOn;
extern DWORD dwExecState;
extern DMINIT g_dmi;
extern DMGD g_dmgd;
extern DMXAPI g_dmxapi;
extern char rgchTitleDir[MAX_OBJ_PATH+1];
extern char rgchTitleName[64];
extern char rgchDbgName[256];
extern BOOL fBootWait;
extern char *pszCmdLine;
extern KEVENT kevtServ;
extern PULONG g_pulFrameCount;
extern BOOL g_fDebugging;
extern ULONG g_ulDbgIP;
extern BOOL g_fLockLevel;
extern ULARGE_INTEGER g_luBoxId;
extern KEVENT kevtNull;
extern ULARGE_INTEGER g_luAdminPasswd;
extern BOOL g_fAdminPasswd;
extern XProfpGlobals* DmProfileData;

#endif // _DMP_INC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmmodule.c ===
/*
 *
 * dmmodule.c
 *
 * Get information about loaded modules and about memory
 *
 */

#include "dmp.h"

/* We can't allow the Ex/Dm pool defines here */
#undef ExAllocatePool
#undef ExAllocatePoolWithTag
#undef ExFreePool

NTSTATUS
StLoadImage(
	PCOSTR oszName,
	PCOSTR oszFor,
	PLDR_DATA_TABLE_ENTRY *ppldte
	);

void
UnloadReferencedModules(
	PLDR_DATA_TABLE_ENTRY pldte
	);

RTL_CRITICAL_SECTION csLoader;

void InitLoader(void)
{
	RtlInitializeCriticalSection(&csLoader);
}

struct {
	PVOID pfnImport;
	PVOID pfnSub;
} rgfsub[] = {
	{ NULL, DmAllocatePool },
	{ NULL, DmAllocatePoolWithTag },
	{ NULL, DmFreePool },
};

/* In certain cases, we may want to call the functions we've overridden.  Here
 * are the stubs */
void DmExFreePool(PVOID p)
{
	void (*pfnExFreePool)(PVOID) = rgfsub[2].pfnImport;
	pfnExFreePool(p);
}

PLDR_DATA_TABLE_ENTRY PldteGetModule(LPCSTR sz, BOOL fMatchExt)
{
	PLDR_DATA_TABLE_ENTRY pldte = NULL;
	PLIST_ENTRY ple;
	WCHAR *wz;
	int cch;
	const char *pch;

	ple = g_dmi.LoadedModuleList->Flink;
	while(ple != g_dmi.LoadedModuleList) {
		pldte = CONTAINING_RECORD(ple, LDR_DATA_TABLE_ENTRY,
			InLoadOrderLinks);
		ple = ple->Flink;
		wz = pldte->BaseDllName.Buffer;
		cch = pldte->BaseDllName.Length >> 1;
		pch = sz;
		while(cch) {
			char ch1, ch2;
			ch1 = (char )*wz++;
			if(ch1 >= 'a' && ch1 <= 'z')
				ch1 -= 'a' - 'A';
			ch2 = *pch++;
			if(ch2 >= 'a' && ch2 <= 'z')
				ch2 -= 'a' - 'A';
			if(ch1 != ch2)
				break;
			--cch;
		}
		if(cch == 0) {
			if(*pch == 0)
				/* We've matched the whole name */
				break;
		} else if(!fMatchExt && pch[-1] == 0 && wz[-1] == '.')
				/* We've matched the basename */
				break;
		pldte = NULL;
	}
	return pldte;
}

HRESULT DmGetMemory(LPCVOID pb, DWORD cb, LPVOID lpbBuf, LPDWORD pcbRet)
{
	DWORD cbRet;
	BOOL fIsPageValid = TRUE;
	DWORD dwPageBase = (DWORD) pb + 0x1000;

	if (!lpbBuf)
		return E_INVALIDARG;

	for(cbRet = 0; cb-- && fIsPageValid; ++(DWORD)pb) {
		if((dwPageBase ^ (DWORD)pb) & 0xfffff000) {
			dwPageBase = (DWORD)pb & 0xfffff000;
			fIsPageValid = MmIsAddressValid((BYTE *)pb);
		}
		if(fIsPageValid)
			fIsPageValid = FGetMemory((BYTE *)pb, lpbBuf);
		if(fIsPageValid)
			++cbRet, ++(BYTE *)lpbBuf;
	}

	if(pcbRet)
		*pcbRet = cbRet;

	return !cb || pcbRet ? XBDM_NOERR : XBDM_MEMUNMAPPED;
}

HRESULT DmSetMemory(LPVOID pb, DWORD cb, LPCVOID lpbBuf, LPDWORD pcbRet)
{
	DWORD cbRet;
	BOOL fIsPageValid = TRUE;
	DWORD dwPageBase = (DWORD) pb + 0x1000;

	if (!lpbBuf)
		return E_INVALIDARG;

	for(cbRet = 0; cb-- && fIsPageValid; ++(DWORD)pb) {
		if((dwPageBase ^ (DWORD)pb) & 0xfffff000) {
			dwPageBase = (DWORD)pb & 0xfffff000;
			fIsPageValid = MmIsAddressValid(pb);
		}
		if(fIsPageValid)
			fIsPageValid = FSetMemory(pb, *(BYTE *)lpbBuf);
		if(fIsPageValid)
			++cbRet, ++(BYTE *)lpbBuf;
	}

	if(pcbRet)
		*pcbRet = cbRet;

	return !cb || pcbRet ? XBDM_NOERR : XBDM_MEMUNMAPPED;
}

void FixupBistroImage(void)
{
    /* VTune Call Graph needs to be able to modify the code pages in the image,
     * so we need to detect whether we're running an instrumented image.  We
     * look for a section marked .bistro.  If we see one, we go through all of
     * the section flags and mark them as writable */
    PXBEIMAGE_SECTION pxsh;
    int cxsh;

    cxsh = XeImageHeader()->NumberOfSections;
    pxsh = XeImageHeader()->SectionHeaders;

    for(; cxsh--; ++pxsh) {
        if(0 == memcmp(pxsh->SectionName, ".bistro", 8)) {
            /* We found it */
            cxsh = XeImageHeader()->NumberOfSections;
            pxsh = XeImageHeader()->SectionHeaders;
            for(; cxsh--; ++pxsh)
                pxsh->SectionFlags |= XBEIMAGE_SECTION_WRITEABLE;
            return;
        }
    }
}

DWORD DwXmhFlags(PDMN_MODLOAD pdmml)
{
	DWORD dwFlags = DMN_MODFLAG_XBE;
    PIMAGE_DOS_HEADER pdosh;
    PIMAGE_NT_HEADERS pnth;

	if (XeImageHeader()->TlsDirectory)
		dwFlags |= DMN_MODFLAG_TLS;

    /* See if we appear to have PE headers here */
    do {
        pdosh = pdmml->BaseAddress;
        if(pdosh->e_magic != IMAGE_DOS_SIGNATURE)
            break;
        pnth = (PIMAGE_NT_HEADERS)((ULONG)pdosh + pdosh->e_lfanew);
        if(pnth->Signature != IMAGE_NT_SIGNATURE)
            break;
        if(pnth->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
    		dwFlags |= DMN_MODFLAG_PEHEADER;
    } while (0);

	return dwFlags;
}

struct _DM_WALK_MODULES {
	PLIST_ENTRY ple;
};

HRESULT DmWalkLoadedModules(PDM_WALK_MODULES *ppdmwm, DMN_MODLOAD *pdmml)
{
	PDM_WALK_MODULES pdmwm;
	PLDR_DATA_TABLE_ENTRY pldte;
	PIMAGE_NT_HEADERS pnth;

	if(!ppdmwm || !pdmml)
		return E_INVALIDARG;

	pdmwm = *ppdmwm;
	if(!pdmwm) {

		/* Set up our list */
		pdmwm = DmAllocatePoolWithTag(sizeof *pdmwm, 'mwmd');
		if(!pdmwm)
			return E_OUTOFMEMORY;
		pdmwm->ple = g_dmi.LoadedModuleList->Flink;
		*ppdmwm = pdmwm;
	}

	for(;;) {

		if(pdmwm->ple == g_dmi.LoadedModuleList)
			break;

		pldte = CONTAINING_RECORD(pdmwm->ple, LDR_DATA_TABLE_ENTRY,
			InLoadOrderLinks);
		pdmwm->ple = pdmwm->ple->Flink;
		FillSzFromWz(pdmml->Name, sizeof pdmml->Name,
			pldte->BaseDllName.Buffer, pldte->BaseDllName.Length >> 1);
		pdmml->BaseAddress = pldte->DllBase;
		if(!(pldte->Flags & LDRP_ENTRY_XE_IMAGE)) {
			pdmml->Size = pldte->SizeOfImage;
			pnth = RtlImageNtHeader(pldte->DllBase);
			if(pnth) {
				pdmml->CheckSum = (ULONG)pnth->OptionalHeader.CheckSum;
				pdmml->TimeStamp = (ULONG)pnth->FileHeader.TimeDateStamp;
			} else {
				pdmml->CheckSum = 0;
				pdmml->TimeStamp = 0;
			}
			pdmml->Flags = 0;
			return XBDM_NOERR;
		} else {
			pdmml->Size = XeImageHeader()->NtSizeOfImage;
			pdmml->TimeStamp = XeImageHeader()->NtTimeDateStamp;
			pdmml->CheckSum = XeImageHeader()->NtCheckSum;
			pdmml->Flags = DwXmhFlags(pdmml);
			return XBDM_NOERR;
		}
	}

	/* We didn't find anything to return, so say end of list */
	return XBDM_ENDOFLIST;
}

HRESULT DmCloseLoadedModules(PDM_WALK_MODULES pdmwm)
{
	if (!pdmwm)
		DmFreePool(pdmwm);
	return XBDM_NOERR;
}

struct _DM_WALK_MODSECT {
	PLDR_DATA_TABLE_ENTRY pldte;
	union {
		struct {
			/* XE module */
			PXBEIMAGE_SECTION pxsh;
			int cxsh;
			int ixsh;
		};
		struct {
			/* kernel module */
			int ish;
			PIMAGE_NT_HEADERS pnth;
			PIMAGE_SECTION_HEADER psh;
			int csh;
		};
	};
};

void RewindDmws(PDM_WALK_MODSECT pdmws)
{
	if(pdmws->pldte->Flags & LDRP_ENTRY_XE_IMAGE) {
		pdmws->cxsh = XeImageHeader()->NumberOfSections;
		pdmws->pxsh = XeImageHeader()->SectionHeaders;
		pdmws->ixsh = 0;
	} else {
		pdmws->pnth = RtlImageNtHeader(pdmws->pldte->DllBase);
		if(pdmws->pnth) {
			pdmws->psh = IMAGE_FIRST_SECTION(pdmws->pnth);
			pdmws->csh = pdmws->pnth->FileHeader.NumberOfSections;
			pdmws->ish = 0;
		}
	}
}

void DmslFromXsh(PXBEIMAGE_SECTION pxsh, PDMN_SECTIONLOAD pdmsl)
{
	strncpy(pdmsl->Name, pxsh->SectionName, MAX_PATH);
	pdmsl->Name[MAX_PATH-1] = 0;
	pdmsl->BaseAddress = (PVOID)pxsh->VirtualAddress;
	pdmsl->Size = pxsh->VirtualSize;
    pdmsl->Index = pxsh - XeImageHeader()->SectionHeaders;
	pdmsl->Flags = pxsh->SectionReferenceCount ? DMN_SECFLAG_LOADED : 0;
}

HRESULT DmWalkModuleSections(PDM_WALK_MODSECT *ppdmws, LPCSTR szModule,
	PDMN_SECTIONLOAD pdmsl)
{
	PDM_WALK_MODSECT pdmws;

	if (!ppdmws || !pdmsl)
		return E_INVALIDARG;

	pdmws = *ppdmws;
	if(!pdmws) {
		PLDR_DATA_TABLE_ENTRY pldte;

		if (!szModule)
			return E_INVALIDARG;

		/* First find the module */
		pldte = PldteGetModule(szModule, TRUE);
		if(!pldte)
			/* Never found a match */
			return XBDM_NOMODULE;

		/* Now we can set things up */
		pdmws = DmAllocatePoolWithTag(sizeof *pdmws, 'swmd');
		if(!pdmws)
			return E_OUTOFMEMORY;
		*ppdmws = pdmws;
		pdmws->pldte = pldte;
		RewindDmws(pdmws);
	}

	for(;;) {
		if(pdmws->pldte->Flags & LDRP_ENTRY_XE_IMAGE) {
			/* This is an XE section */
			PXBEIMAGE_SECTION pxsh;

			if(!pdmws->cxsh)
				/* Nothing left */
				break;

			pxsh = pdmws->pxsh++;
			--pdmws->cxsh;

			/* We want to report this section */
			DmslFromXsh(pxsh, pdmsl);
            ++pdmws->ixsh;
			return XBDM_NOERR;
		} else {
			/* Make sure we actually have headers */
			if(!pdmws->pnth)
				return XBDM_NOMODULE;
			if(pdmws->csh) {
				/* We want to report this section */
				strcpy(pdmsl->Name, pdmws->psh->Name);
				pdmsl->Name[8] = 0;
				pdmsl->BaseAddress = (PVOID)((PBYTE)pdmws->pldte->DllBase +
					pdmws->psh->PointerToRawData);
				pdmsl->Size = pdmws->psh->Misc.VirtualSize;
				pdmsl->Index = ++pdmws->ish;
				pdmsl->Flags = 0;
				++pdmws->psh;
				--pdmws->csh;
				return XBDM_NOERR;
			}
			break;
		}
	}
	return XBDM_ENDOFLIST;
}

HRESULT DmCloseModuleSections(PDM_WALK_MODSECT pdmws)
{
	if (pdmws)
		DmFreePool(pdmws);
	return XBDM_NOERR;
}

HRESULT DmGetModuleLongName(LPCSTR szShort, LPSTR szLong, LPDWORD pcchLong)
{
	PLDR_DATA_TABLE_ENTRY pldte;
	LPCSTR sz;
	DWORD cch;
	DWORD cchMax;

	if (!szShort || !szLong || !pcchLong)
		return E_INVALIDARG;

	/* First find the module */
	pldte = PldteGetModule(szShort, TRUE);

	if(!pldte)
		return XBDM_NOMODULE;

	/* No XE means no data */
	if(!(pldte->Flags & LDRP_ENTRY_XE_IMAGE))
		return E_FAIL;

	/* Look for the long name */
	sz = XeImageHeader()->DebugPathName;
	if(!sz)
		return E_FAIL;

	cchMax = *pcchLong - 1;
	for(cch = 0; *sz && cch < cchMax; ++cch)
		*szLong++ = *sz++;
	*szLong = 0;
	*pcchLong = cch;
	return XBDM_NOERR;
}

HRESULT DmGetXbeInfo(LPCSTR szName, PDM_XBE pxbe)
{
	NTSTATUS st;
	HANDLE h;
	IO_STATUS_BLOCK iosb;
	POBJECT_STRING objectName;
	XBEIMAGE_HEADER xh;
	PXBEIMAGE_HEADER pxh;
	HRESULT hr;

	if (!pxbe)
		return E_INVALIDARG;

	/* If we already have an XBE in memory, we'll use its information.
		report the name it came from */
	pxh = XeImageHeader();

	if(MmDbgReadCheck(pxh) && !(g_dmi.Flags & DMIFLAG_RUNSHELL))
	{
		//
		// Grab the image name out the	LDR_CURRENT_IMAGE structure.
		//
		objectName = XeImageFileName;
		FObNameToFileName(objectName, pxbe->LaunchPath, sizeof(pxbe->LaunchPath));
		pxbe->TimeStamp = pxh->TimeDateStamp;
		pxbe->CheckSum = 0;
		pxbe->StackSize = pxh->SizeOfStackCommit;
		return XBDM_NOERR;
	}

	st = FCreateFile(&h, GENERIC_READ | SYNCHRONIZE, szName, NULL, 0, 0,
		 FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);
	if(!NT_SUCCESS(st))
		return XBDM_NOSUCHFILE;
	/* Make sure we can read an XE header out of this thing */
	st = NtReadFile(h, NULL, NULL, NULL, &iosb, &xh, sizeof xh, NULL);
	if(NT_SUCCESS(st) && xh.Signature == XBEIMAGE_SIGNATURE) {
		int ich;
		for(ich = 0; *szName && ich < sizeof pxbe->LaunchPath - 1; ++ich)
			pxbe->LaunchPath[ich] = *szName++;
		pxbe->LaunchPath[ich] = 0;
		pxbe->TimeStamp = xh.TimeDateStamp;
		pxbe->CheckSum = 0;
		pxbe->StackSize = xh.SizeOfStackCommit;
		hr = XBDM_NOERR;
	} else
		hr = XBDM_NOSUCHFILE;
	NtClose(h);
	return hr;
}

BOOL FResolveImport(PVOID pvBase, PIMAGE_EXPORT_DIRECTORY ped, ULONG cbExports,
	LPCSTR szName, PVOID *ppvRet)
{
	ULONG *rgichNames;
	USHORT *rgwOrdinals;
	ULONG *rgpvFunctions;
	ULONG iMic, iMid, iMac;
	ULONG iSym;

	if(((ULONG)szName & 0xffff0000) == 0)
		/* ordinal */
		iSym = (ULONG)szName - ped->Base;
	else {
		rgichNames = (PVOID)((PBYTE)pvBase + ped->AddressOfNames);
		rgwOrdinals = (PVOID)((PBYTE)pvBase + ped->AddressOfNameOrdinals);

		//
		// Lookup the import name in the name table using a binary search.
		//

		iMic = 0;
		iMid = 0;
		iMac = ped->NumberOfNames;

		while (iMac > iMic) {
			int sgn;

			//
			// Compute the next probe index and compare the import name
			// with the export name entry.
			//

			iMid = (iMic + iMac) >> 1;
			sgn = strcmp(szName, (PCHAR)((PCHAR)pvBase + rgichNames[iMid]));

			if (sgn < 0) {
				iMac = iMid;

			} else if (sgn > 0) {
				iMic = iMid + 1;

			} else {
				break;
			}
		}

		//
		// If the iMac index is less than the iMic index, then a matching
		// table entry was not found. Otherwise, get the ordinal number
		// from the ordinal table.
		//

		if (iMac <= iMic)
			return FALSE;
		else
			iSym = rgwOrdinals[iMid];
	}

	if(iSym >= ped->NumberOfFunctions)
		return FALSE;

	rgpvFunctions = (PVOID)((PBYTE)pvBase + ped->AddressOfFunctions);
	*ppvRet = (PBYTE)pvBase + rgpvFunctions[iSym];

	if(*ppvRet > (PVOID)ped && *ppvRet < (PVOID)((PBYTE)ped + cbExports)) {
		/* This is a forwarder */
		int cchDll;
		PSTR szSym;
		char szDll[64];
		PLDR_DATA_TABLE_ENTRY pldteF;

		szSym = strchr(*ppvRet, '.');
		if(!szSym)
			return FALSE;
		cchDll = szSym++ - (PCHAR)*ppvRet;
		if(cchDll > sizeof szDll - 1)
			return FALSE;
		memcpy(szDll, *ppvRet, cchDll);
		szDll[cchDll] = 0;
		pldteF = PldteGetModule(szDll, FALSE);
		if(!pldteF)
			return FALSE;
		return DmGetProcAddress((HANDLE)pldteF, szSym, ppvRet);
	} else {
		/* Check to see whether we need to do import substitution on this
		 * guy */
		int ifsub = sizeof rgfsub / sizeof rgfsub[0];
		while(ifsub--) {
			if(*ppvRet == rgfsub[ifsub].pfnImport) {
				*ppvRet = rgfsub[ifsub].pfnSub;
				break;
			}
		}
	}

	return TRUE;
}

BOOL FResolveImageImports(PLDR_DATA_TABLE_ENTRY pldteImage, PCOSTR oszName,
	PLIST_ENTRY LoadedModuleList)
{
	PIMAGE_IMPORT_DESCRIPTOR pid;
	PIMAGE_EXPORT_DIRECTORY ped;
	ULONG cbImports;
	ULONG cbExports;
	PLDR_DATA_TABLE_ENTRY pldte;
	PIMAGE_THUNK_DATA pthILT;
	PIMAGE_THUNK_DATA pthIAT;
	PBYTE pbImageBase = pldteImage->DllBase;
	int ipldte;
	BOOL fLoadFailed = FALSE;

	/* Loop through all of the imports of this library and fix them up, loading
	 * the supporting libs as necessary */
	pid = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(pbImageBase,
		TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &cbImports);
	if(!pid)
		return FALSE;

	if(!LoadedModuleList)
		LoadedModuleList = g_dmi.LoadedModuleList;

	if(g_dmi.LoadedModuleList) {
		/* Build a list of imported libraries */
		PIMAGE_IMPORT_DESCRIPTOR pidT = pid;
		for(ipldte = 0; pidT->Name && pidT->FirstThunk; ++ipldte, ++pidT);
		pldteImage->LoadedImports = DmAllocatePoolWithTag((ipldte + 1) *
			sizeof(PVOID), 'TDmM');
		if(!pldteImage)
			return FALSE;
		RtlZeroMemory(pldteImage->LoadedImports, (ipldte + 1) * sizeof(PVOID));
		*(int *)pldteImage->LoadedImports = ipldte;
	} else
		/* This is not an unloadable module */
		pldteImage->LoadedImports = NULL;

	ipldte = 1;
	while(pid->Name && pid->FirstThunk) {
		/* Get the loader entry for this library */
		if(g_dmi.LoadedModuleList) {
			char *szName = pbImageBase + pid->Name;
			RtlEnterCriticalSection(&csLoader);
			/* See if this guy is already loaded */
			_asm {
				pushfd
				cli
			}
			pldte = PldteGetModule(szName, TRUE);
			if(pldte)
				++pldte->LoadCount;
			_asm popfd
			if(!pldte) {
				/* Not already loaded, so we need to load it */
				if(!NT_SUCCESS(StLoadImage(szName, oszName, &pldte)))
					pldte = NULL;
			}
			RtlLeaveCriticalSection(&csLoader);
		} else {
			/* We're relocating ourselves, so we need to look up the
			 * entry.  But we should safely assume that the first entry in
			 * the list is the kernel */
			pldte = CONTAINING_RECORD(LoadedModuleList->Flink,
				LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		}
		if(!pldte)
			return FALSE;
		if(pldteImage->LoadedImports)
			((PVOID *)pldteImage->LoadedImports)[ipldte++] = pldte;

		/* Get the export directory from the library we've referenced */
		ped = (PIMAGE_EXPORT_DIRECTORY)
			RtlImageDirectoryEntryToData(pldte->DllBase, TRUE,
			IMAGE_DIRECTORY_ENTRY_EXPORT, &cbExports);
		if(!ped) {
			UnloadReferencedModules(pldteImage);
			return FALSE;
		}

		/* Now loop over all of the import thunks and fix them up */
		pthILT = (PIMAGE_THUNK_DATA)(pbImageBase + pid->OriginalFirstThunk);
		pthIAT = (PIMAGE_THUNK_DATA)(pbImageBase + pid->FirstThunk);
		while(pthILT->u1.AddressOfData) {
			char *szName;
			if(IMAGE_SNAP_BY_ORDINAL(pthILT->u1.Ordinal))
				szName = (char *)IMAGE_ORDINAL(pthILT->u1.Ordinal);
			else {
				PIMAGE_IMPORT_BY_NAME pibn = (PIMAGE_IMPORT_BY_NAME)
					(pbImageBase + pthILT->u1.AddressOfData);
				szName = pibn->Name;
			}
			if(!FResolveImport(pldte->DllBase, ped, cbExports, szName,
				(PVOID *)&pthIAT->u1.Function))
			{
#if DBG
				char szError[256];
				char szFn[32];
				STRING st, *pst;

				if(((ULONG)szName & 0xffff0000) == 0) {
					sprintf(szFn, "ordinal %d", szName);
					szName = szFn;
				}
				sprintf(szError, "missing %s in %s\n", szName,
					pbImageBase + pid->Name);
				st.Buffer = szError;
				st.MaximumLength = sizeof szError - 1;
				st.Length = (USHORT)strlen(szError);
				pst = &st;
				_asm {
					mov eax, BREAKPOINT_PRINT
					mov ecx, pst
					int 2dh
					int 3
				}
#endif // DBG
				fLoadFailed = TRUE;
			}
			++pthILT;
			++pthIAT;
		}
		if(fLoadFailed) {
			UnloadReferencedModules(pldteImage);
			return FALSE;
		}
		++pid;
	}
	return TRUE;
}

BOOL FFinishImageLoad(PLDR_DATA_TABLE_ENTRY pldteT, LPCSTR szName,
	PLDR_DATA_TABLE_ENTRY *ppldteOut)
{
	PLDR_DATA_TABLE_ENTRY pldte;
	UNICODE_STRING ustName;
	UNICODE_STRING ustFullName;
	ANSI_STRING ast;
	NTSTATUS st;
	PBYTE pbBase = pldteT->DllBase;
	PIMAGE_NT_HEADERS pnth;
	const char *pch, *pchBase;
	ULONG ul;

	for(pch = pchBase = szName; *pch; ++pch)
		if(*pch == '\\')
			pchBase = pch + 1;

	RtlInitAnsiString(&ast, pchBase);
	ustName.MaximumLength = RtlAnsiStringToUnicodeSize(&ast);
	ustName.Buffer = DmAllocatePool(ustName.MaximumLength);
	if(!ustName.Buffer)
		return FALSE;
	st = RtlAnsiStringToUnicodeString(&ustName, &ast, FALSE);
	if(!NT_SUCCESS(st))
		goto RetFree1;

	RtlInitAnsiString(&ast, szName);
	ustFullName.MaximumLength = RtlAnsiStringToUnicodeSize(&ast);
	ustFullName.Buffer = DmAllocatePool(ustFullName.MaximumLength);
	if(!ustFullName.Buffer)
		goto RetFree1;
	st = RtlAnsiStringToUnicodeString(&ustFullName, &ast, FALSE);
	if(!NT_SUCCESS(st))
		goto RetFree2;

	pldte = DmAllocatePoolWithTag(sizeof *pldte, 'dLmM');
	if(!pldte) {
RetFree2:
		DmFreePool(ustFullName.Buffer);
RetFree1:
		DmFreePool(ustName.Buffer);
		return FALSE;
	}

	RtlZeroMemory(pldte, sizeof *pldte);
	pldte->BaseDllName = ustName;
	pldte->FullDllName = ustFullName;
	pldte->DllBase = pldteT->DllBase;
	pnth = RtlImageNtHeader(pbBase);
	pldte->EntryPoint = pbBase + pnth->OptionalHeader.AddressOfEntryPoint;
	pldte->SizeOfImage = pnth->OptionalHeader.SizeOfImage;
	pldte->CheckSum = pnth->OptionalHeader.CheckSum;
	pldte->Flags = LDRP_ENTRY_PROCESSED | LDRP_SYSTEM_MAPPED;
	pldte->LoadCount = 1;
	pldte->LoadedImports = pldteT->LoadedImports;
	ExInterlockedInsertTailList(g_dmi.LoadedModuleList, &pldte->InLoadOrderLinks);
	if(RtlImageDirectoryEntryToData(pldte->DllBase, TRUE,
		IMAGE_DIRECTORY_ENTRY_DEBUG, &ul))
	{
		DbgLoadImageSymbols(&ast, pldte->DllBase, (ULONG_PTR)-1);
		pldte->Flags |= LDRP_DEBUG_SYMBOLS_LOADED;
	}
	if(ppldteOut)
		*ppldteOut = pldte;
	return TRUE;
}

BOOL FFixupXbdm(PVOID pvBase, PDMINIT pdmi)
{
	LDR_DATA_TABLE_ENTRY ldte;
	PVOID *rgppv[3];
	int ifsub;

	ldte.DllBase = pvBase;
	/* Find our kernel imports */
	if(!FResolveImageImports(&ldte, NULL, pdmi->LoadedModuleList))
		return FALSE;
	/* Initialize the pool */
	InitPool();
	ldte.LoadedImports = (PVOID)-1;
	g_dmi.LoadedModuleList = pdmi->LoadedModuleList;
	if(!FFinishImageLoad(&ldte, "xbdm.dll", NULL))
		return FALSE;

	/* With the module loaded, we now need to set up the kernel routine
	 * substitution list, and then thunk ourselves */
	_asm {
		lea eax, ExAllocatePool
		lea ecx, ExAllocatePoolWithTag
		lea edx, ExFreePool
		mov rgppv, eax
		mov rgppv+4, ecx
		mov rgppv+8, edx
	}
	for(ifsub = 0; ifsub < 3; ++ifsub) {
		rgfsub[ifsub].pfnImport = *rgppv[ifsub];
		*rgppv[ifsub] = rgfsub[ifsub].pfnSub;
	}
}

void UnloadReferencedModules(PLDR_DATA_TABLE_ENTRY pldte)
{
	if(pldte->LoadedImports) {
		PLDR_DATA_TABLE_ENTRY *rgpldte = pldte->LoadedImports;
		int i;
		int c = (int)rgpldte[0];
		for(i = c; i; --i) {
			HANDLE h = (HANDLE)rgpldte[i];
			if(h)
				DmUnloadExtension(h);
		}
		DmFreePool(rgpldte);
		pldte->LoadedImports = NULL;
	}
}

HRESULT DmUnloadExtension(HANDLE hModule)
{
	PLDR_DATA_TABLE_ENTRY pldte = (PLDR_DATA_TABLE_ENTRY)hModule;

	if(pldte->LoadedImports == (PVOID)-1)
		/* This module can't be unloaded */
		return XBDM_NOERR;

	_asm {
		pushfd
		cli
	}
	if(--pldte->LoadCount == 0) {
		RemoveEntryList(&pldte->InLoadOrderLinks);
	} else
		pldte = NULL;
	_asm popfd
	if(pldte) {
		ANSI_STRING ast;
		char sz[256];

		ast.Length = 0;
		ast.MaximumLength = sizeof sz;
		ast.Buffer = sz;
		RtlUnicodeStringToAnsiString(&ast, &pldte->FullDllName, FALSE);
		DbgUnLoadImageSymbols(&ast, pldte->DllBase, (ULONG_PTR)-1);

		UnloadReferencedModules(pldte);

		MmDbgFreeMemory(pldte->DllBase, 0);
		DmFreePool(pldte->BaseDllName.Buffer);
		DmFreePool(pldte->FullDllName.Buffer);
		DmFreePool(pldte);
	}

	return XBDM_NOERR;
}

NTSTATUS StLoadImage(PCOSTR oszName, PCOSTR oszFor,
	PLDR_DATA_TABLE_ENTRY *ppldte)
{
	NTSTATUS st;
	HANDLE h;
	IO_STATUS_BLOCK iosb;
	OBJECT_ATTRIBUTES oa;
	OBJECT_STRING ost;
	FILE_NETWORK_OPEN_INFORMATION fni;
	LDR_DATA_TABLE_ENTRY ldte;

	*ppldte = NULL;
	if(oszFor) {
		const OCHAR *poch, *pochDir;
		int cchBase;
		int cchTot;

		for(poch = pochDir = oszFor; *poch; ++poch)
			if(*poch == '\\')
				pochDir = poch;
		cchBase = strlen(oszName);
		cchTot = (pochDir - oszFor) + cchBase + 1;
		poch = oszName;
		oszName = DmAllocatePool(cchTot + 1);
		if(!poch)
			return STATUS_INSUFFICIENT_RESOURCES;
		memcpy((POCHAR)oszName, oszFor, (pochDir - oszFor) + 1);
		memcpy((POCHAR)oszName + (cchTot - cchBase), poch, cchBase);
		((POCHAR)oszName)[cchTot] = 0;
	}

	RtlInitObjectString(&ost, oszName);
	InitializeObjectAttributes(&oa, &ost, OBJ_CASE_INSENSITIVE, NULL,
		NULL);
	st = NtOpenFile(&h, FILE_EXECUTE, &oa, &iosb, 0,
		FILE_SYNCHRONOUS_IO_NONALERT);
	if(!NT_SUCCESS(st))
		goto ErrRet;
	st = NtQueryInformationFile(h, &iosb, &fni, sizeof fni,
		FileNetworkOpenInformation);
	if(!NT_SUCCESS(st))
		goto ErrClose;
	ldte.DllBase = MmDbgAllocateMemory(fni.EndOfFile.LowPart, PAGE_READWRITE);
	if(ldte.DllBase == NULL) {
		st = STATUS_NO_MEMORY;
		goto ErrClose;
	}
	st = NtReadFile(h, NULL, NULL, NULL, &iosb, ldte.DllBase,
		fni.EndOfFile.LowPart, NULL);
	if(!NT_SUCCESS(st))
		goto ErrClose;
	try {
		/* Now that the image is loaded, we first relocate it */
		st = LdrRelocateImage(ldte.DllBase, "xbdm", STATUS_SUCCESS,
			STATUS_CONFLICTING_ADDRESSES, STATUS_INVALID_IMAGE_FORMAT);
		if(NT_SUCCESS(st)) {
			/* Now we resolve its imports */
			st = FResolveImageImports(&ldte, oszName, NULL) ? STATUS_SUCCESS :
				STATUS_DRIVER_ENTRYPOINT_NOT_FOUND;
			if(NT_SUCCESS(st) && !FFinishImageLoad(&ldte, oszName, ppldte)) {
				st = STATUS_INSUFFICIENT_RESOURCES;
				UnloadReferencedModules(&ldte);
			}
			if(NT_SUCCESS(st)) {
				BOOL fUnload = FALSE;
				/* We need to call this function's entry point.  Since we
				 * don't have any faith that the calling convention of the
				 * callee is sane, we do this via an asm thunk */
				CallDxtEntry((*ppldte)->EntryPoint, &fUnload);
				if(fUnload)
					st = 0x80001000;
			}
		}
	} except(EXCEPTION_EXECUTE_HANDLER) {
		st = GetExceptionCode();
	}
	if(!NT_SUCCESS(st)) {
		if(*ppldte) {
			/* We failed after registering the module.  Need to pull it from
			 * the list */
			DmUnloadExtension((HANDLE)*ppldte);
			*ppldte = NULL;
		} else
			MmDbgFreeMemory(ldte.DllBase, fni.EndOfFile.LowPart);
	}

ErrClose:
	NtClose(h);

ErrRet:
	if(oszFor)
		DmFreePool((PVOID)oszName);

	return st;
}

HRESULT DmLoadExtension(LPCSTR szName, PHANDLE phModule, PVOID *ppvBase)
{
	OCHAR oszName[256];
	NTSTATUS st;
	OBJECT_STRING ost;
	const char *pch, *pchBase;
	LDR_DATA_TABLE_ENTRY *pldte;

	if (!szName)
		return E_INVALIDARG;

	st = FFileNameToObName(szName, oszName, sizeof(oszName)/sizeof(OCHAR)) ?
		STATUS_SUCCESS : STATUS_OBJECT_PATH_INVALID;

	RtlEnterCriticalSection(&csLoader);
	/* See if this basename is already loaded */
	for(pchBase = NULL, pch = szName; *pch; ++pch)
		if(*pch == '\\')
			pchBase = pch + 1;
	_asm {
		pushfd
		cli
	}
	pldte = PldteGetModule(pchBase ? pchBase : szName, TRUE);
	if(pldte) {
		if(pchBase && NT_SUCCESS(st)) {
			/* The basename is there; if the full filenames are different,
			 * then we'll generate an error */
			WCHAR *wz;
			int cch;
			const OCHAR *poch;

			wz = pldte->FullDllName.Buffer;
			cch = pldte->FullDllName.Length >> 1;
			poch = szName;
			while(cch) {
				char ch1, ch2;
				ch1 = (char )*wz++;
				if(ch1 >= 'a' && ch1 <= 'z')
					ch1 -= 'a' - 'A';
				ch2 = (char )*pch++;
				if(ch2 >= 'a' && ch2 <= 'z')
					ch2 -= 'a' - 'A';
				if(ch1 != ch2)
					break;
				--cch;
			}
			if(cch || *pch)
				/* The names differ */
				st = STATUS_OBJECT_NAME_COLLISION;
		}
		if(NT_SUCCESS(st))
			/* We've got a match; increment the refcount and we're done */
			++pldte->LoadCount;
	}
	_asm popfd

	if(!pldte && NT_SUCCESS(st))
		/* No already-loaded module, so let's try to load it */
		st = StLoadImage(oszName, NULL, &pldte);
	RtlLeaveCriticalSection(&csLoader);

	switch(st) {
	case STATUS_OBJECT_NAME_NOT_FOUND:
	case STATUS_OBJECT_PATH_NOT_FOUND:
	case STATUS_OBJECT_PATH_INVALID:
	case STATUS_OBJECT_NAME_INVALID:
		return XBDM_NOSUCHFILE;
	default:
		if(!NT_SUCCESS(st))
			return E_FAIL;
		break;
	}
	if(phModule)
		*phModule = (HANDLE)pldte;
	if(ppvBase)
		*ppvBase = pldte->DllBase;
	return XBDM_NOERR;
}

HRESULT DmGetProcAddress(HANDLE hModule, LPCSTR szName, PVOID *ppvRet)
{
	PLDR_DATA_TABLE_ENTRY pldte = (PLDR_DATA_TABLE_ENTRY)hModule;
	PVOID pvBase = pldte->DllBase;
	PIMAGE_EXPORT_DIRECTORY ped;
	ULONG cbExports;

	if (!szName || !ppvRet)
		return E_INVALIDARG;

	/* Find the module's export directory */
	ped = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(pvBase, TRUE,
		IMAGE_DIRECTORY_ENTRY_EXPORT, &cbExports);
	if(!ped)
		return XBDM_NOSUCHFILE;

	return FResolveImport(pvBase, ped, cbExports, szName, ppvRet) ?
		XBDM_NOERR : XBDM_NOSUCHFILE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dminit.c ===
/*
**
** dminit.c
**
** Debug module initialization
**
*/

#include "dmp.h"
#include <xboxp.h>
#include "xconfig.h"
#include <xprofp.h>

BOOL fBootWait; // 2 means wait forever, 3 means wait once with no timeout
PKPROCESS pprocSystem;
DMINIT g_dmi;
DMGD g_dmgd;
DMXAPI g_dmxapi;
char rgchTitleDir[MAX_OBJ_PATH+1];
char rgchTitleName[64];
char *pszCmdLine;
RTL_CRITICAL_SECTION csIniFile;
HANDLE g_hIniFile;
BOOL g_fFinishedLoadingIniFile;
HAL_SHUTDOWN_REGISTRATION hsrAPIC = { DisableAPIC, 0 };
ULONG g_ulDbgIP;
KEVENT kevtNull;

// This is what we're calling our ini file for now.  It will change someday
char szIniName[] = "E:\\xbdm.ini";
char szDxtDir[] = "E:\\dxt";
OCHAR oszDxtTemplate[] = OTEXT("*.DXT");

VOID CreateThreadNotify(HANDLE pid, HANDLE tid, BOOLEAN fCreate);
void LoadIniFile(void);
void LoadPlugIns(void);

ULONG DmEntryPoint(PVOID pvXbdmBase, PDMINIT pdmi, ULONG unused)
{
    WSADATA wsad;
    NTSTATUS st;
    KIRQL irqlSav;

    // Pass a pointer to the kernel's global profile data structure
    DmProfileData = (XProfpGlobals*)pdmi->XProfpDataPtr;

    /* Finish the process of fixing up our image */
    if(!FFixupXbdm(pvXbdmBase, pdmi))
        return STATUS_DRIVER_ENTRYPOINT_NOT_FOUND;

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    /* Set things up */
    if(!FInitThreadDebugData(PsGetCurrentThread()))
        return STATUS_NO_MEMORY;
	pprocSystem = PsGetCurrentProcess();
	g_dmi = *pdmi;
    g_dmi.D3DDriverData = &g_dmgd;
    g_dmi.XapiData = &g_dmxapi;
	InitializeCriticalSection(&csIniFile);
    HalRegisterShutdownNotification(&hsrAPIC, TRUE);
    KeInitializeEvent(&kevtNull, SynchronizationEvent, TRUE);
    InitSecurity();
    InitBreakpoints();
    InitNotifications();
	InitServ();
    InitLoader();
    InitCounters();
	KeGetCurrentPrcb()->DebugMonitorData = &g_dmi;
	dwExecState = DMN_EXEC_PENDING;

    // register for thread notifications (so we can keep our per-thread data)
    st = PsSetCreateThreadNotifyRoutine(CreateThreadNotify);
    if(!NT_SUCCESS(st)) {
        ASSERT(FALSE);
        return st;
    }

    /* If we've loaded from CD, mark our paths correctly */
    if(pdmi->Flags & DMIFLAG_CDBOOT)
        szIniName[0] = szDxtDir[0] = 1;

    // Load the ini file
    LoadIniFile();
	
    // start networking
    st = XNetStartup(NULL);
    ASSERT(st == NO_ERROR);

	// start winsock
    if(0 != WSAStartup(2, &wsad))
        return STATUS_NO_MEMORY;

    /* Start our listening thread */
    if(!FStartDebugService())
        return STATUS_NO_MEMORY;

    /* Reconnect persistent notification channels.  We're not necessarily
     * ready to start getting commands from them, but we won't give them any
     * reason to do anything yet */
	EnsurePersistentSockets();

    /* Load all plugins */
    LoadPlugIns();

    /* If we're in an active debug session, we need to wait until we've
     * reconnected with the host */
    if(fBootWait && DmGetCurrentDmtd()->DebugEvent) {
		LARGE_INTEGER li;
        BOOL fWait = fBootWait;

		DbgPrint("dm: waiting for debugger connection\n");
		if(fBootWait != 2) {
			/* One wait is all we'll do */
			fBootWait = FALSE;
			WriteIniFile();
		}
		DmGetCurrentDmtd()->DebugFlags |= DMFLAG_STOPPED;
		NotifyComponents(DM_EXEC, dwExecState = DMN_EXEC_PENDING);
		/* We'll sit in a wait state for only fifteen seconds unless we've been
		 * told to wait forever */
		li.QuadPart = Int32x32To64(15000, -10000);
        st = KeWaitForSingleObject(DmGetCurrentDmtd()->DebugEvent, UserRequest,
            UserMode, FALSE, fWait == 1 ? &li : NULL);
		if(st == STATUS_TIMEOUT)
			NotifyComponents(DM_EXEC, dwExecState = DMN_EXEC_START);
		DmGetCurrentDmtd()->DebugFlags &= ~(DMFLAG_STOPPED | DMFLAG_EXCEPTION);
	} else
		NotifyComponents(DM_EXEC, dwExecState = DMN_EXEC_START);

	/* If we have a specified title directory, let's ensure it's a valid
	 * directory and then map it in */
	FTitleExists(*rgchTitleDir ? rgchTitleDir : 0, rgchTitleName, pszCmdLine,
		TRUE);
    irqlSav = KeRaiseIrqlToDpcLevel();
    if(pszCmdLine) {
        DmFreePool(pszCmdLine);
        pszCmdLine = NULL;
    }
    KeLowerIrql(irqlSav);

	*pdmi = g_dmi;
	return STATUS_SUCCESS;
}

VOID CreateThreadNotify(HANDLE pid, HANDLE tid, BOOLEAN fCreate)
{
    if(fCreate) {
		NTSTATUS st;
		PETHREAD pthr;

		st = PsLookupThreadByThreadId(tid, &pthr);
		if(NT_SUCCESS(st)) {
			if(!FInitThreadDebugData(pthr))
				DbgPrint("dm: could not alloc thread data\n");
			else if(pthr->Tcb.TlsData) {
				/* We want to advertise this thread's creation, but we need to
				 * do that within the context of the created thread, not our
				 * thread, so we replace the thread's system routine with our
				 * own, which will send the appropriate notifications */
				PDMTD pdmtd = (PDMTD)pthr->DebugData;
				PKSWITCHFRAME pksf = (PKSWITCHFRAME)pthr->Tcb.KernelStack;
				PKSYSTEM_ROUTINE *ppfn = (PVOID)(pksf + 1);

				pdmtd->DebugFlags |= DMFLAG_STARTTHREAD;
				pdmtd->SystemStartupRoutine = *ppfn;
				*ppfn = DmpThreadStartup;
			}
            ObDereferenceObject(pthr);
		} else
			DbgPrint("dm: could not get new thread\n");
    } else {
	    DMTD *pdmtd;

		/* Advertise this thread's destruction */
		if(PsGetCurrentThread()->Tcb.TlsData)
			NotifyComponents(DM_DESTROYTHREAD,
				(DWORD)PsGetCurrentThread()->UniqueThread);
        pdmtd = PsGetCurrentThread()->DebugData;
		if(pdmtd) {
			PsGetCurrentThread()->DebugData = NULL;
            if(pdmtd->ExceptionStack) {
                MmDeleteKernelStack(pdmtd->ExceptionStack,
                    (PUCHAR)pdmtd->ExceptionStack - 0x2000);
            }
			if(pdmtd->DebugEvent) {
				pdmtd->DebugEvent = NULL;
				/* There shouldn't be anybody waiting on this event */
				ASSERT(IsListEmpty(&pdmtd->DebugEventData.Header.WaitListHead));
			}
			DmFreePool(pdmtd);
		}
    }
}

VOID SetIPParam(ULONG ulValueIndex, LPCSTR pszStaticIP)
{
	ULONG ulAddr = htonl(UlAddrFromSz(pszStaticIP));

	ExSaveNonVolatileSetting(ulValueIndex, REG_DWORD, &ulAddr, sizeof(ulAddr));
}

BOOL FInitThreadDebugData(PETHREAD pthr)
{
    PDMTD pdmtd;

    /* Allocate a new thread data structure, if we don't already have one */
	pdmtd = pthr->DebugData;
	if(!pdmtd) {
		pdmtd = pthr->DebugData = DmAllocatePoolWithTag(sizeof(DMTD), 'dtmD');
		if(!pdmtd)
			return FALSE;
		RtlZeroMemory(pdmtd, sizeof(DMTD));

        /* Allocate an 8k stack on which we can process exceptions.  If this
         * allocation fails, we'll run exceptions on the thread's stack and
         * hope we don't run out of stack */
        pdmtd->ExceptionStack = MmCreateKernelStack(0x2000, TRUE);
	}

    /* Mark this as an XAPI thread */
	if(pthr->Tcb.TlsData)
		pdmtd->DebugFlags |= DMFLAG_XAPITHREAD;

    /* Set up a synchronization event for exception notification */
    if(pdmtd->DebugEvent) {
        ASSERT(FALSE);
        return TRUE;
    }
    KeInitializeEvent(&pdmtd->DebugEventData, NotificationEvent, FALSE);
	pdmtd->DebugEvent = &pdmtd->DebugEventData;
    return TRUE;
}

void DoIniLine(LPCSTR sz)
{
	char rgchIPAddr[20];
	int cchCmd = CchOfWord(sz);

	if(cchCmd == 0); // nothing to do
    else if(FEqualRgch("wait", sz, cchCmd)) {
        if(PchGetParam(sz, "forever", FALSE))
            fBootWait = 2;
        else if(PchGetParam(sz, "stop", FALSE))
            fBootWait = 3;
        else
            fBootWait = 1;
    } else if(FEqualRgch("notify", sz, cchCmd)) {
		/* Set up a notification channel here */
	} else if(FEqualRgch("notifyat", sz, cchCmd)) {
		FNotifyAtCmd(INVALID_SOCKET, sz, TRUE);
	} else if(FEqualRgch("staticip", sz, cchCmd)) {
        FGetDwParam(sz, "addr", &g_ulDbgIP);
#if 0
    // deprecated network commands
	} else if(FEqualRgch("staticip", sz, cchCmd)) {
		if(!FGetSzParam(sz, "addr", rgchIPAddr, sizeof rgchIPAddr)) {
			*rgchIPAddr = 0;
		}
		SetIPParam(XC_ONLINE_IP_ADDRESS, rgchIPAddr);
	} else if(FEqualRgch("subnetmask", sz, cchCmd)) {
		if(!FGetSzParam(sz, "addr", rgchIPAddr, sizeof rgchIPAddr)) {
			*rgchIPAddr = 0;
		}
		SetIPParam(XC_ONLINE_SUBNET_ADDRESS, rgchIPAddr);
	} else if(FEqualRgch("defgateway", sz, cchCmd)) {
		if(!FGetSzParam(sz, "addr", rgchIPAddr, sizeof rgchIPAddr)) {
			*rgchIPAddr = 0;
		}
		SetIPParam(XC_ONLINE_DEFAULT_GATEWAY_ADDRESS, rgchIPAddr);
#endif
	} else
		/* Process this as a normal command if we can */
		HandleCommand(-1, sz);
}

void LoadIniFile(void)
{
	NTSTATUS st;
	IO_STATUS_BLOCK iosb;
	char *rgchBuf;
	char *pch;
	char *pchLine;
	int cb;
	const int cbBuf = 0x1000;

	/* Make sure we can get a read buffer */
	rgchBuf = DmAllocatePoolWithTag(cbBuf + 1, 'mdbX');
	if(!rgchBuf)
		return;

	RtlEnterCriticalSection(&csIniFile);

    /* We leave the ini file open so that we can keep a reference to the FCB
     * and restrict access to the ini file if somebody tries to copy it */
    st = FCreateFile(&g_hIniFile, GENERIC_READ | SYNCHRONIZE, szIniName,
        NULL, 0, 0, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);

	if(NT_SUCCESS(st)) {
		/* Repeatedly read in chunks of file until there's no more file */
		cb = 0;
		for(;;) {
			st = NtReadFile(g_hIniFile, NULL, NULL, NULL, &iosb, rgchBuf + cb,
				cbBuf - cb, NULL);
            if(NT_SUCCESS(st))
				cb += iosb.Information;
			if(!cb)
				break;
			/* Keep pulling lines out of this block to process */
			pchLine = rgchBuf;
			for(pch = rgchBuf; pch < rgchBuf + cb; ++pch) {
				if(*pch == '\012' || *pch == '\015') {
					*pch = 0;
					DoIniLine(pchLine);
					pchLine = pch + 1;
				}
			}
			/* If we've miraculously failed to hit any line breaks in the
			 * data we have, we'll treat the whole thing as one big line */
			if(pchLine == rgchBuf) {
				*pch = 0;
				DoIniLine(pchLine);
				cb = 0;
			} else {
				/* We've processed a bunch of lines and have a partial line
				 * left over, so set it aside and get ready to read more
				 * file */
				memmove(rgchBuf, pchLine, rgchBuf + cb - pchLine);
				cb -= pchLine - rgchBuf;
			}
		}
	}
    g_fFinishedLoadingIniFile = TRUE;
	RtlLeaveCriticalSection(&csIniFile);
	DmFreePool(rgchBuf);
}

#if 0
void LoadPlugIn(const OCHAR *oszName)
{
	PVOID pvImage;
    HANDLE h;

    if(SUCCEEDED(DmLoadExtension(oszName, &h, &pvImage))) {
		PDM_ENTRYPROC pfn;

		pfn = (PDM_ENTRYPROC)((ULONG_PTR)pvImage +
			RtlImageNtHeader(pvImage)->OptionalHeader.AddressOfEntryPoint);
		//_asm int 3
		pfn();
	}
}
#endif

void LoadPlugIns(void)
{
	HANDLE h;
	NTSTATUS st;
	IO_STATUS_BLOCK iosb;
	FILE_DIRECTORY_INFORMATION fda;
	OCHAR oszName[256];
    struct
    {
	    FILE_DIRECTORY_INFORMATION fna;
        OCHAR ozName[256];
    } fna;
	BOOLEAN fFirst = TRUE;
    OBJECT_STRING templateName;

	st = FCreateFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, szDxtDir, NULL,
		0, FILE_SHARE_READ, FILE_OPEN, FILE_DIRECTORY_FILE |
		FILE_SYNCHRONOUS_IO_NONALERT);
	if(NT_SUCCESS(st)) {
        templateName.Buffer = oszDxtTemplate;
        templateName.Length = sizeof oszDxtTemplate - sizeof(OCHAR);
        templateName.MaximumLength = sizeof oszDxtTemplate;

		do {
			st = NtQueryDirectoryFile(h, NULL, NULL, NULL, &iosb, &fna.fna,
				sizeof fna, FileDirectoryInformation, &templateName, fFirst);
			if(NT_SUCCESS(st)) {
				int cch = fna.fna.FileNameLength / sizeof(OCHAR);
				soprintf(oszName, OTEXT("%s\\%*.*s"),
					szDxtDir, cch, cch, fna.fna.FileName);
                DmLoadExtension(oszName, NULL, NULL);
			}
			fFirst = FALSE;
		} while (NT_SUCCESS(st));
		NtClose(h);
	}
}

void WriteIniData(INF *pinf, const BYTE *pb, int cb)
{
	IO_STATUS_BLOCK iosb;

	if(pb) {
		while(cb) {
			int cbT = pinf->cbBuf - pinf->cbUsed;
			if(cb >= cbT) {
				memcpy(pinf->pbBuf + pinf->cbUsed, pb, cbT);
				NtWriteFile(pinf->h, NULL, NULL, NULL, &iosb, pinf->pbBuf,
					pinf->cbBuf, NULL);
				pb += cbT;
				cb -= cbT;
				pinf->cbUsed = 0;
			} else {
				memcpy(pinf->pbBuf + pinf->cbUsed, pb, cb);
				pb += cb;
				pinf->cbUsed += cb;
				cb = 0;
			}
		}
	} else {
		/* Flush */
		NtWriteFile(pinf->h, NULL, NULL, NULL, &iosb, pinf->pbBuf,
			pinf->cbUsed, NULL);
		pinf->cbUsed = 0;
	}
}

void WriteIniSzNoCRLF(INF *pinf, LPCSTR sz)
{
	WriteIniData(pinf, sz, strlen(sz));
}

void WriteIniSz(INF *pinf, LPCSTR sz)
{
	WriteIniSzNoCRLF(pinf, sz);
	WriteIniData(pinf, "\015\012", 2);
}

void WriteIniFile(void)
{
	NTSTATUS st;
	INF inf;
    char sz[64];

    /* We don't write if we're a CD boot.  We also don't write if we haven't
     * finished reading the ini file yet */
    if((g_dmi.Flags & DMIFLAG_CDBOOT) || !g_fFinishedLoadingIniFile)
        return;

	inf.cbBuf = 0x1000;
	inf.cbUsed = 0;
	/* Make sure we can get a write buffer */
	inf.pbBuf = DmAllocatePoolWithTag(inf.cbBuf, 'mdbX');
	if(!inf.pbBuf)
		return;

	RtlEnterCriticalSection(&csIniFile);
    if(g_hIniFile)
        NtClose(g_hIniFile);

    st = FCreateFile(&inf.h, GENERIC_WRITE | SYNCHRONIZE, szIniName, NULL,
        0, 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT);
	if(NT_SUCCESS(st)) {
        g_hIniFile = inf.h;
		WriteIniSz(&inf, "[xbdm]");
		/* Write all the data we know about */
        switch(fBootWait) {
        case 1:
            WriteIniSz(&inf, "wait");
            break;
        case 2:
            WriteIniSz(&inf, "wait forever");
            break;
        case 3:
            WriteIniSz(&inf, "wait stop");
            break;
        }
#if 0
		/* For now, titledir is not reboot persistent */
		if(rgchTitleDir[0]) {
			WriteIniSzNoCRLF(&inf, "titledir name=");
			WriteIniSz(&inf, rgchTitleDir);
		}
#endif
		if(rgchDbgName[0]) {
			WriteIniSzNoCRLF(&inf, "dbgname name=");
			WriteIniSz(&inf, rgchDbgName);
		}
        if(g_ulDbgIP) {
            sprintf(sz, "staticip addr=0x%08x", g_ulDbgIP);
            WriteIniSz(&inf, sz);
        }
		WriteIniNotifiers(&inf);
        WriteIniSecurity(&inf);
		/* Flush */
		WriteIniData(&inf, NULL, 0);
    } else
        g_hIniFile = NULL;

	RtlLeaveCriticalSection(&csIniFile);
	DmFreePool(inf.pbBuf);
}

__declspec(naked) void DisableAPIC(PHAL_SHUTDOWN_REGISTRATION phsr)
{
    _asm {
        // Find the local APIC
        xor edx, edx
        xor eax, eax
        mov ecx, 0x1b
        rdmsr

        // Do nothing if already disabled
        test ax, 0x800
        jz disabled

        // Disable it -- shouldn't need to mark as s/w disabled
        and ah, 0xf7
        wrmsr
disabled:
        ret 4
    }
}

/* And here are some functions just to replace missing kernel functions */
#undef PsGetCurrentThreadId
HANDLE PsGetCurrentThreadId( VOID )
{
    return PsGetCurrentThread()->UniqueThread;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmpool.c ===
/*
 *
 * dmpool.c
 *
 * copied from ex\pool.c
 *
 */

#include "dmp.h"
#include "pool.h"

//
// FREE_CHECK_KTIMER - If enabled causes each free pool to verify no
// active KTIMERs are in the pool block being freed.
//

#if 0

#define FREE_CHECK_KTIMER(Va, NumberOfBytes) \
            KeCheckForTimer(Va, NumberOfBytes)

#else

#define FREE_CHECK_KTIMER(Va, NumberOfBytes)

#endif


//
// We redefine the LIST_ENTRY macros to have each pointer biased
// by one so any rogue code using these pointers will access
// violate.  See \nt\public\sdk\inc\ntrtl.h for the original
// definition of these macros.
//
// This is turned off in the shipping product.
//

#ifndef NO_POOL_CHECKS

ULONG ExpPoolBugCheckLine;

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) & ~1))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) |  1))

#define PrivateInitializeListHead(ListHead) (                     \
    (ListHead)->Flink = (ListHead)->Blink = EncodeLink(ListHead))

#define PrivateIsListEmpty(ListHead)              \
    (DecodeLink((ListHead)->Flink) == (ListHead))

#define PrivateRemoveHeadList(ListHead)                     \
    DecodeLink((ListHead)->Flink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Flink))}

#define PrivateRemoveTailList(ListHead)                     \
    DecodeLink((ListHead)->Blink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Blink))}

#define PrivateRemoveEntryList(Entry) {       \
    PLIST_ENTRY _EX_Blink;                    \
    PLIST_ENTRY _EX_Flink;                    \
    _EX_Flink = DecodeLink((Entry)->Flink);   \
    _EX_Blink = DecodeLink((Entry)->Blink);   \
    _EX_Blink->Flink = EncodeLink(_EX_Flink); \
    _EX_Flink->Blink = EncodeLink(_EX_Blink); \
    }

#define PrivateInsertTailList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Blink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    _EX_Blink = DecodeLink(_EX_ListHead->Blink); \
    (Entry)->Flink = EncodeLink(_EX_ListHead);   \
    (Entry)->Blink = EncodeLink(_EX_Blink);      \
    _EX_Blink->Flink = EncodeLink(Entry);        \
    _EX_ListHead->Blink = EncodeLink(Entry);     \
    }

#define PrivateInsertHeadList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Flink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    _EX_Flink = DecodeLink(_EX_ListHead->Flink); \
    (Entry)->Flink = EncodeLink(_EX_Flink);      \
    (Entry)->Blink = EncodeLink(_EX_ListHead);   \
    _EX_Flink->Blink = EncodeLink(Entry);        \
    _EX_ListHead->Flink = EncodeLink(Entry);     \
    }

#define CHECK_LIST(LINE,LIST,ENTRY)                                         \
    if ((DecodeLink(DecodeLink((LIST)->Flink)->Blink) != (LIST)) ||         \
        (DecodeLink(DecodeLink((LIST)->Blink)->Flink) != (LIST))) {         \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx (BAD_POOL_HEADER,                                  \
                          3,                                                \
                          (ULONG_PTR)LIST,                                  \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Flink)->Blink),     \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Blink)->Flink));    \
    }

#define CHECK_POOL_HEADER(LINE,ENTRY) {                                                 \
    PPOOL_HEADER PreviousEntry;                                                         \
    PPOOL_HEADER NextEntry;                                                             \
    if ((ENTRY)->PreviousSize != 0) {                                                   \
        PreviousEntry = (PPOOL_HEADER)((PPOOL_BLOCK)(ENTRY) - (ENTRY)->PreviousSize);   \
        if (PreviousEntry->BlockSize != (ENTRY)->PreviousSize) {                        \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx(BAD_POOL_HEADER, 5, (ULONG_PTR)PreviousEntry, LINE, (ULONG_PTR)ENTRY); \
        }                                                                               \
    }                                                                                   \
    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)(ENTRY) + (ENTRY)->BlockSize);              \
    if (!PAGE_END(NextEntry)) {                                                         \
        if (NextEntry->PreviousSize != (ENTRY)->BlockSize) {                            \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx(BAD_POOL_HEADER, 5, (ULONG_PTR)NextEntry, LINE, (ULONG_PTR)ENTRY);     \
        }                                                                               \
    }                                                                                   \
}

#define ASSERT_ALLOCATE_IRQL(_NumberOfBytes)                            \
    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                          \
        KeBugCheckEx (BAD_POOL_CALLER, 8, KeGetCurrentIrql(), 0, _NumberOfBytes);                                                            \
    }

#define ASSERT_FREE_IRQL(_P)                                            \
    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                          \
        KeBugCheckEx (BAD_POOL_CALLER, 9, KeGetCurrentIrql(), 0, (ULONG_PTR)P);                                                              \
    }

#define ASSERT_POOL_NOT_FREE(_Entry)                                    \
    if ((_Entry->PoolType & POOL_TYPE_MASK) == 0) {                     \
        KeBugCheckEx (BAD_POOL_CALLER, 6, __LINE__, (ULONG_PTR)_Entry, _Entry->Ulong1);                                                                 \
    }

#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)                               \
    if (_Entry->PoolType == 0) {                                        \
        KeBugCheckEx(BAD_POOL_CALLER, 1, (ULONG_PTR)_Entry, (ULONG_PTR)(*(PULONG)_Entry), 0);                                                           \
    }

#define CHECK_LOOKASIDE_LIST(LINE,LIST,ENTRY) {NOTHING;}

#else

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define PrivateInitializeListHead InitializeListHead
#define PrivateIsListEmpty        IsListEmpty
#define PrivateRemoveHeadList     RemoveHeadList
#define PrivateRemoveTailList     RemoveTailList
#define PrivateRemoveEntryList    RemoveEntryList
#define PrivateInsertTailList     InsertTailList
#define PrivateInsertHeadList     InsertHeadList

#define ASSERT_ALLOCATE_IRQL(_P)            {NOTHING;}
#define ASSERT_FREE_IRQL(_P)                {NOTHING;}
#define ASSERT_POOL_NOT_FREE(_Entry)        {NOTHING;}
#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)   {NOTHING;}

//
// The check list macros come in two flavors - there is one in the checked
// and free build that will bugcheck the system if a list is ill-formed, and
// there is one for the final shipping version that has all the checked
// disabled.
//
// The check lookaside list macros also comes in two flavors and is used to
// verify that the look aside lists are well formed.
//
// The check pool header macro (two flavors) verifies that the specified
// pool header matches the preceeding and succeeding pool headers.
//

#define CHECK_LIST(LINE,LIST,ENTRY)         {NOTHING;}
#define CHECK_POOL_HEADER(LINE,ENTRY)       {NOTHING;}

#define CHECK_LOOKASIDE_LIST(LINE,LIST,ENTRY) {NOTHING;}

#define CHECK_POOL_PAGE(PAGE) \
    {                                                                         \
        PPOOL_HEADER P = (PPOOL_HEADER)(((ULONG_PTR)(PAGE)) & ~(PAGE_SIZE-1));    \
        ULONG SIZE, LSIZE;                                                    \
        LOGICAL FOUND=FALSE;                                                  \
        LSIZE = 0;                                                            \
        SIZE = 0;                                                             \
        do {                                                                  \
            if (P == (PPOOL_HEADER)PAGE) {                                    \
                FOUND = TRUE;                                                 \
            }                                                                 \
            if (P->PreviousSize != LSIZE) {                                   \
                DbgPrint("DMPOOL: Inconsistent size: ( %lx ) - %lx->%u != %u\n",\
                         PAGE, P, P->PreviousSize, LSIZE);                    \
                DbgBreakPoint();                                              \
            }                                                                 \
            LSIZE = P->BlockSize;                                             \
            SIZE += LSIZE;                                                    \
            P = (PPOOL_HEADER)((PPOOL_BLOCK)P + LSIZE);                       \
        } while ((SIZE < (PAGE_SIZE / POOL_SMALLEST_BLOCK)) &&                \
                 (PAGE_END(P) == FALSE));                                     \
        if ((PAGE_END(P) == FALSE) || (FOUND == FALSE)) {                     \
            DbgPrint("DMPOOL: Inconsistent page: %lx\n",P);                     \
            DbgBreakPoint();                                                  \
        }                                                                     \
    }

#endif


#define MAX_TRACKER_TABLE   1025
#define MAX_BIGPAGE_TABLE   4096
// #define MAX_TRACKER_TABLE   5
// #define MAX_BIGPAGE_TABLE   4

ULONG FirstPrint;

PPOOL_TRACKER_TABLE PoolTrackTable;
SIZE_T PoolTrackTableSize;
SIZE_T PoolTrackTableMask;

PPOOL_TRACKER_BIG_PAGES PoolBigPageTable;
SIZE_T PoolBigPageTableSize;
SIZE_T PoolBigPageTableHash;

FORCEINLINE BOOL FIsDmPool(PVOID P)
{
    return ((ULONG)P & 0xF0000000) == 0xB0000000;
}

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T Size
    );

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN ULONG Size
    );

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages
    );

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va
    );

//
// Define macros to pack and unpack a pool index.
//

#define MARK_POOL_HEADER_ALLOCATED(POOLHEADER)      {(POOLHEADER)->PoolIndex = 0x80;}
#define MARK_POOL_HEADER_FREED(POOLHEADER)          {(POOLHEADER)->PoolIndex = 0;}
#define IS_POOL_HEADER_MARKED_ALLOCATED(POOLHEADER) ((POOLHEADER)->PoolIndex == 0x80)

//
// Pool descriptors for nonpaged pool and nonpaged pool must succeed are
// static.
//

POOL_DESCRIPTOR DmPoolDescriptor;

KSPIN_LOCK ExpTaggedPoolLock;

//
// Define paged and nonpaged pool lookaside descriptors.
//

POOL_LOOKASIDE_LIST ExpSmallDmPoolLookasideLists[POOL_SMALL_LISTS];


//
// LOCK_POOL and UNLOCK_POOL are only used within this module.
//

#define LOCK_POOL(LockHandle) {                                                \
    LockHandle = KeRaiseIrqlToDpcLevel();                                      \
}

#define UNLOCK_POOL(LockHandle) {                                              \
    KeLowerIrql(LockHandle);                                                   \
}

typedef struct _DMPP {
    struct _DMPP *pdmppNext;
    ULONG cpg;
    struct _DMPP *pdmppSucc;
} DMPP, *PDMPP;

static PDMPP pdmppHead;
static ULONG cpgDmppList;
static const ULONG cpgDmppMax = ((64 * 1024) >> PAGE_SHIFT);

void QueueDmpp(PDMPP pdmpp)
{
    PDMPP *ppdmpp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    /* First see whether we can coalesce this block with another */
    pdmpp->pdmppSucc = (PDMPP)((ULONG_PTR)pdmpp + (pdmpp->cpg << PAGE_SHIFT));
    ppdmpp = &pdmppHead;
    while(*ppdmpp) {
        if(pdmpp->pdmppSucc == *ppdmpp) {
            /* We precede another block */
            pdmpp->pdmppSucc = (*ppdmpp)->pdmppSucc;
            cpgDmppList -= (*ppdmpp)->cpg;
            pdmpp->cpg += (*ppdmpp)->cpg;
            *ppdmpp = (*ppdmpp)->pdmppNext;
        } else if((*ppdmpp)->pdmppSucc == pdmpp) {
            /* We follow another block */
            (*ppdmpp)->pdmppSucc = pdmpp->pdmppSucc;
            cpgDmppList -= (*ppdmpp)->cpg;
            (*ppdmpp)->cpg += pdmpp->cpg;
            pdmpp = *ppdmpp;
            *ppdmpp = (*ppdmpp)->pdmppNext;
        } else
            ppdmpp = &(*ppdmpp)->pdmppNext;
    }

    /* Now insert our possibly coalesced block back into the list */
    ppdmpp = &pdmppHead;
    while(*ppdmpp && (*ppdmpp)->cpg < pdmpp->cpg)
        ppdmpp = &(*ppdmpp)->pdmppNext;
    pdmpp->pdmppNext = *ppdmpp;
    *ppdmpp = pdmpp;
    cpgDmppList += pdmpp->cpg;
}

ULONG
DmpFreePoolMemory(
    IN PVOID pvFree,
    IN SIZE_T cb
    )
{
    KIRQL irqlSav;
    int cpgNeed;
    int cpg;
    PMMPTE pmmpte;
    PDMPP pdmpp;

    irqlSav = KeRaiseIrqlToDpcLevel();

    /* If we need to retain some of this memory in the free page pool, figure
     * out how much */
    if(cpgDmppList < cpgDmppMax) {
        cpgNeed = cpgDmppMax - cpgDmppList;
        if(cb != 0)
            cpg = (cb + PAGE_SIZE - 1) >> PAGE_SHIFT;
        else {
            pmmpte = MiGetPteAddress(pvFree);
            for(cpg = 1; !pmmpte->Hard.GuardOrEndOfAllocation; ++cpg, ++pmmpte);
        }
        if(cpg < cpgNeed)
            cpgNeed = cpg;

        /* The front end of the block is going to go into the free list */
        pdmpp = (PDMPP)pvFree;
        pdmpp->cpg = cpgNeed;
        QueueDmpp(pdmpp);

        /* The tail end of the block, if any, will be sent back to the memory
         * manager */
        if(cpg != cpgNeed) 
            DmpFreePoolMemory((PVOID)((ULONG_PTR)pvFree + (cpgNeed << PAGE_SHIFT)),
                (cpg - cpgNeed) << PAGE_SHIFT);
    } else
        /* The whole block can be sent back */
        cpg = MmDbgFreeMemory(pvFree, cb);

    KeLowerIrql(irqlSav);
    
    return cpg;
}

PVOID DmpAllocatePoolMemory(
    IN SIZE_T cb
    )
{
    KIRQL irqlSav;
    ULONG cpgNeed;
    ULONG cpg;
    PMMPTE pmmpte;
    PDMPP pdmpp, pdmppTail, *ppdmpp;
    PVOID pv;

    /* We go to the mm first */
    pv = MmDbgAllocateMemory(cb, PAGE_READWRITE);
    if(pv)
        return pv;

    /* No luck; we're going to have to pull off our pool */
    irqlSav = KeRaiseIrqlToDpcLevel();

    /* See if we can find a sufficiently large free block */
    cpgNeed = (cb + PAGE_SIZE - 1) >> PAGE_SHIFT;
    ppdmpp = &pdmppHead;
    while(*ppdmpp && (*ppdmpp)->cpg < cpgNeed)
        ppdmpp = &(*ppdmpp)->pdmppNext;

    if(*ppdmpp) {
        /* Got one.  Remove it from the list */
        pdmpp = *ppdmpp;
        *ppdmpp = pdmpp->pdmppNext;
        cpgDmppList -= pdmpp->cpg;

        /* If we have a tail end, put it back on the free list */
        if(pdmpp->cpg > cpgNeed) {
            pdmppTail = (PDMPP)((ULONG_PTR)pdmpp + (cpgNeed << PAGE_SHIFT));
            pdmppTail->cpg = pdmpp->cpg - cpgNeed;
            QueueDmpp(pdmppTail);
        }

        /* Walk the PTEs and mark the allocation boundary */
        pmmpte = MiGetPteAddress(pdmpp);
        while(--cpgNeed)
            (pmmpte++)->Hard.GuardOrEndOfAllocation = 0;
        pmmpte->Hard.GuardOrEndOfAllocation = 1;

        pv = pdmpp;
    } else if (cpgNeed <= cpgDmppList) {
        /* We couldn't find a sufficiently large block, but we have enough
         * pages to reclaim.  Reclaim as many as necessary and then try
         * our luck */
        while(cpgNeed && pdmppHead) {
            pdmpp = pdmppHead;
            pdmppHead = pdmpp->pdmppNext;
            cpgDmppList -= pdmpp->cpg;

            /* If this is more than we need to free, then put the tail back
             * on the list */
            if(pdmpp->cpg > cpgNeed) {
                pdmppTail = (PDMPP)((ULONG_PTR)pdmpp + (cpgNeed << PAGE_SHIFT));
                pdmppTail->cpg = pdmpp->cpg - cpgNeed;
                QueueDmpp(pdmppTail);
                pdmpp->cpg = cpgNeed;
            }

            MmDbgFreeMemory(pdmpp, pdmpp->cpg << PAGE_SHIFT);
        }

        /* Now see whether our reclaimed pages can be reallocated */
        pv = MmDbgAllocateMemory(cb, PAGE_READWRITE);
    } else
        pv = NULL;

    KeLowerIrql(irqlSav);

    return pv;
}

PVOID
DmpAllocatePoolPages(
    IN SIZE_T NumberOfBytes
    )
{

    PVOID p = DmpAllocatePoolMemory(NumberOfBytes);
    if(p) {
        PBYTE pT = p;
        SIZE_T cb;

        while(NumberOfBytes) {
            cb = NumberOfBytes > PAGE_SIZE ? PAGE_SIZE : NumberOfBytes;
            RtlFillMemoryUlong(pT, cb, 'looP');
            NumberOfBytes -= cb;
            pT += cb;
        }
    }
    return p;
}

VOID
InitPool(
    VOID
    )

/*++

Routine Description:

    This procedure initializes a pool descriptor for the specified pool
    type.  Once initialized, the pool may be used for allocation and
    deallocation.

    This function should be called once for each base pool type during
    system initialization.

    Each pool descriptor contains an array of list heads for free
    blocks.  Each list head holds blocks which are a multiple of
    the POOL_BLOCK_SIZE.  The first element on the list [0] links
    together free entries of size POOL_BLOCK_SIZE, the second element
    [1] links together entries of POOL_BLOCK_SIZE * 2, the third
    POOL_BLOCK_SIZE * 3, etc, up to the number of blocks which fit
    into a page.

Arguments:

    PoolType - Supplies the type of pool being initialized (e.g.
               nonpaged pool, paged pool...).

Return Value:

    None.

--*/

{
    ULONG Index;
    PDMPP pdmpp;
    KIRQL irqlSav;

    //
    // Initialize nonpaged pools.
    //

#if !DBG
    if (NtGlobalFlag & FLG_POOL_ENABLE_TAGGING) {
#endif  //!DBG
        PoolTrackTableSize = MAX_TRACKER_TABLE;
        PoolTrackTableMask = PoolTrackTableSize - 2;
        PoolTrackTable = DmpAllocatePoolMemory(PoolTrackTableSize *
            sizeof(POOL_TRACKER_TABLE));

        RtlZeroMemory(PoolTrackTable, PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE));

        PoolBigPageTableSize = MAX_BIGPAGE_TABLE;
        PoolBigPageTableHash = PoolBigPageTableSize - 1;
        PoolBigPageTable = DmpAllocatePoolMemory(PoolBigPageTableSize *
            sizeof(POOL_TRACKER_BIG_PAGES));

        RtlZeroMemory(PoolBigPageTable, PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES));
#if !DBG
    }
#endif  //!DBG

    //
    // Initialize the spinlocks for nonpaged pool.
    //

    KeInitializeSpinLock (&ExpTaggedPoolLock);

    //
    // Initialize the nonpaged pool descriptor.
    //

    DmPoolDescriptor.RunningAllocs = 0;
    DmPoolDescriptor.RunningDeAllocs = 0;
    DmPoolDescriptor.TotalPages = 0;
    DmPoolDescriptor.TotalBigPages = 0;

    //
    // Initialize the allocation listheads.
    //

    for (Index = 0; Index < POOL_LIST_HEADS; Index += 1) {
        PrivateInitializeListHead(&DmPoolDescriptor.ListHeads[Index]);
    }

    if (PoolTrackTable) {
        ExpInsertPoolTracker('looP',
                              (ULONG) ROUND_TO_PAGES(PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE)));

        ExpInsertPoolTracker('looP',
                              (ULONG) ROUND_TO_PAGES(PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES)));
    }

    /* Allocate the minimum free list */
    pdmpp = MmDbgAllocateMemory(cpgDmppMax << PAGE_SHIFT, PAGE_READWRITE);
    if(pdmpp) {
        irqlSav = KeRaiseIrqlToDpcLevel();
        pdmpp->cpg = cpgDmppMax;
        QueueDmpp(pdmpp);
        KeLowerIrql(irqlSav);
    }
}

PVOID
DmAllocatePool(
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block.  This function is used to
    access both the page-aligned pools, and the list head entries (less than
    a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned
    pool allocator is used.  The allocated block will be page-aligned
    and a page-sized multiple.

    Otherwise, the appropriate pool list entry is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request.  If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split.  One piece is placed back into the pool, and
    the other piece is used to satisfy the request.  If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called.  The page is split and added
    to the pool...

Arguments:

    PoolType - ignored

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
        not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    return DmAllocatePoolWithTag (NumberOfBytes, 'enoN');
}

PVOID
DmAllocatePoolWithTag(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block. This function is used to
    access both the page-aligned pools and the list head entries (less
    than a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned pool
    allocator is used. The allocated block will be page-aligned and a
    page-sized multiple.

    Otherwise, the appropriate pool list entry is used. The allocated
    block will be 64-bit aligned, but will not be page aligned. The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request. If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split. One piece is placed back into the pool, and
    the other piece is used to satisfy the request. If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called. The page is split and added
    to the pool.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

    Tag - Supplies the caller's identifying tag.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
        not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    PVOID Block;
    PPOOL_HEADER Entry;
    PPOOL_LOOKASIDE_LIST LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_HEADER SplitEntry;
    KIRQL LockHandle;
    PPOOL_DESCRIPTOR PoolDesc = &DmPoolDescriptor;
    ULONG Index;
    ULONG ListNumber;
    ULONG NeededSize;
    PLIST_ENTRY ListHead;
    ULONG NumberOfPages;
    PVOID CallingAddress;
    PVOID CallersCaller;

    ASSERT(NumberOfBytes != 0);
    ASSERT_ALLOCATE_IRQL(NumberOfBytes);

    //
    // Check to determine if the requested block can be allocated from one
    // of the pool lists or must be directly allocated from virtual memory.
    //

    if (NumberOfBytes > POOL_BUDDY_MAX) {

        //
        // The requested size is greater than the largest block maintained
        // by allocation lists.
        //

        LOCK_POOL(LockHandle);

        PoolDesc->RunningAllocs += 1;

        Entry = (PPOOL_HEADER) DmpAllocatePoolPages(NumberOfBytes);

        if (Entry != NULL) {

            NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);
            PoolDesc->TotalBigPages += NumberOfPages;

            UNLOCK_POOL(LockHandle);

            if (PoolBigPageTable != NULL) {

                if (ExpAddTagForBigPages((PVOID)Entry,
                                         Tag,
                                         NumberOfPages) == FALSE) {
                    Tag = ' GIB';
                }

                ExpInsertPoolTracker (Tag,
                                      (ULONG) ROUND_TO_PAGES(NumberOfBytes));
            }

        } else {

            UNLOCK_POOL(LockHandle);

            KdPrint(("EX: DmAllocatePool (%p) returning NULL\n", NumberOfBytes));
        }

        return Entry;
    }

    //
    // The requested size is less than or equal to the size of the
    // maximum block maintained by the allocation lists.
    //

    //
    // Compute the Index of the listhead for blocks of the requested
    // size.
    //

    ListNumber = (ULONG)((NumberOfBytes + POOL_OVERHEAD + (POOL_SMALLEST_BLOCK - 1)) >> POOL_BLOCK_SHIFT);

    NeededSize = ListNumber;

    //
    // If the requested pool block is a small block, then attempt to
    // allocate the requested pool from the per processor lookaside
    // list. If the attempt fails, then attempt to allocate from the
    // system lookaside list. If the attempt fails, then select a
    // pool to allocate from and allocate the block normally.
    //

    if (NeededSize <= POOL_SMALL_LISTS) {
        LookasideList = &ExpSmallDmPoolLookasideLists[NeededSize - 1];
        LookasideList->TotalAllocates += 1;

        CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, 0);

        Entry = (PPOOL_HEADER)InterlockedPopEntrySList (&LookasideList->ListHead);

        if (Entry != NULL) {

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, Entry);

            Entry -= 1;
            LookasideList->AllocateHits += 1;

            Entry->PoolType = 1;
            MARK_POOL_HEADER_ALLOCATED(Entry);

            Entry->PoolTag = Tag;

            if (PoolTrackTable != NULL) {

                ExpInsertPoolTracker (Tag, Entry->BlockSize << POOL_BLOCK_SHIFT);
            }

            //
            // Zero out any back pointer to our internal structures
            // to stop someone from corrupting us via an
            // uninitialized pointer.
            //

            ((PULONG)((PCHAR)Entry + POOL_OVERHEAD))[0] = 0;

            return (PUCHAR)Entry + POOL_OVERHEAD;
        }
    }

    LOCK_POOL(LockHandle);

    //
    // The following code has an outer loop and an inner loop.
    //
    // The outer loop is utilized to repeat a nonpaged must succeed
    // allocation if necessary.
    //
    // The inner loop is used to repeat an allocation attempt if there
    // are no entries in any of the pool lists.
    //

    PoolDesc->RunningAllocs += 1;
    ListHead = &PoolDesc->ListHeads[ListNumber];

    do {

        //
        // Attempt to allocate the requested block from the current free
        // blocks.
        //

        do {

            //
            // If the list is not empty, then allocate a block from the
            // selected list.
            //

            if (PrivateIsListEmpty(ListHead) == FALSE) {

                CHECK_LIST( __LINE__, ListHead, 0 );
                Block = PrivateRemoveHeadList(ListHead);
                CHECK_LIST( __LINE__, ListHead, 0 );
                Entry = (PPOOL_HEADER)((PCHAR)Block - POOL_OVERHEAD);

                ASSERT(Entry->BlockSize >= NeededSize);

                ASSERT(Entry->PoolType == 0);

                if (Entry->BlockSize != NeededSize) {

                    //
                    // The selected block is larger than the allocation
                    // request. Split the block and insert the remaining
                    // fragment in the appropriate list.
                    //
                    // If the entry is at the start of a page, then take
                    // the allocation from the front of the block so as
                    // to minimize fragmentation. Otherwise, take the
                    // allocation from the end of the block which may
                    // also reduce fragmentation if the block is at the
                    // end of a page.
                    //

                    if (Entry->PreviousSize == 0) {

                        //
                        // The entry is at the start of a page.
                        //

                        SplitEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                        SplitEntry->BlockSize = (UCHAR)(Entry->BlockSize - (UCHAR)NeededSize);
                        SplitEntry->PreviousSize = (UCHAR)NeededSize;

                        //
                        // If the allocated block is not at the end of a
                        // page, then adjust the size of the next block.
                        //

                        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)SplitEntry + SplitEntry->BlockSize);
                        if (PAGE_END(NextEntry) == FALSE) {
                            NextEntry->PreviousSize = SplitEntry->BlockSize;
                        }

                    } else {

                        //
                        // The entry is not at the start of a page.
                        //

                        SplitEntry = Entry;
                        Entry->BlockSize -= (UCHAR)NeededSize;
                        Entry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
                        Entry->PreviousSize = SplitEntry->BlockSize;

                        //
                        // If the allocated block is not at the end of a
                        // page, then adjust the size of the next block.
                        //

                        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                        if (PAGE_END(NextEntry) == FALSE) {
                            NextEntry->PreviousSize = (UCHAR)NeededSize;
                        }
                    }

                    //
                    // Set the size of the allocated entry, clear the pool
                    // type of the split entry, set the index of the split
                    // entry, and insert the split entry in the appropriate
                    // free list.
                    //

                    Entry->BlockSize = (UCHAR)NeededSize;
                    SplitEntry->PoolType = 0;
                    Index = SplitEntry->BlockSize;

                    CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], 0);
                    PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));
                    CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], 0);
                    CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)), 0);
                }

                Entry->PoolType = 1;

                MARK_POOL_HEADER_ALLOCATED(Entry);

                CHECK_POOL_HEADER(__LINE__, Entry);

                UNLOCK_POOL(LockHandle);

                Entry->PoolTag = Tag;

                if (PoolTrackTable != NULL) {

                    ExpInsertPoolTracker (Tag,
                                          Entry->BlockSize << POOL_BLOCK_SHIFT);
                }

                //
                // Zero out any back pointer to our internal structures
                // to stop someone from corrupting us via an
                // uninitialized pointer.
                //

                ((PULONGLONG)((PCHAR)Entry + POOL_OVERHEAD))[0] = 0;

                return (PCHAR)Entry + POOL_OVERHEAD;
            }
            ListHead += 1;

        } while (ListHead != &PoolDesc->ListHeads[POOL_LIST_HEADS]);

        //
        // A block of the desired size does not exist and there are
        // no large blocks that can be split to satisfy the allocation.
        // Attempt to expand the pool by allocating another page to be
        // added to the pool.
        //

        Entry = (PPOOL_HEADER)DmpAllocatePoolPages(PAGE_SIZE);

        if (Entry == NULL) {

            //
            // No more pool of the specified type is available.
            //

            KdPrint(("EX: DmAllocatePool (%p) returning NULL\n",
                NumberOfBytes));

            UNLOCK_POOL(LockHandle);

            return NULL;
        }

        //
        // Insert the allocated page in the last allocation list.
        //

        PoolDesc->TotalPages += 1;
        Entry->PoolType = 0;

        //
        // N.B. A byte is used to store the block size in units of the
        //      smallest block size. Therefore, if the number of small
        //      blocks in the page is greater than 255, the block size
        //      is set to 255.
        //

        if ((PAGE_SIZE / POOL_SMALLEST_BLOCK) > 255) {
            Entry->BlockSize = 255;

        } else {
            Entry->BlockSize = (UCHAR)(PAGE_SIZE / POOL_SMALLEST_BLOCK);
        }

        Entry->PreviousSize = 0;
        ListHead = &PoolDesc->ListHeads[POOL_LIST_HEADS - 1];

        CHECK_LIST(__LINE__, ListHead, 0);
        PrivateInsertHeadList(ListHead, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
        CHECK_LIST(__LINE__, ListHead, 0);
        CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), 0);

    } while (TRUE);
}

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This function inserts a pool tag in the tag table and increments the
    number of allocates and updates the total allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    Size - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

--*/

{
    ULONG Hash;
    ULONG OriginalKey;
    ULONG OriginalHash;
    ULONG Index;
    KIRQL OldIrql;
    ULONG BigPages;
    LOGICAL HashedIt;
    SIZE_T NewSize;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    SIZE_T NewSizeMask;
    PPOOL_TRACKER_TABLE OldTable;
    PPOOL_TRACKER_TABLE NewTable;

retry:

    //
    // Compute hash index and search for pool tag.
    //

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    Hash = ((40543*((((((((PUCHAR)&Key)[0]<<2)^((PUCHAR)&Key)[1])<<2)^((PUCHAR)&Key)[2])<<2)^((PUCHAR)&Key)[3]))>>2) & (ULONG)PoolTrackTableMask;
    Index = Hash;

    do {
        if (PoolTrackTable[Hash].Key == Key) {
            PoolTrackTable[Hash].Key = Key;
            goto EntryFound;
        }

        if (PoolTrackTable[Hash].Key == 0 && Hash != PoolTrackTableSize - 1) {
            PoolTrackTable[Hash].Key = Key;
            goto EntryFound;
        }

        Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;
    } while (Hash != Index);

    //
    // No matching entry and no free entry was found.
    // If the overflow bucket has been used then expansion of the tracker table
    // is not allowed because a subsequent free of a tag can go negative as the
    // original allocation is in overflow and a newer allocation may be
    // distinct.
    //

    NewSize = ((PoolTrackTableSize - 1) << 1) + 1;
    NewSizeInBytes = NewSize * sizeof(POOL_TRACKER_TABLE);

    SizeInBytes = PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE);

    if ((NewSizeInBytes > SizeInBytes) &&
        (PoolTrackTable[PoolTrackTableSize - 1].Key == 0)) {

        NewTable = DmpAllocatePoolMemory (NewSizeInBytes);

        if (NewTable != NULL) {

            OldTable = (PVOID)PoolTrackTable;

            KdPrint(("DMPOOL:grew track table (%p, %p, %p)\n",
                OldTable,
                PoolTrackTableSize,
                NewTable));

            RtlZeroMemory ((PVOID)NewTable, NewSizeInBytes);

            //
            // Rehash all the entries into the new table.
            //

            NewSizeMask = NewSize - 2;

            for (OriginalHash = 0; OriginalHash < PoolTrackTableSize; OriginalHash += 1) {
                OriginalKey = PoolTrackTable[OriginalHash].Key;

                if (OriginalKey == 0) {
                    continue;
                }

                Hash = (ULONG)((40543*((((((((PUCHAR)&OriginalKey)[0]<<2)^((PUCHAR)&OriginalKey)[1])<<2)^((PUCHAR)&OriginalKey)[2])<<2)^((PUCHAR)&OriginalKey)[3]))>>2) & (ULONG)NewSizeMask;
                Index = Hash;

                HashedIt = FALSE;
                do {
                    if (NewTable[Hash].Key == 0 && Hash != NewSize - 1) {
                        RtlCopyMemory ((PVOID)&NewTable[Hash],
                                       (PVOID)&PoolTrackTable[OriginalHash],
                                       sizeof(POOL_TRACKER_TABLE));
                        HashedIt = TRUE;
                        break;
                    }

                    Hash = (Hash + 1) & (ULONG)NewSizeMask;
                } while (Hash != Index);

                //
                // No matching entry and no free entry was found, have to bail.
                //

                if (HashedIt == FALSE) {
                    KdPrint(("DMPOOL:rehash of track table failed (%p, %p, %p %p)\n",
                        OldTable,
                        PoolTrackTableSize,
                        NewTable,
                        OriginalKey));

                    DmpFreePoolMemory (NewTable, 0);
                    goto overflow;
                }
            }

            PoolTrackTable = NewTable;
            PoolTrackTableSize = NewSize;
            PoolTrackTableMask = NewSizeMask;

            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

            BigPages = DmpFreePoolMemory (OldTable, 0);

            ExpRemovePoolTracker ('looP', BigPages * PAGE_SIZE);

            ExpInsertPoolTracker ('looP', (ULONG) ROUND_TO_PAGES(NewSizeInBytes));

            goto retry;
        }
    }

overflow:

    //
    // Use the very last entry as a bit bucket for overflows.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

    PoolTrackTable[Hash].Key = 'lfvO';

    //
    // Update pool tracker table entry.
    //

EntryFound:

    PoolTrackTable[Hash].NonPagedAllocs += 1;
    PoolTrackTable[Hash].NonPagedBytes += Size;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return;
}

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN ULONG Size
    )

/*++

Routine Description:

    This function increments the number of frees and updates the total
    allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    Size - Supplies the allocation size.

Return Value:

    None.

--*/

{
    ULONG Hash;
    ULONG Index;
    KIRQL OldIrql;

    //
    // Compute hash index and search for pool tag.
    //

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    Hash = ((40543*((((((((PUCHAR)&Key)[0]<<2)^((PUCHAR)&Key)[1])<<2)^((PUCHAR)&Key)[2])<<2)^((PUCHAR)&Key)[3]))>>2) & (ULONG)PoolTrackTableMask;
    Index = Hash;

    do {
        if (PoolTrackTable[Hash].Key == Key) {
            goto EntryFound;
        }

        if (PoolTrackTable[Hash].Key == 0 && Hash != PoolTrackTableSize - 1) {
            KdPrint(("DMPOOL: Unable to find tracker %lx, table corrupted\n", Key));
            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
            return;
        }

        Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;
    } while (Hash != Index);

    //
    // No matching entry and no free entry was found.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

    //
    // Update pool tracker table entry.
    //

EntryFound:

    PoolTrackTable[Hash].NonPagedBytes -= Size;
    PoolTrackTable[Hash].NonPagedFrees += 1;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return;
}

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages
    )
/*++

Routine Description:

    This function inserts a pool tag in the big page tag table.

Arguments:

    Va - Supplies the allocated virtual address.

    Key - Supplies the key value used to locate a matching entry in the
        tag table.

    NumberOfPages - Supplies the number of pages that were allocated.

Return Value:

    TRUE if an entry was allocated, FALSE if not.

Environment:

    No pool locks held so the table may be freely expanded here as needed.

--*/
{
    ULONG Hash;
    ULONG BigPages;
    PVOID OldTable;
    LOGICAL Inserted;
    KIRQL OldIrql;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    PPOOL_TRACKER_BIG_PAGES NewTable;
    PPOOL_TRACKER_BIG_PAGES p;

retry:

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);
    while ((LONG_PTR)PoolBigPageTable[Hash].Va < 0) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {

                //
                // Try to expand the tracker table.
                //

                SizeInBytes = PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES);
                NewSizeInBytes = (SizeInBytes << 1);

                if (NewSizeInBytes > SizeInBytes) {
                    NewTable = DmpAllocatePoolMemory (NewSizeInBytes);

                    if (NewTable != NULL) {
    
                        OldTable = (PVOID)PoolBigPageTable;

                        KdPrint(("DMPOOL:grew big table (%p, %p, %p)\n",
                            OldTable,
                            PoolBigPageTableSize,
                            NewTable));

                        RtlCopyMemory ((PVOID)NewTable,
                                       OldTable,
                                       SizeInBytes);

                        RtlZeroMemory ((PVOID)(NewTable + PoolBigPageTableSize),
                                       NewSizeInBytes - SizeInBytes);

                        PoolBigPageTable = NewTable;
                        PoolBigPageTableSize <<= 1;
                        PoolBigPageTableHash = PoolBigPageTableSize - 1;

                        ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

                        BigPages = DmpFreePoolMemory (OldTable, 0);

                        ExpRemovePoolTracker ('looP',
                                              BigPages * PAGE_SIZE);

                        ExpInsertPoolTracker ('looP',
                                              (ULONG) ROUND_TO_PAGES(NewSizeInBytes));

                        goto retry;
                    }
                }

                if (!FirstPrint) {
                    KdPrint(("DMPOOL:unable to insert big page slot %lx\n",Key));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
                return FALSE;
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    p = &PoolBigPageTable[Hash];

    ASSERT ((LONG_PTR)Va < 0);

    p->Va = Va;
    p->Key = Key;
    p->NumberOfPages = NumberOfPages;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return TRUE;
}

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va
    )
{
    ULONG Hash;
    LOGICAL Inserted;
    KIRQL OldIrql;
    ULONG ReturnKey;

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);
    while (PoolBigPageTable[Hash].Va != Va) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {
                if (!FirstPrint) {
                    KdPrint(("DMPOOL:unable to find big page slot %lx\n",Va));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
                return ' GIB';
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    ASSERT ((LONG_PTR)Va < 0);
    (ULONG_PTR)PoolBigPageTable[Hash].Va &= MAXLONG_PTR;

    ReturnKey = PoolBigPageTable[Hash].Key;
    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
    return ReturnKey;
}

VOID
DmFreePool(
    IN PVOID P
    )
/*++

Routine Description:

    This function deallocates a block of pool. This function is used to
    deallocate to both the page aligned pools and the buddy (less than
    a page) pools.

    If the address of the block being deallocated is page-aligned, then
    the page-aligned pool deallocator is used.

    Otherwise, the binary buddy pool deallocator is used.  Deallocation
    looks at the allocated block's pool header to determine the pool
    type and block size being deallocated.  If the pool was allocated
    using ExAllocatePoolWithQuota, then after the deallocation is
    complete, the appropriate process's pool quota is adjusted to reflect
    the deallocation, and the process object is dereferenced.

Arguments:

    P - Supplies the address of the block of pool being deallocated.

Return Value:

    None.

--*/
{
    PPOOL_HEADER Entry;
    ULONG Index;
    KIRQL LockHandle;
    PPOOL_LOOKASIDE_LIST LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_DESCRIPTOR PoolDesc = &DmPoolDescriptor;
    LOGICAL Combined;
    ULONG BigPages;
    ULONG Tag;

    if(!FIsDmPool(P)) {
        DbgPrint("DmFreePool called for %08x\n", P);
        DmExFreePool(P);
        return;
    }

    //
    // If entry is page aligned, then call free block to the page aligned
    // pool. Otherwise, free the block to the allocation lists.
    //

    if (PAGE_ALIGNED(P)) {

        ASSERT_FREE_IRQL(P);

        if (PoolTrackTable != NULL) {
            Tag = ExpFindAndRemoveTagBigPages(P);
        }

        LOCK_POOL(LockHandle);

        PoolDesc->RunningDeAllocs += 1;

        BigPages = DmpFreePoolMemory(P, 0);

        if (PoolTrackTable != NULL) {
            ExpRemovePoolTracker(Tag, BigPages * PAGE_SIZE);
        }

        //
        // Check if a KTIMER is currently active in this memory block
        //

        FREE_CHECK_KTIMER(P, BigPages << PAGE_SHIFT);

        PoolDesc->TotalBigPages -= BigPages;

        UNLOCK_POOL(LockHandle);

        return;
    }

    //
    // Align the entry address to a pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

    ASSERT_POOL_NOT_FREE(Entry);

    ASSERT_FREE_IRQL(P);

    if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
        KeBugCheckEx (BAD_POOL_CALLER, 7, __LINE__, (ULONG_PTR)Entry, (ULONG_PTR)P);
    }

    MARK_POOL_HEADER_FREED(Entry);

    ASSERT_POOL_TYPE_NOT_ZERO(Entry);

    //
    // Check if a KTIMER is currently active in this memory block.
    //

    FREE_CHECK_KTIMER(Entry, (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));

    //
    // If pool tagging is enabled, then update the pool tracking database.
    // Otherwise, check to determine if quota was charged when the pool
    // block was allocated.
    //

    if (PoolTrackTable != NULL) {
        Tag = Entry->PoolTag;
        ExpRemovePoolTracker(Tag, Entry->BlockSize << POOL_BLOCK_SHIFT);
    }

    //
    // If the pool block is a small block, then attempt to free the block
    // to the single entry lookaside list. If the free attempt fails, then
    // free the block by merging it back into the pool data structures.
    //

    Index = Entry->BlockSize;

    if (Index <= POOL_SMALL_LISTS) {

        //
        // Attempt to free the small block to a per processor lookaside
        // list.
        //

        LookasideList = &ExpSmallDmPoolLookasideLists[Index - 1];

        CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

        if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
            Entry += 1;
            InterlockedPushEntrySList(&LookasideList->ListHead,
                                      (PSINGLE_LIST_ENTRY)Entry);

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

            return;
        }
    }

    LOCK_POOL(LockHandle);

    CHECK_POOL_HEADER(__LINE__, Entry);

    PoolDesc->RunningDeAllocs += 1;

    //
    // Free the specified pool block.
    //
    // Check to see if the next entry is free.
    //

    Combined = FALSE;
    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
    if (PAGE_END(NextEntry) == FALSE) {

        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)), P);
            PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink), P);
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink), P);

            Entry->BlockSize += NextEntry->BlockSize;
        }
    }

    //
    // Check to see if the previous entry is free.
    //

    if (Entry->PreviousSize != 0) {
        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)), P);
            PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink), P);
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink), P);

            NextEntry->BlockSize += Entry->BlockSize;
            Entry = NextEntry;
        }
    }

    //
    // If the block being freed has been combined into a full page,
    // then return the free page to memory management.
    //

    if (PAGE_ALIGNED(Entry) &&
        (PAGE_END((PPOOL_BLOCK)Entry + Entry->BlockSize) != FALSE)) {

        DmpFreePoolMemory(Entry, 0);

        PoolDesc->TotalPages -= 1;

    } else {

        //
        // Insert this element into the list.
        //

        Entry->PoolType = 0;
        Index = Entry->BlockSize;

        //
        // If the freed block was combined with any other block, then
        // adjust the size of the next block if necessary.
        //

        if (Combined != FALSE) {

            //
            // The size of this entry has changed, if this entry is
            // not the last one in the page, update the pool block
            // after this block to have a new previous allocation size.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
            if (PAGE_END(NextEntry) == FALSE) {
                NextEntry->PreviousSize = Entry->BlockSize;
            }

            //
            // Reduce fragmentation and insert at the tail in hopes
            // neighbors for this will be freed before this is reallocated.
            //

            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), P);

        } else {

            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            PrivateInsertHeadList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), P);
        }
    }

    UNLOCK_POOL(LockHandle);
}

ULONG
DmQueryPoolBlockSize (
    IN PVOID PoolBlock
    )

/*++

Routine Description:

    This function returns the size of the pool block.

Arguments:

    PoolBlock - Supplies the address of the block of pool.

Return Value:

    Size of pool block.

--*/

{
    PPOOL_HEADER Entry;
    ULONG size;

    if (PAGE_ALIGNED(PoolBlock)) {
        return MmQueryAllocationSize(PoolBlock);
    }

    //
    // Align entry on pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)PoolBlock - POOL_OVERHEAD);
    size = (ULONG)((Entry->BlockSize << POOL_BLOCK_SHIFT) - POOL_OVERHEAD);

    return size;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmprofil.c ===
/*
 *
 * dmprofil.c
 *
 * Profile objects
 *
 */

#include "dmp.h"

// Profile object
typedef struct _POB {
    LIST_ENTRY le;
    ULONG ulNext;
    int iulInterval;
    PDMPROFILE_HANDLER pfn;
} POB, *PPOB;

void DeletePob(PVOID);
extern KEVENT kevtNull;
OBJECT_TYPE obtPob = { DmAllocatePoolWithTag, DmFreePool, NULL, DeletePob, NULL, &kevtNull, 'opmd' };
LIST_ENTRY lePobHead = { &lePobHead, &lePobHead };
BOOL g_fResetInterval;
ULONG ulNextProfInt;
ULONG ulCurProfBase;
ULONG rgulIntervalTable[] =
{
        1221,
        2441,
        4883,
        9766,
       19531,
       39063,
       78125,
      156250,
      312500,
      625000,
     1250000,
     2500000,
     5000000,
     5000000 | 0x80000000
};

void QueuePob(PPOB ppob)
{
    ULONG ulNext;
    PLIST_ENTRY ple;
    PPOB ppobBefore;
    BOOL fStart;

    /* Dequeue if already on the list */
    _asm cli
    if(ppob->le.Flink) {
        RemoveEntryList(&ppob->le);
    }
    _asm sti

    /* Start the profile interrupt or reset the profile interval if
     * necessary */
    ulNext = 1 << ppob->iulInterval;
    fStart = ulCurProfBase == 0;
    if(fStart || ulNext < ulCurProfBase) {
        g_dmi.HalProfileIntervalRoutine(rgulIntervalTable[ppob->iulInterval]);
        ulCurProfBase = ulNext;
        if(fStart)
            g_dmi.HalStartProfileRoutine(0);
    }

    /* Now set the time to fire and queue */
    _asm cli
    ppob->ulNext = ulNextProfInt + ulNext;
    ple = lePobHead.Flink;
    while(ple != &lePobHead) {
        ppobBefore = CONTAINING_RECORD(ple, POB, le);
        if((int)(ppob->ulNext - ppobBefore->ulNext) < 0)
            /* Here's where we insert */
            break;
        ple = ple->Flink;
    }
    /* ple now points to the following entry or to the list head if we go at
     * the end */
    ppob->le.Flink = ple;
    ppob->le.Blink = ple->Blink;
    ple->Blink->Flink = &ppob->le;
    ple->Blink = &ppob->le;
    _asm sti
}

void DeletePob(PVOID pv)
{
    PPOB ppob = (PPOB)pv;
    KIRQL irqlSav = KeRaiseIrqlToDpcLevel();

    /* Dequeue this guy */
    _asm {
        pushfd
        cli
    }
    RemoveEntryList(&ppob->le);
    _asm popfd

    /* If the list is now empty, end the interrupt */
    if(lePobHead.Flink == &lePobHead) {
        g_dmi.HalStopProfileRoutine(0);
        ulCurProfBase = 0;
    } else if(1 << ppob->iulInterval == ulCurProfBase) {
        /* May need to change the interval, but we need to wait until the next
         * scheduled interrupt is sent so we keep the interrupt chain timed
         * correctly */
        PLIST_ENTRY ple;
        _asm {
            pushfd
            cli
        }
        g_fResetInterval = 32;
        for(ple = lePobHead.Flink; ple != &lePobHead; ple = ple->Flink) {
            ppob = CONTAINING_RECORD(ple, POB, le);
            if(ppob->iulInterval < g_fResetInterval)
                g_fResetInterval = ppob->iulInterval + 1;
        }
        _asm popfd
    }
    KeLowerIrql(irqlSav);
}

HRESULT DmStartProfile(PHANDLE ph, ULONG ulInterval, PDMPROFILE_HANDLER pfn)
{
    PPOB ppob;
    NTSTATUS st;
    int iul;

    st = ObCreateObject(&obtPob, NULL, sizeof(POB), &ppob);
    if(!NT_SUCCESS(st))
        return HrFromStatus(st, E_FAIL);
    RtlZeroMemory(ppob, sizeof *ppob);
    
    /* Make sure we can get a handle for this guy */
    st = ObOpenObjectByPointer(ppob, &obtPob, ph);
    if(!NT_SUCCESS(st)) {
        ObDereferenceObject(ppob);
        return HrFromStatus(st, E_FAIL);
    }
    
    /* Find an interval to fire on */
    ulInterval &= 0x7fffffff;
    for(iul = 0; (int)rgulIntervalTable[iul] >= 0; ++iul) {
        if(ulInterval <= rgulIntervalTable[iul])
            break;
    }
    if(iul) {
        /* See whether greater or smaller interval is closest */
        if(rgulIntervalTable[iul] - ulInterval >
                ulInterval - rgulIntervalTable[iul - 1])
            --iul;
    }
    if((int)rgulIntervalTable[iul] < 0)
        --iul;
    ppob->iulInterval = iul;
    ppob->pfn = pfn;

    /* Queue the object and return */
    ObDereferenceObject(ppob);
    QueuePob(ppob);
    return XBDM_NOERR;
}

HRESULT DmStopProfile(HANDLE h)
{
    PPOB ppob;
    NTSTATUS st;

    /* If we're at raised irql (like inside the ISR), this isn't going to
     * work */
    if(KeGetCurrentIrql() > DISPATCH_LEVEL)
        return E_FAIL;
    st = NtClose(h);
    return NT_SUCCESS(st) ? XBDM_NOERR : HrFromStatus(st, E_FAIL);
}

void ProfInt(PKTRAP_FRAME ptf)
{
	DMN_PROFINT dmpi;
    PLIST_ENTRY ple;
    BOOL fReset;

	dmpi.SegCs = (USHORT)ptf->SegCs;
    dmpi.EFlags = ptf->EFlags;
	dmpi.Eip = ptf->Eip;
    
    /* Walk the list of installed interrupt handlers and call anybody who's
     * due */
    ple = lePobHead.Flink;
    while(ple != &lePobHead) {
        PPOB ppob = CONTAINING_RECORD(ple, POB, le);
        if((int)(ppob->ulNext - ulNextProfInt) > 0)
            /* Nobody else due */
            break;
        ple = ple->Flink;
        if(ppob->ulNext == ulNextProfInt) {
            if(g_fResetInterval) {
                g_dmi.HalProfileIntervalRoutine(rgulIntervalTable[g_fResetInterval -
                    1]);
                ulCurProfBase = 1 << (g_fResetInterval - 1);
                g_fResetInterval = 0;
            }
            ppob->pfn(&dmpi);
            QueuePob(ppob);
        }
    }

    /* Update our interrupt time */
    ulNextProfInt += ulCurProfBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmserv.c ===
/*
 *
 * dmserv.c
 *
 * The debug monitor server
 *
 */

#include "dmp.h"
#include "xboxp.h"
#include "xconfig.h"
#include "av.h"
#include "xlaunch.h"
#undef DeleteFile
#include "d3d8.h"

void ShowIPAddress(ULONG);
DWORD DedicatedServThread(LPVOID lpv);

RTL_CRITICAL_SECTION csEch;
RTL_CRITICAL_SECTION csAccept;
CST rgcst[MAX_CONNECTIONS];
const char rgchHex[] = "0123456789ABCDEF";
char rgchDbgName[256];
ULONG ulIpAddr;
BOOL g_fServShutdown;
BOOL g_fDebugging;
BOOL g_fLockLevel;
BOOL g_fDebugSecureMode;// = TRUE;
ULARGE_INTEGER g_luBoxId;
KEVENT kevtServ;
PETHREAD pthrServ;
extern CHH rgchh[];
extern int cchh;

INITIALIZED_OBJECT_STRING_RDATA(ostDash, "\\Device\\Harddisk0\\Partition1\\DASHBOARD.XBX");
CHAR XdkLauncherPathname[] = "\\Device\\Harddisk0\\Partition2\\xshell.xbe";

/* Extension stuff */
ECH *rgpech[MAX_ECH];

NTSTATUS
WINAPI
XWriteTitleInfoNoReboot(
    PCOSTR pszLaunchPath,
    PCOSTR pszDDrivePath,
    DWORD dwLaunchDataType,
    DWORD dwTitleId,
    PLAUNCH_DATA pLaunchData
    );

BOOL
WINAPI
XapiFormatFATVolume(
    POBJECT_STRING VolumePath
    );

void InitServ(void)
{
    InitializeCriticalSection(&csEch);
    InitializeCriticalSection(&csAccept);
    KeInitializeEvent(&kevtServ, NotificationEvent, FALSE);
}

void StopServ(void)
{
    int icst;
    PETHREAD pthr;

    /* Loop through the socket list and close each one down */
    EnterCriticalSection(&csAccept);
    g_fServShutdown = TRUE;
    for(icst = 0; icst < MAX_CONNECTIONS; ++icst) {
        if(rgcst[icst].s != INVALID_SOCKET) {
            /* If this socket isn't running on the current thread, it may be
             * inside of a select.  In that case, we take it off the thread,
             * stop the select, and give the thread a little bit of time to
             * exit the select */
            pthr = rgcst[icst].pthrDedicated;
            rgcst[icst].pthrDedicated = NULL;
            if(pthr != PsGetCurrentThread()) {
                KeAlertThread(&pthr->Tcb, KernelMode);
                Sleep(20);
            }
            shutdown(rgcst[icst].s, SD_SEND);
        }
    }
    LeaveCriticalSection(&csAccept);

    /* Wait for the sockets to close */
    Sleep(200);
}

int SgnCompareRgch(const char *sz1, const char *sz2, int cch)
{
    while(cch-- && *sz1) {
        char ch1 = *sz1++;
        char ch2 = *sz2++;
        if(ch1 >= 'a' && ch2 <= 'z')
            ch1 -= 32;
        if(ch2 >= 'a' && ch2 <= 'z')
            ch2 -= 32;
        if(ch1 != ch2)
            return ch1 - ch2;
    }
    if(*sz1)
        return *sz1;
    return cch < 0 ? 0 : -*sz2;
}

BOOL FEqualRgch(const char *sz1, const char *sz2, int cch)
{
    return SgnCompareRgch(sz1, sz2, cch) == 0;
}

DWORD DwHexFromSz(LPCSTR sz, LPCSTR *szOut)
{
    DWORD dw = 0;

    for(;;) {
        if(*sz >= '0' && *sz <= '9')
            dw = dw * 16 + (*sz - '0');
        else if(*sz >= 'A' && *sz <= 'F')
            dw = dw * 16 + (*sz - 'A' + 10);
        else if(*sz >= 'a' && *sz <= 'f')
            dw = dw * 16 + (*sz - 'a' + 10);
        else
            break;
        ++sz;
    }
    if(szOut)
        *szOut = sz;
    return dw;
}

DWORD DwFromSz(LPCSTR sz, int *pcchUsed)
{
    DWORD dw = 0;
    LPCSTR szStart = sz;

    /* Process decimal, octal, or hex */
    if(*sz == '0') {
        ++sz;
        if(*sz == 'x')
            dw = DwHexFromSz(++sz, &sz);
        else
            while(*sz >= '0' && *sz <= '7')
                dw = dw * 8 + (*sz++ - '0');
    } else
        while(*sz >= '0' && *sz <= '9')
            dw = dw * 10 + (*sz++ - '0');
    if(pcchUsed)
        *pcchUsed = sz - szStart;
    return dw;
}

void CloseConn(int icst)
{
    KIRQL irql;

    ASSERT(rgcst[icst].s != INVALID_SOCKET);
    closesocket(rgcst[icst].s);

    /* The server thread will attempt to read data from this socket once
     * pechDedicated is cleared, and may attempt to reuse this
     * connection state as soon as the socket ID is set to INVALID.  We
     * need to do all of this as one atomic operation */
    irql = KeRaiseIrqlToDpcLevel();
    rgcst[icst].dwStatus = 0;
    rgcst[icst].pechDedicated = NULL;
    rgcst[icst].pthrDedicated = NULL;
    rgcst[icst].s = INVALID_SOCKET;
    KeLowerIrql(irql);
}

void InitDmcc(int icst)
{
    rgcst[icst].dmcc.BytesRemaining = -1;
    rgcst[icst].dmcc.Buffer = NULL;
    rgcst[icst].dmcc.CustomData = &rgcst[icst].ccs;
    rgcst[icst].dmcc.HandlingFunction = NULL;
    rgcst[icst].dwStatus &= ~(CONN_BINARY | CONN_BINSEND | CONN_MULTILINE);
}

BOOL PrintSockLine(SOCKET s, LPCSTR sz)
{
    char szT[1024];
    int ich;

    for(ich = 0; sz[ich] && ich < sizeof szT - 2; ++ich)
        szT[ich] = sz[ich];

    if(sz[ich]) {
        /* Didn't get the whole string, so we have to send two packets */
        if(send(s, sz, strlen(sz), 0) <= 0)
            return FALSE;
        if(send(s, "\015\012", 2, 0) <= 0)
            return FALSE;
    } else {
        szT[ich++] = '\015';
        szT[ich++] = '\012';
        if(send(s, szT, ich, 0) <= 0)
            return FALSE;
    }
    return TRUE;
}

BOOL ReadSockLine(SOCKET s, char *sz, int cch)
{
    int cb;
    int ich = 0;

    --cch; /* save room for \0 */
    while(ich < cch) {
        cb = recv(s, &sz[ich], 1, 0);
        if(cb <= 0) {
            if(ich == 0)
                return FALSE;
            sz[ich] = 0;
            return TRUE;
        }
        if(sz[ich] == '\012') {
            sz[ich] = 0;
            return TRUE;
        }
        if(sz[ich] != '\015')
            ++ich;
    }
    sz[ich] = 0;
    return TRUE;
}

__inline BOOL FIsSpace(char ch)
{
    return ch == ' ' || ch == '\015' || ch == 0;
}

const char *PchGetParam(LPCSTR szCmd, LPCSTR szKey, BOOL fNeedValue)
{
    const char *pchTok;
    int cchTok;
    BOOL fQuote = FALSE;

    /* Skip the command */
    for(pchTok = szCmd; !FIsSpace(*pchTok); ++pchTok);

    while(*pchTok) {
        /* Skip leading spaces */
        while(*pchTok && FIsSpace(*pchTok))
            ++pchTok;
        if(!*pchTok)
            return NULL;
        for(cchTok = 0; !FIsSpace(pchTok[cchTok]); ++cchTok) {
            if(pchTok[cchTok] == '=') {
                if(FEqualRgch(szKey, pchTok, cchTok))
                    return pchTok + cchTok + 1; /* Skip the '=' */
                break;
            }
        }
        /* If we didn't see the '=' we need to check anyway */
        if(!fNeedValue && pchTok[cchTok] != '=' && FEqualRgch(szKey, pchTok,
                cchTok))
            return pchTok + cchTok;
        /* No match, so we need to skip past the value */
        pchTok += cchTok;
        while(*pchTok && (!FIsSpace(*pchTok) || fQuote))
            if(*pchTok++ == '"')
                fQuote = !fQuote;
    }
    return NULL;
}

int CchOfWord(LPCSTR sz)
{
    int cch;
    for(cch = 0; !FIsSpace(sz[cch]); ++cch);
    return cch;
}

void GetParam(LPCSTR szLine, LPSTR szBuf, int cchBuf)
{
    int cch = 0;
    BOOL fQuote = FALSE;

    while(cch < cchBuf-1 && *szLine && (!FIsSpace(*szLine) || fQuote)) {
        if(*szLine == '"') {
            if(fQuote && szLine[1] == '"') {
                /* Double quote inside a string gets copied as a single
                 * quote */
                szBuf[cch++] = '"';
                szLine += 2;
            } else {
                fQuote = !fQuote;
                ++szLine;
            }
        } else
            szBuf[cch++] = *szLine++;
    }
    szBuf[cch] = 0;
}

BOOL FGetSzParam(LPCSTR szLine, LPCSTR szKey, LPSTR szBuf, int cchBuf)
{
    LPCSTR pch = PchGetParam(szLine, szKey, TRUE);
    if(!pch)
        return FALSE;
    GetParam(pch, szBuf, cchBuf);
    return TRUE;
}

BOOL FGetDwParam(LPCSTR szLine, LPCSTR szKey, DWORD *pdw)
{
    int cch;
    char sz[32];
    LPCSTR pch = PchGetParam(szLine, szKey, TRUE);
    if(!pch)
        return FALSE;
    GetParam(pch, sz, sizeof sz);
    *pdw = DwFromSz(sz, &cch);
    return FIsSpace(sz[cch]);
}

BOOL FGetQwordParam(LPCSTR szLine, LPCSTR szKey, ULARGE_INTEGER *plu)
{
    int cch;
    char sz[32];
    LPCSTR pch;

    pch = PchGetParam(szLine, szKey, TRUE);
    if(!pch)
        return FALSE;
    GetParam(pch, sz, sizeof sz - 1);
    sz[sizeof sz - 1] = 0;

    /* Verify the 0q prefix */
    if(sz[0] != '0' || sz[1] != 'q')
        return FALSE;
    /* Make sure we have a bunch of hex characters */
    for(cch = 2; cch < sizeof sz && !FIsSpace(sz[cch]); ++cch) {
        if(!(sz[cch] >= '0' && sz[cch] <= '9' ||
                sz[cch] >= 'A' && sz[cch] <= 'F' ||
                sz[cch] >= 'a' && sz[cch] <= 'f'))
            return FALSE;
    }
    cch -= 2;
    if(cch <= 0)
        return FALSE;

    /* Move the text out to the end of the string and fill the preceding
     * characters with zeroes */
    memmove(&sz[sizeof sz - 1 - cch], &sz[2], cch);
    memset(sz, '0', sizeof sz - 1 - cch);

    /* Now parse out the two dwords */
    plu->LowPart = DwHexFromSz(&sz[sizeof sz - 9], NULL);
    sz[sizeof sz - 9] = 0;
    plu->HighPart = DwHexFromSz(&sz[sizeof sz - 17], NULL);
    return TRUE;
}

BOOL FGetNamedDwParam(LPCSTR szLine, LPCSTR szKey, DWORD *pdw, LPSTR szResp)
{
    if(!FGetDwParam(szLine, szKey, pdw)) {
        sprintf(szResp, "missing %s", szKey);
        return FALSE;
    }
    return TRUE;
}

ULONG UlAddrFromSz(LPCSTR sz)
{
    ULONG ul;
    int ib;
    int ich;

    for(ib = 0; ib < 4; ++ib) {
        BYTE b = 0;

        for(ich = 0; ich < 3; ++ich) {
            if(sz[ich] < '0' || sz[ich] > '9')
                break;
            b = 10 * b + (sz[ich] - '0');
        }
        if(ich == 0 || sz[ich] != (ib == 3 ? 0 : '.'))
            return 0;
        sz += ich + 1;
        ((BYTE *)&ul)[ib ^ 3] = b;
    }
    return ul;
}

LPCSTR SzStdResponse(HRESULT hr)
{
    LPCSTR pszResp;

    switch(hr) {
    case XBDM_NOSUCHFILE:
        pszResp = "file not found";
        break;
    case XBDM_NOMODULE:
        pszResp = "no such module";
        break;
    case XBDM_MEMUNMAPPED:
        pszResp = "memory not mapped";
        break;
    case XBDM_NOTHREAD:
        pszResp = "no such thread";
        break;
    case XBDM_INVALIDCMD:
        pszResp = "unknown command";
        break;
    case XBDM_NOTSTOPPED:
        pszResp = "not stopped";
        break;
    case XBDM_MUSTCOPY:
        pszResp = "file must be copied";
        break;
    case XBDM_ALREADYEXISTS:
        pszResp = "file already exists";
        break;
    case XBDM_DIRNOTEMPTY:
        pszResp = "directory not empty";
        break;
    case XBDM_BADFILENAME:
        pszResp = "filename is invalid";
        break;
    case XBDM_CANNOTCREATE:
        pszResp = "file cannot be created";
        break;
    case XBDM_DEVICEFULL:
        pszResp = "no room on device";
        break;
    case XBDM_MULTIRESPONSE:
        pszResp = "multiline response follows";
        break;
    case XBDM_BINRESPONSE:
        pszResp = "binary response follows";
        break;
    case XBDM_READYFORBIN:
        pszResp = "send binary data";
        break;
    case XBDM_CANNOTACCESS:
        pszResp = "access denied";
        break;
    case XBDM_NOTDEBUGGABLE:
        pszResp = "not debuggable";
        break;
    case XBDM_BADCOUNTTYPE:
        pszResp = "type invalid";
        break;
    case XBDM_COUNTUNAVAILABLE:
        pszResp = "data not available";
        break;
    case XBDM_NOTLOCKED:
        pszResp = "box is not locked";
        break;
    case XBDM_KEYXCHG:
        pszResp = "key exchange required";
        break;
    case XBDM_MUSTBEDEDICATED:
        pszResp = "dedicated connection required";
        break;
    case E_OUTOFMEMORY:
        pszResp = "out of memory";
        break;
    case E_UNEXPECTED:
        pszResp = "unexpected error";
        break;
    case E_INVALIDARG:
        pszResp = "bad parameter";
        break;
    case XBDM_NOERR:
        pszResp = "OK";
        break;
    default:
        pszResp = "";
        break;
    }
    return pszResp;
}

HRESULT HrFromStatus(NTSTATUS st, HRESULT hrDefault)
{
    switch(st) {
    case STATUS_DIRECTORY_NOT_EMPTY:
        return XBDM_DIRNOTEMPTY;
    case STATUS_OBJECT_NAME_COLLISION:
        return XBDM_ALREADYEXISTS;
    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_OBJECT_NAME_NOT_FOUND:
        return XBDM_NOSUCHFILE;
    case STATUS_OBJECT_PATH_INVALID:
    case STATUS_OBJECT_NAME_INVALID:
        return XBDM_BADFILENAME;
    case STATUS_ACCESS_DENIED:
        return XBDM_CANNOTACCESS;
    case STATUS_DISK_FULL:
        return XBDM_DEVICEFULL;
    case STATUS_INSUFFICIENT_RESOURCES:
        return E_OUTOFMEMORY;
    case STATUS_INVALID_HANDLE:
        return E_INVALIDARG;
    }
    return hrDefault;
}

ULONG DmplOfConnection(PDM_CMDCONT pdmcc)
{
    if(!pdmcc)
        return -1;
    return rgcst[(PCST)pdmcc - rgcst].dmplCur;
}

BOOL FDedicateConnection(int icst, PECH pech)
{
    PETHREAD pthrExpect;
    HANDLE hthrNew;
    PVOID pfnCreateThread;

    pthrExpect = rgcst[icst].pthrDedicated;

    /* We should only be rededicating a connection running on the current
     * thread */
    if(PsGetCurrentThread() != pthrExpect) {
        DbgPrint("dm: rededicating a connection on the wrong thread!\n");
        return FALSE;
    }

    /* Create the new thread */
    if(pech) {
        pfnCreateThread = pech->pfnCreateThread;
        if(!pfnCreateThread)
            pfnCreateThread = CreateThread;
        hthrNew = (*(HANDLE (*)())pfnCreateThread)(NULL, 0,
            DedicatedServThread, (LPVOID)icst, CREATE_SUSPENDED, NULL);
        if(!hthrNew)
            return FALSE;
    } else
        pfnCreateThread = NULL;

    /* Send the success message */
    PrintSockLine(rgcst[icst].s, "205- connection dedicated");

    /* Mark the connection state for the new thread.  We mark the thread ID
     * as NULL; dedicated threads will fill it in when they start */
    rgcst[icst].pthrDedicated = NULL;
    rgcst[icst].pechDedicated = pech;

    /* Wake up the new thread */
    if(pfnCreateThread) {
        NtResumeThread(hthrNew, NULL);
        CloseHandle(hthrNew);
    } else {
        rgcst[icst].pthrDedicated = pthrServ;
        KeAlertThread(&pthrServ->Tcb, KernelMode);
    }

    return TRUE;
}

void SendHrSzResp(SOCKET s, HRESULT hr, LPCSTR szResp, LPSTR szBuf)
{
    /* Make sure we have an error code we like */
    if(((hr >> 16) & 0x7fff) != FACILITY_XBDM) {
        hr = SUCCEEDED(hr) ? XBDM_NOERR : XBDM_UNDEFINED;
        if(!szResp)
            szResp = SzStdResponse(E_UNEXPECTED);
    } else if((hr & 0xffff) > 0xff)
        hr = XBDM_UNDEFINED;

    if(FAILED(hr))
        szBuf[0] = '4';
    else
        szBuf[0] = '2';
    szBuf[1] = (char) ('0' + (hr & 0xffff) / 10);   // overflow?
    szBuf[2] = (char) ('0' + (hr & 0xffff) % 10);
    szBuf[3] = '-';
    szBuf[4] = ' ';
    if(szResp != szBuf) {
        if(szResp)
            strcpy(szBuf + 5, szResp);
        else
            szBuf[5] = 0;
    }
    PrintSockLine(s, szBuf);
}

HRESULT HrHandleBuiltinCommand(DWORD dmplCur, LPCSTR sz, int cchCmd,
    LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    int ichhMin, ichhMac, ichhMid;
    int sgn;
    BOOL fPermitted;

    ichhMin = 0;
    ichhMac = cchh;

    while(ichhMin < ichhMac) {
        ichhMid = (ichhMin + ichhMac) / 2;
        sgn = SgnCompareRgch(rgchh[ichhMid].szCommand, sz, cchCmd);
        if(sgn == 0)
            break;
        else if(sgn < 0)
            ichhMin = ichhMid + 1;
        else
            ichhMac = ichhMid;
    }

    if(ichhMin < ichhMac) {
        /* Check for appropriate permission */
        if(rgchh[ichhMid].dmplCombined)
            fPermitted = (dmplCur & rgchh[ichhMid].dmplCombined) ==
                rgchh[ichhMid].dmplCombined;
        else if(rgchh[ichhMid].dmplMask)
            fPermitted = dmplCur & rgchh[ichhMid].dmplMask;
        else
            fPermitted = TRUE;
        if(fPermitted) {
            /* Make sure we're running on the right thread */
            if(!pthrServ || PsGetCurrentThread() == pthrServ ||
                (rgchh[ichhMid].dwFlags & CHH_ANYTHREAD))
            {
                hr = (*rgchh[ichhMid].pfnHandler)(sz, szResp, cchResp, pdmcc);
            } else
                hr = XBDM_MUSTBEDEDICATED;
        } else
            hr = XBDM_CANNOTACCESS;
    } else
        hr = XBDM_INVALIDCMD;
    return hr;
}

void DoSendReceive(int icst, BOOL fSend)
{
    HRESULT hr;
    SOCKET s = rgcst[icst].s;
    char szBuf[256];
    char szResp[256];

    if(!rgcst[icst].dmcc.Buffer) {
        *szBuf = 0;
        rgcst[icst].dmcc.Buffer = szBuf;
        rgcst[icst].dmcc.BufferSize = sizeof szBuf;
    }
    szResp[0] = 0;
    if(!fSend) {
        int cb;
        /* We need to receive data.  First, we attempt to take it from our
         * command receive buffer */
        cb = rgcst[icst].dwStatus & CONN_RECEIVED;
        if(cb) {
            int ib;
            int ibT;

            ib = cb;
            if((DWORD)cb > rgcst[icst].dmcc.BytesRemaining)
                ib = rgcst[icst].dmcc.BytesRemaining;
            if((DWORD)cb > rgcst[icst].dmcc.BufferSize)
                ib = rgcst[icst].dmcc.BufferSize;
            if(ib) {
                rgcst[icst].dmcc.DataSize = ib;
                memcpy(rgcst[icst].dmcc.Buffer, rgcst[icst].szBuf, ib);
                for(ibT = 0; ib < cb; )
                    rgcst[icst].szBuf[ibT++] = rgcst[icst].szBuf[ib++];
                rgcst[icst].dwStatus = (rgcst[icst].dwStatus &
                    ~CONN_RECEIVED) | ibT;
            } else
                rgcst[icst].dmcc.DataSize = 0;
        } else {
            /* Receive as much data as we can */
            cb = rgcst[icst].dmcc.BufferSize;
            if((DWORD)cb > rgcst[icst].dmcc.BytesRemaining)
                cb = rgcst[icst].dmcc.BytesRemaining;
            if(cb) {
                cb = recv(s, rgcst[icst].dmcc.Buffer, cb, 0);
                if(cb <= 0) {
                    /* Socket is gone, so clean up and flag an error */
                    cb  = 0;
                    CloseConn(icst);
                }
            }
            rgcst[icst].dmcc.DataSize = cb;
        }
    }
    hr = rgcst[icst].dmcc.HandlingFunction(&rgcst[icst].dmcc, szResp,
        sizeof szResp);
    if(fSend) {
        if(SUCCEEDED(hr)) {
            if(rgcst[icst].dmcc.DataSize == -1) {
                /* We have a string to send, so send it */
                PrintSockLine(s, rgcst[icst].dmcc.Buffer);
            } else if(rgcst[icst].dmcc.DataSize) {
                /* We have data to send, so send it */
                int cbSend = rgcst[icst].dmcc.DataSize;
                while(cbSend) {
                    int cbSent = send(s, (PBYTE)rgcst[icst].dmcc.Buffer +
                        rgcst[icst].dmcc.DataSize - cbSend, cbSend, 0);
                    if(cbSent <= 0) {
                        /* A send error occurred, so close the connection and
                         * tell the handling function we can accept no more
                         * data */
                        rgcst[icst].dmcc.BytesRemaining = 0;
                        rgcst[icst].dmcc.HandlingFunction(&rgcst[icst].dmcc,
                            szResp, sizeof szResp);
                        CloseConn(icst);
                        break;
                    } else
                        cbSend -= cbSent;
                }
            }
        } else if(hr == XBDM_ENDOFLIST) {
            /* We're out of data, so send end-of-data if appropriate and go
             * back to text mode */
            if(rgcst[icst].dwStatus & CONN_MULTILINE)
                PrintSockLine(s, ".");
            InitDmcc(icst);
        } else {
            /* An unexpected error has occurred.  Forcibly terminate the
             * connection */
            CloseConn(icst);
        }
    } else if(rgcst[icst].dmcc.BytesRemaining == 0) {
        /* If we've reached the end of our data stream, we can give the
         * appropriate response */
        LPCSTR pszResp;

        /* We may have an extended response, in which case we need to
         * prepare for it */
        rgcst[icst].dwStatus &= ~CONN_BINARY;
        rgcst[icst].dmcc.BytesRemaining = -1;
        switch(hr) {
        case XBDM_MULTIRESPONSE:
            rgcst[icst].dwStatus |= CONN_MULTILINE;
            rgcst[icst].dmcc.DataSize = -1;
            break;
        case XBDM_BINRESPONSE:
            rgcst[icst].dwStatus |= CONN_BINSEND;
            break;
        default:
            InitDmcc(icst);
            break;
        }
        if(rgcst[icst].dwStatus & (CONN_MULTILINE | CONN_BINSEND | CONN_BINARY) &&
            !rgcst[icst].dmcc.HandlingFunction)
        {
            /* We gotta fail this */
            hr = E_UNEXPECTED;
            rgcst[icst].dwStatus &= ~(CONN_MULTILINE | CONN_BINSEND | CONN_BINARY);
            szResp[0] = 0;
        }

        pszResp = szResp[0] ? szResp : SzStdResponse(hr);
        SendHrSzResp(s, hr, pszResp, szBuf);
    }

    if(rgcst[icst].dmcc.Buffer == szBuf)
        rgcst[icst].dmcc.Buffer = NULL;
}

PECH PechFindHandler(LPCSTR sz, int cch)
{
    int iech;

    /* Look up the command processor */
    for(iech = 0; iech < MAX_ECH; ++iech) {
        if(rgpech[iech] && FEqualRgch(rgpech[iech]->szExtName, sz, cch))
            return rgpech[iech];
    }
    return NULL;
}

void HandleCommand(int icst, LPCSTR sz)
{
    int cchCmd = CchOfWord(sz);
    HRESULT hr = 0;
    int ich;
    char szResp[512];
    LPCSTR pszResp;
    PDM_CMDCONT pdmcc;
    DWORD dmplCur;
    PECH pech = NULL;

    /* Make sure we're prepared to call this thing */
    if(icst >= 0) {
        pdmcc = &rgcst[icst].dmcc;
        InitDmcc(icst);
        dmplCur = rgcst[icst].dmplCur;
    } else {
        pdmcc = NULL;
        dmplCur = -1;
    }
    szResp[5] = 0;
    /* If this command belongs to an external command processor, we send it
     * there */
    for(ich = 0; ich < cchCmd; ++ich) {
        if(sz[ich] == '!') {
            BOOL fMatchingConnection;

            /* Look up the command processor */
            pech = PechFindHandler(sz, ich);
            if(pech) {
                /* All external commands require control permission */
                if(dmplCur & DMPL_PRIV_CONTROL) {
                    /* Make sure this handler was appropriately dedicated, if
                     * necessary */
                    if(pech == rgcst[icst].pechDedicated)
                        fMatchingConnection = TRUE;
                    else if(!pech->pfnCreateThread && !rgcst[icst].pechDedicated)
                        fMatchingConnection = TRUE;
                    else
                        fMatchingConnection = FALSE;
                    if(fMatchingConnection) {
                        hr = pech->pfnHandler(sz, szResp + 5,
                            sizeof szResp - 5, pdmcc);
                        if(!hr)
                            hr = XBDM_NOERR;
                    } else
                        hr = XBDM_MUSTBEDEDICATED;
                } else
                    hr = XBDM_CANNOTACCESS;
            } else {
                /* No command handler, can't do anything */
                hr = XBDM_INVALIDCMD;
                *szResp = 0;
            }
            break;
        } else if(FIsSpace(sz[ich]))
            break;
    }

    if(!hr) {
        /* Nobody has handled it yet, so we use our own internal handler.
         * Internal commands must be run on the server thread to avoid
         * possible deadlock if xapi is stopped */
        hr = HrHandleBuiltinCommand(dmplCur, sz, cchCmd, szResp + 5,
            sizeof szResp - 5, pdmcc);
    }

    if(hr && icst >= 0) {
        /* We have some sort of response to process.  First convert to a known
         * error code */
        if(szResp[5])
            pszResp = szResp;
        else
            pszResp = SzStdResponse(hr);

        /* We may have to indicate a special mode */
        switch(hr) {
        case XBDM_MULTIRESPONSE:
            rgcst[icst].dwStatus |= CONN_MULTILINE;
            rgcst[icst].dmcc.DataSize = -1;
            break;
        case XBDM_BINRESPONSE:
            rgcst[icst].dwStatus |= CONN_BINSEND;
            break;
        case XBDM_READYFORBIN:
            rgcst[icst].dwStatus |= CONN_BINARY;
            break;
        }
        if(rgcst[icst].dwStatus & (CONN_MULTILINE | CONN_BINSEND | CONN_BINARY) &&
            !rgcst[icst].dmcc.HandlingFunction)
        {
            /* We gotta fail this */
            hr = E_UNEXPECTED;
            rgcst[icst].dwStatus &= ~(CONN_MULTILINE | CONN_BINSEND | CONN_BINARY);
        }

        if(hr == XBDM_DEDICATED) {
            /* We need to spin off a thread to handle this connection */
            if(FDedicateConnection(icst, pech))
                /* The new thread will send the dedicated message */
                hr = 0;
            else
                hr = E_FAIL;
        }
    }

    if(hr && icst >= 0) {
        /* Now send our response */
        SendHrSzResp(rgcst[icst].s, hr, pszResp, szResp);

        if(hr == XBDM_READYFORBIN && pdmcc->BytesRemaining == 0)
            /* Zero-length receive, so fake up the receive now to end it */
            DoSendReceive(icst, FALSE);
    }
}

void AnswerName(SOCKET s)
{
    struct {
        BYTE bRequest;
        BYTE cchName;
        char szName[256];
    } nm;
    struct sockaddr_in sin;
    int cbAddr = sizeof sin;
    int cbPkt;

    cbPkt = recvfrom(s, (PVOID)&nm, sizeof nm, 0, (struct sockaddr *)&sin,
        &cbAddr);
    switch(nm.bRequest) {
    case 1:
    case 3:
        /* Name request.  1 is to match the name, 3 is to match anything */
        if(nm.bRequest == 1) {
            nm.bRequest = 0;
            /* Need to ensure more than two bytes received before we can
             * look at nm.cchName */
            if(cbPkt < 2 || cbPkt != 2 + nm.cchName)
                /* Ill-formed packet, do nothing */
                break;
            nm.szName[nm.cchName] = 0;
            /* Is it us? */
            if(!nm.cchName || !FEqualRgch(nm.szName, rgchDbgName, nm.cchName)
                    || rgchDbgName[nm.cchName] != 0)
                /* Not for us */
                break;
        }
        /* Answer the request */
        nm.bRequest = 2;
        for(nm.cchName = 0; rgchDbgName[nm.cchName]; ++nm.cchName)
            nm.szName[nm.cchName] = rgchDbgName[nm.cchName];
        break;
    default:
        /* We won't answer a request we don't recognize */
        nm.bRequest = 0;
        break;
    }
    if(nm.bRequest)
        sendto(s, (PVOID)&nm, nm.cchName + 2, 0, (struct sockaddr *)&sin,
            cbAddr);
}

void HandleSocketRead(int icst)
{
    if(rgcst[icst].dwStatus & CONN_BINARY)
        DoSendReceive(icst, FALSE);
    else {
        /* Text data coming in; read it */
        int cbRcv;
        int cbBuf;
        char *pchBuf;
        char rgbBufT[64];
        int ich;

        if(rgcst[icst].dwStatus & CONN_OVERFLOW) {
            /* Overflowed the buffer, ignore the data */
            pchBuf = rgbBufT;
            cbBuf = MAX_CONN_BUF - sizeof rgbBufT;
        } else {
            cbBuf = rgcst[icst].dwStatus & CONN_RECEIVED;
            pchBuf = &rgcst[icst].szBuf[cbBuf];
        }
        cbRcv = recv(rgcst[icst].s, pchBuf, MAX_CONN_BUF -
            cbBuf, 0);
        if(cbRcv <= 0) {
            /* Connection is bad, give up */
            CloseConn(icst);
            return;
        }
        if(!(rgcst[icst].dwStatus & CONN_OVERFLOW)) {
            rgcst[icst].dwStatus += cbRcv;
            if((rgcst[icst].dwStatus & CONN_RECEIVED) ==
                    MAX_CONN_BUF)
                rgcst[icst].dwStatus |= CONN_OVERFLOW;
        }
        if(pchBuf != rgcst[icst].szBuf) {
            /* We're receiving additional data, so we may need to look
             * back one for the CR */
            --pchBuf;
            ++cbRcv;
        }
        /* Let's see if we got our end-of-line, which must be of the
         * form CR-LF or CR-0 */
        for(ich = 0; ich < cbRcv; ++ich)
            if(pchBuf[ich] == '\015')
                break;
        if(ich < cbRcv - 1) {
            /* Got EOL, so let's do our requisite processing */
            if(rgcst[icst].dwStatus & CONN_OVERFLOW) {
                PrintSockLine(rgcst[icst].s, "406- line too long");
                rgcst[icst].dwStatus &= ~(CONN_OVERFLOW | CONN_RECEIVED);
            } else {
                pchBuf[ich++] = 0;
                HandleCommand(icst, rgcst[icst].szBuf);
                if(rgcst[icst].s != INVALID_SOCKET) {
                    int ichNew = 0;
                    while(++ich < cbRcv)
                        rgcst[icst].szBuf[ichNew++] = pchBuf[ich];
                    rgcst[icst].dwStatus &= ~CONN_RECEIVED;
                    rgcst[icst].dwStatus |= ichNew;
                }
            }
        }
    }
}

DWORD DedicatedServThread(LPVOID lpv)
{
    int icst = (int)lpv;

    DmGetCurrentDmtd()->DebugFlags |= DMFLAG_DEBUGTHREAD;
    rgcst[icst].pthrDedicated = PsGetCurrentThread();

    while(rgcst[icst].s != INVALID_SOCKET && rgcst[icst].pthrDedicated ==
        PsGetCurrentThread())
    {
        fd_set fds;
        BOOL fSend;

        FD_ZERO(&fds);
        FD_SET(rgcst[icst].s, &fds);
        fSend = rgcst[icst].dwStatus & (CONN_BINSEND | CONN_MULTILINE);

        while(select(0, fSend ? NULL : &fds, fSend ? &fds : NULL, NULL, 0) == 0);
        if(!FD_ISSET(rgcst[icst].s, &fds))
            /* How did this happen? */
            CloseConn(icst);
        else if(fSend)
            DoSendReceive(icst, TRUE);
        else
            HandleSocketRead(icst);
    }
    return 0;
}

DWORD ServerThread(LPVOID pv)
{
    SOCKET sockListen;
    SOCKET sockName;
    int icst;
    struct sockaddr_in sin;
    fd_set fds;
    fd_set fdsSend;
    NTSTATUS st;
    char sz[128];
    PULARGE_INTEGER plu;

    //Boost the base priority of this thread so that the dm is response, especially
    //important xbcp.
    KeSetBasePriorityThread(KeGetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    DmGetCurrentDmtd()->DebugFlags |= DMFLAG_DEBUGTHREAD;
    pthrServ = PsGetCurrentThread();

    for(icst = 0; icst < MAX_CONNECTIONS; ++icst)
        rgcst[icst].s = INVALID_SOCKET;
    sockListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sockListen == INVALID_SOCKET)
        return 0;
    st = TRUE;
    if(0 != setsockopt(sockListen, SOL_SOCKET, SO_REUSEADDR, (PVOID)&st,
        sizeof st))
    {
        _asm int 3
        closesocket(sockListen);
        return 0;
    }
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(DEBUGGER_PORT);
    if(0 != bind(sockListen, (struct sockaddr *)&sin, sizeof sin)) {
        _asm int 3
        closesocket(sockListen);
        return 0;
    }
    if(0 != listen(sockListen, MAX_CONNECTIONS)) {
        _asm int 3
        closesocket(sockListen);
        return 0;
    }

    /* Set up our name answering socket */
    sockName = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sockName != INVALID_SOCKET) {
        BOOL fReuse = TRUE;
        if(0 != setsockopt(sockName, SOL_SOCKET, SO_REUSEADDR, (PVOID)&fReuse,
            sizeof fReuse))
        {
NameErr:
            closesocket(sockName);
            sockName = INVALID_SOCKET;
        } else {
            sin.sin_family = AF_INET;
            sin.sin_addr.s_addr = 0;
            sin.sin_port = htons(DEBUGGER_PORT);
            if(0 != bind(sockName, (struct sockaddr *)&sin, sizeof sin))
                goto NameErr;
        }
    }

    // DbgPrint("dm: listening\n");
    KeSetEvent(&kevtServ, EVENT_INCREMENT, FALSE);

    /* Now we wait for connections and answer what's there */
    for(;;) {
        do {
            FD_ZERO(&fds);
            FD_ZERO(&fdsSend);
            FD_SET(sockListen, &fds);
            if(sockName != INVALID_SOCKET)
                FD_SET(sockName, &fds);
            for(icst = 0; icst < MAX_CONNECTIONS; ++icst) {
                if(rgcst[icst].s != INVALID_SOCKET &&
                    rgcst[icst].pthrDedicated == PsGetCurrentThread())
                {
                    FD_SET(rgcst[icst].s, rgcst[icst].dwStatus &
                        (CONN_BINSEND | CONN_MULTILINE) ? &fdsSend : &fds);
                }
            }
        } while(select(0, &fds, &fdsSend, NULL, NULL) <= 0);

        /* Accept new connections */
        if(FD_ISSET(sockListen, &fds)) {
            SOCKET sockNew;
            int cb = sizeof sin;
            sockNew = accept(sockListen, (struct sockaddr *)&sin, &cb);
            if(sockNew == INVALID_SOCKET)
                continue;
            EnterCriticalSection(&csAccept);
            if(g_fServShutdown)
                icst = MAX_CONNECTIONS;
            else {
                for(icst = 0; icst < MAX_CONNECTIONS; ++icst) {
                    if(rgcst[icst].s == INVALID_SOCKET)
                        break;
                }
            }
            if(icst < MAX_CONNECTIONS) {
                rgcst[icst].s = sockNew;
                rgcst[icst].pthrDedicated = pthrServ;
            }
            LeaveCriticalSection(&csAccept);
            if(icst == MAX_CONNECTIONS) {
                PrintSockLine(sockNew, "401- max number of connections exceeded");
                fAllowKd = TRUE; // we're going to need to debug if this happens
                closesocket(sockNew);
            } else {
                if(g_fLockLevel) {
                    rgcst[icst].dmplCur = 0;
                    plu = &rgcst[icst].luConnectNonce;
                    KeQuerySystemTime((PLARGE_INTEGER)plu);
                    _asm {
                        mov ecx, plu
                        rdtsc
                        xor [ecx], eax
                        xor [ecx+4], edx
                    }
                    sprintf(sz, "201- boxid=0q%08x%08x nonce=0q%08x%08x",
                        g_luBoxId.HighPart, g_luBoxId.LowPart, plu->HighPart,
                        plu->LowPart);
                    PrintSockLine(sockNew, sz);
                } else {
                    rgcst[icst].dmplCur = -1;
                    PrintSockLine(sockNew, "201- connected");
                }
                rgcst[icst].dwStatus = 0;
                InitDmcc(icst);
            }
        } else if(FD_ISSET(sockName, &fds)) {
            /* Answer name requests */
            AnswerName(sockName);
        } else for(icst = 0; icst < MAX_CONNECTIONS; ++icst) {
            if(rgcst[icst].s == INVALID_SOCKET)
                continue;
            if(FD_ISSET(rgcst[icst].s, &fdsSend)) {
                DoSendReceive(icst, TRUE);
                continue;
            }
            if(FD_ISSET(rgcst[icst].s, &fds))
                HandleSocketRead(icst);
        }
    }
}

BOOL FStartDebugService(void)
{
    NTSTATUS st;
    HANDLE hthr;

    st = PsCreateSystemThread(&hthr, NULL, ServerThread, NULL, TRUE);
    return NT_SUCCESS(st);
}

HRESULT DmSetXboxName(LPCSTR szName)
{
    if(szName) {
        strncpy(rgchDbgName, szName, sizeof rgchDbgName);
        rgchDbgName[sizeof rgchDbgName - 1] = 0;
    } else
        rgchDbgName[0] = 0;
    WriteIniFile();
    return XBDM_NOERR;
}

HRESULT DmGetXboxName(LPSTR szName, LPDWORD pcch)
{
    DWORD ich;

    if (!szName || !pcch)
        return E_INVALIDARG;

    for(ich = 0; rgchDbgName[ich] && ich < *pcch - 1; ++ich)
        *szName++ = rgchDbgName[ich];
    *szName = 0;
    return rgchDbgName[ich] ? XBDM_BUFFER_TOO_SMALL : XBDM_NOERR;
}

HRESULT DmRegisterCommandProcessor(LPCSTR sz, PDM_CMDPROC pfn)
{
    return DmRegisterCommandProcessorEx(sz, pfn, NULL);
}

HRESULT DmRegisterCommandProcessorEx(LPCSTR sz, PDM_CMDPROC pfn,
    PVOID pfnCreateThread)
{
    int ich;
    int iech;
    ECH *pech;
    HRESULT hr;

    if (!sz)
        return E_INVALIDARG;

    RtlEnterCriticalSection(&csEch);
    if(!pfn) {
        /* We're going to unregister, so find the matching handler and pull
         * it */
        for(ich = 0; sz[ich]; ++ich);
        for(iech = 0; iech < MAX_ECH; ++iech) {
            if(rgpech[iech] && FEqualRgch(rgpech[iech]->szExtName, sz, ich)) {
                DmFreePool(rgpech[iech]);
                rgpech[iech] = NULL;
            }
        }
        hr = XBDM_NOERR;
    } else {
        /* Let's find somewhere to put it */
        for(iech = 0; iech < MAX_ECH; ++iech)
            if(!rgpech[iech])
                break;
        if(iech < MAX_ECH) {
            pech = DmAllocatePoolWithTag(sizeof *pech, 'hcmd');
        } else
            pech = NULL;
        if(pech) {
            for(ich = 0; sz[ich] && ich < sizeof pech->szExtName - 1; ++ich)
                pech->szExtName[ich] = sz[ich];
            if(sz[ich]) {
                DmFreePool(pech);
                hr = E_INVALIDARG;
            } else {
                pech->szExtName[ich] = 0;
                pech->pfnHandler = pfn;
                pech->pfnCreateThread = pfnCreateThread;
                rgpech[iech] = pech;
                hr = XBDM_NOERR;
            }
        } else
            hr = E_OUTOFMEMORY;
    }
    RtlLeaveCriticalSection(&csEch);
    return hr;
}

HRESULT HrDedicateConnection(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szHandler[256];
    int icst;
    PECH pech;

    if(!pdmcc)
        return E_INVALIDARG;

    if(PchGetParam(sz, "global", FALSE))
        pech = NULL;
    else if(!FGetSzParam(sz, "handler", szHandler, sizeof szHandler)) {
        strcpy(szResp, "missing handler");
        return E_FAIL;
    } else {
        pech = PechFindHandler(szHandler, strlen(szHandler));
        if(!pech)
            return XBDM_NOSUCHFILE;
    }

    icst = (PCST)pdmcc - rgcst;
    /* Rededicate the connection.  If this is successful, the success
     * message will be sent in the new thread */
    return FDedicateConnection(icst, pech) ? 0 : E_FAIL;
}

HRESULT DmThreadUserData(DWORD tid, PDWORD *ppdwRet)
{
    PETHREAD pthr;
    NTSTATUS st;
    HRESULT hr = XBDM_NOTHREAD;

    if (!ppdwRet)
        return E_INVALIDARG;

    if(tid == DM_CURRENT_THREAD) {
        pthr = PsGetCurrentThread();
        ObfReferenceObject(pthr);
        st = STATUS_SUCCESS;
    } else
        st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
    if(NT_SUCCESS(st)) {
        DMTD *pdmtd = DmGetCurrentDmtd();
        if(pdmtd) {
            *ppdwRet = &pdmtd->UserData;
            hr = XBDM_NOERR;
        }
        ObDereferenceObject(pthr);
    }
    return hr;
}

HRESULT HrEndConversation(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    int icst;

    if(!pdmcc)
        return E_INVALIDARG;
    icst = (PCST)pdmcc - rgcst;
    PrintSockLine(rgcst[icst].s, "200- bye");
    CloseConn(icst);
    return 0;
}

HRESULT HrSetDbgName(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szNewName[sizeof rgchDbgName];
    HRESULT hr;
    KIRQL irqlSav;

    if(!FGetSzParam(sz, "name", szNewName, sizeof szNewName)) {
        /* We're querying for the current name */
        strcpy(szResp, rgchDbgName);
        hr = XBDM_NOERR;
    } else if(!FConnectionPermission(pdmcc, DMPL_PRIV_CONFIGURE))
        hr = XBDM_CANNOTACCESS;
    else {
        irqlSav = KeRaiseIrqlToDpcLevel();
        memcpy(rgchDbgName, szNewName, sizeof rgchDbgName);
        hr = XBDM_NOERR;
        KeLowerIrql(irqlSav);
        WriteIniFile();
    }
    return hr;
}

HRESULT HrToggleGPUCounters(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    HRESULT hr;

    if(PchGetParam(sz, "enable", FALSE))
        hr = DmEnableGPUCounter(TRUE);
    else if(PchGetParam(sz, "disable", FALSE))
        hr = DmEnableGPUCounter(FALSE);
    return hr;
}

HRESULT HrToggleKDState(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    HRESULT hr = XBDM_NOERR;

    if(PchGetParam(sz, "enable", FALSE)) {
        fAllowKd = TRUE;
        strcpy(szResp, "kd enabled");
    } else if(PchGetParam(sz, "disable", FALSE)) {
        fAllowKd = FALSE;
        strcpy(szResp, "kd disabled");
    } else if(PchGetParam(sz, "except", FALSE)) {
        fAllowKd = TRUE;
        ExceptionsToKd();
    } else if(PchGetParam(sz, "exceptif", FALSE)) {
        /* Forward exceptions to KD only if KD is connected */
        if(*KdDebuggerEnabled) {
            fAllowKd = TRUE;
            ExceptionsToKd();
        }
    } else {
        strcpy(szResp, "improper command");
        hr = E_FAIL;
    }

    return hr;
}

HRESULT HrSetupNotifyAt(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    int icst;

    if(!pdmcc)
        return E_FAIL;
    icst = (PCST)pdmcc - rgcst;
    hr = FNotifyAtCmd(rgcst[icst].s, sz, FALSE) ? XBDM_NOERR :
        E_FAIL;
    /* Keep the ini file up-to-date */
    if(SUCCEEDED(hr))
        WriteIniFile();
    return hr;
}

HRESULT HrSetupNotify(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    int icst;
    HRESULT hr;

    if(!pdmcc)
        return E_FAIL;
    icst = (PCST)pdmcc - rgcst;

    if(FConvertToNotifySock(rgcst[icst].s)) {
        /* This socket is no longer our responsibility */
        rgcst[icst].s = INVALID_SOCKET;
        hr = 0;
    } else {
        strcpy(szResp, "notification limit exceeded");
        hr = E_FAIL;
    }
    return hr;
}

HRESULT HrDoStopon(BOOL fStop, LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD dw = 0;

    if(PchGetParam(sz, "all", FALSE)) {
        dw = -1;
        strcpy(szResp, fStop ? "stop on all" : "stop on none");
    } else {
        if(PchGetParam(sz, "fce", FALSE))
            dw |= DMSTOP_FCE;
        if(PchGetParam(sz, "debugstr", FALSE))
            dw |= DMSTOP_DEBUGSTR;
        if(PchGetParam(sz, "createthread", FALSE))
            dw |= DMSTOP_CREATETHREAD;
    }
    return DmStopOn(dw, fStop);
}

HRESULT HrStopon(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    return HrDoStopon(TRUE, sz, szResp, cchResp, pdmcc);
}

HRESULT HrNostopon(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    return HrDoStopon(FALSE, sz, szResp, cchResp, pdmcc);
}

HRESULT HrGo(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    if(dwExecState == DMN_EXEC_START) {
        sprintf(szResp, "not stopped");
        return E_FAIL;
    }
    DmGo();
    return XBDM_NOERR;
}

HRESULT HrStop(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    if(dwExecState != DMN_EXEC_START) {
        sprintf(szResp, "already stopped");
        return E_FAIL;
    }
    DmStop();
    return XBDM_NOERR;
}

BOOL FTitleExists(LPCSTR szDir, LPCSTR szTitle, LPCSTR szCmdLine, BOOL fMapIt)
{
    HANDLE h;
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING objectName;
    IO_STATUS_BLOCK iosb;
    BOOL fRet;
    NTSTATUS st;
    OCHAR oszPath[MAX_OBJ_PATH+1];
    OCHAR *pochTitle;
    OCHAR *pochMax;
    int ich;

    if(!szDir || !szDir[0]) {
		/* No dir name, so we expect szTitle to have the complete path name
		 * to the title */
		if(!szTitle || !FFileNameToObName(szTitle, oszPath, sizeof oszPath /
			sizeof(OCHAR)))
		{
			return FALSE;
		}
		pochTitle = NULL;
	} else {
		if(!FFileNameToObName(szDir, oszPath, sizeof oszPath / sizeof(OCHAR)))
			return FALSE;
		pochTitle = oszPath;
	}
    if(!szTitle)
        szTitle = "default.xbe";

	if(pochTitle) {
		/* Construct a complete path for the title and remember where both
		 * parts go */
		pochMax = oszPath + sizeof oszPath / sizeof(OCHAR);
		while(*pochTitle)
			++pochTitle;
		/* If we're in a root dir, don't add the extra '\' */
		if(pochTitle > oszPath && pochTitle[-1] != '\\')
			*pochTitle++ = '\\';
		for(ich = 0; &pochTitle[ich] < pochMax && szTitle[ich]; ++ich)
			pochTitle[ich] = szTitle[ich];
		if(&pochTitle[ich] >= pochMax - 1)
			return FALSE;
		pochTitle[ich] = 0;
	}

    /* Verify the file exists */
    RtlInitObjectString(&objectName, oszPath);
    InitializeObjectAttributes(&oa, &objectName, OBJ_CASE_INSENSITIVE, NULL,
        NULL);
    st = NtOpenFile(&h, SYNCHRONIZE, &oa, &iosb, FILE_SHARE_READ,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    fRet = NT_SUCCESS(st);
    if(fRet) {
        NtClose(h);
        if(fMapIt) {
			if(pochTitle) {
				pochTitle[-1] = 0;
				pochMax = oszPath;
			} else {
				pochMax = NULL;
				pochTitle = oszPath;
			}
            /* We require that the command line passed in is the size of the
             * launch data, so we don't need to do any copying here */
            fRet = NT_SUCCESS(XWriteTitleInfoNoReboot(pochTitle, pochMax,
                szCmdLine ? LDT_FROM_DEBUGGER_CMDLINE : LDT_NONE, 0,
                (PLAUNCH_DATA) szCmdLine));
        }
    }
    return fRet;
}

HRESULT HrReceiveFileData(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    FILE_DISPOSITION_INFORMATION fdi;
    IO_STATUS_BLOCK iosb;

    if(pdmcc->DataSize) {
        if(pccs->rgbBuf)
            /* Digest the data in the buffer */
            pccs->ib += pdmcc->DataSize;
        else
            pccs->ib = DISK_BUF_SIZE;
        pdmcc->BytesRemaining -= pdmcc->DataSize;
    } else {
        /* If there's no data, then either we had a zero-length file, or
         * we've lost our socket.  In the latter case, we need to delete
         * the file */
        if(pdmcc->BytesRemaining) {
            pdmcc->BytesRemaining = 0;
            fdi.DeleteFile = TRUE;
            NtSetInformationFile(pccs->hFile, &iosb, &fdi, sizeof(fdi),
                FileDispositionInformation);
        }
    }

    /* See if we're ready for a disk write */
    if(!pdmcc->BytesRemaining || pccs->ib == DISK_BUF_SIZE) {
        NTSTATUS st;

        if(pccs->hFile) {
            st = NtWriteFile(pccs->hFile, NULL, NULL, NULL, &iosb,
                pccs->rgbBuf, pccs->ib, NULL);
            /* Close the file if we're out of data */
            if(!NT_SUCCESS(st)) {
                /* If an error, try to delete the file and signal an error
                 * condition */
                fdi.DeleteFile = TRUE;
                NtSetInformationFile(pccs->hFile, &iosb, &fdi, sizeof(fdi),
                    FileDispositionInformation);
                NtClose(pccs->hFile);
                pccs->hFile = NULL;
                pccs->fError = TRUE;
            } else if(!pdmcc->BytesRemaining) {
                NtClose(pccs->hFile);
                pccs->hFile = NULL;
            }
        }
        pccs->ib = 0;
        if(!pdmcc->BytesRemaining && pccs->rgbBuf)
            /* Clean up our buffer */
            DmFreePool(pccs->rgbBuf);
    }

    /* Make sure the buffer pointer is set up */
    if(pccs->rgbBuf) {
        pdmcc->Buffer = pccs->rgbBuf + pccs->ib;
        pdmcc->BufferSize = DISK_BUF_SIZE - pccs->ib;
    }

    return pccs->fError ? E_UNEXPECTED : XBDM_NOERR;
}

HRESULT HrReceiveFile(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    LARGE_INTEGER liSize;
    NTSTATUS st;
    char szName[MAX_OBJ_PATH+1];
    CCS *pccs;
    IO_STATUS_BLOCK iosb;
    FILE_END_OF_FILE_INFORMATION feof;
    FILE_DISPOSITION_INFORMATION fdi;
    HRESULT hr;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }
    if(!FGetNamedDwParam(sz, "length", &pdmcc->BytesRemaining, szResp))
        return E_FAIL;

    pccs = (CCS *)pdmcc->CustomData;
    liSize.HighPart = 0;
    liSize.LowPart = pdmcc->BytesRemaining;

    st = FCreateFile(&pccs->hFile, GENERIC_WRITE | DELETE | SYNCHRONIZE,
        szName, &liSize, 0, 0, FILE_OVERWRITE_IF,
        FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        /* Set the size of the file now */
        feof.EndOfFile = liSize;
        st = NtSetInformationFile(pccs->hFile, &iosb, &feof, sizeof(feof),
            FileEndOfFileInformation);
        if(NT_SUCCESS(st)) {
            /* Make sure we'll have a buffer for received data */
            pccs->ib = 0;
            pccs->rgbBuf = DmAllocatePoolWithTag(DISK_BUF_SIZE, 'bdbd');
            /* Even if the alloc fails, we'll still have a small static buffer */
            pdmcc->Buffer = pccs->rgbBuf;
            pdmcc->BufferSize = DISK_BUF_SIZE;
            pccs->fError = FALSE;
            pdmcc->HandlingFunction = HrReceiveFileData;
            return XBDM_READYFORBIN;
        } else {
            /* Mark the file for deletion and close the file */
            fdi.DeleteFile = TRUE;
            NtSetInformationFile(pccs->hFile, &iosb, &fdi, sizeof(fdi),
                FileDispositionInformation);
            NtClose(pccs->hFile);
            pccs->hFile = NULL;
        }
    }
    return HrFromStatus(st, XBDM_CANNOTCREATE);
}

HRESULT HrSendFileData(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    if(pdmcc->BytesRemaining == 0) {
        /* End of file */
        NtClose(pccs->hFile);
        if(pccs->rgbBuf)
            DmFreePool(pccs->rgbBuf);
        return XBDM_ENDOFLIST;
    }
    if(!pccs->fDidSize) {
        /* First we need to send the length */
        pdmcc->BytesRemaining = pccs->ib;
        memcpy(pdmcc->Buffer, &pccs->ib, sizeof(DWORD));
        pdmcc->DataSize = sizeof(DWORD);
        pccs->fDidSize = TRUE;
    } else {
        NTSTATUS st;
        IO_STATUS_BLOCK iosb;
        DWORD cb;

        cb = pdmcc->BufferSize;
        if(cb > pdmcc->BytesRemaining)
            cb = pdmcc->BytesRemaining;
        st = NtReadFile(pccs->h, NULL, NULL, NULL, &iosb, pdmcc->Buffer, cb,
            NULL);
        if(!NT_SUCCESS(st))
            // BUG BUG -- need to signal read failure
            RtlZeroMemory(pdmcc->Buffer, cb);
        pdmcc->BytesRemaining -= cb;
        pdmcc->DataSize = cb;
    }
    return XBDM_NOERR;
}

HRESULT HrSendFile(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    IO_STATUS_BLOCK iosb;
    FILE_NETWORK_OPEN_INFORMATION ni;
    char szName[MAX_OBJ_PATH+1];
    CCS *pccs;
    HRESULT hr;
    int icst;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    pccs = (CCS *)pdmcc->CustomData;
    st = FCreateFile(&pccs->hFile, GENERIC_READ | SYNCHRONIZE, szName,
                    NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        st = NtQueryInformationFile(pccs->hFile, &iosb, &ni, sizeof ni,
            FileNetworkOpenInformation);
        if(NT_SUCCESS(st)) {
            if(ni.EndOfFile.HighPart) {
                /* File is too big to transfer */
                sprintf(szResp, "file is too big");
                hr = E_FAIL;
            } else {
                /* Get a buffer for sending if we can */
                pdmcc->BufferSize = 1024;
                pccs->rgbBuf = pdmcc->Buffer = DmAllocatePoolWithTag(
                    pdmcc->BufferSize, 'bdbd');
                pccs->ib = ni.EndOfFile.LowPart;
                pccs->fDidSize = FALSE;
                pdmcc->BytesRemaining = 1;
                pdmcc->HandlingFunction = HrSendFileData;
                return XBDM_BINRESPONSE;
            }
        } else
            hr = E_UNEXPECTED;
        NtClose(pccs->h);
    } else
        hr = HrFromStatus(st, XBDM_CANNOTACCESS);
    return hr;
}

void GetFileAttrSz(LPSTR sz, ULONG dwAttributes, PLARGE_INTEGER pliChange,
    PLARGE_INTEGER pliCreate, PLARGE_INTEGER pliSize)
{
    sprintf(sz, "sizehi=0x%x sizelo=0x%x createhi=0x%08x createlo=0x%08x "
        "changehi=0x%08x changelo=0x%08x%s%s%s", pliSize->HighPart,
        pliSize->LowPart, pliCreate->HighPart, pliCreate->LowPart,
        pliChange->HighPart, pliChange->LowPart,
        dwAttributes & FILE_ATTRIBUTE_DIRECTORY ? " directory" : "",
        dwAttributes & FILE_ATTRIBUTE_READONLY ? " readonly" : "",
        dwAttributes & FILE_ATTRIBUTE_HIDDEN ? " hidden" : "");
}

HRESULT HrReportFileAttributes(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    for(;;) {
        switch(pdmcc->BytesRemaining++) {
        case 1:
            GetFileAttrSz(pdmcc->Buffer, pccs->fba.FileAttributes,
                &pccs->fba.LastWriteTime, &pccs->fba.CreationTime,
                &pccs->fba.EndOfFile);
            return XBDM_NOERR;
        default:
            return XBDM_ENDOFLIST;
        }
    }
}

HRESULT HrGetFileAttributes(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    OCHAR oszFilename[MAX_OBJ_PATH+1];
    NTSTATUS st;
    OBJECT_STRING objFilename;
    OBJECT_ATTRIBUTES oa;
    char szName[MAX_OBJ_PATH+1];
    CCS *pccs;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    /* Turn the filename into an object manager name*/
    if(!FFileNameToObName(szName, oszFilename, sizeof oszFilename /
            sizeof(OCHAR)))
        return XBDM_NOSUCHFILE;
    RtlInitObjectString(&objFilename, oszFilename);
    InitializeObjectAttributes(&oa, &objFilename, OBJ_CASE_INSENSITIVE, NULL,
        NULL);

    pccs = (CCS *)pdmcc->CustomData;
    pdmcc->HandlingFunction = HrReportFileAttributes;
    pdmcc->BytesRemaining = 1;
    st = NtQueryFullAttributesFile(&oa, &pccs->fba);
    return NT_SUCCESS(st) ? XBDM_MULTIRESPONSE : HrFromStatus(st,
        XBDM_CANNOTACCESS);
}

HRESULT HrSetFileAttributes(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    HANDLE h;
    IO_STATUS_BLOCK iosb;
    char szName[MAX_OBJ_PATH+1];
    HRESULT hr;

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    st = FCreateFile(&h, SYNCHRONIZE, szName, NULL, 0,
        FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        FILE_NETWORK_OPEN_INFORMATION fna;

        st = NtQueryInformationFile(h, &iosb, &fna, sizeof fna,
            FileNetworkOpenInformation);
        if(NT_SUCCESS(st)) {
            FILE_BASIC_INFORMATION fba;
            DWORD dwAttrMask = 0;
            DWORD dwAttrNew = 0;
            DWORD dwT;

            RtlZeroMemory(&fba, sizeof fba);
            if(FGetDwParam(sz, "readonly", &dwT)) {
                dwAttrMask |= FILE_ATTRIBUTE_READONLY;
                if(dwT)
                    dwAttrNew |= FILE_ATTRIBUTE_READONLY;
            }
            if(FGetDwParam(sz, "hidden", &dwT)) {
                dwAttrMask |= FILE_ATTRIBUTE_HIDDEN;
                if(dwT)
                    dwAttrNew |= FILE_ATTRIBUTE_HIDDEN;
            }
            FGetDwParam(sz, "createhi", &fba.CreationTime.HighPart);
            FGetDwParam(sz, "createlo", &fba.CreationTime.LowPart);
            FGetDwParam(sz, "changehi", &fba.LastWriteTime.HighPart);
            FGetDwParam(sz, "changelo", &fba.LastWriteTime.LowPart);
            fba.FileAttributes = fna.FileAttributes ^ ((fna.FileAttributes ^
                dwAttrNew) & dwAttrMask);
            if(!fba.FileAttributes)
                fba.FileAttributes = FILE_ATTRIBUTE_NORMAL;
            st = NtSetInformationFile(h, &iosb, &fba, sizeof fba,
                FileBasicInformation);
            hr = NT_SUCCESS(st) ? XBDM_NOERR : HrFromStatus(st, E_FAIL);
        }
        NtClose(h);
    } else
        hr = HrFromStatus(st, XBDM_CANNOTACCESS);
    return hr;
}

HRESULT HrRenameFile(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    HANDLE h;
    IO_STATUS_BLOCK iosb;
    char  szName[MAX_OBJ_PATH+1];
    OCHAR oszNewName[MAX_OBJ_PATH+1];
    FILE_RENAME_INFORMATION fri;
    HRESULT hr;

    if(!FGetSzParam(sz, "newname", szName, sizeof szName)) {
        strcpy(szResp, "missing new name");
        return E_FAIL;
    }
    if(!FFileNameToObName(szName, oszNewName, MAX_OBJ_PATH+1)) {
        strcpy(szResp, "new name does not exist");
        return XBDM_NOSUCHFILE;
    }

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    /* Get a handle to the original file */
    st = FCreateFile(&h, GENERIC_WRITE | SYNCHRONIZE, szName, NULL, 0, 0,
                    FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        RtlZeroMemory(&fri, sizeof fri);
        RtlInitObjectString(&fri.FileName, oszNewName);
        st = NtSetInformationFile(h, &iosb, &fri, sizeof fri,
             FileRenameInformation);
        NtClose(h);
        switch(st) {
        case STATUS_NOT_SAME_DEVICE:
            hr = XBDM_MUSTCOPY;
            break;
        default:
            if(NT_SUCCESS(st))
                hr = XBDM_NOERR;
            else
                hr = HrFromStatus(st, XBDM_CANNOTCREATE);
            break;
        }
    } else
        hr = XBDM_CANNOTACCESS;

    return hr;
}

HRESULT HrDeleteFile(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    HANDLE h;
    IO_STATUS_BLOCK iosb;
    FILE_DISPOSITION_INFORMATION fdi;
    char szName[MAX_OBJ_PATH+1];
    HRESULT hr;
    BOOL fIsDirectory;
    char *pch;

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }
    fIsDirectory = PchGetParam(sz, "dir", FALSE) != NULL;

    /* We're going to prohibit the deletion of any drives */
    pch = szName;
    if(*pch == 'x' || *pch == 'X')
        ++pch;
    if(pch[1] == ':' && pch[2] == '\\' && pch[3] == 0)
        /* Looks like a drive name */
        return XBDM_CANNOTACCESS;

    st = FCreateFile(&h, DELETE | SYNCHRONIZE, szName, NULL, 0, 0,
        FILE_OPEN, fIsDirectory ?
        FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE :
        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);
    if(NT_SUCCESS(st)) {
        RtlZeroMemory(&fdi, sizeof fdi);
        fdi.DeleteFile = TRUE;
        st = NtSetInformationFile(h, &iosb, &fdi, sizeof fdi,
            FileDispositionInformation);
        if(NT_SUCCESS(st))
            hr = XBDM_NOERR;
        else
            hr = HrFromStatus(st, XBDM_CANNOTACCESS);
        NtClose(h);
    } else {
        switch(st) {
        case STATUS_NOT_A_DIRECTORY :
            sprintf(szResp, "not a directory");
            hr = XBDM_CANNOTACCESS;
            break;
        case STATUS_FILE_IS_A_DIRECTORY:
            sprintf(szResp, "is a directory");
            hr = XBDM_CANNOTACCESS;
            break;
        default:
            hr = HrFromStatus(st, XBDM_CANNOTACCESS);
            break;
        }
    }

    return hr;
}

HRESULT HrReportDirList(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    NTSTATUS st;
    IO_STATUS_BLOCK iosb;
    struct
    {
        FILE_DIRECTORY_INFORMATION fna;
        OCHAR ozName[MAX_OBJ_PATH+1];
    } fna;
    CCS *pccs = (CCS *)pdmcc->CustomData;
    HRESULT hr;
    LPSTR szResp;

    st = NtQueryDirectoryFile(pccs->h, NULL, NULL, NULL, &iosb,
        &fna.fna, sizeof fna, FileDirectoryInformation,
        NULL, (BOOLEAN)(pccs->i == 0));
    if(pdmcc->BytesRemaining && NT_SUCCESS(st))
    {
        ULONG ich;

        ++pccs->i;

        fna.fna.FileNameLength /= sizeof(OCHAR); // from bytes to cwch
        if(fna.fna.FileNameLength >= pdmcc->BufferSize)
            fna.fna.FileNameLength = pdmcc->BufferSize - 1;
        strcpy(pdmcc->Buffer, "name=\"");
        for(szResp = pdmcc->Buffer; *szResp; ++szResp);
        for(ich = 0; ich < fna.fna.FileNameLength; ++ich)
            szResp[ich] = (char)fna.fna.FileName[ich];
        szResp[ich++] = '"';
        szResp[ich++] = ' ';
        GetFileAttrSz(szResp + ich, fna.fna.FileAttributes,
            &fna.fna.LastWriteTime, &fna.fna.CreationTime, &fna.fna.EndOfFile);
        hr = XBDM_NOERR;
    } else {
        NtClose(pccs->h);
        DmFreePool(pdmcc->Buffer);
        hr = XBDM_ENDOFLIST;
    }
    return hr;
}

HRESULT HrGetDirList(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    char szName[MAX_OBJ_PATH+1];
    CCS *pccs;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    pccs = (CCS *)pdmcc->CustomData;
    pccs->i = 0;
    pdmcc->BufferSize = 512;
    pdmcc->Buffer = DmAllocatePool(pdmcc->BufferSize);
    if(!pdmcc->Buffer)
        /* We can't fall back on the default 256-byte buffer in this case */
        return E_OUTOFMEMORY;
    pdmcc->HandlingFunction = HrReportDirList;
    pdmcc->DataSize = -1;

    st = FCreateFile(&pccs->h, FILE_LIST_DIRECTORY | SYNCHRONIZE, szName, NULL, 0,
                FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    return NT_SUCCESS(st) ? XBDM_MULTIRESPONSE : HrFromStatus(st,
        XBDM_CANNOTACCESS);
}

HRESULT HrMkdir(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    HANDLE h;
    char szName[MAX_OBJ_PATH+1];

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    st = FCreateFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, szName,
        NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE, FILE_DIRECTORY_FILE |
        FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        NtClose(h);
        return XBDM_NOERR;
    } else if(st == STATUS_OBJECT_NAME_COLLISION)
        return XBDM_ALREADYEXISTS;
    else
        return HrFromStatus(st, XBDM_CANNOTCREATE);
}

HRESULT HrFormatFAT(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    DWORD dwPartition;
    OCHAR szPartition[MAX_OBJ_PATH + 1];
    OBJECT_STRING ost;

    if(dwExecState != DMN_EXEC_PENDING) {
        strcpy(szResp, "not stopped");
        return E_FAIL;
    }
    if(!FGetNamedDwParam(sz, "partition", &dwPartition, szResp))
        return E_FAIL;
    if(dwPartition < 1 || dwPartition > 5)
        return XBDM_NOSUCHFILE;

    sprintf(szPartition, "\\Device\\Harddisk0\\Partition%d", dwPartition);
    RtlInitObjectString(&ost, szPartition);
    if(XapiFormatFATVolume(&ost))
        return XBDM_NOERR;

    strcpy(szResp, "unable to format");
    return XBDM_CANNOTACCESS;
}

HRESULT DmSetTitle(LPCSTR szDir, LPCSTR szTitle, LPCSTR pchCmdLine)
{
    if (!szTitle)
        return E_INVALIDARG;

    if(pchCmdLine) {
        KIRQL irql = KeRaiseIrqlToDpcLevel();
        if(pszCmdLine)
            DmFreePool(pszCmdLine);
        pszCmdLine = DmAllocatePool(sizeof(LD_FROM_DEBUGGER_CMDLINE));
        if(pszCmdLine)
            strcpy(pszCmdLine, pchCmdLine);
        KeLowerIrql(irql);
        if(!pszCmdLine)
            return E_OUTOFMEMORY;
    }

    if(!FTitleExists(szDir, szTitle, NULL, FALSE))
        return XBDM_CANNOTACCESS;
	if(szDir)
		strcpy(rgchTitleDir, szDir);
	else
		rgchTitleDir[0] = 0;
    strcpy(rgchTitleName, szTitle);
    return XBDM_NOERR;
}

HRESULT HrSetTitle(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szNewDir[sizeof rgchTitleDir];
    char szNewName[sizeof rgchTitleName];
	char *pszDir;

    pszDir = FGetSzParam(sz, "dir", szNewDir, sizeof szNewDir) ?
		szNewDir : NULL;
    if(!FGetSzParam(sz, "name", szNewName, sizeof szNewName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }
    return DmSetTitle(pszDir, szNewName, PchGetParam(sz, "cmdline", TRUE));
}

HRESULT HrSetDefaultTitle(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szLaunchData[MAX_LAUNCH_PATH + 1];
    char szLaunchDir[MAX_PATH + 1];
    NTSTATUS st;
    HANDLE h;
    IO_STATUS_BLOCK iosb;
    HRESULT hr;
    char *pch;
    OBJECT_STRING ost;
    OBJECT_ATTRIBUTES oa;
    FILE_DISPOSITION_INFORMATION fdi;

    // Make sure dashboard.xbx file isn't read-only
    InitializeObjectAttributes(&oa, &ostDash, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenFile(&h, FILE_WRITE_ATTRIBUTES|SYNCHRONIZE, &oa, &iosb, 0,
            FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(st)) {
        FILE_BASIC_INFORMATION BasicInfo;
        RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
        BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        NtSetInformationFile(h, &iosb, &BasicInfo, sizeof(BasicInfo), FileBasicInformation);
        NtClose(h);
    }

    if(PchGetParam(sz, "none", FALSE)) {
        // Set the default title to be the dashboard
        InitializeObjectAttributes(&oa, &ostDash, OBJ_CASE_INSENSITIVE, NULL, NULL);
        st = NtOpenFile(&h, DELETE | SYNCHRONIZE, &oa, &iosb, 0,
            FILE_SYNCHRONOUS_IO_NONALERT);
        if(NT_SUCCESS(st)) {
            RtlZeroMemory(&fdi, sizeof fdi);
            fdi.DeleteFile = TRUE;
            st = NtSetInformationFile(h, &iosb, &fdi, sizeof fdi,
                FileDispositionInformation);
            hr = NT_SUCCESS(st) ? XBDM_NOERR : E_UNEXPECTED;
            NtClose(h);
        } else
            hr = XBDM_NOERR;
        return hr;
    }

    RtlZeroMemory(szLaunchData, sizeof szLaunchData);

    if (PchGetParam(sz, "launcher", FALSE)) {
        // Set the default title to be the xdk launcher
        strcpy(szLaunchData, XdkLauncherPathname);
        pch = strrchr(szLaunchData, '\\');
        ASSERT(pch != NULL);
        pch += 1;
    } else {
        // Set the default title to be the specified XBE
        if(!FGetSzParam(sz, "dir", szLaunchDir, sizeof szLaunchDir - 1)) {
            strcpy(szResp, "missing dir");
            return E_FAIL;
        }
        if(!FFileNameToObName(szLaunchDir, szLaunchData, sizeof szLaunchData - 1))
            return XBDM_NOSUCHFILE;
        for(pch = szLaunchData; *pch; ++pch);
        if(pch[-1] != '\\')
            *pch++ = '\\';
        if(!FGetSzParam(sz, "name", pch, szLaunchData + (sizeof szLaunchData - 1) - pch))
        {
            strcpy(szResp, "missing name");
            return E_FAIL;
        }
    }

    /* Verify the file exists */
    RtlInitObjectString(&ost, szLaunchData);
    InitializeObjectAttributes(&oa, &ost, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenFile(&h, SYNCHRONIZE, &oa, &iosb, FILE_SHARE_READ,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if(!NT_SUCCESS(st))
        return HrFromStatus(st, XBDM_CANNOTACCESS);
    NtClose(h);

    /* We've found the file, so now write out the name */
    pch[-1] = TITLE_PATH_DELIMITER;
    InitializeObjectAttributes(&oa, &ostDash, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtCreateFile(&h, GENERIC_WRITE | DELETE | SYNCHRONIZE,
        &oa, &iosb, NULL, 0, 0, FILE_OVERWRITE_IF,
        FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        st = NtWriteFile(h, NULL, NULL, NULL, &iosb, szLaunchData, sizeof
            szLaunchData - 1, NULL);
        if(!NT_SUCCESS(st)) {
            /* Can't write, so try to delete */
            hr = HrFromStatus(st, E_UNEXPECTED);
            RtlZeroMemory(&fdi, sizeof fdi);
            fdi.DeleteFile = TRUE;
            st = NtSetInformationFile(h, &iosb, &fdi, sizeof fdi,
                FileDispositionInformation);
            hr = NT_SUCCESS(st) ? XBDM_NOERR : E_UNEXPECTED;
        } else
            hr = XBDM_NOERR;
        NtClose(h);
    } else
        hr = E_FAIL;
    return hr;
}

HRESULT HrReportMemory(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    /* We print 32 bytes per line, which takes 64 characters + 2 newline chars
     * (66 chars) to constitute a line */
    DWORD cb;
    DWORD dwPageBase;
    BYTE b;
    DWORD ibLim = 32;
    DWORD ib;
    LPSTR sz = pdmcc->Buffer;
    BOOL fPageValid;

    if(!pdmcc->BytesRemaining) {
        /* No more data */
        if(pdmcc->Buffer && pdmcc->BufferSize == 1056) {
            DmFreePool(pdmcc->Buffer);
            pdmcc->Buffer = NULL;
        }
        return XBDM_ENDOFLIST;
    }

    cb = pdmcc->BufferSize / 66;
    if(cb > pdmcc->BytesRemaining)
        cb = pdmcc->BytesRemaining;
    dwPageBase = (DWORD)pccs->pb + 0x1000;
    pdmcc->BytesRemaining -= cb;

    while(cb) {
        ibLim = 32;

        if(cb < ibLim)
            ibLim = cb;
        for(ib = 0; ib < ibLim; ++ib, ++pccs->pb) {
            if(((DWORD)pccs->pb ^ dwPageBase) & 0xfffff000) {
                dwPageBase = (DWORD)pccs->pb & 0xfffff000;
                fPageValid = MmIsAddressValid(pccs->pb);
            }
            if(fPageValid)
                /* If this address has an associated breakpoint, then the
                 * memory we want isn't the int 3, but the breakpoint data */
                fPageValid = FGetMemory(pccs->pb, &b);
            if(fPageValid) {
                sz[2*ib] = rgchHex[(b >> 4) & 0xf];
                sz[2*ib+1] = rgchHex[b & 0xf];
            } else
                sz[2*ib] = sz[2*ib+1] = '?';
        }
        sz[2*ib] = '\015';
        sz[2*ib+1] = '\012';
        sz += 2*ib + 2;
        cb -= ibLim;
    }

    pdmcc->DataSize = sz - (LPSTR)pdmcc->Buffer;
    return XBDM_NOERR;
}

HRESULT HrGetMemory(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs;

    if(!pdmcc)
        return E_FAIL;
    pccs = (CCS *)pdmcc->CustomData;
    if(!FGetNamedDwParam(sz, "addr", (DWORD *)&pccs->pb, szResp))
        return E_FAIL;
    if(!FGetNamedDwParam(sz, "length", &pdmcc->BytesRemaining, szResp))
        return E_FAIL;

    strcpy(szResp, "memory data follows");
    pdmcc->HandlingFunction = HrReportMemory;
    /* We'd like a ~1k buffer for sending data, but if we can't find the
     * memory, we'll just get the default buffer */
    pdmcc->BufferSize = 1056;
    pdmcc->Buffer = DmAllocatePoolWithTag(pdmcc->BufferSize, 'mdbX');
    return XBDM_MULTIRESPONSE;
}

HRESULT HrSetMemory(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    int i;
    char rgch[5];
    BYTE b;
    DWORD dwPageBase;
    BOOL fPageValid;
    int cb = 0;
    LPCSTR szData;
    BYTE *pb;

    if(!FGetNamedDwParam(sz, "addr", (DWORD *)&pb, szResp))
        return E_FAIL;
    szData = PchGetParam(sz, "data", FALSE);
    dwPageBase = (DWORD)pb + 0x1000;

    rgch[0] = '0';
    rgch[1] = 'x';
    rgch[4] = 0;

    if(szData) {
        for(;;++cb, ++pb) {
            if(FIsSpace(*szData))
                break;
            for(i = 0; i < 2; ++i) {
                if(!(*szData >= '0' && *szData <= '9' ||
                        *szData >= 'a' && *szData <= 'f' ||
                        *szData >= 'A' && *szData <= 'F')) {
                    strcpy(szResp, "400- syntax error in data");
                    return E_FAIL;
                }
                rgch[2+i] = *szData++;
            }
            b = (BYTE)DwFromSz(rgch, NULL);
            if(((DWORD)pb ^ dwPageBase) & 0xfffff000) {
                dwPageBase = (DWORD)pb & 0xfffff000;
                fPageValid = MmIsAddressValid(pb);
            }
            if(fPageValid)
                /* If there's a breakpoint at this address, we need to set
                 * the breakpoint data, not change the int 3 */
                fPageValid = FSetMemory(pb, b);
            if(!fPageValid) {
                sprintf(szResp, "set %d bytes", cb);
                return XBDM_MEMUNMAPPED;
            }
        }
    }
    sprintf(szResp, "set %d bytes", cb);
    return XBDM_NOERR;
}

HRESULT HrReportThreads(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    int ich;

    if(!pdmcc->BytesRemaining || !pccs->i) {
        DmFreePool(pccs->h);
        return XBDM_ENDOFLIST;
    }

    /* Pack as many thread ids into the buffer as we can */
    for(ich = 0; (DWORD)ich < pdmcc->BufferSize - 10 && pccs->i; ) {
        sprintf((LPSTR)pdmcc->Buffer + ich, "%d\015\012",
            ((LPDWORD)pccs->h)[--pccs->i]);
        while(((LPSTR)pdmcc->Buffer)[ich])
            ++ich;
    }

    pdmcc->DataSize = ich;
    return XBDM_NOERR;
}

HRESULT HrListThreads(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    HRESULT hr;

    if(!pdmcc)
        return E_FAIL;
    /* Make a list that we think will be big enough */
    pccs = (CCS *)pdmcc->CustomData;
    pccs->h = DmAllocatePoolWithTag(256 * sizeof(DWORD), 'mdbX');
    if(!pccs->h)
        return E_OUTOFMEMORY;
    pccs->i = 256;
    hr = DmGetThreadList((LPDWORD)pccs->h, (LPDWORD)&pccs->i);
    if(FAILED(hr)) {
        if(hr == XBDM_BUFFER_TOO_SMALL)
            hr = E_UNEXPECTED;
        DmFreePool(pccs->h);
    } else {
        hr = XBDM_MULTIRESPONSE;
        strcpy(szResp, "thread list follows");
    }
    pdmcc->HandlingFunction = HrReportThreads;
    return hr;
}

HRESULT HrHaltThread(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    DWORD tid;

    if(!FGetDwParam(sz, "thread", &tid))
        tid = 0;
    return DmHaltThread(tid);
}

HRESULT HrContinueThread(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD tid;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    return DmContinueThread(tid, (BOOL)PchGetParam(sz, "exception", FALSE));
}

HRESULT HrSuspendThread(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD tid;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    return DmSuspendThread(tid);
}

HRESULT HrResumeThread(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD tid;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    return DmResumeThread(tid);
}

HRESULT HrFunctionCall(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD tid;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    return DmSetupFunctionCall(tid);
}

typedef struct _CREG {
    char *szName;
    DWORD dwOffset;
    DWORD cb;
} CREG;

#define CtxOffset(field) ((DWORD)(&((PCONTEXT)0)->field))
#define Creg(reg) { #reg, CtxOffset(reg), sizeof ((PCONTEXT)0)->reg }
#define FpCreg(reg) { #reg, CtxOffset(FloatSave.reg), \
    sizeof ((PCONTEXT)0)->FloatSave.reg }

static CREG rgcregCtrl[] = {
    Creg(Ebp), Creg(Esp), Creg(Eip), Creg(EFlags)
};

static CREG rgcregInt[] = {
    Creg(Eax), Creg(Ebx), Creg(Ecx), Creg(Edx), Creg(Edi), Creg(Esi)
};

static CREG rgcregFPCtrl[] = {
    FpCreg(Cr0NpxState)
};

typedef struct _RCC {
    CONTEXT cr;
    union {
        struct {
            int irgcreg;
            CREG *pcreg;
            int icreg;
            CREG *pcregNext;
        };
        struct {
            DWORD tid;
            BOOL fSend;
            int iSend;
            int ib;
        };
    };
} RCC;

CREG *PcregNext(RCC *prcc)
{
    while(!prcc->icreg) {
        /* Time to switch to the next register set */
        switch(prcc->irgcreg) {
        case 0:
            if((prcc->cr.ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
                prcc->pcreg = rgcregCtrl;
                prcc->icreg = sizeof rgcregCtrl / sizeof(CREG);
            } else
                prcc->icreg = 0;
            ++prcc->irgcreg;
            break;
        case 1:
            if((prcc->cr.ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {
                prcc->pcreg = rgcregInt;
                prcc->icreg = sizeof rgcregInt / sizeof(CREG);
            } else
                prcc->icreg = 0;
            ++prcc->irgcreg;
            break;
        case 2:
            if((prcc->cr.ContextFlags & CONTEXT_FLOATING_POINT) ==
                CONTEXT_FLOATING_POINT)
            {
                prcc->pcreg = rgcregFPCtrl;
                prcc->icreg = sizeof rgcregFPCtrl / sizeof(CREG);
            } else
                prcc->icreg = 0;
            ++prcc->irgcreg;
            break;
        default:
            /* Nothing left */
            return prcc->pcregNext = NULL;
        }
    }
    --prcc->icreg;
    return prcc->pcregNext = prcc->pcreg++;
}

#define SIZE_OF_EXT_REGISTERS 0x200

HRESULT HrDoExtContext(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    RCC *prcc = (RCC *)pdmcc->CustomData;
    HRESULT hr = XBDM_NOERR;
    BOOL fDone = FALSE;

    if(prcc->fSend) {
        switch(prcc->iSend++) {
        case 0:
            pdmcc->DataSize = sizeof(DWORD);
            memcpy(pdmcc->Buffer, &pdmcc->BytesRemaining, pdmcc->DataSize);
            break;
        case 1:
            pdmcc->Buffer = &prcc->cr.FloatSave;
            pdmcc->DataSize = pdmcc->BytesRemaining;
            break;
        default:
            pdmcc->BytesRemaining = 0;
            break;
        }
        if(!pdmcc->BytesRemaining) {
            fDone = TRUE;
            hr = XBDM_ENDOFLIST;
        }
    } else if(pdmcc->DataSize != 0) {
        DWORD cbCopy = SIZE_OF_EXT_REGISTERS - prcc->ib;
        if(cbCopy > pdmcc->DataSize)
            cbCopy = pdmcc->DataSize;
        if(cbCopy)
            memcpy((BYTE *)&prcc->cr.FloatSave + prcc->ib, pdmcc->Buffer,
                cbCopy);
        pdmcc->BytesRemaining -= pdmcc->DataSize;
        prcc->ib += cbCopy;
        if(!pdmcc->BytesRemaining) {
            fDone = TRUE;
            prcc->cr.ContextFlags = CONTEXT_EXTENDED_REGISTERS;
            hr = DmSetThreadContext(prcc->tid, &prcc->cr);
        } else
            hr = XBDM_NOERR;
    } else
        fDone = TRUE;

    if(fDone)
        DmFreePool(prcc);
    return hr;
}

HRESULT HrGetExtContext(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    RCC *prcc;
    CONTEXT cr;
    HRESULT hr;
    DWORD tid;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    cr.ContextFlags = CONTEXT_EXTENDED_REGISTERS;
    hr = DmGetThreadContext(tid, &cr);
    if(SUCCEEDED(hr)) {
        if((cr.ContextFlags & CONTEXT_EXTENDED_REGISTERS) ==
            CONTEXT_EXTENDED_REGISTERS)
        {
            prcc = DmAllocatePoolWithTag(sizeof *prcc, 'rcmd');
            if(!prcc)
                return E_OUTOFMEMORY;
            memcpy(&prcc->cr, &cr, sizeof cr);
            prcc->iSend = 0;
            prcc->fSend = TRUE;
            pdmcc->CustomData = prcc;
            pdmcc->HandlingFunction = HrDoExtContext;
            ASSERT(SIZE_OF_EXT_REGISTERS <= sizeof prcc->cr.FloatSave);
            pdmcc->BytesRemaining = SIZE_OF_EXT_REGISTERS;
            hr = XBDM_BINRESPONSE;
        } else
            hr = XBDM_NOTSTOPPED;
    }
    return hr;
}

HRESULT HrReportContext(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    RCC *prcc = (RCC *)pdmcc->CustomData;
    DWORD ich = 0;
    DWORD ichLim = pdmcc->BufferSize - 22;
    CREG *pcreg;

    if(!pdmcc->BytesRemaining || !(pcreg = prcc->pcregNext)) {
        DmFreePool(prcc);
        return XBDM_ENDOFLIST;
    }

    /* Fill as much of the buffer as we can */
    while(pcreg && ich < ichLim) {
        if(pcreg->cb == 4)
            sprintf((char *)pdmcc->Buffer + ich, "%s=0x%08x\015\012",
                pcreg->szName, *(DWORD *)((BYTE *)&prcc->cr + pcreg->dwOffset));
        else
            sprintf((char *)pdmcc->Buffer + ich, "%s=0x%04x\015\012",
                pcreg->szName, *(USHORT *)((BYTE *)&prcc->cr + pcreg->dwOffset));
        while(((char *)pdmcc->Buffer)[ich])
            ++ich;
        pcreg = PcregNext(prcc);
    }

    pdmcc->DataSize = ich;
    return XBDM_NOERR;
}

HRESULT HrGetContext(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    RCC *prcc;
    CONTEXT cr;
    HRESULT hr;
    DWORD tid;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    cr.ContextFlags = 0;
    if(PchGetParam(sz, "control", FALSE))
        cr.ContextFlags |= CONTEXT_CONTROL;
    if(PchGetParam(sz, "int", FALSE))
        cr.ContextFlags |= CONTEXT_INTEGER;
    if(PchGetParam(sz, "full", FALSE))
        cr.ContextFlags |= CONTEXT_FULL;
    if(PchGetParam(sz, "fp", FALSE))
        cr.ContextFlags |= CONTEXT_FLOATING_POINT;
    hr = DmGetThreadContext(tid, &cr);
    if(SUCCEEDED(hr)) {
        prcc = DmAllocatePoolWithTag(sizeof *prcc, 'rcmd');
        if(!prcc)
            return E_OUTOFMEMORY;
        memcpy(&prcc->cr, &cr, sizeof cr);
        prcc->icreg = 0;
        prcc->irgcreg = 0;
        PcregNext(prcc);
        pdmcc->CustomData = prcc;
        pdmcc->HandlingFunction = HrReportContext;
        hr = XBDM_MULTIRESPONSE;
    }
    return hr;
}

HRESULT HrSetContext(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CONTEXT cr;
    HRESULT hr;
    DWORD dw;
    DWORD tid;
    RCC *prcc;
    DWORD cbExtRegs;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;

    /* If we're going to set the extended context, make sure we'll be able to
     * do so */
    if(FGetDwParam(sz, "ext", &cbExtRegs)) {
        if(!pdmcc)
            return E_FAIL;
        pdmcc->BytesRemaining = cbExtRegs;
        prcc = DmAllocatePoolWithTag(sizeof *prcc, 'rcmd');
        if(!prcc)
            return E_OUTOFMEMORY;
    } else
        prcc = NULL;

    /* We need the current context and then we'll modify the appropriate
     * fields */
    cr.ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT;
    hr = DmGetThreadContext(tid, &cr);
    if(SUCCEEDED(hr)) {
        int icreg;
        int irgcreg;
        CREG *pcreg;

        for(irgcreg = 0; irgcreg < 2; ++irgcreg) {
            switch(irgcreg) {
            case 0:
                pcreg = rgcregCtrl;
                icreg = sizeof rgcregCtrl / sizeof(CREG);
                break;
            case 1:
                pcreg = rgcregInt;
                icreg = sizeof rgcregInt / sizeof(CREG);
                break;
            case 2:
                pcreg = rgcregFPCtrl;
                icreg = sizeof rgcregFPCtrl / sizeof(CREG);
                break;
            }

            for(; icreg--; ++pcreg) {
                if(FGetDwParam(sz, pcreg->szName, &dw)) {
                    if(pcreg->cb == 4)
                        *(DWORD *)((BYTE *)&cr + pcreg->dwOffset) = dw;
                    else
                        *(USHORT *)((BYTE *)&cr + pcreg->dwOffset) = (USHORT)dw;
                }
            }
        }
        hr = DmSetThreadContext(tid, &cr);
    }
    /* Now see if we want to capture the extended context */
    if(prcc) {
        if(SUCCEEDED(hr)) {
            /* We're not going to be getting the cr0 state when the data
             * comes in, so we'll put it in now */
            prcc->cr.FloatSave.Cr0NpxState = cr.FloatSave.Cr0NpxState;
            pdmcc->CustomData = prcc;
            pdmcc->Buffer = NULL;
            prcc->fSend = FALSE;
            prcc->ib = 0;
            prcc->tid = tid;
            pdmcc->HandlingFunction = HrDoExtContext;
            hr = XBDM_READYFORBIN;
        } else
            DmFreePool(prcc);
    }

    return hr;
}

void FillSzFromWz(char *sz, int cch, WCHAR *wz, int cwch)
{
    if(cwch < 0) {
        while(*wz && cch > 1) {
            *sz++ = (char)*wz++;
            --cch;
        }
    } else {
        while(cwch && cch > 1) {
            *sz++ = (char)*wz++;
            --cch;
            --cwch;
        }
    }
    *sz = 0;
}

HRESULT HrReportCounters(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    HRESULT hr;
    DWORD cch;
    DM_COUNTINFO dmci;

    if(!pdmcc->BytesRemaining) {
        DmCloseCounters(pccs->pdmwc);
        return XBDM_ENDOFLIST;
    }

    cch = pdmcc->BufferSize;
    hr = DmWalkPerformanceCounters(&pccs->pdmwc, &dmci);
    if(SUCCEEDED(hr))
        sprintf(pdmcc->Buffer, "name=\"%s\" type=0x%08x", dmci.Name,
            dmci.Type);
    else {
        DmCloseCounters(pccs->pdmwc);
        pdmcc->BytesRemaining = 0;
    }
    return hr;
}

HRESULT HrListCounters(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    if(!pdmcc)
        return E_FAIL;
    pccs = (CCS *)pdmcc->CustomData;
    pccs->pdmwc = NULL;
    pdmcc->HandlingFunction = HrReportCounters;
    return XBDM_MULTIRESPONSE;
}

HRESULT HrReportCounterData(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    switch(pdmcc->BytesRemaining++) {
    case 1:
        sprintf(pdmcc->Buffer, "type=0x%08x vallo=0x%08x "
            "valhi=0x%08x ratelo=0x%08x ratehi=0x%08x", pccs->dmcd.CountType,
            pccs->dmcd.CountValue.LowPart, pccs->dmcd.CountValue.HighPart,
            pccs->dmcd.RateValue.LowPart, pccs->dmcd.RateValue.HighPart);
        break;
    default:
        return XBDM_ENDOFLIST;
    }
    return XBDM_NOERR;
}

HRESULT HrQueryPerformanceCounter(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    HRESULT hr;
    char szName[256];
    HANDLE h;
    DWORD dwType;

    if(!pdmcc)
        return E_FAIL;

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    if(!FGetNamedDwParam(sz, "type", &dwType, szResp))
        return E_FAIL;

    hr = DmOpenPerformanceCounter(szName, &h);
    if(SUCCEEDED(hr)) {
        pccs = (CCS *)pdmcc->CustomData;
        hr = DmQueryPerformanceCounterHandle(h, dwType, &pccs->dmcd);
        NtClose(h);
    }
    if(SUCCEEDED(hr)) {
        pdmcc->HandlingFunction = HrReportCounterData;
        pdmcc->BytesRemaining = 1;
        hr = XBDM_MULTIRESPONSE;
        strcpy(szResp, "counter data follows");
    }
    return hr;
}

HRESULT HrReportModules(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    HRESULT hr;
    DMN_MODLOAD dmml;

    if(!pdmcc->BytesRemaining) {
        DmCloseLoadedModules(pccs->pdmwm);
        return XBDM_ENDOFLIST;
    }

    hr = DmWalkLoadedModules(&pccs->pdmwm, &dmml);
    if(SUCCEEDED(hr))
        GetModLoadSz(pdmcc->Buffer, &dmml);
    else {
        DmCloseLoadedModules(pccs->pdmwm);
        pdmcc->BytesRemaining = 0;
    }
    return hr;
}

HRESULT HrListModules(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    if(!pdmcc)
        return E_FAIL;
    pccs = (CCS *)pdmcc->CustomData;
    pccs->pdmwm = NULL;
    pdmcc->HandlingFunction = HrReportModules;
    return XBDM_MULTIRESPONSE;
}

HRESULT HrReportModuleSections(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    DMN_SECTIONLOAD dmsl;
    HRESULT hr;

    if(!pdmcc->BytesRemaining) {
        DmCloseModuleSections(pccs->pdmws);
        return XBDM_ENDOFLIST;
    }

    hr = DmWalkModuleSections(&pccs->pdmws, NULL, &dmsl);
    if(SUCCEEDED(hr))
        GetSectLoadSz(pdmcc->Buffer, &dmsl);
    else {
        DmCloseModuleSections(pccs->pdmws);
        pdmcc->BytesRemaining = 0;
    }
    return hr;
}

HRESULT HrListModuleSections(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    char szName[MAX_OBJ_PATH+1];
    HRESULT hr;
    DMN_SECTIONLOAD dmsl;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }
    pccs = (CCS *)pdmcc->CustomData;
    pccs->pdmws = NULL;
    hr = DmWalkModuleSections(&pccs->pdmws, szName, &dmsl);
    if(SUCCEEDED(hr) || hr == XBDM_ENDOFLIST) {
        pdmcc->HandlingFunction = HrReportModuleSections;
        RewindDmws(pccs->pdmws);
        hr = XBDM_MULTIRESPONSE;
    }
    return hr;
}

HRESULT HrDoBreak(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    PVOID pvAddr;
    HRESULT hr;
    BOOL fClear;

#if 0
    if(PchGetParam(sz, "list", FALSE)) {
        DoListBreakpoints(isock);
        return;
    }
#endif
    if(PchGetParam(sz, "now", FALSE)) {
        Sleep(250);
        _asm int 3
        return XBDM_NOERR;
    }
    if(PchGetParam(sz, "start", FALSE)) {
        hr = DmSetInitialBreakpoint();
        if(FAILED(hr))
            strcpy(szResp, "execution not pending");
        return hr;
    }
    if(PchGetParam(sz, "clearall", FALSE)) {
        RemoveAllBreakpoints();
        return XBDM_NOERR;
    }
    fClear = PchGetParam(sz, "clear", FALSE) != 0;
    if(FGetNamedDwParam(sz, "addr", (DWORD *)&pvAddr, szResp)) {
        if(fClear)
            /* We're only removing this breakpoint */
            hr = DmRemoveBreakpoint(pvAddr);
        else
            hr = DmSetBreakpoint(pvAddr);
    } else {
        /* See if we're doing a hw breakpoint */
        DWORD dwType = DMBREAK_NONE;
        DWORD dwSize = 0;

        if(FGetDwParam(sz, "read", (DWORD *)&pvAddr))
            dwType = DMBREAK_READWRITE;
        else if(FGetDwParam(sz, "write", (DWORD *)&pvAddr))
            dwType = DMBREAK_WRITE;
        else if(FGetDwParam(sz, "execute", (DWORD *)&pvAddr))
            dwType = DMBREAK_EXECUTE;
        if(dwType == DMBREAK_NONE)
            /* Never saw a valid command */
            hr = E_FAIL;
        else if(fClear || FGetNamedDwParam(sz, "size", &dwSize, szResp)) {
            szResp[0] = 0;
            hr = DmSetDataBreakpoint(pvAddr, fClear ? DMBREAK_NONE : dwType,
                dwSize);
        } else
            hr = E_FAIL;
    }
    return hr;
}

HRESULT HrIsBreak(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    PVOID pvAddr;
    DWORD dwType;
    HRESULT hr;

    if(!FGetNamedDwParam(sz, "addr", (DWORD *)&pvAddr, szResp))
        return E_FAIL;

    hr = DmIsBreakpoint(pvAddr, &dwType);
    if(SUCCEEDED(hr))
        sprintf(szResp, "type=%d", dwType);
    return hr;
}

HRESULT HrSetConfig(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    ULONG ulIndex;
    DWORD dwValue;

    if(!FGetNamedDwParam(sz, "index", &ulIndex, szResp))
        return E_FAIL;

    if(!FGetNamedDwParam(sz, "value", &dwValue, szResp))
        return E_FAIL;

    if (!NT_SUCCESS(ExSaveNonVolatileSetting(ulIndex, REG_DWORD, &dwValue, sizeof(DWORD))))
    {
        strcpy(szResp, "setvalue failed");
        return E_FAIL;
    }

    return XBDM_NOERR;
}

#if 0
void DoListBreakpoints(int isock)
{
    SOCKET s = rgsockConnect[isock];
    BYTE *pb = (BYTE *)-1;
    char sz[64];

    PrintSockLine(s, "202- breakpoint list follows");
    while(FGetNextBreakpoint(&pb)) {
        sprintf(sz, "0x%08x", pb);
        PrintSockLine(s, sz);
    }
    PrintSockLine(s, ".");
}
#endif

HRESULT HrIsStopped(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    DM_THREADSTOP dmts;
    DWORD tid;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    hr = DmIsThreadStopped(tid, &dmts);
    if(SUCCEEDED(hr)) {
        switch(dmts.NotifiedReason) {
        case DM_DEBUGSTR:
            sprintf(szResp, "debugstr thread=%d stop",
                dmts.u.DebugStr.ThreadId);
            break;
        case DM_ASSERT:
            sprintf(szResp, "assert prompt thread=%d stop",
                dmts.u.DebugStr.ThreadId);
            break;
        default:
            if(!FGetNotifySz(dmts.NotifiedReason, (DWORD)&dmts.u, szResp))
                strcpy(szResp, "stopped");
            break;
        }
    }
    return hr;
}

HRESULT HrReportThreadInfo(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    switch(pdmcc->BytesRemaining++) {
    case 1:
        sprintf(pdmcc->Buffer, "suspend=%d priority=%d tlsbase=0x%08x",
            pccs->dmti.SuspendCount, pccs->dmti.Priority, pccs->dmti.TlsBase);
        break;
    default:
        return XBDM_ENDOFLIST;
    }
    return XBDM_NOERR;
}

HRESULT HrThreadInfo(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    DWORD tid;
    CCS *pccs;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    pccs = (CCS *)pdmcc->CustomData;
    hr = DmGetThreadInfo(tid, &pccs->dmti);
    if(SUCCEEDED(hr)) {
        pdmcc->HandlingFunction = HrReportThreadInfo;
        pdmcc->BytesRemaining = 1;
        hr = XBDM_MULTIRESPONSE;
        strcpy(szResp, "thread info follows");
    }
    return hr;
}

HRESULT HrReportXapiInfo(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    switch(pdmcc->BytesRemaining++) {
    case 1:
        sprintf(pdmcc->Buffer, "lasterr=0x%08x", pccs->dmxd.LastErrorOffset);
        break;
    default:
        return XBDM_ENDOFLIST;
    }
    return XBDM_NOERR;
}

HRESULT HrXapiInfo(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    DWORD tid;
    CCS *pccs;

    if(!pdmcc)
        return E_FAIL;
    pccs = (CCS *)pdmcc->CustomData;
    hr = DmGetXtlData(&pccs->dmxd);
    if(SUCCEEDED(hr)) {
        pdmcc->HandlingFunction = HrReportXapiInfo;
        pdmcc->BytesRemaining = 1;
        hr = XBDM_MULTIRESPONSE;
        strcpy(szResp, "xtl info follows");
    }
    return hr;
}

HRESULT HrDoLongName(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    char szModule[MAX_OBJ_PATH+1];

    if(!FGetSzParam(sz, "name", szModule, sizeof szModule)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    hr = DmGetModuleLongName(szModule, szResp, &cchResp);
    if(hr == E_FAIL)
        strcpy(szResp, "no long name available");
    return hr;
}

HRESULT HrReportXbeInfo(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    switch(pccs->iiXbe++) {
    case 0:
        sprintf(pdmcc->Buffer, "timestamp=0x%08x", pccs->pxbe->TimeStamp);
        break;
    case 1:
        sprintf(pdmcc->Buffer, "checksum=0x%08x", pccs->pxbe->CheckSum);
        break;
    case 2:
        /* We're a little sneaky with the name -- we know the buffer we have
         * for the name is big enough, so we slide it over, overwriting the
         * timestamp and checksum values, and insert the "name=" in front */
        memmove(&pccs->pxbe->LaunchPath[5], pccs->pxbe->LaunchPath,
            MAX_PATH + 1);
        memcpy(pccs->pxbe->LaunchPath, "name=", 5);
        pdmcc->Buffer = pccs->pxbe->LaunchPath;
        break;
    default:
        pdmcc->BytesRemaining = 0;
        break;
    }

    if(!pdmcc->BytesRemaining) {
        DmFreePool(pccs->pxbe);
        return XBDM_ENDOFLIST;
    }
    return XBDM_NOERR;
}

HRESULT HrXbeInfo(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    char szName[MAX_OBJ_PATH+1];
    char *pszName;
    CCS *pccs;
    HRESULT hr;

    if(!pdmcc)
        return E_FAIL;
    if(PchGetParam(sz, "running", FALSE))
        pszName = NULL;
    else if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    } else
        pszName = szName;
    pccs = (CCS *)pdmcc->CustomData;
    pccs->pxbe = DmAllocatePoolWithTag(sizeof(DM_XBE), 'dmbX');
    if(!pccs->pxbe)
        return E_OUTOFMEMORY;
    hr = DmGetXbeInfo(pszName, pccs->pxbe);
    if(FAILED(hr))
        DmFreePool(pccs->pxbe);
    else {
        pdmcc->HandlingFunction = HrReportXbeInfo;
        pdmcc->BytesRemaining = 1;
        pccs->iiXbe = 0;
        hr = XBDM_MULTIRESPONSE;
    }
    return hr;
}

BOOL DmIsDebuggerPresent(void)
{
    return g_fDebugging;
}

HRESULT HrConnectDebugger(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    if(g_dmi.Flags & DMIFLAG_RUNSHELL)
        return XBDM_NOTDEBUGGABLE;
    if(PchGetParam(sz, "connect", FALSE)) {
        g_fDebugging = TRUE;
        fAllowKd = FALSE;
    } else if(PchGetParam(sz, "disconnect", FALSE))
        g_fDebugging = FALSE;
    else {
        sprintf(szResp, "no command");
        return E_FAIL;
    }
    return XBDM_NOERR;
}

HRESULT HrSystemTime(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    LARGE_INTEGER li;

    KeQuerySystemTime(&li);
    if(li.HighPart > 0x20000000)
        return XBDM_CLOCKNOTSET;
    sprintf(szResp, "high=0x%x low=0x%x", li.HighPart, li.LowPart);
    return XBDM_NOERR;
}

HRESULT HrGetAltAddr(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    XNADDR xna;
    int err;

    err = XNetGetTitleXnAddr(&xna);
    if(err == XNET_GET_XNADDR_NONE || err == XNET_GET_XNADDR_PENDING)
        return E_FAIL;
    sprintf(szResp, "addr=0x%08x", ntohl(xna.ina.s_addr));
    return XBDM_NOERR;
}

HRESULT HrSetSystemTime(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    LARGE_INTEGER li;
    NTSTATUS st;
    DWORD tzflag;

    if(!FGetDwParam(sz, "clockhi", &li.HighPart) || !FGetDwParam(sz, "clocklo", &li.LowPart))
        return XBDM_CLOCKNOTSET;
    st = NtSetSystemTime(&li, NULL);

    // Set default timezone and language if necessary
    if (FGetDwParam(sz, "tz", &tzflag)) {
        XBOX_USER_SETTINGS userSettings;
        ULONG type, length;
        st = ExQueryNonVolatileSetting(
                XC_MAX_OS,
                &type,
                &userSettings,
                sizeof(userSettings),
                &length);

        if (NT_SUCCESS(st)) {
            BOOL isInvalid = FALSE;
            // Default to Pacific time zone if not set
            if (XBOX_INVALID_TIMEZONE_SETTING(userSettings)) {
                userSettings.TimeZoneBias = 480;
                strncpy(userSettings.TimeZoneStdName, "PST", XC_TZNAMELEN);
                strncpy(userSettings.TimeZoneDltName, "PDT", XC_TZNAMELEN);
                userSettings.TimeZoneStdBias = 0;
                userSettings.TimeZoneDltBias = -60;
                userSettings.TimeZoneStdDate.Month = 10;
                userSettings.TimeZoneStdDate.Day = 5;
                userSettings.TimeZoneStdDate.DayOfWeek = 0;
                userSettings.TimeZoneStdDate.Hour = 0;
                userSettings.TimeZoneDltDate.Month = 4;
                userSettings.TimeZoneDltDate.Day = 1;
                userSettings.TimeZoneDltDate.DayOfWeek = 0;
                userSettings.TimeZoneDltDate.Hour = 0;
                isInvalid = TRUE;
            }

            // Default language to English if not set
            if (userSettings.Language == XC_LANGUAGE_UNKNOWN) {
                userSettings.Language = XC_LANGUAGE_ENGLISH;
                isInvalid = TRUE;
            }

            if (isInvalid) {
                st = ExSaveNonVolatileSetting(
                        XC_MAX_OS,
                        REG_BINARY,
                        &userSettings,
                        sizeof(userSettings));
            }
        }
    }

    return NT_SUCCESS(st) ? XBDM_NOERR : XBDM_CLOCKNOTSET;
}

HRESULT HrReboot(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    int icst;
    DWORD dw = 0;

    if(!pdmcc)
        return FALSE;
    icst = (PCST)pdmcc - rgcst;
    PrintSockLine(rgcst[icst].s, "200- OK");

    if(PchGetParam(sz, "stop", FALSE))
        dw |= DMBOOT_STOP;
    if(PchGetParam(sz, "wait", FALSE))
        dw |= DMBOOT_WAIT;
    if(PchGetParam(sz, "warm", FALSE))
        dw |= DMBOOT_WARM;
    if(PchGetParam(sz, "nodebug", FALSE))
        dw |= DMBOOT_NODEBUG;
    DmReboot(dw);
    return 0;
}

HRESULT HrMagicReboot(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    int icst;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING objectName;
    IO_STATUS_BLOCK iosb;
    NTSTATUS st;
    OCHAR oszTitle[MAX_OBJ_PATH+1];
    OCHAR *pochTitle;
    OCHAR *poch;
    char szTitle[MAX_OBJ_PATH+1];
    DWORD dwFlags = DMBOOT_NODEBUG | DMBOOT_WARM;

    if(!FGetSzParam(sz, "title", szTitle, sizeof szTitle)) {
        strcpy(szResp, "missing title");
        return E_FAIL;
    }

    if(PchGetParam(sz, "debug", FALSE))
        dwFlags &= ~DMBOOT_NODEBUG;

    if(!FFileNameToObName(szTitle, oszTitle, sizeof oszTitle / sizeof(OCHAR)))
        return XBDM_NOSUCHFILE;

    for(poch = oszTitle; *poch; ++poch)
        if(*poch == '\\')
            pochTitle = poch;

    DmStop();
    /* Verify the file exists */
    RtlInitObjectString(&objectName, oszTitle);
    InitializeObjectAttributes(&oa, &objectName, OBJ_CASE_INSENSITIVE, NULL,
        NULL);
    st = NtOpenFile(&h, SYNCHRONIZE, &oa, &iosb, FILE_SHARE_READ,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        NtClose(h);
        *pochTitle++ = 0;
        st = NT_SUCCESS(XWriteTitleInfoNoReboot(pochTitle, oszTitle, LDT_NONE,
            0, NULL));
        if(NT_SUCCESS(st)) {
            icst = (PCST)pdmcc - rgcst;
            PrintSockLine(rgcst[icst].s, "200- OK");
            DmReboot(dwFlags);
        }
    }
    return HrFromStatus(st, E_FAIL);
}

#include "xprofp.h"
#define XBOX_CAP_FILENAME "E:\\xboxcap.dat"

XProfpFileHeader* CAPGetFileHeader()
{
    XProfpFileHeader* fileheader = (XProfpFileHeader*)
        MmAllocateSystemMemory(XPROF_FILE_HEADER_SIZE, PAGE_READWRITE);

    if (fileheader) {
        PLIST_ENTRY list, head;
        ULONG count;

        memset(fileheader, 0, XPROF_FILE_HEADER_SIZE);
        fileheader->version = XPROF_FILE_VERSION;

        // save information about currently loaded modules
        head = g_dmi.LoadedModuleList;
        list = head->Flink;
        for (count=0; list != head; list=list->Flink) {
            PLDR_DATA_TABLE_ENTRY entry;
            WCHAR* wstr;
            CHAR* str;
            ULONG len;

            entry = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
            fileheader->modules[count].loadaddr = (ULONG) entry->DllBase;
            fileheader->modules[count].size = entry->SizeOfImage;

            len = entry->BaseDllName.Length / sizeof(WCHAR);
            if (len >= XPROF_MAX_MODULE_NAMELEN-1) {
                // The base DLL name is too long
                // Just ignore this module.
                continue;
            }

            // Truncate unicode name to ASCII
            wstr = entry->BaseDllName.Buffer;
            str = fileheader->modules[count].name;
            while (len--)
                *str++ = (CHAR) *wstr++;

            // Null-terminator
            *str = 0;
            count++;
        }

        fileheader->module_count = count;
    }

    return fileheader;
}

NTSTATUS CAPWriteFile(XProfpGlobals* xprofData)
{
    BYTE* bufstart = (BYTE*) xprofData->bufstart;
    BYTE* bufend = (BYTE*) xprofData->bufnext_stopped;
    HANDLE file = NULL;
    XProfpFileHeader* fileheader = NULL;
    ULONG count;
    NTSTATUS status;
    IO_STATUS_BLOCK iostatusBlock;
    FILE_END_OF_FILE_INFORMATION endOfFile;
    FILE_ALLOCATION_INFORMATION allocation;

    // Sanity check
    if (!bufstart || !bufend || bufend <= bufstart) {
        return STATUS_UNSUCCESSFUL;
    }

    // Create the file for writing
    //  we're doing sequential writes only and
    //  we don't need intermediate buffering

    count = bufend - bufstart;
    ASSERT(((ULONG_PTR) bufstart % PAGE_SIZE) == 0);

    status = FCreateFile(
                &file,
                GENERIC_WRITE | SYNCHRONIZE,
                XBOX_CAP_FILENAME,
                NULL,
                0,
                0,
                FILE_OVERWRITE_IF,
                FILE_SYNCHRONOUS_IO_NONALERT |
                    FILE_SEQUENTIAL_ONLY |
                    FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) goto exit;

    // Generate the profile data file header
    fileheader = CAPGetFileHeader();
    if (!fileheader) {
        status = STATUS_NO_MEMORY;
        goto exit;
    }

    ASSERT(XPROF_FILE_HEADER_SIZE % PAGE_SIZE == 0);
    status = NtWriteFile(
                file,
                NULL,
                NULL,
                NULL,
                &iostatusBlock,
                fileheader,
                XPROF_FILE_HEADER_SIZE,
                NULL);

    if (!NT_SUCCESS(status)) goto exit;

    // Write the profile data out to disk
    //  size is rounded up to a multiple of 512
    status = NtWriteFile(
                file,
                NULL,
                NULL,
                NULL,
                &iostatusBlock,
                bufstart,
                (count + 511) & ~511,
                NULL);

    if (!NT_SUCCESS(status)) goto exit;

    // Set file size
    count += XPROF_FILE_HEADER_SIZE;
    endOfFile.EndOfFile.QuadPart = count;
    status = NtSetInformationFile(
                file,
                &iostatusBlock,
                &endOfFile,
                sizeof(endOfFile),
                FileEndOfFileInformation);

    if (!NT_SUCCESS(status)) goto exit;

    allocation.AllocationSize.QuadPart = count;
    status = NtSetInformationFile(
                file,
                &iostatusBlock,
                &allocation,
                sizeof(allocation),
                FileAllocationInformation);

exit:
    if (file) { NtClose(file); }
    if (fileheader) { MmFreeSystemMemory(fileheader, XPROF_FILE_HEADER_SIZE); }
    return status;
}

HRESULT HrCAPControl(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS status = STATUS_NOT_IMPLEMENTED;

    if (PchGetParam(sz, "start", FALSE)) {
        // Start profile data collection
        status = DmCapControl(XPROF_START, 0);
    } else {
        // Stop profile data collection
        status = DmCapControl(XPROF_STOP, 0);

        // Save the profile data to disk
        if (NT_SUCCESS(status)) {
            XProfpGlobals* xprofData = DmProfileData;
            LONG lock;

            // Prevent other threads from freeing the profile data buffer
            // while we're trying to write it to disk
            lock = InterlockedCompareExchange(&xprofData->lock, 1, 0);

            if (lock != 0) {
                status = STATUS_DEVICE_BUSY;
            } else {
                CAPWriteFile(xprofData);

                // Unlock the profile data buffer
                xprofData->lock = 0;
            }
        }
    }

    if (NT_SUCCESS(status)) return XBDM_NOERR;

    // Note: should we map error status to HRESULT?
    sprintf(szResp, "error status 0x%08x", status);
    return XBDM_UNDEFINED;
}

HRESULT HrIrtSweep(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS status = STATUS_NOT_IMPLEMENTED;
    HANDLE file;

    #ifdef _XBOX_ENABLE_PROFILING
    #define IRTSWEEP_FILENAME "E:\\irtsweep.dat"

    status = FCreateFile(
                &file,
                GENERIC_WRITE | SYNCHRONIZE,
                IRTSWEEP_FILENAME,
                NULL,
                0,
                0,
                FILE_OVERWRITE_IF,
                FILE_SYNCHRONOUS_IO_NONALERT |
                    FILE_SEQUENTIAL_ONLY |
                    FILE_NO_INTERMEDIATE_BUFFERING);

    if (NT_SUCCESS(status)) {
        status = IrtSweep(file);
        NtClose(file);
    }

    #endif

    if (NT_SUCCESS(status)) return XBDM_NOERR;
    sprintf(szResp, "error status 0x%08x", status);
    return XBDM_UNDEFINED;
}

HRESULT HrReceiveKernelImage(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    HRESULT hr = XBDM_NOERR;
    DWORD crc;
    CCS *pccs;

    pccs = pdmcc->CustomData;

    if (pdmcc->DataSize) {
        if ( pccs->KernelImage.BytesReceived + pdmcc->DataSize <= \
             pccs->KernelImage.ImageSize) {
            CopyMemory(pccs->KernelImage.ImageBuffer + pccs->KernelImage.BytesReceived, \
                pdmcc->Buffer, pdmcc->DataSize);
        }
        pdmcc->BytesRemaining -= pdmcc->DataSize;
        pccs->KernelImage.BytesReceived += pdmcc->DataSize;
    } else if (pdmcc->BytesRemaining) {
        DmFreePool(pccs->KernelImage.ImageBuffer);
        DmFreePool(pdmcc->Buffer);
        return E_UNEXPECTED;
    }

    if (pdmcc->BytesRemaining == 0) {
        crc = Crc32(0xFFFFFFFF, pccs->KernelImage.ImageBuffer, pccs->KernelImage.ImageSize);
        if (pccs->KernelImage.Crc != crc) {
            _snprintf(szResponse, cchResponse, "bad data detected in kernel image");
            hr = E_UNEXPECTED;
        } else {
            _snprintf(szResponse, cchResponse, "flashing...");
            Sleep(250);
            hr = FlashKernelImage(pccs->KernelImage.ImageBuffer,
                    pccs->KernelImage.ImageSize, szResponse, cchResponse,
                    pccs->KernelImage.IgnoreVersionChecking);
        }
        DmFreePool(pccs->KernelImage.ImageBuffer);
        DmFreePool(pdmcc->Buffer);
    }

    return hr;
}

HRESULT HrFlashKernelImage(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    SIZE_T ImageSize;
    BOOL IgnoreVersionChecking = FALSE;

    if (!pdmcc) {
        return E_FAIL;
    }

    pccs = (CCS *)pdmcc->CustomData;

    if (!FGetNamedDwParam(sz, "length", &ImageSize, szResp) || \
        !FGetNamedDwParam(sz, "crc", &pccs->KernelImage.Crc, szResp)) {
        _snprintf(szResp, cchResp, "Invalid parameter(s)");
        return E_FAIL;
    }

    FGetNamedDwParam(sz, "ignoreversionchecking", &IgnoreVersionChecking, szResp);
    pccs->KernelImage.IgnoreVersionChecking = IgnoreVersionChecking;

    pccs->KernelImage.ImageSize = ImageSize;
    pdmcc->BytesRemaining = ImageSize;

    if (ImageSize < 0x80000 || (ImageSize & (ImageSize - 1)) != 0) {
        _snprintf(szResp, cchResp, "Invalid kernel image size");
        return E_FAIL;
    }

    pccs->KernelImage.ImageBuffer = DmAllocatePoolWithTag(ImageSize, 'mdbX');

    if (!pccs->KernelImage.ImageBuffer) {
        _snprintf(szResp, cchResp, "Not enough memory");
        return HrFromStatus(STATUS_NO_MEMORY, XBDM_UNDEFINED);
    }

    pdmcc->Buffer = DmAllocatePoolWithTag(0x2000, 'mdbX');

    if (!pdmcc->Buffer) {
        DmFreePool(pccs->KernelImage.ImageBuffer);
        _snprintf(szResp, cchResp, "Not enough memory");
        return HrFromStatus(STATUS_NO_MEMORY, XBDM_UNDEFINED);
    }

    pdmcc->BufferSize = 0x2000;
    pdmcc->HandlingFunction = HrReceiveKernelImage;
    pccs->KernelImage.BytesReceived = 0;

    return XBDM_READYFORBIN;
}

typedef struct _DRIVENAME_CONVERSION_ENTRY
{
    PCOSTR  ObjectName;
    ULONG   ObjectNameLength; //Without a terminating NULL
    OCHAR       DriveName;
    BOOL    Visible;
} DRIVENAME_TABLE_ENTRY, *PDRIVENAME_TABLE_ENTRY;
extern DRIVENAME_TABLE_ENTRY DriveNameConversionTable[];

HRESULT HrGetDriveList(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    char szName[8];
    OBJECT_STRING objectName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE h;
    DRIVENAME_TABLE_ENTRY *pdte;
    struct {
        OBJECT_DIRECTORY_INFORMATION odi;
        OCHAR sz[256];
    } odi;

    RtlInitObjectString(&objectName, "");
    InitializeObjectAttributes(&objectAttributes, &objectName,
        OBJ_CASE_INSENSITIVE, ObDosDevicesDirectory(), NULL);

    status = NtOpenDirectoryObject(&h, &objectAttributes);
    if(NT_SUCCESS(status)) {
        int i = 0;

        // Query the directory object to get the list of actual drives
        for(;;) {
            status = NtQueryDirectoryObject(h, &odi, sizeof odi, (i == 0), &i,
                NULL);
            if (!NT_SUCCESS(status))
                break;

            /* Reject this drive if it's not one character plus a colon */
            if(odi.odi.Name.Length != 2 || odi.odi.Name.Buffer[1] != ':')
                continue;

            /* Compare each drive in the drivename conversion table to the
             * current enumerated drive.  If there is a match, then that drive
             * has been remapped - let the table handling code below deal with
             * it */
            for(pdte = DriveNameConversionTable; pdte->ObjectName; ++pdte) {
                BYTE bMask;
                if(pdte->DriveName < 'A' || (pdte->DriveName & 0xDF) > 'Z')
                    bMask = 0xFF;
                else
                    bMask = 0xDF;
                /* Compare case-insensitive */
                if (!((odi.odi.Name.Buffer[0] ^ pdte->DriveName) & bMask))
                {
                    /* Found a matching entry - ignore the entry; it'll get
                     * handled in the table handling code below */
                    break;
                }
            }

            if (!pdte->ObjectName)
            {
                HANDLE hT;
                /* The current enumerated drive does not exist in the table.
                 * We'll need to handle it here.  Is the drive mounted? */
                odi.odi.Name.Buffer[2] = '\\';
                odi.odi.Name.Length = 3;
                InitializeObjectAttributes(&objectAttributes, &odi.odi.Name,
                    OBJ_CASE_INSENSITIVE, ObDosDevicesDirectory(), NULL);
                status = NtOpenFile(&hT, SYNCHRONIZE,&objectAttributes, &iosb,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
                if (NT_SUCCESS(status))
                {
                    *szResp++ = odi.odi.Name.Buffer[0];
                    NtClose(hT);
                }
            }
        }
        NtClose(h);
    }

    // Enumerate through the conversion table
    szName[1] = ':';
    szName[2] = '\\';
    szName[3] = 0;
    for(pdte = DriveNameConversionTable; pdte->ObjectName; ++pdte) {
        if (pdte->Visible)
        {
            // Is the drive mounted?
            szName[0] = pdte->DriveName;
            status = FCreateFile(&h, SYNCHRONIZE, szName, NULL, 0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN, FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
            if (NT_SUCCESS(status))
            {
                *szResp++ = pdte->DriveName;
                NtClose(h);
            }
        }
    }

    // Close off the 'list' string value
    *szResp = 0;

    // Mark that we've been through here once so that next time through we know we're done
    return XBDM_NOERR;
}

HRESULT HrReportDriveFreeSpace(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION NormalSizeInfo;
    CCS *pccs = (CCS *)pdmcc->CustomData;

    ULARGE_INTEGER FreeBytesAvailableToCaller;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER BytesPerAllocationUnit;

    if (pdmcc->BytesRemaining-- == 0)
    {
        // Already sent the data, so close the file, free up our buffer, and return "we're done!"
        NtClose(pccs->h);
        DmFreePool(pdmcc->Buffer);
        pdmcc->Buffer = NULL;
        return XBDM_ENDOFLIST;
    }

    // Determine the size parameters of the volume.
    Status = NtQueryVolumeInformationFile(
                pccs->h,
                &IoStatusBlock,
                &NormalSizeInfo,
                sizeof(NormalSizeInfo),
                FileFsSizeInformation
                );

    if ( !NT_SUCCESS(Status) ) {
        sprintf(pdmcc->Buffer, "unknown error (%d)", Status);
        return E_FAIL;
    }

    BytesPerAllocationUnit.QuadPart     = NormalSizeInfo.BytesPerSector   * NormalSizeInfo.SectorsPerAllocationUnit;
    FreeBytesAvailableToCaller.QuadPart = BytesPerAllocationUnit.QuadPart * NormalSizeInfo.AvailableAllocationUnits.QuadPart;
    TotalNumberOfBytes.QuadPart         = BytesPerAllocationUnit.QuadPart * NormalSizeInfo.TotalAllocationUnits.QuadPart;

    // Add the results to the result string
    sprintf(pdmcc->Buffer, "freetocallerlo=0x%08x freetocallerhi=0x%08x totalbyteslo=0x%08x totalbyteshi=0x%08x totalfreebyteslo=0x%08x totalfreebyteshi=0x%08x",
            FreeBytesAvailableToCaller.LowPart, FreeBytesAvailableToCaller.HighPart,
            TotalNumberOfBytes.LowPart, TotalNumberOfBytes.HighPart,
            FreeBytesAvailableToCaller.LowPart, FreeBytesAvailableToCaller.HighPart);

    return XBDM_NOERR;
}

HRESULT HrGetDriveFreeSpace(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    char szName[MAX_OBJ_PATH+1];
    CCS *pccs = (CCS *)pdmcc->CustomData;

    if(!pdmcc)
        return E_FAIL;

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    pdmcc->BufferSize = 512;
    pdmcc->Buffer = DmAllocatePool(pdmcc->BufferSize);
    pdmcc->HandlingFunction = HrReportDriveFreeSpace;
    pdmcc->BytesRemaining = 1;  // Internal counter
    st = FCreateFile(&pccs->h, FILE_LIST_DIRECTORY | SYNCHRONIZE, szName, NULL, 0,
                FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    return NT_SUCCESS(st) ? XBDM_MULTIRESPONSE : HrFromStatus(st,
        XBDM_CANNOTACCESS);
}

HRESULT HrSendFrameData(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    // end of data?
    if (pdmcc->BytesRemaining <= 0) {
        DmFreePool(pdmcc->Buffer);
        pdmcc->Buffer = NULL;

        // We've finished sending the data, so start the threads going again
        DmGo();

        return XBDM_ENDOFLIST;
    }

    if(pccs->Screenshot.fFirstTime == FALSE) {
        /* First we need to send the various parameters (pitch, format, buffer size, etc) */
        sprintf(pdmcc->Buffer, "pitch=0x%08x width=0x%08x height=0x%08x format=0x%08x, framebuffersize=0x%08x",
                            pccs->Screenshot.Pitch, pccs->Screenshot.Width, pccs->Screenshot.Height, pccs->Screenshot.Format, pdmcc->BytesRemaining);
        pdmcc->DataSize = -1;
        pccs->Screenshot.fFirstTime = TRUE;
    } else {
        // if (buffersize%8k != 0) need to send less data
        DWORD cBytesToSend = min (pdmcc->BytesRemaining, pdmcc->BufferSize);
        // send 8k of data
        memcpy(pdmcc->Buffer, pccs->Screenshot.pbyFrameBuffer, cBytesToSend);
        pdmcc->DataSize = cBytesToSend;
        pdmcc->BytesRemaining -= cBytesToSend;

        // point at next 8k of data
        pccs->Screenshot.pbyFrameBuffer += cBytesToSend;
    }

    return XBDM_NOERR;
}

HRESULT HrScreenshot(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    D3DSurface d3dsurface;
    int width, height, pitch, bitdepth, format;
    DWORD start;

    if(!g_dmgd.Surface) {
        strcpy(szResp, "can't find screen buffer");
        return E_FAIL;
    }

    //pdmgd = DmGetCurrentValue((ULONG)((BYTE*)&dm.D3DDriverData - (BYTE*)&dm));
    d3dsurface = *(g_dmgd.Surface);

    // Stop all threads so that no more Presents are added to the queue.
    DmStop();

    // Busy-wait until all previously queues Presents are processed by the GPU
    start = NtGetTickCount();
    while( *(g_dmgd.FlipCounter) != *(g_dmgd.FrameCounter))
    {
        if ( (NtGetTickCount() - start) >= 2000 ) {
            DmGo();
            strcpy(szResp, "can't lock GPU");
            return E_FAIL;
        }
    }

    // Extract size information
    width = (d3dsurface.Size & D3DSIZE_WIDTH_MASK) + 1;
    height = ((d3dsurface.Size & D3DSIZE_HEIGHT_MASK) >> D3DSIZE_HEIGHT_SHIFT) + 1;
    pitch = (((d3dsurface.Size & D3DSIZE_PITCH_MASK) >> D3DSIZE_PITCH_SHIFT) + 1) * D3DTEXTURE_PITCH_ALIGNMENT;
    format = (d3dsurface.Format & D3DFORMAT_FORMAT_MASK) >> D3DFORMAT_FORMAT_SHIFT;

    switch(format) {
    case D3DFMT_LIN_A8R8G8B8:
        bitdepth = 4;
        break;

    case D3DFMT_LIN_X8R8G8B8:
        bitdepth = 4;
        break;

    case D3DFMT_LIN_R5G6B5:
        bitdepth = 2;
        break;

    case D3DFMT_LIN_X1R5G5B5:
        bitdepth = 2;
        break;

    default:
        DmGo();
        strcpy(szResp, "Unexpected framebuffer format");
        return E_FAIL;
    }

    pccs->Screenshot.pbyFrameBuffer = (BYTE *) (d3dsurface.Data | 0xF0000000);

    pccs->Screenshot.fFirstTime = FALSE;
    pccs->Screenshot.Width = width;
    pccs->Screenshot.Height = height;
    pccs->Screenshot.Pitch = pitch;
    pccs->Screenshot.Format = format;

    // Set up the transfer buffer
    pdmcc->BufferSize = 8192;
    pdmcc->Buffer = DmAllocatePool(pdmcc->BufferSize);
    pdmcc->HandlingFunction = HrSendFrameData;
    pdmcc->BytesRemaining = pitch * height;
    return XBDM_BINRESPONSE;
}

HRESULT HrSendPSSnapshotData(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    // end of data?
    if (pdmcc->BytesRemaining <= 0)
    {
        pdmcc->Buffer = NULL;
        *(g_dmgd.pdwOpcode) = PSSNAP_DONE;      // signal D3D to release buffer
        return XBDM_ENDOFLIST;
    }

    pdmcc->DataSize = 32768;
    pdmcc->BytesRemaining = 0;

    return XBDM_NOERR;
}

HRESULT HrPSSnap(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    DWORD dwX, dwY, dwOpcode;
    struct
    {
        DWORD dwX;
        DWORD dwY;
        DWORD dwFlags;
        DWORD dwMarker;
    } args;
    DWORD dwStart;

    if(!FGetDwParam(sz, "x", &args.dwX))
    {
        strcpy(szResp, "Missing X parameter");
        return E_FAIL;
    }
    if(!FGetDwParam(sz, "y", &args.dwY))
    {
        strcpy(szResp, "Missing Y parameter");
        return E_FAIL;
    }

    if(!FGetDwParam(sz, "flags", &args.dwFlags))
        args.dwFlags = 0;

    if(!FGetDwParam(sz, "marker", &args.dwMarker))
        args.dwMarker = 0;

    if(*(g_dmgd.pdwOpcode))
    {
        sprintf(szResp, "D3D snapshot client in invalid state (%08x)", *(g_dmgd.pdwOpcode));
        return E_FAIL;
    }

    // build opcode for D3D pixel shader snapshot
    *(g_dmgd.ppSnapshotBuffer) = (BYTE *)(&args);
    *(g_dmgd.pdwOpcode) = PSSNAP_REQUEST;

    // wait for the opcode to change
    dwStart = NtGetTickCount();
    while(1)
    {
        dwOpcode = *(g_dmgd.pdwOpcode) & 0xff000000;
        if((dwOpcode == PSSNAP_ACK) ||
           (dwOpcode == PSSNAP_ERROR))
            break;

        Sleep(50);
        if ( (NtGetTickCount() - dwStart) >= 2000 ) {
            strcpy(szResp, "Opcode timeout:  Failed to receive acknowledge");
            *(g_dmgd.pdwOpcode) = PSSNAP_IDLE;
            return E_FAIL;
        }
    }

    if(dwOpcode == PSSNAP_ERROR)
    {
        switch(*(g_dmgd.pdwOpcode) & 0x00ffffff)
        {
        case 1:
            sprintf(szResp, "The Application is using an unsupported framebuffer format.  Only A8R8G8B8 is supported at this time.");
            break;

        case 2:
            sprintf(szResp, "Debugger doesn't support an Xbox app using a Pure Device - Remove D3DCREATE_PUREDEVICE");
            break;

        case 3:
            sprintf(szResp, "Debugger wasn't able to allocate memory.");
            break;

        default:
            sprintf(szResp, "D3D snapshot client returned error %d",  *(g_dmgd.pdwOpcode) & 0x00ffffff);
            break;
        }

        *(g_dmgd.pdwOpcode) = PSSNAP_IDLE;
        return E_FAIL;
    }

    // Set up the transfer buffer
    pdmcc->BufferSize = 32768;
    pdmcc->Buffer = *(g_dmgd.ppSnapshotBuffer);
    pdmcc->HandlingFunction = HrSendPSSnapshotData;
    pdmcc->BytesRemaining = 32768;

    return XBDM_BINRESPONSE;
}

HRESULT HrSendVSSnapshotData(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    // end of data?
    if (pdmcc->BytesRemaining <= 0)
    {
        pdmcc->Buffer = NULL;
        *(g_dmgd.pdwOpcode) = VSSNAP_DONE;      // signal D3D to release buffer
        return XBDM_ENDOFLIST;
    }

    pdmcc->DataSize = 32768;
    pdmcc->BytesRemaining = 0;

    return XBDM_NOERR;
}

HRESULT HrVSSnap(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    DWORD dwOpcode;
    DWORD dwStart;
    struct
    {
        DWORD dwFirst;
        DWORD dwLast;
        DWORD dwFlags;
        DWORD dwMarker;
    } args;

    if(*(g_dmgd.pdwOpcode))
    {
        sprintf(szResp, "D3D snapshot client in invalid state (%08x)", *(g_dmgd.pdwOpcode));
        return E_FAIL;
    }

    if(!FGetDwParam(sz, "first", &args.dwFirst))
    {
        strcpy(szResp, sz);
        return E_FAIL;
    }
    if(!FGetDwParam(sz, "last", &args.dwLast))
    {
        strcpy(szResp, "Missing Last parameter");
        return E_FAIL;
    }
    if(!FGetDwParam(sz, "flags", &args.dwFlags))
        args.dwFlags = 0;

    if(!FGetDwParam(sz, "marker", &args.dwMarker))
        args.dwMarker = 0;

    if(args.dwFlags & 0x08000000)
    {
        // xray sequence instead
        *(g_dmgd.pdwOpcode) = XRAY_BEGINREQ;
        *(g_dmgd.ppSnapshotBuffer) = (BYTE *)(&args);

        // wait for the opcode to change
        dwStart = NtGetTickCount();
        while(1)
        {
            dwOpcode = *(g_dmgd.pdwOpcode) & 0xff000000;
            if((dwOpcode == XRAY_BEGINACK) ||
               (dwOpcode == XRAY_ERROR))
                break;

            Sleep(50);
            if ( (NtGetTickCount() - dwStart) >= 2000 ) {
                sprintf(szResp, "Opcode timeout:  Failed to receive acknowledge: %08x", dwOpcode);
                *(g_dmgd.pdwOpcode) = XRAY_IDLE;
                return E_FAIL;
            }
        }
        if(dwOpcode == XRAY_ERROR)
        {
            switch(*(g_dmgd.pdwOpcode) & 0x00ffffff)
            {
            case 2:
                sprintf(szResp, "Debugger doesn't support an Xbox app using a Pure Device - Remove D3DCREATE_PUREDEVICE");
                break;

            default:
                sprintf(szResp, "D3D snapshot client returned error %d",  *(g_dmgd.pdwOpcode) & 0x00ffffff);
                break;
            }
            *(g_dmgd.pdwOpcode) = XRAY_IDLE;
            return E_FAIL;
        }
        *(g_dmgd.pdwOpcode) = XRAY_IDLE;
        return XBDM_NOERR;
    }
    else
    {
        if(args.dwFlags & 0x04000000)
        {
            // end xray sequence instead
            *(g_dmgd.pdwOpcode) = XRAY_ENDREQ;

            // wait for the opcode to change
            dwStart = NtGetTickCount();
            while(1)
            {
                dwOpcode = *(g_dmgd.pdwOpcode) & 0xff000000;
                if((dwOpcode == XRAY_ENDACK) ||
                   (dwOpcode == XRAY_ERROR))
                    break;

                Sleep(50);
                if ( (NtGetTickCount() - dwStart) >= 2000 ) {
                    strcpy(szResp, "Opcode timeout:  Failed to receive acknowledge");
                    *(g_dmgd.pdwOpcode) = VSSNAP_IDLE;
                    return E_FAIL;
                }
            }

            if(dwOpcode == XRAY_ERROR)
            {
                switch(*(g_dmgd.pdwOpcode) & 0x00ffffff)
                {
                case 2:
                    sprintf(szResp, "Debugger doesn't support an Xbox app using a Pure Device - Remove D3DCREATE_PUREDEVICE");
                    break;

                default:
                    sprintf(szResp, "D3D snapshot client returned error %d",  *(g_dmgd.pdwOpcode) & 0x00ffffff);
                    break;
                }
                *(g_dmgd.pdwOpcode) = XRAY_IDLE;
                return E_FAIL;
            }
            *(g_dmgd.pdwOpcode) = XRAY_IDLE;
            return XBDM_NOERR;
        }
    }

    // build opcode for D3D vertex shader snapshot
    dwOpcode = VSSNAP_REQUEST;

    *(g_dmgd.ppSnapshotBuffer) = (BYTE *)(&args);
    *(g_dmgd.pdwOpcode) = dwOpcode;

    // wait for the opcode to change
    dwStart = NtGetTickCount();
    while(1)
    {
        dwOpcode = *(g_dmgd.pdwOpcode) & 0xff000000;
        if((dwOpcode == VSSNAP_ACK) ||
           (dwOpcode == VSSNAP_ERROR))
            break;

        Sleep(50);
        if ( (NtGetTickCount() - dwStart) >= 2000 ) {
            strcpy(szResp, "Opcode timeout:  Failed to receive acknowledge");
            *(g_dmgd.pdwOpcode) = VSSNAP_IDLE;
            return E_FAIL;
        }
    }

    if(dwOpcode == VSSNAP_ERROR)
    {
        switch(*(g_dmgd.pdwOpcode) & 0x00ffffff)
        {
        case 2:
            sprintf(szResp, "Debugger doesn't support an Xbox app using a Pure Device - Remove D3DCREATE_PUREDEVICE");
            break;

        case 3:
            sprintf(szResp, "Debugger wasn't able to allocate memory.");
            break;

        default:
            sprintf(szResp, "D3D snapshot client returned error %d",  *(g_dmgd.pdwOpcode) & 0x00ffffff);
            break;
        }
        *(g_dmgd.pdwOpcode) = VSSNAP_IDLE;
        return E_FAIL;
    }

    // Set up the transfer buffer
    pdmcc->BufferSize = 32768;
    pdmcc->Buffer = *(g_dmgd.ppSnapshotBuffer);
    pdmcc->HandlingFunction = HrSendVSSnapshotData;
    pdmcc->BytesRemaining = 32768;

    return XBDM_BINRESPONSE;
}

HRESULT HrSetLockMode(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;

    if(PchGetParam(sz, "unlock", FALSE)) {
        g_fLockLevel = FALSE;
        hr = XBDM_NOERR;
    } else if(FGetQwordParam(sz, "boxid", &g_luBoxId)) {
        g_fLockLevel = TRUE;
        hr = XBDM_NOERR;
    } else {
        /* Potential failure */
        hr = E_FAIL;
        strcpy(szResp, "missing parameters");
    }
    if(PchGetParam(sz, "encrypt", FALSE)) {
        if(g_fLockLevel) {
            g_fLockLevel = 2;
            hr = XBDM_NOERR;
        } else
            /* If unlock was specified, we'll return success as set above;
             * if not, we'll return failure.  In either case, hr is already
             * set correctly, so we'll just make sure the error message
             * is sufficient */
            strcpy(szResp, "box not locked; file encryption not enabled");
    }

    RemoveAllUsers();
    WriteIniFile();
    return hr;
}

HRESULT HrSetDebugSecureMode(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    int icst;

    if(!g_fDebugSecureMode)
        return XBDM_INVALIDCMD;
    if(!pdmcc)
        return E_FAIL;
    icst = (PCST)pdmcc - rgcst;
    rgcst[icst].dmplCur = -1;
    return XBDM_NOERR;
}

HRESULT HrGetBoxId(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    if(!g_fLockLevel)
        return XBDM_NOTLOCKED;
    sprintf(szResp, "boxid=0q%08x%08x", g_luBoxId.HighPart, g_luBoxId.LowPart);
    return XBDM_NOERR;
}

HRESULT HrAuthenticateUser(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szName[256];
    ULARGE_INTEGER luResponse;
    int icst;
    BOOL fKeyXchg;
    LPCSTR pszName;

    if(!pdmcc)
        return E_FAIL;
    icst = (PCST)pdmcc - rgcst;
    if((rgcst[icst].dwStatus & CONN_DHKEY) && FGetQwordParam(sz, "passwd",
        &luResponse))
    {
        luResponse.LowPart ^= rgcst[icst].luDHKey.LowPart;
        luResponse.HighPart ^= rgcst[icst].luDHKey.HighPart;
        fKeyXchg = TRUE;
    } else if(!FGetQwordParam(sz, "resp", &luResponse)) {
noresp:
        strcpy(szResp, "missing response");
        return E_FAIL;
    } else
        fKeyXchg = FALSE;

    if(PchGetParam(sz, "admin", FALSE)) {
        /* Trying to authenticate using the admin passwd.  This requires a
         * valid response */
        if(fKeyXchg)
            goto noresp;
        pszName = NULL;
    } else if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    } else
        pszName = szName;

    rgcst[icst].dmplCur = DmplAuthenticateUser(pszName,
        &rgcst[icst].luConnectNonce, &luResponse, &fKeyXchg);
    if(!rgcst[icst].dmplCur)
        return fKeyXchg ? XBDM_KEYXCHG : XBDM_CANNOTACCESS;
    return XBDM_NOERR;
}

HRESULT HrSetAdminPasswd(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    int icst;
    ULARGE_INTEGER luPasswd;
    ULARGE_INTEGER luT;
    PULARGE_INTEGER plu;

    if(PchGetParam(sz, "none", FALSE)) {
        g_fAdminPasswd = FALSE;
        WriteIniFile();
        return XBDM_NOERR;
    }

    /* We need to establish a key-exchange key.  But if we're running from the
     * ini file, we'll just use a key-exchange key of 0 to load in the
     * plaintext password */
    if(!pdmcc) {
        luT.QuadPart = 0;
        plu = &luT;
    } else {
        icst = (PCST)pdmcc - rgcst;
        if(!(rgcst[icst].dwStatus & CONN_DHKEY))
            return XBDM_KEYXCHG;
        plu = &rgcst[icst].luDHKey;
    }

    if(!FGetQwordParam(sz, "passwd", &luPasswd)) {
        strcpy(szResp, "missing passwd");
        return E_FAIL;
    }
    g_luAdminPasswd.LowPart = luPasswd.LowPart ^ plu->LowPart;
    g_luAdminPasswd.HighPart = luPasswd.HighPart ^ plu->HighPart;
    g_fAdminPasswd = TRUE;
    WriteIniFile();
    return XBDM_NOERR;
}

HRESULT HrGetUserPriv(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szUserName[128];
    DWORD dwPrivileges;
    HRESULT hr;
    int icst;

    dwPrivileges = DmplOfConnection(pdmcc);
    if(PchGetParam(sz, "me", FALSE)) {
        /* We're interested in the privileges for this connection */
        hr = pdmcc ? XBDM_NOERR : E_FAIL;
    } else if(!(dwPrivileges & DMPL_PRIV_MANAGE))
        hr = XBDM_CANNOTACCESS;
    else if(!FGetSzParam(sz, "name", szUserName, sizeof szUserName)) {
        strcpy(szResp, "missing name");
        hr = E_FAIL;
    } else
        hr = DmGetUserAccess(szUserName, &dwPrivileges);

    if(SUCCEEDED(hr)) {
        if(dwPrivileges)
            FillAccessPrivSz(szResp-1, dwPrivileges);
        else
            strcpy(szResp, "none");
    }

    return hr;
}

HRESULT HrSetUserPriv(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szUserName[128];
    DWORD dwPrivileges;
    HRESULT hr;

    if(!FGetSzParam(sz, "name", szUserName, sizeof szUserName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    dwPrivileges = DmplFromSz(sz);
    return DmSetUserAccess(szUserName, dwPrivileges);
}

HRESULT HrReportUsers(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    HRESULT hr;
    DM_USER dusr;

    hr = DmWalkUserList(&pccs->pdmwu, &dusr);
    if(!pdmcc->BytesRemaining)
        hr = XBDM_ENDOFLIST;
    else if(SUCCEEDED(hr))
        FillUserInfoSz(pdmcc->Buffer, dusr.UserName, dusr.AccessPrivileges,
            NULL);
    else {
        DmCloseUserList(pccs->pdmwu);
        hr = XBDM_ENDOFLIST;
    }

    return hr;
}

HRESULT HrListUsers(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    if(!g_fLockLevel)
        return XBDM_NOTLOCKED;
    if(!pdmcc)
        return E_FAIL;

    pccs = (CCS *)pdmcc->CustomData;
    pdmcc->HandlingFunction = HrReportUsers;
    pccs->pdmwu = NULL;
    return XBDM_MULTIRESPONSE;
}

HRESULT HrPerformDHExchange(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    extern BYTE g_abOakleyGroup1Base[];
    extern BYTE g_abOakleyGroup1Mod[];
    BYTE rgbDHKey[96];
    BYTE rgbY[96];
    int icst;
    HRESULT hr;

    if(pdmcc->CustomData) {
        /* We're sending, so send all of the data */
        if(pdmcc->BytesRemaining) {
            pdmcc->DataSize = 96;
            pdmcc->BytesRemaining = 0;
            hr = XBDM_NOERR;
        } else {
            DmFreePool(pdmcc->Buffer);
            hr = XBDM_ENDOFLIST;
        }
    } else if(pdmcc->DataSize) {
        /* Grab the data that's here */
        memcpy((PUCHAR)pdmcc->Buffer + 2 * 96 - pdmcc->BytesRemaining,
            pdmcc->Buffer, pdmcc->DataSize);
        pdmcc->BytesRemaining -= pdmcc->DataSize;
        if(!pdmcc->BytesRemaining) {
            /* OK, now we've got g^x at buffer+96.  We need to compute y,
             * g^xy, and g^y.  First generate y */
            XNetRandom(rgbY, 96);
            /* Now compute g^xy */
            XcModExp((PULONG)rgbDHKey, (PULONG)((PUCHAR)pdmcc->Buffer + 96),
                (PULONG)rgbY, (PULONG)g_abOakleyGroup1Mod,
                96 / 4);
            /* And prepare g^y to be sent */
            XcModExp((PULONG)pdmcc->Buffer, (PULONG)g_abOakleyGroup1Base,
                (PULONG)rgbY, (PULONG)g_abOakleyGroup1Mod,
                96 / 4);
            pdmcc->CustomData = pdmcc->Buffer;
            /* Now that we have g^xy, we can hash it and mark the key
             * exchange complete */
            icst = (PCST)pdmcc - rgcst;
            rgcst[icst].luDHKey.QuadPart = 0;
            XBCHashData(&rgcst[icst].luDHKey, rgbDHKey, sizeof rgbDHKey);
            rgcst[icst].dwStatus |= CONN_DHKEY;
            /* Now get ready to send g^y */
            hr = XBDM_BINRESPONSE;
        } else
            hr = XBDM_NOERR;
    } else {
        /* Connection died on receive */
        DmFreePool(pdmcc->Buffer);
        pdmcc->BytesRemaining = 0;
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT HrKeyExchange(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    if(!pdmcc)
        return E_FAIL;

    /* We need to allocate a buffer to build up the remote constant --
     * we can't let it trickle in via the standard buffer */
    pdmcc->BufferSize = 2 * 96;
    pdmcc->Buffer = DmAllocatePoolWithTag(pdmcc->BufferSize, 'HDmd');
    if(!pdmcc->Buffer)
        return E_OUTOFMEMORY;

    /* Set up to receive the remote constant */
    pdmcc->BytesRemaining = 96;
    pdmcc->HandlingFunction = HrPerformDHExchange;
    pdmcc->CustomData = NULL;
    return XBDM_READYFORBIN;
}

HRESULT HrReportMmGlobal(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    extern PMMGLOBALDATA MmGlobalData;
    PMMGLOBALDATA p = MmGlobalData;
    ULONG MmHighestPhysicalPage;
    PCI_SLOT_NUMBER PCISlotNumber;
    MM_STATISTICS mmstat;
    UCHAR MemoryTop;
    PMMPFN MmPfnDatabase;
    HRESULT hr;
    int n;

    switch (pdmcc->BytesRemaining++) {

    case 1:

        //
        // Access the host bridge's configuration space.
        //

        PCISlotNumber.u.AsULONG = 0;
        PCISlotNumber.u.bits.DeviceNumber = XPCICFG_HOSTBRIDGE_DEVICE_ID;
        PCISlotNumber.u.bits.FunctionNumber = XPCICFG_HOSTBRIDGE_FUNCTION_ID;
        HalReadPCISpace(0, PCISlotNumber.u.AsULONG, CR_CPU_MEMTOP_LIMIT,
            &MemoryTop, sizeof(UCHAR));

        MmHighestPhysicalPage = (((ULONG)MemoryTop + 1) * 4096) - 1;

        MmPfnDatabase = (PMMPFN)(MM_SYSTEM_PHYSICAL_MAP +
            (MiGetPdeAddress(MM_SYSTEM_PHYSICAL_MAP)->Hard.PageFrameNumber << PAGE_SHIFT));

        n = _snprintf(pdmcc->Buffer, pdmcc->BufferSize,
                "MmHighestPhysicalPage=0x%x RetailPfnRegion=0x%x SystemPteRange=0x%x "
                "AvailablePages=0x%x AllocatedPagesByUsage=0x%x PfnDatabase=0x%x",
                MmHighestPhysicalPage, p->RetailPfnRegion, p->SystemPteRange,
                p->AvailablePages, p->AllocatedPagesByUsage, MmPfnDatabase);
        hr = n < 0 ? XBDM_BUFFER_TOO_SMALL : XBDM_NOERR;
        break;

    case 2:
        mmstat.Length = sizeof(mmstat);
        MmQueryStatistics(&mmstat);
        n = _snprintf(pdmcc->Buffer, pdmcc->BufferSize,
                "AddressSpaceLock=0x%x VadRoot=0x%x VadHint=0x%x VadFreeHint=0x%x "
                "MmNumberOfPhysicalPages=0x%x MmAvailablePages=0x%x",
                p->AddressSpaceLock, p->VadRoot, p->VadHint, p->VadFreeHint,
                mmstat.TotalPhysicalPages, mmstat.AvailablePages);

        hr = n < 0 ? XBDM_BUFFER_TOO_SMALL : XBDM_NOERR;
        break;

    default:
        hr = XBDM_ENDOFLIST;
    }

    return hr;
}

HRESULT HrGetMmGlobal(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    pdmcc->HandlingFunction = HrReportMmGlobal;
    pdmcc->BytesRemaining = 1;
    return XBDM_MULTIRESPONSE;
}

HRESULT HrReturnBuffer(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    if(!pdmcc->BytesRemaining) {
        DmFreePool(pdmcc->Buffer);
        return XBDM_ENDOFLIST;
    }
    pdmcc->DataSize = pdmcc->BytesRemaining;
    pdmcc->BytesRemaining = 0;
    return XBDM_NOERR;
}

HRESULT HrGetDvdBlk(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD dwBlk;
    CCS *pccs;
    HANDLE h;
    IO_STATUS_BLOCK iosb;
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING ost;
    NTSTATUS st;
    LARGE_INTEGER li;
    PDEVICE_OBJECT pdev;

    if(!pdmcc)
        return E_FAIL;

    if(!FGetNamedDwParam(sz, "block", &dwBlk, szResp))
        return E_FAIL;

    RtlInitObjectString(&ost, "\\Device\\Cdrom0");
    st = ObReferenceObjectByName(&ost, 0, IoDeviceObjectType, NULL, &pdev);
    if(!NT_SUCCESS(st))
        return E_FAIL;
    pdmcc->Buffer = DmAllocatePool(pdmcc->BufferSize = 2048);
    if(!pdmcc->Buffer) {
        ObDereferenceObject(pdev);
        return E_FAIL;
    }
    li.QuadPart = dwBlk;
    li.QuadPart *= 2048;
    st = IoSynchronousFsdRequest(IRP_MJ_READ, pdev, pdmcc->Buffer,
        2048, &li);
    ObDereferenceObject(pdev);
    if(!NT_SUCCESS(st)) {
        ExFreePool(pdmcc->Buffer);
        return E_FAIL;
    }
    pdmcc->HandlingFunction = HrReturnBuffer;
    pdmcc->BytesRemaining = 2048;
    return XBDM_BINRESPONSE;
}

/* This list must be sorted */
CHH rgchh[] = {
    { "adminpw", DMPL_PRIV_MANAGE, HrSetAdminPasswd },
    { "altaddr", DMPL_PRIV_CONTROL, HrGetAltAddr },
    { "authuser", 0, HrAuthenticateUser },
    { "boxid", 0, HrGetBoxId },
    { "break", DMPL_PRIV_CONTROL, HrDoBreak },
    { "bye", 0, HrEndConversation, 0, CHH_ANYTHREAD },
    { "capcontrol", DMPL_PRIV_CONTROL, HrCAPControl },
    { "continue", DMPL_PRIV_CONTROL, HrContinueThread },
    { "dbgname", 0, HrSetDbgName },
    { "debugger", DMPL_PRIV_CONTROL, HrConnectDebugger },
    { "debugmode", 0, HrSetDebugSecureMode },
    { "dedicate", 0, HrDedicateConnection, 0, CHH_ANYTHREAD },
    { "deftitle", DMPL_PRIV_CONTROL, HrSetDefaultTitle },
    { "delete", 0, HrDeleteFile, DMPL_PRIV_READ | DMPL_PRIV_WRITE },
    { "dirlist", DMPL_PRIV_READ, HrGetDirList },
    { "drivefreespace", DMPL_PRIV_READ, HrGetDriveFreeSpace },
    { "drivelist", DMPL_PRIV_READ, HrGetDriveList },
    { "dvdblk", DMPL_PRIV_READ, HrGetDvdBlk },
    { "flash", DMPL_PRIV_CONFIGURE, HrFlashKernelImage },
    { "fmtfat", DMPL_PRIV_CONFIGURE, HrFormatFAT },
    { "funccall", DMPL_PRIV_CONTROL, HrFunctionCall },
    { "getcontext", DMPL_PRIV_CONTROL, HrGetContext },
    { "getextcontext", DMPL_PRIV_CONTROL, HrGetExtContext },
    { "getfile", DMPL_PRIV_READ, HrSendFile },
    { "getfileattributes", DMPL_PRIV_READ | DMPL_PRIV_WRITE, HrGetFileAttributes },
    { "getmem", DMPL_PRIV_CONTROL, HrGetMemory },
    { "getuserpriv", 0, HrGetUserPriv },
    { "go", DMPL_PRIV_CONTROL, HrGo },
    { "gpucount", DMPL_PRIV_CONTROL, HrToggleGPUCounters },
    { "halt", DMPL_PRIV_CONTROL, HrHaltThread },
    { "irtsweep", DMPL_PRIV_CONTROL, HrIrtSweep },
    { "isbreak", DMPL_PRIV_CONTROL, HrIsBreak },
    { "isstopped", DMPL_PRIV_CONTROL, HrIsStopped },
    { "kd", DMPL_PRIV_CONTROL, HrToggleKDState },
    { "keyxchg", 0, HrKeyExchange },
    { "lockmode", DMPL_PRIV_MANAGE, HrSetLockMode },
    { "magicboot", DMPL_PRIV_CONTROL, HrMagicReboot },
    { "mkdir", DMPL_PRIV_WRITE, HrMkdir },
    { "mmglobal", DMPL_PRIV_CONTROL, HrGetMmGlobal },
    { "modlong", DMPL_PRIV_CONTROL, HrDoLongName },
    { "modsections", DMPL_PRIV_CONTROL, HrListModuleSections },
    { "modules", DMPL_PRIV_CONTROL, HrListModules },
    { "nostopon", DMPL_PRIV_CONTROL, HrNostopon },
    { "notify", DMPL_PRIV_CONTROL, HrSetupNotify },
    { "notifyat", DMPL_PRIV_CONTROL, HrSetupNotifyAt },
    { "pclist", DMPL_PRIV_CONTROL, HrListCounters },
    { "pssnap", DMPL_PRIV_CONTROL, HrPSSnap },
    { "querypc", DMPL_PRIV_CONTROL, HrQueryPerformanceCounter },
    { "reboot", DMPL_PRIV_CONTROL, HrReboot },
    { "rename", 0, HrRenameFile, DMPL_PRIV_READ | DMPL_PRIV_WRITE },
    { "resume", DMPL_PRIV_CONTROL, HrResumeThread },
    { "screenshot", DMPL_PRIV_CONTROL, HrScreenshot },
    { "sendfile", DMPL_PRIV_WRITE, HrReceiveFile },
    { "setconfig", DMPL_PRIV_CONFIGURE, HrSetConfig },
    { "setcontext", DMPL_PRIV_CONTROL, HrSetContext },
    { "setfileattributes", DMPL_PRIV_WRITE, HrSetFileAttributes },
    { "setmem", DMPL_PRIV_CONTROL, HrSetMemory },
    { "setsystime", DMPL_PRIV_CONFIGURE, HrSetSystemTime },
    { "setuserpriv", DMPL_PRIV_MANAGE, HrSetUserPriv },
    { "stop", DMPL_PRIV_CONTROL, HrStop },
    { "stopon", DMPL_PRIV_CONTROL, HrStopon },
    { "suspend", DMPL_PRIV_CONTROL, HrSuspendThread },
    { "sysfileupd", DMPL_PRIV_CONTROL, HrUpdateSystemFile },
    { "systime", 0, HrSystemTime },
    { "threadinfo", DMPL_PRIV_CONTROL, HrThreadInfo },
    { "threads", DMPL_PRIV_CONTROL, HrListThreads },
    { "title", DMPL_PRIV_CONTROL, HrSetTitle },
    { "user", DMPL_PRIV_MANAGE, HrAddUserCommand },
    { "userlist", DMPL_PRIV_MANAGE, HrListUsers },
    { "vssnap", DMPL_PRIV_CONTROL, HrVSSnap },
    { "xbeinfo", DMPL_PRIV_CONTROL, HrXbeInfo },
    { "xtlinfo", DMPL_PRIV_CONTROL, HrXapiInfo },
};

int cchh = sizeof rgchh / sizeof rgchh[0];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmsecure.c ===
/*
 *
 * dmsecure.c
 *
 * Connection security functions
 *
 */

#include "dmp.h"

static ULONG rgN[8] = {
    0x283C481D,
    0x9AD82AA1,
    0x85A5E1F9,
    0x1B23963C,
    0xF70B4975,
    0xDFDC02C7,
    0xF29176FC,
    0x6B04BD38
};

static HANDLE hUserList;
RTL_CRITICAL_SECTION csUserList;
ULARGE_INTEGER g_luAdminPasswd;
BOOL g_fAdminPasswd;

typedef struct _DMUSER {
    ULARGE_INTEGER luPasswd;
    DWORD dwPrivileges;
    BOOL fHasPasswd;
} DMUSER, *PDMUSER;

static OBJECT_TYPE obtUser = {
    DmAllocatePoolWithTag,
    DmFreePool,
    NULL,
    NULL,
    NULL,
    &kevtNull,
    'SUmd'
};

void XBCEncryptCore(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluBlock)
{
    int i;

    for(i = 0; i < 8; ++i) { 
        pluBlock->LowPart ^= (pluBlock->HighPart >> 5) + rgN[i] +
            (~pluBlock->HighPart << 6) + (pluBlock->HighPart ^ pluKey->LowPart);
        pluBlock->HighPart ^= (~pluBlock->LowPart >> 5) + rgN[7-i] +
            (pluBlock->LowPart << 6) + (pluBlock->LowPart ^ pluKey->HighPart);
    }
}

void XBCDecryptCore(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluBlock)
{
    int i;

    for(i = 0; i < 8; ++i) { 
        pluBlock->HighPart ^= (~pluBlock->LowPart >> 5) + rgN[i] +
            (pluBlock->LowPart << 6) + (pluBlock->LowPart ^ pluKey->HighPart);
        pluBlock->LowPart ^= (pluBlock->HighPart >> 5) + rgN[7-i] +
            (~pluBlock->HighPart << 6) + (pluBlock->HighPart ^ pluKey->LowPart);
    }
}

void XBCHashBlock(PULARGE_INTEGER pluHash, PULARGE_INTEGER pluData)
{
    /* We don't use Davies-Meyer directly, we use an analogous formula:
     *   H(i) = E(H(i-1),M(i)) X M(i)
     */
    ULARGE_INTEGER luTemp;

    luTemp = *pluData;
    XBCEncryptCore(pluHash, &luTemp);
    pluHash->LowPart = pluData->LowPart ^ luTemp.LowPart;
    pluHash->HighPart = pluData->HighPart ^ luTemp.HighPart;
}

void XBCHashData(PULARGE_INTEGER pluHash, const BYTE *pb, ULONG cb)
{
    ULARGE_INTEGER lu;

    /* Process the 8-byte chunks first */
    while(cb >= 8) {
        memcpy(&lu, pb, 8);
        pb += 8;
        cb -= 8;
        XBCHashBlock(pluHash, &lu);
    }
    if(cb) {
        memset(&lu, 0, sizeof lu);
        memcpy(&lu, pb, cb);
        XBCHashBlock(pluHash, &lu);
    }
}

void XBCCross(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluData,
    PULARGE_INTEGER pluResult)
{
    ULARGE_INTEGER luTemp;

    /* Compute H(K, H(K, M)) where K is the key and M is the data */
    pluResult->QuadPart = 0x2718281831415926;
    XBCHashBlock(pluResult, pluKey);
    luTemp = *pluResult;
    XBCHashBlock(&luTemp, pluData);
    XBCHashBlock(pluResult, &luTemp);
}

void InitSecurity(void)
{
    NTSTATUS st;

    /* We use the object manager to store the user list, so we need to create
     * a directory object to contain the list */
    st = NtCreateDirectoryObject(&hUserList, NULL);
    if(!NT_SUCCESS(st))
        hUserList = NULL;
    InitializeCriticalSection(&csUserList);
}

PDMUSER PusrLookupUser(LPCSTR szUserName)
{
    PDMUSER pusr;
    OBJECT_ATTRIBUTES oa;
    NTSTATUS st;
    OBJECT_STRING ost;
    HANDLE h;

    /* First look up the handle -- we need to do this because this object
     * isn't rooted in the object namespace.  We don't synchronize access
     * to the list since the object manager does that for us */
    RtlInitObjectString(&ost, szUserName);
    InitializeObjectAttributes(&oa, &ost, 0, hUserList, NULL);
    st = ObOpenObjectByName(&oa, &obtUser, NULL, &h);
    if(!NT_SUCCESS(st))
        return NULL;
    /* Now get the underlying object */
    st = ObReferenceObjectByHandle(h, NULL, &pusr);
    NtClose(h);
    return NT_SUCCESS(st) ? pusr : NULL;
}

DWORD DmplAuthenticateUser(LPCSTR szUserName, PULARGE_INTEGER pluNonce,
    PULARGE_INTEGER pluResponse, BOOL *pfKeyXchg)
{
    PDMUSER pusr;
    ULARGE_INTEGER luHandshake;
    ULONG dmpl;

    if(!szUserName) {
        /* We're doing an admin password check */
        if(*pfKeyXchg || !g_fAdminPasswd)
            return 0;
        XBCCross(&g_luAdminPasswd, pluNonce, &luHandshake);
        return luHandshake.QuadPart == pluResponse->QuadPart ? -1 : 0;
    }

    /* Look up this user */
    pusr = PusrLookupUser(szUserName);
    if(!pusr)
        return 0;
    
    /* Verify the password */
    if(pusr->fHasPasswd) {
        if(!*pfKeyXchg) {
            XBCCross(&pusr->luPasswd, pluNonce, &luHandshake);
            dmpl = luHandshake.QuadPart == pluResponse->QuadPart ?
                pusr->dwPrivileges : 0;
        } else
            dmpl = 0;
        *pfKeyXchg = FALSE;
    } else {
        /* The user hasn't set a password yet.  If we're getting the password
         * now, then all is well.  If not, we'll deny access and demand a
         * password */
        if(*pfKeyXchg) {
            pusr->luPasswd.QuadPart = pluResponse->QuadPart;
            pusr->fHasPasswd = TRUE;
            dmpl = pusr->dwPrivileges;
            *pfKeyXchg = FALSE;
            /* We've changed the userlist, so we need to rewrite it */
            WriteIniFile();
        } else {
            dmpl = 0;
            *pfKeyXchg = TRUE;
        }
    }

    /* Clean up */
    ObDereferenceObject(pusr);
    return dmpl;
}

HRESULT DmEnableSecurity(BOOL fEnable)
{
    g_fLockLevel = !!fEnable;
    RemoveAllUsers();
    return XBDM_NOERR;
}

HRESULT DmIsSecurityEnabled(LPBOOL pfEnabled)
{
    if(!pfEnabled)
        return E_INVALIDARG;

    *pfEnabled = g_fLockLevel != 0;
    return XBDM_NOERR;
}

HRESULT HrDoAddUser(LPCSTR szUserName, PDMUSER pusrTemplate)
{
    PDMUSER pusr;
    HRESULT hr;
    OBJECT_STRING ost;
    OBJECT_ATTRIBUTES oa;
    NTSTATUS st;
    HANDLE h;

    /* No users allowed if the box isn't locked */
    if(!g_fLockLevel)
        return XBDM_NOTLOCKED;

    /* Synchronize access */
    EnterCriticalSection(&csUserList);

    /* See if this user already exists */
    pusr = PusrLookupUser(szUserName);
    if(pusr) {
        LeaveCriticalSection(&csUserList);
        return XBDM_ALREADYEXISTS;
    }

    /* Make a new user */
    RtlInitObjectString(&ost, szUserName);
    InitializeObjectAttributes(&oa, &ost, OBJ_PERMANENT, hUserList, NULL);
    st = ObCreateObject(&obtUser, &oa, sizeof *pusr, &pusr);
    if(!NT_SUCCESS(st)) {
        LeaveCriticalSection(&csUserList);
        return E_OUTOFMEMORY;
    }

    /* Now add this user to the handle table so it can be found later.  Mark a
     * pointer bias of 1 to keep the object persistent */
    st = ObInsertObject(pusr, &oa, 1, &h);

    /* We no longer need exclusive access to the user list */
    LeaveCriticalSection(&csUserList);

    /* We don't need our base reference to this object anymore.  If we added it
     * to the handle table, the pointer will still be valid and if not, we want
     * to kill off the reference anyway */
    ObDereferenceObject(pusr);
    
    if(NT_SUCCESS(st)) {
        memcpy(pusr, pusrTemplate, sizeof *pusr);
        NtClose(h);
        hr = XBDM_NOERR;
    } else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT DmAddUser(LPCSTR szUserName, DWORD dmpl)
{
    DMUSER usr;

    memset(&usr, 0, sizeof usr);
    usr.dwPrivileges = dmpl;
    return HrDoAddUser(szUserName, &usr);
}

HRESULT DmRemoveUser(LPCSTR szUserName)
{
    PDMUSER pusr;
    HRESULT hr;

    /* Synchronize access */
    EnterCriticalSection(&csUserList);

    /* Find the user we want to delete */
    pusr = PusrLookupUser(szUserName);

    /* Delete it if we found it */
    if(pusr) {
        /* Mark the object as temporary so it will be removed from the
         * directory */
        ObMakeTemporaryObject(pusr);
        /* Deref the object twice -- once for our reference and once for the
         * base reference -- to actually delete the object */
        ObDereferenceObject(pusr);
        ObDereferenceObject(pusr);
        hr = XBDM_NOERR;
    } else
        hr = XBDM_NOSUCHFILE;

    LeaveCriticalSection(&csUserList);

    return hr;
}

HRESULT HrAddUserCommand(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DMUSER usr;
    char szUserName[64];
    HRESULT hr;
    BOOL fRemove;

    /* Get the user name */
    if(!FGetSzParam(sz, "name", szUserName, sizeof szUserName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    /* If we're removing, then remove */
    if(PchGetParam(sz, "remove", FALSE))
        return DmRemoveUser(szUserName);

    /* Set the password, if available.  We only accept the password if this
     * command is coming from the ini file */
    if(!pdmcc && FGetQwordParam(sz, "passwd", &usr.luPasswd))
        usr.fHasPasswd = TRUE;
    else
        usr.fHasPasswd = FALSE;

    /* Set the privileges */
    usr.dwPrivileges = DmplFromSz(sz);

    /* Do the work */
    return HrDoAddUser(szUserName, &usr);
}

void FillAccessPrivSz(LPSTR sz, DWORD dwPriv)
{
    LPSTR szOrig = sz;

    if(dwPriv & DMPL_PRIV_READ) {
        strcpy(sz, " read");
        sz += 5;
    }
    if(dwPriv & DMPL_PRIV_WRITE) {
        strcpy(sz, " write");
        sz += 6;
    }
    if(dwPriv & DMPL_PRIV_CONTROL) {
        strcpy(sz, " control");
        sz += 8;
    }
    if(dwPriv & DMPL_PRIV_CONFIGURE) {
        strcpy(sz, " config");
        sz += 7;
    }
    if(dwPriv & DMPL_PRIV_MANAGE) {
        strcpy(sz, " manage");
        sz += 7;
    }
    *sz = 0;
}

DWORD DmplFromSz(LPCSTR sz)
{
    ULONG dmpl = 0;

    if(PchGetParam(sz, "read", FALSE))
        dmpl |= DMPL_PRIV_READ;
    if(PchGetParam(sz, "write", FALSE))
        dmpl |= DMPL_PRIV_WRITE;
    if(PchGetParam(sz, "control", FALSE))
        dmpl |= DMPL_PRIV_CONTROL;
    if(PchGetParam(sz, "config", FALSE))
        dmpl |= DMPL_PRIV_CONFIGURE;
    if(PchGetParam(sz, "manage", FALSE))
        dmpl |= DMPL_PRIV_MANAGE;

    return dmpl;
}

void FillUserInfoSz(LPSTR sz, LPCSTR szName, DWORD dwPrivileges,
    PULARGE_INTEGER pluPasswd)
{
    char szPasswd[32];

    if(pluPasswd)
        sprintf(szPasswd, " passwd=0q%08x%08x", pluPasswd->HighPart,
            pluPasswd->LowPart);
    else
        szPasswd[0] = 0;

    sprintf(sz, "name=\"%s\"%s", szName, szPasswd);
    FillAccessPrivSz(sz + strlen(sz), dwPrivileges);
}

void WriteIniSecurity(INF *pinf)
{
    struct {
        OBJECT_DIRECTORY_INFORMATION odi;
        OCHAR sz[64];
    } odi;
    HRESULT hr;
    HANDLE h;
    int i;
    PDMUSER pusr;
    char sz[256];

    EnterCriticalSection(&csUserList);

    if(g_fLockLevel) {
        sprintf(sz, "lockmode boxid=0q%08x%08x%s", g_luBoxId.HighPart,
            g_luBoxId.LowPart, g_fLockLevel==2 ? " encrypt" : "");
        WriteIniSz(pinf, sz);
    }

    if(g_fAdminPasswd) {
        sprintf(sz, "adminpw passwd=0q%08x%08x", g_luAdminPasswd.HighPart,
            g_luAdminPasswd.LowPart);
        WriteIniSz(pinf, sz);
    }

    if(g_fLockLevel && hUserList) {
        strcpy(sz, "user ");
        i = 0;
        while(NT_SUCCESS(NtQueryDirectoryObject(hUserList, &odi, sizeof odi,
            i == 0, &i, NULL)))
        {
            ASSERT(odi.odi.Name.Buffer == odi.sz);
            odi.sz[odi.odi.Name.Length] = 0;
            pusr = PusrLookupUser(odi.odi.Name.Buffer);
            if(pusr) {
                FillUserInfoSz(sz + 5, odi.sz, pusr->dwPrivileges,
                    pusr->fHasPasswd ? &pusr->luPasswd : NULL);
                WriteIniSz(pinf, sz);
                ObDereferenceObject(pusr);
            }
        }
    }

    LeaveCriticalSection(&csUserList);
}

void RemoveAllUsers(void)
{
    struct {
        OBJECT_DIRECTORY_INFORMATION odi;
        OCHAR sz[64];
    } odi;
    HRESULT hr;
    HANDLE h;
    int i;
    PDMUSER pusr;

    EnterCriticalSection(&csUserList);

    /* We actually only empty the user list if the lock level is zero */
    if(!g_fLockLevel && hUserList) {
        i = 0;
        while(NT_SUCCESS(NtQueryDirectoryObject(hUserList, &odi, sizeof odi,
            i == 0, &i, NULL)))
        {
            ASSERT(odi.odi.Name.Buffer == odi.sz);
            odi.sz[odi.odi.Name.Length] = 0;
            pusr = PusrLookupUser(odi.odi.Name.Buffer);
            if(pusr) {
                ObMakeTemporaryObject(pusr);
                ObDereferenceObject(pusr);
                ObDereferenceObject(pusr);
                i = 0;
            }
        }
    }

    LeaveCriticalSection(&csUserList);
}

DMHRAPI DmSetUserAccess(LPCSTR szUserName, DWORD dwAccess)
{
    PDMUSER pusr;

    pusr = PusrLookupUser(szUserName);
    if(!pusr)
        return XBDM_NOSUCHFILE;
    pusr->dwPrivileges = dwAccess;
    ObDereferenceObject(pusr);
    return XBDM_NOERR;
}

DMHRAPI DmGetUserAccess(LPCSTR szUserName, LPDWORD lpdwAccess)
{
    PDMUSER pusr;

    pusr = PusrLookupUser(szUserName);
    if(!pusr)
        return XBDM_NOSUCHFILE;
    *lpdwAccess = pusr->dwPrivileges;
    ObDereferenceObject(pusr);
    return XBDM_NOERR;
}

DMHRAPI DmWalkUserList(PDM_WALK_USERS *ppdmwu, PDM_USER pdusr)
{
    struct {
        OBJECT_DIRECTORY_INFORMATION odi;
        OCHAR sz[64];
    } odi;
    HRESULT hr;
    HANDLE h;
    int i;
    PDMUSER pusr;
    NTSTATUS st;

    if(!ppdmwu)
        return E_INVALIDARG;
    if(!g_fLockLevel || !hUserList)
        return XBDM_ENDOFLIST;

    st = NtQueryDirectoryObject(hUserList, &odi, sizeof odi,
        *(PULONG)ppdmwu == 0, (PULONG)ppdmwu, NULL);
    if(st == STATUS_NO_MORE_ENTRIES)
        return XBDM_ENDOFLIST;
    else if(!NT_SUCCESS(st))
        return HrFromStatus(st, E_FAIL);
    
    memset(pdusr, 0, sizeof *pdusr);
    memcpy(pdusr->UserName, odi.odi.Name.Buffer, odi.odi.Name.Length);
    pusr = PusrLookupUser(pdusr->UserName);
    if(!pusr)
        return E_UNEXPECTED;
    pdusr->AccessPrivileges = pusr->dwPrivileges;
    return XBDM_NOERR;
}

DMHRAPI DmCloseUserList(PDM_WALK_USERS pdmwu)
{
    return XBDM_NOERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\sysfileupd.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sysfileupd.c

Abstract:

    This module implements routines to update system files on XDK.

--*/

#include "dmp.h"
#undef DeleteFile

NTSTATUS
ReplaceFile(
    IN OBJECT_STRING* NewFileName,
    IN HANDLE ExistingHandle
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;
    FILE_RENAME_INFORMATION RenameInfo;

    // Clear read-only file attribute as needed
    InitializeObjectAttributes(&ObjA, NewFileName, OBJ_CASE_INSENSITIVE, 0, 0);

    Status = NtOpenFile(&Handle, (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &ObjA, &IoStatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT);

    if (NT_SUCCESS(Status)) {
        RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
        BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        NtSetInformationFile(Handle, &IoStatusBlock, &BasicInfo, sizeof(BasicInfo),
            FileBasicInformation);
        NtClose(Handle);
    }

    // Rename the file
    RenameInfo.ReplaceIfExists = TRUE;
    RenameInfo.RootDirectory = 0;
    RenameInfo.FileName.Length = NewFileName->Length;
    RenameInfo.FileName.MaximumLength = NewFileName->MaximumLength;
    RenameInfo.FileName.Buffer = NewFileName->Buffer;

    Status = NtSetInformationFile(ExistingHandle, &IoStatusBlock, &RenameInfo,
        sizeof(RenameInfo), FileRenameInformation);

    return Status;
}

HRESULT HrReceiveSystemFile(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    FILE_DISPOSITION_INFORMATION fdi;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    if (pdmcc->DataSize) {
        pccs->sysupd.BytesReceived += pdmcc->DataSize;
        ASSERT(pccs->sysupd.BytesReceived <= DISK_BUF_SIZE);
        pdmcc->BytesRemaining -= pdmcc->DataSize;
    } else if (pdmcc->BytesRemaining) {
        DmFreePool(pccs->sysupd.FileBuffer);
        DmFreePool(pccs->sysupd.FileName.Buffer);
        fdi.DeleteFile = TRUE;
        NtSetInformationFile(pccs->sysupd.FileHandle, &IoStatusBlock, &fdi,
            sizeof(fdi), FileDispositionInformation);
        _snprintf(szResponse, cchResponse, "Unexpected data size");
        szResponse[cchResponse - 1] = 0;
        return E_UNEXPECTED;
    }

    // See if we're ready for a disk write
    if (!pdmcc->BytesRemaining || pccs->sysupd.BytesReceived == DISK_BUF_SIZE) {

        pccs->sysupd.Crc = Crc32(pccs->sysupd.Crc, pccs->sysupd.FileBuffer,
            pccs->sysupd.BytesReceived);

        Status = NtWriteFile(pccs->sysupd.FileHandle, NULL, NULL,
            NULL, &IoStatusBlock, pccs->sysupd.FileBuffer,
            pccs->sysupd.BytesReceived, NULL);

        if (!NT_SUCCESS(Status)) {
cleanup:
            fdi.DeleteFile = TRUE;
            NtSetInformationFile(pccs->sysupd.FileHandle, &IoStatusBlock,
                &fdi, sizeof(fdi), FileDispositionInformation);
            NtClose(pccs->sysupd.FileHandle);
            pccs->sysupd.FileHandle = NULL;
            _snprintf(szResponse, cchResponse, "File write error");
            szResponse[cchResponse - 1] = 0;
            return HrFromStatus(Status, XBDM_CANNOTCREATE);
        } else if (!pdmcc->BytesRemaining) {
            if (pccs->sysupd.Crc != pccs->sysupd.ExpectedCrc) {
                _snprintf(szResponse, cchResponse, "Invalid CRC");
                szResponse[cchResponse - 1] = 0;
                goto cleanup;
            }
            Status = ReplaceFile(&pccs->sysupd.FileName, pccs->sysupd.FileHandle);
            if (!NT_SUCCESS(Status)) {
                _snprintf(szResponse, cchResponse, "Replace file failed (0x%X)", Status);
                szResponse[cchResponse - 1] = 0;
                goto cleanup;
            }
            NtClose(pccs->sysupd.FileHandle);
        }

        pccs->sysupd.BytesReceived = 0;

        if (!pdmcc->BytesRemaining) {
            DmFreePool(pccs->sysupd.FileBuffer);
            pccs->sysupd.FileBuffer = NULL;
        }
    }

    // Make sure the buffer pointer is set up
    pdmcc->Buffer = pccs->sysupd.FileBuffer + pccs->sysupd.BytesReceived;
    pdmcc->BufferSize = DISK_BUF_SIZE - pccs->sysupd.BytesReceived;
    return XBDM_NOERR;
}

VOID
CreateDirectoryFromPath(
    IN CONST OBJECT_STRING* Path
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    WORD Length;

    FileName.Buffer = Path->Buffer;
    Length = FileName.Length = Path->Length;
    FileName.MaximumLength = Path->MaximumLength;
    InitializeObjectAttributes(&ObjA, &FileName, OBJ_CASE_INSENSITIVE, 0, 0);

    // REVIEW: there should be a better way to do this
    for (FileName.Length=1; FileName.Length<Length; FileName.Length++) {
        if (FileName.Buffer[FileName.Length] != '\\') {
            continue;
        }

        Status = NtCreateFile(&Handle, FILE_LIST_DIRECTORY | SYNCHRONIZE,
            &ObjA, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_CREATE,
            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | \
            FILE_OPEN_FOR_BACKUP_INTENT);

        if (NT_SUCCESS(Status)) {
            NtClose(Handle);
        }
    }
}

HRESULT HrUpdateSystemFile(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS* pccs;
    SIZE_T ImageSize;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING ObjS;
    OCHAR buffer[512];
    LARGE_INTEGER FileSize;
    OCHAR* psz;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_END_OF_FILE_INFORMATION feof;
    FILE_DISPOSITION_INFORMATION fdi;
    HRESULT hr;

    if (!pdmcc) {
        return E_FAIL;
    }

    pccs = (CCS*)pdmcc->CustomData;

    // Get file size and CRC32 of entire file
    if (!FGetNamedDwParam(sz, "size", &pdmcc->BytesRemaining, szResp) || \
        !FGetNamedDwParam(sz, "crc", &pccs->sysupd.ExpectedCrc, szResp)) {
        _snprintf(szResp, cchResp, "Invalid parameter(s)");
        szResp[cchResp - 1] = 0;
        return E_FAIL;
    }

    // Allocate buffer for file name and file buffer
    pccs->sysupd.FileBuffer = DmAllocatePoolWithTag(
        DISK_BUF_SIZE + sizeof(buffer), 'ufsx');
    if (!pccs->sysupd.FileBuffer) {
        _snprintf(szResp, cchResp, "Not enough memory");
        szResp[cchResp - 1] = 0;
        return E_OUTOFMEMORY;
    }

    pccs->sysupd.FileName.Length = 0;
    pccs->sysupd.FileName.MaximumLength = sizeof(buffer);
    pccs->sysupd.FileName.Buffer = (PCHAR)\
        ((ULONG_PTR)pccs->sysupd.FileBuffer + DISK_BUF_SIZE);

    if (!FGetSzParam(sz, "name", pccs->sysupd.FileName.Buffer,
            pccs->sysupd.FileName.MaximumLength/sizeof(OCHAR))) {
        _snprintf(szResp, cchResp, "missing or invalid file name");
        szResp[cchResp - 1] = 0;
        hr = E_FAIL;
        goto cleanup;
    }

    pccs->sysupd.FileName.Length = strlen(pccs->sysupd.FileName.Buffer) * \
        sizeof(OCHAR);
    ASSERT(pccs->sysupd.FileName.Length < sizeof(buffer));

    // Create temporary file which later will be renamed to the real target
    strcpy(buffer, pccs->sysupd.FileName.Buffer);
    psz = strrchr(buffer, '\\');

    if (!psz || sizeof(buffer) - ((ULONG_PTR)psz - (ULONG_PTR)buffer + 1) < \
        sizeof("\\temp1234.tmp")) {
        _snprintf(szResp, cchResp, "Invalid file name");
        szResp[cchResp - 1] = 0;
        hr = E_INVALIDARG;
        goto cleanup;
    }

    sprintf(psz, "\\temp%04x.tmp", NtGetTickCount() & 0xFFFF);
    RtlInitObjectString(&ObjS, buffer);
    InitializeObjectAttributes(&ObjA, &ObjS, OBJ_CASE_INSENSITIVE, 0, 0);
    CreateDirectoryFromPath(&ObjS);

    FileSize.HighPart = 0;
    FileSize.LowPart = pdmcc->BytesRemaining;

    Status = NtCreateFile(&pccs->sysupd.FileHandle, GENERIC_WRITE | DELETE | SYNCHRONIZE,
        &ObjA, &IoStatusBlock, &FileSize, FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_CREATE,
        FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT);

    if (NT_SUCCESS(Status)) {

        // Commit the size of the file
        feof.EndOfFile = FileSize;

        Status = NtSetInformationFile(pccs->sysupd.FileHandle, &IoStatusBlock, &feof,
            sizeof(feof), FileEndOfFileInformation);

        if (NT_SUCCESS(Status)) {
            pccs->sysupd.BytesReceived = 0;
            pccs->sysupd.Crc = ~0UL;
            pdmcc->Buffer = pccs->sysupd.FileBuffer;
            pdmcc->BufferSize = DISK_BUF_SIZE;
            pdmcc->HandlingFunction = HrReceiveSystemFile;
            return XBDM_READYFORBIN;
        } else {
            // Mark the file for deletion and close the file
            fdi.DeleteFile = TRUE;
            NtSetInformationFile(&pccs->sysupd.FileHandle, &IoStatusBlock, &fdi, sizeof(fdi),
                FileDispositionInformation);
            NtClose(pccs->sysupd.FileHandle);
            pccs->sysupd.FileHandle = NULL;
            _snprintf(szResp, cchResp, "Disk full");
            szResp[cchResp - 1] = 0;
        }
    }

    hr = HrFromStatus(Status, XBDM_CANNOTCREATE);

cleanup:
    DmFreePool(pccs->sysupd.FileBuffer);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\i386\dbregs.asm ===
title   "Debug registers"
.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Debug registers"

;++
;
; SetDreg
;
; Set up dr0-dr3 and dr7 for hardware breakpoints
;
;--
cPublicProc _SetDreg, 5
cPublicFpo 0,0
; don't want to be bothered while we're setting this stuff up
        pushfd
        cli
        mov ecx, [esp+8]
; First set up a mask to clear out dr7
        shl ecx, 1
        mov eax, 0f0003h
        shl eax, cl
        not eax
        mov edx, dr7
        and eax, edx
        xor edx, edx
        mov dr7, eax
        mov dr6, edx
; If we're disabling the breakpoint, we're done now
        mov dl, [esp+24]
        shr ecx, 1
        test edx, edx
        jz sd10
; Set the appropriate dreg
        test ecx, ecx
        mov eax, [esp+12]
        jnz cl0
        mov dr0, eax
        jmp sd1
cl0:
        dec ecx
        jnz cl1
        mov dr1, eax
        jmp sd1
cl1:
        dec ecx
        jnz cl2
        mov dr2, eax
        jmp sd1
cl2:
        dec ecx
        jnz reg3
        mov dr3, eax
sd1:
; now construct the thing we actually shift into dr7
        xor edx, edx
        mov dl, [esp+20]
        shl edx, 2
        mov ecx, [esp+8]
        or dl, [esp+16]
        shl ecx, 1
        shl edx, 16
        or edx, 3
        mov eax, dr7
        shl edx, cl
        or edx, eax
        mov dr7, edx
; and now we're done
sd10:
        popfd
        ret 14h
reg3:
        int 3
        jmp sd10
stdENDP _SetDreg

cPublicFastCall DwExchangeDr6, 1
        mov eax, dr6
        mov dr6, ecx
        fstRET DwExchangeDr6
fstENDP DwExchangeDr6

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmtl.c ===
/*
 *
 * dmtl.c
 *
 * Debug monitor transport layer
 *
 */

#include "dmp.h"

BOOL DmStartRmtSession(ULONG ulIPAddr)
{
    /* We need to establish the connection before we can successfully spin off
     * the debug thread */
	SOCKET sockMain;
	SOCKET sockPoll;
	struct sockaddr_in addr;

    _asm int 3

	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(ulIPAddr);

	/* Connect the main thread */
	sockMain = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(INVALID_SOCKET == sockMain) {
        _asm int 3
        return FALSE;
    }
	addr.sin_port = htons(0x801);
	if(0 != connect(sockMain, (struct sockaddr *)&addr, sizeof addr)) {
        _asm int 3
		closesocket(sockMain);
		return FALSE;
	}

	/* Connect the poll thread */
	sockPoll = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(INVALID_SOCKET == sockPoll) {
        _asm int 3
	    closesocket(sockMain);
	    return FALSE;
	}
	addr.sin_port = htons(0x802);
	if(0 != connect(sockPoll, (struct sockaddr *)&addr, sizeof addr)) {
        _asm int 3
		closesocket(sockPoll);
		closesocket(sockMain);
		return FALSE;
	}

	return TRUE;
}

void DmListenForRmtSession(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\dmserv.h ===
/*
 *
 * dmserv.h
 *
 * Random stuff for the server
 *
 */

#define MAX_CONNECTIONS 4
#define MAX_CONN_BUF 512
#define CONN_BINARY 0x80000000
#define CONN_OVERFLOW 0x40000000
#define CONN_BINSEND 0x20000000
#define CONN_BINERROR 0x10000000
#define CONN_MULTILINE 0x08000000
#define CONN_DHKEY 0x02000000
#define CONN_RECEIVED 0xffff
#define DISK_BUF_SIZE 0x4000

/* Command continue stuff */
typedef struct _CCS {
    union {
        FILE_NETWORK_OPEN_INFORMATION fba;
        struct {
            HANDLE h;
            int i;
        };
        BYTE *pb;
        DM_THREADINFO dmti;
        DM_XTLDATA dmxd;
        DM_COUNTDATA dmcd;
        struct {
            HANDLE hFile;
            BYTE *rgbBuf;
            int ib;
            BOOL fError:1,
            fDidSize:1,
            unused:30;
        };
        PDM_WALK_MODULES pdmwm;
        PDM_WALK_MODSECT pdmws;
        PDM_WALK_COUNTERS pdmwc;
        PDM_WALK_USERS pdmwu;
        struct {
            PDM_XBE pxbe;
            int iiXbe;
        };
        struct {
            PBYTE  ImageBuffer;
            SIZE_T ImageSize;
            SIZE_T BytesReceived;
            DWORD  Crc;
            BOOL   IgnoreVersionChecking;
        } KernelImage;
        struct {
            PBYTE FileBuffer;
            HANDLE FileHandle;
            OBJECT_STRING FileName;
            DWORD Crc, ExpectedCrc;
            SIZE_T BytesReceived;
        } sysupd;
        struct {
            DWORD Width, Height, Pitch, Format;
            BOOL fFirstTime;
            BYTE *pbyFrameBuffer;
        } Screenshot;
    };
} CCS;

/* Extended command handler */
typedef struct _ECH {
    char szExtName[64];
    PDM_CMDPROC pfnHandler;
    HANDLE (*pfnCreateThread)();
} ECH, *PECH;

#define MAX_ECH 16

/* Command handler */
typedef struct _CHH {
    LPCSTR szCommand;
    DWORD dmplMask;
    PDM_CMDPROC pfnHandler;
    DWORD dmplCombined;
    DWORD dwFlags;
} CHH, *PCHH;

#define CHH_ANYTHREAD 1

/* Connection state */
typedef struct _CST {
    SOCKET s;
    DWORD dwStatus;
    DWORD dmplCur;
    PECH pechDedicated;
    PETHREAD pthrDedicated;
    ULARGE_INTEGER luDHKey;
    ULARGE_INTEGER luConnectNonce;
    char szBuf[MAX_CONN_BUF];
    DM_CMDCONT dmcc;
    CCS ccs;
} CST, *PCST;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\i386\defer.asm ===
title   "Deferred notifications"
.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Deferred notifications"

        extrn   _g_ppdfnNext:DWORD
        extrn   _g_pdfnFirst:DWORD
        extrn   _ProcessDeferredNotifications@4:near

;++
;
; QueueDfn
;
; Queue a deferred notification on the global queue
;
;--

cPublicProc _QueueDfn, 1
cPublicFpo 0,0
        mov     eax, [esp+4]
        pushfd
        cli

; put this guy on the tail of the list
        mov     ecx, _g_ppdfnNext
        mov     [ecx], eax
        mov     _g_ppdfnNext, eax

        popfd
        ret     4

stdENDP _QueueDfn

cPublicProc _ProcessDfns, 0
cPublicFpo 0,0
        push    ebp
        mov     ebp, esp
        pushfd
        cli

; first, null-terminate the list
        xor     ecx, ecx
        mov     eax, _g_ppdfnNext
        mov     [eax], ecx

; figure out what work we're going to do
        mov     eax, _g_pdfnFirst
        push    eax

; now reset the list
        lea     eax, _g_pdfnFirst
        mov     _g_ppdfnNext, eax

; now we're ready to do the notifications
        sti
        call    _ProcessDeferredNotifications@4

; and we're done
        popfd
        mov     esp, ebp
        pop     ebp
        ret

stdENDP _ProcessDfns

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\flash.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    flash.c

Abstract:

    This module implements function used to program kernel image to flash
    ROM on EVT and DVT machine.

--*/

#include "dmp.h"
#include <pci.h>

#define ROM_VERSION_BYTE_OFFSET 0x78

typedef enum {
    FlashUnknownDevice = 0,
    FlashSST49LF040,
    FlashGeneric29F080,
    FlashGeneric29F040,
    FlashGeneric29F020,
} FlashDeviceID;

typedef struct {
    FlashDeviceID DeviceID;
    WCHAR* DeviceCodes;
} FlashDeviceClass;

typedef enum {
    FlashStatusReady,
    FlashStatusBusy,
    FlashStatusEraseSuspended,
    FlashStatusTimeout,
    FlashStatusError
} FlashStatus;

//
// Table of known flash devices list
//

FlashDeviceClass _FlashDeviceClass[] = {
    { FlashSST49LF040,    L"\xBF53" },
    { FlashGeneric29F080, L"\x01D5\x04D5\xADD5" },
    { FlashGeneric29F040, L"\x1F13\x20E2\xC2A4\xADA4" },
    { FlashGeneric29F020, L"\x1F07\x1F08\x1F0B\x2034\x20B0\xC234\xC2B0\xDA8C" },
};

//
// Mapped virtual address of ROM region
//

PVOID KernelRomBase;

// SIZE_T
// FlashSize(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro returns size of flash ROM specified by device identifier id
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Size of flash ROM for specified device
//
// --

#define FlashSize(ID)       FlashSizeMap[(ID)]

SIZE_T FlashSizeMap[] = {
    0,
    512 * 1024,     // SST 49LF040 Firmware Hub
    1024 * 1024,    // Generic 29F080
    512 * 1024,     // Generic 29F040
    256 * 1024,     // Generic 29F020
};

// ULONG_PTR
// FlashBaseAddress(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro calculates the base address of flash ROM specified by ID,
//     based on the size of the chip
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Base address of flash ROM from top 4GB
//
// --

#define FlashBaseAddress(ID)    ((ULONG_PTR)(0xFFFFFFFF-FlashSize(ID)+1))

//
// Lowest possible base address of flash ROM and region size
//

#define FLASH_BASE_ADDRESS      0xFFF00000
#define FLASH_REGION_SIZE       (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

// BYTE
// FlashReadByte(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads one byte from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     A read byte from specified address
//
// --

#define FlashReadByte(a) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteByte(
//     IN ULONG_PTR Physical,
//     IN BYTE Byte
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes one byte to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Byte - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteByte(a, d) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

// WORD
// FlashReadWord(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads two bytes from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     Two byte from specified address
//
// --

#define FlashReadWord(a) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteWord(
//     IN ULONG_PTR Physical,
//     IN WORD Word
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes two bytes to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Word - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteWord(a, d) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

FlashStatus
FlashGetStatus(
    IN FlashDeviceID ID,
    IN ULONG_PTR Address OPTIONAL,
    IN BYTE Data
    )
/*++

Routine Description:

    This routine checks status of flash chip using data# polling method.
    The data# polling bit, DQ7, indicates whether the Embeded Algorithm
    is in progress or completed.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    Address - Physical address of flash ROM to be checked

    Data - Expected data at specified address

Return Value:

    Status of flash chip, see the definition of FlashStatus above.

--*/
{
    UCHAR retry=1, d, t;

    if (!ARGUMENT_PRESENT(Address)) {
        Address = FlashBaseAddress(ID);
    }

    if (ID == FlashSST49LF040) {

        //
        // SST doesn't support Exceeded Timing Limits, DQ5
        //

        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if (t == d) {
            return FlashStatusReady;
        } else {
            return FlashStatusBusy;
        }

    } else {

again:
        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if (t == d) {
            return FlashStatusReady;        // data matches
        } else if (d & 0x20) {              // Timeout?
            d = FlashReadByte(Address) & 0x80;
            if (t == d) {
                return FlashStatusReady;    // data matches
            }
            if (retry--) {
                goto again;                 // may have been write completion
            }
            return FlashStatusTimeout;
        }

        if (retry--) {
            goto again;                     // may have been write completion
        } else {
            return FlashStatusError;
        }
    }
}

VOID
FlashResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine resets flash ROM back to read mode if device is in ID command
    mode or during a program or erase operation

Arguments:

    None

Return Value:

    None

--*/
{
    FlashWriteByte(0xFFFF5555, 0xAA);
    FlashWriteByte(0xFFFF2AAA, 0x55);
    FlashWriteByte(0xFFFF5555, 0xF0);
    KeStallExecutionProcessor(150000);
}

FlashDeviceID
FlashDetectDevice(
    VOID
    )
/*++

Routine Description:

    This routine detects the device and manufacturer id of flash device on
    the system.  The device on Xbus will be detected first and if no device
    detected, LPC bus will be next.

Arguments:

    None

Return Value:

    Type of flash id installed in the system or FlashUnknownDevice

--*/
{
    BYTE byte;
    BYTE id1=0, id2=0;
    WORD DeviceID;
    BOOL FirstTime = TRUE;
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_COMMON_CONFIG Configuration;
    SIZE_T loop;

detect:

    FlashWriteByte(0xFFFF5555, 0xAA);
    FlashWriteByte(0xFFFF2AAA, 0x55);
    FlashWriteByte(0xFFFF5555, 0x90);

    KeStallExecutionProcessor(1);

    id1 = FlashReadByte(0xFFFF0000);
    id2 = FlashReadByte(0xFFFF0001);
    DeviceID = id1 << 8 | id2;

    FlashResetDevice();

    for (loop=0; loop<sizeof(_FlashDeviceClass)/sizeof(_FlashDeviceClass[0]); loop++) {
        if (wcschr(_FlashDeviceClass[loop].DeviceCodes, DeviceID)) {
            return _FlashDeviceClass[loop].DeviceID;
        }
    }

    if (FirstTime == TRUE) {

        //
        // We are here because we couldn't find any flash ROM on Xbus.
        // Next thing is to see if this is a EVT board and enable ROM
        // write bus cycle to LPC interface.  By default the write cycle
        // to ROM will drop.
        //

        FirstTime = FALSE;

        //
        // Looking for PCI-to-LPC bridge
        //

        for (byte=0x00; byte<=0xff; byte++) {
            PCISlotNumber.u.AsULONG = byte;
            HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));
            if (Configuration.BaseClass == 6 && Configuration.SubClass == 1) {
                break;
            }
        }

        //
        // If it is Nvidia PCI-to-LPC bridge, enable LPC ROM write
        //

        if (Configuration.VendorID == 0x10DE && Configuration.DeviceID == 0x01B2) {
            byte = 0x01;
            HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte));
            goto detect;
        }

    } else {

        //
        // If we still couldn't find any flash ROM on LPC bus, disable LPC
        // ROM write
        //

        byte = 0x00;
        HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte));
    }

    return FlashUnknownDevice;
}

BOOL
FlashEraseChip(
    FlashDeviceID ID
    )
/*++

Routine Description:

    This routine erase the content of entire flash ROM to 0xFF.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    ULONG_PTR FlashPtr;
    BOOL fBlank = FALSE;
    SIZE_T Count, Retries=5;

    while (Retries--) {

        FlashWriteByte(0xFFFF5555, 0xAA);
        FlashWriteByte(0xFFFF2AAA, 0x55);
        FlashWriteByte(0xFFFF5555, 0x80);
        FlashWriteByte(0xFFFF5555, 0xAA);
        FlashWriteByte(0xFFFF2AAA, 0x55);
        FlashWriteByte(0xFFFF5555, 0x10);

        FlashPtr = ~0L;

        //
        // Wait until flash chip is ready and completely erased.
        //

        Count = 0x100000;
        while (FlashGetStatus(ID, FlashPtr, 0xFF) != FlashStatusReady && Count) {
            Count--;
        }

        //
        // For some reasons in the FIB DVT, even the flash status is
        // ready but the actual data is not written to the chip.
        // We just have to poll the actual data and spin for a while
        // if it didn't get through.
        //

        Count = 0x100000;
        while (FlashReadByte(FlashPtr) != 0xFF && Count) {
            KeStallExecutionProcessor(150000);
            Count--;
        }

        //
        // Perform a blank check by compare all the content with 0xFF
        //

        Count = FlashSize(ID);
        FlashResetDevice();
        FlashPtr = FlashBaseAddress(ID);

        ASSERTMSG("Size of flash ROM must be power of two", (Count & (Count-1)) == 0);

        while (Count) {
            if (FlashReadWord(FlashPtr) != 0xFFFF) {
                DbgPrint("FLASH: blank check failed (retries=%d)\n", Retries);
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if (Count == 0) {
            fBlank = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fBlank;
}

BOOL
FlashProgramImage(
    IN FlashDeviceID ID,
    IN PVOID ImageBuffer
    )
/*++

Routine Description:

    This routine programs the content of flash ROM with new image.  The flash
    ROM has to be blank first before programming.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    ImageBuffer - Buffer contains the content to be programmed

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    BYTE b;
    PBYTE pb;
    PWORD pw;
    ULONG TimeOut;
    ULONG_PTR FlashPtr;
    BYTE TrueData, CurrData;
    BOOL Loop, fSuccess = FALSE;
    SIZE_T Count, Retries = 5;
    SIZE_T Again;

    while (Retries--) {

        Count = FlashSize(ID);
        pb = (PBYTE)ImageBuffer;
        FlashPtr = FlashBaseAddress(ID);

        while (Count--) {

            b = *pb++;

            if (b != 0xFF) {
                FlashWriteByte(0xFFFF5555, 0xAA);
                FlashWriteByte(0xFFFF2AAA, 0x55);
                FlashWriteByte(0xFFFF5555, 0xA0);
                FlashWriteByte(FlashPtr, b);

                //
                // Wait until flash chip is ready for next command
                //

                Again = 0x100000;
                while (FlashGetStatus(ID, FlashPtr, b) != FlashStatusReady && Again) {
                    Again--;
                }

                //
                // For some reasons in the FIB DVT, even the flash status is
                // ready but the actual data is not written to the chip.
                // We just have to poll the actual data and spin for a while
                // if it didn't get through.
                //

                Again = 0x100000;
                while (FlashReadByte(FlashPtr) != b && Again) {
                    Again--;
                }
            }

            FlashPtr++;
        }

        //
        // Verify the content that just has been programmed
        //

        Count = FlashSize(ID);
        pw = (PWORD)ImageBuffer;
        FlashPtr = FlashBaseAddress(ID);
        FlashResetDevice();

        while (Count) {
            if (FlashReadWord(FlashPtr) != *pw++) {
                DbgPrint("FLASH: verification failed (retries=%d)\n", Retries);
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if (Count == 0) {
            fSuccess = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fSuccess;
}

UINT64
FASTCALL
FlashReadMSR(
    IN ULONG Address
    )
/*++

Routine Description:

    This routine reads Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

Return Value:

    64-bit value of specified MSR

--*/
{
    __asm {
        rdmsr
    }
}

VOID
FASTCALL
FlashWriteMSR(
    IN ULONG Address,
    IN UINT64 Value
    )
/*++

Routine Description:

    This routine writes Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

    Value - 64-bit value to be written

Return Value:

    None

--*/
{
    __asm {
        mov     eax, DWORD PTR [Value]
        mov     edx, DWORD PTR [Value+4]
        wrmsr
    }
}

#ifdef FLASH_TIME

UINT64
FlashReadTSC(
    VOID
    )
/*++

Routine Description:

    This routine reads processor's time-stamp counter.  The time-stamp counter
    is contained in a 64-bit MSR.  The high-order of 32 bits MSR are loaded
    into the EDX register, and the low-order 32 bits are loaded into the EAX
    register.  The processor increments the time-stamp counter MSR every
    clock cycle and resets it to 0 whenever the processor reset.

Arguments:

    None

Return Value:

    64-bit MSR of time-stamp counter

--*/
{
    __asm {
        rdtsc
    }
}

#endif // FLASH_TIME

VOID
FlashChangeRomCaching(
    BOOL EnableCache
    )
/*++

Routine Description:

    This routine searches for ROM cache setting in MTRR and disable it.  It is
    necessary to disable and flash cache before changing MTRR.  The following
    steps are recommended by Intel in order to change MTRR settings. Save CR4,
    disable and flush processor cache, flush TLB, disable MTRR, change MTRR
    settings, flush cache and TLB, enable MTRR and restore CR4

Arguments:

    EnableCache - TRUE to enable caching, FALSE to disable

Return Value:

    None

--*/
{
    ULONG MTRR;
    UINT64 v, MTRRdeftype;
    ULONG Base, Type;


    __asm {
        push    ecx
        push    edx

        _emit   0fh                 ; mov  eax, cr4
        _emit   20h
        _emit   0e0h

        push    eax                 ; save content of cr4

        mov     eax, cr0            ; disable and flush cache
        push    eax                 ; save content of cr0
        or      eax, 060000000H
        mov     cr0, eax
        wbinvd

        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Save the content of MTRR deftype and disable MTRR
    //

    MTRRdeftype = FlashReadMSR(0x2FF);
    FlashWriteMSR(0x2FF, 0);

    for (MTRR=0x200; MTRR<0x20F; MTRR+=2) {
        v = FlashReadMSR(MTRR);
        Base = (ULONG)((v >> 12) & 0xFFFFFF);
        Type = (BYTE)v;

        //
        // Set or reset valid bit according to cache enable flag
        //

        if (Base >= (FLASH_BASE_ADDRESS >> 12) && Type != 0) {
            v = FlashReadMSR(MTRR+1);
            v = EnableCache ? (v | 0x800) : (v & (~0x800));
            FlashWriteMSR(MTRR+1, v);
        }
    }

    __asm {
        wbinvd                      ; flush cache
        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Restore content of MTRR deftype, MTRR should be re-enabled
    //

    FlashWriteMSR(0x2FF, MTRRdeftype);

    __asm {
        pop     eax                 ; restore cr0
        mov     cr0, eax

        pop     eax                 ; restore cr4

        _emit   0fh                 ; mov  cr4, eax
        _emit   22h
        _emit   0e0h

        pop     edx
        pop     ecx
    }
}

HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp,
    IN  BOOL   IgnoreVersionChecking
    )
{
#ifdef FLASH_TIME
    UINT64 ClockTick;
#endif

    FlashDeviceID ID;
    HRESULT hr = XBDM_NOERR;
    BYTE RomVersion, ImageVersion;

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC();
#endif

    if (IsBadReadPtr(ImageBuffer, ImageSize) || \
        IsBadWritePtr(szResp, cchResp)) {
        return HRESULT_FROM_WIN32(ERROR_NOACCESS);
    }

    //
    // Map top 1MB of physical memory of ROM region (FFF00000-FFFFFFFF)
    //

    KernelRomBase = MmMapIoSpace(FLASH_BASE_ADDRESS, FLASH_REGION_SIZE,
                                 PAGE_READWRITE | PAGE_NOCACHE);

    if (!KernelRomBase) {
        _snprintf(szResp, cchResp, "unable to map i/o space");
        return E_FAIL;
    }

    //
    // Before disable all interrupts, sleep 300 msec so that the TCP/IP stack
    // get a chance a respond ACK to the other end
    //

    Sleep(300);

    __asm cli

    DbgPrint("FLASH: interrupts are now disabled\n");

    //
    // Disable ROM caching
    //

    FlashChangeRomCaching(FALSE);

    ID = FlashDetectDevice();

    if (ID == FlashUnknownDevice) {
        _snprintf(szResp, cchResp, "Unknown flash device id");
        hr = E_FAIL;
        goto cleanup;
    }

    if (FlashSize(ID) != ImageSize) {
        _snprintf(szResp, cchResp, "Invalid image size");
        hr = E_FAIL;
        goto cleanup;
    }

    RomVersion = FlashReadByte(FLASH_BASE_ADDRESS + ROM_VERSION_BYTE_OFFSET);
    ImageVersion = ((PBYTE)ImageBuffer)[ROM_VERSION_BYTE_OFFSET];

    if (!IgnoreVersionChecking && RomVersion != ImageVersion) {
        _snprintf(szResp, cchResp, "Mismatch ROM version (rom=%x, image=%x)",
            RomVersion, ImageVersion);
        hr = E_FAIL;
        goto cleanup;
    }

    DbgPrint("FLASH: erasing and blank checking...\n");

    if ( !FlashEraseChip(ID) ) {
        _snprintf(szResp, cchResp, "Failed to erase flash chip");
        hr = E_FAIL;
        goto cleanup;
    }

    DbgPrint("FLASH: programming...\n");

    if (!FlashProgramImage(ID, ImageBuffer)) {
        _snprintf(szResp, cchResp, "Failed to program kernel image (verify failed)");
        hr = E_FAIL;
        goto cleanup;
    }

    DbgPrint("FLASH: done...\n");

    if (SUCCEEDED(hr)) {
        _snprintf(szResp, cchResp, "Done, new image flashed");
    }

    hr = XBDM_NOERR;

cleanup:

    __asm sti

    DbgPrint("FLASH: interrupts are now enabled\n");

    MmUnmapIoSpace(KernelRomBase, FLASH_REGION_SIZE);

    //
    // Re-enable ROM caching as needed
    //

    FlashChangeRomCaching(TRUE);

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC() - ClockTick;
    DbgPrint("FLASH: elapsed time %I64u seconds\n", ClockTick / 733000000UI64);
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\i386\dxtstart.asm ===
title   "dxt entry call"
.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "dxt entry call"

;++
;
; CallDxtEntry
;
; Call a debugger extension's entry point and keep the stack pointer safe
;
;--

cPublicProc _CallDxtEntry, 2
cPublicFpo 0,0
        xor     ecx, ecx
        mov     eax, [esp+4]
        mov     edx, [esp+8]
        push    ebp
        mov     ebp, esp
        push    ecx
        push    ecx
        push    edx
        call    eax
        mov     esp, ebp
        pop     ebp
        ret     8

stdENDP _CallDxtEntry

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\i386\funccall.asm ===
title   "Function call injection"
.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Function call injection"

        extrn   _DwPreFuncCall@4:near
        extrn   _PostFuncCall@4:near

;++
;
; SetupFuncCall
;
; Wraps all of the work needed to do an embedded function call
;
;--
cPublicProc _SetupFuncCall, 0
cPublicFpo 0,0
        push    eax
        push    ebp
        mov     ebp, esp
        sub     esp, 24
        mov     [ebp-4], eax
        mov     [ebp-8], ecx
        mov     [ebp-12], edx
        mov     [ebp-16], esi
        mov     [ebp-20], edi

; set up for our stack copy
        lea     eax, [ebp-24]
        push    eax
        call    _DwPreFuncCall@4
        mov     ecx, eax

; allocate our stack space
        sub     esp, eax
        mov     edx, [ebp-24]
        mov     edi, esp
        mov     esi, [edx]

; remember our return address
        test    ecx, ecx
        mov     eax, [eax+esi]
        mov     [ebp+4], eax

; if there's nothing to copy, then we won't actually copy the data or make the
; call
        je      Sfc10

; copy the stack data
        rep     movsb

; the address at TOS is the one we're going to call, so call it
        pop     eax
        call    eax
        mov     [ebp-4], eax

; clean up
Sfc10:
        push    [ebp-24]
        call    _PostFuncCall@4
        mov     eax, [ebp-4]
        mov     ecx, [ebp-8]
        mov     edx, [ebp-12]
        mov     esi, [ebp-16]
        mov     edi, [ebp-20]
        mov     esp, ebp
        pop     ebp
        ret

stdENDP _SetupFuncCall

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\exp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    exp.h

Abstract:

    This module contains the private (internal) header file for the executive.

--*/

#ifndef _EXP_
#define _EXP_

#include <ntos.h>
#include <pool.h>

#endif // _EXP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\i386\muldiv.asm ===
title   "Multiply and Divide"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     muldiv.asm (taken from base\client\i386\critsect.asm)
;
;  Abstract:
;
;     Optimized multiply and divide routines
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;
;--

.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Multiply and Divide"
;++
;
; LONG
; MulDiv(
;    IN LONG nNumber,
;    IN LONG nNumerator,
;    IN LONG nDenominator
;    )
;
; Routine Description:
;
;    This function multiples two 32-bit numbers forming a 64-bit product.
;    The 64-bit product is rounded and then divided by a 32-bit divisor
;    yielding a 32-bit result.
;
; Arguments:
;
;    nNumber - Supllies the multiplier.
;
;    nNumerator - Supplies the multiplicand.
;
;    nDenominator - Supplies the divisor.
;
; Return Value:
;
;    If the divisor is zero or an overflow occurs, then a value of -1 is
;    returned as the function value. Otherwise, the rounded quotient is
;    returned as the funtion value.
;
;--

nNumber      equ [esp + 4]
nNumerator   equ [esp + 8]
nDenominator equ DWORD PTR [esp + 12]

cPublicProc _MulDiv, 3
cPublicFpo 3,0
        mov     eax, nNumber            ; get multiplier absolute value
        or      eax, eax                ;
        js      short MD32_First        ; if s, multiplier is negative

;
; The multiplier is positive.
;

        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      MD32_Second             ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      MD32_Third              ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error        ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error        ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error:
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is negative.
;

MD32_First:                             ;
        neg     eax                     ; negate multiplier
        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      short MD32_First10      ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First20      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative and the multiplicand is negative.
;

MD32_First10:                           ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First30      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error10:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv


;
; The multiplier is negative, the multiplicand is positive, and the
; divisor is negative.
;

MD32_First20:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative, the multiplier is negative, and the divisor
; is negative.
;

MD32_First30:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive and the multiplicand is negative.
;

MD32_Second:                            ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_Second10     ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; check for overflow
        jg      short MD32_error20      ; if g, overlfow has occured

        stdRET  _MulDiv

MD32_error20:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is negative, and the divisor
; is negative.
;

MD32_Second10:                          ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is positive, the divisor
; is negative.
;

MD32_Third:                             ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error20      ; if g, overflow has occured

        stdRET  _MulDiv

stdENDP _MulDiv

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\mutant.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    mutant.c

Abstract:

    This module implements the executive mutant object. Functions are
    provided to create, open, release, and query mutant objects.

--*/

#include "exp.h"

//
// Define private function prototypes.
//

VOID
ExpDeleteMutant (
    IN PVOID Mutant
    );

//
// Mutant object type information.
//

DECLSPEC_RDATA OBJECT_TYPE ExMutantObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    ExpDeleteMutant,
    NULL,
    (PVOID)FIELD_OFFSET(KMUTANT, Header),
    'atuM'
};

VOID
ExpDeleteMutant (
    IN PVOID Mutant
    )

/*++

Routine Description:

    This function is called when an executive mutant object is about to
    be deleted. The mutant object is released with an abandoned status to
    ensure that it is removed from the owner thread's mutant list if the
    mutant object is currently owned by a thread.

Arguments:

    Mutant - Supplies a pointer to an executive mutant object.

Return Value:

    None.

--*/

{

    //
    // Release the mutant object with an abandoned status to ensure that it
    // is removed from the owner thread's mutant list if the mutant is
    // currently owned by a thread.
    //

    KeReleaseMutant((PKMUTANT)Mutant, MUTANT_INCREMENT, TRUE, FALSE);
    return;
}

NTSTATUS
NtCreateMutant (
    OUT PHANDLE MutantHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN BOOLEAN InitialOwner
    )

/*++

Routine Description:

    This function creates a mutant object, sets its initial count to one
    (signaled), and opens a handle to the object with the specified desired
    access.

Arguments:

    MutantHandle - Supplies a pointer to a variable that will receive the
        mutant object handle.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    InitialOwner - Supplies a boolean value that determines whether the
        creator of the object desires immediate ownership of the object.

Return Value:

    TBS

--*/

{

    PVOID Mutant;
    NTSTATUS Status;

    //
    // Allocate mutant object.
    //

    Status = ObCreateObject(&ExMutantObjectType,
                            ObjectAttributes,
                            sizeof(KMUTANT),
                            (PVOID *)&Mutant);

    //
    // If the mutant object was successfully allocated, then initialize
    // the mutant object and attempt to insert the mutant object in the
    // current process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeMutant((PKMUTANT)Mutant, InitialOwner);
        Status = ObInsertObject(Mutant,
                                ObjectAttributes,
                                0,
                                MutantHandle);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryMutant (
    IN HANDLE MutantHandle,
    OUT PMUTANT_BASIC_INFORMATION MutantInformation
    )

/*++

Routine Description:

    This function queries the state of a mutant object and returns the
    requested information in the specified record structure.

Arguments:

    MutantHandle - Supplies a handle to a mutant object.

    MutantInformation - Supplies a pointer to a record that is to receive
        the requested information.

Return Value:

    TBS

--*/

{

    BOOLEAN Abandoned;
    BOOLEAN OwnedByCaller;
    LONG Count;
    PVOID Mutant;
    NTSTATUS Status;

    //
    // Reference mutant object by handle.
    //

    Status = ObReferenceObjectByHandle(MutantHandle,
                                       &ExMutantObjectType,
                                       &Mutant);

    //
    // If the reference was successful, then read the current state and
    // abandoned status of the mutant object, dereference mutant object,
    // fill in the information structure, and return the length of the
    // information structure if specified. If the write of the mutant
    // information or the return length fails, then do not report an error.
    // When the caller accesses the information structure or length an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Count = KeReadStateMutant((PKMUTANT)Mutant);
        Abandoned = ((PKMUTANT)Mutant)->Abandoned;
        OwnedByCaller = (BOOLEAN)((((PKMUTANT)Mutant)->OwnerThread ==
                                                     KeGetCurrentThread()));

        ObDereferenceObject(Mutant);

        MutantInformation->CurrentCount = Count;
        MutantInformation->OwnedByCaller = OwnedByCaller;
        MutantInformation->AbandonedState = Abandoned;
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtReleaseMutant (
    IN HANDLE MutantHandle,
    OUT PLONG PreviousCount OPTIONAL
    )

/*++

Routine Description:

    This function releases a mutant object.

Arguments:

    Mutant - Supplies a handle to a mutant object.

    PreviousCount - Supplies an optional pointer to a variable that will
        receive the previous mutant count.

Return Value:

    TBS

--*/

{

    LONG Count;
    PVOID Mutant;
    NTSTATUS Status;

    //
    // Reference mutant object by handle.
    //
    // Note that the desired access is specified as zero since only the
    // owner can release a mutant object.
    //

    Status = ObReferenceObjectByHandle(MutantHandle,
                                       &ExMutantObjectType,
                                       &Mutant);

    //
    // If the reference was successful, then release the mutant object. If
    // an exception occurs because the caller is not the owner of the mutant
    // object, then dereference mutant object and return the exception code
    // as the service status. Otherise write the previous count value if
    // specified. If the write of the previous count fails, then do not
    // report an error. When the caller attempts to access the previous
    // count value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        try {
            Count = KeReleaseMutant((PKMUTANT)Mutant, MUTANT_INCREMENT, FALSE, FALSE);
            ObDereferenceObject(Mutant);
            if (ARGUMENT_PRESENT(PreviousCount)) {
                *PreviousCount = Count;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ObDereferenceObject(Mutant);
            return GetExceptionCode();
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\semphore.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    semphore.c

Abstract:

    This module implements the executive semaphore object. Functions are
    provided to create, open, release, and query semaphore objects.

--*/

#include "exp.h"

//
// Semaphore object type information.
//

DECLSPEC_RDATA OBJECT_TYPE ExSemaphoreObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    NULL,
    (PVOID)FIELD_OFFSET(KSEMAPHORE, Header),
    'ameS'
};

NTSTATUS
NtCreateSemaphore (
    IN PHANDLE SemaphoreHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN LONG InitialCount,
    IN LONG MaximumCount
    )

/*++

Routine Description:

    This function creates a semaphore object, sets its initial count to the
    specified value, sets its maximum count to the specified value, and opens
    a handle to the object with the specified desired access.

Arguments:

    SemaphoreHandle - Supplies a pointer to a variable that will receive the
        semaphore object handle.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    InitialCount - Supplies the initial count of the semaphore object.

    MaximumCount - Supplies the maximum count of the semaphore object.

Return Value:

    TBS

--*/

{

    PVOID Semaphore;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if ((MaximumCount <= 0) || (InitialCount < 0) ||
       (InitialCount > MaximumCount)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate semaphore object.
    //

    Status = ObCreateObject(&ExSemaphoreObjectType,
                            ObjectAttributes,
                            sizeof(KSEMAPHORE),
                            (PVOID *)&Semaphore);

    //
    // If the semaphore object was successfully allocated, then initialize
    // the semaphore object and attempt to insert the semaphore object in
    // the current process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeSemaphore((PKSEMAPHORE)Semaphore,
                              InitialCount,
                              MaximumCount);

        Status = ObInsertObject(Semaphore,
                                ObjectAttributes,
                                0,
                                SemaphoreHandle);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQuerySemaphore (
    IN HANDLE SemaphoreHandle,
    OUT PSEMAPHORE_BASIC_INFORMATION SemaphoreInformation
    )

/*++

Routine Description:

    This function queries the state of a semaphore object and returns the
    requested information in the specified record structure.

Arguments:

    SemaphoreHandle - Supplies a handle to a semaphore object.

    SemaphoreInformation - Supplies a pointer to a record that is to receive
        the requested information.

Return Value:

    TBS

--*/

{

    PVOID Semaphore;
    LONG Count;
    LONG Maximum;
    NTSTATUS Status;

    //
    // Reference semaphore object by handle.
    //

    Status = ObReferenceObjectByHandle(SemaphoreHandle,
                                       &ExSemaphoreObjectType,
                                       &Semaphore);

    //
    // If the reference was successful, then read the current state and
    // maximum count of the semaphore object, dereference semaphore object,
    // fill in the information structure, and return the length of the
    // information structure if specified. If the write of the semaphore
    // information or the return length fails, then do not report an error.
    // When the caller accesses the information structure or length an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Count = KeReadStateSemaphore((PKSEMAPHORE)Semaphore);
        Maximum = ((PKSEMAPHORE)Semaphore)->Limit;
        ObDereferenceObject(Semaphore);

        SemaphoreInformation->CurrentCount = Count;
        SemaphoreInformation->MaximumCount = Maximum;
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtReleaseSemaphore (
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT PLONG PreviousCount OPTIONAL
    )

/*++

Routine Description:

    This function releases a semaphore object by adding the specified release
    count to the current value.

Arguments:

    Semaphore - Supplies a handle to a semaphore object.

    ReleaseCount - Supplies the release count that is to be added to the
        current semaphore count.

    PreviousCount - Supplies an optional pointer to a variable that will
        receive the previous semaphore count.

Return Value:

    TBS

--*/

{

    LONG Count;
    PVOID Semaphore;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if (ReleaseCount <= 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Reference semaphore object by handle.
    //

    Status = ObReferenceObjectByHandle(SemaphoreHandle,
                                       &ExSemaphoreObjectType,
                                       &Semaphore);

    //
    // If the reference was successful, then release the semaphore object.
    // If an exception occurs because the maximum count of the semaphore
    // has been exceeded, then dereference the semaphore object and return
    // the exception code as the service status. Otherwise write the previous
    // count value if specified. If the write of the previous count fails,
    // then do not report an error. When the caller attempts to access the
    // previous count value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        try {
            Count = KeReleaseSemaphore((PKSEMAPHORE)Semaphore,
                                       SEMAPHORE_INCREMENT,
                                       ReleaseCount,
                                       FALSE);
            ObDereferenceObject(Semaphore);
            if (ARGUMENT_PRESENT(PreviousCount)) {
                *PreviousCount = Count;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ObDereferenceObject(Semaphore);
            return GetExceptionCode();
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dm\xbdm\i386\thread.asm ===
title   "Thread start"
.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Thread start"

        extrn   _FStartThread@12:near

;++
;
; DmpThreadStartup
;
; Provided as the substitute thread system routine for xapi threads so that we
; can send the appropriate notifications
;
;--

cPublicProc _DmpThreadStartup, 2
cPublicFpo 0,0
        mov     ecx, [esp+4]            ; copy args
        mov     eax, [esp+8]
        push    eax                     ; make space for our data
        push    eax
        push    eax                     ; push the args again
        push    ecx
        lea     eax, [esp+8]
        push    eax
        call    _FStartThread@12
        pop     eax                     ; break if requested
        test    eax, eax
        jz      dts10
        int     3
dts10:
        pop     eax                     ; call the real start routine
        jmp     eax
; no return

stdENDP _DmpThreadStartup

;++
;
; CallOnStack
;
; Calls the requested function on a different stack
;
; Parameters:
;   [esp+4] - function to call
;   [esp+8] - new stack base
;   [esp+12] - pointer to argument block
;
;--

cPublicProc _CallOnStack, 3
        push    ebp                     ; build a frame link
        mov     ebp, esp
        push    esi
        push    edi
        mov     esi, [ebp+12]           ; prepare to switch stacks
        xor     eax, eax
        mov     edi, [esi]
        mov     [esi], eax              ; prevent recursion
        test    edi, edi                ; switch stacks only if non-NULL
        jz      cos10
        mov     esp, edi
cos10:
        mov     edx, [ebp+16]
        mov     eax, [ebp+8]
        push    edx
        call    eax                     ; call the new function
        mov     [esi], edi              ; restore the usable stack pointer
        lea     esp, [ebp-8]            ; unwind
        pop     edi
        pop     esi
        pop     ebp
        ret     12

stdENDP _CallOnStack

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\rwlock.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    rwlock.c

Abstract:

    This module implements routines to support executive reader/writer locks.

--*/

#include "exp.h"

VOID
ExInitializeReadWriteLock(
    IN PERWLOCK ReadWriteLock
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLOSE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    ReadWriteLock->LockCount = -1;
    ReadWriteLock->WritersWaitingCount = 0;
    ReadWriteLock->ReadersWaitingCount = 0;
    ReadWriteLock->ReadersEntryCount = 0;

    KeInitializeEvent(&ReadWriteLock->WriterEvent, SynchronizationEvent, FALSE);
    KeInitializeSemaphore(&ReadWriteLock->ReaderSemaphore, 0, MAXLONG);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\pool.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    pool.c

Abstract:

    This module implements the NT executive pool allocator.

--*/

#include "exp.h"

#pragma hdrstop

#undef ExAllocatePoolWithTag
#undef ExAllocatePool

//
// FREE_CHECK_KTIMER - If enabled causes each free pool to verify no
// active KTIMERs are in the pool block being freed.
//

#if DBG

#define FREE_CHECK_KTIMER(Va, NumberOfBytes) \
            KeCheckForTimer(Va, NumberOfBytes)

#else

#define FREE_CHECK_KTIMER(Va, NumberOfBytes)

#endif

//
// We redefine the LIST_ENTRY macros to have each pointer biased
// by one so any rogue code using these pointers will access
// violate.  See \nt\public\sdk\inc\ntrtl.h for the original
// definition of these macros.
//
// This is turned off in the shipping product.
//

#ifndef NO_POOL_CHECKS

ULONG ExpPoolBugCheckLine;

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) & ~1))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) |  1))

#define PrivateInitializeListHead(ListHead) (                     \
    (ListHead)->Flink = (ListHead)->Blink = EncodeLink(ListHead))

#define PrivateIsListEmpty(ListHead)              \
    (DecodeLink((ListHead)->Flink) == (ListHead))

#define PrivateRemoveHeadList(ListHead)                     \
    DecodeLink((ListHead)->Flink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Flink))}

#define PrivateRemoveTailList(ListHead)                     \
    DecodeLink((ListHead)->Blink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Blink))}

#define PrivateRemoveEntryList(Entry) {       \
    PLIST_ENTRY _EX_Blink;                    \
    PLIST_ENTRY _EX_Flink;                    \
    _EX_Flink = DecodeLink((Entry)->Flink);   \
    _EX_Blink = DecodeLink((Entry)->Blink);   \
    _EX_Blink->Flink = EncodeLink(_EX_Flink); \
    _EX_Flink->Blink = EncodeLink(_EX_Blink); \
    }

#define PrivateInsertTailList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Blink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    _EX_Blink = DecodeLink(_EX_ListHead->Blink); \
    (Entry)->Flink = EncodeLink(_EX_ListHead);   \
    (Entry)->Blink = EncodeLink(_EX_Blink);      \
    _EX_Blink->Flink = EncodeLink(Entry);        \
    _EX_ListHead->Blink = EncodeLink(Entry);     \
    }

#define PrivateInsertHeadList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Flink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    _EX_Flink = DecodeLink(_EX_ListHead->Flink); \
    (Entry)->Flink = EncodeLink(_EX_Flink);      \
    (Entry)->Blink = EncodeLink(_EX_ListHead);   \
    _EX_Flink->Blink = EncodeLink(Entry);        \
    _EX_ListHead->Flink = EncodeLink(Entry);     \
    }

#define CHECK_LIST(LINE,LIST,ENTRY)                                         \
    if ((DecodeLink(DecodeLink((LIST)->Flink)->Blink) != (LIST)) ||         \
        (DecodeLink(DecodeLink((LIST)->Blink)->Flink) != (LIST))) {         \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx (BAD_POOL_HEADER,                                  \
                          3,                                                \
                          (ULONG_PTR)LIST,                                  \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Flink)->Blink),     \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Blink)->Flink));    \
    }

#define CHECK_POOL_HEADER(LINE,ENTRY) {                                                 \
    PPOOL_HEADER PreviousEntry;                                                         \
    PPOOL_HEADER NextEntry;                                                             \
    if ((ENTRY)->PreviousSize != 0) {                                                   \
        PreviousEntry = (PPOOL_HEADER)((PPOOL_BLOCK)(ENTRY) - (ENTRY)->PreviousSize);   \
        if (PreviousEntry->BlockSize != (ENTRY)->PreviousSize) {                        \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx(BAD_POOL_HEADER, 5, (ULONG_PTR)PreviousEntry, LINE, (ULONG_PTR)ENTRY); \
        }                                                                               \
    }                                                                                   \
    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)(ENTRY) + (ENTRY)->BlockSize);              \
    if (!PAGE_END(NextEntry)) {                                                         \
        if (NextEntry->PreviousSize != (ENTRY)->BlockSize) {                            \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx(BAD_POOL_HEADER, 5, (ULONG_PTR)NextEntry, LINE, (ULONG_PTR)ENTRY);     \
        }                                                                               \
    }                                                                                   \
}

#define ASSERT_ALLOCATE_IRQL(_NumberOfBytes)                            \
    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                          \
        KeBugCheckEx (BAD_POOL_CALLER, 8, KeGetCurrentIrql(), 0, _NumberOfBytes);                                                            \
    }

#define ASSERT_FREE_IRQL(_P)                                            \
    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                          \
        KeBugCheckEx (BAD_POOL_CALLER, 9, KeGetCurrentIrql(), 0, (ULONG_PTR)P);                                                              \
    }

#define ASSERT_POOL_NOT_FREE(_Entry)                                    \
    if ((_Entry->PoolType & POOL_TYPE_MASK) == 0) {                     \
        KeBugCheckEx (BAD_POOL_CALLER, 6, __LINE__, (ULONG_PTR)_Entry, _Entry->Ulong1);                                                                 \
    }

#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)                               \
    if (_Entry->PoolType == 0) {                                        \
        KeBugCheckEx(BAD_POOL_CALLER, 1, (ULONG_PTR)_Entry, (ULONG_PTR)(*(PULONG)_Entry), 0);                                                           \
    }

#define CHECK_LOOKASIDE_LIST(LINE,LIST,ENTRY) {NOTHING;}

#else

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define PrivateInitializeListHead InitializeListHead
#define PrivateIsListEmpty        IsListEmpty
#define PrivateRemoveHeadList     RemoveHeadList
#define PrivateRemoveTailList     RemoveTailList
#define PrivateRemoveEntryList    RemoveEntryList
#define PrivateInsertTailList     InsertTailList
#define PrivateInsertHeadList     InsertHeadList

#define ASSERT_ALLOCATE_IRQL(_P)            {NOTHING;}
#define ASSERT_FREE_IRQL(_P)                {NOTHING;}
#define ASSERT_POOL_NOT_FREE(_Entry)        {NOTHING;}
#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)   {NOTHING;}

//
// The check list macros come in two flavors - there is one in the checked
// and free build that will bugcheck the system if a list is ill-formed, and
// there is one for the final shipping version that has all the checked
// disabled.
//
// The check lookaside list macros also comes in two flavors and is used to
// verify that the look aside lists are well formed.
//
// The check pool header macro (two flavors) verifies that the specified
// pool header matches the preceeding and succeeding pool headers.
//

#define CHECK_LIST(LINE,LIST,ENTRY)         {NOTHING;}
#define CHECK_POOL_HEADER(LINE,ENTRY)       {NOTHING;}

#define CHECK_LOOKASIDE_LIST(LINE,LIST,ENTRY) {NOTHING;}

#define CHECK_POOL_PAGE(PAGE) \
    {                                                                         \
        PPOOL_HEADER P = (PPOOL_HEADER)(((ULONG_PTR)(PAGE)) & ~(PAGE_SIZE-1));    \
        ULONG SIZE, LSIZE;                                                    \
        LOGICAL FOUND=FALSE;                                                  \
        LSIZE = 0;                                                            \
        SIZE = 0;                                                             \
        do {                                                                  \
            if (P == (PPOOL_HEADER)PAGE) {                                    \
                FOUND = TRUE;                                                 \
            }                                                                 \
            if (P->PreviousSize != LSIZE) {                                   \
                DbgPrint("POOL: Inconsistent size: ( %lx ) - %lx->%u != %u\n",\
                         PAGE, P, P->PreviousSize, LSIZE);                    \
                DbgBreakPoint();                                              \
            }                                                                 \
            LSIZE = P->BlockSize;                                             \
            SIZE += LSIZE;                                                    \
            P = (PPOOL_HEADER)((PPOOL_BLOCK)P + LSIZE);                       \
        } while ((SIZE < (PAGE_SIZE / POOL_SMALLEST_BLOCK)) &&                \
                 (PAGE_END(P) == FALSE));                                     \
        if ((PAGE_END(P) == FALSE) || (FOUND == FALSE)) {                     \
            DbgPrint("POOL: Inconsistent page: %lx\n",P);                     \
            DbgBreakPoint();                                                  \
        }                                                                     \
    }

#endif

#ifndef NO_POOL_TAG_TRACKING

#define MAX_TRACKER_TABLE   1025
#define MAX_BIGPAGE_TABLE   4096
// #define MAX_TRACKER_TABLE   5
// #define MAX_BIGPAGE_TABLE   4

ULONG FirstPrint;

PPOOL_TRACKER_TABLE PoolTrackTable;
SIZE_T PoolTrackTableSize;
SIZE_T PoolTrackTableMask;

PPOOL_TRACKER_BIG_PAGES PoolBigPageTable;
SIZE_T PoolBigPageTableSize;
SIZE_T PoolBigPageTableHash;

KSPIN_LOCK ExpTaggedPoolLock;

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T Size
    );

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN ULONG Size
    );

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages
    );

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va
    );

#endif

//
// Define macros to pack and unpack a pool index.
//

#define MARK_POOL_HEADER_ALLOCATED(POOLHEADER)      {(POOLHEADER)->PoolIndex = 0x80;}
#define MARK_POOL_HEADER_FREED(POOLHEADER)          {(POOLHEADER)->PoolIndex = 0;}
#define IS_POOL_HEADER_MARKED_ALLOCATED(POOLHEADER) ((POOLHEADER)->PoolIndex == 0x80)

//
// Pool descriptors for nonpaged pool and nonpaged pool must succeed are
// static.
//

POOL_DESCRIPTOR NonPagedPoolDescriptor;

//
// Define paged and nonpaged pool lookaside descriptors.
//

POOL_LOOKASIDE_LIST ExpSmallNPagedPoolLookasideLists[POOL_SMALL_LISTS];

//
// LOCK_POOL and UNLOCK_POOL are only used within this module.
//

#define LOCK_POOL(LockHandle) {                                                \
    LockHandle = KeRaiseIrqlToDpcLevel();                                      \
}

#define UNLOCK_POOL(LockHandle) {                                              \
    KeLowerIrql(LockHandle);                                                   \
}

VOID
InitializePool(
    VOID
    )
/*++

Routine Description:

    This procedure initializes a pool descriptor for the specified pool
    type.  Once initialized, the pool may be used for allocation and
    deallocation.

    This function should be called once for each base pool type during
    system initialization.

    Each pool descriptor contains an array of list heads for free
    blocks.  Each list head holds blocks which are a multiple of
    the POOL_BLOCK_SIZE.  The first element on the list [0] links
    together free entries of size POOL_BLOCK_SIZE, the second element
    [1] links together entries of POOL_BLOCK_SIZE * 2, the third
    POOL_BLOCK_SIZE * 3, etc, up to the number of blocks which fit
    into a page.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG Index;
    PPOOL_LOOKASIDE_LIST Lookaside;

#ifndef NO_POOL_TAG_TRACKING
    //
    // Initialize pool tracking data structures.
    //

    KeInitializeSpinLock (&ExpTaggedPoolLock);

    PoolTrackTableSize = MAX_TRACKER_TABLE;
    PoolTrackTableMask = PoolTrackTableSize - 2;
    PoolTrackTable = MmDbgAllocateMemory(PoolTrackTableSize *
        sizeof(POOL_TRACKER_TABLE), PAGE_READWRITE);

    RtlZeroMemory(PoolTrackTable, PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE));

    PoolBigPageTableSize = MAX_BIGPAGE_TABLE;
    PoolBigPageTableHash = PoolBigPageTableSize - 1;
    PoolBigPageTable = MmDbgAllocateMemory(PoolBigPageTableSize *
        sizeof(POOL_TRACKER_BIG_PAGES), PAGE_READWRITE);

    RtlZeroMemory(PoolBigPageTable, PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES));
#endif

    //
    // Initialize the nonpaged pool descriptor.
    //

    NonPagedPoolDescriptor.RunningAllocs = 0;
    NonPagedPoolDescriptor.RunningDeAllocs = 0;
    NonPagedPoolDescriptor.TotalPages = 0;
    NonPagedPoolDescriptor.TotalBigPages = 0;

    //
    // Initialize the allocation listheads.
    //

    for (Index = 0; Index < POOL_LIST_HEADS; Index += 1) {
        PrivateInitializeListHead(&NonPagedPoolDescriptor.ListHeads[Index]);
    }

    //
    // Initialize the nonpaged small pool lookaside structures,
    //

    for (Index = 0; Index < POOL_SMALL_LISTS; Index += 1) {
        Lookaside = &ExpSmallNPagedPoolLookasideLists[Index];
        Lookaside->ListHead.Alignment = 0;
        Lookaside->Depth = 2;
        Lookaside->TotalAllocates = 0;
        Lookaside->AllocateHits = 0;
    }
}

PVOID
ExAllocatePool(
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block.  This function is used to
    access both the page-aligned pools, and the list head entries (less than
    a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned
    pool allocator is used.  The allocated block will be page-aligned
    and a page-sized multiple.

    Otherwise, the appropriate pool list entry is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request.  If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split.  One piece is placed back into the pool, and
    the other piece is used to satisfy the request.  If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called.  The page is split and added
    to the pool...

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - Not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/
{
    return ExAllocatePoolWithTag(NumberOfBytes, 'enoN');
}

PVOID
ExAllocatePoolWithTag(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block. This function is used to
    access both the page-aligned pools and the list head entries (less
    than a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned pool
    allocator is used. The allocated block will be page-aligned and a
    page-sized multiple.

    Otherwise, the appropriate pool list entry is used. The allocated
    block will be 64-bit aligned, but will not be page aligned. The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request. If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split. One piece is placed back into the pool, and
    the other piece is used to satisfy the request. If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called. The page is split and added
    to the pool.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

    Tag - Supplies the caller's identifying tag.

Return Value:

    NULL - Not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/
{
    PVOID Block;
    PPOOL_HEADER Entry;
    PPOOL_LOOKASIDE_LIST LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_HEADER SplitEntry;
    KIRQL LockHandle;
    PPOOL_DESCRIPTOR PoolDesc = &NonPagedPoolDescriptor;
    ULONG Index;
    ULONG ListNumber;
    ULONG NeededSize;
    PLIST_ENTRY ListHead;
    ULONG NumberOfPages;

    ASSERT(NumberOfBytes != 0);
    ASSERT_ALLOCATE_IRQL(NumberOfBytes);

    //
    // Check to determine if the requested block can be allocated from one
    // of the pool lists or must be directly allocated from virtual memory.
    //

    if (NumberOfBytes > POOL_BUDDY_MAX) {

        //
        // The requested size is greater than the largest block maintained
        // by allocation lists.
        //

        LOCK_POOL(LockHandle);

        PoolDesc->RunningAllocs += 1;

        Entry = (PPOOL_HEADER) MmAllocatePoolPages (NumberOfBytes);

        if (Entry != NULL) {

            NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);
            PoolDesc->TotalBigPages += NumberOfPages;

            UNLOCK_POOL(LockHandle);

#ifndef NO_POOL_TAG_TRACKING
            if (PoolBigPageTable != NULL) {

                if (ExpAddTagForBigPages((PVOID)Entry,
                                         Tag,
                                         NumberOfPages) == FALSE) {
                    Tag = ' GIB';
                }

                ExpInsertPoolTracker (Tag,
                                      (ULONG) ROUND_TO_PAGES(NumberOfBytes));
            }
#endif

        } else {

            UNLOCK_POOL(LockHandle);

            KdPrint(("EX: ExAllocatePool (%p) returning NULL\n", NumberOfBytes));
        }

        return Entry;
    }

    //
    // The requested size is less than or equal to the size of the
    // maximum block maintained by the allocation lists.
    //

    //
    // Compute the Index of the listhead for blocks of the requested
    // size.
    //

    ListNumber = (ULONG)((NumberOfBytes + POOL_OVERHEAD + (POOL_SMALLEST_BLOCK - 1)) >> POOL_BLOCK_SHIFT);

    NeededSize = ListNumber;

    //
    // If the requested pool block is a small block, then attempt to
    // allocate the requested pool from the per processor lookaside
    // list. If the attempt fails, then attempt to allocate from the
    // system lookaside list. If the attempt fails, then select a
    // pool to allocate from and allocate the block normally.
    //

    if (NeededSize <= POOL_SMALL_LISTS) {
        LookasideList = &ExpSmallNPagedPoolLookasideLists[NeededSize - 1];
        LookasideList->TotalAllocates += 1;

        CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, 0);

        Entry = (PPOOL_HEADER)InterlockedPopEntrySList (&LookasideList->ListHead);

        if (Entry != NULL) {

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, Entry);

            Entry -= 1;
            LookasideList->AllocateHits += 1;

            Entry->PoolType = (UCHAR)1;
            MARK_POOL_HEADER_ALLOCATED(Entry);

            Entry->PoolTag = Tag;

#ifndef NO_POOL_TAG_TRACKING
            if (PoolTrackTable != NULL) {
                ExpInsertPoolTracker (Tag, Entry->BlockSize << POOL_BLOCK_SHIFT);
            }
#endif

            //
            // Zero out any back pointer to our internal structures
            // to stop someone from corrupting us via an
            // uninitialized pointer.
            //

            ((PULONG)((PCHAR)Entry + POOL_OVERHEAD))[0] = 0;

            return (PUCHAR)Entry + POOL_OVERHEAD;
        }
    }

    LOCK_POOL(LockHandle);

    //
    // The following code has an outer loop and an inner loop.
    //
    // The outer loop is utilized to repeat a nonpaged must succeed
    // allocation if necessary.
    //
    // The inner loop is used to repeat an allocation attempt if there
    // are no entries in any of the pool lists.
    //

    PoolDesc->RunningAllocs += 1;
    ListHead = &PoolDesc->ListHeads[ListNumber];

    do {

        //
        // Attempt to allocate the requested block from the current free
        // blocks.
        //

        do {

            //
            // If the list is not empty, then allocate a block from the
            // selected list.
            //

            if (PrivateIsListEmpty(ListHead) == FALSE) {

                CHECK_LIST( __LINE__, ListHead, 0 );
                Block = PrivateRemoveHeadList(ListHead);
                CHECK_LIST( __LINE__, ListHead, 0 );
                Entry = (PPOOL_HEADER)((PCHAR)Block - POOL_OVERHEAD);

                ASSERT(Entry->BlockSize >= NeededSize);

                ASSERT(Entry->PoolType == 0);

                if (Entry->BlockSize != NeededSize) {

                    //
                    // The selected block is larger than the allocation
                    // request. Split the block and insert the remaining
                    // fragment in the appropriate list.
                    //
                    // If the entry is at the start of a page, then take
                    // the allocation from the front of the block so as
                    // to minimize fragmentation. Otherwise, take the
                    // allocation from the end of the block which may
                    // also reduce fragmentation if the block is at the
                    // end of a page.
                    //

                    if (Entry->PreviousSize == 0) {

                        //
                        // The entry is at the start of a page.
                        //

                        SplitEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                        SplitEntry->BlockSize = (UCHAR)(Entry->BlockSize - (UCHAR)NeededSize);
                        SplitEntry->PreviousSize = (UCHAR)NeededSize;

                        //
                        // If the allocated block is not at the end of a
                        // page, then adjust the size of the next block.
                        //

                        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)SplitEntry + SplitEntry->BlockSize);
                        if (PAGE_END(NextEntry) == FALSE) {
                            NextEntry->PreviousSize = SplitEntry->BlockSize;
                        }

                    } else {

                        //
                        // The entry is not at the start of a page.
                        //

                        SplitEntry = Entry;
                        Entry->BlockSize -= (UCHAR)NeededSize;
                        Entry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
                        Entry->PreviousSize = SplitEntry->BlockSize;

                        //
                        // If the allocated block is not at the end of a
                        // page, then adjust the size of the next block.
                        //

                        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                        if (PAGE_END(NextEntry) == FALSE) {
                            NextEntry->PreviousSize = (UCHAR)NeededSize;
                        }
                    }

                    //
                    // Set the size of the allocated entry, clear the pool
                    // type of the split entry, set the index of the split
                    // entry, and insert the split entry in the appropriate
                    // free list.
                    //

                    Entry->BlockSize = (UCHAR)NeededSize;
                    SplitEntry->PoolType = 0;
                    Index = SplitEntry->BlockSize;

                    CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], 0);
                    PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));
                    CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], 0);
                    CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)), 0);
                }

                Entry->PoolType = (UCHAR)1;

                MARK_POOL_HEADER_ALLOCATED(Entry);

                CHECK_POOL_HEADER(__LINE__, Entry);

                UNLOCK_POOL(LockHandle);

                Entry->PoolTag = Tag;

#ifndef NO_POOL_TAG_TRACKING
                if (PoolTrackTable != NULL) {
                    ExpInsertPoolTracker (Tag,
                                          Entry->BlockSize << POOL_BLOCK_SHIFT);
                }
#endif

                //
                // Zero out any back pointer to our internal structures
                // to stop someone from corrupting us via an
                // uninitialized pointer.
                //

                ((PULONGLONG)((PCHAR)Entry + POOL_OVERHEAD))[0] = 0;

                return (PCHAR)Entry + POOL_OVERHEAD;
            }
            ListHead += 1;

        } while (ListHead != &PoolDesc->ListHeads[POOL_LIST_HEADS]);

        //
        // A block of the desired size does not exist and there are
        // no large blocks that can be split to satisfy the allocation.
        // Attempt to expand the pool by allocating another page to be
        // added to the pool.
        //

        Entry = (PPOOL_HEADER)MmAllocatePoolPages (PAGE_SIZE);

        if (Entry == NULL) {

            //
            // No more pool of the specified type is available.
            //

            KdPrint(("EX: ExAllocatePool (%p) returning NULL\n", NumberOfBytes));

            UNLOCK_POOL(LockHandle);

            return NULL;
        }

        //
        // Insert the allocated page in the last allocation list.
        //

        PoolDesc->TotalPages += 1;
        Entry->PoolType = 0;

        //
        // N.B. A byte is used to store the block size in units of the
        //      smallest block size. Therefore, if the number of small
        //      blocks in the page is greater than 255, the block size
        //      is set to 255.
        //

        if ((PAGE_SIZE / POOL_SMALLEST_BLOCK) > 255) {
            Entry->BlockSize = 255;

        } else {
            Entry->BlockSize = (UCHAR)(PAGE_SIZE / POOL_SMALLEST_BLOCK);
        }

        Entry->PreviousSize = 0;
        ListHead = &PoolDesc->ListHeads[POOL_LIST_HEADS - 1];

        CHECK_LIST(__LINE__, ListHead, 0);
        PrivateInsertHeadList(ListHead, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
        CHECK_LIST(__LINE__, ListHead, 0);
        CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), 0);

    } while (TRUE);
}

VOID
ExFreePool(
    IN PVOID P
    )
/*++

Routine Description:

    This function deallocates a block of pool. This function is used to
    deallocate to both the page aligned pools and the buddy (less than
    a page) pools.

    If the address of the block being deallocated is page-aligned, then
    the page-aligned pool deallocator is used.

    Otherwise, the binary buddy pool deallocator is used.  Deallocation
    looks at the allocated block's pool header to determine the pool
    type and block size being deallocated.  If the pool was allocated
    using ExAllocatePoolWithQuota, then after the deallocation is
    complete, the appropriate process's pool quota is adjusted to reflect
    the deallocation, and the process object is dereferenced.

Arguments:

    P - Supplies the address of the block of pool being deallocated.

Return Value:

    None.

--*/
{
    PPOOL_HEADER Entry;
    ULONG Index;
    KIRQL LockHandle;
    PPOOL_LOOKASIDE_LIST LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_DESCRIPTOR PoolDesc = &NonPagedPoolDescriptor;
    LOGICAL Combined;
    ULONG BigPages;
    ULONG Tag;

    //
    // If entry is page aligned, then call free block to the page aligned
    // pool. Otherwise, free the block to the allocation lists.
    //

    if (PAGE_ALIGNED(P)) {

        ASSERT_FREE_IRQL(P);

#ifndef NO_POOL_TAG_TRACKING
        if (PoolTrackTable != NULL) {
            Tag = ExpFindAndRemoveTagBigPages(P);
        }
#endif

        LOCK_POOL(LockHandle);

        PoolDesc->RunningDeAllocs += 1;

        BigPages = MmFreePoolPages(P);

#ifndef NO_POOL_TAG_TRACKING
        if (PoolTrackTable != NULL) {
            ExpRemovePoolTracker(Tag, BigPages * PAGE_SIZE);
        }
#endif

        //
        // Check if a KTIMER is currently active in this memory block
        //

        FREE_CHECK_KTIMER(P, BigPages << PAGE_SHIFT);

        PoolDesc->TotalBigPages -= BigPages;

        UNLOCK_POOL(LockHandle);

        return;
    }

    //
    // Align the entry address to a pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

    ASSERT_POOL_NOT_FREE(Entry);

    ASSERT_FREE_IRQL(P);

    if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
        KeBugCheckEx (BAD_POOL_CALLER, 7, __LINE__, (ULONG_PTR)Entry, (ULONG_PTR)P);
    }

    MARK_POOL_HEADER_FREED(Entry);

    ASSERT_POOL_TYPE_NOT_ZERO(Entry);

    //
    // Check if a KTIMER is currently active in this memory block.
    //

    FREE_CHECK_KTIMER(Entry, (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));

#ifndef NO_POOL_TAG_TRACKING
    //
    // If pool tagging is enabled, then update the pool tracking database.
    //

    if (PoolTrackTable != NULL) {
        Tag = Entry->PoolTag;
        ExpRemovePoolTracker(Tag, Entry->BlockSize << POOL_BLOCK_SHIFT);
    }
#endif

    //
    // If the pool block is a small block, then attempt to free the block
    // to the single entry lookaside list. If the free attempt fails, then
    // free the block by merging it back into the pool data structures.
    //

    Index = Entry->BlockSize;

    if (Index <= POOL_SMALL_LISTS) {

        //
        // Attempt to free the small block to a per processor lookaside
        // list.
        //

        LookasideList = &ExpSmallNPagedPoolLookasideLists[Index - 1];

        CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

        if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
            Entry += 1;
            InterlockedPushEntrySList(&LookasideList->ListHead,
                                      (PSINGLE_LIST_ENTRY)Entry);

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

            return;
        }
    }

    LOCK_POOL(LockHandle);

    CHECK_POOL_HEADER(__LINE__, Entry);

    PoolDesc->RunningDeAllocs += 1;

    //
    // Free the specified pool block.
    //
    // Check to see if the next entry is free.
    //

    Combined = FALSE;
    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
    if (PAGE_END(NextEntry) == FALSE) {

        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)), P);
            PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink), P);
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink), P);

            Entry->BlockSize += NextEntry->BlockSize;
        }
    }

    //
    // Check to see if the previous entry is free.
    //

    if (Entry->PreviousSize != 0) {
        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)), P);
            PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink), P);
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink), P);

            NextEntry->BlockSize += Entry->BlockSize;
            Entry = NextEntry;
        }
    }

    //
    // If the block being freed has been combined into a full page,
    // then return the free page to memory management.
    //

    if (PAGE_ALIGNED(Entry) &&
        (PAGE_END((PPOOL_BLOCK)Entry + Entry->BlockSize) != FALSE)) {

        MmFreePoolPages(Entry);

        PoolDesc->TotalPages -= 1;

    } else {

        //
        // Insert this element into the list.
        //

        Entry->PoolType = 0;
        Index = Entry->BlockSize;

        //
        // If the freed block was combined with any other block, then
        // adjust the size of the next block if necessary.
        //

        if (Combined != FALSE) {

            //
            // The size of this entry has changed, if this entry is
            // not the last one in the page, update the pool block
            // after this block to have a new previous allocation size.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
            if (PAGE_END(NextEntry) == FALSE) {
                NextEntry->PreviousSize = Entry->BlockSize;
            }

            //
            // Reduce fragmentation and insert at the tail in hopes
            // neighbors for this will be freed before this is reallocated.
            //

            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), P);

        } else {

            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            PrivateInsertHeadList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), P);
        }
    }

    UNLOCK_POOL(LockHandle);
}

ULONG
ExQueryPoolBlockSize (
    IN PVOID PoolBlock
    )
/*++

Routine Description:

    This function returns the size of the pool block.

Arguments:

    PoolBlock - Supplies the address of the block of pool.

Return Value:

    Size of pool block.

--*/
{
    PPOOL_HEADER Entry;
    ULONG size;

    if (PAGE_ALIGNED(PoolBlock)) {
        return MmQueryAllocationSize(PoolBlock);
    }

    //
    // Align entry on pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)PoolBlock - POOL_OVERHEAD);
    size = (ULONG)((Entry->BlockSize << POOL_BLOCK_SHIFT) - POOL_OVERHEAD);

    return size;
}

#ifndef NO_POOL_TAG_TRACKING

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T Size
    )
/*++

Routine Description:

    This function inserts a pool tag in the tag table and increments the
    number of allocates and updates the total allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    Size - Supplies the allocation size.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

--*/
{
    ULONG Hash;
    ULONG OriginalKey;
    ULONG OriginalHash;
    ULONG Index;
    KIRQL OldIrql;
    ULONG BigPages;
    LOGICAL HashedIt;
    SIZE_T NewSize;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    SIZE_T NewSizeMask;
    PPOOL_TRACKER_TABLE OldTable;
    PPOOL_TRACKER_TABLE NewTable;

retry:

    //
    // Compute hash index and search for pool tag.
    //

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    Hash = ((40543*((((((((PUCHAR)&Key)[0]<<2)^((PUCHAR)&Key)[1])<<2)^((PUCHAR)&Key)[2])<<2)^((PUCHAR)&Key)[3]))>>2) & (ULONG)PoolTrackTableMask;
    Index = Hash;

    do {
        if (PoolTrackTable[Hash].Key == Key) {
            PoolTrackTable[Hash].Key = Key;
            goto EntryFound;
        }

        if (PoolTrackTable[Hash].Key == 0 && Hash != PoolTrackTableSize - 1) {
            PoolTrackTable[Hash].Key = Key;
            goto EntryFound;
        }

        Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;
    } while (Hash != Index);

    //
    // No matching entry and no free entry was found.
    // If the overflow bucket has been used then expansion of the tracker table
    // is not allowed because a subsequent free of a tag can go negative as the
    // original allocation is in overflow and a newer allocation may be
    // distinct.
    //

    NewSize = ((PoolTrackTableSize - 1) << 1) + 1;
    NewSizeInBytes = NewSize * sizeof(POOL_TRACKER_TABLE);

    SizeInBytes = PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE);

    if ((NewSizeInBytes > SizeInBytes) &&
        (PoolTrackTable[PoolTrackTableSize - 1].Key == 0)) {

        NewTable = MmDbgAllocateMemory (NewSizeInBytes, PAGE_READWRITE);

        if (NewTable != NULL) {

            OldTable = (PVOID)PoolTrackTable;

            KdPrint(("POOL:grew track table (%p, %p, %p)\n",
                OldTable,
                PoolTrackTableSize,
                NewTable));

            RtlZeroMemory ((PVOID)NewTable, NewSizeInBytes);

            //
            // Rehash all the entries into the new table.
            //

            NewSizeMask = NewSize - 2;

            for (OriginalHash = 0; OriginalHash < PoolTrackTableSize; OriginalHash += 1) {
                OriginalKey = PoolTrackTable[OriginalHash].Key;

                if (OriginalKey == 0) {
                    continue;
                }

                Hash = (ULONG)((40543*((((((((PUCHAR)&OriginalKey)[0]<<2)^((PUCHAR)&OriginalKey)[1])<<2)^((PUCHAR)&OriginalKey)[2])<<2)^((PUCHAR)&OriginalKey)[3]))>>2) & (ULONG)NewSizeMask;
                Index = Hash;

                HashedIt = FALSE;
                do {
                    if (NewTable[Hash].Key == 0 && Hash != NewSize - 1) {
                        RtlCopyMemory ((PVOID)&NewTable[Hash],
                                       (PVOID)&PoolTrackTable[OriginalHash],
                                       sizeof(POOL_TRACKER_TABLE));
                        HashedIt = TRUE;
                        break;
                    }

                    Hash = (Hash + 1) & (ULONG)NewSizeMask;
                } while (Hash != Index);

                //
                // No matching entry and no free entry was found, have to bail.
                //

                if (HashedIt == FALSE) {
                    KdPrint(("POOL:rehash of track table failed (%p, %p, %p %p)\n",
                        OldTable,
                        PoolTrackTableSize,
                        NewTable,
                        OriginalKey));

                    MmDbgFreeMemory (NewTable, 0);
                    goto overflow;
                }
            }

            PoolTrackTable = NewTable;
            PoolTrackTableSize = NewSize;
            PoolTrackTableMask = NewSizeMask;

            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

            BigPages = MmDbgFreeMemory (OldTable, 0);

            goto retry;
        }
    }

overflow:

    //
    // Use the very last entry as a bit bucket for overflows.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

    PoolTrackTable[Hash].Key = 'lfvO';

    //
    // Update pool tracker table entry.
    //

EntryFound:

    PoolTrackTable[Hash].NonPagedAllocs += 1;
    PoolTrackTable[Hash].NonPagedBytes += Size;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return;
}

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN ULONG Size
    )
/*++

Routine Description:

    This function increments the number of frees and updates the total
    allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    Size - Supplies the allocation size.

Return Value:

    None.

--*/
{
    ULONG Hash;
    ULONG Index;
    KIRQL OldIrql;

    //
    // Compute hash index and search for pool tag.
    //

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    Hash = ((40543*((((((((PUCHAR)&Key)[0]<<2)^((PUCHAR)&Key)[1])<<2)^((PUCHAR)&Key)[2])<<2)^((PUCHAR)&Key)[3]))>>2) & (ULONG)PoolTrackTableMask;
    Index = Hash;

    do {
        if (PoolTrackTable[Hash].Key == Key) {
            goto EntryFound;
        }

        if (PoolTrackTable[Hash].Key == 0 && Hash != PoolTrackTableSize - 1) {
            KdPrint(("POOL: Unable to find tracker %lx, table corrupted\n", Key));
            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
            return;
        }

        Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;
    } while (Hash != Index);

    //
    // No matching entry and no free entry was found.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

    //
    // Update pool tracker table entry.
    //

EntryFound:

    PoolTrackTable[Hash].NonPagedBytes -= Size;
    PoolTrackTable[Hash].NonPagedFrees += 1;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return;
}

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages
    )
/*++

Routine Description:

    This function inserts a pool tag in the big page tag table.

Arguments:

    Va - Supplies the allocated virtual address.

    Key - Supplies the key value used to locate a matching entry in the
        tag table.

    NumberOfPages - Supplies the number of pages that were allocated.

Return Value:

    TRUE if an entry was allocated, FALSE if not.

Environment:

    No pool locks held so the table may be freely expanded here as needed.

--*/
{
    ULONG Hash;
    ULONG BigPages;
    PVOID OldTable;
    LOGICAL Inserted;
    KIRQL OldIrql;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    PPOOL_TRACKER_BIG_PAGES NewTable;
    PPOOL_TRACKER_BIG_PAGES p;

retry:

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);
    while ((LONG_PTR)PoolBigPageTable[Hash].Va < 0) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {

                //
                // Try to expand the tracker table.
                //

                SizeInBytes = PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES);
                NewSizeInBytes = (SizeInBytes << 1);

                if (NewSizeInBytes > SizeInBytes) {
                    NewTable = MmDbgAllocateMemory (NewSizeInBytes, PAGE_READWRITE);

                    if (NewTable != NULL) {
    
                        OldTable = (PVOID)PoolBigPageTable;

                        KdPrint(("POOL:grew big table (%p, %p, %p)\n",
                            OldTable,
                            PoolBigPageTableSize,
                            NewTable));

                        RtlCopyMemory ((PVOID)NewTable,
                                       OldTable,
                                       SizeInBytes);

                        RtlZeroMemory ((PVOID)(NewTable + PoolBigPageTableSize),
                                       NewSizeInBytes - SizeInBytes);

                        PoolBigPageTable = NewTable;
                        PoolBigPageTableSize <<= 1;
                        PoolBigPageTableHash = PoolBigPageTableSize - 1;

                        ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

                        BigPages = MmDbgFreeMemory (OldTable, 0);

                        goto retry;
                    }
                }

                if (!FirstPrint) {
                    KdPrint(("POOL:unable to insert big page slot %lx\n",Key));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
                return FALSE;
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    p = &PoolBigPageTable[Hash];

    ASSERT ((LONG_PTR)Va < 0);

    p->Va = Va;
    p->Key = Key;
    p->NumberOfPages = NumberOfPages;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return TRUE;
}

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va
    )
{
    ULONG Hash;
    LOGICAL Inserted;
    KIRQL OldIrql;
    ULONG ReturnKey;

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);
    while (PoolBigPageTable[Hash].Va != Va) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {
                if (!FirstPrint) {
                    KdPrint(("POOL:unable to find big page slot %lx\n",Va));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
                return ' GIB';
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    ASSERT ((LONG_PTR)Va < 0);
    (ULONG_PTR)PoolBigPageTable[Hash].Va &= MAXLONG_PTR;

    ReturnKey = PoolBigPageTable[Hash].Key;
    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
    return ReturnKey;
}

#endif // NO_POOL_TAG_TRACKING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\event.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    event.c

Abstract:

    This module implements the executive event object. Functions are provided
    to create, open, set, reset, pulse, and query event objects.

--*/

#include "exp.h"

//
// Event object type information.
//

DECLSPEC_RDATA OBJECT_TYPE ExEventObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    NULL,
    (PVOID)FIELD_OFFSET(KEVENT, Header),
    'vevE'
};

NTSTATUS
NtClearEvent (
    IN HANDLE EventHandle
    )

/*++

Routine Description:

    This function sets an event object to a Not-Signaled state.

Arguments:

    EventHandle - Supplies a handle to an event object.

Return Value:

    TBS

--*/

{

    PVOID Event;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       &ExEventObjectType,
                                       &Event);

    //
    // If the reference was successful, then set the state of the event
    // object to Not-Signaled and dereference event object.
    //

    if (NT_SUCCESS(Status)) {
        KeClearEvent((PKEVENT)Event);
        ObDereferenceObject(Event);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtCreateEvent (
    OUT PHANDLE EventHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    )

/*++

Routine Description:

    This function creates an event object, sets it initial state to the
    specified value, and opens a handle to the object with the specified
    desired access.

Arguments:

    EventHandle - Supplies a pointer to a variable that will receive the
        event object handle.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    EventType - Supplies the type of the event (autoclearing or notification).

    InitialState - Supplies the initial state of the event object.

Return Value:

    TBS

--*/

{

    PVOID Event;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if ((EventType != NotificationEvent) && (EventType != SynchronizationEvent)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate event object.
    //

    Status = ObCreateObject(&ExEventObjectType,
                            ObjectAttributes,
                            sizeof(KEVENT),
                            (PVOID *)&Event);

    //
    // If the event object was successfully allocated, then initialize the
    // event object and attempt to insert the event object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeEvent((PKEVENT)Event, EventType, InitialState);
        Status = ObInsertObject(Event,
                                ObjectAttributes,
                                0,
                                EventHandle);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtPulseEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state, attempts to
    satisfy as many waits as possible, and then resets the state of the
    event object to Not-Signaled.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    TBS

--*/

{

    PVOID Event;
    LONG State;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       &ExEventObjectType,
                                       &Event);

    //
    // If the reference was successful, then pulse the event object,
    // dereference event object, and write the previous state value if
    // specified. If the write of the previous state fails, then do not
    // report an error. When the caller attempts to access the previous
    // state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KePulseEvent((PKEVENT)Event, EVENT_INCREMENT, FALSE);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            *PreviousState = State;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryEvent (
    IN HANDLE EventHandle,
    OUT PEVENT_BASIC_INFORMATION EventInformation
    )

/*++

Routine Description:

    This function queries the state of an event object and returns the
    requested information in the specified record structure.

Arguments:

    EventHandle - Supplies a handle to an event object.

    EventInformation - Supplies a pointer to a record that is to receive the
        requested information.

Return Value:

    TBS

--*/

{

    PKEVENT Event;
    LONG State;
    NTSTATUS Status;
    EVENT_TYPE EventType;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       &ExEventObjectType,
                                       (PVOID *)&Event);

    //
    // If the reference was successful, then read the current state of
    // the event object, deference event object, fill in the information
    // structure, and return the length of the information structure if
    // specified. If the write of the event information or the return
    // length fails, then do not report an error. When the caller accesses
    // the information structure or length an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KeReadStateEvent(Event);
        EventType = Event->Header.Type;
        ObDereferenceObject(Event);

        EventInformation->EventType = EventType;
        EventInformation->EventState = State;
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtResetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Not-Signaled state.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    TBS

--*/

{

    PVOID Event;
    LONG State;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       &ExEventObjectType,
                                       &Event);

    //
    // If the reference was successful, then set the state of the event
    // object to Not-Signaled, dereference event object, and write the
    // previous state value if specified. If the write of the previous
    // state fails, then do not report an error. When the caller attempts
    // to access the previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KeResetEvent((PKEVENT)Event);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            *PreviousState = State;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state and attempts to
    satisfy as many waits as possible.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    TBS

--*/

{

    PVOID Event;
    LONG State;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       &ExEventObjectType,
                                       &Event);

    //
    // If the reference was successful, then set the event object to the
    // Signaled state, dereference event object, and write the previous
    // state value if specified. If the write of the previous state fails,
    // then do not report an error. When the caller attempts to access the
    // previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KeSetEvent((PKEVENT)Event, EVENT_INCREMENT, FALSE);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            *PreviousState = State;
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\timer.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module implements the executive timer object. Functions are provided
    to create, open, cancel, set, and query timer objects.

--*/

#include "exp.h"

//
// Define private function prototypes.
//

VOID
ExpDeleteTimer (
    IN PVOID Object
    );

//
// Timer object type information.
//

DECLSPEC_RDATA OBJECT_TYPE ExTimerObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    ExpDeleteTimer,
    NULL,
    (PVOID)FIELD_OFFSET(KTIMER, Header),
    'emiT'
};

//
// Executive timer object structure definition.
//

typedef struct _ETIMER {
    KTIMER KeTimer;
    KAPC TimerApc;
    KDPC TimerDpc;
    LIST_ENTRY ActiveTimerListEntry;
    LONG Period;
    BOOLEAN ApcAssociated;
} ETIMER, *PETIMER;

//
// Define macros to lock and unlock the various timer lists.
//

#define ExpAcquireTimerLock(TIMER, OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

#define ExpReleaseTimerLock(TIMER, OldIrql) \
    KeLowerIrql(OldIrql)

#define ExpAcquireThreadActiveTimerListLock(THREAD, OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

#define ExpReleaseThreadActiveTimerListLock(THREAD, OldIrql) \
    KeLowerIrql(OldIrql)

#define ExpAcquireThreadActiveTimerListLockAtDpcLevel(THREAD) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

#define ExpReleaseThreadActiveTimerListLockFromDpcLevel(THREAD)

VOID
ExpTimerApcRoutine (
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function is the special APC routine that is called to remove
    a timer from the current thread's active timer list.

Arguments:

    Apc - Supplies a pointer to the APC object used to invoke this routine.

    NormalRoutine - Supplies a pointer to a pointer to the normal routine
        function that was specified when the APC was initialized.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to
        two arguments that contain untyped data.

Return Value:

    None.

--*/

{

    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    KIRQL OldIrql;

    //
    // Get address of executive timer object and the current thread object.
    //

    ExThread = PsGetCurrentThread();
    ExTimer = CONTAINING_RECORD(Apc, ETIMER, TimerApc);

    //
    // If the timer is still in the current thread's active timer list, then
    // remove it if it is not a periodic timer and set APC associated FALSE.
    // It is possible for the timer not to be in the current thread's active
    // timer list since the APC could have been delivered, and then another
    // thread could have set the timer again with another APC. This would
    // have caused the timer to be removed from the current thread's active
    // timer list.
    //
    // N. B. The spin locks for the timer and the active timer list must be
    //  acquired in the order: 1) timer lock, 2) thread list lock.
    //

    Dereference = FALSE;
    ExpAcquireTimerLock(ExTimer, &OldIrql);
    ExpAcquireThreadActiveTimerListLockAtDpcLevel(ExThread);
    if ((ExTimer->ApcAssociated) && (&ExThread->Tcb == ExTimer->TimerApc.Thread)) {
        if (ExTimer->Period == 0) {
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            Dereference = TRUE;
        }

    } else {
        *NormalRoutine = (PKNORMAL_ROUTINE)NULL;
    }

    ExpReleaseThreadActiveTimerListLockFromDpcLevel(ExThread);
    ExpReleaseTimerLock(ExTimer, OldIrql);
    if (Dereference) {
        ObDereferenceObject((PVOID)ExTimer);
    }

    return;
}

VOID
ExpTimerDpcRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is the DPC routine that is called when a timer expires that
    has an associated APC routine. Its function is to insert the associated
    APC into the target thread's APC queue.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Supplies a pointer to the executive timer that contains
        the DPC that caused this routine to be executed.

    SystemArgument1, SystemArgument2 - Supplies values that are not used by
        this routine.

Return Value:

    None.

--*/

{

    PETIMER ExTimer;
    PKTIMER KeTimer;
    KIRQL OldIrql;

    //
    // Get address of executive and kernel timer objects.
    //

    ExTimer = (PETIMER)DeferredContext;
    KeTimer = &ExTimer->KeTimer;

    //
    // If there is still an APC associated with the timer, then insert the APC
    // in target thread's APC queue. It is possible that the timer does not
    // have an associated APC. This can happen when the timer is set to expire
    // by a thread running on another processor just after the DPC has been
    // removed from the DPC queue, but before it has acquired the timer related
    // spin lock.
    //

    ExpAcquireTimerLock(ExTimer, &OldIrql);
    if (ExTimer->ApcAssociated) {
        KeInsertQueueApc(&ExTimer->TimerApc,
                         SystemArgument1,
                         SystemArgument2,
                         TIMER_APC_INCREMENT);
    }

    ExpReleaseTimerLock(ExTimer, OldIrql);
    return;
}

VOID
ExpDeleteTimer (
    IN PVOID Object
    )

/*++

Routine Description:

    This function is the delete routine for timer objects. Its function is
    to cancel the timer and free the spin lock associated with a timer.

Arguments:

    Object - Supplies a pointer to an executive timer object.

Return Value:

    None.

--*/

{
    PETIMER     ExTimer;

    ExTimer = (PETIMER) Object;

    //
    // Cancel the timer and free the spin lock associated with the timer.
    //

    KeCancelTimer(&ExTimer->KeTimer);
    return;
}

VOID
ExTimerRundown (
    )

/*++

Routine Description:

    This function is called when a thread is about to be terminated to
    process the active timer list. It is assumed that APC's have been
    disabled for the subject thread, thus this code cannot be interrupted
    to execute an APC for the current thread.

Arguments:

    None.

Return Value:

    None.

--*/

{

    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;

    //
    // Process each entry in the active timer list.
    //

    ExThread = PsGetCurrentThread();
    ExpAcquireThreadActiveTimerListLock(ExThread, &OldIrql);
    NextEntry = ExThread->ActiveTimerListHead.Flink;
    while (NextEntry != &ExThread->ActiveTimerListHead) {
        ExTimer = CONTAINING_RECORD(NextEntry, ETIMER, ActiveTimerListEntry);

        //
        // Increment the reference count on the object so that it cannot be
        // deleted, and then drop the active timer list lock.
        //
        // N. B. The object reference cannot fail and will acquire no mutexes.
        //

        ObReferenceObject(ExTimer);
        ExpReleaseThreadActiveTimerListLock(ExThread, OldIrql);

        //
        // Acquire the timer spin lock and reacquire the active time list spin
        // lock. If the timer is still in the current thread's active timer
        // list, then cancel the timer, remove the timer's DPC from the DPC
        // queue, remove the timer's APC from the APC queue, remove the timer
        // from the thread's active timer list, and set the associate APC
        // flag FALSE.
        //
        // N. B. The spin locks for the timer and the active timer list must be
        //  acquired in the order: 1) timer lock, 2) thread list lock.
        //

        ExpAcquireTimerLock(ExTimer, &OldIrql);
        ExpAcquireThreadActiveTimerListLockAtDpcLevel(ExThread);
        if ((ExTimer->ApcAssociated) && (&ExThread->Tcb == ExTimer->TimerApc.Thread)) {
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            KeRemoveQueueApc(&ExTimer->TimerApc);
            Dereference = TRUE;

        } else {
            Dereference = FALSE;
        }

        ExpReleaseThreadActiveTimerListLockFromDpcLevel(ExThread);
        ExpReleaseTimerLock(ExTimer, OldIrql);
        if (Dereference) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        ObDereferenceObject((PVOID)ExTimer);

        //
        // Raise IRQL to DISPATCH_LEVEL and reacquire active timer list
        // spin lock.
        //

        ExpAcquireThreadActiveTimerListLock(ExThread, &OldIrql);
        NextEntry = ExThread->ActiveTimerListHead.Flink;
    }

    ExpReleaseThreadActiveTimerListLock(ExThread, OldIrql);
    return;
}

NTSTATUS
NtCreateTimer (
    OUT PHANDLE TimerHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    )

/*++

Routine Description:

    This function creates an timer object and opens a handle to the object with
    the specified desired access.

Arguments:

    TimerHandle - Supplies a pointer to a variable that will receive the
        timer object handle.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    TimerType - Supplies the type of the timer (autoclearing or notification).

Return Value:

    TBS

--*/

{

    PETIMER ExTimer;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if ((TimerType != NotificationTimer) &&
        (TimerType != SynchronizationTimer)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate timer object.
    //

    Status = ObCreateObject(&ExTimerObjectType,
                            ObjectAttributes,
                            sizeof(ETIMER),
                            (PVOID *)&ExTimer);

    //
    // If the timer object was successfully allocated, then initialize the
    // timer object and attempt to insert the time object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeDpc(&ExTimer->TimerDpc,
                        ExpTimerDpcRoutine,
                        (PVOID)ExTimer);

        KeInitializeTimerEx(&ExTimer->KeTimer, TimerType);
        ExTimer->ApcAssociated = FALSE;
        Status = ObInsertObject((PVOID)ExTimer,
                                ObjectAttributes,
                                0,
                                TimerHandle);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    )

/*++

Routine Description:

    This function cancels a timer object.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    CurrentState - Supplies an optional pointer to a variable that will
        receive the current state of the timer object.

Return Value:

    TBS

--*/

{

    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    KIRQL OldIrql;
    BOOLEAN State;
    NTSTATUS Status;

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       &ExTimerObjectType,
                                       (PVOID *)&ExTimer);

    //
    // If the reference was successful, then cancel the timer object,
    // dereference the timer object, and write the current state value
    // if specified. If the write attempt fails, then do not report an
    // error. When the caller attempts to access the current state value,
    // an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        ExpAcquireTimerLock(ExTimer, &OldIrql);
        if (ExTimer->ApcAssociated) {
            ExThread = CONTAINING_RECORD(ExTimer->TimerApc.Thread, ETHREAD, Tcb);
            ExpAcquireThreadActiveTimerListLockAtDpcLevel(ExThread);
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            ExpReleaseThreadActiveTimerListLockFromDpcLevel(ExThread);
            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            KeRemoveQueueApc(&ExTimer->TimerApc);
            Dereference = TRUE;

        } else {
            KeCancelTimer(&ExTimer->KeTimer);
            Dereference = FALSE;
        }

        ExpReleaseTimerLock(ExTimer, OldIrql);
        if (Dereference) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        //
        // Read current state of timer, dereference timer object, and set
        // current state.
        //

        State = KeReadStateTimer(&ExTimer->KeTimer);
        ObDereferenceObject(ExTimer);
        if (ARGUMENT_PRESENT(CurrentState)) {
            *CurrentState = State;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryTimer (
    IN HANDLE TimerHandle,
    OUT PTIMER_BASIC_INFORMATION TimerInformation
    )

/*++

Routine Description:

    This function queries the state of an timer object and returns the
    requested information in the specified record structure.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    TimerInformation - Supplies a pointer to a record that is to receive the
        requested information.

Return Value:

    TBS

--*/

{

    PETIMER ExTimer;
    PKTIMER KeTimer;
    BOOLEAN State;
    NTSTATUS Status;
    LARGE_INTEGER TimeToGo;

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       &ExTimerObjectType,
                                       (PVOID *)&ExTimer);

    //
    // If the reference was successful, then read the current state,
    // compute the time remaining, dereference the timer object, fill in
    // the information structure, and return the length of the information
    // structure if specified. If the write of the time information or the
    // return length fails, then do not report an error. When the caller
    // accesses the information structure or the length, an violation will
    // occur.
    //

    if (NT_SUCCESS(Status)) {
        KeTimer = &ExTimer->KeTimer;
        State = KeReadStateTimer(KeTimer);
        KiQueryInterruptTime(&TimeToGo);
        TimeToGo.QuadPart = KeTimer->DueTime.QuadPart - TimeToGo.QuadPart;
        ObDereferenceObject(ExTimer);

        TimerInformation->TimerState = State;
        TimerInformation->RemainingTime = TimeToGo;
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetTimerEx (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN KPROCESSOR_MODE ApcMode,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN WakeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an timer object to a Not-Signaled state and sets the timer
    to expire at the specified time.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    DueTime - Supplies a pointer to absolute of relative time at which the
        timer is to expire.

    TimerApcRoutine - Supplies an optional pointer to a function which is to
        be executed when the timer expires. If this parameter is not specified,
        then the TimerContext parameter is ignored.

    TimerContext - Supplies an optional pointer to an arbitrary data structure
        that will be passed to the function specified by the TimerApcRoutine
        parameter. This parameter is ignored if the TimerApcRoutine parameter
        is not specified.

    WakeTimer - Supplies a boolean value that specifies whether the timer
        wakes computer operation if sleeping

    Period - Supplies an optional repetitive period for the timer.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the timer object.

Return Value:

    TBS

--*/

{

    BOOLEAN AssociatedApc;
    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    LARGE_INTEGER ExpirationTime;
    KIRQL OldIrql;
    BOOLEAN State;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if (Period < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Capture the expiration time.
    //

    ExpirationTime = *DueTime;

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       &ExTimerObjectType,
                                       (PVOID *)&ExTimer);

    //
    // If this WakeTimer flag is set, return the appropiate informational
    // success status code.
    //

    if (NT_SUCCESS(Status) && WakeTimer) {
        Status = STATUS_TIMER_RESUME_IGNORED;
    }

    //
    // If the reference was successful, then cancel the timer object, set
    // the timer object, dereference time object, and write the previous
    // state value if specified. If the write of the previous state value
    // fails, then do not report an error. When the caller attempts to
    // access the previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        ExpAcquireTimerLock(ExTimer, &OldIrql);

        if (ExTimer->ApcAssociated) {
            ExThread = CONTAINING_RECORD(ExTimer->TimerApc.Thread, ETHREAD, Tcb);
            ExpAcquireThreadActiveTimerListLockAtDpcLevel(ExThread);
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            ExpReleaseThreadActiveTimerListLockFromDpcLevel(ExThread);
            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            KeRemoveQueueApc(&ExTimer->TimerApc);
            Dereference = TRUE;

        } else {
            KeCancelTimer(&ExTimer->KeTimer);
            Dereference = FALSE;
        }

        //
        // Read the current state of the timer.
        //

        State = KeReadStateTimer(&ExTimer->KeTimer);

        //
        // If an APC routine is specified, then initialize the APC, acquire the
        // thread's active time list lock, insert the timer in the thread's
        // active timer list, set the timer with an associated DPC, and set the
        // associated APC flag TRUE. Otherwise set the timer without an associated
        // DPC, and set the associated APC flag FALSE.
        //

        ExTimer->Period = Period;
        if (ARGUMENT_PRESENT(TimerApcRoutine)) {
            ExThread = PsGetCurrentThread();
            KeInitializeApc(&ExTimer->TimerApc,
                            &ExThread->Tcb,
                            ExpTimerApcRoutine,
                            (PKRUNDOWN_ROUTINE)NULL,
                            (PKNORMAL_ROUTINE)TimerApcRoutine,
                            ApcMode,
                            TimerContext);

            ExpAcquireThreadActiveTimerListLockAtDpcLevel(ExThread);
            InsertTailList(&ExThread->ActiveTimerListHead,
                           &ExTimer->ActiveTimerListEntry);

            ExTimer->ApcAssociated = TRUE;
            ExpReleaseThreadActiveTimerListLockFromDpcLevel(ExThread);
            KeSetTimerEx(&ExTimer->KeTimer,
                         ExpirationTime,
                         Period,
                         &ExTimer->TimerDpc);

            AssociatedApc = TRUE;

        } else {
            KeSetTimerEx(&ExTimer->KeTimer,
                         ExpirationTime,
                         Period,
                         NULL);

            AssociatedApc = FALSE;
        }

        ExpReleaseTimerLock(ExTimer, OldIrql);

        //
        // Dereference the object as appropriate.
        //

        if (Dereference) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        if (AssociatedApc == FALSE) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        if (ARGUMENT_PRESENT(PreviousState)) {
            *PreviousState = State;
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\systime.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    systime.c

Abstract:

    This module implements the NT system time services.

--*/

#include "exp.h"

//
// Guards against multiple threads attempting to set the system time.
//
INITIALIZED_CRITICAL_SECTION(ExpTimeRefreshLock);

NTSTATUS
NtSetSystemTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL
    )

/*++

Routine Description:

    This function sets the current system time and optionally returns the
    previous system time.

Arguments:

    SystemTime - Supplies a pointer to the new value for the system time.

    PreviousTime - Supplies an optional pointer to a variable that receives
        the previous system time.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_ACCESS_VIOLATION is returned if the input parameter for the
        system time cannot be read or the output parameter for the system
        time cannot be written.

    STATUS_INVALID_PARAMETER is returned if the input system time is negative.

--*/

{
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER NewTime;
    TIME_FIELDS TimeFields;

    PAGED_CODE();

    RtlEnterCriticalSectionAndRegion(&ExpTimeRefreshLock);

    //
    // Get the new system time and check to ensure that the value is
    // positive and resonable. If the new system time is negative, then
    // return an invalid parameter status.
    //

    NewTime = *SystemTime;

    if ((NewTime.HighPart < 0) || (NewTime.HighPart > 0x20000000)) {
        RtlLeaveCriticalSectionAndRegion(&ExpTimeRefreshLock);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the system time, and capture the previous system time in a
    // local variable, then store the local variable in the previous time
    // variable if it is specified. This is required so that faults can
    // be prevented from happening in the set time routine.
    //

    KeSetSystemTime(&NewTime, &CurrentTime);

    RtlTimeToTimeFields(&NewTime, &TimeFields);
    HalSetRealTimeClock(&TimeFields);

    if (ARGUMENT_PRESENT(PreviousTime)) {
        *PreviousTime = CurrentTime;
    }

    //
    // Mark the CMOS data as valid.
    //

    HalMarkCmosValid();

    RtlLeaveCriticalSectionAndRegion(&ExpTimeRefreshLock);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\i386\raisests.asm ===
title  "Raise Exception"
;++
;
; Copyright (c) 1990  Microsoft Corporation
;
; Module Name:
;
;    raisests.asm
;
; Abstract:
;
;    This module implements the function to raise a software exception.
;
; Author:
;
;    Bryan Willman  11 Nov 90
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

        EXTRNP  _RtlDispatchException,2
        EXTRNP  _ZwContinue,2
        EXTRNP  _ZwRaiseException,3

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; Context flags definition.
;

CONTEXT_SETTING EQU CONTEXT_INTEGER OR CONTEXT_CONTROL OR CONTEXT_SEGMENTS

;
; Exception record length definition.
;

EXCEPTION_RECORD_LENGTH EQU (ErExceptionInformation + 16) AND 0fffffff0H

        page
        subttl  "Raise Software Exception"
;++
;
; VOID
; ExRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord
;    )
;
; Routine Description:
;
;    This function raises a software exception by building a context record,
;    establishing the stack limits of the current processor mode, and calling
;    the exception dispatcher. If the exception dispatcher finds a handler
;    to process the exception, then control is returned to the caller using
;    the NtContinue system service. Otherwise the NtLastChance system service
;    is called to provide default handing.
;
;   N.B.    On the 386, floating point state is not defined for non-fp
;           exceptions.  Therefore, this routine does not attempt to
;           capture it.
;
;           This means this routine cannot be used to report fp exceptions.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _ExRaiseException  , 1

        push    ebp
        mov     ebp,esp
        pushfd                          ; save flags before sub
        sub     esp,ContextFrameLength  ; Allocate a context record

;
; Save regs we use in context record
;

        mov     [(ebp-ContextFrameLength-4)+CsEax],eax
        mov     [(ebp-ContextFrameLength-4)+CsEcx],ecx

;
; Get pointer to exception report record, and set the exceptionaddress
; field to be our return address
;

        mov     eax,[ebp+8]             ; (eax) -> ExceptionReportRecord

        mov     ecx,[ebp+4]
        mov     [eax.ErExceptionAddress],ecx

;
; Copy machine context into the context record
;

        lea     eax,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        mov     [eax.CsEip],ecx

        mov     [eax.CsEbx],ebx
        mov     [eax.CsEdx],edx

        mov     [eax.CsEsi],esi
        mov     [eax.CsEdi],edi

        lea     ecx,[ebp+8]
        mov     [eax.CsEsp],ecx

        mov     ecx,[ebp]
        mov     [eax.CsEbp],ecx

        mov     ecx,[ebp-4]
        mov     [eax.CsEflags],ecx

        mov     dword ptr [eax.CsSegCs],cs
        mov     dword ptr [eax.CsSegSs],ss

;
; Set Context flags, note that FLOATING_POINT is NOT set.
;

        mov     dword ptr [eax.CsContextFlags],CONTEXT_SETTING

;
; _RtlDispatchException(ExceptionRecord, ContextRecord)
;
        stdCall    _RtlDispatchException, <[ebp+8],eax>
;
; If the exception is successfully dispatched, then continue execution.
; Otherwise, give the kernel debugger a chance to handle the exception.
;
        lea     ecx,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        or      eax, eax
        jz      short ere10

        stdCall    _ZwContinue, <ecx,0>
        jmp     short ere20

ere10:
        stdCall    _ZwRaiseException, <[ebp+8],ecx,0>

ere20:
;
; Either the attempt to continue execution or the attempt to give
; the kernel debugger a chance to handle the exception failed. Raise
; a noncontinuable exception.
;
        stdCall    _ExRaiseStatus, <eax>


stdENDP _ExRaiseException

        page
        subttl  "Raise Software Exception"
;++
;
; VOID
; ExRaiseStatus (
;     IN NTSTATUS Status
;     )
;
; Routine Description:
;
;    This function raises a software exception with the specified status value
;    by building a context record, establishing the stack limits of the current
;    processor mode, and calling the exception dispatcher. If the exception
;    dispatcher finds a handler to process the exception, then control is
;    returned to the caller using the NtContinue system service. Otherwise
;    the NtLastChance system service is called to provide default handing.
;
;   N.B.    On the 386, floating point state is not defined for non-fp
;           exceptions.  Therefore, this routine does not attempt to
;           capture it.
;
;           This means this routine cannot be used to report fp exceptions.
;
; Arguments:
;
;     Status - Supplies the status value to be used as the exception code
;         for the exception that is to be raised.
;
; Return Value:
;
;     None.

; Arguments:
;
;--

cPublicProc     _ExRaiseStatus,1

        push    ebp
        mov     ebp,esp
        pushfd                          ; save flags before sub
        sub     esp,ContextFrameLength+ExceptionRecordLength

;
; Save regs we use in context record
;

        mov     [(ebp-ContextFrameLength-4)+CsEax],eax
        mov     [(ebp-ContextFrameLength-4)+CsEcx],ecx

;
; Copy machine context into the context record
;


        lea     eax,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        mov     ecx,[ebp+4]                     ; [ecx] = returned address
        mov     [eax.CsEip],ecx

        mov     [eax.CsEbx],ebx
        mov     [eax.CsEdx],edx

        mov     [eax.CsEsi],esi
        mov     [eax.CsEdi],edi

        lea     ecx,[ebp+8]
        mov     [eax.CsEsp],ecx

        mov     ecx,[ebp]
        mov     [eax.CsEbp],ecx

        mov     ecx,[ebp-4]
        mov     [eax.CsEflags],ecx

        mov     dword ptr [eax.CsSegCs],cs
        mov     dword ptr [eax.CsSegSs],ss

;
; Set Context flags, note that FLOATING_POINT is NOT set.
;

        mov     dword ptr [eax.CsContextFlags],CONTEXT_SETTING

;
; Get pointer to exception report record, and set the exceptionaddress
; field to be our return address
;

        lea     eax,[ebp-ContextFrameLength-ExceptionRecordLength-4]
                                        ; (eax) -> ExceptionRecord
        mov     ecx,[ebp+4]
        mov     dword ptr [eax.ErExceptionAddress],ecx
        mov     ecx,[ebp+8]
        mov     dword ptr [eax.ErExceptionCode],ecx
        mov     dword ptr [eax.ErNumberParameters], 0
        mov     dword ptr [eax.ErExceptionRecord], 0
        mov     dword ptr [eax.ErExceptionFlags], EXCEPTION_NONCONTINUABLE

;
; _RtlDispatchException(ExceptionRecord, ContextRecord)
;

        lea     ecx,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

; ecx - Context record
; eax - Exception record
        stdCall _RtlDispatchException, <eax, ecx>

;
; An unwind was not initiated during the dispatching of a noncontinuable
; exception. Give the kernel debugger a chance to handle the exception.
;

;
; _ZwRaiseException(ExceptionRecord, ContextRecord, FirstChance=TRUE)
;

        lea     ecx,[ebp-ContextFrameLength-4]  ; (eax) -> Context record
        lea     eax,[ebp-ContextFrameLength-ExceptionRecordLength-4]
; 1 - TRUE
; ecx - Context Record
; eax - Exception Report Record
        stdCall   _ZwRaiseException, <eax, ecx, 1>

;
; We came back, suggesting some sort of error in the call.  Raise
; a status exception to report this, return from ZwRaiseException is type.
;

        stdCall    _ExRaiseStatus, <eax>


stdENDP _ExRaiseStatus

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\i386\intrlfst.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intrlfst.asm
;
; Abstract:
;
;    This module implements functions to support interlocked operations.
;    Interlocked operations can only operate on nonpaged data.
;
;    This module implements the fast call version of the interlocked
;    fuctions.
;
; Author:
;
;    Ken Reneris (kenr) 5-May-1994
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   General Notes on Interlocked Procedures:
;
;       These procedures assume that neither their code, nor any of
;       the data they touch, will cause a page fault.
;
;       They use spinlocks to achieve MP atomicity, iff it's an MP machine.
;       (The spinlock macros generate zilch if NT_UP = 1, and
;        we if out some aux code here as well.)
;
;       They turn off interrupts so that they can be used for synchronization
;       between ISRs and driver code.  Flags are preserved so they can
;       be called in special code (Like IPC interrupt handlers) that
;       may have interrupts off.
;
;--

        page ,132
        subttl  "ExInterlockedAddLargeStatistic"
;++
;
; VOID
; FASTCALL
; ExInterlockedAddLargeStatistic (
;    IN PLARGE_INTEGER Addend,
;    IN ULONG Increment
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned large integer.
;
; Arguments:
;
;    (ecx) Addend - Supplies a pointer to the variable whose value is
;                     adjusted by the increment value.
;
;    (edx) Increment - Supplies the increment value that is added to the
;                      addend variable.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall ExInterlockedAddLargeStatistic, 2
cPublicFpo 0,0

        add dword ptr [ecx], edx        ; add low part of large statistic
        adc dword ptr [ecx+4], 0        ; add carry to high part

        fstRET  ExInterlockedAddLargeStatistic ; return

fstENDP ExInterlockedAddLargeStatistic

        page , 132
        subttl  "Interlocked Insert Head List"
;++
;
; PLIST_ENTRY
; ExfInterlockedInsertHeadList (
;    IN PLIST_ENTRY ListHead,
;    IN PLIST_ENTRY ListEntry
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;   (ecx) = ListHead - Supplies a pointer to the head of the doubly linked
;                       list into which an entry is to be inserted.
;
;   (edx) = ListEntry - Supplies a pointer to the entry to be inserted at the
;                       head of the list.
;
; Return Value:
;
;    Pointer to entry that was at the head of the list or NULL if the list
;    was empty.
;
;--

cPublicFastCall ExfInterlockedInsertHeadList    , 2
cPublicFpo 0, 1

        pushfd
        cli

        mov     eax, LsFlink[ecx]       ; (eax)->next entry in the list
        mov     [edx]+LsFlink, eax      ; store next link in entry
        mov     [edx]+LsBlink, ecx      ; store previous link in entry
        mov     [ecx]+LsFlink, edx      ; store next link in head
        mov     [eax]+LsBlink, edx      ; store previous link in next

        popfd

        xor     eax, ecx                ; return null if list was empty
        jz      short Eiih15
        xor     eax, ecx
Eiih15: fstRET  ExfInterlockedInsertHeadList

fstENDP ExfInterlockedInsertHeadList

        page , 132
        subttl  "Interlocked Insert Tail List"
;++
;
; PLIST_ENTRY
; FASTCALL
; ExfInterlockedInsertTailList (
;    IN PLIST_ENTRY ListHead,
;    IN PLIST_ENTRY ListEntry
;    )
;
; Routine Description:
;
;    This function inserts an entry at the tail of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;   (ecx) =  ListHead - Supplies a pointer to the head of the doubly linked
;            list into which an entry is to be inserted.
;
;   (edx) =  ListEntry - Supplies a pointer to the entry to be inserted at the
;            tail of the list.
;
; Return Value:
;
;    Pointer to entry that was at the tail of the list or NULL if the list
;    was empty.
;
;--

cPublicFastCall ExfInterlockedInsertTailList, 2
cPublicFpo 0, 1

        pushfd
        cli

        mov     eax, LsBlink[ecx]       ; (eax)->prev entry in the list
        mov     [edx]+LsFlink, ecx      ; store next link in entry
        mov     [edx]+LsBlink, eax      ; store previous link in entry
        mov     [ecx]+LsBlink, edx      ; store next link in head
        mov     [eax]+LsFlink, edx      ; store previous link in next

        popfd

        xor     eax, ecx                ; return null if list was empty
        jz      short Eiit15
        xor     eax, ecx
Eiit15: fstRET  ExfInterlockedInsertTailList

fstENDP ExfInterlockedInsertTailList

        page , 132
        subttl  "Interlocked Remove Head List"
;++
;
; PLIST_ENTRY
; FASTCALL
; ExfInterlockedRemoveHeadList (
;    IN PLIST_ENTRY ListHead
;    )
;
; Routine Description:
;
;    This function removes an entry from the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the head of the doubly linked
;          list from which an entry is to be removed.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall ExfInterlockedRemoveHeadList    , 1
cPublicFpo 0, 1

        pushfd
        cli

        mov     eax, [ecx]+LsFlink      ; (eax)-> next entry
        cmp     eax, ecx                ; Is list empty?
        je      short Eirh20            ; if e, list is empty, go Eirh20

        mov     edx, [eax]+LsFlink      ; (ecx)-> next entry(after deletion)
        mov     [ecx]+LsFlink, edx      ; store address of next in head
        mov     [edx]+LsBlink, ecx      ; store address of previous in next
if DBG
        mov     [eax]+LsFlink, 0baddd0ffh
        mov     [eax]+LsBlink, 0baddd0ffh
endif
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedRemoveHeadList

Eirh20: popfd
        xor     eax,eax                 ; (eax) = null for empty list
        fstRET  ExfInterlockedRemoveHeadList

fstENDP ExfInterlockedRemoveHeadList

        page , 132
        subttl  "Interlocked Pop Entry Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; InterlockedPopEntrySList (
;    IN PSINGLE_LIST_ENTRY ListHead
;    )
;
; Routine Description:
;
;    This function removes an entry from the front of a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         pop entry code which has a compatible calling sequence and data
;         structure.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which an entry is to be removed.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall InterlockedPopEntrySList, 1

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address

;
; N.B. The following code is the continuation address should a fault
;      occur in the rare case described below.
;

        public  ExpInterlockedPopEntrySListResume
ExpInterlockedPopEntrySListResume:      ;

        mov     edx, [ebp] + 4          ; get current sequence number
        mov     eax, [ebp] + 0          ; get current next link

;
; If the list is empty, then there is nothing that can be removed.
;

Epop10: or      eax, eax                ; check if list is empty
        jz      short Epop20            ; if z set, list is empty
        mov     ecx, edx                ; copy sequence number and depth
        add     ecx, 0FFFFH             ; adjust sequence number and depth

;
; N.B. It is possible for the following instruction to fault in the rare
;      case where the first entry in the list is allocated on another
;      processor and freed between the time the free pointer is read above
;      and the following instruction. When this happens, the access fault
;      code continues execution above at the resumption address and the
;      entire operation is retried.
;

        public  ExpInterlockedPopEntrySListFault
ExpInterlockedPopEntrySListFault:       ;

        mov     ebx, [eax]              ; get address of successor entry

.586
        cmpxchg8b qword ptr [ebp]       ; compare and exchange
.386

        jnz     short Epop10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

Epop20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    InterlockedPopEntrySList

fstENDP InterlockedPopEntrySList

        page , 132
        subttl  "Interlocked Push Entry Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; InterlockedPushEntrySList (
;    IN PSINGLE_LIST_ENTRY ListHead,
;    IN PSINGLE_LIST_ENTRY ListEntry
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a sequenced singly linked
;    list so that access to the list is synchronized in an MP system.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         push entry code which has a compatible calling sequence and data
;         structure.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the sequenced listhead into which
;          an entry is to be inserted.
;
;    (edx) ListEntry - Supplies a pointer to the entry to be inserted at the
;          head of the list.
;
; Return Value:
;
;    Previous contents of ListHead.  NULL implies list went from empty
;       to not empty.
;
;--

cPublicFastCall InterlockedPushEntrySList, 2

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     ebx, edx                ; save list entry address
        mov     edx, [ebp] + 4          ; get current sequence number
        mov     eax, [ebp] + 0          ; get current next link
Epsh10: mov     [ebx], eax              ; set next link in new first entry
        mov     ecx, edx                ; copy sequence number
        add     ecx, 010001H            ; increment sequence number and depth

.586
        cmpxchg8b qword ptr[ebp]        ; compare and exchange
.386

        jnz     short Epsh10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    InterlockedPushEntrySList

fstENDP InterlockedPushEntrySList

        page , 132
        subttl  "Interlocked Flush Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; InterlockedFlushSList (
;    IN PSINGLE_LIST_ENTRY ListHead
;    )
;
; Routine Description:
;
;    This function removes the entire list from a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry at the top of the list is removed
;    and returned as the function value and the list header is set to point
;    to NULL.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         pop entry code which has a compatible calling sequence and data
;         structure.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which the list is to be flushed.
;
; Return Value:
;
;    The address of the entire current list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall InterlockedFlushSList, 1

cPublicFpo 0,1

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     edx, [ebp] + 4          ; get current sequence number
        mov     eax, [ebp] + 0          ; get current next link

;
; N.B. The following code is the retry code should the compare
;      part of the compare exchange operation fail
;
; If the list is empty, then there is nothing that can be removed.
;

Efls10: or      eax, eax                ; check if list is empty
        jz      short Efls20            ; if z set, list is empty
        mov     ecx, 0	                ; clear sequence number and depth
        mov     ebx, 0                  ; clear successor entry pointer

.586
        cmpxchg8b qword ptr [ebp]       ; compare and exchange
.386

        jnz     short Efls10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

Efls20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    InterlockedFlushSList

fstENDP InterlockedFlushSList

        page , 132
        subttl  "Interlocked i386 Exchange Ulong"
;++
;
;   ULONG
;   FASTCALL
;   InterlockedExchange (
;       IN PULONG Target,
;       IN ULONG Value
;       )
;
;   Routine Description:
;
;       This function atomically exchanges the Target and Value, returning
;       the prior contents of Target
;
;       See Exi386InterlockedExchangeUlong.  This function is the i386
;       architectural specific version of ExInterlockedDecrementLong.
;       No source directly calls this function, instead
;       ExInterlockedDecrementLong is called and when built on x86 these
;       calls are macroed to the i386 optimized version.
;
;   Arguments:
;
;       (ecx) = Source - Address of ULONG to exchange
;       (edx) = Value  - New value of ULONG
;
;   Return Value:
;
;       The prior value of Source
;--

cPublicFastCall InterlockedExchange, 2
cPublicFpo 0,0
.486
        mov     eax, [ecx]                  ; get comperand value
Ixchg:  cmpxchg [ecx], edx                  ; compare and swap
        jnz     Ixchg                       ; if nz, exchange failed
.386

        fstRET  InterlockedExchange
fstENDP InterlockedExchange

;++
;
; LONG
; InterlockedIncrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of one to the addend variable.
;
;    No checking is done for overflow.
;
; Arguments:
;
;    Addend (ecx) - Supplies a pointer to a variable whose value is to be
;       incremented by one.
;
; Return Value:
;
;   (eax) - The incremented value.
;
;--

cPublicFastCall InterlockedIncrement,1
cPublicFpo 0,0

        mov     eax, 1                  ; set increment value

.486
        xadd    [ecx], eax              ; interlocked increment
.386p
        inc     eax                     ; adjust return value

        fstRET InterlockedIncrement

fstENDP InterlockedIncrement

        page , 132
        subttl  "InterlockedDecrment"
;++
;
; LONG
; InterlockedDecrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of -1 to the addend variable.
;
;    No checking is done for overflow
;
; Arguments:
;
;    Addend (ecx) - Supplies a pointer to a variable whose value is to be
;       decremented by one.
;
; Return Value:
;
;   (eax) - The decremented value.
;
;--

cPublicFastCall InterlockedDecrement,1
cPublicFpo 0,0

        mov     eax, -1                 ; set decrment value

.486
        xadd    [ecx], eax              ; interlocked decrement
.386

        dec     eax                     ; adjust return value

        fstRET InterlockedDecrement

fstENDP InterlockedDecrement

        page , 132
        subttl  "Interlocked Compare Exchange"
;++
;
;   PVOID
;   FASTCALL
;   InterlockedCompareExchange (
;       IN OUT PVOID *Destination,
;       IN PVOID Exchange,
;       IN PVOID Comperand
;       )
;
;   Routine Description:
;
;    This function performs an interlocked compare of the destination
;    value with the comperand value. If the destination value is equal
;    to the comperand value, then the exchange value is stored in the
;    destination. Otherwise, no operation is performed.
;
; Arguments:
;
;    (ecx)  Destination - Supplies a pointer to destination value.
;
;    (edx) Exchange - Supplies the exchange value.
;
;    [esp + 4] Comperand - Supplies the comperand value.
;
; Return Value:
;
;    The initial destination value is returned as the function value.
;
;--

cPublicFastCall InterlockedCompareExchange, 3
cPublicFpo 0,0

        mov     eax, [esp + 4]          ; set comperand value
.486
        cmpxchg [ecx], edx              ; compare and exchange
.386

        fstRET  InterlockedCompareExchange

fstENDP InterlockedCompareExchange

        page , 132
        subttl  "Interlocked Compare Exchange 64-bits"
;++
;
; LONGLONG
; FASTCALL
; ExInterlockedCompareExchange64 (
;    IN PLONGLONG Destination,
;    IN PLONGLONG Exchange,
;    IN PLONGLONG Comperand
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         compare exchange 64-bit code which has a compatible calling
;         sequence and data structure.
;
; Arguments:
;
;    (ecx) Destination - Supplies a pointer to the destination variable.
;
;    (edx) Exchange - Supplies a pointer to the exchange value.
;
;    (esp+4) Comperand - Supplies a pointer to the comperand value.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicFastCall ExInterlockedCompareExchange64, 3

cPublicFpo 0,1

;
; Save nonvolatile registers and read the exchange and comperand values.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; set destination address
        mov     ebx, [edx]              ; get exchange value
        mov     ecx, [edx] + 4          ;
        mov     edx, [esp] + 12         ; get comperand address
        mov     eax, [edx]              ; get comperand value
        mov     edx, [edx] + 4          ;

.586
        cmpxchg8b qword ptr[ebp]        ; compare and exchange
.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    ExInterlockedCompareExchange64

fstENDP ExInterlockedCompareExchange64

        page , 132
        subttl  "Interlocked Exchange Add"
;++
;
;   LONG
;   FASTCALL
;   InterlockedExchangeAdd (
;       IN OUT PLONG Addend,
;       IN LONG Increment
;       )
;
;   Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsinged long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    (ecx)  Addend - Supplies a pointer to a variable whose value is to be
;                    adjusted by the increment value.
;
;    (edx) Increment - Supplies the increment value to be added to the
;                      addend variable.
;
; Return Value:
;
;    The initial value of the addend variable.
;
;--

cPublicFastCall InterlockedExchangeAdd, 2
cPublicFpo 0,0

.486
        xadd    [ecx], edx              ; exchange add
.386

        mov     eax, edx                ; set initial value

        fstRET  InterlockedExchangeAdd

fstENDP InterlockedExchangeAdd

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\settings.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    settings.c

Abstract:

    Functions for querying or saving non-volatile settings

--*/

#include "exp.h"

#include <windef.h>
#include <winbase.h>
#include <xbox.h>
#include "xboxp.h"
#include "xconfig.h"

//
// Guards against multiple threads accessing settings at the same time
//
INITIALIZED_CRITICAL_SECTION(ExpNonVolatileSettingsLock);

//
// SMBus slave addresses for reading/writing EEPROM
//
#define EEPROM_SMBUS_WRITE  0xA8
#define EEPROM_SMBUS_READ   0xA9
#define EEPROM_RW_BLOCK     2

//
// EEPROM shadow in RAM
//
DECLSPEC_STICKY UCHAR EEPROMShadow[EEPROM_TOTAL_MEMORY_SIZE];
DECLSPEC_STICKY ULONG EEPROMShadowIsValid;


NTSTATUS
ExpReadEEPROMIntoCache()

/*++

Routine Description:

    Read the entire content of the EEPROM into the RAM buffer

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    USHORT* p = (USHORT*) EEPROMShadow;
    ULONG Offset;
    NTSTATUS Status;

    ASSERT(EEPROM_RW_BLOCK == sizeof(*p));

    // Read data out of the EEPROM, 2 bytes at a time
    for (Offset=0; Offset < EEPROM_TOTAL_MEMORY_SIZE; Offset += EEPROM_RW_BLOCK) {
        ULONG val;
        Status = HalReadSMBusWord(EEPROM_SMBUS_READ, (UCHAR) Offset, &val);
        if (!NT_SUCCESS(Status)) {
            KdPrint(("EX: failed to read EEPROM offset %02x, status=%08x\n", Offset, Status));
            return Status;
        }
        *p++ = (USHORT) val;
    }

    // Check to see if the EEPROM is empty (i.e. all 1's)
    p = (USHORT*) EEPROMShadow;
    for (Offset=0; Offset < EEPROM_TOTAL_MEMORY_SIZE/EEPROM_RW_BLOCK; Offset++) {
        if (p[Offset] != 0xffff)
            return STATUS_SUCCESS;
    }

    KdPrint(("Uninitialized EEPROM data!!!\n"));
    return STATUS_INVALID_DEVICE_STATE;
}


NTSTATUS
ExpReadEEPROMSection(
    ULONG Offset,
    ULONG Count,
    VOID* Buffer,
    BOOLEAN DoChecksum
    )

/*++

Routine Description:

    Read data from the specified section of the EEPROM

Arguments:

    Offset - Starting byte offset of the specified EEPROM section
    Count - Number of bytes in the section
    Buffer - Buffer for returning the data

Return Value:

    Status code

--*/

{
    // Make sure we have a cached copy of the EEPROM content in RAM
    if (!EEPROMShadowIsValid) {
        NTSTATUS Status = ExpReadEEPROMIntoCache();
        if (!NT_SUCCESS(Status)) return Status;

        EEPROMShadowIsValid = TRUE;
    }

    memcpy(Buffer, &EEPROMShadow[Offset], Count);

    // Verify the section checksum if requested
    if (DoChecksum && XConfigChecksum(Buffer, Count) != 0xffffffff) {
        KdPrint(("Corrupted EEPROM data!!!\n"));
        return STATUS_DEVICE_DATA_ERROR;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ExpWriteEEPROM(
    ULONG Offset,
    ULONG Count,
    const VOID* Buffer
    )

/*++

Routine Description:

    Write data to EEPROM

Arguments:

    Offset - EEPROM byte offset to start writing at
    Count - Number of bytes to write
    Buffer - Points to the data to be written to the EEPROM

Return Value:

    Status code

--*/

{
    const USHORT* p = (const USHORT*) Buffer;
    NTSTATUS Status;

    ASSERT(EEPROM_RW_BLOCK == sizeof(*p));
    ASSERT(Count % EEPROM_RW_BLOCK == 0);

    // Update the cached content as well
    if (EEPROMShadowIsValid) {
        memcpy(&EEPROMShadow[Offset], Buffer, Count);
    }

    // Write data into the EEPROM, 2 bytes at a time
    for (Count += Offset; Offset < Count; Offset += EEPROM_RW_BLOCK) {
        ULONG val = *p++;
        Status = HalWriteSMBusWord(EEPROM_SMBUS_WRITE, (UCHAR) Offset, val);
        if (!NT_SUCCESS(Status)) {
            KdPrint(("EX: failed to write EEPROM offset %02x, status=%08x\n", Offset, Status));
            // If the write fails, marked the cached data as invalid
            EEPROMShadowIsValid = FALSE;
            return Status;
        }
    }

    return STATUS_SUCCESS;
}


//
// Information about a non-volatile setting
//
typedef struct _SETTING_ENTRY_INFO {
    UCHAR Type;
    UCHAR Index;
    UCHAR Size;
    UCHAR Offset;
} SETTING_ENTRY_INFO;

//
// Values in the factory settings section of the EEPROM
//
#define FACTORY_SETTING_ENTRY(type, index, field) { \
            type, \
            index - XC_FACTORY_START_INDEX, \
            FIELD_SIZE(XBOX_FACTORY_SETTINGS, field), \
            FIELD_OFFSET(XBOX_FACTORY_SETTINGS, field) \
        }

const SETTING_ENTRY_INFO FactorySettingsInfo[] = {
    FACTORY_SETTING_ENTRY(REG_BINARY, XC_FACTORY_SERIAL_NUMBER, SerialNumber),
    FACTORY_SETTING_ENTRY(REG_BINARY, XC_FACTORY_ETHERNET_ADDR, EthernetAddr),
    FACTORY_SETTING_ENTRY(REG_BINARY, XC_FACTORY_ONLINE_KEY, OnlineKey),
    FACTORY_SETTING_ENTRY(REG_DWORD, XC_FACTORY_AV_REGION, AVRegion),

    { REG_BINARY, XC_MAX_FACTORY-XC_FACTORY_START_INDEX, EEPROM_FACTORY_SECTION_SIZE, 0 }
};

//
// Values in the user settings section of the EEPROM
//
#define USER_SETTING_ENTRY(type, index, field) { \
            type, \
            index, \
            FIELD_SIZE(XBOX_USER_SETTINGS, field), \
            FIELD_OFFSET(XBOX_USER_SETTINGS, field) \
        }

const SETTING_ENTRY_INFO UserSettingsInfo[] = {
    USER_SETTING_ENTRY(REG_DWORD, XC_TIMEZONE_BIAS, TimeZoneBias),
    USER_SETTING_ENTRY(REG_BINARY, XC_TZ_STD_NAME, TimeZoneStdName),
    USER_SETTING_ENTRY(REG_BINARY, XC_TZ_STD_DATE, TimeZoneStdDate),
    USER_SETTING_ENTRY(REG_DWORD, XC_TZ_STD_BIAS, TimeZoneStdBias),
    USER_SETTING_ENTRY(REG_BINARY, XC_TZ_DLT_NAME, TimeZoneDltName),
    USER_SETTING_ENTRY(REG_BINARY, XC_TZ_DLT_DATE, TimeZoneDltDate),
    USER_SETTING_ENTRY(REG_DWORD, XC_TZ_DLT_BIAS, TimeZoneDltBias),
    USER_SETTING_ENTRY(REG_DWORD, XC_LANGUAGE, Language),
    USER_SETTING_ENTRY(REG_DWORD, XC_VIDEO_FLAGS, VideoFlags),
    USER_SETTING_ENTRY(REG_DWORD, XC_AUDIO_FLAGS, AudioFlags),
    USER_SETTING_ENTRY(REG_DWORD, XC_PARENTAL_CONTROL_GAMES, ParentalControlGames),
    USER_SETTING_ENTRY(REG_DWORD, XC_PARENTAL_CONTROL_PASSWORD, ParentalControlPassword),
    USER_SETTING_ENTRY(REG_DWORD, XC_PARENTAL_CONTROL_MOVIES, ParentalControlMovies),
    USER_SETTING_ENTRY(REG_DWORD, XC_ONLINE_IP_ADDRESS, OnlineIpAddress),
    USER_SETTING_ENTRY(REG_DWORD, XC_ONLINE_DNS_ADDRESS, OnlineDnsAddress),
    USER_SETTING_ENTRY(REG_DWORD, XC_ONLINE_DEFAULT_GATEWAY_ADDRESS, OnlineDefaultGatewayAddress),
    USER_SETTING_ENTRY(REG_DWORD, XC_ONLINE_SUBNET_ADDRESS, OnlineSubnetMask),
    USER_SETTING_ENTRY(REG_DWORD, XC_MISC_FLAGS, MiscFlags),
    USER_SETTING_ENTRY(REG_DWORD, XC_DVD_REGION, DvdRegion),

    { REG_BINARY, XC_MAX_OS, EEPROM_USER_SECTION_SIZE, 0 }
};


const SETTING_ENTRY_INFO*
ExpFindSettingInfo(
    const SETTING_ENTRY_INFO* Table,
    ULONG Count,
    ULONG Index
    )

/*++

Routine Description:

    Find information about a specified non-volatile setting

Arguments:

    Table - Points to a table that contains information about
        all non-volatile settings in one section
    Count - Number of entries in the table
    Index - Specifies which setting is interested interested in

Return Value:

    Returns a pointer to the information about the specified setting
    NULL if the specified setting is not supported

--*/

{
    const SETTING_ENTRY_INFO* EntryInfo;
    
    for (EntryInfo=Table; Count--; EntryInfo++) 
        if (EntryInfo->Index == Index) return EntryInfo;

    return NULL;
}


NTSTATUS
ExQueryNonVolatileSetting(
    IN ULONG ValueIndex,
    OUT ULONG* Type,
    OUT VOID* Value,
    IN ULONG ValueLength,
    OUT ULONG* ResultLength
    )

/*++

Routine Description:

    Query a non-volatile factory or user setting

Arguments:

    ValueIndex - Specifies which non-volatile setting to query
    Type - Return the value type
    Value - Output buffer for storing the result
    ValueLength - Specifies the output buffer size
    ResultLength - Returns the actually amount of data returned to the caller

Return Value:

    Status code

--*/

{
    NTSTATUS Status;
    ULONG SectionOffset, SectionSize;
    const SETTING_ENTRY_INFO* EntryInfo;
    UCHAR buf[EEPROM_TOTAL_MEMORY_SIZE];

    //
    // Sanity checks for the EEPROM layout
    //
    ASSERT(EEPROM_ENCRYPTED_SECTION_SIZE % EEPROM_PAGE_ALIGNMENT == 0 &&
           EEPROM_FACTORY_SECTION_SIZE % EEPROM_PAGE_ALIGNMENT == 0 &&
           EEPROM_ENCRYPTED_SECTION_SIZE +
           EEPROM_FACTORY_SECTION_SIZE +
           EEPROM_USER_SECTION_SIZE <= EEPROM_TOTAL_MEMORY_SIZE);

    ASSERT(Type != NULL && Value != NULL);

    //
    // Special case for game region value
    //
    if (ValueIndex == XC_FACTORY_GAME_REGION) {
        if (ResultLength)
            *ResultLength = sizeof(ULONG);
        if (ValueLength < sizeof(ULONG))
            return STATUS_BUFFER_TOO_SMALL;

        *Type = REG_DWORD;
        *((ULONG*) Value) = XboxGameRegion;
        return STATUS_SUCCESS;
    }

    //
    // Another special case to read the entire EEPROM content at once
    // or to read the encrypted data section
    //
    if (ValueIndex == XC_MAX_ALL || ValueIndex == XC_ENCRYPTED_SECTION) {
        SectionSize = (ValueIndex == XC_MAX_ALL) ?
                        EEPROM_TOTAL_MEMORY_SIZE :
                        EEPROM_ENCRYPTED_SECTION_SIZE;

        if (ResultLength)
            *ResultLength = SectionSize;
        if (ValueLength < SectionSize)
            return STATUS_BUFFER_TOO_SMALL;

        *Type = REG_BINARY;

        RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
        Status = ExpReadEEPROMSection(0, SectionSize, Value, FALSE);
        RtlLeaveCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
        return Status;
    }
    
    //
    // Figure out which setting is being queried
    //
    if (ValueIndex <= XC_MAX_OS) {
        //
        // User settings section
        //
        SectionOffset = EEPROM_USER_SECTION_START;
        SectionSize = EEPROM_USER_SECTION_SIZE;
        EntryInfo = ExpFindSettingInfo(
                        UserSettingsInfo,
                        sizeof(UserSettingsInfo) / sizeof(UserSettingsInfo[0]),
                        ValueIndex);
    } else if (ValueIndex <= XC_MAX_FACTORY) {
        //
        // Factory settings section
        //
        SectionOffset = EEPROM_FACTORY_SECTION_START;
        SectionSize = EEPROM_FACTORY_SECTION_SIZE;
        EntryInfo = ExpFindSettingInfo(
                        FactorySettingsInfo,
                        sizeof(FactorySettingsInfo) / sizeof(FactorySettingsInfo[0]),
                        ValueIndex - XC_FACTORY_START_INDEX);
    } else {
        EntryInfo = NULL;
    }

    //
    // The requested value doesn't exist
    //
    if (EntryInfo == NULL)
        return STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // Now read the relevant section from the EEPROM
    //
    RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
    Status = ExpReadEEPROMSection(SectionOffset, SectionSize, buf, TRUE);
    RtlLeaveCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);

    if (!NT_SUCCESS(Status))
        return Status;

    //
    // Is the supplied output buffer large enough
    //
    if (ValueLength < EntryInfo->Size)
        return STATUS_BUFFER_TOO_SMALL;

    //
    // Now copy the value to the output buffer and return success.
    // If the output buffer is larger than necessary, unused portion is zero-filled.
    //
    *Type = EntryInfo->Type;
    if (ResultLength)
        *ResultLength = EntryInfo->Size;

    memset(Value, 0, ValueLength);
    memcpy(Value, &buf[EntryInfo->Offset], EntryInfo->Size);
    return STATUS_SUCCESS;
}


NTSTATUS
ExSaveNonVolatileSetting(
    IN ULONG ValueIndex,
    IN ULONG Type,
    IN const VOID* Value,
    IN ULONG ValueLength
    )

/*++

Routine Description:

    Save a non-volatile user-setting

Arguments:

    ValueIndex - Specifies which non-volatile setting to save
    Type - Specifies the value type
    Value - Points to the value to be saved
    ValueLength - Size of the data

Return Value:

    Status code

--*/

{
    NTSTATUS Status;
    ULONG SectionOffset, SectionSize;
    const SETTING_ENTRY_INFO* EntryInfo;
    UCHAR OldSettings[EEPROM_TOTAL_MEMORY_SIZE];
    UCHAR NewSettings[EEPROM_TOTAL_MEMORY_SIZE];
    BOOLEAN SmartWrite = TRUE;
    UCHAR* buf;

    ASSERT(Value != NULL);

    if (ValueIndex == XC_MAX_ALL) {
        //
        // Special case to write the entire EEPROM content at once
        //
        if (ValueLength != EEPROM_TOTAL_MEMORY_SIZE)
            return STATUS_INVALID_PARAMETER;

        RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);

        //
        // We try to be smart about the write.  If we can fetch all of the old
        // settings, we'll use the smart write code.  Otherwise, we'll
        // just force the complete write.
        //
        SectionOffset = 0;
        SectionSize = EEPROM_TOTAL_MEMORY_SIZE;
        memcpy(NewSettings, Value, SectionSize);
        Status = ExpReadEEPROMSection(SectionOffset, SectionSize, OldSettings,
            FALSE);
        if(!NT_SUCCESS(Status))
            SmartWrite = FALSE;
        goto DoSmartWrite;
    } else if (ValueIndex <= XC_MAX_OS) {
        //
        // User settings section
        //
        SectionOffset = EEPROM_USER_SECTION_START;
        SectionSize = EEPROM_USER_SECTION_SIZE;
        EntryInfo = ExpFindSettingInfo(
                        UserSettingsInfo,
                        sizeof(UserSettingsInfo) / sizeof(UserSettingsInfo[0]),
                        ValueIndex);
#ifdef DEVKIT
    } else if (ValueIndex == XC_FACTORY_GAME_REGION) {
        //
        // Special case to update the game region
        //
        if (ValueLength != FIELD_SIZE(XBOX_ENCRYPTED_SETTINGS, GameRegion))
            return STATUS_INVALID_PARAMETER;

        RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
        
        Status = ExpWriteEEPROM(
                    EEPROM_ENCRYPTED_SECTION_START +
                        FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, GameRegion),
                    ValueLength,
                    Value);

        if (NT_SUCCESS(Status))
            XboxGameRegion = *((ULONG*) Value);

        RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
        return Status;
    } else if (ValueIndex <= XC_MAX_FACTORY) {
        //
        // Factory settings section
        //
        SectionOffset = EEPROM_FACTORY_SECTION_START;
        SectionSize = EEPROM_FACTORY_SECTION_SIZE;
        EntryInfo = ExpFindSettingInfo(
                        FactorySettingsInfo,
                        sizeof(FactorySettingsInfo) / sizeof(FactorySettingsInfo[0]),
                        ValueIndex - XC_FACTORY_START_INDEX);
#endif // DEVKIT
    } else {
        EntryInfo = NULL;
    }

    if (EntryInfo == NULL)
        return STATUS_OBJECT_NAME_NOT_FOUND;

    // NOTE: If necessary in the future, we could potentially store
    // a REG_DWORD value in a smaller field (e.g. UCHAR or USHORT),
    // as long as the top bits of the value to be stored are all 0's.
    if (ValueLength > EntryInfo->Size)
        return STATUS_INVALID_PARAMETER;

    RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);

    //
    // Read the entire user configuration section of the EEPROM
    //
    Status = ExpReadEEPROMSection(SectionOffset, SectionSize, OldSettings, TRUE);

    if (!NT_SUCCESS(Status)) {
#ifndef DEVKIT
        //
        // If we're not just changing an entry in the user section, and the
        // EEPROM is corrupt, we don't want to make things worse by changing
        // it some more, so we'll just fail out.  If this is an entry from the
        // user section, we'll just restore the user portion of the EEPROM to
        // default (ie., zero) settings.
        //
        if(SectionOffset != EEPROM_USER_SECTION_START) {
            RtlLeaveCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
            return Status;
        }
#endif

        // Reset the configuration section with default values.
        memset(NewSettings, 0, SectionSize);
        SmartWrite = FALSE;
    } else {
        memcpy(NewSettings, OldSettings, SectionSize);
    }

    //
    // Update the specified field
    //
    buf = &(NewSettings[EntryInfo->Offset]);
    memset(buf, 0, EntryInfo->Size);
    memcpy(buf, Value, ValueLength);

    //
    // Compute the new checksum
    //  We use the 32-bit version of the TCP/IP checksum algorithm, i.e.
    //  1's complement of the 1's complement sum of the whole data structure.
    //  The checksum field itself is 0 when the checksum is computed.
    //

    //
    // NOTE: Checksum MUST be stored as the first ULONG of the settings structure
    //
    
    *((PULONG) NewSettings) = 0;
    *((PULONG) NewSettings) = ~XConfigChecksum(NewSettings, SectionSize);

    //
    // Write out the data to EEPROM
    //
DoSmartWrite:
    if (SmartWrite) {
        UCHAR* oldbuf = OldSettings;
        UCHAR* newbuf = NewSettings;
        ULONG Offset = 0;

        Status = STATUS_SUCCESS;
        while (Offset < SectionSize) {
            if (memcmp(oldbuf+Offset, newbuf+Offset, EEPROM_RW_BLOCK) != 0) {
                Status = ExpWriteEEPROM(SectionOffset+Offset, EEPROM_RW_BLOCK, newbuf+Offset);
                if (!NT_SUCCESS(Status)) break;
            }
            Offset += EEPROM_RW_BLOCK;
        }

    } else {
        Status = ExpWriteEEPROM(SectionOffset, SectionSize, NewSettings);
    }

    RtlLeaveCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);

    return Status;
}


NTSTATUS
ExReadWriteRefurbInfo(
    OUT XBOX_REFURB_INFO* RefurbInfo,
    IN ULONG ValueLength,
    IN BOOLEAN DoWrite
    )

/*++

Routine Description:

    Read or write refurb information

Arguments:

    RefurbInfo - Pointer to the data buffer
    ValueLength - Size of the data buffer
    DoWrite - TRUE for writing and FALSE for reading

Return Value:

    Status code

--*/

{
    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE disk;

    ASSERT(RefurbInfo != NULL);
    if (ValueLength != sizeof(XBOX_REFURB_INFO))
        return STATUS_INVALID_PARAMETER;

    //
    // Open disk partition 0 for raw r/w access
    //
    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtOpenFile(
                &disk,
                GENERIC_READ | (DoWrite ? GENERIC_WRITE : 0) | SYNCHRONIZE,
                &oa,
                &iosb,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(status)) {
        LARGE_INTEGER offset;
        CHAR buf[XBOX_HD_SECTOR_SIZE];
        XBOX_REFURB_INFO* info = (XBOX_REFURB_INFO*) buf;

        //
        // Refurb information is stored in sector 3
        // 
        ASSERT(sizeof(XBOX_REFURB_INFO) <= XBOX_HD_SECTOR_SIZE);
        memset(buf, 0, sizeof(buf));
        offset.QuadPart = XBOX_REFURB_INFO_SECTOR_INDEX * XBOX_HD_SECTOR_SIZE;

        if (DoWrite) {
            memcpy(info, RefurbInfo, sizeof(XBOX_REFURB_INFO));
            info->Signature = XBOX_REFURB_INFO_SIGNATURE;
            status = NtWriteFile(disk, 0, NULL, NULL, &iosb, info, XBOX_HD_SECTOR_SIZE, &offset);
        } else {
            status = NtReadFile(disk, 0, NULL, NULL, &iosb, info, XBOX_HD_SECTOR_SIZE, &offset);
            if (NT_SUCCESS(status)) {
                if (info->Signature != XBOX_REFURB_INFO_SIGNATURE) {
                    //
                    // Invalid signature - assume everything is uninitialized
                    //
                    memset(RefurbInfo, 0, sizeof(XBOX_REFURB_INFO));
                } else {
                    memcpy(RefurbInfo, info, sizeof(XBOX_REFURB_INFO));
                }
            }
        }

        NtClose(disk);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\i386\rwlocka.asm ===
TITLE   "Reader/Writer Lock Routines"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     rwlocka.asm
;
;  Abstract:
;
;     This module implements functions to support executive reader/writer locks.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

        EXTRNP  _KeReleaseSemaphore,4
        EXTRNP  _KeSetEvent,3
        EXTRNP  _KeWaitForSingleObject,5

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

ReadWriteLock equ     [esp + 4]

;++
;
; VOID
; ExAcquireReadWriteLockExclusive(
;     IN PERWLOCK ReadWriteLock
;     )
;
; Routine Description:
;
;     This function acquires a reader/writer lock for exclusive access.
;
; Arguments:
;
;     ReadWriteLock - Supplies the address of the reader/writer lock.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _ExAcquireReadWriteLockExclusive, 1

;
; Load the read/writer lock address into a register and disable interrupts to
; synchronize access to the lock.
;

        mov     ecx, ReadWriteLock
        cli

;
; Increment the lock count.  If the count doesn't transition from negative one
; to zero, then a reader or writer already owns the lock.  Otherwise, we own the
; write lock, so ReadersEntryCount should be zero.
;

        inc     dword ptr ErwLockCount[ecx]
        jnz     ContentionExclusive

        sti
        stdRET  _ExAcquireReadWriteLockExclusive

;
; Block until all of the readers or the writer release the lock.
;

ContentionExclusive:
        inc     dword ptr ErwWritersWaitingCount[ecx]
        sti
        add     ecx, ErwWriterEvent
.errnz (WrExecutive - 0)
        xor     edx, edx
        stdCall _KeWaitForSingleObject,<ecx,edx,edx,edx,edx>
        stdRET  _ExAcquireReadWriteLockExclusive

stdENDP _ExAcquireReadWriteLockExclusive

;++
;
; VOID
; ExAcquireReadWriteLockShared(
;     IN PERWLOCK ReadWriteLock
;     )
;
; Routine Description:
;
;     This function acquires a reader/writer lock for shared access.
;
; Arguments:
;
;     ReadWriteLock - Supplies the address of the reader/writer lock.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _ExAcquireReadWriteLockShared, 1

;
; Load the read/writer lock address into a register and disable interrupts to
; synchronize access to the lock.
;

        mov     ecx, ReadWriteLock
        cli

;
; Increment the lock count.  If the count doesn't transition from negative one
; to zero, then a reader or writer already owns the lock.  Otherwise, we own the
; read lock, so increment the number of readers.
;

        inc     dword ptr ErwLockCount[ecx]
        jnz     ContentionShared

ContentionNoWriters:
        inc     dword ptr ErwReadersEntryCount[ecx]
        sti
        stdRET  _ExAcquireReadWriteLockShared

;
; Check if there's a writer that already owns the lock or if there are any
; waiting writers.  If not, we can share the lock with the existing reader.
; Otherwise, block until the writer completes or the next writer has completed.
;

ContentionShared:
        xor     edx, edx
        cmp     dword ptr ErwReadersEntryCount[ecx], edx
        je      ContentionBlockForWriter
        cmp     dword ptr ErwWritersWaitingCount[ecx], edx
        je      ContentionNoWriters

ContentionBlockForWriter:
        inc     dword ptr ErwReadersWaitingCount[ecx]
        sti
        add     ecx, ErwReaderSemaphore
.errnz (WrExecutive - 0)
        stdCall _KeWaitForSingleObject,<ecx,edx,edx,edx,edx>
        stdRET  _ExAcquireReadWriteLockShared

stdENDP _ExAcquireReadWriteLockShared

;++
;
; VOID
; ExReleaseReadWriteLock(
;     IN PERWLOCK ReadWriteLock
;     )
;
; Routine Description:
;
;     This function releases a reader/writer lock.
;
; Arguments:
;
;     ReadWriteLock - Supplies the address of the reader/writer lock.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _ExReleaseReadWriteLock, 1

;
; Load the read/writer lock address into a register and disable interrupts to
; synchronize access to the lock.
;

        mov     ecx, ReadWriteLock
        cli

;
; Decrement the lock count.  If the count is greater than or equal to zero, then
; there are either shared readers using the lock or there are waiters for the
; lock.
;

        dec     dword ptr ErwLockCount[ecx]
        jge     ReleaseContention

;
; Zero out the number of readers that have entered the lock.  Either a writer
; is releasing the lock, in which case this count is already zero, or else the
; last reader is releasing the lock, in which case we want the count to
; decrement to zero.
;

        mov     dword ptr ErwReadersEntryCount[ecx], 0

ReleaseExit:
        sti
        stdRET  _ExReleaseReadWriteLock

;
; Check if the lock is owned by a single writer or one or more readers.
;

ReleaseContention:
        cmp     dword ptr ErwReadersEntryCount[ecx], 0
        mov     eax, dword ptr ErwReadersWaitingCount[ecx]
        mov     edx, dword ptr ErwWritersWaitingCount[ecx]
        je      ReleaseByWriter

;
; The lock is owned by a reader, so decrement the number of readers that have
; entered the lock.  If the reader count reaches zero, then there must be a
; waiting writer that needs to be signaled.
;

ReleaseByReader:
        dec     dword ptr ErwReadersEntryCount[ecx]
        jnz     ReleaseExit

ReleaseWriter:
        dec     dword ptr ErwWritersWaitingCount[ecx]
        sti
        add     ecx, ErwWriterEvent
        stdcall _KeSetEvent,<ecx,EVENT_INCREMENT,0>
        stdRET  _ExReleaseReadWriteLock

;
; The lock is owned by a writer.  If there aren't any readers waiting for the
; lock, then there must be another writer.  Otherwise, unblock as many readers
; as are currently queued up for the lock.
;

ReleaseByWriter:
        test    eax, eax
        jz      ReleaseWriter

ReleaseReaders:
        mov     dword ptr ErwReadersEntryCount[ecx], eax
        xor     edx, edx
        mov     dword ptr ErwReadersWaitingCount[ecx], edx
        sti
        add     ecx, ErwReaderSemaphore
        stdcall _KeReleaseSemaphore,<ecx,EVENT_INCREMENT,eax,edx>
        stdRET  _ExReleaseReadWriteLock

stdENDP _ExReleaseReadWriteLock

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\allocsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    allocsup.c

Abstract:

    This module implements routines which provide support for managing volume
    cluster allocations.

--*/

#include "fatx.h"

NTSTATUS
FatxInitializeDirectoryCluster(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG ClusterNumber
    )
/*++

Routine Description:

    This routine initializes the contents of the supplied cluster for use as a
    directory entry cluster.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ClusterNumber - Specifies the cluster number to initialize.

Return Value:

    Status of operation.

--*/
{
    ULONGLONG PhysicalByteOffset;

    ASSERT(FatxIsValidCluster(VolumeExtension, ClusterNumber));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Compute the physical byte offset of the starting cluster.  Clusters
    // always start on a page boundary.
    //

    PhysicalByteOffset = FatxClusterToPhysicalByteOffset(VolumeExtension,
        ClusterNumber);

    ASSERT(BYTE_OFFSET(PhysicalByteOffset) == 0);

    //
    // Use the file system cache to quickly fill the cluster with 0xFFs
    // (FAT_DIRENT_NEVER_USED2) using a single cache buffer.  This pattern is
    // used in order to minimize signal noise when writing to a memory unit (MU)
    // device.
    //

    return FscWriteFFs(&VolumeExtension->CacheExtension, Irp, PhysicalByteOffset,
        VolumeExtension->BytesPerCluster);
}

NTSTATUS
FatxLinkClusterChains(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG LinkClusterNumber,
    IN ULONG StartingClusterNumber
    )
/*++

Routine Description:

    This routine links the starting cluster number to the link cluster number.
    The link cluster number should currently have the value FAT_CLUSTER_LAST.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    LinkClusterNumber - Specifies the cluster number to link in the starting
        cluster number to.  This cluster should be the end of an existing file
        allocation chain.

    StartingClusterNumber - Specifies the starting cluster number of an
        allocation chain which is added to the above cluster chain.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONGLONG PhysicalFatByteOffset;
    PVOID CacheBuffer;
    PVOID FatEntry;

    ASSERT(FatxIsValidCluster(VolumeExtension, LinkClusterNumber));
    ASSERT(FatxIsValidCluster(VolumeExtension, StartingClusterNumber));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Map in the cache buffer that contains the desired file allocation table
    // entry.
    //

    PhysicalFatByteOffset = VolumeExtension->FatByteOffset +
        FatxClusterToFatByteOffset(VolumeExtension, LinkClusterNumber);

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalFatByteOffset, TRUE, &CacheBuffer);

    if (NT_SUCCESS(status)) {

        //
        // Change the file allocation table entry from FAT_CLUSTER_LAST to the
        // starting cluster number of the allocation extension.
        //

        FatEntry = CacheBuffer;
        ASSERT(FatxReadFatEntry(VolumeExtension, FatEntry) == FAT_CLUSTER_LAST);
        FatxWriteFatEntry(VolumeExtension, FatEntry, StartingClusterNumber);

        //
        // Write the change back out the disk and unmap the cache buffer.
        //

        status = FscWriteBuffer(&VolumeExtension->CacheExtension,
            Irp, PhysicalFatByteOffset, 1 << VolumeExtension->FatEntryShift,
            CacheBuffer);
    }

    //
    // If we failed to complete the above operation, then delete the allocation
    // extension on behalf of the caller.
    //

    if (!NT_SUCCESS(status)) {
        FatxFreeClusters(VolumeExtension, Irp, StartingClusterNumber, FALSE);
    }

    return status;
}

NTSTATUS
FatxAllocateClusters(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG EndingCluster,
    IN ULONG ClustersNeeded,
    OUT FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS],
    OUT PULONG NumberOfClusterRuns,
    OUT PULONG ReturnedEndingCluster
    )
/*++

Routine Description:

    This routine allocates a chain of clusters.  The cluster chain is optionally
    linked to the supplied ending cluster.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    EndingCluster - Specifies the last cluster of an existing file allocation
        chain.  The new file allocation chain is linked to this cluster.

    ClustersNeeded - Specifies the number of clusters to allocate.

    ClusterRuns - Specifies an array of that will receive the starting physical
        cluster and run length for the first FAT_MAXIMUM_CLUSTER_RUNS cluster
        fragments.

    NumberOfClusterRuns - Specifies the buffer to receive the number of cluster
        runs that were actually filled in.

    ReturnedEndingCluster - Specifies the buffer to receive the last cluster of
        the allocation chain.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG SectorSize;
    ULONG SectorMask;
    PFAT_CLUSTER_RUN CurrentClusterRun;
    PFAT_CLUSTER_RUN EndingClusterRun;
    ULONG EndingClusterFatByteOffset;
    ULONG ClusterNumber;
    BOOLEAN UsedFirstAvailableClusterHint;
    ULONG InitialCluster;
    BOOLEAN SkipLinkClusterChains;
    ULONG ClusterRunInitialCluster;
    ULONG ClusterRunLength;
    PVOID LastFatEntry;
    ULONG LastSectorLastAllocatedCluster;
    ULONG FirstAllocatedCluster;
    ULONG LastAllocatedCluster;
    BOOLEAN CacheBufferDirty;
    PVOID CacheBuffer;
    ULONG CacheBufferFatByteOffset;
    ULONG CacheBufferClustersAllocated;
    ULONG FatByteOffset;
    ULONG SectorFatByteOffset;
    PVOID FatEntry;
    ULONG FatEntryClusterNumber;

    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    SectorSize = VolumeExtension->SectorSize;
    SectorMask = SectorSize - 1;

    //
    // The below code assumes that relative byte offsets into the file
    // allocation table have the same page alignment as their corresponding
    // physical byte offsets.
    //

    ASSERT(BYTE_OFFSET(VolumeExtension->FatByteOffset) == 0);

    //
    // Check if the volume has enough clusters available to satisfy the request.
    //

    if (ClustersNeeded > VolumeExtension->NumberOfClustersAvailable) {
        return STATUS_DISK_FULL;
    }

    //
    // Keep track of the current and maximum cluster run pointers.
    //

#if DBG
    RtlFillMemory(ClusterRuns, sizeof(FAT_CLUSTER_RUN) * FAT_MAXIMUM_CLUSTER_RUNS, 0xcc);
#endif

    CurrentClusterRun = &ClusterRuns[0];
    EndingClusterRun = &ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS];

    //
    // Determine from what cluster to start scanning for free clusters.
    //

    if (EndingCluster != FAT_CLUSTER_NULL) {

        EndingClusterFatByteOffset = FatxClusterToFatByteOffset(VolumeExtension,
            EndingCluster);
        ClusterNumber = EndingCluster + 1;

        if (ClusterNumber == VolumeExtension->NumberOfClusters +
            FAT_RESERVED_FAT_ENTRIES) {
            ClusterNumber = VolumeExtension->FirstAvailableClusterHint;
        }

    } else {
        EndingClusterFatByteOffset = MAXULONG;
        ClusterNumber = VolumeExtension->FirstAvailableClusterHint;
    }

    //
    // Walk the file allocation table allocating the cluster chain.
    //

    UsedFirstAvailableClusterHint =
        (BOOLEAN)(ClusterNumber == VolumeExtension->FirstAvailableClusterHint);
    InitialCluster = FAT_CLUSTER_NULL;
    SkipLinkClusterChains = FALSE;
    ClusterRunInitialCluster = FAT_CLUSTER_NULL;
    ClusterRunLength = 0;
    LastFatEntry = NULL;
    LastSectorLastAllocatedCluster = EndingCluster;
    FirstAllocatedCluster = FAT_CLUSTER_NULL;
    LastAllocatedCluster = FAT_CLUSTER_NULL;
    CacheBufferDirty = FALSE;
    CacheBuffer = NULL;
    CacheBufferFatByteOffset = 0;
    CacheBufferClustersAllocated = 0;

    for (;;) {

        ASSERT(FatxIsValidCluster(VolumeExtension, ClusterNumber));

        //
        // Compute the relative offset to the file allocation table entry for
        // the next cluster to check and its sector aligned byte offset.
        //

        FatByteOffset = FatxClusterToFatByteOffset(VolumeExtension, ClusterNumber);
        SectorFatByteOffset = FatByteOffset & ~SectorMask;

        //
        // If we haven't mapped in a cache buffer yet or if we're switching
        // sectors, then we need to commit and switch cache buffers.
        //

        if ((CacheBuffer == NULL) ||
            (CacheBufferFatByteOffset != SectorFatByteOffset)) {

            //
            // If another cache buffer has already been mapped, then commit the
            // changes on this buffer if necessary.
            //

            if (CacheBuffer != NULL) {

                if (CacheBufferDirty) {

                    status = FscWriteBuffer(&VolumeExtension->CacheExtension,
                        Irp, VolumeExtension->FatByteOffset +
                        CacheBufferFatByteOffset, SectorSize, CacheBuffer);

                    if (!NT_SUCCESS(status)) {
                        break;
                    }

                    //
                    // Decrease the number of clusters available on the volume
                    // now that we've commited the file allocation table sector.
                    //

                    VolumeExtension->NumberOfClustersAvailable -=
                        CacheBufferClustersAllocated;

                    //
                    // If we have an existing allocation from a previous sector,
                    // then link up the first cluster from this sector to the
                    // last cluster from the previous sector.
                    //
                    // Note that FatxLinkClusterChains calls FatxFreeClusters
                    // for the starting cluster number when the operation fails.
                    //

                    if ((LastSectorLastAllocatedCluster != FAT_CLUSTER_NULL) &&
                        !SkipLinkClusterChains) {

                        status = FatxLinkClusterChains(VolumeExtension, Irp,
                            LastSectorLastAllocatedCluster,
                            FirstAllocatedCluster);

                        if (!NT_SUCCESS(status)) {
                            break;
                        }
                    }

                    LastSectorLastAllocatedCluster = LastAllocatedCluster;

                } else {
                    FscUnmapBuffer(CacheBuffer);
                }

                CacheBufferDirty = FALSE;
                CacheBufferClustersAllocated = 0;
            }

            //
            // Map the next file allocation table page into memory.
            //

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                VolumeExtension->FatByteOffset + SectorFatByteOffset, TRUE,
                &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                break;
            }

            CacheBufferFatByteOffset = SectorFatByteOffset;

            //
            // If we're searching for clusters on the same sector as the initial
            // ending cluster number, then set LastFatEntry to point at that
            // cluster's file allocation table entry.  That causes the below
            // code to link the initial ending cluster to any clusters we find
            // on the same sector with a single write operation.
            //

            if ((LastSectorLastAllocatedCluster != FAT_CLUSTER_NULL) &&
                (LastSectorLastAllocatedCluster == EndingCluster) &&
                ((EndingClusterFatByteOffset & ~SectorMask) == SectorFatByteOffset)) {

                LastFatEntry = (PUCHAR)CacheBuffer +
                    (EndingClusterFatByteOffset & SectorMask);
                SkipLinkClusterChains = TRUE;

                ASSERT(FatxReadFatEntry(VolumeExtension, LastFatEntry) ==
                    FAT_CLUSTER_LAST);

            } else {
                LastFatEntry = NULL;
                SkipLinkClusterChains = FALSE;
            }
        }

        //
        // Compute the pointer to the desired file allocation table entry and
        // grab its allocation status.
        //

        FatEntry = (PUCHAR)CacheBuffer + (FatByteOffset & SectorMask);
        FatEntryClusterNumber = FatxReadFatEntry(VolumeExtension, FatEntry);

        //
        // Check if the cluster is unallocated.
        //

        if (FatEntryClusterNumber == FAT_CLUSTER_AVAILABLE) {

            //
            // Convert the unallocated cluster to an allocated cluster.
            //

            if (FatxIsFlagClear(VolumeExtension->Flags, FAT_VOLUME_FAT16X)) {
                *(PULONG)FatEntry = FAT_CLUSTER_LAST;
            } else {
                *(PUSHORT)FatEntry = FAT_CLUSTER16_LAST;
            }

            CacheBufferDirty = TRUE;
            CacheBufferClustersAllocated++;

            //
            // Check how to link this newly allocated cluster to the file's
            // cluster chain.
            //

            if (LastFatEntry != NULL) {

                //
                // The previously allocated cluster resides in the same sector
                // as this newly allocated cluster, so link the clusters up now.
                //

                FatxWriteFatEntry(VolumeExtension, LastFatEntry, ClusterNumber);

            } else {

                //
                // This is the first cluster allocation for this sector.  After
                // we write out this sector, we'll go back and fix up the
                // cluster chain to point at this cluster number.
                //

                FirstAllocatedCluster = ClusterNumber;
            }

            //
            // If this is the first cluster that we're allocating, remember its
            // number.  This is also the first cluster for the first cluster
            // run.
            //
            // Otherwise, if this newly allocated cluster isn't physically
            // contiguous with the current cluster run, then store the current
            // cluster run into the caller's buffer if space allows and then
            // start a new cluster run.
            //

            if (InitialCluster == FAT_CLUSTER_NULL) {

                InitialCluster = ClusterNumber;

                ClusterRunInitialCluster = ClusterNumber;
                ASSERT(ClusterRunLength == 0);

            } else if ((ClusterRunInitialCluster + ClusterRunLength) !=
                ClusterNumber) {

                if (CurrentClusterRun < EndingClusterRun) {
                    CurrentClusterRun->PhysicalClusterNumber = ClusterRunInitialCluster;
                    CurrentClusterRun->ClusterRunLength = ClusterRunLength;
                    CurrentClusterRun++;
                }

                ClusterRunInitialCluster = ClusterNumber;
                ClusterRunLength = 0;
            }

            ClusterRunLength++;

            //
            // If we continue to allocate clusters in this sector, then we can
            // use the current file allocation table entry pointer to link up
            // those clusters.
            //

            LastFatEntry = FatEntry;
            LastAllocatedCluster = ClusterNumber;

            //
            // Decrement the number of clusters needed.
            //

            if (--ClustersNeeded == 0) {

                //
                // We've allocated all of the clusters we need.  Commit the
                // changes on this buffer.
                //

                status = FscWriteBuffer(&VolumeExtension->CacheExtension,
                    Irp, VolumeExtension->FatByteOffset +
                    CacheBufferFatByteOffset, SectorSize, CacheBuffer);

                if (!NT_SUCCESS(status)) {
                    break;
                }

                //
                // If we starting scanning for free clusters from the first
                // available cluster hint, then we need to update that hint to
                // point past the last cluster that we allocated.
                //

                if (UsedFirstAvailableClusterHint) {
                    VolumeExtension->FirstAvailableClusterHint =
                        LastAllocatedCluster + 1;
                }

                //
                // Decrease the number of clusters available on the volume now
                // that we've commited the file allocation table sector.
                //

                VolumeExtension->NumberOfClustersAvailable -=
                    CacheBufferClustersAllocated;

                //
                // If we have an existing allocation from a previous sector,
                // then link up the first cluster from this sector to the last
                // cluster from the previous sector.
                //
                // Note that FatxLinkClusterChains calls FatxFreeClusters for
                // the starting cluster number when the operation fails.
                //

                if ((LastSectorLastAllocatedCluster != FAT_CLUSTER_NULL) &&
                    !SkipLinkClusterChains) {

                    status = FatxLinkClusterChains(VolumeExtension, Irp,
                        LastSectorLastAllocatedCluster,
                        FirstAllocatedCluster);

                    if (!NT_SUCCESS(status)) {
                        break;
                    }
                }

                //
                // Store this last cluster run if space allows.
                //

                if (CurrentClusterRun < EndingClusterRun) {
                    CurrentClusterRun->PhysicalClusterNumber = ClusterRunInitialCluster;
                    CurrentClusterRun->ClusterRunLength = ClusterRunLength;
                    CurrentClusterRun++;
                }

                //
                // Return the number of cluster runs that were actually used.
                //

                *NumberOfClusterRuns = CurrentClusterRun - ClusterRuns;

                //
                // Return the last cluster that we allocated to the client.  If
                // we overflowed the cluster runs array, then this is the only
                // easy way to get the value.
                //

                *ReturnedEndingCluster = LastAllocatedCluster;

                return STATUS_SUCCESS;
            }
        }

        //
        // Advance to the next cluster.  If we reach the end of the disk, jump
        // back to the first available cluster hint.  If we've already used the
        // first available cluster hint, then either the in memory state is
        // corrupt or the on disk structures are corrupt, so bail out.
        //

        ClusterNumber++;

        if (ClusterNumber == VolumeExtension->NumberOfClusters +
            FAT_RESERVED_FAT_ENTRIES) {

            if (UsedFirstAvailableClusterHint) {
                FatxDbgPrint(("FATX: FAT table is corrupt.\n"));
                FscDiscardBuffer(CacheBuffer);
                status = STATUS_DISK_CORRUPT_ERROR;
                break;
            }

            ClusterNumber = VolumeExtension->FirstAvailableClusterHint;
            UsedFirstAvailableClusterHint = TRUE;
        }
    }

    //
    // We failed for some reason.  Attempt to free any clusters that we've
    // already allocated.  Nothing has been written to the disk yet if
    // LastSectorLastAllocatedCluster is still initialized to EndingCluster.
    //

    ASSERT(!NT_SUCCESS(status));

    if (LastSectorLastAllocatedCluster != EndingCluster) {

        if (EndingCluster != FAT_CLUSTER_NULL) {
            FatxFreeClusters(VolumeExtension, Irp, EndingCluster, TRUE);
        } else if (InitialCluster != FAT_CLUSTER_NULL) {
            FatxFreeClusters(VolumeExtension, Irp, InitialCluster, FALSE);
        }
    }

    return status;
}

BOOLEAN
FatxFreeClusters(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG ClusterNumber,
    IN BOOLEAN MarkFirstAsLast
    )
/*++

Routine Description:

    This routine converts an allocated chain of clusters to free clusters.

    This routine can optionally mark the initial cluster as FAT_CLUSTER_LAST in
    order to truncate an existing file allocation.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ClusterNumber - Specifies the first cluster to mark as free or to truncate.

    MarkFirstAsLast - Specifies whether the first cluster should be marked as
        FAT_CLUSTER_LAST or FAT_CLUSTER_AVAILABLE.  This can be used to truncate
        an existing file allocation.

Return Value:

    Status of operation.

--*/
{
    BOOLEAN Result;
    ULONG SectorSize;
    ULONG SectorMask;
    ULONG FirstAvailableClusterHint;
    ULONG FatEntryFreeValue;
    BOOLEAN FlushedFirstDirtySector;
    PVOID CacheBuffer;
    ULONG CacheBufferFatByteOffset;
    ULONG CacheBufferClustersFreed;
    ULONG FatByteOffset;
    ULONG SectorFatByteOffset;
    NTSTATUS status;
    PVOID FatEntry;

    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    SectorSize = VolumeExtension->SectorSize;
    SectorMask = SectorSize - 1;
    FirstAvailableClusterHint = VolumeExtension->FirstAvailableClusterHint;

    //
    // The below code assumes that relative byte offsets into the file
    // allocation table have the same page alignment as their corresponding
    // physical byte offsets.
    //

    ASSERT(BYTE_OFFSET(VolumeExtension->FatByteOffset) == 0);

    //
    // Check if the starting cluster number is valid to reduce the amount of
    // code at the call sites.  We may be passed a cluster number from a
    // directory entry that hasn't been validated yet.
    //

    if (!FatxIsValidCluster(VolumeExtension, ClusterNumber)) {
        return FALSE;
    }

    //
    // Compute the value that we want to be writing into the first file
    // allocation table entry.
    //

    FatEntryFreeValue = MarkFirstAsLast ? FAT_CLUSTER_LAST : FAT_CLUSTER_AVAILABLE;

    //
    // If we're truncating an existing file allocation, then the flush of the
    // first dirty sector must succeed or else we'll end up leaving a dangling
    // allocation.  If we're deleting an entire file allocation, then it's okay
    // to fail on the first write since there aren't any other pointers to the
    // allocation chain.
    //

    FlushedFirstDirtySector = (BOOLEAN)!MarkFirstAsLast;

    //
    // Walk the file allocation table freeing the cluster chain.
    //

    Result = FALSE;
    CacheBuffer = NULL;
    CacheBufferFatByteOffset = 0;
    CacheBufferClustersFreed = 0;

    for (;;) {

        //
        // Compute the relative offset to the file allocation table entry for
        // the next cluster to check and its sector aligned byte offset.
        //

        FatByteOffset = FatxClusterToFatByteOffset(VolumeExtension, ClusterNumber);
        SectorFatByteOffset = FatByteOffset & ~SectorMask;

        //
        // If we haven't mapped in a cache buffer yet or if we're switching
        // sectors, then we need to commit and switch cache buffers.
        //

        if ((CacheBuffer == NULL) ||
            (CacheBufferFatByteOffset != SectorFatByteOffset)) {

            //
            // If another cache buffer has already been mapped, then commit the
            // changes on this buffer.
            //

            if (CacheBuffer != NULL) {

                status = FscWriteBuffer(&VolumeExtension->CacheExtension,
                    Irp, VolumeExtension->FatByteOffset +
                    CacheBufferFatByteOffset, SectorSize, CacheBuffer);

                if (NT_SUCCESS(status)) {

                    //
                    // Store the first available cluster in case it changed for
                    // this cache buffer.
                    //

                    VolumeExtension->FirstAvailableClusterHint =
                        FirstAvailableClusterHint;

                    //
                    // Increase the number of clusters available on the volume
                    // now that we've committed the file allocation table
                    // sector.
                    //

                    VolumeExtension->NumberOfClustersAvailable +=
                        CacheBufferClustersFreed;

                    Result = TRUE;

                } else {

                    //
                    // If we failed to flush the first sector, then bail out
                    // now.  We can't free any additional clusters without
                    // leaving behind dangling clusters.
                    //

                    if (!FlushedFirstDirtySector) {
                        return FALSE;
                    }

                    //
                    // We failed to write out the last cache buffer, but
                    // we're going to keep trying to free the rest of the
                    // cluster chain.  Restore the first available cluster
                    // number back to a clean value.
                    //

                    FirstAvailableClusterHint =
                        VolumeExtension->FirstAvailableClusterHint;
                }

                FlushedFirstDirtySector = TRUE;
                CacheBufferClustersFreed = 0;
            }

            //
            // Map the next file allocation table page into memory.
            //

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                VolumeExtension->FatByteOffset + SectorFatByteOffset, TRUE,
                &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                return Result;
            }

            CacheBufferFatByteOffset = SectorFatByteOffset;
        }

        //
        // Mark the file allocation table entry as the last allocated unit or as
        // an available entry.  We'll only mark the first cluster that we
        // process as the end of file.
        //

        FatEntry = (PUCHAR)CacheBuffer + (FatByteOffset & SectorMask);

        if ((ClusterNumber < FirstAvailableClusterHint) &&
            (FatEntryFreeValue == FAT_CLUSTER_AVAILABLE)) {
            FirstAvailableClusterHint = ClusterNumber;
        }

        ClusterNumber = FatxReadFatEntry(VolumeExtension, FatEntry);
        FatxWriteFatEntry(VolumeExtension, FatEntry, FatEntryFreeValue);

        if (FatEntryFreeValue == FAT_CLUSTER_AVAILABLE) {
            CacheBufferClustersFreed++;
        }

        //
        // All future file allocation table entries are marked as unallocated.
        //

        FatEntryFreeValue = FAT_CLUSTER_AVAILABLE;

        //
        // Verify that the next cluster entry to free is valid.  Note that this
        // check also handles the normal FAT_CLUSTER_LAST case.
        //

        if (!FatxIsValidCluster(VolumeExtension, ClusterNumber)) {
            break;
        }
    }

    //
    // At this point, we only break out of the above loop when we find an
    // invalid cluster entry.  The cluster entry is most likely the end of file
    // marker.
    //

    if (ClusterNumber != FAT_CLUSTER_LAST) {
        FatxDbgPrint(("FATX: corrupt FAT chain found while freeing clusters\n"));
    }

    //
    // We're still holding on to a dirty cache buffer, so commit the changes.
    //

    ASSERT(CacheBuffer != NULL);

    status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp,
        VolumeExtension->FatByteOffset + CacheBufferFatByteOffset, SectorSize,
        CacheBuffer);

    if (NT_SUCCESS(status)) {

        //
        // Store the first available cluster in case it changed for this cache
        // buffer.
        //

        VolumeExtension->FirstAvailableClusterHint = FirstAvailableClusterHint;

        //
        // Increase the number of clusters available on the volume now that
        // we've committed the file allocation table page.
        //

        VolumeExtension->NumberOfClustersAvailable += CacheBufferClustersFreed;

        Result = TRUE;
    }

    //
    // The root directory should always consume at least one cluster, so we
    // don't check for equality here.
    //

    ASSERT(VolumeExtension->NumberOfClustersAvailable <
        VolumeExtension->NumberOfClusters);

    return Result;
}

NTSTATUS
FatxInitializeAllocationSupport(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine initializes the allocation support for the supplied volume.
    This includes doing things such as determining the number of free clusters
    on the volume and finding the initial cluster to use for new file
    allocations.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    BOOLEAN FirstPage;
    ULONG NumberOfClustersAvailable;
    ULONG FirstAvailableClusterHint;
    ULONG TotalClustersRemaining;
    ULONG FatByteOffset;
    PVOID CacheBuffer;
    ULONG PageClustersRemaining;
    PUSHORT FatEntry16;
    PUSHORT EndingFatEntry16;
    PULONG FatEntry32;
    PULONG EndingFatEntry32;

    ASSERT(BYTE_OFFSET(VolumeExtension->FatByteOffset) == 0);

    //
    // Walk over the file allocation table to determine the number of available
    // clusters and other information used for cluster allocation.
    //

    status = STATUS_SUCCESS;
    FirstPage = TRUE;
    NumberOfClustersAvailable = 0;
    FirstAvailableClusterHint = MAXULONG;
    TotalClustersRemaining = VolumeExtension->NumberOfClusters +
        FAT_RESERVED_FAT_ENTRIES;
    FatByteOffset = 0;

    while (TotalClustersRemaining > 0) {

        //
        // Map the file allocation table page into memory.
        //

        status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
            VolumeExtension->FatByteOffset + FatByteOffset, FALSE, &CacheBuffer);

        if (!NT_SUCCESS(status)) {
            break;
        }

        if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_FAT16X)) {

            PageClustersRemaining = PAGE_SIZE / sizeof(USHORT);

            if (PageClustersRemaining > TotalClustersRemaining) {
                PageClustersRemaining = TotalClustersRemaining;
            }

            FatEntry16 = (PUSHORT)CacheBuffer;
            EndingFatEntry16 = FatEntry16 + PageClustersRemaining;

            if (FirstPage) {
                FirstPage = FALSE;
                FatEntry16 += FAT_RESERVED_FAT_ENTRIES;
            }

            for (NOTHING; FatEntry16 < EndingFatEntry16; FatEntry16++) {

                if (*FatEntry16 == FAT_CLUSTER16_AVAILABLE) {

                    //
                    // If this is the first available cluster that we've seen,
                    // then save off the number.  We use this as a hint to avoid
                    // scanning the entire volume for a free cluster.
                    //

                    if (FirstAvailableClusterHint == MAXULONG) {
                        FirstAvailableClusterHint =
                            (FatByteOffset / sizeof(USHORT)) +
                            (FatEntry16 - (PUSHORT)CacheBuffer);
                    }

                    //
                    // Increment the number of available clusters for the volume.
                    //

                    NumberOfClustersAvailable++;
                }
            }

        } else {

            PageClustersRemaining = PAGE_SIZE / sizeof(ULONG);

            if (PageClustersRemaining > TotalClustersRemaining) {
                PageClustersRemaining = TotalClustersRemaining;
            }

            FatEntry32 = (PULONG)CacheBuffer;
            EndingFatEntry32 = FatEntry32 + PageClustersRemaining;

            if (FirstPage) {
                FirstPage = FALSE;
                FatEntry32 += FAT_RESERVED_FAT_ENTRIES;
            }

            for (NOTHING; FatEntry32 < EndingFatEntry32; FatEntry32++) {

                if (*FatEntry32 == FAT_CLUSTER_AVAILABLE) {

                    //
                    // If this is the first available cluster that we've seen,
                    // then save off the number.  We use this as a hint to avoid
                    // scanning the entire volume for a free cluster.
                    //

                    if (FirstAvailableClusterHint == MAXULONG) {
                        FirstAvailableClusterHint =
                            (FatByteOffset / sizeof(ULONG)) +
                            (FatEntry32 - (PULONG)CacheBuffer);
                    }

                    //
                    // Increment the number of available clusters for the volume.
                    //

                    NumberOfClustersAvailable++;
                }
            }
        }

        //
        // Unmap this cache buffer.
        //

        FscUnmapBuffer(CacheBuffer);

        //
        // Advance to the next file allocation table page.
        //

        FatByteOffset += PAGE_SIZE;
        TotalClustersRemaining -= PageClustersRemaining;
    }

    //
    // Store the results in the volume extension.
    //

    VolumeExtension->NumberOfClustersAvailable = NumberOfClustersAvailable;
    VolumeExtension->FirstAvailableClusterHint = FirstAvailableClusterHint;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ex\i386\intrlock.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intrlock.asm
;
; Abstract:
;
;    This module implements functions to support interlocked operations.
;    Interlocked operations can only operate on nonpaged data.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Feb-1990
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   bryanwi 1-aug-90    Clean up and fix stuff.
;   bryanwi 3-aug-90    Add ExInterlockedIncrementLlong,...
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   General Notes on Interlocked Procedures:
;
;       These procedures assume that neither their code, nor any of
;       the data they touch, will cause a page fault.
;
;       They use spinlocks to achieve MP atomicity, iff it's an MP machine.
;       (The spinlock macros generate zilch if NT_UP = 1, and
;        we if out some aux code here as well.)
;
;       They turn off interrupts so that they can be used for synchronization
;       between ISRs and driver code.  Flags are preserved so they can
;       be called in special code (Like IPC interrupt handlers) that
;       may have interrupts off.
;
;--


;;      align  512

        page ,132
        subttl  "ExInterlockedAddLargeInteger"
;++
;
; LARGE_INTEGER
; ExInterlockedAddLargeInteger (
;    IN PLARGE_INTEGER Addend,
;    IN LARGE_INTEGER Increment,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned large integer. The initial value of
;    the addend variable is returned as the function value.
;
; Arguments:
;
;    (TOS+4) = Addend - a pointer to the addend value
;    (TOS+8) = Increment - the increment value
;    (TOS+16) = Lock - a pointer to a pointer to a spin lock
;
; Return Value:
;
;    The initial value of the addend variable is stored in eax:edx
;
;--

EiulAddend      equ     [ebp + 8]
EiulIncrement   equ     [ebp + 12]
EiulLock        equ     [ebp + 20]
EiulRetval      equ     [ebp - 8]

cPublicProc _ExInterlockedAddLargeInteger, 4

        push    ebp
        mov     ebp,esp
        sub     esp, 8

eiul10: pushfd
        cli                             ; disable interrupts

        mov     eax,EiulAddend          ; (eax)-> addend variable
        mov     ecx,[eax]               ; (ecx)= low part of addend value
        mov     edx,[eax]+4             ; (edx)= high part of addend value
        mov     EiulRetVal,ecx               ; set low part of return value
        mov     EiulRetVal+4,edx             ; set high part of return value
        add     ecx,EiulIncrement       ; add low parts of large integer
        adc     edx,EiulIncrement+4     ; add high parts of large integer and carry
        mov     eax,EiulAddend          ; RELOAD (eax)-> addend variable
        mov     [eax],ecx               ; store low part of result
        mov     [eax]+4,edx             ; store high part of result

        popfd                           ; restore flags including interrupts
        mov     eax, EiulRetval         ; calling convention
        mov     edx, EiulRetval+4       ; calling convention
        mov     esp, ebp
        pop     ebp
        stdRET    _ExInterlockedAddLargeInteger

stdENDP _ExInterlockedAddLargeInteger

        page ,132
        subttl  "ExInterlocked Exchange Add Large Integer"
;++
;
; LARGE_INTEGER
; ExInterlockedExchangeAddLargeInteger (
;    IN PLARGE_INTEGER Addend,
;    IN LARGE_INTEGER Increment,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned large integer. The initial value of
;    the addend variable is returned as the function value.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         add large integer code which has a compatible calling sequence
;         and data structure.
;
; Arguments:
;
;    (TOS + 4) = Addend - Supplies a pointer to the addend variable.
;
;    (TOS + 8) = Increment - Supplies the increment value.
;
;    (TOS + 16) = Lock - Supplies a pointer a spin lock.
;
;    N.B. This routine does not use the spin lock.
;
; Return Value:
;
;    The initial value of the addend variable is stored in eax:edx.
;
;--

XaAddend      equ     [esp + 12]
XaIncrement   equ     [esp + 16]
XaLock        equ     [esp + 24]

cPublicProc _ExInterlockedExchangeAddLargeInteger, 4

cPublicFpo 0,2

;
; Save nonvolatile registers and get the addend value.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, XaAddend           ; get the addend variable address
        mov     eax,[ebp] + 0           ; get low part of addend value
        mov     edx,[ebp] + 4           ; get high part of addend value

;
; Add the increment value to the addend value.
;

Xa10:   mov     ebx, eax                ; copy low part of addend value
        mov     ecx, edx                ; copy high part of addend value
        add     ebx, XaIncrement        ; add low part of increment value
        adc     ecx, XaIncrement + 4    ; add high part of increment value

;
; Exchange the updated addend value with the previous addend value.
;

.586
        cmpxchg8b qword ptr [ebp]       ; compare and exchange
.386

        jnz     short Xa10              ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

        pop     ebp                     ;
        pop     ebx                     ;

        stdRET    _ExInterlockedExchangeAddLargeInteger

stdENDP _ExInterlockedExchangeAddLargeInteger

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\close.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLOSE.

--*/

#include "fatx.h"

NTSTATUS
FatxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLOSE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFILE_OBJECT FileObject;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    PFAT_FCB Fcb;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Always grab the exclusive lock because we could end up writing to the
    // disk and we also use this lock to guard access to the file control block
    // and file control block list.
    //

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;

    //
    // Delete the directory enumeration context if one exists.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext != NULL) {
        FileObject->FsContext2 = NULL;
        ExFreePool(DirectoryEnumContext);
    }

    //
    // Dereference the file control block associated with the file object.
    //

    Fcb = (PFAT_FCB)FileObject->FsContext;
    FileObject->FsContext = NULL;
    FatxDereferenceFcb(Fcb);

    //
    // Decrement the file object count for the volume and check if we're ready
    // to delete this device object.
    //

    VolumeExtension->FileObjectCount--;

    if ((VolumeExtension->FileObjectCount == 0) &&
        FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        FatxReleaseVolumeMutex(VolumeExtension);
        FatxDeleteVolumeDevice(DeviceObject);
    } else {
        FatxReleaseVolumeMutex(VolumeExtension);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\cleanup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLEANUP.

--*/

#include "fatx.h"

NTSTATUS
FatxFsdCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLEANUP requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFILE_OBJECT FileObject;
    PFAT_FCB Fcb;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;
    Fcb = (PFAT_FCB)FileObject->FsContext;

    //
    // Synchronize with pending asynchronous I/O by acquiring the file's mutex.
    //

    if (FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY)) {
        FatxAcquireFileMutexExclusive(Fcb);
    }

    //
    // Always grab the exclusive lock to synchronize access to the share access
    // data structure.  Multiple threads closing distinct file objects pointing
    // at the same file control block could execute this routine at the same
    // time.
    //

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Cleanup the sharing mode associated with the file object.
    //

    IoRemoveShareAccess(FileObject, &Fcb->ShareAccess);

    //
    // If this was the last open handle to the file, then check if we need to
    // perform any cleanup actions for the file.  Abandon the actions if the
    // volume has been dismounted.
    //

    if ((Fcb->ShareAccess.OpenCount == 0) &&
        FatxIsFlagClear(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DELETE_ON_CLOSE)) {

            //
            // The file or directory is flagged for deletion.  Mark the
            // directory entry as deleted.
            //

            ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_ROOT_DIRECTORY));

            status = FatxMarkDirectoryEntryDeleted(VolumeExtension, Irp, Fcb);

            if (NT_SUCCESS(status)) {

                //
                // The directory entry was succesfully marked as deleted, so
                // free the clusters allocated to the file.  Note that
                // FatxFreeClusters checks if the first cluster number is valid
                // for the volume, so we don't have to do any validation here.
                //

                FatxFreeClusters(VolumeExtension, Irp, Fcb->FirstCluster, FALSE);

                //
                // Remove this file control block from the list of siblings so
                // and dereference the parent file control block.
                //

                if (Fcb->ParentFcb != NULL) {

                    RemoveEntryList(&Fcb->SiblingFcbLink);
                    FatxDereferenceFcb(Fcb->ParentFcb);

                    Fcb->ParentFcb = NULL;
                }
            }

        } else if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_UPDATE_DIRECTORY_ENTRY)) {

            //
            // If there are any pending changes to flush out to the directory
            // entry (last write time), then do that now.
            //

            FatxUpdateDirectoryEntry(VolumeExtension, Irp, Fcb);
        }
    }

    //
    // Mark the file object as having been cleaned up.
    //

    FileObject->Flags |= FO_CLEANUP_COMPLETE;

    //
    // Release the mutexes that we acquired above.
    //

    FatxReleaseVolumeMutex(VolumeExtension);

    if (FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY)) {
        FatxReleaseFileMutex(Fcb);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\devctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module implements routines related to handling IRP_MJ_DEVICE_CONTROL.

--*/

#include "fatx.h"

NTSTATUS
FatxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DEVICE_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    FatxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Set a completion routine to unlock the volume mutex.
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp, FatxVolumeIoCompletion, NULL, TRUE, TRUE,
        TRUE);

    //
    // Call down to the target device.
    //

    status = IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

    //
    // Leave the critical region that we acquired when we took the volume mutex.
    //

    KeLeaveCriticalRegion();

    return status;

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\driver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module implements routines that apply to the driver object including
    initialization and IRP dispatch routines.

--*/

#include "fatx.h"

//
// Driver object for the FAT file system.
//
DECLSPEC_RDATA DRIVER_OBJECT FatxDriverObject = {
    NULL,                               // DriverStartIo
    NULL,                               // DriverDeleteDevice
    FatxDismountVolume,                 // DriverDismountVolume
    {
        FatxFsdCreate,                  // IRP_MJ_CREATE
        FatxFsdClose,                   // IRP_MJ_CLOSE
        FatxFsdReadWrite,               // IRP_MJ_READ
        FatxFsdReadWrite,               // IRP_MJ_WRITE
        FatxFsdQueryInformation,        // IRP_MJ_QUERY_INFORMATION
        FatxFsdSetInformation,          // IRP_MJ_SET_INFORMATION
        FatxFsdFlushBuffers,            // IRP_MJ_FLUSH_BUFFERS
        FatxFsdQueryVolumeInformation,  // IRP_MJ_QUERY_VOLUME_INFORMATION
        FatxFsdDirectoryControl,        // IRP_MJ_DIRECTORY_CONTROL
        FatxFsdFileSystemControl,       // IRP_MJ_FILE_SYSTEM_CONTROL
        FatxFsdDeviceControl,           // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        FatxFsdCleanup,                 // IRP_MJ_CLEANUP
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\create.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements routines related to handling IRP_MJ_CREATE.

--*/

#include "fatx.h"

NTSTATUS
FatxLookupElementNameInDirectory(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN POBJECT_STRING ElementName,
    OUT PDIRENT ReturnedDirectoryEntry,
    OUT PULONG ReturnedDirectoryByteOffset,
    OUT PULONG ReturnedEmptyDirectoryByteOffset
    )
/*++

Routine Description:

    This routine looks up the supplied file name in the supplied directory
    file control block.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    ElementName - Specifies the name to search for in the directory.

    ReturnedDirectoryEntry - Specifies the buffer to receive the directory entry
        for the file if found.

    ReturnedDirectoryByteOffset - Specifies the buffer to receive the byte
        offset of the entry in the directory stream.

    ReturnedEmptyDirectoryByteOffset - Specifies the buffer to receive the byte
        offset of the first free directory empty.  The value is only meaningful
        if STATUS_OBJECT_NAME_NOT_FOUND is returned.  MAXULONG is returned if we
        don't find an empty slot before finding the end of the directory stream.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG EmptyDirectoryByteOffset;
    ULONG DirectoryByteOffset;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    PVOID CacheBuffer;
    PDIRENT DirectoryEntry;
    OBJECT_STRING DirectoryEntryFileName;
    ULONG ClusterNumber;
    ULONG ClusterBytesRemaining;
    PDIRENT EndingDirectoryEntry;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    CacheBuffer = NULL;
    EmptyDirectoryByteOffset = MAXULONG;

    //
    // If the directory byte offset lookup hint is non-zero, then the caller is
    // enumerating files in this directory.  To speed up opens for the file that
    // was last enumerated, we'll compare the directory entry at this byte
    // offset against the desired name.  If this fails, reset the hint so that
    // future lookups aren't impacted.
    //

    DirectoryByteOffset = DirectoryFcb->Directory.DirectoryByteOffsetLookupHint;

    if (DirectoryByteOffset != 0) {

        //
        // Get the physical byte offset corresponding to the file's directory
        // byte offset.
        //

        status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp,
            DirectoryFcb, DirectoryByteOffset, FALSE, &PhysicalByteOffset,
            &PhysicalRunLength);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Map the directory entry into the cache.
        //

        status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
            PhysicalByteOffset, FALSE, &CacheBuffer);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Check if the file name matches the name we're looking for.
        //

        DirectoryEntry = (PDIRENT)CacheBuffer;

        DirectoryEntryFileName.Length = DirectoryEntry->FileNameLength;
        DirectoryEntryFileName.Buffer = DirectoryEntry->FileName;

        if ((DirectoryEntryFileName.Length == ElementName->Length) &&
            (DirectoryEntryFileName.Length <= FAT_FILE_NAME_LENGTH) &&
            RtlEqualObjectString(&DirectoryEntryFileName, ElementName, TRUE)) {

            //
            // Copy the directory entry and its file byte offset back into the
            // caller's buffers.
            //

            *ReturnedDirectoryEntry = *DirectoryEntry;
            *ReturnedDirectoryByteOffset = DirectoryByteOffset;

            status = STATUS_SUCCESS;
            goto CleanupAndExit;
        }

        //
        // Unmap this cache buffer.
        //

        FscUnmapBuffer(CacheBuffer);
        CacheBuffer = NULL;

        //
        // Reset the directory byte offset lookup hint so that we don't keep
        // checking this specific directory entry.
        //

        DirectoryFcb->Directory.DirectoryByteOffsetLookupHint = 0;
        DirectoryByteOffset = 0;
    }

    //
    // Get the first cluster of the directory stream and validate it.
    //

    ClusterNumber = DirectoryFcb->FirstCluster;

    if (!FatxIsValidCluster(VolumeExtension, ClusterNumber)) {
        FatxDbgPrint(("FATX: invalid starting cluster for directory\n"));
        status = STATUS_FILE_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Process the directory stream.
    //

    for (;;) {

        //
        // Compute the physical byte offset of the next cluster and the number
        // of bytes remaining in this cluster.
        //

        PhysicalByteOffset = FatxClusterToPhysicalByteOffset(VolumeExtension,
            ClusterNumber);
        ClusterBytesRemaining = VolumeExtension->BytesPerCluster;

        //
        // The starting byte offset for the file area is always page aligned and
        // the cluster size is a multiple of the page size, so we can make some
        // optimizations below.
        //

        ASSERT(BYTE_OFFSET(PhysicalByteOffset) == 0);
        ASSERT(BYTE_OFFSET(ClusterBytesRemaining) == 0);

        do {

            //
            // Map in the next page of the cluster.
            //

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                PhysicalByteOffset, FALSE, &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }

            //
            // Process the directory entries on this cache buffer.
            //

            DirectoryEntry = (PDIRENT)CacheBuffer;
            EndingDirectoryEntry = (PDIRENT)((PUCHAR)CacheBuffer + PAGE_SIZE);

            do {

                //
                // If we've found the last directory entry in the stream or a
                // deleted directory entry, then save off its byte offset in
                // case we want to create a new entry.
                //

                if ((DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED) ||
                    (DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED2) ||
                    (DirectoryEntry->FileNameLength == FAT_DIRENT_DELETED)) {

                    if (EmptyDirectoryByteOffset == MAXULONG) {
                        EmptyDirectoryByteOffset = DirectoryByteOffset;
                    }
                }

                //
                // If we find a directory entry with a file name starting with
                // FAT_DIRENT_NEVER_USED or FAT_DIRENT_NEVER_USED2, then we're
                // at the end of the directory stream.
                //

                if ((DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED) ||
                    (DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED2)) {
                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                    goto CleanupAndExit;
                }

                //
                // Check if the file name matches the name we're looking for.
                //

                DirectoryEntryFileName.Length = DirectoryEntry->FileNameLength;
                DirectoryEntryFileName.Buffer = DirectoryEntry->FileName;

                if ((DirectoryEntryFileName.Length == ElementName->Length) &&
                    (DirectoryEntryFileName.Length <= FAT_FILE_NAME_LENGTH) &&
                    RtlEqualObjectString(&DirectoryEntryFileName, ElementName, TRUE)) {

                    //
                    // Copy the directory entry and its file byte offset back
                    // into the caller's buffers.
                    //

                    *ReturnedDirectoryEntry = *DirectoryEntry;
                    *ReturnedDirectoryByteOffset = DirectoryByteOffset;

                    status = STATUS_SUCCESS;
                    goto CleanupAndExit;
                }

                //
                // Advance to the next directory entry.
                //

                DirectoryEntry++;
                DirectoryByteOffset += sizeof(DIRENT);

            } while (DirectoryEntry < EndingDirectoryEntry);

            //
            // Unmap this cache buffer.
            //

            FscUnmapBuffer(CacheBuffer);
            CacheBuffer = NULL;

            //
            // Adjust the number of bytes remaining in this cluster and the next
            // cache byte offset.
            //

            PhysicalByteOffset += PAGE_SIZE;
            ClusterBytesRemaining -= PAGE_SIZE;

        } while (ClusterBytesRemaining > 0);

        //
        // Advance to the next cluster.
        //

        status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, DirectoryFcb,
            DirectoryByteOffset, &ClusterNumber, NULL);

        if (status == STATUS_END_OF_FILE) {
            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Don't allow a directory to exceed the maximum allowed directory size.
        // We check for this case after the call to FatxFileByteOffsetToCluster
        // so that a directory that's exactly the maximum allowed directory size
        // will properly fill its allocation size and ending cluster number for
        // the sake of code further downstream.
        //

        if (NT_SUCCESS(status) &&
            (DirectoryByteOffset >= FAT_MAXIMUM_DIRECTORY_FILE_SIZE)) {
            status = STATUS_FILE_CORRUPT_ERROR;
            goto CleanupAndExit;
        }
    }

CleanupAndExit:
    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

#if DBG
    //
    // We should only use the empty directory byte offset when we return
    // STATUS_OBJECT_NAME_NOT_FOUND.  For any other return code, return a bogus
    // direcotory byte offset so that we catch illegal uses of the byte offset.
    //

    if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
        EmptyDirectoryByteOffset = MAXULONG - 1;
    }
#endif

    *ReturnedEmptyDirectoryByteOffset = EmptyDirectoryByteOffset;

    return status;
}

NTSTATUS
FatxCheckDesiredAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    IN UCHAR FileAttributes,
    IN BOOLEAN CreatingFile
    )
/*++

Routine Description:

    This routine checks that the desired access mask is compatible with the
    supplied file attributes.  For example, a file that's marked read-only
    can't be opened for write access.

Arguments:

    DesiredAccess - Specifies the access rights that the caller would like for
        the file handle.

    CreateOptions - Specifies the options controlling how the file is to be
        created or opened.

    FileAttributes - Specifies the file attributes of the file to be opened.

    CreatingFile - Specifies whether or not we're in the process of creating a
        new file.

Return Value:

    Status of operation.

--*/
{
    //
    // Never allow a volume ID or device to be opened.
    //

    if (!FatxIsValidFileAttributes(FileAttributes)) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Check the access mask depending on whether this is a directory or not.
    //

    if (FatxIsFlagSet(FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

        if (FatxIsFlagSet(DesiredAccess, ~(DELETE | READ_CONTROL | WRITE_OWNER |
            WRITE_DAC | SYNCHRONIZE | ACCESS_SYSTEM_SECURITY | FILE_WRITE_DATA |
            FILE_READ_EA | FILE_WRITE_EA | FILE_READ_ATTRIBUTES |
            FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY | FILE_TRAVERSE |
            FILE_DELETE_CHILD | FILE_APPEND_DATA))) {
            return STATUS_ACCESS_DENIED;
        }

    } else {

        if (FatxIsFlagSet(DesiredAccess, ~(DELETE | READ_CONTROL | WRITE_OWNER |
            WRITE_DAC | SYNCHRONIZE | ACCESS_SYSTEM_SECURITY | FILE_READ_DATA |
            FILE_WRITE_DATA | FILE_READ_EA | FILE_WRITE_EA | FILE_READ_ATTRIBUTES |
            FILE_WRITE_ATTRIBUTES | FILE_EXECUTE | FILE_DELETE_CHILD |
            FILE_APPEND_DATA))) {
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // Check the access mask if this is a read-only file.
    //

    if (FatxIsFlagSet(FileAttributes, FILE_ATTRIBUTE_READONLY)) {

        if (!CreatingFile &&
            FatxIsFlagSet(DesiredAccess, ~(DELETE | READ_CONTROL | WRITE_OWNER |
            WRITE_DAC | SYNCHRONIZE | ACCESS_SYSTEM_SECURITY | FILE_READ_DATA |
            FILE_READ_EA | FILE_WRITE_EA | FILE_READ_ATTRIBUTES |
            FILE_WRITE_ATTRIBUTES | FILE_EXECUTE | FILE_LIST_DIRECTORY |
            FILE_TRAVERSE))) {
            return STATUS_ACCESS_DENIED;
        }

        if (FatxIsFlagSet(CreateOptions, FILE_DELETE_ON_CLOSE)) {
            return STATUS_CANNOT_DELETE;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FatxOpenTargetDirectory(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN ULONG FileExists,
    IN BOOLEAN NoReferenceCount
    )
/*++

Routine Description:

    This routine opens the supplied target directory for a rename operation.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block of the target directory to
        open.

    FileExists - Specifies the value, FILE_EXISTS or FILE_DOES_NOT_EXIST, that
        should be placed in the IRP's information field on success.

    NoReferenceCount - Specifies whether or not the reference count for
        the directory file control block should be incremented.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK DesiredAccess;
    USHORT ShareAccess;
    PFILE_OBJECT FileObject;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    DesiredAccess = IrpSp->Parameters.Create.DesiredAccess;
    ShareAccess = IrpSp->Parameters.Create.ShareAccess;
    FileObject = IrpSp->FileObject;

    //
    // It's possible for the file control block to be NULL if a file failed to
    // be moved from one directory to another.  In that case,
    // FatxSetRenameInformation sets the file's parent file control block to
    // NULL.
    //

    if (DirectoryFcb == NULL) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));

    //
    // If this is the first open handle to the file, then initialize the sharing
    // mode.  Otherwise, verify that the requested sharing mode is compatible
    // with the current sharing mode.
    //

    if (DirectoryFcb->ShareAccess.OpenCount == 0) {
        IoSetShareAccess(DesiredAccess, ShareAccess, FileObject,
            &DirectoryFcb->ShareAccess);
        status = STATUS_SUCCESS;
    } else {
        status = IoCheckShareAccess(DesiredAccess, ShareAccess, FileObject,
            &DirectoryFcb->ShareAccess, TRUE);
    }

    //
    // Fill in the file object with the file control block.
    //

    if (NT_SUCCESS(status)) {

        if (!NoReferenceCount) {
            DirectoryFcb->ReferenceCount++;
        }

        FileObject->FsContext = DirectoryFcb;
        FileObject->FsContext2 = NULL;

        VolumeExtension->FileObjectCount++;

        //
        // Indicate to the caller whether or not a file already exists with the
        // specified name.
        //

        Irp->IoStatus.Information = FileExists;

        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
FatxCreateNewFile(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN POBJECT_STRING ElementName,
    IN ULONG EmptyDirectoryByteOffset,
    IN UCHAR FileAttributes,
    IN ULONG AllocationSize,
    OUT PDIRENT DirectoryEntry,
    OUT PFAT_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine is called to create a new file or directory.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the directory to create the new file in.

    ElementName - Specifies the name of the file to create.

    EmptyDirectoryByteOffset - Specifies the byte offset of the first free
        directory entry or MAXULONG if there aren't any free entries in the
        directory.

    FileAttributes - Specifies the new attributes for the file.

    AllocationSize - Specifies the new allocation size for the file.

    DirectoryEntry - Specifies a local buffer that can be used to construct the
        directory entry.

    ReturnedFcb - Specifies the buffer to receive the created file control
        block.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS];
    ULONG NumberOfClusterRuns;
    ULONG FirstCluster;
    ULONG EndingCluster;
    LARGE_INTEGER CreationTime;
    PFAT_FCB Fcb;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));
    ASSERT(ElementName->Length != 0);
    ASSERT(ElementName->Length <= FAT_FILE_NAME_LENGTH);

    //
    // If there isn't an empty directory entry, then we'll need to add another
    // cluster to the directory.
    //

    if (EmptyDirectoryByteOffset == MAXULONG) {

        //
        // If we found the end of the directory stream, then we must have
        // established how many bytes are allocated to the file.
        //

        ASSERT(DirectoryFcb->AllocationSize != MAXULONG);

        //
        // The new directory empty will be placed at the start of the new
        // extension.
        //

        EmptyDirectoryByteOffset = DirectoryFcb->AllocationSize;

        //
        // Attempt to add another cluster to the directory's allocation.
        //

        status = FatxExtendDirectoryAllocation(VolumeExtension, Irp,
            DirectoryFcb);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // Figure out if we need to allocate some clusters to this file now or not.
    //

    if (FatxIsFlagSet(FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

        //
        // Allocate a single cluster.
        //

        status = FatxAllocateClusters(VolumeExtension, Irp, FAT_CLUSTER_NULL, 1,
            ClusterRuns, &NumberOfClusterRuns, &EndingCluster);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        ASSERT(NumberOfClusterRuns == 1);
        ASSERT(EndingCluster == ClusterRuns[0].PhysicalClusterNumber);

        FirstCluster = ClusterRuns[0].PhysicalClusterNumber;
        AllocationSize = VolumeExtension->BytesPerCluster;

        //
        // Initialize the contents of the directory cluster.
        //

        status = FatxInitializeDirectoryCluster(VolumeExtension, Irp, FirstCluster);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

    } else if (AllocationSize != 0) {

        //
        // Allocate the requested number of clusters.
        //

        AllocationSize = FatxRoundToClusters(VolumeExtension, AllocationSize);

        status = FatxAllocateClusters(VolumeExtension, Irp, FAT_CLUSTER_NULL,
            AllocationSize >> VolumeExtension->ClusterShift, ClusterRuns,
            &NumberOfClusterRuns, &EndingCluster);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        FirstCluster = ClusterRuns[0].PhysicalClusterNumber;

    } else {

        //
        // The file doesn't require an initial allocation.
        //

        FirstCluster = FAT_CLUSTER_NULL;
        EndingCluster = FAT_CLUSTER_NULL;
        NumberOfClusterRuns = 0;
        status = STATUS_SUCCESS;
    }

    //
    // Construct a copy of the new directory entry on the stack.
    //

    RtlZeroMemory(DirectoryEntry, sizeof(DIRENT));

    DirectoryEntry->FileNameLength = (UCHAR)ElementName->Length;

    RtlCopyMemory(DirectoryEntry->FileName, ElementName->Buffer,
        ElementName->Length);

    DirectoryEntry->FileAttributes = FileAttributes;
    DirectoryEntry->FirstCluster = FirstCluster;

    KeQuerySystemTime(&CreationTime);
    FatxTimeToFatTimestamp(&CreationTime, &DirectoryEntry->CreationTime);
    DirectoryEntry->LastWriteTime = DirectoryEntry->CreationTime;
    DirectoryEntry->LastAccessTime = DirectoryEntry->CreationTime;

    //
    // Construct a file control block for the desired file from the directory
    // entry on the stack.
    //

    status = FatxCreateFcb(DirectoryFcb, FirstCluster, DirectoryEntry,
        EmptyDirectoryByteOffset, &Fcb);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Commit the directory entry.
    //

    status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, Fcb);

    if (!NT_SUCCESS(status)) {
        FatxDereferenceFcb(Fcb);
        goto CleanupAndExit;
    }

    //
    // If the file or directory was given an initial allocation, then fill in
    // the allocation size and ending cluster number for the file control block.
    // Copy the allocated cluster runs into the file's cluster cache.
    //

    if (AllocationSize != 0) {

        ASSERT(Fcb->AllocationSize == MAXULONG);

        Fcb->AllocationSize = AllocationSize;
        Fcb->EndingCluster = EndingCluster;

        FatxAppendClusterRunsToClusterCache(Fcb, 0, ClusterRuns,
            NumberOfClusterRuns);

    } else {
        ASSERT(Fcb->AllocationSize == 0);
        ASSERT(Fcb->EndingCluster == FAT_CLUSTER_NULL);
    }

    *ReturnedFcb = Fcb;
    status = STATUS_SUCCESS;

CleanupAndExit:
    if (!NT_SUCCESS(status)) {
        FatxFreeClusters(VolumeExtension, Irp, FirstCluster, FALSE);
    }

    return status;
}

NTSTATUS
FatxOverwriteExistingFile(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN UCHAR FileAttributes,
    IN ULONG AllocationSize
    )
/*++

Routine Description:

    This routine is called to overwrite an existing file with the file having
    the supplied file attributes and allocation size.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileFcb - Specifies the file control block that describes the file to
        overwrite.

    FileAttributes - Specifies the new attributes for the file.

    AllocationSize - Specifies the new allocation size for the file.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    UCHAR OriginalFileAttributes;
    ULONG OriginalFileSize;
    LARGE_INTEGER OriginalLastWriteTime;
    FAT_TIME_STAMP OriginalCreationTime;
    FAT_TIME_STAMP OriginalLastAccessTime;

    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_DIRECTORY));

    //
    // Verify that the attributes don't try to change this file into a
    // directory.
    //

    if (FatxIsFlagSet(FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the file has already been opened, then we can't safely truncate the
    // file.  We hold the volume's mutex for exclusive access and would need to
    // acquire the file's mutex for exclusive access, but that's a violation of
    // our locking order.  Instead of trying to rearrange the code to fix the
    // locking order, treat this as a sharing violation.
    //
    // For the case of a reference count of exactly one, we know that no other
    // thread could have a reference to this file control block, so there's no
    // possibility that we can dead lock by acquiring the file's mutex for
    // exclusive access here.  We go to the effort of acquiring the file mutex
    // to satisfy the assertions in FatxSetAllocationSize.
    //

    if (FileFcb->ReferenceCount >= 2) {
        return STATUS_SHARING_VIOLATION;
    }

    FatxAcquireFileMutexExclusive(FileFcb);

    //
    // Save off the fields from the file control block that we're going to
    // change so that we can back out any changes if we fail below.
    //

    OriginalFileAttributes = FileFcb->FileAttributes;
    OriginalFileSize = FileFcb->FileSize;
    OriginalLastWriteTime = FileFcb->LastWriteTime;
    OriginalCreationTime = FileFcb->CreationTime;
    OriginalLastAccessTime = FileFcb->LastAccessTime;

    //
    // Fill in the file control block with the values for an overwritten file
    // and flag that the directory entry needs to be updated.
    //

    FileFcb->FileAttributes = FileAttributes;
    FileFcb->FileSize = 0;

    FileFcb->Flags &= ~FAT_FCB_DISABLE_LAST_WRITE_TIME;
    FileFcb->Flags |= FAT_FCB_UPDATE_DIRECTORY_ENTRY;

    KeQuerySystemTime(&FileFcb->LastWriteTime);
    FatxTimeToFatTimestamp(&FileFcb->LastWriteTime, &FileFcb->CreationTime);
    FileFcb->LastAccessTime = FileFcb->CreationTime;

    //
    // Set the allocation size for the file.  The directory entry may be updated
    // inside this call.
    //

    status = FatxSetAllocationSize(VolumeExtension, Irp, FileFcb, AllocationSize,
        TRUE, FALSE);

    //
    // If changing the allocation size for the file didn't cause the directory
    // entry to be updated, then do it here.
    //

    if (NT_SUCCESS(status) &&
        FatxIsFlagSet(FileFcb->Flags, FAT_FCB_UPDATE_DIRECTORY_ENTRY)) {
        status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);
    }

    //
    // If we failed for any reason, then restore the fields of the file control
    // block so that we still mirror the on-disk structures.
    //

    if (!NT_SUCCESS(status)) {
        FileFcb->FileAttributes = OriginalFileAttributes;
        FileFcb->FileSize = OriginalFileSize;
        FileFcb->LastWriteTime = OriginalLastWriteTime;
        FileFcb->CreationTime = OriginalCreationTime;
        FileFcb->LastAccessTime = OriginalLastAccessTime;
    }

    FatxReleaseFileMutex(FileFcb);

    return status;
}

NTSTATUS
FatxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CREATE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK DesiredAccess;
    UCHAR FileAttributes;
    USHORT ShareAccess;
    ULONG CreateOptions;
    ULONG CreateDisposition;
    PFILE_OBJECT FileObject;
    OBJECT_STRING RemainingName;
    PFILE_OBJECT RelatedFileObject;
    PFAT_FCB CurrentFcb;
    BOOLEAN TrailingBackslash;
    BOOLEAN CreateFcbCalled;
    OBJECT_STRING ElementName;
    DIRENT DirectoryEntry;
    ULONG DirectoryByteOffset;
    ULONG EmptyDirectoryByteOffset;
    PFAT_FCB FoundOrNewFcb;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    DesiredAccess = IrpSp->Parameters.Create.DesiredAccess;
    FileAttributes =
        (UCHAR)FatxFilterFileAttributes(IrpSp->Parameters.Create.FileAttributes);
    ShareAccess = IrpSp->Parameters.Create.ShareAccess;
    CreateOptions = IrpSp->Parameters.Create.Options;
    CreateDisposition = (CreateOptions >> 24) & 0xFF;
    FileObject = IrpSp->FileObject;
    RemainingName = *IrpSp->Parameters.Create.RemainingName;
    RelatedFileObject = FileObject->RelatedFileObject;

    //
    // Always grab the exclusive lock because we could end up writing to the
    // disk and we also use this lock to guard access to the file control block
    // and file control block list.
    //

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Don't allow a file to be opened based on its file ID.
    //

    if (FatxIsFlagSet(CreateOptions, FILE_OPEN_BY_FILE_ID)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // Verify that the initial file allocation size is limited to 32-bits.
    //

    if (Irp->Overlay.AllocationSize.HighPart != 0) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Determine whether we parse the file name from the root of the volume or
    // from a subdirectory by looking at RelatedFileObject.
    //

    if (RelatedFileObject != NULL) {

        //
        // Grab the file control block out of the related file object.
        //

        CurrentFcb = (PFAT_FCB)RelatedFileObject->FsContext;

        //
        // Verify that the related file object is really a directory object.
        // Note that the file control block could be NULL if the file object was
        // opened as a result of a direct device open in the I/O manager.
        //

        if ((CurrentFcb == NULL) ||
            FatxIsFlagClear(CurrentFcb->Flags, FAT_FCB_DIRECTORY)) {
            status = STATUS_INVALID_PARAMETER;
            goto CleanupAndExit;
        }

        //
        // If the directory is marked for deletion, then the directory won't
        // contain any files and it won't allow any files to be created, so bail
        // out now.  This also catches code that uses a directory file object
        // after its handle has been closed and the directory has been deleted,
        // such as for symbolic link objects.
        //

        if (FatxIsFlagSet(CurrentFcb->Flags, FAT_FCB_DELETE_ON_CLOSE)) {
            status = STATUS_DELETE_PENDING;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the related directory.
        //

        if (RemainingName.Length == 0) {

            if (FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
                status = FatxOpenTargetDirectory(VolumeExtension, Irp,
                    CurrentFcb->ParentFcb, FILE_EXISTS, FALSE);
                goto CleanupAndExit;
            }

            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }

        //
        // Verify that this is not an absolute path.
        //

        if (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

        //
        // Verify that the path doesn't exceed the length restictions.
        //

        if ((CurrentFcb->PathNameLength + sizeof(OBJ_NAME_PATH_SEPARATOR) +
            RemainingName.Length) > FAT_PATH_NAME_LIMIT * sizeof(OCHAR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

    } else {

        //
        // Check if we're supposed to open the physical volume.
        //

        if (RemainingName.Length == 0) {

            CurrentFcb = (PFAT_FCB)&VolumeExtension->VolumeFcb;

            //
            // Verify that the create disposition allows us to open an existing
            // file.
            //

            if ((CreateDisposition != FILE_OPEN) &&
                (CreateDisposition != FILE_OPEN_IF)) {
                status = STATUS_ACCESS_DENIED;
                goto CleanupAndExit;
            }

            //
            // The caller shouldn't be expecting to see a directory file.
            //

            if (FatxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
                status = STATUS_NOT_A_DIRECTORY;
                goto CleanupAndExit;
            }

            //
            // The physical volume cannot be deleted.
            //

            if (FatxIsFlagSet(CreateOptions, FILE_DELETE_ON_CLOSE)) {
                status = STATUS_CANNOT_DELETE;
                goto CleanupAndExit;
            }

            //
            // The physical volume cannot be renamed.
            //

            if (FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            //
            // Physical volume access is always non-cached.  Mark the file
            // object as non-cached so that the I/O manager enforces alignment
            // requirements.
            //

            FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;

            //
            // If this is the first open handle to the file, then initialize the
            // sharing mode.  Otherwise, verify that the requested sharing mode
            // is compatible with the current sharing mode.
            //

            if (CurrentFcb->ShareAccess.OpenCount == 0) {
                IoSetShareAccess(DesiredAccess, ShareAccess, FileObject,
                    &CurrentFcb->ShareAccess);
                status = STATUS_SUCCESS;
            } else {
                status = IoCheckShareAccess(DesiredAccess, ShareAccess,
                    FileObject, &CurrentFcb->ShareAccess, TRUE);
            }

            //
            // Fill in the file object with the file control block.
            //

            if (NT_SUCCESS(status)) {

                CurrentFcb->ReferenceCount++;

                FileObject->FsContext = CurrentFcb;
                FileObject->FsContext2 = NULL;

                VolumeExtension->FileObjectCount++;

                //
                // Indicate to the caller that we opened the file as opposed to creating
                // or overwriting the file.
                //

                Irp->IoStatus.Information = FILE_OPENED;

                status = STATUS_SUCCESS;
            }

            goto CleanupAndExit;
        }

        //
        // Start searching relative to the root directory.
        //

        CurrentFcb = VolumeExtension->RootDirectoryFcb;

        //
        // Verify that this is an absolute path.
        //

        if (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the root directory.
        //

        if (RemainingName.Length == sizeof(OCHAR)) {

            //
            // The root directory cannot be renamed.
            //

            if (FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }

        //
        // Verify that the path doesn't exceed the length restictions.
        //

        if (RemainingName.Length > FAT_PATH_NAME_LIMIT * sizeof(OCHAR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }
    }

    //
    // Check if the file name ends in a backslash.  If so, strip it off and set
    // a flag so that we can later verify that the target file is a directory.
    //
    // We've already checked for an empty file name or a file name that consists
    // of a single backslash above, so we know that before and after this check
    // that the remaining name will still have some characters in it.
    //

    ASSERT(RemainingName.Length > 0);

    if (RemainingName.Buffer[(RemainingName.Length / sizeof(OCHAR)) - 1] ==
        OBJ_NAME_PATH_SEPARATOR) {
        RemainingName.Length -= sizeof(OCHAR);
        TrailingBackslash = TRUE;
    } else {
        TrailingBackslash = FALSE;
    }

    ASSERT(RemainingName.Length > 0);

    //
    // Process the file name.  At this point, we're only walking the open file
    // control block list.
    //

    for (;;) {

        //
        // Pull off the next element of the file name.
        //

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        //
        // Verify that there aren't multiple backslashes in the name.
        //

        if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
            OBJ_NAME_PATH_SEPARATOR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            break;
        }

        //
        // Check if a file control block already exists for this file name.
        //

        if (!FatxFindOpenChildFcb(CurrentFcb, &ElementName, &FoundOrNewFcb)) {
            break;
        }

        CurrentFcb = FoundOrNewFcb;

        //
        // If we have consumed the entire name, then the file is already open.
        // Bump up the reference count and skip past the on-disk search loop.
        //

        if (RemainingName.Length == 0) {

            if (FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
                status = FatxOpenTargetDirectory(VolumeExtension, Irp,
                    CurrentFcb->ParentFcb, FILE_EXISTS, FALSE);
                goto CleanupAndExit;
            }

            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenCurrentFcb;
        }
    }

    //
    // Continue processing the file name.  At this point, we're searching
    // directory streams for the requested file.
    //

    CreateFcbCalled = FALSE;

    do {

        //
        // On the first iteration of the loop, we've already dissected the name
        // we're looking for so don't dissect another piece of the name.
        //

        if (CreateFcbCalled) {

            //
            // Pull off the next element of the file name.
            //

            ObDissectName(RemainingName, &ElementName, &RemainingName);

            //
            // Verify that there aren't multiple backslashes in the name.
            //

            if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
                OBJ_NAME_PATH_SEPARATOR)) {
                status = STATUS_OBJECT_NAME_INVALID;
                break;
            }
        }

        //
        // Check if the name is a legal FAT file name.
        //

        if (!FatxIsValidFatFileName(&ElementName)) {
            status = STATUS_OBJECT_NAME_INVALID;
            break;
        }

        //
        // Lookup the element in the directory.
        //

        status = FatxLookupElementNameInDirectory(VolumeExtension, Irp,
            CurrentFcb, &ElementName, &DirectoryEntry, &DirectoryByteOffset,
            &EmptyDirectoryByteOffset);

        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // If the element wasn't found and we still have more elements to
            // process, then the path was not found.
            //

            if (RemainingName.Length != 0) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                break;
            }

            //
            // If the parent directory is marked for deletion, don't allow any
            // files to be created.
            //

            if (FatxIsFlagSet(CurrentFcb->Flags, FAT_FCB_DELETE_ON_CLOSE)) {
                status = STATUS_DELETE_PENDING;
                break;
            }

            //
            // If we're inside a move file operation, then call the helper to
            // open the target directory and indicate that the file doesn't
            // already exist.
            //

            if (FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {

                status = FatxOpenTargetDirectory(VolumeExtension, Irp,
                    CurrentFcb, FILE_DOES_NOT_EXIST, CreateFcbCalled);

                if (NT_SUCCESS(status)) {
                    goto CleanupAndExit;
                }

                break;
            }

            //
            // If the create disposition doesn't allow us to create files, then
            // we're done.
            //

            if ((CreateDisposition == FILE_OPEN) ||
                (CreateDisposition == FILE_OVERWRITE)) {
                break;
            }

            //
            // Don't allow a trailing backslash to be mixed with a request to
            // create a non-directory file.
            //

            if (TrailingBackslash &&
                FatxIsFlagSet(CreateOptions, FILE_NON_DIRECTORY_FILE)) {
                status = STATUS_OBJECT_NAME_INVALID;
                break;
            }

            //
            // Ensure that the directory file attribute is set or clear
            // depending on the creation options.
            //

            if (FatxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
                FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
            } else {
                FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
            }

            //
            // Verify that the desired access is compatible with the file's
            // desired attributes.
            //

            status = FatxCheckDesiredAccess(DesiredAccess, CreateOptions,
                FileAttributes, TRUE);

            if (!NT_SUCCESS(status)) {
                break;
            }

            //
            // Create the new file.
            //

            status = FatxCreateNewFile(VolumeExtension, Irp, CurrentFcb,
                &ElementName, EmptyDirectoryByteOffset, FileAttributes,
                Irp->Overlay.AllocationSize.LowPart, &DirectoryEntry,
                &FoundOrNewFcb);

            if (!NT_SUCCESS(status)) {
                break;
            }

            //
            // If this is the second or greater iteration of this loop, then we want
            // want to release the reference to the parent directory from
            // FatxCreateNewFile.  The parent directory already has a reference count
            // of one from when we created that file control block.
            //

            if (CreateFcbCalled) {
                ASSERT(CurrentFcb->ReferenceCount >= 2);
                CurrentFcb->ReferenceCount--;
            }

            //
            // Initializing the sharing mode.
            //

            IoSetShareAccess(DesiredAccess, ShareAccess, FileObject,
                &FoundOrNewFcb->ShareAccess);

            //
            // Fill in the file object with the file control block that we
            // created.
            //

            FileObject->FsContext = FoundOrNewFcb;
            FileObject->FsContext2 = NULL;

            VolumeExtension->FileObjectCount++;

            //
            // Apply the delete on close flag if necessary.
            //

            if (FatxIsFlagSet(CreateOptions, FILE_DELETE_ON_CLOSE) &&
                FatxIsFlagClear(FoundOrNewFcb->Flags, FAT_FCB_DIRECTORY)) {
                FoundOrNewFcb->Flags |= FAT_FCB_DELETE_ON_CLOSE;
            }

            //
            // Indicate to the caller that we created a new file as opposed to
            // opening an existing file.
            //

            Irp->IoStatus.Information = FILE_CREATED;

            status = STATUS_SUCCESS;
            goto CleanupAndExit;

        } else if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // If there's still more of a path name to process, then verify that the
        // file we found is a directory.
        //

        if ((RemainingName.Length != 0) &&
            FatxIsFlagClear(DirectoryEntry.FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
            break;
        }

        //
        // If there's no more path name to process and we're opening the file
        // for a rename operation, then call the helper to open the target
        // directory and indicate that the file already exists.
        //

        if ((RemainingName.Length == 0) &&
            FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {

            status = FatxOpenTargetDirectory(VolumeExtension, Irp, CurrentFcb,
                FILE_EXISTS, CreateFcbCalled);

            if (NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }

            break;
        }

        //
        // The file isn't already open.  Construct a new file control block
        // for this file.
        //

        status = FatxCreateFcb(CurrentFcb, DirectoryEntry.FirstCluster,
            &DirectoryEntry, DirectoryByteOffset, &FoundOrNewFcb);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // If this is the second or greater iteration of this loop, then we want
        // to release the reference to the parent directory from FatxCreateFcb.
        // The parent directory already has a reference count of one from when
        // we created that file control block.
        //

        if (CreateFcbCalled) {
            ASSERT(CurrentFcb->ReferenceCount >= 2);
            CurrentFcb->ReferenceCount--;
        }

        CreateFcbCalled = TRUE;
        CurrentFcb = FoundOrNewFcb;

    } while (RemainingName.Length != 0);

    //
    // If we failed to open the file, then before bailing out, we may need to
    // dereference the current file control block.  If we haven't created any
    // file control blocks, then there's no file control blocks to clean up.
    //

    if (!NT_SUCCESS(status)) {

        if (CreateFcbCalled) {
            FatxDereferenceFcb(CurrentFcb);
        }

        goto CleanupAndExit;
    }

    //
    // If the caller is expecting to open only a file or directory file, then
    // verify that the file type matches.
    //

OpenCurrentFcb:
    if (FatxIsFlagSet(CurrentFcb->Flags, FAT_FCB_DIRECTORY)) {

OpenStartDirectoryFcb:
        if ((CreateDisposition != FILE_OPEN) &&
            (CreateDisposition != FILE_OPEN_IF)) {
            status = STATUS_OBJECT_NAME_COLLISION;
        } else if (FatxIsFlagSet(CreateOptions, FILE_NON_DIRECTORY_FILE)) {
            status = STATUS_FILE_IS_A_DIRECTORY;
        }

    } else {

        if (CreateDisposition == FILE_CREATE) {
            status = STATUS_OBJECT_NAME_COLLISION;
        } else if (TrailingBackslash ||
            FatxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
            status = STATUS_NOT_A_DIRECTORY;
        }
    }

    //
    // By the time we get here, we should have already handled the flag that
    // indicates a move file operation.
    //

    ASSERT(FatxIsFlagClear(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY));

    //
    // Verify that the desired access is compatible with the file's attributes.
    //

    if (NT_SUCCESS(status)) {
        status = FatxCheckDesiredAccess(DesiredAccess, CreateOptions,
            CurrentFcb->FileAttributes, FALSE);
    }

    //
    // If this is the first open handle to the file, then initialize the sharing
    // mode.  Otherwise, verify that the requested sharing mode is compatible
    // with the current sharing mode.
    //

    if (NT_SUCCESS(status)) {

        if (CurrentFcb->ShareAccess.OpenCount == 0) {
            IoSetShareAccess(DesiredAccess, ShareAccess, FileObject,
                &CurrentFcb->ShareAccess);
        } else {
            status = IoCheckShareAccess(DesiredAccess, ShareAccess,
                FileObject, &CurrentFcb->ShareAccess, TRUE);
        }
    }

    //
    // Check if we should overwrite or open the existing file.
    //

    if (NT_SUCCESS(status)) {

        if ((CreateDisposition == FILE_SUPERSEDE) ||
            (CreateDisposition == FILE_OVERWRITE) ||
            (CreateDisposition == FILE_OVERWRITE_IF)) {

            //
            // The code above has already verified that CreateDisposition is
            // either FILE_OPEN or FILE_OPEN_IF for directories.
            //

            ASSERT(FatxIsFlagClear(CurrentFcb->Flags, FAT_FCB_DIRECTORY));

            status = FatxOverwriteExistingFile(VolumeExtension, Irp, CurrentFcb,
                FileAttributes, Irp->Overlay.AllocationSize.LowPart);

            if (NT_SUCCESS(status)) {

                //
                // Indicate to the caller that we overwrote an existing file as
                // opposed to creating the file.
                //

                Irp->IoStatus.Information = FILE_OVERWRITTEN;

            } else {

                //
                // Cleanup the sharing mode associated with the file object;
                // we're going to be failing this creation.
                //

                IoRemoveShareAccess(FileObject, &CurrentFcb->ShareAccess);
            }

        } else {

            //
            // Indicate to the caller that we opened the file as opposed to
            // creating or overwriting the file.
            //

            Irp->IoStatus.Information = FILE_OPENED;
        }
    }

    //
    // Fill in the file object with the file control block that we created.
    //

    if (NT_SUCCESS(status)) {

        FileObject->FsContext = CurrentFcb;
        FileObject->FsContext2 = NULL;

        VolumeExtension->FileObjectCount++;

        //
        // Apply the delete on close flag if necessary.
        //

        if (FatxIsFlagSet(CreateOptions, FILE_DELETE_ON_CLOSE) &&
            FatxIsFlagClear(CurrentFcb->Flags, FAT_FCB_DIRECTORY)) {
            CurrentFcb->Flags |= FAT_FCB_DELETE_ON_CLOSE;
        }

        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    //
    // If we reach this point, then we're going to be failing the call so
    // cleanup any file control block we're still holding on to.
    //

    FatxDereferenceFcb(CurrentFcb);

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\fat.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    fat.h

Abstract:

    This module defines the on-disk structure of the FAT file system.

--*/

#ifndef _FAT_
#define _FAT_

#include <pshpack1.h>

//
// Define the length of the volume name stored in the FAT volume metadata block.
// This includes one character for storing a null terminator.  This should be
// equal to MAX_MUNAME (from xbox.h).
//

#define FAT_VOLUME_NAME_LENGTH          32

//
// Defines the length of region reserved for online related data.
//

#define FAT_ONLINE_DATA_LENGTH          2048

//
// Define the structure of the FAT volume metadata block.  The metadata block
// is at physical byte offset zero of the volume.  The metadata block is either
// 4096 bytes or one device sector in length, whichever is greater.
//

typedef struct _FAT_VOLUME_METADATA {
    ULONG Signature;
    ULONG SerialNumber;
    ULONG SectorsPerCluster;
    ULONG RootDirFirstCluster;
    WCHAR VolumeName[FAT_VOLUME_NAME_LENGTH];
    UCHAR OnlineData[FAT_ONLINE_DATA_LENGTH];
    // Unused space in the block is filled with 0xFF bytes.
} FAT_VOLUME_METADATA, *PFAT_VOLUME_METADATA;

//
// Define the volume signature value contained in the volume metadata block.
//

#define FAT_VOLUME_SIGNATURE            'XTAF'

//
// The first entry of the FAT is reserved in order to catch media errors that
// cause part of the FAT to be zeroed out.
//

#define FAT_RESERVED_FAT_ENTRIES        1

//
// The following constants the are the valid FAT index values.
//

#define FAT_CLUSTER_AVAILABLE           (ULONG)0x00000000
#define FAT_CLUSTER_RESERVED            (ULONG)0xfffffff0
#define FAT_CLUSTER_BAD                 (ULONG)0xfffffff7
#define FAT_CLUSTER_MEDIA               (ULONG)0xfffffff8
#define FAT_CLUSTER_LAST                (ULONG)0xffffffff

#define FAT_CLUSTER16_AVAILABLE         (USHORT)0x0000
#define FAT_CLUSTER16_RESERVED          (USHORT)0xfff0
#define FAT_CLUSTER16_BAD               (USHORT)0xfff7
#define FAT_CLUSTER16_MEDIA             (USHORT)0xfff8
#define FAT_CLUSTER16_LAST              (USHORT)0xffff

#define FAT_CLUSTER_NULL                (ULONG)0

//
// FAT files have the following time/date structures.
//

typedef union _FAT_TIME_STAMP {
    struct {
        USHORT DoubleSeconds : 5;
        USHORT Minute        : 6;
        USHORT Hour          : 5;
        USHORT Day           : 5;
        USHORT Month         : 4;
        USHORT Year          : 7; // Relative to 2000
    };
    ULONG AsULONG;
} FAT_TIME_STAMP;
typedef FAT_TIME_STAMP *PFAT_TIME_STAMP;

//
// FAT files have the following name length.
//

#define FAT_FILE_NAME_LENGTH            255

//
// FAT paths have the following name limit.
//

#define FAT_PATH_NAME_LIMIT             255

//
// The directory entry record exists for every file/directory on the
// disk except for the root directory.
//

typedef struct _DIRENT {
    UCHAR FileNameLength;                           // offset 0x00
    UCHAR FileAttributes;                           // offset 0x01
    UCHAR FileName[FAT_FILE_NAME_LENGTH];           // offset 0x02
    ULONG FirstCluster;                             // offset 0x2C
    ULONG FileSize;                                 // offset 0x30
    FAT_TIME_STAMP CreationTime;                    // offset 0x34
    FAT_TIME_STAMP LastWriteTime;                   // offset 0x38
    FAT_TIME_STAMP LastAccessTime;                  // offset 0x3C
} DIRENT, *PDIRENT;                                 // sizeof = 64

//
// The first byte of a dirent describes the dirent.
//

#define FAT_DIRENT_NEVER_USED           0x00
#define FAT_DIRENT_DELETED              0xE5
#define FAT_DIRENT_NEVER_USED2          0xFF

//
// FAT directories have the following file size restriction.  The restriction
// helps to avoid circular FAT corruption (directories don't track the file
// size in their directory entry) and to ensure that titles don't create a
// directory structure that's slow to search.
//

#define FAT_MAXIMUM_DIRECTORY_FILE_SIZE (4096 * sizeof(DIRENT))

#include <poppack.h>

#endif // _FAT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\fatsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fatsup.c

Abstract:

    This module implements FAT file system utility routines.

--*/

#include "fatx.h"

//
// A condensed table of legal fat character values
//
const ULONG FatxFatIllegalTable[] = {
    0xffffffff,
    0xfc009c04,
    0x10000000,
    0x10000000,
    0x00000000,
    0x00000000,
    0x00000000,
    0x00000000,
};

BOOLEAN
FatxIsValidFatFileName(
    IN POBJECT_STRING FileName
    )
/*++

Routine Description:

    This routine checks if the supplied file name is a legal FAT file name

Arguments:

    FileName - Specifies the buffer to check for validity.

Return Value:

    Returns TRUE if the string is valid, else FALSE.

--*/
{
    POSTR Buffer;
    POSTR EndingBuffer;
    OCHAR Char;

    //
    // If the file name is zero or too long, then the name is not valid.
    //

    if ((FileName->Length == 0) || (FileName->Length > FAT_FILE_NAME_LENGTH)) {
        return FALSE;
    }

    //
    // Perform some preliminary checks if the name begins with a period.
    //

    Buffer = FileName->Buffer;
    EndingBuffer = Buffer + FileName->Length / sizeof(OCHAR);

    if (*Buffer == '.') {

        //
        // If the name is "." or "..", then the name is not valid.
        //

        if ((FileName->Length == sizeof(OCHAR)) ||
            (FileName->Length == sizeof(OCHAR) * 2) && (*(Buffer + 1) == '.')) {
            return FALSE;
        }
    }

    //
    // Process the rest of the file name.
    //

    while (Buffer < EndingBuffer) {

        Char = *Buffer++;

        //
        // Check for illegal FAT characters.
        //

        if (FatxFatIllegalTable[Char >> 5] & (1 << (Char & 31))) {
            return FALSE;
        }
    }

    return TRUE;
}

LARGE_INTEGER
FatxFatTimestampToTime(
    IN PFAT_TIME_STAMP FatTimestamp
    )
/*++

Routine Description:

    This routine converts a FAT timestamp to a NT system time.

Arguments:

    FatTimestamp - Specifies the timestamp to convert to NT system time.

Return Value:

    Conversion to NT system time.

--*/
{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeField;

    TimeField.Year = (USHORT)(FatTimestamp->Year + 2000);
    TimeField.Month = FatTimestamp->Month;
    TimeField.Day = FatTimestamp->Day;
    TimeField.Hour = FatTimestamp->Hour;
    TimeField.Minute = FatTimestamp->Minute;
    TimeField.Second = (USHORT)(FatTimestamp->DoubleSeconds * 2);
    TimeField.Milliseconds = 0;

    if (!RtlTimeFieldsToTime(&TimeField, &SystemTime)) {
        SystemTime.QuadPart = 0;
    }

    return SystemTime;
}

LOGICAL
FatxTimeToFatTimestamp(
    IN PLARGE_INTEGER Time,
    OUT PFAT_TIME_STAMP FatTimestamp
    )
/*++

Routine Description:

    This routine converts a NT system time to a FAT timestamp.

Arguments:

    Time - Specifies the NT system time.

    FatTimestamp - Specifies the buffer to receive the FAT timestamp.

Return Value:

    Returns TRUE if the time could be converted to a valid FAT time, else FALSE.

--*/
{

    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeField;

    //
    // Round the time up to the nearest double second.
    //

    LocalTime.QuadPart = Time->QuadPart + (2 * 1000 * 1000 * 10 - 1);

    RtlTimeToTimeFields(&LocalTime, &TimeField);

    FatTimestamp->Year = (USHORT)(TimeField.Year - 2000);
    FatTimestamp->Month = TimeField.Month;
    FatTimestamp->Day = TimeField.Day;
    FatTimestamp->Hour = TimeField.Hour;
    FatTimestamp->Minute = TimeField.Minute;
    FatTimestamp->DoubleSeconds = (USHORT)(TimeField.Second >> 1);

    return (TimeField.Year >= 2000) && (TimeField.Year <= 2000 + 127);
}

LARGE_INTEGER
FatxRoundToFatTime(
    IN PLARGE_INTEGER Time
    )
/*++

Routine Description:

    This routine rounds a NT system time to FAT granularity (two seconds).

Arguments:

    Time - Specifies the NT system time.

Return Value:

    Rounded NT system time.

--*/
{
    FAT_TIME_STAMP FatTimestamp;

    //
    // Convert the time to a FAT timestamp and back.
    //

    if ((Time->QuadPart != 0) && FatxTimeToFatTimestamp(Time, &FatTimestamp)) {
        return FatxFatTimestampToTime(&FatTimestamp);
    } else {
        return *Time;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\dirctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    dirctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_DIRECTORY_CONTROL.

--*/

#include "fatx.h"

NTSTATUS
FatxFindNextDirectoryEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN ULONG DirectoryByteOffset,
    IN POBJECT_STRING TemplateFileName,
    OUT PDIRENT ReturnedDirectoryEntry,
    OUT PULONG ReturnedDirectoryByteOffset
    )
/*++

Routine Description:

    This routine finds the next directory entry that matches the query template
    specification.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    DirectoryByteOffset - Specifies the directory byte offset to start scanning
        from.

    TemplateFileName - Specifies the optional file name to match.

    ReturnedDirectoryEntry - Specifies the buffer to receive the directory entry
        for the file if found.

    ReturnedDirectoryByteOffset - Specifies the buffer to receive the byte
        offset of the entry in the directory stream.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID CacheBuffer;
    ULONG ClusterNumber;
    LONG FileNameLengthLimit;
    ULONGLONG PhysicalByteOffset;
    ULONG ClusterBytesRemaining;
    ULONG ClusterByteOffset;
    ULONG PageBytesRemaining;
    PDIRENT DirectoryEntry;
    PDIRENT EndingDirectoryEntry;
    OBJECT_STRING DirectoryEntryFileName;

    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    CacheBuffer = NULL;

    //
    // If we're in the first cluster, then we can skip accessing the cluster
    // cache and go directly to the first cluster.  Otherwise, we need to go
    // through the cluster cache to map the current byte offset to the cluster
    // number.
    //

    if (DirectoryByteOffset < VolumeExtension->BytesPerCluster) {

        //
        // Get the first cluster of the directory stream and validate it.
        //

        ClusterNumber = DirectoryFcb->FirstCluster;

        if (!FatxIsValidCluster(VolumeExtension, ClusterNumber)) {
            FatxDbgPrint(("FATX: invalid starting cluster for directory\n"));
            status = STATUS_FILE_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

    } else {

        //
        // Get the cluster number corresponding to the current byte offset.
        //

        status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, DirectoryFcb,
            DirectoryByteOffset, &ClusterNumber, NULL);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }
    }

    //
    // Compute the longest file name that we'll allow to be enumerated.  If the
    // directory's path name length is near FAT_PATH_NAME_LIMIT, then we don't
    // want to return names that would cause us to overflow that limit.
    //

    FileNameLengthLimit = FAT_PATH_NAME_LIMIT - (DirectoryFcb->PathNameLength +
        sizeof(OBJ_NAME_PATH_SEPARATOR));

    if (FileNameLengthLimit > FAT_FILE_NAME_LENGTH) {
        FileNameLengthLimit = FAT_FILE_NAME_LENGTH;
    } else if (FileNameLengthLimit <= 0) {
        status = STATUS_END_OF_FILE;
        goto CleanupAndExit;
    }

    //
    // Process the directory stream.
    //

    for (;;) {

        //
        // Compute the physical byte offset of the next cluster and the number
        // of bytes remaining in this cluster.
        //

        PhysicalByteOffset = FatxClusterToPhysicalByteOffset(VolumeExtension,
            ClusterNumber);
        ClusterBytesRemaining = VolumeExtension->BytesPerCluster;

        //
        // If the directory byte offset is not cluster aligned, then bump up the
        // physical byte offset and reduce the number of bytes remaining by the
        // number of misaligned bytes.
        //

        ClusterByteOffset = FatxByteOffsetIntoCluster(VolumeExtension,
            DirectoryByteOffset);
        PhysicalByteOffset += ClusterByteOffset;
        ClusterBytesRemaining -= ClusterByteOffset;

        do {

            //
            // Map in the next page of the cluster.
            //

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                PhysicalByteOffset, FALSE, &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }

            //
            // Compute the number of bytes remaining on this cache buffer.
            //

            PageBytesRemaining = PAGE_SIZE - BYTE_OFFSET(PhysicalByteOffset);

            //
            // Adjust the number of bytes remaining in this cluster and the next
            // cache byte offset depending on whether we're near the end of the
            // cluster or not.
            //

            if (PageBytesRemaining < ClusterBytesRemaining) {
                ClusterBytesRemaining -= PageBytesRemaining;
                PhysicalByteOffset += PageBytesRemaining;
            } else {
                PageBytesRemaining = ClusterBytesRemaining;
                ClusterBytesRemaining = 0;
            }

            //
            // Process the directory entries on this cache buffer.
            //

            DirectoryEntry = (PDIRENT)CacheBuffer;
            EndingDirectoryEntry = (PDIRENT)((PUCHAR)DirectoryEntry +
                PageBytesRemaining);

            do {

                //
                // If we find a directory entry with a file name starting with
                // FAT_DIRENT_NEVER_USED or FAT_DIRENT_NEVER_USED2, then we're
                // at the end of the directory stream.
                //

                if ((DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED) ||
                    (DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED2)) {
                    status = STATUS_END_OF_FILE;
                    goto CleanupAndExit;
                }

                //
                // Check if the file name matches the name we're looking for.
                //
                // Make sure that the file name is legal so that we don't return
                // names to the caller that FatxFsdCreate will fail to locate.
                //

                DirectoryEntryFileName.Length = DirectoryEntry->FileNameLength;
                DirectoryEntryFileName.Buffer = DirectoryEntry->FileName;

                if ((DirectoryEntry->FileNameLength <= (ULONG)FileNameLengthLimit) &&
                    FatxIsValidFileAttributes(DirectoryEntry->FileAttributes) &&
                    FatxIsValidFatFileName(&DirectoryEntryFileName) &&
                    ((TemplateFileName->Buffer == NULL) ||
                    IoIsNameInExpression(TemplateFileName, &DirectoryEntryFileName))) {

                    //
                    // Copy the directory entry and its file byte offset back
                    // into the caller's buffers.
                    //

                    *ReturnedDirectoryEntry = *DirectoryEntry;
                    *ReturnedDirectoryByteOffset = DirectoryByteOffset;

                    status = STATUS_SUCCESS;
                    goto CleanupAndExit;
                }

                //
                // Advance to the next directory entry.
                //

                DirectoryEntry++;
                DirectoryByteOffset += sizeof(DIRENT);

            } while (DirectoryEntry < EndingDirectoryEntry);

            //
            // Unmap this cache buffer.
            //

            FscUnmapBuffer(CacheBuffer);
            CacheBuffer = NULL;

        } while (ClusterBytesRemaining > 0);

        //
        // Advance to the next cluster.
        //

        status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, DirectoryFcb,
            DirectoryByteOffset, &ClusterNumber, NULL);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Don't allow a directory to exceed the maximum allowed directory size.
        // We check for this case after the call to FatxFileByteOffsetToCluster
        // so that a directory that's exactly the maximum allowed directory size
        // will properly fill its allocation size and ending cluster number for
        // the sake of code further downstream.
        //

        if (NT_SUCCESS(status) &&
            (DirectoryByteOffset >= FAT_MAXIMUM_DIRECTORY_FILE_SIZE)) {
            status = STATUS_FILE_CORRUPT_ERROR;
            goto CleanupAndExit;
        }
    }

CleanupAndExit:
    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

    return status;
}

NTSTATUS
FatxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DIRECTORY_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFAT_FCB DirectoryFcb;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    POBJECT_STRING TemplateFileName;
    ULONG FileInformationClass;
    SIZE_T FileInformationBaseLength;
    BOOLEAN InitialQuery;
    DIRENT DirectoryEntry;
    ULONG DirectoryByteOffset;
    PFILE_DIRECTORY_INFORMATION DirectoryInformation;
    ULONG FileNameBytesToCopy;
    ULONG OutputBytesRemaining;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    DirectoryFcb = (PFAT_FCB)FileObject->FsContext;

    //
    // Synchronize the creation and access of the directory context control
    // block by acquiring the exclusive mutex for the volume.
    //

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Ensure that the file object is for a directory.
    //

    if (FatxIsFlagClear(DirectoryFcb->Flags, FAT_FCB_DIRECTORY)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // If the directory is marked for deletion, then the directory won't contain
    // any files and it won't allow any files to be created, so bail out now.
    // This also catches code that uses a directory file object after its handle
    // has been closed and the directory has been deleted, such as for symbolic
    // link objects.
    //

    if (FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DELETE_ON_CLOSE)) {
        status = STATUS_DELETE_PENDING;
        goto CleanupAndExit;
    }

    //
    // Verify that this is a supported information class.
    //

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;

    switch (FileInformationClass) {

        case FileDirectoryInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_DIRECTORY_INFORMATION,
                FileName[0]);
            break;

        case FileNamesInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_NAMES_INFORMATION,
                FileName[0]);
            break;

        default:
            status = STATUS_INVALID_INFO_CLASS;
            goto CleanupAndExit;
    }

    //
    // The query cannot be started relative to a starting index.
    //

    if (FatxIsFlagSet(IrpSp->Flags, SL_INDEX_SPECIFIED)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // If this is the first query for this directory, then allocate a directory
    // context control block and initialize it.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext == NULL) {

        TemplateFileName = IrpSp->Parameters.QueryDirectory.FileName;

        status = IoCreateDirectoryEnumContext(TemplateFileName,
            &DirectoryEnumContext);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Connect the directory enumeration context to the file object.
        //

        FileObject->FsContext2 = DirectoryEnumContext;

        InitialQuery = TRUE;

    } else {

        InitialQuery = FALSE;
    }

    //
    // If we're to restart the directory scan, then reset the current index to
    // zero.
    //

    if (FatxIsFlagSet(IrpSp->Flags, SL_RESTART_SCAN)) {
        DirectoryEnumContext->QueryOffset = 0;
    }

    //
    // Find the next directory entry that matches our query criteria.
    //
    // On return, DirectoryEnumContext->QueryOffset still points at the original
    // identifier.  It's only updated after we're about to successfully return
    // so that no entries are lost in the event of an invalid parameter or pool
    // allocation failure.
    //

    status = FatxFindNextDirectoryEntry(VolumeExtension, Irp, DirectoryFcb,
        DirectoryEnumContext->QueryOffset,
        &DirectoryEnumContext->TemplateFileName, &DirectoryEntry,
        &DirectoryByteOffset);

    if (NT_SUCCESS(status)) {

        //
        // The I/O manager has already checked that the user's buffer has enough
        // space to contain at least the header.
        //

        ASSERT(IrpSp->Parameters.QueryDirectory.Length >= FileInformationBaseLength);

        //
        // Zero out the header.
        //

        DirectoryInformation = (PFILE_DIRECTORY_INFORMATION)Irp->UserBuffer;
        RtlZeroMemory(DirectoryInformation, FileInformationBaseLength);

        //
        // For FileDirectoryInformation and FileNamesInformation, the
        // FileNameLength field is immediately before the FileName buffer.
        //

        *((PULONG)((PUCHAR)DirectoryInformation + FileInformationBaseLength -
            sizeof(ULONG))) = DirectoryEntry.FileNameLength;

        //
        // If this is a FileDirectoryInformation request, then fill in more
        // information.  We have to go to dig into the file entry descriptor
        // to get the information we need, so we'll construct a file control
        // block to get the attributes.
        //

        if (FileInformationClass == FileDirectoryInformation) {

            if (FatxIsFlagSet(DirectoryEntry.FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

                DirectoryInformation->EndOfFile.QuadPart = 0;
                DirectoryInformation->AllocationSize.QuadPart = 0;

            } else {

                //
                // AllocationSize should be filled in with the number of clusters
                // actually allocated to the file, but we don't want to have to
                // go parse the entire FAT chain to obtain this piece of
                // information.  We'll let the caller assume that the file has
                // been allocated the number of bytes actually in the file.
                //

                DirectoryInformation->EndOfFile.QuadPart =
                    (ULONGLONG)DirectoryEntry.FileSize;
                DirectoryInformation->AllocationSize.QuadPart =
                    (ULONGLONG)DirectoryEntry.FileSize;
            }

            DirectoryInformation->CreationTime =
                FatxFatTimestampToTime(&DirectoryEntry.CreationTime);
            DirectoryInformation->LastAccessTime =
            DirectoryInformation->LastWriteTime =
            DirectoryInformation->ChangeTime =
                FatxFatTimestampToTime(&DirectoryEntry.LastWriteTime);

            if (DirectoryEntry.FileAttributes == 0) {
                DirectoryInformation->FileAttributes = FILE_ATTRIBUTE_NORMAL;
            } else {
                DirectoryInformation->FileAttributes = DirectoryEntry.FileAttributes;
            }
        }

        //
        // If nothing has gone wrong yet, then copy the file name to the user's
        // buffer.
        //

        if (NT_SUCCESS(status)) {

            OutputBytesRemaining =
                ALIGN_DOWN(IrpSp->Parameters.QueryDirectory.Length -
                FileInformationBaseLength, sizeof(OCHAR));
            FileNameBytesToCopy = DirectoryEntry.FileNameLength;

            if (FileNameBytesToCopy > OutputBytesRemaining) {
                FileNameBytesToCopy = OutputBytesRemaining;
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                status = STATUS_SUCCESS;
            }

            RtlCopyMemory((PUCHAR)DirectoryInformation + FileInformationBaseLength,
                DirectoryEntry.FileName, FileNameBytesToCopy);

            //
            // Fill in the number of bytes that we wrote to the user's buffer.
            //

            Irp->IoStatus.Information = FileInformationBaseLength +
                FileNameBytesToCopy;

            //
            // Check that we didn't overflow the user's buffer.  The I/O manager
            // does the initial check to make sure there's enough space for the
            // static structure for a given information class, but we might
            // overflow the buffer when copying in the variable length file
            // name.
            //

            ASSERT(Irp->IoStatus.Information <=
                IrpSp->Parameters.QueryDirectory.Length);

            //
            // Update the query offset.
            //

            DirectoryEnumContext->QueryOffset = DirectoryByteOffset +
                sizeof(DIRENT);

            //
            // Store the directory byte offset in the directory file control
            // block.  If the caller attempts to open this file, then we'll use
            // this to quickly locate the file's directory entry.
            //

            DirectoryFcb->Directory.DirectoryByteOffsetLookupHint =
                DirectoryByteOffset;
        }

    } else if (status == STATUS_END_OF_FILE) {

        //
        // If we hit the end of the directory stream, then return an appropriate
        // status code depending on whether this was the first pass through this
        // routine for this handle or not.
        //

        status = InitialQuery ? STATUS_NO_SUCH_FILE : STATUS_NO_MORE_FILES;
    }

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\mountvol.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    mountvol.c

Abstract:

    This module implements routines related to the mounting of a FAT volume.

--*/

#include "fatx.h"

NTSTATUS
FatxCreateVolumeDevice(
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PDISK_GEOMETRY DiskGeometry,
    IN PPARTITION_INFORMATION PartitionInformation,
    OUT PDEVICE_OBJECT *ReturnedVolumeDeviceObject
    )
/*++

Routine Description:

    This routine creates an instance of a volume device object.

Arguments:

    TargetDeviceObject - Specifies the device object that the volume object
        sends I/O requests to.

    DiskGeometry - Specifies the disk geometry of the target device.

    PartitionInformation - Specifies the partition information for the target
        device.

    ReturnedVolumeDeviceObject - Specifies the buffer to receive the created
        device object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT VolumeDeviceObject;
    PFAT_VOLUME_EXTENSION VolumeExtension;

    //
    // Create the volume's device object.
    //

    status = IoCreateDevice(&FatxDriverObject, sizeof(FAT_VOLUME_EXTENSION),
        NULL, FILE_DEVICE_DISK_FILE_SYSTEM, FALSE, &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Increase the volume's IRP stack size for requests that we pass down to
    // the target device object.
    //

    VolumeDeviceObject->StackSize = (UCHAR)(VolumeDeviceObject->StackSize +
        TargetDeviceObject->StackSize);

    //
    // Ensure that the alignment for this device matches the requirements of the
    // target device.
    //

    if (VolumeDeviceObject->AlignmentRequirement < TargetDeviceObject->AlignmentRequirement) {
        VolumeDeviceObject->AlignmentRequirement = TargetDeviceObject->AlignmentRequirement;
    }

    //
    // If the target device object supports scatter gather I/O, then indicate
    // that we can as well.
    //

    if (FatxIsFlagSet(TargetDeviceObject->Flags, DO_SCATTER_GATHER_IO)) {
        VolumeDeviceObject->Flags |= DO_SCATTER_GATHER_IO;
    }

    //
    // Set the size of a sector for this device.
    //

    VolumeDeviceObject->SectorSize = (USHORT)DiskGeometry->BytesPerSector;

    //
    // Increment the reference count on the target device object since we'll be
    // holding a pointer to it.
    //

    ObReferenceObject(TargetDeviceObject);

    //
    // Initialize the volume's device extension data.
    //

    VolumeExtension = (PFAT_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    VolumeExtension->TargetDeviceObject = TargetDeviceObject;
    VolumeExtension->PartitionLength = PartitionInformation->PartitionLength;
    VolumeExtension->SectorSize = DiskGeometry->BytesPerSector;
    VolumeExtension->SectorShift = RtlFindFirstSetRightMember(DiskGeometry->BytesPerSector);

    //
    // Initialize the volume's instance lock.
    //

    ExInitializeReadWriteLock(&VolumeExtension->VolumeMutex);

    //
    // Initialize the volume's cluster cache lock.
    //

    RtlInitializeCriticalSection(&VolumeExtension->ClusterCacheMutex);

    //
    // Initialize the file control block for the physical volume.
    //

    VolumeExtension->VolumeFcb.Flags = FAT_FCB_VOLUME;
    VolumeExtension->VolumeFcb.ReferenceCount = 1;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    VolumeDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Return the device object to the caller.
    //

    *ReturnedVolumeDeviceObject = VolumeDeviceObject;

    return STATUS_SUCCESS;
}

VOID
FatxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    )
/*++

Routine Description:

    This routine deletes an instance of a volume device object.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to delete.

Return Value:

    Status of operation.

--*/
{
    PFAT_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // There shouldn't be any open files for this volume.
    //

    ASSERT(VolumeExtension->FileObjectCount == 0);

    //
    // Delete the volume's cluster cache lock.
    //

    RtlDeleteCriticalSection(&VolumeExtension->ClusterCacheMutex);

    //
    // Delete any file control blocks created by the volume.
    //

    if (VolumeExtension->RootDirectoryFcb != NULL) {
        FatxDereferenceFcb(VolumeExtension->RootDirectoryFcb);
    }

    //
    // Invalidate any file system cache buffers for this device.
    //

    FscInvalidateDevice(&VolumeExtension->CacheExtension);

    //
    // Release the reference on the target device object.
    //

    if (VolumeExtension->TargetDeviceObject != NULL) {
        ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice(VolumeDeviceObject);
}

NTSTATUS
FatxProcessBootSector(
    IN PDEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp,
    IN PLARGE_INTEGER PartitionLength
    )
/*++

Routine Description:

    This routine reads the boot sector for the supplied volume device object,
    validates its structure, and caches any interesting information in the
    device extension.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to mount.

    Irp - Specifies the packet that describes the I/O request.

    PartitionLength - Specifies the length of the partition in bytes.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PVOID CacheBuffer;
    ULONG StructureAlignment;
    ULONG NumberOfReservedBytes;
    PFAT_VOLUME_METADATA VolumeMetadata;
    ULONG RootDirectoryFirstCluster;
    ULONG NumberOfClustersLimit;
    ULONG NumberOfBytesPerFat;
    ULONGLONG NumberOfUnreservedBytes;
    ULONGLONG NumberOfFileAreaBytes;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;
    CacheBuffer = NULL;

    //
    // Compute the alignment between the various file system structures.
    // Everything should be page aligned in order to maximum file system cache
    // efficiency.
    //

    StructureAlignment = ROUND_TO_PAGES(VolumeExtension->SectorSize);

    //
    // Compute the number of reserved bytes for the volume.
    //
    // We only need to reserve enough space for the volume metadata block.
    //

    NumberOfReservedBytes = PAGE_SIZE;

    if (NumberOfReservedBytes < StructureAlignment) {
        NumberOfReservedBytes = StructureAlignment;
    }

    //
    // Verify that the partition has enough space to contain the reserved bytes.
    //

    if ((ULONGLONG)NumberOfReservedBytes >= (ULONGLONG)PartitionLength->QuadPart) {
        status = STATUS_UNRECOGNIZED_VOLUME;
        goto CleanupAndExit;
    }

    //
    // Map the volume metadata block into the cache.
    //

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp, 0, FALSE,
        &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        status = STATUS_UNRECOGNIZED_VOLUME;
        goto CleanupAndExit;
    }

    VolumeMetadata = (PFAT_VOLUME_METADATA)CacheBuffer;

    //
    // Verify that the signature is valid.
    //

    if (VolumeMetadata->Signature != FAT_VOLUME_SIGNATURE) {
        FatxDbgPrint(("FATX: found unrecognized signature\n"));
        status = STATUS_UNRECOGNIZED_VOLUME;
        goto CleanupAndExit;
    }

    //
    // Verify that the sectors per cluster looks reasonable.
    //

    switch (VolumeMetadata->SectorsPerCluster) {

        case 1:
        case 2:
        case 4:
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
            break;

        default:
            FatxDbgPrint(("FATX: found invalid sectors per cluster\n"));
            status = STATUS_UNRECOGNIZED_VOLUME;
            goto CleanupAndExit;
    }

    VolumeExtension->BytesPerCluster = VolumeMetadata->SectorsPerCluster <<
        VolumeExtension->SectorShift;
    VolumeExtension->ClusterShift =
        RtlFindFirstSetRightMember(VolumeExtension->BytesPerCluster);

    //
    // Copy the serial number from to the volume extension.
    //

    VolumeExtension->SerialNumber = VolumeMetadata->SerialNumber;

    //
    // Remember the root directory cluster and unmap the volume metadata block.
    //

    RootDirectoryFirstCluster = VolumeMetadata->RootDirFirstCluster;

    FscUnmapBuffer(CacheBuffer);
    CacheBuffer = NULL;

    //
    // Verify that the number of bytes per cluster is greater than or equal to
    // the structure alignment requirement.
    //

    if (VolumeExtension->BytesPerCluster < StructureAlignment) {
        FatxDbgPrint(("FATX: found too small of cluster size\n"));
        status = STATUS_UNRECOGNIZED_VOLUME;
        goto CleanupAndExit;
    }

    //
    // For volumes with more than 64K of clusters, we use 32-bit file allocation
    // table entries.  Otherwise, we use 16-bit file allocation table entries.
    // This is not FAT16 as defined by DOS; we still have a FAT32 style BIOS
    // parameter block, but the FAT is in a "compressed" format.
    //
    // Note that we base the test on the limit of the number of clusters for the
    // entire partition.  The same test is performed in the FAT format code.
    //
    // The below number isn't exactly 64K, because we need to avoid the magic
    // cluster numbers that mark free or end of file clusters.
    //

    NumberOfClustersLimit = (ULONG)((ULONGLONG)PartitionLength->QuadPart >>
        VolumeExtension->ClusterShift) + FAT_RESERVED_FAT_ENTRIES;

    if (NumberOfClustersLimit < FAT_CLUSTER16_RESERVED) {
        VolumeExtension->Flags |= FAT_VOLUME_FAT16X;
        VolumeExtension->FatEntryShift = 1;
        NumberOfBytesPerFat = NumberOfClustersLimit * sizeof(USHORT);
    } else {
        VolumeExtension->FatEntryShift = 2;
        NumberOfBytesPerFat = NumberOfClustersLimit * sizeof(ULONG);
    }

    NumberOfBytesPerFat = (NumberOfBytesPerFat + (StructureAlignment - 1)) &
        ~(StructureAlignment - 1);

    //
    // Compute the number of bytes that haven't been reserved above.
    //

    NumberOfUnreservedBytes = (ULONGLONG)PartitionLength->QuadPart -
        NumberOfReservedBytes;

    //
    // Verify that the partition has enough space to contain the FAT.
    //

    if ((ULONGLONG)NumberOfBytesPerFat >= NumberOfUnreservedBytes) {
        FatxDbgPrint(("FATX: volume too small to hold the FAT\n"));
        status = STATUS_UNRECOGNIZED_VOLUME;
        goto CleanupAndExit;
    }

    //
    // Compute the number of clusters available on the volume.
    //

    NumberOfFileAreaBytes = NumberOfUnreservedBytes - NumberOfBytesPerFat;

    VolumeExtension->NumberOfClusters = (ULONG)(NumberOfFileAreaBytes >>
        VolumeExtension->ClusterShift);

    //
    // Compute the physical byte offsets of the FAT and the first cluster.
    //

    VolumeExtension->FatByteOffset = NumberOfReservedBytes;
    VolumeExtension->FileAreaByteOffset = VolumeExtension->FatByteOffset +
        NumberOfBytesPerFat;

    //
    // When dealing with the file system cache, other parts of the file system
    // assume that the file allocation table or file area start on a page
    // aligned byte offset.  Also, the number of bytes per cluster must be a
    // multiple of the page size.
    //

    ASSERT(BYTE_OFFSET(VolumeExtension->FatByteOffset) == 0);
    ASSERT(BYTE_OFFSET(VolumeExtension->FileAreaByteOffset) == 0);
    ASSERT(BYTE_OFFSET(VolumeExtension->BytesPerCluster) == 0);

    //
    // Create the file control block for the root directory.
    //

    status = FatxCreateFcb(NULL, RootDirectoryFirstCluster, NULL, 0,
        &VolumeExtension->RootDirectoryFcb);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    status = STATUS_SUCCESS;

CleanupAndExit:
    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

    return status;
}

NTSTATUS
FatxMountVolume(
    IN PDEVICE_OBJECT TargetDeviceObject
    )
/*++

Routine Description:

    This routine is called by the I/O manager to attempt to mount this file
    system.

Arguments:

    TargetDeviceObject - Specifies the device object to attempt to mount.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIRP Irp;
    PDEVICE_OBJECT VolumeDeviceObject;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    DISK_GEOMETRY DiskGeometry;
    PARTITION_INFORMATION PartitionInformation;

    Irp = NULL;
    VolumeDeviceObject = NULL;

    FatxAcquireGlobalMutexExclusive();

    //
    // Get the drive geometry from the device.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
        TargetDeviceObject, NULL, 0, &DiskGeometry, sizeof(DISK_GEOMETRY), NULL,
        FALSE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Get the partition information from the device.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
        TargetDeviceObject, NULL, 0, &PartitionInformation,
        sizeof(PARTITION_INFORMATION), NULL, FALSE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Create an I/O request packet in order to submit requests to the target
    // device.
    //

    Irp = IoAllocateIrp(TargetDeviceObject->StackSize);

    if (Irp == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Create the volume's device object.
    //

    status = FatxCreateVolumeDevice(TargetDeviceObject, &DiskGeometry,
        &PartitionInformation, &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    VolumeExtension = (PFAT_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // Process the boot sector for the volume.
    //

    status = FatxProcessBootSector(VolumeDeviceObject, Irp,
        &PartitionInformation.PartitionLength);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Initialize the allocation support for the volume.
    //

    status = FatxInitializeAllocationSupport(VolumeExtension, Irp);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Connect the volume device object to the target device object and return
    // success.
    //

    TargetDeviceObject->MountedOrSelfDevice = VolumeDeviceObject;
    VolumeDeviceObject = NULL;

    status = STATUS_SUCCESS;

CleanupAndExit:
    if (VolumeDeviceObject != NULL) {
        FatxDeleteVolumeDevice(VolumeDeviceObject);
    }

    if (Irp != NULL) {
        IoFreeIrp(Irp);
    }

    FatxReleaseGlobalMutex();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\fcbsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fcbsup.c

Abstract:

    This module implements routines which provide support for file control
    blocks.

--*/

#include "fatx.h"

//
// Local support.
//

VOID
FatxDbgPrintClusterCache(
    IN PFAT_FCB Fcb
    );

NTSTATUS
FatxCreateFcb(
    IN PFAT_FCB ParentFcb OPTIONAL,
    IN ULONG FirstCluster,
    IN PDIRENT DirectoryEntry OPTIONAL,
    IN ULONG DirectoryByteOffset OPTIONAL,
    OUT PFAT_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine constructs a file control block that represents the file at the
    supplied starting cluster number and with the optionally supplied directory
    attributes.

Arguments:

    VolumeExtension - Specifies the volume that contains the file control block.

    ParentFcb - Specifies the parent directory that contains the supplied file.

    FirstCluster - Specifies the starting cluster number for the file.

    DirectoryEntry - Optionally specifies the directory entry to obtain more
        attributes about the file.

    DirectoryByteOffset - Optionally specifies the byte offset of the directory
        entry.

    ReturnedFcb - Specifies the buffer to receive the created file control
        block.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SIZE_T FcbSize;
    ULONG FcbPoolTag;
    PFAT_FCB Fcb;
    ULONG PathNameLength;
    ULONG Index;

    //
    // Compute the size of the file control block.
    //

    if (DirectoryEntry == NULL) {
        FcbSize = FAT_DIRECTORY_FCB_SIZE;
        FcbPoolTag = 'cRtF';
    } else if (FatxIsFlagSet(DirectoryEntry->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        FcbSize = FAT_DIRECTORY_FCB_SIZE + DirectoryEntry->FileNameLength;
        FcbPoolTag = 'cDtF';
    } else {
        FcbSize = FAT_FILE_FCB_SIZE + DirectoryEntry->FileNameLength;
        FcbPoolTag = 'cFtF';
    }

    //
    // Allocate the file control block.
    //

    Fcb = ExAllocatePoolWithTag(FcbSize, FcbPoolTag);

    if (Fcb != NULL) {

        //
        // Initialize the file control block.
        //

        RtlZeroMemory(Fcb, FcbSize);

        //
        // A file control block starts with the single reference for the caller.
        //

        Fcb->ReferenceCount = 1;

        //
        // Store the first cluster of the stream in the file control block.  We
        // don't validate that the cluster is valid here because we need to be
        // able to create a file control block so that we can delete a corrupt
        // directory entry.
        //

        Fcb->FirstCluster = FirstCluster;
        Fcb->EndingCluster = FAT_CLUSTER_NULL;

        //
        // We don't know how many clusters have been allocated to the file yet
        // unless the starting cluster is null.
        //

        if (Fcb->FirstCluster == FAT_CLUSTER_NULL) {
            ASSERT(Fcb->AllocationSize == 0);
        } else {
            Fcb->AllocationSize = MAXULONG;
        }

        //
        // If a directory entry was supplied, then copy the attributes out of
        // the entry into the file control block.
        //

        if (DirectoryEntry != NULL) {

            ASSERT(ParentFcb != NULL);
            ASSERT(FatxIsFlagSet(ParentFcb->Flags, FAT_FCB_DIRECTORY));

            Fcb->FileAttributes = DirectoryEntry->FileAttributes;
            Fcb->FileSize = DirectoryEntry->FileSize;

            Fcb->LastAccessTime = DirectoryEntry->LastAccessTime;
            Fcb->CreationTime = DirectoryEntry->CreationTime;
            Fcb->LastWriteTime = FatxFatTimestampToTime(&DirectoryEntry->LastWriteTime);

            //
            // If the file attributes indicate that this is a directory, then
            // mark the file control block as a directory, too.  Otherwise,
            // initialize the file mutex.
            //

            if (FatxIsFlagSet(Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
                Fcb->Flags |= FAT_FCB_DIRECTORY;
                Fcb->FileNameBuffer = Fcb->Directory.OriginalFileName;
            } else{
                ExInitializeReadWriteLock(&Fcb->File.FileMutex);
                Fcb->FileNameBuffer = Fcb->File.OriginalFileName;
            }

            //
            // Copy the file name to the file control block.
            //

            ASSERT(DirectoryEntry->FileNameLength != 0);
            ASSERT(DirectoryEntry->FileNameLength <= FAT_FILE_NAME_LENGTH);

            Fcb->FileNameLength = DirectoryEntry->FileNameLength;

            RtlCopyMemory(Fcb->FileNameBuffer, DirectoryEntry->FileName,
                DirectoryEntry->FileNameLength);

            //
            // Store the byte offset of the directory entry so that we don't
            // have to search for the entry again when making changes.
            //

            Fcb->DirectoryByteOffset = DirectoryByteOffset;

            //
            // Increment the reference count for the parent file control block
            // and attach it to this file control block.
            //

            ParentFcb->ReferenceCount++;
            Fcb->ParentFcb = ParentFcb;

            //
            // Compute the length of the path name.
            //

            PathNameLength = ParentFcb->PathNameLength +
                sizeof(OBJ_NAME_PATH_SEPARATOR) + Fcb->FileNameLength;
            Fcb->PathNameLength = (UCHAR)PathNameLength;

            ASSERT(PathNameLength <= FAT_PATH_NAME_LIMIT);

            //
            // Insert the file control block into the child list of the parent
            // file control block.
            //

            InsertHeadList(&ParentFcb->Directory.ChildFcbList, &Fcb->SiblingFcbLink);

        } else {

            //
            // The only time that a directory entry is not supplied is when
            // we're creating the file control block for the root directory.
            //

            Fcb->Flags |= FAT_FCB_DIRECTORY | FAT_FCB_ROOT_DIRECTORY;
            Fcb->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
            ASSERT(Fcb->PathNameLength == 0);
        }

        //
        // For directories, initialize the child file control block list as
        // empty and set the directory entry lookup hint to zero.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
            InitializeListHead(&Fcb->Directory.ChildFcbList);
            Fcb->Directory.DirectoryByteOffsetLookupHint = 0;
        }

        //
        // Initialize the cluster cache for the file control block.  The cluster
        // cache has already been zeroed above.  The ClusterRunLength fields
        // must be zero in order for the elements to appear as free.  The LRU
        // list head is also zero.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {

            //
            // For directories, the initialization is trivial because the
            // cluster cache is small.
            //

            ASSERT(FAT_DIRECTORY_CLUSTER_CACHE_ENTRIES == 2);

            Fcb->Directory.ClusterCache[0].LruBlink = 1;
            Fcb->Directory.ClusterCache[0].LruFlink = 1;

        } else {

            //
            // For files, chain each entry to its neighbors and then go back and
            // fix up the first and last elements of the cache to correctly wrap
            // around.
            //

            ASSERT(FAT_FILE_CLUSTER_CACHE_ENTRIES > 2);

            for (Index = 0; Index < FAT_FILE_CLUSTER_CACHE_ENTRIES; Index++) {
                Fcb->File.ClusterCache[Index].LruBlink = Index - 1;
                Fcb->File.ClusterCache[Index].LruFlink = Index + 1;
            }

            Fcb->File.ClusterCache[0].LruBlink = FAT_FILE_CLUSTER_CACHE_ENTRIES - 1;
            Fcb->File.ClusterCache[FAT_FILE_CLUSTER_CACHE_ENTRIES - 1].LruFlink = 0;
        }

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    *ReturnedFcb = Fcb;

    return status;
}

BOOLEAN
FatxFindOpenChildFcb(
    IN PFAT_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PFAT_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine searches the child file control block for the supplied
    directory for a file that has the supplied file name.

Arguments:

    DirectoryFcb - Specifies the file control block of the directory to search.

    FileName - Specifies the name to search for in the directory.

    ReturnedFcb - Specifies the buffer to receive the found file control block.

Return Value:

    Returns TRUE if the file control block was found, else FALSE.

--*/
{
    PLIST_ENTRY NextFcbLink;
    PFAT_FCB Fcb;
    OBJECT_STRING FcbFileName;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));

    //
    // Walk through the file control blocks actively in use by the volume and
    // find a match.
    //

    NextFcbLink = DirectoryFcb->Directory.ChildFcbList.Flink;

    while (NextFcbLink != &DirectoryFcb->Directory.ChildFcbList) {

        Fcb = CONTAINING_RECORD(NextFcbLink, FAT_FCB, SiblingFcbLink);

        FcbFileName.Length = Fcb->FileNameLength;
        FcbFileName.Buffer = Fcb->FileNameBuffer;

        if ((FcbFileName.Length == FileName->Length) &&
            RtlEqualObjectString(&FcbFileName, FileName, TRUE)) {
            *ReturnedFcb = Fcb;
            return TRUE;
        }

        NextFcbLink = Fcb->SiblingFcbLink.Flink;
    }

    *ReturnedFcb = NULL;
    return FALSE;
}

NTSTATUS
FatxUpdateDirectoryEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb
    )
/*++

Routine Description:

    This routine writes out the directory entry for the supplied file using the
    in-memory directory information.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Fcb - Specifies the file control block that describes the directory entry to
        update.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    PVOID CacheBuffer;
    PDIRENT DirectoryEntry;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_ROOT_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // It's possible for the file control block to be NULL if a file failed to
    // be moved from one directory to another.  In that case,
    // FatxSetRenameInformation sets the file's parent file control block to
    // NULL.
    //

    if (Fcb->ParentFcb == NULL) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    //
    // Get the physical byte offset corresponding to the file's directory byte
    // offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp,
        Fcb->ParentFcb, Fcb->DirectoryByteOffset, FALSE, &PhysicalByteOffset,
        &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Map the directory entry into the cache.
    //

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, TRUE, &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Apply the information in the file control block to the directory entry.
    //

    DirectoryEntry = (PDIRENT)CacheBuffer;

    DirectoryEntry->FileNameLength = Fcb->FileNameLength;

    RtlCopyMemory(DirectoryEntry->FileName, Fcb->FileNameBuffer,
        Fcb->FileNameLength);

    DirectoryEntry->FileAttributes = Fcb->FileAttributes;
    DirectoryEntry->FirstCluster = Fcb->FirstCluster;
    DirectoryEntry->FileSize = Fcb->FileSize;
    DirectoryEntry->CreationTime = Fcb->CreationTime;
    DirectoryEntry->LastAccessTime = Fcb->LastAccessTime;

    FatxTimeToFatTimestamp(&Fcb->LastWriteTime, &DirectoryEntry->LastWriteTime);

    //
    // Write the change back out the disk and unmap the cache buffer.
    //

    status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, sizeof(DIRENT), CacheBuffer);

    if (NT_SUCCESS(status)) {
        Fcb->Flags &= ~FAT_FCB_UPDATE_DIRECTORY_ENTRY;
    }

    return status;
}

NTSTATUS
FatxMarkDirectoryEntryDeleted(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb
    )
/*++

Routine Description:

    This routine marks a directory entry as being deleted.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Fcb - Specifies the file control block that describes the directory entry to
        mark as deleted.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    PVOID CacheBuffer;
    PDIRENT DirectoryEntry;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_ROOT_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // It's possible for the file control block to be NULL if a file failed to
    // be moved from one directory to another.  In that case,
    // FatxSetRenameInformation sets the file's parent file control block to
    // NULL.
    //

    if (Fcb->ParentFcb == NULL) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    //
    // Get the physical byte offset corresponding to the file's directory byte
    // offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp,
        Fcb->ParentFcb, Fcb->DirectoryByteOffset, FALSE, &PhysicalByteOffset,
        &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Map the directory entry into the cache.
    //

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, TRUE, &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Apply the information in the file control block to the directory entry.
    //

    DirectoryEntry = (PDIRENT)CacheBuffer;

    DirectoryEntry->FileNameLength = FAT_DIRENT_DELETED;

    //
    // Write the change back out the disk and unmap the cache buffer.
    //

    status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, sizeof(DIRENT), CacheBuffer);

    return status;
}

VOID
FatxMoveClusterCacheEntryToTail(
    IN PFAT_FCB Fcb,
    IN PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache,
    IN ULONG ClusterCacheIndex
    )
/*++

Routine Description:

    This routine updates the LRU links for the supplied cluster cache such that
    the supplied cluster cache index is at the end of the LRU list.

Arguments:

    Fcb - Specifies the file control block that contains the cluster cache.

    ClusterCache - Specifies the pointer to the first entry of the cluster
        cache.

    ClusterCacheIndex - Specifies the index of the element to move to the end of
        the LRU list.  This index cannot be the current head of the LRU list
        (instead just change the LRU list head to be this entry's forward link).

Return Value:

    None.

--*/
{
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;
    PFAT_FCB_CLUSTER_CACHE_ENTRY CurrentHeadCacheEntry;

    ASSERT(ClusterCacheIndex != Fcb->ClusterCacheLruHead);

    ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];
    CurrentHeadCacheEntry = &ClusterCache[Fcb->ClusterCacheLruHead];

    //
    // Unlink the element that we're moving to the end of the LRU list from its
    // neighbors.
    //

    ClusterCache[ClusterCacheEntry->LruBlink].LruFlink =
        ClusterCacheEntry->LruFlink;
    ClusterCache[ClusterCacheEntry->LruFlink].LruBlink =
        ClusterCacheEntry->LruBlink;

    //
    // Link the element that we're moving to the end of the LRU list to the head
    // of the LRU list and the old tail of the LRU list.
    //

    ClusterCacheEntry->LruFlink = Fcb->ClusterCacheLruHead;
    ClusterCacheEntry->LruBlink = CurrentHeadCacheEntry->LruBlink;

    //
    // Link the old tail of the LRU list and the head of the LRU list to the
    // element that we're moving to the end of the LRU list
    //

    ClusterCache[CurrentHeadCacheEntry->LruBlink].LruFlink = ClusterCacheIndex;
    CurrentHeadCacheEntry->LruBlink = ClusterCacheIndex;
}

BOOLEAN
FatxFillEmptyClusterCacheEntry(
    IN PFAT_FCB Fcb,
    IN PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache,
    IN ULONG PhysicalClusterNumber,
    IN ULONG FileClusterNumber,
    IN ULONG ClusterRunLength
    )
/*++

Routine Description:

    This routine fills an empty cluster cache entry with the supplied cluster
    run.

Arguments:

    Fcb - Specifies the file control block that contains the cluster cache.

    ClusterCache - Specifies the pointer to the first entry of the cluster
        cache.

    PhysicalClusterNumber - Specifies the first physical cluster of the run.

    FileClusterNumber - Specifies the file cluster that the first physical
        cluster maps to.

    ClusterRunLength - Specifies the number of clusters in the run.

Return Value:

    Returns TRUE if there are more empty slots available in the cluster cache,
    else FALSE.

--*/
{
    ULONG ClusterCacheIndex;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;

    //
    // Search the cluster cache for the first empty cache entry.
    //

    ClusterCacheIndex = Fcb->ClusterCacheLruHead;

    do {

        ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

        //
        // If this is an empty cache entry, then fill in the cache entry with
        // the supplied cluster run and return whether or not there are more
        // empty cache entries.
        //

        if (ClusterCacheEntry->ClusterRunLength == 0) {

            ClusterCacheEntry->PhysicalClusterNumber = PhysicalClusterNumber;
            ClusterCacheEntry->FileClusterNumber = FileClusterNumber;
            ClusterCacheEntry->ClusterRunLength = ClusterRunLength;

            ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;
            ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

            return (BOOLEAN)(ClusterCacheEntry->ClusterRunLength == 0);
        }

        //
        // Advance to the next LRU index.
        //

        ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;

    } while (ClusterCacheIndex != Fcb->ClusterCacheLruHead);

    //
    // No empty entries were found.  Return FALSE so that the caller doesn't
    // keep trying to fill empty cache entries.
    //

    return FALSE;
}

NTSTATUS
FatxFileByteOffsetToCluster(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb,
    IN ULONG FileByteOffset,
    OUT PULONG ReturnedClusterNumber,
    OUT PULONG ReturnedClusterRunLength OPTIONAL
    )
/*++

Routine Description:

    This routine returns the cluster number for the file byte offset into the
    supplied file.

    If this routine is given a file byte offset beyond the end of the allocated
    cluster chain, then STATUS_END_OF_FILE is returned.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Fcb - Specifies the file control block to retrieve the next cluster for.

    FileByteOffset - Specifies the file byte offset to retrive the cluster
        number for.

    ReturnedClusterNumber - Specifies the buffer to receive the cluster value
        for the supplied file byte offset.

    ReturnedClusterRunLength - Specifies the optional buffer to receive the
        number of adjacent clusters that can be accessed relative to the
        starting cluster number.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache;
    BOOLEAN HaveEmptyClusterCacheEntries;
    ULONG RequestedFileClusterNumber;
    UCHAR ClusterCacheIndex;
    PFAT_FCB_CLUSTER_CACHE_ENTRY NearestCacheEntry;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;
    PFAT_FCB_CLUSTER_CACHE_ENTRY CurrentHeadCacheEntry;
    ULONG PhysicalClusterNumber;
    ULONG FileClusterNumber;
    ULONG ClusterRunLength;
    PVOID CacheBuffer;
    ULONG CacheBufferFatByteOffset;
    ULONG StartingPhysicalClusterNumber;
    ULONG StartingFileClusterNumber;
    ULONG FatByteOffset;
    ULONG LastPhysicalClusterNumber;
    PVOID FatEntry;

    //
    // The volume mutex should be acquired for either exclusive or shared access
    // in order to synchronize with FatxAllocateClusters and FatxFreeClusters.
    //

    ASSERT(ExDbgIsReadWriteLockLocked(&VolumeExtension->VolumeMutex));

    //
    // Make sure that we weren't called with the file control block for the
    // volume.  Volume file control blocks don't have a cache allocated.
    //

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));

    //
    // Synchronize access to the cluster cache using a special volume mutex.  At
    // this point, the volume mutex may only be held in shared mode so to guard
    // against multiple writers in this code path, we need an additional mutex.
    //

    FatxAcquireClusterCacheMutex(VolumeExtension);

    //
    // The below code assumes that relative byte offsets into the file
    // allocation table have the same page alignment as their corresponding
    // physical byte offsets.
    //

    ASSERT(BYTE_OFFSET(VolumeExtension->FatByteOffset) == 0);

    //
    // If we're requesting a file byte offset beyond the known end of file, then
    // bail out now.
    //

    if ((Fcb->AllocationSize != MAXULONG) &&
        (FileByteOffset >= Fcb->AllocationSize)) {
        FatxReleaseClusterCacheMutex(VolumeExtension);
        return STATUS_END_OF_FILE;
    }

    //
    // Obtain the base pointer to the cluster cache for the given type of file
    // control block.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
        ClusterCache = Fcb->Directory.ClusterCache;
    } else {
        ClusterCache = Fcb->File.ClusterCache;
    }

    //
    // Convert the file byte offset into its file cluster number.
    //

    RequestedFileClusterNumber = FileByteOffset >> VolumeExtension->ClusterShift;

    //
    // Search the cluster cache for the file cluster number.
    //

    HaveEmptyClusterCacheEntries = FALSE;
    ClusterCacheIndex = Fcb->ClusterCacheLruHead;
    NearestCacheEntry = NULL;

    do {

        ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

        //
        // If this is an empty cache entry, then break out now.  Set a flag so
        // that below code knows that we have at least one empty cache entry
        // that can be populated with cluster runs that are found while
        // searching for the requested file cluster number.
        //

        if (ClusterCacheEntry->ClusterRunLength == 0) {
            HaveEmptyClusterCacheEntries = TRUE;
            break;
        }

        //
        // Check if the cache entry contains the requested file cluster number.
        //

        if (RequestedFileClusterNumber >= ClusterCacheEntry->FileClusterNumber) {

            if (RequestedFileClusterNumber < ClusterCacheEntry->FileClusterNumber +
                ClusterCacheEntry->ClusterRunLength) {

                //
                // Move the entry to the top of the LRU list, if it's not
                // already the top element.
                //

MoveAndMatchCurrentCacheEntry:
                if (ClusterCacheIndex != Fcb->ClusterCacheLruHead) {

                    CurrentHeadCacheEntry = &ClusterCache[Fcb->ClusterCacheLruHead];

                    //
                    // If the index that we're moving to the top of the LRU list
                    // is the element at the bottom of the LRU list, then we can
                    // simply change the LRU head index to point at the bottom
                    // index.  The list links are already set up.  This is the
                    // common case for sequential access through the file.
                    //

                    if (ClusterCacheIndex != CurrentHeadCacheEntry->LruBlink) {
                        FatxMoveClusterCacheEntryToTail(Fcb, ClusterCache,
                            ClusterCacheIndex);
                    }

                    Fcb->ClusterCacheLruHead = ClusterCacheIndex;
                }

                //
                // Compute the actual cluster number.
                //

                PhysicalClusterNumber = ClusterCacheEntry->PhysicalClusterNumber +
                    (RequestedFileClusterNumber -
                    ClusterCacheEntry->FileClusterNumber);

                *ReturnedClusterNumber = PhysicalClusterNumber;

                //
                // Compute the number of clusters in this run.
                //

                if (ReturnedClusterRunLength != NULL) {

                    ClusterRunLength = ClusterCacheEntry->ClusterRunLength -
                        (PhysicalClusterNumber -
                        ClusterCacheEntry->PhysicalClusterNumber);
                    ASSERT(ClusterRunLength >= 1);

                    *ReturnedClusterRunLength = ClusterRunLength;
                }

                FatxReleaseClusterCacheMutex(VolumeExtension);
                return STATUS_SUCCESS;
            }

            //
            // The cache entry doesn't contain the requested file cluster
            // number.  If the cache entry's file cluster number is the nearest
            // file cluster number we have found before the requested file
            // cluster number, then keep a pointer to it.  If we need to go back
            // to the disk to read the FAT chain, we can start at this cluster.
            //

            if ((NearestCacheEntry == NULL) ||
                (ClusterCacheEntry->FileClusterNumber > NearestCacheEntry->FileClusterNumber)) {
                NearestCacheEntry = ClusterCacheEntry;
            }
        }

        //
        // Advance to the next LRU index.
        //

        ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;

    } while (ClusterCacheIndex != Fcb->ClusterCacheLruHead);

    //
    // The file cluster number wasn't found in the cache.  We'll have to go back
    // to the file allocation table to retrieve the mapping.
    //

    if (NearestCacheEntry != NULL) {

        //
        // We found a cache entry that was before the requested cluster number.
        // We can start the linear search at this point.
        //

        PhysicalClusterNumber = NearestCacheEntry->PhysicalClusterNumber +
            NearestCacheEntry->ClusterRunLength - 1;
        FileClusterNumber = NearestCacheEntry->FileClusterNumber +
            NearestCacheEntry->ClusterRunLength - 1;

        ASSERT(FatxIsValidCluster(VolumeExtension, PhysicalClusterNumber));

    } else {

        //
        // We didn't find a cache entry before the request cluster number, so we
        // have to start from the first cluster of the file.
        //

        LastPhysicalClusterNumber = FAT_CLUSTER_NULL;
        PhysicalClusterNumber = Fcb->FirstCluster;
        FileClusterNumber = 0;

        //
        // Check that the cluster number is valid.
        //

        if (!FatxIsValidCluster(VolumeExtension, PhysicalClusterNumber)) {

            //
            // If the first cluster of the file is zero and this is not a
            // directory, then no space has been allocated to the file, so
            // change the cluster number to the end of file marker for the sake
            // of the below checks.  Directories must have one cluster allocated
            // to them, so it's invalid to see an empty cluster chain at this
            // point.
            //

            if ((PhysicalClusterNumber == FAT_CLUSTER_NULL) &&
                FatxIsFlagClear(Fcb->Flags, FAT_FCB_DIRECTORY)) {
                PhysicalClusterNumber = FAT_CLUSTER_LAST;
            }

            //
            // Return the appropriate error code depending on whether we found
            // the end of file marker or not.  Now that we've found the end of
            // file, we can fill in the number of clusters actually allocated
            // to the file.
            //

FoundInvalidClusterNumber:
            if (PhysicalClusterNumber == FAT_CLUSTER_LAST) {
                Fcb->AllocationSize = FileClusterNumber <<
                    VolumeExtension->ClusterShift;
                Fcb->EndingCluster = LastPhysicalClusterNumber;
                status = STATUS_END_OF_FILE;
            } else {
                status = STATUS_FILE_CORRUPT_ERROR;
            }

            FatxReleaseClusterCacheMutex(VolumeExtension);
            return status;
        }
    }

    //
    // Walk the file allocation table chain until we find the requested cluster
    // number.
    //

    CacheBuffer = NULL;
    CacheBufferFatByteOffset = 0;
    ClusterRunLength = 1;
    StartingPhysicalClusterNumber = PhysicalClusterNumber;
    StartingFileClusterNumber = FileClusterNumber;

    while (FileClusterNumber < RequestedFileClusterNumber) {

        //
        // Advance to the next file cluster.
        //

        FileClusterNumber++;

        //
        // Convert the cluster number to its physical file allocation table byte
        // offset.
        //

        FatByteOffset = FatxClusterToFatByteOffset(VolumeExtension,
            PhysicalClusterNumber);

        //
        // If this is the first iteration of the loop or if the next file
        // allocation table entry sits on a different page, then switch to a new
        // cache buffer page.
        //

        if ((CacheBuffer == NULL) ||
            (CacheBufferFatByteOffset != (ULONG)PAGE_ALIGN(FatByteOffset))) {

            //
            // If another cache page has already been mapped, then unmap it now.
            //

            if (CacheBuffer != NULL) {
                FscUnmapBuffer(CacheBuffer);
            }

            //
            // Compute the page aligned byte offset for the desired cache page.
            //

            CacheBufferFatByteOffset = (ULONG)PAGE_ALIGN(FatByteOffset);

            //
            // Map the file allocation table page into memory.
            //

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                VolumeExtension->FatByteOffset + CacheBufferFatByteOffset,
                FALSE, &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                FatxReleaseClusterCacheMutex(VolumeExtension);
                return status;
            }
        }

        //
        // Keep track of the last physical cluster number and lookup the next
        // physical cluster number.
        //

        LastPhysicalClusterNumber = PhysicalClusterNumber;
        FatEntry = (PUCHAR)CacheBuffer + BYTE_OFFSET(FatByteOffset);
        PhysicalClusterNumber = FatxReadFatEntry(VolumeExtension, FatEntry);

        //
        // Check that the cluster number is valid.
        //

        if (!FatxIsValidCluster(VolumeExtension, PhysicalClusterNumber)) {
            FscUnmapBuffer(CacheBuffer);
            goto FoundInvalidClusterNumber;
        }

        //
        // If the last and current physical clusters are adjacent, then increase
        // the cluster run length.  Otherwise, this is a new run of at least one
        // cluster.
        //

        if (LastPhysicalClusterNumber + 1 != PhysicalClusterNumber) {

            if (NearestCacheEntry != NULL) {

                //
                // If NearestCacheEntry is non-NULL, then we must have started
                // scanning clusters from this entry and not have found any
                // intermediate cluster runs.  We can increase the length of
                // this cluster run.  NearestCacheEntry is nulled out so that on
                // subsequent iterations of this loop, we don't continue adding
                // clusters to the run and so that we we break out of the loop
                // we don't attempt to add the clusters to the run.
                //

                ASSERT(StartingPhysicalClusterNumber ==
                    (NearestCacheEntry->PhysicalClusterNumber + NearestCacheEntry->ClusterRunLength - 1));
                ASSERT(StartingFileClusterNumber ==
                    (NearestCacheEntry->FileClusterNumber + NearestCacheEntry->ClusterRunLength - 1));

                NearestCacheEntry->ClusterRunLength += (ClusterRunLength - 1);
                NearestCacheEntry = NULL;

            } else {

                //
                // If there are empty entries in the cluster cache, then go
                // ahead and fill one with the run we just found.  We may not
                // end up using it, but it's better then just losing the work
                // we've already performed.
                //

                if (HaveEmptyClusterCacheEntries) {
                    HaveEmptyClusterCacheEntries =
                        FatxFillEmptyClusterCacheEntry(Fcb, ClusterCache,
                            StartingPhysicalClusterNumber,
                            StartingFileClusterNumber, ClusterRunLength);
                }
            }

            ClusterRunLength = 1;
            StartingPhysicalClusterNumber = PhysicalClusterNumber;
            StartingFileClusterNumber = FileClusterNumber;

        } else {
            ClusterRunLength++;
        }
    }

    //
    // While we have one of the pages of the file allocation table mapped
    // into memory, then try to find as many adjacent clusters as possible.
    //

    if (CacheBuffer != NULL) {

        for (;;) {

            //
            // Convert the cluster number to its physical file allocation table
            // byte offset.
            //

            FatByteOffset = FatxClusterToFatByteOffset(VolumeExtension,
                PhysicalClusterNumber);

            //
            // Break out of the loop if this file allocation table entry is on a
            // different page from the current cache buffer page.
            //

            if (CacheBufferFatByteOffset != (ULONG)PAGE_ALIGN(FatByteOffset)) {
                break;
            }

            //
            // Keep track of the last physical cluster number and lookup the
            // next physical cluster number.
            //

            LastPhysicalClusterNumber = PhysicalClusterNumber;
            FatEntry = (PUCHAR)CacheBuffer + BYTE_OFFSET(FatByteOffset);
            PhysicalClusterNumber = FatxReadFatEntry(VolumeExtension, FatEntry);

            //
            // Increase the length of the cluster run if the last and current
            // physical clusters are adjacent, otherwise break out now.
            //

            if (LastPhysicalClusterNumber + 1 != PhysicalClusterNumber) {

                if (PhysicalClusterNumber == FAT_CLUSTER_LAST) {

                    //
                    // If we found the last cluster of the file, then go ahead and
                    // and fill in the number of clusters allocated to the file
                    // now so that we don't have to bother computing it later.
                    //

                    Fcb->AllocationSize = (StartingFileClusterNumber +
                        ClusterRunLength) << VolumeExtension->ClusterShift;
                    Fcb->EndingCluster = LastPhysicalClusterNumber;

                } else if (FatxIsValidCluster(VolumeExtension, PhysicalClusterNumber)) {

                    //
                    // If there are empty entries in the cluster cache, then go
                    // ahead and fill one with a single entry cluster run for
                    // the next file cluster.  We may not end up using it, but
                    // it avoids us having to map in this cache page again just
                    // to find the next link.
                    //
                    // The cache shouldn't already contain an entry for this
                    // starting file cluster number.  We know that the cache
                    // isn't empty, so we haven't started discarding entries
                    // yet.  If we had already visited this new starting file
                    // cluster number, then the cache would have already had an
                    // entry for the requested file cluster number and we would
                    // never have reached this code.
                    //

                    if (HaveEmptyClusterCacheEntries) {
                        HaveEmptyClusterCacheEntries =
                            FatxFillEmptyClusterCacheEntry(Fcb, ClusterCache,
                                PhysicalClusterNumber,
                                StartingFileClusterNumber + ClusterRunLength, 1);
                    }
                }

                break;

            } else {
                ClusterRunLength++;
            }
        }

        FscUnmapBuffer(CacheBuffer);
    }

    //
    // If NearestCacheEntry is non-NULL, then we must have started scanning for
    // clusters from this entry and not found any discontiguous cluster runs in
    // the above loop.  Increase the length of the existing cache entry.
    //
    // Jump back to the above code that moves the current cache entry to the top
    // of the cluster cache and returns.
    //

    if (NearestCacheEntry != NULL) {

        ASSERT(StartingPhysicalClusterNumber ==
            (NearestCacheEntry->PhysicalClusterNumber + NearestCacheEntry->ClusterRunLength - 1));
        ASSERT(StartingFileClusterNumber ==
            (NearestCacheEntry->FileClusterNumber + NearestCacheEntry->ClusterRunLength - 1));

        NearestCacheEntry->ClusterRunLength += (ClusterRunLength - 1);

        ClusterCacheIndex = (UCHAR)(NearestCacheEntry - ClusterCache);
        ClusterCacheEntry = NearestCacheEntry;

        goto MoveAndMatchCurrentCacheEntry;
    }

    //
    // Grab the tail cluster cache entry, which is either empty or is the least
    // recently used entry, and fill it in with the cluster run.
    //
    // Jump back to the above code that moves the current cache entry to the top
    // of the cluster cache and returns.
    //

    ClusterCacheIndex = (UCHAR)ClusterCache[Fcb->ClusterCacheLruHead].LruBlink;
    ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

    ClusterCacheEntry->PhysicalClusterNumber = StartingPhysicalClusterNumber;
    ClusterCacheEntry->FileClusterNumber = StartingFileClusterNumber;
    ClusterCacheEntry->ClusterRunLength = ClusterRunLength;

    goto MoveAndMatchCurrentCacheEntry;
}

NTSTATUS
FatxFileByteOffsetToPhysicalByteOffset(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb,
    IN ULONG FileByteOffset,
    IN BOOLEAN AcquireVolumeMutexShared,
    OUT PULONGLONG ReturnedPhysicalByteOffset,
    OUT PULONG ReturnedPhysicalRunLength
    )
/*++

Routine Description:

    This routine returns the physical byte offset for the file byte offset into
    the supplied file.

    If this routine is given a file byte offset beyond the end of the allocated
    cluster chain, then STATUS_FILE_CORRUPT_ERROR is returned.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Fcb - Specifies the file control block to retrieve the next cluster for.

    FileByteOffset - Specifies the file byte offset to retrive the cluster
        number for.

    AcquireVolumeMutexShared - Specifies whether or not to acquire the volume
        mutex for shared access.

    ReturnedPhysicalByteOffset - Specifies the buffer to receive the physical
        byte offset for the supplied file byte offset.

    ReturnedPhysicalRunLength - Specifies the optional buffer to receive the
        number of adjacent bytes that can be accessed relative to the starting
        physical byte offset.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG ClusterNumber;
    ULONG ClusterRunLength;
    ULONG ByteOffsetIntoCluster;

    if (AcquireVolumeMutexShared) {
        FatxAcquireVolumeMutexShared(VolumeExtension);
    }

    status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, Fcb,
        FileByteOffset, &ClusterNumber, &ClusterRunLength);

    if (AcquireVolumeMutexShared) {
        FatxReleaseVolumeMutex(VolumeExtension);
    }

    if (NT_SUCCESS(status)) {

        ByteOffsetIntoCluster = FatxByteOffsetIntoCluster(VolumeExtension,
            FileByteOffset);

        *ReturnedPhysicalByteOffset =
            FatxClusterToPhysicalByteOffset(VolumeExtension, ClusterNumber) +
            ByteOffsetIntoCluster;

        *ReturnedPhysicalRunLength =
            (ClusterRunLength << VolumeExtension->ClusterShift) -
            ByteOffsetIntoCluster;

    } else {

        //
        // For every client of this routine, the file byte offset should already
        // be known to be valid, so if we see end of file here, then convert to
        // a file corrupt error.
        //

        if (status == STATUS_END_OF_FILE) {
            status = STATUS_FILE_CORRUPT_ERROR;
        }
    }

    return status;
}

VOID
FatxAppendClusterRunsToClusterCache(
    IN PFAT_FCB Fcb,
    IN ULONG FileClusterNumber,
    IN FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS],
    IN ULONG NumberOfClusterRuns
    )
/*++

Routine Description:

    This routine appends a series of cluster runs to the cluster cache of the
    supplied file.

Arguments:

    Fcb - Specifies the file control block that contains the cluster cache that
        will be appended to.

    FileClusterNumber - Specifies the starting logical cluster number for the
        supplied cluster runs.

    ClusterRuns - Specifies the cluster runs that will be appended to the
        cluster cache.

    NumberOfClusterRuns - Specifies the number of cluster runs that are valid.

Return Value:

    None.

--*/
{
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;
    ULONG ClusterCacheIndex;
    PFAT_CLUSTER_RUN CurrentClusterRun;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));
    ASSERT(Fcb->AllocationSize != MAXULONG);
    ASSERT(NumberOfClusterRuns >= 1);

    //
    // Note that no explicit synchronization is required here.  The cluster
    // cache is appended to only when modifying the allocation of an existing
    // file.  For files, we have exclusive access to the file's mutex.  For
    // directories, we have exclusive access to the volume's mutex.  In either
    // case, no reader can enter the file system and end up using this file's
    // cluster cache while we're modifying it.
    //

    //
    // Obtain the base pointer to the cluster cache for the given type of file
    // control block.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
        ClusterCache = Fcb->Directory.ClusterCache;
    } else {
        ClusterCache = Fcb->File.ClusterCache;
    }

    //
    // If this isn't the first allocation for the file, then check if we can
    // merge any existing cache entry with the first cluster run.
    //

    if (FileClusterNumber != 0) {

        ClusterCacheIndex = Fcb->ClusterCacheLruHead;

        do {

            ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

            //
            // If this is an empty cache entry, then break out now.  There
            // aren't any more entries to check.
            //

            if (ClusterCacheEntry->ClusterRunLength == 0) {
                break;
            }

            ASSERT(ClusterCacheEntry->FileClusterNumber < FileClusterNumber);

            //
            // Check if we've found a cache entry that has the logical clusters
            // immediately before clusters we're going to append to the cache.
            //

            if (ClusterCacheEntry->FileClusterNumber +
                ClusterCacheEntry->ClusterRunLength == FileClusterNumber) {

                //
                // Check if the cache entry is also physically contiguous with
                // the first cluster run.  If so, then combine the cache entry
                // with the first cluster run and move the cache entry to the
                // tail of the cache so that we reuse it immediately below.
                //

                if (ClusterCacheEntry->PhysicalClusterNumber +
                    ClusterCacheEntry->ClusterRunLength ==
                    ClusterRuns[0].PhysicalClusterNumber) {

                    FileClusterNumber = ClusterCacheEntry->FileClusterNumber;
                    ClusterRuns[0].PhysicalClusterNumber =
                        ClusterCacheEntry->PhysicalClusterNumber;
                    ClusterRuns[0].ClusterRunLength +=
                        ClusterCacheEntry->ClusterRunLength;

                    if (ClusterCacheIndex == Fcb->ClusterCacheLruHead) {
                        Fcb->ClusterCacheLruHead =
                            (UCHAR)ClusterCacheEntry->LruFlink;
                    } else {
                        FatxMoveClusterCacheEntryToTail(Fcb, ClusterCache,
                            ClusterCacheIndex);
                    }
                }

                break;
            }

            //
            // Advance to the next LRU index.
            //

            ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;

        } while (ClusterCacheIndex != Fcb->ClusterCacheLruHead);
    }

    //
    // In the below loop where we insert the cluster runs into the cluster
    // cache, we do it in reverse order, so we need to advance the file cluster
    // number to its ending number.  Loop through the cluster runs and advance
    // the number to its ending value.
    //

    CurrentClusterRun = ClusterRuns + NumberOfClusterRuns - 1;

    do {

        FileClusterNumber += CurrentClusterRun->ClusterRunLength;

        //
        // Advance to the next cluster run.
        //

        CurrentClusterRun--;

    } while (CurrentClusterRun >= ClusterRuns);

    //
    // Insert each cluster run from end to start into the cluster cache.
    //

    ClusterCacheEntry = &ClusterCache[Fcb->ClusterCacheLruHead];
    CurrentClusterRun = ClusterRuns + NumberOfClusterRuns - 1;

    do {

        ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruBlink;
        ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

        //
        // The file cluster number refers to the ending cluster from the end of
        // the cluster runs or the previous cluster run.  Adjust it to refer to
        // the start of this cluster run.
        //

        FileClusterNumber -= CurrentClusterRun->ClusterRunLength;

        //
        // Fill in the cache entry with the next cluster run.
        //

        ClusterCacheEntry->PhysicalClusterNumber =
            CurrentClusterRun->PhysicalClusterNumber;
        ClusterCacheEntry->FileClusterNumber = FileClusterNumber;
        ClusterCacheEntry->ClusterRunLength = CurrentClusterRun->ClusterRunLength;

        //
        // Advance to the next cluster run.
        //

        CurrentClusterRun--;

    } while (CurrentClusterRun >= ClusterRuns);

    //
    // Update the head index of the cluster cache to point at the last element
    // that we inserted.
    //

    Fcb->ClusterCacheLruHead = (UCHAR)ClusterCacheIndex;
}

VOID
FatxInvalidateClusterCache(
    IN PFAT_FCB FileFcb,
    IN ULONG FileClusterNumber
    )
/*++

Routine Description:

    This routine invalidates the entries in the cluster cache for the supplied
    file starting with the supplied cluster number.

Arguments:

    FileFcb - Specifies the file control block whose cluster cache should be
        emptied.

    FileClusterNumber - Specifies the file cluster number to start invalidating
        entries from.

Return Value:

    None.

--*/
{
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache;
    ULONG StartingClusterCacheLruHead;
    ULONG NextClusterCacheIndex;
    ULONG ClusterCacheIndex;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;

    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME));

    //
    // The cluster cache is invalidated only in paths when modifying the
    // allocation of an existing file.  As a result, we already have exclusive
    // access to the file's mutex.  That's enough to protect us against another
    // thread reading or writing to this file's cluster cache, so don't bother
    // acquiring the cluster cache.
    //

    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Search the cluster cache for entries after the supplied file cluster
    // number.
    //

    ClusterCache = FileFcb->File.ClusterCache;
    StartingClusterCacheLruHead = FileFcb->ClusterCacheLruHead;
    NextClusterCacheIndex = StartingClusterCacheLruHead;

    do {

        ClusterCacheIndex = NextClusterCacheIndex;
        ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];
        NextClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;

        //
        // If this is an empty cache entry, then break out now.  There aren't
        // any more entries to invalidate.
        //

        if (ClusterCacheEntry->ClusterRunLength == 0) {
            break;
        }

        //
        // Check if the cache entry contains the requested file cluster number.
        //

        if (FileClusterNumber <= ClusterCacheEntry->FileClusterNumber) {

            //
            // The cache entry starts at or is beyond the range to be
            // invalidated.  Invalidate this entry and push it to the end of the
            // LRU list.
            //
            // If the cache entry is at the head of the LRU list, then change
            // the LRU list head to point at the next element which will
            // automatically make this element the tail of the list.  Otherwise,
            // we'll need to move the entry to the tail of the list by updating
            // the LRU links.
            //

            ClusterCacheEntry->ClusterRunLength = 0;

            if (ClusterCacheIndex == FileFcb->ClusterCacheLruHead) {
                FileFcb->ClusterCacheLruHead = (UCHAR)ClusterCacheEntry->LruFlink;
            } else {
                FatxMoveClusterCacheEntryToTail(FileFcb, ClusterCache,
                    ClusterCacheIndex);
            }

        } else if (FileClusterNumber < ClusterCacheEntry->FileClusterNumber +
            ClusterCacheEntry->ClusterRunLength) {

            //
            // The cache entry contains part of the range to be invalidated.
            // Clip off the extra clusters from the entry.
            //

            ClusterCacheEntry->ClusterRunLength = FileClusterNumber -
                ClusterCacheEntry->FileClusterNumber;
        }

    } while (NextClusterCacheIndex != StartingClusterCacheLruHead);
}

NTSTATUS
FatxDeleteFileAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb
    )
/*++

Routine Description:

    This routine deletes the file allocation assigned to the supplied file.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileFcb - Specifies the file control block to delete the file allocation
        for.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG OriginalFirstCluster;
    ULONG OriginalFileSize;

    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());
    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    //
    // If the file doesn't have any allocation assigned to it and the file size
    // is already zero, then we can bail out immediately.
    //

    if ((FileFcb->FirstCluster == FAT_CLUSTER_NULL) &&
        (FileFcb->FileSize == 0)) {
        ASSERT(FileFcb->AllocationSize == 0);
        ASSERT(FileFcb->EndingCluster == FAT_CLUSTER_NULL);
        return STATUS_SUCCESS;
    }

    //
    // Save off the fields from the file control block that we're going to
    // change so that we can back out any changes if we fail below.
    //

    OriginalFirstCluster = FileFcb->FirstCluster;
    OriginalFileSize = FileFcb->FileSize;

    //
    // Reset the starting cluster and file size to zero.
    //

    FileFcb->FirstCluster = FAT_CLUSTER_NULL;
    FileFcb->FileSize = 0;

    //
    // Commit the directory change.  If this fails, then back out the changes to
    // the file control block so that we still mirror the on-disk structure.
    //

    status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);

    if (!NT_SUCCESS(status)) {
        FileFcb->FirstCluster = OriginalFirstCluster;
        FileFcb->FileSize = OriginalFileSize;
        return status;
    }

    //
    // Invalidate the entire cluster cache for the file control block.
    //

    FatxInvalidateClusterCache(FileFcb, 0);

    //
    // Free the cluster chain starting with the first cluster.  FatxFreeClusters
    // will check that the cluster number is valid, so we don't have to do it
    // here.  We ignore any result from FatxFreeClusters.  If some error occurs
    // inside that routine, then we may have lost clusters on the disk, but
    // everything else on the disk and in memory is consistent.
    //

    FatxFreeClusters(VolumeExtension, Irp, OriginalFirstCluster, FALSE);

    //
    // Zero out the number of bytes allocated to this file and reset the ending
    // cluster number.
    //

    FileFcb->AllocationSize = 0;
    FileFcb->EndingCluster = FAT_CLUSTER_NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
FatxTruncateFileAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN ULONG AllocationSize
    )
/*++

Routine Description:

    This routine truncates the file allocation assigned to the supplied file to
    the supplied number of bytes.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileFcb - Specifies the file control block to truncate the file allocation
        for.

    AllocationSize - Specifies the new allocation size for the file, aligned to
        a cluster boundary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG OriginalFileSize;
    ULONG ClusterNumber;

    ASSERT(AllocationSize != 0);
    ASSERT(FatxByteOffsetIntoCluster(VolumeExtension, AllocationSize) == 0);
    ASSERT(FileFcb->AllocationSize != MAXULONG);
    ASSERT(FileFcb->AllocationSize > AllocationSize);
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());
    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    //
    // If the allocation size for the file is non-zero, then the starting and
    // ending cluster numbers must also be valid.
    //

    if (FileFcb->AllocationSize != 0) {
        ASSERT(FileFcb->FirstCluster != FAT_CLUSTER_NULL);
        ASSERT(FileFcb->EndingCluster != FAT_CLUSTER_NULL);
    }

    //
    // Find the cluster number of the byte before the desired allocation size.
    //

    status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, FileFcb,
        AllocationSize - 1, &ClusterNumber, NULL);

    if (status == STATUS_END_OF_FILE) {
        status = STATUS_FILE_CORRUPT_ERROR;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Check if the current file size is greater than the requested allocation
    // size.  If so, then we'll need to truncate the file size as well.
    //

    if (FileFcb->FileSize > AllocationSize) {

        //
        // Save off the fields from the file control block that we're going to
        // change so that we can back out any changes if we fail below.
        //

        OriginalFileSize = FileFcb->FileSize;

        //
        // Truncate the file size to the number of bytes that will be allocated
        // to the file.
        //

        FileFcb->FileSize = AllocationSize;

        //
        // Commit the directory change.  If this fails, then back out the changes
        // to the file control block so that we still mirror the on-disk
        // structure.
        //

        status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);

        if (!NT_SUCCESS(status)) {
            FileFcb->FileSize = OriginalFileSize;
            return status;
        }
    }

    //
    // Free the cluster chain starting with the cluster number found above.
    // This first cluster number is marked as the last cluster in the file and
    // everything after this cluster is marked as free.
    //

    if (FatxFreeClusters(VolumeExtension, Irp, ClusterNumber, TRUE)) {

        //
        // FatxFreeClusterChain returns TRUE if it was able to modify the first
        // cluster in the chain.  We only modify the number of clusters
        // allocated if we were able to detach the unwanted clusters.  If
        // anything fails after the modification to the first cluster, then we
        // may have lost clusters on the disk, but everything else on disk and
        // in memory is consistent.
        //

        FileFcb->AllocationSize = AllocationSize;

        //
        // Change the ending cluster for the file to the cluster that we found
        // above.
        //

        FileFcb->EndingCluster = ClusterNumber;

        //
        // Invalidate any entries in the cluster cache for the file control
        // block after the new allocation size.
        //

        FatxInvalidateClusterCache(FileFcb, AllocationSize >>
            VolumeExtension->ClusterShift);

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

NTSTATUS
FatxExtendFileAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN ULONG AllocationSize
    )
/*++

Routine Description:

    This routine extends the file allocation assigned to the supplied file to
    the supplied number of clusters.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileFcb - Specifies the file control block to extend the file allocation
        for.

    AllocationSize - Specifies the new allocation size for the file, aligned to
        a cluster boundary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG ClustersNeeded;
    FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS];
    ULONG NumberOfClusterRuns;
    ULONG EndingCluster;
    ULONG OldAllocationSize;

    ASSERT(AllocationSize != 0);
    ASSERT(FatxByteOffsetIntoCluster(VolumeExtension, AllocationSize) == 0);
    ASSERT(FileFcb->AllocationSize != MAXULONG);
    ASSERT(FileFcb->AllocationSize < AllocationSize);
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());
    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    //
    // If the allocation size for the file is non-zero, then the starting and
    // ending cluster numbers must also be valid.
    //

    if (FileFcb->AllocationSize != 0) {
        ASSERT(FileFcb->FirstCluster != FAT_CLUSTER_NULL);
        ASSERT(FileFcb->EndingCluster != FAT_CLUSTER_NULL);
    }

    //
    // Allocate the additional clusters we need to reach the desired allocation
    // size.
    //

    ClustersNeeded = (AllocationSize - FileFcb->AllocationSize) >>
        VolumeExtension->ClusterShift;

    status = FatxAllocateClusters(VolumeExtension, Irp, FileFcb->EndingCluster,
        ClustersNeeded, ClusterRuns, &NumberOfClusterRuns, &EndingCluster);

    if (NT_SUCCESS(status)) {

        //
        // The cluster allocation was successful.  If this is the first cluster
        // of the file, then update the directory entry with this initial
        // cluster.
        //

        if (FileFcb->FirstCluster == FAT_CLUSTER_NULL) {

            FileFcb->FirstCluster = ClusterRuns[0].PhysicalClusterNumber;

            status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);

            if (!NT_SUCCESS(status)) {
                FatxFreeClusters(VolumeExtension, Irp, FileFcb->FirstCluster,
                    FALSE);
                FileFcb->FirstCluster = FAT_CLUSTER_NULL;
            }
        }

        //
        // Update the allocation size and the ending cluster number for the
        // file.  Copy the allocated cluster runs into the file's cluster cache.
        //

        if (NT_SUCCESS(status)) {

            OldAllocationSize = FileFcb->AllocationSize;

            FileFcb->AllocationSize = AllocationSize;
            FileFcb->EndingCluster = EndingCluster;

            FatxAppendClusterRunsToClusterCache(FileFcb,
                OldAllocationSize >> VolumeExtension->ClusterShift,
                ClusterRuns, NumberOfClusterRuns);
        }

    } else if (status != STATUS_DISK_FULL) {

        //
        // If FatxAllocateClusters fails due to any other error than a disk full
        // condition, then reset the file's allocation size and ending cluster
        // number, because we no longer know the correct values.  A disk write
        // error may have occurred after partially extending the file and
        // FatxAllocateClusters can't guarantee that we'll be back in a clean
        // state.
        //

        FileFcb->AllocationSize = MAXULONG;
        FileFcb->EndingCluster = FAT_CLUSTER_NULL;
    }

    return status;
}

NTSTATUS
FatxSetAllocationSize(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN ULONG AllocationSize,
    IN BOOLEAN OverwritingFile,
    IN BOOLEAN DisableTruncation
    )
/*++

Routine Description:

    This routine changes the allocation size of the supplied file.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileFcb - Specifies the file control block to change the allocation size
        for.

    AllocationSize - Specifies the new allocation size for the file.

    OverwritingFile - Specifies whether or not we're allowed to overwrite the
        current file allocation.

    DisableTruncation - If TRUE, if the requested allocation size is smaller
        than the current allocation size, then don't truncate the file
        allocation.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG ClusterNumber;

    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());
    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    AllocationSize = FatxRoundToClusters(VolumeExtension, AllocationSize);

    //
    // If the requested allocation size is zero, then delete the entire
    // allocation assigned to the file.
    //

    if (AllocationSize == 0) {
        return FatxDeleteFileAllocation(VolumeExtension, Irp, FileFcb);
    }

    //
    // Determine the number of bytes currently allocated to the file and find
    // the ending cluster number.  If that can't be determined because the file
    // is corrupt and we're allowed to overwrite the file, then delete the
    // current file allocation and start over.
    //

    if (FileFcb->AllocationSize == MAXULONG) {

        ASSERT(FileFcb->EndingCluster == FAT_CLUSTER_NULL);

        //
        // Attempt to find the cluster corresponding to the maximum byte offset
        // which will have the side effect of filling in the number of bytes
        // allocated.
        //

        status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, FileFcb,
            MAXULONG, &ClusterNumber, NULL);

        if (status == STATUS_END_OF_FILE) {
            status = STATUS_SUCCESS;
        } else if (status == STATUS_FILE_CORRUPT_ERROR && OverwritingFile) {
            status = FatxDeleteFileAllocation(VolumeExtension, Irp, FileFcb);
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // Compute the number of clusters that should be allocated to the file and
    // dispatch the request as appropriate.
    //

    if (FileFcb->AllocationSize < AllocationSize) {
        status = FatxExtendFileAllocation(VolumeExtension, Irp, FileFcb,
            AllocationSize);
    } else if (!DisableTruncation && (FileFcb->AllocationSize > AllocationSize)) {
        status = FatxTruncateFileAllocation(VolumeExtension, Irp, FileFcb,
            AllocationSize);
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
FatxExtendDirectoryAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb
    )
/*++

Routine Description:

    This routine extends the file allocation assigned to the supplied directory
    by one cluster.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block to extend the file
        allocation for.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS];
    ULONG NumberOfClusterRuns;
    ULONG EndingCluster;
    ULONG OldAllocationSize;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // This routine is only called for directories that already exist and only
    // after the entire directory stream has been processed, so we know that the
    // allocation size is non-zero and known.
    //

    ASSERT(DirectoryFcb->AllocationSize != 0);
    ASSERT(DirectoryFcb->AllocationSize != MAXULONG);
    ASSERT(DirectoryFcb->EndingCluster != FAT_CLUSTER_NULL);

    //
    // Don't allow a directory to exceed the directory file size restrictions.
    //

    if (DirectoryFcb->AllocationSize >= FAT_MAXIMUM_DIRECTORY_FILE_SIZE) {
        return STATUS_CANNOT_MAKE;
    }

    //
    // Allocate a single cluster.  We don't specify the ending cluster number
    // because we don't want the cluster attached to the directory's allocation
    // chain yet and it's going to be unlikely that we can get a cluster that's
    // contiguous to the ending cluster anyway.
    //

    status = FatxAllocateClusters(VolumeExtension, Irp, FAT_CLUSTER_NULL, 1,
        ClusterRuns, &NumberOfClusterRuns, &EndingCluster);

    if (NT_SUCCESS(status)) {

        ASSERT(NumberOfClusterRuns == 1);
        ASSERT(EndingCluster == ClusterRuns[0].PhysicalClusterNumber);

        //
        // Initialize the contents of the directory cluster.
        //

        status = FatxInitializeDirectoryCluster(VolumeExtension, Irp, EndingCluster);

        if (NT_SUCCESS(status)) {

            //
            // Link the new cluster to the ending cluster.
            //
            // Note that FatxLinkClusterChains calls FatxFreeClusters for the
            // starting cluster number when the operation fails.
            //

            status = FatxLinkClusterChains(VolumeExtension, Irp,
                DirectoryFcb->EndingCluster, EndingCluster);

            if (NT_SUCCESS(status)) {

                //
                // The directory is now one cluster bigger and the ending
                // cluster is advanced to the new cluster.
                //

                OldAllocationSize = DirectoryFcb->AllocationSize;

                DirectoryFcb->AllocationSize += VolumeExtension->BytesPerCluster;
                DirectoryFcb->EndingCluster = EndingCluster;

                FatxAppendClusterRunsToClusterCache(DirectoryFcb,
                    OldAllocationSize >> VolumeExtension->ClusterShift,
                    ClusterRuns, NumberOfClusterRuns);
            }

        } else {
            FatxFreeClusters(VolumeExtension, Irp, EndingCluster, FALSE);
        }
    }

    return status;
}

NTSTATUS
FatxIsDirectoryEmpty(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb
    )
/*++

Routine Description:

    This routine tests if the supplied directory is empty.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block of the directory to test.

Return Value:

    Returns STATUS_SUCCESS if the directory is empty, STATUS_DIRECTORY_NOT_EMPTY
    if the directory is not empty, else other error codes while attempting to
    make the test.

--*/
{
    NTSTATUS status;
    DIRENT DirectoryEntry;
    ULONG DirectoryByteOffset;
    OBJECT_STRING TemplateFileName;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Attempt to enumerate any file from the supplied directory.  If we get
    // back a file, then the directory is not empty.  If we reach the end of the
    // directory stream, then the directory is empty.  Any other status is an
    // error that we push back to the caller.
    //

    TemplateFileName.Buffer = NULL;

    status = FatxFindNextDirectoryEntry(VolumeExtension, Irp, DirectoryFcb,
        0, &TemplateFileName, &DirectoryEntry, &DirectoryByteOffset);

    if (NT_SUCCESS(status)) {
        status = STATUS_DIRECTORY_NOT_EMPTY;
    } else if (status == STATUS_END_OF_FILE) {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
FatxDeleteFile(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN ULONG DirectoryByteOffset
    )
/*++

Routine Description:

    This routine deletes the file at the byte offset inside the supplied
    directory.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block of the directory that
        contains the file to be deleted.

    DirectoryByteOffset - Specifies the byte offset into the directory for the
        file to delete.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    PVOID CacheBuffer;
    PDIRENT DirectoryEntry;
    ULONG FirstCluster;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Get the physical byte offset corresponding to the file's directory byte
    // offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp,
        DirectoryFcb, DirectoryByteOffset, FALSE, &PhysicalByteOffset,
        &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Map the directory entry into the cache.
    //

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, TRUE, &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Grab the starting cluster number from the directory entry and mark the
    // entry as deleted.
    //

    DirectoryEntry = (PDIRENT)CacheBuffer;

    FirstCluster = DirectoryEntry->FirstCluster;

    DirectoryEntry->FileNameLength = FAT_DIRENT_DELETED;

    //
    // Write the change back out the disk and unmap the cache buffer.
    //

    status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, sizeof(DIRENT), CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Free the clusters for the file.  Note that we don't have to check if the
    // first cluster number is valid because FatxFreeClusters does that for us.
    // We also don't care if FatxFreeClusters fails, because as far as the
    // caller is concerned, the file is deleted.
    //

    FatxFreeClusters(VolumeExtension, Irp, FirstCluster, FALSE);

    return STATUS_SUCCESS;
}

VOID
FatxDereferenceFcb(
    IN PFAT_FCB Fcb
    )
/*++

Routine Description:

    This routine decrements the reference count on the supplied file control
    block.  If the reference count reaches zero, then the file control block is
    deleted.

Arguments:

    Fcb - Specifies the file control block to dereference.

Return Value:

    None.

--*/
{
    PFAT_FCB ParentFcb;

    ASSERT(Fcb->ReferenceCount > 0);

    do {

        //
        // Decrement the reference count and bail out if there are still
        // outstanding references to the file control block.
        //

        if (--Fcb->ReferenceCount != 0) {
            return;
        }

        //
        // The volume's file control block is statically allocated as part of
        // the volume's device extension.  The block is initialized with a
        // reference count of zero at volume mount and should never transition
        // from a reference count of one to zero, so we should never get past
        // the above line for a volume file control block.
        //

        ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));

        //
        // Verify that the child file control block list is empty if this is a
        // directory.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
            ASSERT(IsListEmpty(&Fcb->Directory.ChildFcbList));
        }

        //
        // Save off the parent file control block so that we can dereference it
        // in a bit.
        //

        ParentFcb = Fcb->ParentFcb;

        //
        // Remove this file control block from the list of siblings.
        //

        if (ParentFcb != NULL) {
            RemoveEntryList(&Fcb->SiblingFcbLink);
        }

        //
        // If the file name buffer was replaced by another pool allocated
        // buffer, then free the buffer.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_FREE_FILE_NAME_BUFFER)) {
            ExFreePool(Fcb->FileNameBuffer);
        }

        //
        // Free the file control block.
        //

        ExFreePool(Fcb);

        //
        // Switch to the parent file control block and restart the loop to
        // dereference this object.
        //

        Fcb = ParentFcb;

    } while (Fcb != NULL);
}

#if DBG

VOID
FatxDbgPrintClusterCache(
    IN PFAT_FCB Fcb
    )
/*++

Routine Description:

    This routine dumps out the contents of the supplied file control block's
    cluster cache.

Arguments:

    Fcb - Specifies the file control block to display the cluster cache for.

Return Value:

    None.

--*/
{
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache;
    UCHAR ClusterCacheIndex;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));

    FatxDbgPrint(("FATX: Dumping cluster cache for %s %p:\n",
        FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY) ? "directory" : "file", Fcb));

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
        ClusterCache = Fcb->Directory.ClusterCache;
    } else {
        ClusterCache = Fcb->File.ClusterCache;
    }

    ClusterCacheIndex = Fcb->ClusterCacheLruHead;

    do {

        ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

        FatxDbgPrint(("%02d: F %02d B %02d - P %08x F %08x L %08x\n",
            ClusterCacheIndex,
            ClusterCacheEntry->LruFlink, ClusterCacheEntry->LruBlink,
            ClusterCacheEntry->PhysicalClusterNumber,
            ClusterCacheEntry->FileClusterNumber,
            ClusterCacheEntry->ClusterRunLength));

        ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;

    } while (ClusterCacheIndex != Fcb->ClusterCacheLruHead);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\fileinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION.

--*/

#include "fatx.h"

VOID
FatxQueryNetworkOpenInformation(
    IN PFILE_OBJECT FileObject,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkOpenInformation
    )
/*++

Routine Description:

    This routine fills the information structure with attributes about the
    supplied file object.

Arguments:

    FileObject - Specifies the file object to obtain the information from.

    NetworkOpenInformation - Specifies the buffer to receive the file
        information.

Return Value:

    None.

--*/
{
    PFAT_FCB Fcb;

    Fcb = (PFAT_FCB)FileObject->FsContext;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));

    NetworkOpenInformation->CreationTime =
        FatxFatTimestampToTime(&Fcb->CreationTime);
    NetworkOpenInformation->LastAccessTime =
        FatxFatTimestampToTime(&Fcb->LastAccessTime);
    NetworkOpenInformation->LastWriteTime = FatxRoundToFatTime(&Fcb->LastWriteTime);
    NetworkOpenInformation->ChangeTime = NetworkOpenInformation->LastWriteTime;

    if (Fcb->FileAttributes == 0) {
        NetworkOpenInformation->FileAttributes = FILE_ATTRIBUTE_NORMAL;
    } else {
        NetworkOpenInformation->FileAttributes = Fcb->FileAttributes;
    }

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {

        NetworkOpenInformation->AllocationSize.QuadPart = 0;
        NetworkOpenInformation->EndOfFile.QuadPart = 0;

    } else {

        //
        // AllocationSize should be filled in with the number of clusters
        // actually allocated to the file, but we don't want to have to go parse
        // the entire FAT chain to obtain this piece of information.  We'll let
        // the caller assume that the file has been allocated the number of
        // bytes actually in the file.
        //

        NetworkOpenInformation->AllocationSize.QuadPart = (ULONGLONG)Fcb->FileSize;
        NetworkOpenInformation->EndOfFile.QuadPart = (ULONGLONG)Fcb->FileSize;
    }
}

NTSTATUS
FatxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_QUERY_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFAT_FCB Fcb;
    ULONG BytesWritten;
    PFILE_INTERNAL_INFORMATION InternalInformation;
    PFILE_POSITION_INFORMATION PositionInformation;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PFAT_FCB)FileObject->FsContext;

    FatxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Check if the file object has already been cleaned up.  We don't allow a
    // a file object to be accessed after its handle has been closed.
    //

    if (FatxIsFlagSet(FileObject->Flags, FO_CLEANUP_COMPLETE)) {
        status = STATUS_FILE_CLOSED;
        goto CleanupAndExit;
    }

    //
    // For volume file control blocks, the only thing that can be queried is the
    // current file position.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) &&
        (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryFile.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {

        case FileInternalInformation:
            InternalInformation = (PFILE_INTERNAL_INFORMATION)Irp->UserBuffer;
            InternalInformation->IndexNumber.HighPart = PtrToUlong(VolumeExtension);
            InternalInformation->IndexNumber.LowPart = PtrToUlong(Fcb);
            BytesWritten = sizeof(FILE_INTERNAL_INFORMATION);
            break;

        case FilePositionInformation:
            PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;
            PositionInformation->CurrentByteOffset = FileObject->CurrentByteOffset;
            BytesWritten = sizeof(FILE_POSITION_INFORMATION);
            break;

        case FileNetworkOpenInformation:
            FatxQueryNetworkOpenInformation(FileObject,
                (PFILE_NETWORK_OPEN_INFORMATION)Irp->UserBuffer);
            BytesWritten = sizeof(FILE_NETWORK_OPEN_INFORMATION);
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryFile.Length);

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
FatxSetBasicInformation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PFILE_BASIC_INFORMATION BasicInformation
    )
/*++

Routine Description:

    This routine changes the basic information of the supplied file object.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileObject - Specifies the file object to apply the information to.

    BasicInformation - Specifies the basic information to apply to the file.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    BOOLEAN ChangesMade;
    PFAT_FCB Fcb;
    FAT_TIME_STAMP CreationTime;
    LARGE_INTEGER LastWriteTime;
    FAT_TIME_STAMP FatTimestamp;
    FAT_TIME_STAMP LastAccessTime;
    UCHAR FileAttributes;

    ChangesMade = FALSE;
    Fcb = (PFAT_FCB)FileObject->FsContext;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Validate all of the timestamps from the information structure.  If the
    // timestamp is -1, then that means that the user doesn't want the file
    // system automatically updating the timestamps, such as modifying the last
    // write time when writing to the file.  If the timestamp is zero, then no
    // change should be made to that timestamp.
    //

    if ((BasicInformation->CreationTime.QuadPart == -1) ||
        (BasicInformation->CreationTime.QuadPart == 0)) {

        //
        // Don't change the creation time.  Grab the current creation time from
        // the file control block.
        //

        CreationTime = Fcb->CreationTime;

    } else {

        //
        // Convert the NT system time to a FAT time.
        //

        if (!FatxTimeToFatTimestamp(&BasicInformation->CreationTime,
            &CreationTime)) {
            return STATUS_INVALID_PARAMETER;
        }

        if (CreationTime.AsULONG != Fcb->CreationTime.AsULONG) {
            ChangesMade = TRUE;
        }
    }

    if ((BasicInformation->LastWriteTime.QuadPart == -1) ||
        (BasicInformation->LastWriteTime.QuadPart == 0)) {

        //
        // Don't change the last write time.  Grab the current last write time
        // from the file control block.
        //

        LastWriteTime = Fcb->LastWriteTime;

        //
        // If the caller doesn't want us updating the last write time, then
        // mark the file control block.
        //

        if (BasicInformation->LastWriteTime.LowPart == -1) {
            Fcb->Flags |= FAT_FCB_DISABLE_LAST_WRITE_TIME;
        }

    } else {

        //
        // Verify that we can convert the time to a FAT timestamp.  At this
        // point, we don't care about the result.
        //

        if (!FatxTimeToFatTimestamp(&BasicInformation->LastWriteTime,
            &FatTimestamp)) {
            return STATUS_INVALID_PARAMETER;
        }

        LastWriteTime = BasicInformation->LastWriteTime;

        if (LastWriteTime.QuadPart != Fcb->LastWriteTime.QuadPart) {
            ChangesMade = TRUE;
        }
    }

    if ((BasicInformation->LastAccessTime.QuadPart == -1) ||
        (BasicInformation->LastAccessTime.QuadPart == 0)) {

        //
        // Don't change the last access time.  Grab the current last access time
        // from the file control block.
        //

        LastAccessTime = Fcb->LastAccessTime;

    } else {

        //
        // Convert the NT system time to a FAT time.
        //

        if (!FatxTimeToFatTimestamp(&BasicInformation->LastAccessTime,
            &LastAccessTime)) {
            return STATUS_INVALID_PARAMETER;
        }

        if (LastAccessTime.AsULONG != Fcb->LastAccessTime.AsULONG) {
            ChangesMade = TRUE;
        }
    }

    //
    // Validate the file attributes.
    //

    if (BasicInformation->FileAttributes == 0) {

        //
        // Don't change the file attributes.  Grab the current file attributes
        // from the file control block.
        //

        FileAttributes = Fcb->FileAttributes;

    } else {

        FileAttributes =
            (UCHAR)FatxFilterFileAttributes(BasicInformation->FileAttributes);

        //
        // Make sure that the directory attribute doesn't change.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
            FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
        } else if (FatxIsFlagSet(FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            return STATUS_INVALID_PARAMETER;
        }

        if (FileAttributes != Fcb->FileAttributes) {
            ChangesMade = TRUE;
        }
    }

    if (ChangesMade) {

        //
        // Now that we've validated all of the input from the information
        // structure, apply the changes to the file control block and write out
        // the changes.  If the write fails, we can live with the in-memory copy
        // of these attributes being different than the on-disk copies.
        //

        Fcb->CreationTime = CreationTime;
        Fcb->LastWriteTime = LastWriteTime;
        Fcb->LastAccessTime = LastAccessTime;
        Fcb->FileAttributes = FileAttributes;

        status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, Fcb);

    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
FatxSetRenameInformation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine renames the supplied file object.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFAT_FCB Fcb;
    PFILE_RENAME_INFORMATION RenameInformation;
    POSTR OriginalFileNameBuffer;
    UCHAR OriginalFileNameLength;
    POSTR EndOfFileName;
    POSTR StartOfFileName;
    OBJECT_STRING TargetFileName;
    POSTR TargetFileNameBuffer;
    PFAT_FCB TargetDirectoryFcb;
    ULONG NewPathNameLength;
    DIRENT DirectoryEntry;
    ULONG DirectoryByteOffset;
    ULONG EmptyDirectoryByteOffset;
    PFAT_FCB FoundOrNewFcb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PFAT_FCB)FileObject->FsContext;
    RenameInformation = (PFILE_RENAME_INFORMATION)Irp->UserBuffer;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // It's possible for the file control block to be NULL if a file failed to
    // be moved from one directory to another.  In that case,
    // FatxSetRenameInformation sets the file's parent file control block to
    // NULL.
    //

    if (Fcb->ParentFcb == NULL) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    //
    // There must be at least some characters in the file name.
    //

    if (RenameInformation->FileName.Length == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Save off the original file name buffer and length so that we can attempt
    // to unroll errors below.
    //

    OriginalFileNameBuffer = Fcb->FileNameBuffer;
    OriginalFileNameLength = Fcb->FileNameLength;

    ASSERT(OriginalFileNameBuffer != NULL);

    //
    // Figure out the starting and ending (exclusive) range of the target file
    // name.  In a normal NT file system, the target file name would have been
    // attached to the target file object, but we don't keep the file name as
    // part of the file objects, so we have to go back to user's original
    // buffer.
    //
    // For compatibility with NT, if the name ends with a backslash, ignore the
    // character.
    //

    EndOfFileName = (POSTR)((PCHAR)RenameInformation->FileName.Buffer +
        RenameInformation->FileName.Length);

    if (*(EndOfFileName - 1) == OBJ_NAME_PATH_SEPARATOR) {
        EndOfFileName--;
    }

    StartOfFileName = EndOfFileName;

    while (StartOfFileName > RenameInformation->FileName.Buffer) {

        if (*StartOfFileName == OBJ_NAME_PATH_SEPARATOR) {
            StartOfFileName++;
            break;
        }

        StartOfFileName--;
    }

    //
    // Validate that this is a legal FAT file name.
    //

    TargetFileName.Length = (USHORT)((PCHAR)EndOfFileName - (PCHAR)StartOfFileName);
    TargetFileName.MaximumLength = TargetFileName.Length;
    TargetFileName.Buffer = StartOfFileName;

    if (!FatxIsValidFatFileName(&TargetFileName)) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    // Figure out which directory the file will be renamed into.
    //

    if (IrpSp->Parameters.SetFile.FileObject != NULL) {
        TargetDirectoryFcb =
            (PFAT_FCB)IrpSp->Parameters.SetFile.FileObject->FsContext;
    } else {
        TargetDirectoryFcb = Fcb->ParentFcb;
    }

    ASSERT(FatxIsFlagSet(TargetDirectoryFcb->Flags, FAT_FCB_DIRECTORY));

    //
    // Verify that the path doesn't exceed the length restictions.
    //

    NewPathNameLength = TargetDirectoryFcb->PathNameLength +
        sizeof(OBJ_NAME_PATH_SEPARATOR) + TargetFileName.Length;

    if (NewPathNameLength > FAT_PATH_NAME_LIMIT * sizeof(OCHAR)) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    // If this is a directory, then verify that there are no open files under
    // this directory.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY) &&
        !IsListEmpty(&Fcb->Directory.ChildFcbList)) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Check if the target file name already exists.
    //

    status = FatxLookupElementNameInDirectory(VolumeExtension, Irp,
        TargetDirectoryFcb, &TargetFileName, &DirectoryEntry,
        &DirectoryByteOffset, &EmptyDirectoryByteOffset);

    if (NT_SUCCESS(status)) {

        //
        // The target file name already exists.  Check if the caller allows us
        // to replace an existing file and that we didn't find a directory or
        // read-only file.
        //

        if (!RenameInformation->ReplaceIfExists ||
            FatxIsFlagSet(DirectoryEntry.FileAttributes, FILE_ATTRIBUTE_DIRECTORY) ||
            FatxIsFlagSet(DirectoryEntry.FileAttributes, FILE_ATTRIBUTE_READONLY)) {
            return STATUS_OBJECT_NAME_COLLISION;
        }

        //
        // Don't overwrite a file that's already open.
        //

        if (FatxFindOpenChildFcb(TargetDirectoryFcb, &TargetFileName,
            &FoundOrNewFcb)) {
            return STATUS_ACCESS_DENIED;
        }

        //
        // Delete the existing file.
        //

        status = FatxDeleteFile(VolumeExtension, Irp, TargetDirectoryFcb,
            DirectoryByteOffset);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // We can use the old file's directory byte offset as the byte offset
        // for the renamed file, if needed.
        //

        EmptyDirectoryByteOffset = DirectoryByteOffset;

    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // Some unknown error was returned, so bail out now.
        //

        return status;
    }

    //
    // We'll need to replace the file name buffer that's currently stored in the
    // file control block.  Allocate a new string and copy the target file name
    // into the buffer.
    //

    TargetFileNameBuffer = (POSTR)ExAllocatePoolWithTag(TargetFileName.Length,
        'nFtF');

    if (TargetFileNameBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(TargetFileNameBuffer, TargetFileName.Buffer,
        TargetFileName.Length);

    //
    // Check if we're renaming inside the same directory.  If so, change the
    // file name in the file control block and commit the change.  If this
    // fails, back out to the original file name.
    //

    if (TargetDirectoryFcb == Fcb->ParentFcb) {

        Fcb->FileNameBuffer = TargetFileNameBuffer;
        Fcb->FileNameLength = (UCHAR)TargetFileName.Length;

        status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, Fcb);

        if (NT_SUCCESS(status)) {

            //
            // If the original file name buffer didn't come from the file
            // control block itself, then free it now.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_FREE_FILE_NAME_BUFFER)) {
                ExFreePool(OriginalFileNameBuffer);
            }

            //
            // We're going to keep the file name that we allocated, so set a
            // flag that the close code can look at to know that the file name
            // buffer must be freed.
            //

            Fcb->Flags |= FAT_FCB_FREE_FILE_NAME_BUFFER;

        } else {
            Fcb->FileNameBuffer = OriginalFileNameBuffer;
            Fcb->FileNameLength = OriginalFileNameLength;
        }

        return status;
    }

    //
    // We're moving a file across directories.
    //

    //
    // If there isn't an empty directory entry, then we'll need to add
    // another cluster to the directory.
    //

    if (EmptyDirectoryByteOffset == MAXULONG) {

        //
        // If we found the end of the directory stream, then we must have
        // established how many bytes are allocated to the file.
        //

        ASSERT(TargetDirectoryFcb->AllocationSize != MAXULONG);

        //
        // The new directory empty will be placed at the start of the new
        // extension.
        //

        EmptyDirectoryByteOffset = TargetDirectoryFcb->AllocationSize;

        //
        // Attempt to add another cluster to the directory's allocation.
        //

        status = FatxExtendDirectoryAllocation(VolumeExtension, Irp,
            TargetDirectoryFcb);

        if (!NT_SUCCESS(status)) {
            ExFreePool(TargetFileNameBuffer);
            return status;
        }
    }

    //
    // Mark the directory entry as deleted.  If the system goes down after
    // successfully committing this change, then we've lost the file.
    //

    status = FatxMarkDirectoryEntryDeleted(VolumeExtension, Irp, Fcb);

    if (!NT_SUCCESS(status)) {
        ExFreePool(TargetFileNameBuffer);
        return status;
    }

    //
    // Detach the file control block from its old parent.
    //

    RemoveEntryList(&Fcb->SiblingFcbLink);
    FatxDereferenceFcb(Fcb->ParentFcb);

    //
    // Attach the file control block to its new parent.
    //

    TargetDirectoryFcb->ReferenceCount++;
    Fcb->ParentFcb = TargetDirectoryFcb;
    InsertHeadList(&TargetDirectoryFcb->Directory.ChildFcbList,
        &Fcb->SiblingFcbLink);

    //
    // Update the file control block with its new file name and directory byte
    // offset.
    //

    Fcb->FileNameBuffer = TargetFileNameBuffer;
    Fcb->FileNameLength = (UCHAR)TargetFileName.Length;
    Fcb->DirectoryByteOffset = EmptyDirectoryByteOffset;

    status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, Fcb);

    if (NT_SUCCESS(status)) {

        //
        // Update the path name length stored in the file control block.
        //

        Fcb->PathNameLength = (UCHAR)NewPathNameLength;

        //
        // If the original file name buffer didn't come from the file control
        // block itself, then free it now.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_FREE_FILE_NAME_BUFFER)) {
            ExFreePool(OriginalFileNameBuffer);
        }

        //
        // We're going to keep the file name that we allocated, so set a flag
        // that the close code can look at to know that the file name buffer
        // must be freed.
        //

        Fcb->Flags |= FAT_FCB_FREE_FILE_NAME_BUFFER;

    } else {

        //
        // If this commit fails, then assume that we're not going to have any
        // hope of restoring the original state of the on-disk structures.
        // Leave the file control block in a zombie state by disconnecting it
        // from any parent directory.
        //

        FatxDbgPrint(("FATX: failed to move file across directories\n"));

        Fcb->FileNameBuffer = OriginalFileNameBuffer;
        Fcb->FileNameLength = OriginalFileNameLength;

        RemoveEntryList(&Fcb->SiblingFcbLink);
        FatxDereferenceFcb(TargetDirectoryFcb);

        Fcb->ParentFcb = NULL;

        ExFreePool(TargetFileNameBuffer);
    }

    return status;
}

NTSTATUS
FatxSetDispositionInformation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PFILE_DISPOSITION_INFORMATION DispositionInformation
    )
/*++

Routine Description:

    This routine changes the disposition information of the supplied file
    object.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileObject - Specifies the file object to apply the information to.

    DispositionInformation - Specifies the disposition information to apply to
        the file.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_FCB Fcb;

    Fcb = (PFAT_FCB)FileObject->FsContext;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // If the caller doesn't want to delete the file, then clear the flags from
    // the file control block and the file object.
    //

    if (!DispositionInformation->DeleteFile) {

        Fcb->Flags &= ~FAT_FCB_DELETE_ON_CLOSE;
        FileObject->DeletePending = FALSE;

        return STATUS_SUCCESS;
    }

    //
    // If this is a read only file, then it cannot be deleted.
    //

    if (FatxIsFlagSet(Fcb->FileAttributes, FILE_ATTRIBUTE_READONLY)) {
        return STATUS_CANNOT_DELETE;
    }

    //
    // If this is a directory, then check if the directory is empty.  We'll also
    // allow corrupt directories to be removed from the disk.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {

        status = FatxIsDirectoryEmpty(VolumeExtension, Irp, Fcb);

        if ((status != STATUS_SUCCESS) && (status != STATUS_FILE_CORRUPT_ERROR)) {
            return status;
        }
    }

    //
    // Mark the file as delete pending.
    //

    Fcb->Flags |= FAT_FCB_DELETE_ON_CLOSE;
    FileObject->DeletePending = TRUE;

    return STATUS_SUCCESS;
}

NTSTATUS
FatxSetEndOfFileInformation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PFILE_END_OF_FILE_INFORMATION EndOfFileInformation
    )
/*++

Routine Description:

    This routine changes the end of file information of the supplied file
    object.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileObject - Specifies the file object to apply the information to.

    EndOfFileInformation - Specifies the end of file information to apply to
        the file.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_FCB FileFcb;
    ULONG NewFileSize;
    ULONG OriginalFileSize;

    FileFcb = (PFAT_FCB)FileObject->FsContext;

    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());
    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Validate that the upper 32-bits of the end of file are zero.
    //

    if (EndOfFileInformation->EndOfFile.HighPart != 0) {
        return STATUS_DISK_FULL;
    }

    //
    // If the new file size and the current file size match, then there's
    // nothing to do.
    //

    NewFileSize = EndOfFileInformation->EndOfFile.LowPart;
    OriginalFileSize = FileFcb->FileSize;

    if (NewFileSize == OriginalFileSize) {
        return STATUS_SUCCESS;
    }

    //
    // If the new file size is beyond the current file size, then we might need
    // to extend the file allocation.  Note that we want to make sure that we
    // don't truncate the allocation here if the end of file is less than the
    // allocated size.
    //

    if (NewFileSize > OriginalFileSize) {

        status = FatxSetAllocationSize(VolumeExtension, Irp, FileFcb,
            NewFileSize, FALSE, TRUE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        ASSERT(FileFcb->FileSize == OriginalFileSize);
    }

    //
    // Change the file size in the file control block to the requested file
    // size.
    //

    FileFcb->FileSize = NewFileSize;

    //
    // Commit the directory change.  If this fails, then back out the changes to
    // the file control block so that we still mirror the on-disk structure.
    //

    status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);

    if (!NT_SUCCESS(status)) {
        FileFcb->FileSize = OriginalFileSize;
    }

    return status;
}

NTSTATUS
FatxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_SET_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFAT_FCB Fcb;
    PFILE_POSITION_INFORMATION PositionInformation;
    PFILE_ALLOCATION_INFORMATION AllocationInformation;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PFAT_FCB)FileObject->FsContext;

    //
    // If this is a file control block for a standard file, then we need to
    // acquire the file's mutex in order to synchronize access to the Flags
    // field of the file control block.
    //

    if (FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY)) {
        FatxAcquireFileMutexExclusive(Fcb);
    }

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Check if the file object has already been cleaned up.  We don't allow a
    // a file object to be accessed after its handle has been closed.
    //

    if (FatxIsFlagSet(FileObject->Flags, FO_CLEANUP_COMPLETE)) {
        status = STATUS_FILE_CLOSED;
        goto CleanupAndExit;
    }

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {

        case FileBasicInformation:
            //
            // We can't change the time stamps or the file attributes for the
            // volume or the root directory.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) ||
                FatxIsFlagSet(Fcb->Flags, FAT_FCB_ROOT_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            status = FatxSetBasicInformation(VolumeExtension, Irp, FileObject,
                (PFILE_BASIC_INFORMATION)Irp->UserBuffer);
            break;

        case FileRenameInformation:
            //
            // We can't rename the volume or the root directory.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) ||
                FatxIsFlagSet(Fcb->Flags, FAT_FCB_ROOT_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            status = FatxSetRenameInformation(VolumeExtension, Irp);
            break;

        case FileDispositionInformation:
            //
            // We can't delete the volume or the root directory.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) ||
                FatxIsFlagSet(Fcb->Flags, FAT_FCB_ROOT_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            status = FatxSetDispositionInformation(VolumeExtension, Irp, FileObject,
                (PFILE_DISPOSITION_INFORMATION)Irp->UserBuffer);
            break;

        case FilePositionInformation:
            PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;

            //
            // If the file was opened without intermediate buffering, then the
            // byte offset must be sector aligned.
            //

            if (FatxIsFlagSet(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING) &&
                !FatxIsSectorAligned(VolumeExtension,
                    PositionInformation->CurrentByteOffset.LowPart)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            FileObject->CurrentByteOffset = PositionInformation->CurrentByteOffset;
            break;

        case FileAllocationInformation:
            AllocationInformation =
                (PFILE_ALLOCATION_INFORMATION)Irp->UserBuffer;

            //
            // We can't change the allocation size for the volume or any
            // directory.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) ||
                FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            //
            // Validate that the upper 32-bits of the allocation size are zero.
            //

            if (AllocationInformation->AllocationSize.HighPart != 0) {
                status = STATUS_DISK_FULL;
                goto CleanupAndExit;
            }

            status = FatxSetAllocationSize(VolumeExtension, Irp, Fcb,
                AllocationInformation->AllocationSize.LowPart, FALSE, FALSE);
            break;

        case FileEndOfFileInformation:
            //
            // We can't change the end of file for the volume or any directory.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) ||
                FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            status = FatxSetEndOfFileInformation(VolumeExtension, Irp, FileObject,
                (PFILE_END_OF_FILE_INFORMATION)Irp->UserBuffer);
            break;

        default:
            status = STATUS_INVALID_PARAMETER;
            break;
    }

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    if (FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY)) {
        FatxReleaseFileMutex(Fcb);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\fatx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fatx.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the FAT file system driver.

--*/

#ifndef _FATX_
#define _FATX_

#include <ntos.h>
#include <ntdddisk.h>
#include <limits.h>
#include "fat.h"

#include <pshpack4.h>

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define FatxDbgPrint(x)                         DbgPrint x
#else
#define FatxDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define FatxIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define FatxIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Returns the number of elements in the supplied array.
//

#define ARRAY_ELEMENTS(array)                                                 \
    (sizeof((array)) / sizeof((array)[0]))

//
// Define file control block flags.
//

#define FAT_FCB_VOLUME                          0x01
#define FAT_FCB_DIRECTORY                       0x02
#define FAT_FCB_ROOT_DIRECTORY                  0x04
#define FAT_FCB_DISABLE_LAST_WRITE_TIME         0x08
#define FAT_FCB_DELETE_ON_CLOSE                 0x10
#define FAT_FCB_TRUNCATE_ON_CLOSE               0x20
#define FAT_FCB_UPDATE_DIRECTORY_ENTRY          0x40
#define FAT_FCB_FREE_FILE_NAME_BUFFER           0x80

//
// File control block cluster cache.
//

typedef struct _FAT_FCB_CLUSTER_CACHE_ENTRY {
    ULONG PhysicalClusterNumber : 24;
    ULONG LruFlink : 8;
    ULONG FileClusterNumber : 24;
    ULONG LruBlink : 8;
    ULONG ClusterRunLength;
} FAT_FCB_CLUSTER_CACHE_ENTRY, *PFAT_FCB_CLUSTER_CACHE_ENTRY;

#define FAT_DIRECTORY_CLUSTER_CACHE_ENTRIES     2
#define FAT_FILE_CLUSTER_CACHE_ENTRIES          10

//
// File control block.
//

typedef struct _FAT_FCB_BASE {
    UCHAR Flags;
    UCHAR PathNameLength;
    UCHAR FileNameLength;
    UCHAR FileAttributes;
    ULONG ReferenceCount;
    SHARE_ACCESS ShareAccess;
    UCHAR ClusterCacheLruHead;
} FAT_FCB_BASE, *PFAT_FCB_BASE;

typedef struct _FAT_FCB {
    FAT_FCB_BASE;
    LIST_ENTRY SiblingFcbLink;
    struct _FAT_FCB *ParentFcb;
    ULONG FirstCluster;
    ULONG EndingCluster;
    ULONG FileSize;
    ULONG AllocationSize;
    ULONG DirectoryByteOffset;
    POSTR FileNameBuffer;
    LARGE_INTEGER LastWriteTime;
    FAT_TIME_STAMP CreationTime;
    FAT_TIME_STAMP LastAccessTime;
    union {
        struct {
            ERWLOCK FileMutex;
#if DBG
            PKTHREAD FileMutexExclusiveOwner;
#endif
            FAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache[FAT_FILE_CLUSTER_CACHE_ENTRIES];
            OCHAR OriginalFileName[0];
        } File;
        struct {
            LIST_ENTRY ChildFcbList;
            ULONG DirectoryByteOffsetLookupHint;
            FAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache[FAT_DIRECTORY_CLUSTER_CACHE_ENTRIES];
            OCHAR OriginalFileName[0];
        } Directory;
    };
} FAT_FCB, *PFAT_FCB;

//
// Define the base sizes of the various types of file control blocks.
//

#define FAT_DIRECTORY_FCB_SIZE                  FIELD_OFFSET(FAT_FCB, Directory.OriginalFileName)
#define FAT_FILE_FCB_SIZE                       FIELD_OFFSET(FAT_FCB, File.OriginalFileName)

//
// Volume device extension data.
//

typedef struct _FAT_VOLUME_EXTENSION {
    union {
        FSCACHE_EXTENSION CacheExtension;
        FSCACHE_EXTENSION;
    };
    PFAT_FCB RootDirectoryFcb;
    ULONG FileObjectCount;
    ULONG NumberOfClusters;
    ULONG BytesPerCluster;
    UCHAR SectorShift;
    UCHAR ClusterShift;
    UCHAR FatEntryShift;
    UCHAR Flags;
    ULONGLONG FatByteOffset;
    ULONGLONG FileAreaByteOffset;
    ULONG NumberOfClustersAvailable;
    ULONG FirstAvailableClusterHint;
    ERWLOCK VolumeMutex;
    RTL_CRITICAL_SECTION ClusterCacheMutex;
    FAT_FCB_BASE VolumeFcb;
    ULONG SerialNumber;
    LONG DismountBlockCount;
    PKEVENT DismountUnblockEvent;
#if DBG
    PKTHREAD VolumeMutexExclusiveOwner;
#endif
} FAT_VOLUME_EXTENSION, *PFAT_VOLUME_EXTENSION;

//
// Define volume device extension flags.
//

#define FAT_VOLUME_DISMOUNTED                   0x01
#define FAT_VOLUME_FAT16X                       0x02

//
// Macro to round a size in bytes up to a multiple of the sector size.
//

#define FatxRoundToSectors(volume, size) \
    (((ULONG)(size) + ((volume)->SectorSize - 1)) & \
        ~((volume)->SectorSize - 1))

//
// Macro to check if a length is sector aligned.
//

#define FatxIsSectorAligned(volume, value) \
    ((LOGICAL)(((ULONG)(value) & ((volume)->SectorSize - 1)) == 0))

//
// Macro to verify that a cluster number is valid for the supplied volume.
//

#define FatxIsValidCluster(volume, cluster) \
    ((BOOLEAN)(((ULONG)((cluster) - FAT_RESERVED_FAT_ENTRIES)) < (volume)->NumberOfClusters))

//
// Macro to map a cluster number to the file area byte offset.
//

#define FatxClusterToPhysicalByteOffset(volume, cluster) \
    ((volume)->FileAreaByteOffset + \
        (((ULONGLONG)((cluster) - FAT_RESERVED_FAT_ENTRIES)) << (volume)->ClusterShift))

//
// Macro to map a cluster number to the file allocation table byte offset.
// Valid cluster numbers are limited to 28-bits, so we safely do the below shift
// with a 32-bit type.  This macro operates correctly for FAT16 and FAT32
// volumes.
//

#define FatxClusterToFatByteOffset(volume, cluster) \
    (((ULONG)(cluster)) << (volume)->FatEntryShift)

//
// Macro to convert a FAT16X entry to a FAT32 entry.  The special entries are
// extended to their FAT32 equivalents while normal file clusters are zero
// extended.
//

#define FatxConvertFat16XToFat32(cluster) \
    ((cluster) < FAT_CLUSTER16_RESERVED ? (cluster) : ((ULONG)(SHORT)(cluster)))

//
// Macro to read the cluster from the supplied FAT entry pointer.  This macro
// operates correctly for FAT16X and FAT32 volumes.
//

#define FatxReadFatEntry(volume, fatentry) \
    (FatxIsFlagClear((volume)->Flags, FAT_VOLUME_FAT16X) ? \
        (*(PULONG)fatentry) : \
        FatxConvertFat16XToFat32(*(PUSHORT)fatentry))

//
// Macro to write the cluster to the supplied FAT entry pointer.  This macro
// operates correctly for FAT16X and FAT32 volumes.
//

#define FatxWriteFatEntry(volume, fatentry, cluster) \
    (FatxIsFlagClear((volume)->Flags, FAT_VOLUME_FAT16X) ? \
        ((*(PULONG)fatentry) = (cluster)) : \
        ((*(PUSHORT)fatentry) = (USHORT)(cluster)))

//
// Macro to compute the offset into the cluster of the supplied byte offset.
//

#define FatxByteOffsetIntoCluster(volume, lbo) \
    ((ULONG)(lbo) & ((volume)->BytesPerCluster - 1))

//
// Macro to round a size in bytes up to a multiple of the cluster size.
//

#define FatxRoundToClusters(volume, size) \
    (((ULONG)(size) + ((volume)->BytesPerCluster - 1)) & \
        ~((volume)->BytesPerCluster - 1))

//
// Macro to safely increment the dismount block count for the volume.
//

#define FatxIncrementDismountBlockCount(volume) \
    InterlockedIncrement(&(volume)->DismountBlockCount)

//
// Macro to safely decrement the dismount block count for the volume and to take
// action if the count indicates that a dismount should occur.
//

#define FatxDecrementDismountBlockCount(volume) \
    if (InterlockedDecrement(&(volume)->DismountBlockCount) < 0) \
        FatxSignalDismountUnblockEvent(volume)

//
// Macro to filter out unrecognized directory entry attributes.
//

#define FatxFilterFileAttributes(attributes) \
    ((attributes) & (FILE_ATTRIBUTE_READONLY | \
    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | \
    FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_ARCHIVE))

//
// Macro to verify that the directory entry attributes are valid.
//

#define FatxIsValidFileAttributes(attributes) \
    FatxIsFlagClear(attributes, ~(FILE_ATTRIBUTE_READONLY | \
    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | \
    FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_ARCHIVE))

//
// Structures to support asynchronous I/O.
//

typedef struct _FAT_ASYNC_IO_ENTRY {
    ULONG PhysicalSector;
    ULONG PhysicalIoLength;
} FAT_ASYNC_IO_ENTRY, *PFAT_ASYNC_IO_ENTRY;

typedef struct _FAT_ASYNC_IO_DESCRIPTOR {
    ULONG MajorFunction;
    ULONG IoLength;
    ULONG IoLengthRemaining;
    ULONG BufferOffset;
    ULONG NextAsyncIoEntry;
    PFAT_FCB FileFcb;
    FAT_ASYNC_IO_ENTRY Entries[0];
} FAT_ASYNC_IO_DESCRIPTOR, *PFAT_ASYNC_IO_DESCRIPTOR;

//
// Structures to support cluster allocation.
//

typedef struct _FAT_CLUSTER_RUN {
    ULONG PhysicalClusterNumber;
    ULONG ClusterRunLength;
} FAT_CLUSTER_RUN, *PFAT_CLUSTER_RUN;

#define FAT_MAXIMUM_CLUSTER_RUNS                FAT_FILE_CLUSTER_CACHE_ENTRIES

//
// File system dismount routine.
//

NTSTATUS
FatxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// IRP dispatch routines.
//

NTSTATUS
FatxFsdCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdFlushBuffers(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// File control block support routines.
//

NTSTATUS
FatxCreateFcb(
    IN PFAT_FCB ParentFcb OPTIONAL,
    IN ULONG FirstCluster,
    IN PDIRENT DirectoryEntry OPTIONAL,
    IN ULONG DirectoryByteOffset OPTIONAL,
    OUT PFAT_FCB *ReturnedFcb
    );

BOOLEAN
FatxFindOpenChildFcb(
    IN PFAT_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PFAT_FCB *ReturnedFcb
    );

NTSTATUS
FatxUpdateDirectoryEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb
    );

NTSTATUS
FatxMarkDirectoryEntryDeleted(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb
    );

NTSTATUS
FatxFileByteOffsetToCluster(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb,
    IN ULONG FileByteOffset,
    OUT PULONG ReturnedClusterNumber,
    OUT PULONG ReturnedClusterRunLength OPTIONAL
    );

NTSTATUS
FatxFileByteOffsetToPhysicalByteOffset(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb,
    IN ULONG FileByteOffset,
    IN BOOLEAN AcquireVolumeMutexShared,
    OUT PULONGLONG ReturnedPhysicalByteOffset,
    OUT PULONG ReturnedPhysicalRunLength
    );

VOID
FatxAppendClusterRunsToClusterCache(
    IN PFAT_FCB Fcb,
    IN ULONG FileClusterNumber,
    IN FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS],
    IN ULONG NumberOfClusterRuns
    );

NTSTATUS
FatxExtendFileAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN ULONG AllocationSize
    );

NTSTATUS
FatxSetAllocationSize(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN ULONG AllocationSize,
    IN BOOLEAN OverwritingFile,
    IN BOOLEAN DisableTruncation
    );

NTSTATUS
FatxExtendDirectoryAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb
    );

NTSTATUS
FatxIsDirectoryEmpty(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb
    );

NTSTATUS
FatxDeleteFile(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN ULONG DirectoryByteOffset
    );

VOID
FatxDereferenceFcb(
    IN PFAT_FCB Fcb
    );

//
// File allocation table management routines.
//

NTSTATUS
FatxInitializeDirectoryCluster(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG ClusterNumber
    );

NTSTATUS
FatxLinkClusterChains(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG LinkClusterNumber,
    IN ULONG StartingClusterNumber
    );

NTSTATUS
FatxAllocateClusters(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG EndingCluster,
    IN ULONG ClustersNeeded,
    OUT FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS],
    OUT PULONG NumberOfClusterRuns,
    OUT PULONG ReturnedEndingCluster
    );

BOOLEAN
FatxFreeClusters(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG ClusterNumber,
    IN BOOLEAN MarkFirstAsLast
    );

NTSTATUS
FatxInitializeAllocationSupport(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp
    );

//
// Synchronization routines.
//

VOID
FatxAcquireGlobalMutexExclusive(
    VOID
    );

VOID
FatxReleaseGlobalMutex(
    VOID
    );

VOID
FatxAcquireVolumeMutexExclusive(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    );

VOID
FatxAcquireVolumeMutexShared(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    );

VOID
FatxReleaseVolumeMutex(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    );

#if DBG

VOID
FatxDpcReleaseVolumeMutex(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    );

#else

#define FatxDpcReleaseVolumeMutex(volume) \
    ExReleaseReadWriteLock(&(volume)->VolumeMutex)

#endif

VOID
FatxAcquireFileMutexExclusive(
    IN PFAT_FCB FileFcb
    );

VOID
FatxAcquireFileMutexShared(
    IN PFAT_FCB FileFcb
    );

VOID
FatxReleaseFileMutex(
    IN PFAT_FCB FileFcb
    );

#if DBG

VOID
FatxDpcReleaseFileMutex(
    IN PFAT_FCB FileFcb
    );

#else

#define FatxDpcReleaseFileMutex(filefcb) \
    ExReleaseReadWriteLock(&(filefcb)->File.FileMutex)

#endif

#define FatxAcquireClusterCacheMutex(volume) \
    RtlEnterCriticalSection(&(volume)->ClusterCacheMutex)

#define FatxReleaseClusterCacheMutex(volume) \
    RtlLeaveCriticalSection(&(volume)->ClusterCacheMutex)

//
// Miscellaneous routines.
//

BOOLEAN
FatxIsValidFatFileName(
    IN POBJECT_STRING FileName
    );

LARGE_INTEGER
FatxFatTimestampToTime(
    IN PFAT_TIME_STAMP FatTimestamp
    );

LOGICAL
FatxTimeToFatTimestamp(
    IN PLARGE_INTEGER Time,
    OUT PFAT_TIME_STAMP FatTimestamp
    );

LARGE_INTEGER
FatxRoundToFatTime(
    IN PLARGE_INTEGER Time
    );

NTSTATUS
FatxLookupElementNameInDirectory(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN POBJECT_STRING ElementName,
    OUT PDIRENT ReturnedDirectoryEntry,
    OUT PULONG ReturnedDirectoryByteOffset,
    OUT PULONG ReturnedEmptyDirectoryByteOffset
    );

NTSTATUS
FatxFindNextDirectoryEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN ULONG DirectoryByteOffset,
    IN POBJECT_STRING TemplateFileName,
    OUT PDIRENT ReturnedDirectoryEntry,
    OUT PULONG ReturnedDirectoryByteOffset
    );

NTSTATUS
FatxVolumeIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
FatxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    );

VOID
FatxSignalDismountUnblockEvent(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    );

//
// External symbols.
//

extern DRIVER_OBJECT FatxDriverObject;

extern
UCHAR
FASTCALL
RtlFindFirstSetRightMember(
    IN ULONG Set
    );

#include <poppack.h>

#endif  // FATX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\flush.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module implements routines related to handling IRP_MJ_FLUSH_BUFFERS.

--*/

#include "fatx.h"

NTSTATUS
FatxFsdFlushBuffers(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_FLUSH_BUFFERS
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    FatxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {

        FatxReleaseVolumeMutex(VolumeExtension);

        Irp->IoStatus.Status = STATUS_VOLUME_DISMOUNTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    // Initialize the next IRP stack location.
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Set a completion routine to unlock the volume mutex.
    //

    IoSetCompletionRoutine(Irp, FatxVolumeIoCompletion, NULL, TRUE, TRUE, TRUE);

    //
    // Call down to the target device.
    //

    status = IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

    //
    // Leave the critical region that we acquired when we took the volume mutex.
    //

    KeLeaveCriticalRegion();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\fsctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_FILE_SYSTEM_CONTROL.

--*/

#include "fatx.h"

VOID
FatxSignalDismountUnblockEvent(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine signals the volume's dismount unblock event when the volume's
    dismount block count is negative.

Arguments:

    VolumeExtension - Specifies the volume to signal the dismount unblock event
        for.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    OldIrql = KeRaiseIrqlToDpcLevel();

    if (VolumeExtension->DismountUnblockEvent != NULL) {
        KeSetEvent(VolumeExtension->DismountUnblockEvent, 0, FALSE);
    }

    KeLowerIrql(OldIrql);
}

NTSTATUS
FatxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    FSCTL_DISMOUNT_VOLUME requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

Return Value:

    Status of operation.

--*/
{
    PFAT_VOLUME_EXTENSION VolumeExtension;
    KEVENT DismountUnblockEvent;
    KIRQL OldIrql;
    ULONG FileObjectCount;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume is already marked for dismount.  If not, mark it for
    // dismount.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        FatxReleaseVolumeMutex(VolumeExtension);
        return STATUS_VOLUME_DISMOUNTED;
    }

    VolumeExtension->Flags |= FAT_VOLUME_DISMOUNTED;

    //
    // Synchronize the dismount operation with any read and write operations
    // already in progress.  When all read and write operations have completed,
    // the DismountBlockCount will be zero.  If the DismountBlockCount is not
    // zero at this point, then we need to block.  Whenever a read or write
    // operation completes, the DismountBlockCount is decremented and if the
    // count is negative, then that indicates that this routine is blocked
    // waiting for the operation to complete.
    //
    // A read or write operation can complete from a DPC, so we need to
    // synchronize access to the DismountBlockCount and DismountUnblockEvent at
    // DISPATCH_LEVEL.
    //

    KeInitializeEvent(&DismountUnblockEvent, SynchronizationEvent, FALSE);

    OldIrql = KeRaiseIrqlToDpcLevel();

    ASSERT(VolumeExtension->DismountUnblockEvent == NULL);
    VolumeExtension->DismountUnblockEvent = &DismountUnblockEvent;

    if (VolumeExtension->DismountBlockCount > 0) {

        //
        // Decrement the dismount count so that the lowest possible state is
        // negative one, which FatxDecrementDismountBlockCount uses as the
        // trigger to know that we need to be signaled.
        //

        VolumeExtension->DismountBlockCount--;

        //
        // Wait for the unblock event to be signaled outside of the raised IRQL
        // and ownership of the volume's mutex.  We don't have to worry about
        // another thread attempting to dismount this volume because the above
        // code has already marked the volume as dismounted, so another dismount
        // request will fail.
        //

        KeLowerIrql(OldIrql);
        FatxReleaseVolumeMutex(VolumeExtension);

        KeWaitForSingleObject(&DismountUnblockEvent, Executive, KernelMode,
            FALSE, NULL);

        FatxAcquireVolumeMutexExclusive(VolumeExtension);
        OldIrql = KeRaiseIrqlToDpcLevel();

        //
        // Boost the lowest possible state back up to zero so that read and
        // write operations to the dismounted volume don't keep calling
        // FatxSignalDismountUnblockEvent.
        //

        VolumeExtension->DismountBlockCount++;
    }

    ASSERT(VolumeExtension->DismountUnblockEvent == &DismountUnblockEvent);
    VolumeExtension->DismountUnblockEvent = NULL;

    KeLowerIrql(OldIrql);

    //
    // Invalidate any file system cache buffers for this device.
    // FatxDeleteVolumeDevice will also invalidate the cache, but we might as
    // well release as many cache pages as we can now.
    //

    FscInvalidateDevice(&VolumeExtension->CacheExtension);

    //
    // Synchronize access to the MountedOrSelfDevice with the I/O manager by
    // raising to DISPATCH_LEVEL.
    //
    // Clear out the target device object's MountedOrSelfDevice field.  That
    // will cause future accesses to the target device object to mount a new
    // file system device object.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    VolumeExtension->TargetDeviceObject->MountedOrSelfDevice = NULL;

    KeLowerIrql(OldIrql);

    //
    // Release the reference on the target device object.
    //

    ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    VolumeExtension->TargetDeviceObject = NULL;

    //
    // Take a snapshot of the file object count, release the volume mutex, and
    // delete the volume device if the file object count is zero.  This won't
    // normally happen since there's probably an open handle in order to make
    // this dismount call, but it could happen if an IRP was submitted directly
    // to the device object.
    //
    // We'll print out a debug message if the file object count is greater than
    // two.  XUnmountMU dismounts a volume with two file objects outstanding, so
    // anything beyond that represents some user file that hasn't been closed.
    //

    FileObjectCount = VolumeExtension->FileObjectCount;

    FatxReleaseVolumeMutex(VolumeExtension);

    if (FileObjectCount == 0) {
        FatxDeleteVolumeDevice(DeviceObject);
    } else if (FileObjectCount > 2) {
        FatxDbgPrint(("FATX: dismounting volume %p with %d open file handles\n",
            VolumeExtension, FileObjectCount));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FatxReadWriteVolumeMetadata(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    FSCTL_READ_VOLUME_METADATA and FSCTL_WRITE_VOLUME_METADATA requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFSCTL_VOLUME_METADATA FsctlVolumeMetadata;
    BOOLEAN WritingMetadata;
    PVOID CacheBuffer;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength <
        sizeof(FSCTL_VOLUME_METADATA)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Verify that the starting byte offset and transfer length are valid.  The
    // volume metadata sector is at least 4096 bytes in length.
    //

    FsctlVolumeMetadata =
        (PFSCTL_VOLUME_METADATA)IrpSp->Parameters.FileSystemControl.InputBuffer;

    if ((FsctlVolumeMetadata->ByteOffset >= PAGE_SIZE) ||
        (FsctlVolumeMetadata->TransferLength > PAGE_SIZE) ||
        ((FsctlVolumeMetadata->ByteOffset +
            FsctlVolumeMetadata->TransferLength) > PAGE_SIZE)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Map the volume metadata block into the file system cache.
    //

    WritingMetadata = (BOOLEAN)(IrpSp->Parameters.FileSystemControl.FsControlCode ==
        FSCTL_WRITE_VOLUME_METADATA);

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp, 0,
        WritingMetadata, &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    if (WritingMetadata) {

        //
        // Copy from the transfer buffer to the volume metadata block and write
        // out the changes.
        //

        RtlCopyMemory((PUCHAR)CacheBuffer + FsctlVolumeMetadata->ByteOffset,
            FsctlVolumeMetadata->TransferBuffer, FsctlVolumeMetadata->TransferLength);

        status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp, 0,
            PAGE_SIZE, CacheBuffer);

    } else {

        //
        // Copy from the volume metadata block to the transfer buffer.
        //

        RtlCopyMemory(FsctlVolumeMetadata->TransferBuffer, (PUCHAR)CacheBuffer +
            FsctlVolumeMetadata->ByteOffset, FsctlVolumeMetadata->TransferLength);

        FscUnmapBuffer(CacheBuffer);

        status = STATUS_SUCCESS;
    }

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    return status;
}

NTSTATUS
FatxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_FILE_SYSTEM_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_DISMOUNT_VOLUME:
            status = FatxDismountVolume(DeviceObject);
            break;

        case FSCTL_READ_VOLUME_METADATA:
        case FSCTL_WRITE_VOLUME_METADATA:
            status = FatxReadWriteVolumeMetadata(DeviceObject, Irp);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\readwrit.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    readwrit.c

Abstract:

    This module implements routines related to handling IRP_MJ_READ and
    IRP_MJ_WRITE.

--*/

#include "fatx.h"

//
// Local support.
//

VOID
FatxStartNextAsynchronousIoEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_ASYNC_IO_DESCRIPTOR AsyncIoDescriptor
    );

NTSTATUS
FatxVolumeIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to process the completion of a volume I/O transfer.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Propagate the pending flag up the IRP stack.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Check if this is a read or write completion.  This completion routine is
    // shared by other IRP dispatch routines.
    //

    if ((IrpSp->MajorFunction == IRP_MJ_READ) ||
        (IrpSp->MajorFunction == IRP_MJ_WRITE)) {

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            ASSERT(Irp->IoStatus.Information > 0);
            ASSERT(FatxIsSectorAligned(VolumeExtension, Irp->IoStatus.Information));

            //
            // If the file is open for synchronous I/O, then we need to update
            // the current file position.
            //

            FileObject = IrpSp->FileObject;

            if (FatxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
                FileObject->CurrentByteOffset.QuadPart =
                    IrpSp->Parameters.Read.ByteOffset.QuadPart +
                    Irp->IoStatus.Information;
            }
        }
    }

    FatxDpcReleaseVolumeMutex(VolumeExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
FatxSignalIoEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to signal an event when a thread is blocked on an
    I/O operation inside an IRP dispatch routine.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    KeSetEvent((PKEVENT)Context, IO_DISK_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
FatxSynchronousIoTail(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG FileByteOffset,
    IN ULONG IoLength
    )
/*++

Routine Description:

    This routine is called at the tail of the non-cached and cached synchronous
    I/O routines to update the state in the file control block and file objects.

    This routine is only called on success from these other routines.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    MajorFunction - Specifies the function to be performed; either IRP_MJ_READ
        or IRP_MJ_WRITE.

    FileObject - Specifies the file object that the I/O request is for.

    FileByteOffset - Specifies the file byte offset where the transfer started
        from.

    IoLength - Specifies the number of bytes that were transferred.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_FCB FileFcb;
    ULONG EndingByteOffset;
    ULONG OriginalFileSize;

    FileFcb = (PFAT_FCB)FileObject->FsContext;

    EndingByteOffset = FileByteOffset + IoLength;

    //
    // If we've written to the file, then update the last write time.  The last
    // write time is lazily flushed to the directory entry.  We need to acquire
    // the volume mutex for exclusive access to synchronize with
    // FatxFsdSetInformation and to write out any directory changes below.
    //

    if (MajorFunction == IRP_MJ_WRITE) {

        FatxAcquireVolumeMutexExclusive(VolumeExtension);

        if (FatxIsFlagClear(FileFcb->Flags, FAT_FCB_DISABLE_LAST_WRITE_TIME)) {
            KeQuerySystemTime(&FileFcb->LastWriteTime);
            FileFcb->Flags |= FAT_FCB_UPDATE_DIRECTORY_ENTRY;
        }

        //
        // If the ending byte offset is beyond the current size of the file,
        // then we've extended the file.  Change the file size to the new size
        // and commit the directory change.
        //

        if (EndingByteOffset > FileFcb->FileSize) {

            OriginalFileSize = FileFcb->FileSize;
            FileFcb->FileSize = EndingByteOffset;

            status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);

            if (!NT_SUCCESS(status)) {
                FileFcb->FileSize = OriginalFileSize;
                FatxReleaseVolumeMutex(VolumeExtension);
                return status;
            }
        }

        FatxReleaseVolumeMutex(VolumeExtension);
    }

    //
    // If the file is open for synchronous I/O, then we need to update the
    // current file position.
    //

    if (FatxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
        FileObject->CurrentByteOffset.LowPart = EndingByteOffset;
        FileObject->CurrentByteOffset.HighPart = 0;
    }

    //
    // Fill in the number of bytes of transferred.  This number may be less than
    // the actual number of modified bytes in the buffer if we're at the end of
    // file.
    //

    Irp->IoStatus.Information = IoLength;

    return STATUS_SUCCESS;
}

NTSTATUS
FatxNonCachedSynchronousIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG FileByteOffset,
    IN ULONG BufferByteOffset,
    IN ULONG IoLength,
    IN BOOLEAN PartialTransfer
    )
/*++

Routine Description:

    This routine is called to synchronously read or write a sector aligned
    buffer from or to the target device.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    MajorFunction - Specifies the function to be performed; either IRP_MJ_READ
        or IRP_MJ_WRITE.

    FileObject - Specifies the file object that the I/O request is for.

    FileByteOffset - Specifies the file byte offset to start the transfer from.

    BufferByteOffset - Specifies the buffer byte offset ot start the transfer
        from.

    IoLength - Specifies the number of bytes to transfer.

    PartialTransfer - TRUE if called from FatxPartiallyCachedSynchronousIo, else
        FALSE.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFAT_FCB Fcb;
    PIO_STACK_LOCATION NextIrpSp;
    ULONG OriginalFileByteOffset;
    ULONG IoLengthRemaining;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    ULONGLONG StartingPhysicalByteOffset;
    ULONG PhysicalIoLength;
    ULONGLONG AdjacentPhysicalByteOffset;
    KEVENT IoEvent;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    Fcb = (PFAT_FCB)FileObject->FsContext;
    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    OriginalFileByteOffset = FileByteOffset;
    IoLengthRemaining = FatxRoundToSectors(VolumeExtension, IoLength);

    ASSERT(IoLengthRemaining > 0);
    ASSERT(FatxIsSectorAligned(VolumeExtension, FileByteOffset));

    //
    // Get the physical byte offset corresponding to the starting byte offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp, Fcb,
        FileByteOffset, TRUE, &PhysicalByteOffset, &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Do the transfer.
    //

    do {

        StartingPhysicalByteOffset = PhysicalByteOffset;

        //
        // Compute how many physical bytes we can process in this pass.  The
        // cluster cache doesn't follow adjacent clusters that cross cache pages
        // so we handle that logic here by increasing the physical I/O length
        // until we find a non-adjacent cluster run.  This non-adjacent cluster
        // run is the starting cluster for the next iteration of the outer loop.
        //

        PhysicalIoLength = 0;

        do {

            //
            // Limit the number of bytes in the physical run to the number of
            // bytes left to process.
            //

            if (PhysicalRunLength > IoLengthRemaining) {
                PhysicalRunLength = IoLengthRemaining;
                IoLengthRemaining = 0;
            } else {
                IoLengthRemaining -= PhysicalRunLength;
            }

            //
            // Update the number of physical bytes we can process and the offset
            // into the file.
            //

            PhysicalIoLength += PhysicalRunLength;
            FileByteOffset += PhysicalRunLength;

            if (IoLengthRemaining == 0) {
                break;
            }

            //
            // Compute the physical byte offset for the adjacent run.
            //

            AdjacentPhysicalByteOffset = PhysicalByteOffset + PhysicalRunLength;

            //
            // Obtain the next physical run.
            //

            status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension,
                Irp, Fcb, FileByteOffset, TRUE, &PhysicalByteOffset,
                &PhysicalRunLength);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            //
            // If the next physical byte offset isn't adjacent to the last
            // physical run, then we're done.
            //

        } while (PhysicalByteOffset == AdjacentPhysicalByteOffset);

        //
        // Invalidate any file system cache buffers for this byte range if this
        // is a write operation.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            FscInvalidateByteRange(&VolumeExtension->CacheExtension,
                StartingPhysicalByteOffset, PhysicalIoLength);
        }

        //
        // Initialize (or reinitialize) the synchronization event we'll use to
        // block for the port driver to handle the I/O.
        //

        KeInitializeEvent(&IoEvent, SynchronizationEvent, FALSE);

        //
        // Fill in the starting physical byte offset and the number of bytes to
        // transfer.
        //

        NextIrpSp->Parameters.Read.ByteOffset.QuadPart =
            StartingPhysicalByteOffset;
        NextIrpSp->Parameters.Read.Length = PhysicalIoLength;

        //
        // Fill in the offset into the buffer to start the transfer and update
        // that offset by the number of bytes we'll physically transfer.
        //

        NextIrpSp->Parameters.Read.BufferOffset = BufferByteOffset;
        BufferByteOffset += PhysicalIoLength;

        //
        // Fill in the header for the stack location.  This clears out the
        // MinorFunction, Control, and Flags field as well.
        //

        *((PULONG)&NextIrpSp->MajorFunction) = MajorFunction;

        //
        // Set the completion routine that will signal our synchronization
        // event.
        //

        IoSetCompletionRoutine(Irp, FatxSignalIoEventCompletion, &IoEvent, TRUE,
            TRUE, TRUE);

        //
        // Call down to the target device and block for the I/O to complete.
        //

        status = IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&IoEvent, Executive, KernelMode, FALSE, NULL);
            status = Irp->IoStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Assert that the device handled as many bytes as we programmed it to.
        //

        ASSERT(Irp->IoStatus.Information == PhysicalIoLength);

    } while (IoLengthRemaining > 0);

    if (!PartialTransfer) {
        status = FatxSynchronousIoTail(VolumeExtension, Irp, MajorFunction,
            FileObject, OriginalFileByteOffset, IoLength);
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
FatxNonCachedAsynchronousIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to process the completion of a non-cached
    asynchronous I/O transfer.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFAT_ASYNC_IO_DESCRIPTOR AsyncIoDescriptor;
    PFAT_FCB FileFcb;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    AsyncIoDescriptor = (PFAT_ASYNC_IO_DESCRIPTOR)Context;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        //
        // If there are still more bytes to transfer, then start the entry and
        // bail out.
        //

        if (AsyncIoDescriptor->IoLengthRemaining > 0) {
            FatxStartNextAsynchronousIoEntry(VolumeExtension, Irp,
                AsyncIoDescriptor);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        //
        // If this was a file write, then we need to update the last write time.
        //

        if (AsyncIoDescriptor->MajorFunction == IRP_MJ_WRITE) {

            FileFcb = AsyncIoDescriptor->FileFcb;

            if (FatxIsFlagClear(FileFcb->Flags, FAT_FCB_DISABLE_LAST_WRITE_TIME)) {
                KeQuerySystemTime(&FileFcb->LastWriteTime);
                FileFcb->Flags |= FAT_FCB_UPDATE_DIRECTORY_ENTRY;
            }
        }

        //
        // Fill in the number of bytes of transferred.  This number may be less
        // than the actual number of modified bytes in the buffer if we're at
        // the end of file.
        //

        Irp->IoStatus.Information = AsyncIoDescriptor->IoLength;
    }

    FatxDecrementDismountBlockCount(VolumeExtension);
    FatxDpcReleaseFileMutex(AsyncIoDescriptor->FileFcb);

    ExFreePool(AsyncIoDescriptor);

    return STATUS_SUCCESS;
}

VOID
FatxStartNextAsynchronousIoEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_ASYNC_IO_DESCRIPTOR AsyncIoDescriptor
    )
/*++

Routine Description:

    This routine is called to start the next read or write from the supplied
    asynchronous I/O descriptor.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    AsyncIoDescriptor - Specifies the asynchronous I/O descriptor that indicates
        the next starting physical sector and transfer length.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION NextIrpSp;
    PFAT_ASYNC_IO_ENTRY AsyncIoEntry;
    ULONG PhysicalIoLength;

    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    AsyncIoEntry = &AsyncIoDescriptor->Entries[AsyncIoDescriptor->NextAsyncIoEntry++];
    PhysicalIoLength = AsyncIoEntry->PhysicalIoLength;

    //
    // Adjust the number of bytes remaining in the transfer.
    //

    AsyncIoDescriptor->IoLengthRemaining -= PhysicalIoLength;

    //
    // Fill in the starting physical byte offset and the number of bytes to
    // transfer.
    //

    NextIrpSp->Parameters.Read.ByteOffset.QuadPart =
        (ULONGLONG)AsyncIoEntry->PhysicalSector << VolumeExtension->SectorShift;
    NextIrpSp->Parameters.Read.Length = PhysicalIoLength;

    //
    // Fill in the offset into the buffer to start the transfer and update
    // that offset by the number of bytes we'll physically transfer.
    //

    NextIrpSp->Parameters.Read.BufferOffset = AsyncIoDescriptor->BufferOffset;
    AsyncIoDescriptor->BufferOffset += PhysicalIoLength;

    //
    // Fill in the header for the stack location.  This clears out the
    // MinorFunction, Control, and Flags field as well.
    //

    *((PULONG)&NextIrpSp->MajorFunction) = AsyncIoDescriptor->MajorFunction;

    //
    // Set the completion routine that will start the next entry or finish the
    // transfer.
    //

    IoSetCompletionRoutine(Irp, FatxNonCachedAsynchronousIoCompletion,
        AsyncIoDescriptor, TRUE, TRUE, TRUE);

    //
    // Call down to the target device.
    //

    IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);
}

NTSTATUS
FatxNonCachedAsynchronousIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG FileByteOffset,
    IN ULONG IoLength
    )
/*++

Routine Description:

    This routine is called to asynchronously read or write a sector aligned
    buffer from or to the target device.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    MajorFunction - Specifies the function to be performed; either IRP_MJ_READ
        or IRP_MJ_WRITE.

    FileObject - Specifies the file object that the I/O request is for.

    FileByteOffset - Specifies the file byte offset to start the transfer from.

    IoLength - Specifies the number of bytes to transfer.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFAT_FCB Fcb;
    ULONG IoLengthRemaining;
    SIZE_T AsyncIoDescriptorSize;
    PFAT_ASYNC_IO_DESCRIPTOR AsyncIoDescriptor;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    PFAT_ASYNC_IO_ENTRY AsyncIoEntry;
    ULONGLONG StartingPhysicalByteOffset;
    ULONG PhysicalIoLength;
    ULONGLONG AdjacentPhysicalByteOffset;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    Fcb = (PFAT_FCB)FileObject->FsContext;
    IoLengthRemaining = FatxRoundToSectors(VolumeExtension, IoLength);

    ASSERT(IoLengthRemaining > 0);
    ASSERT(FatxIsSectorAligned(VolumeExtension, FileByteOffset));

    //
    // Always assume the worst case for the state of the file.  If the file is
    // highly fragmented, then we'll need one entry per cluster.  If the file
    // isn't fragmented, then we'll end up wasting memory, but the application
    // will always be charged a consistent number of bytes per transfer.
    //

    // DW: bug fix
    // If the area to write wraps a cluster, allocate space for one more
    // entry.  XDKs starting with 4627 patch this bug in older kernels.
    // They patch by always adding 8 extra (sizeof(FAT_ASYNC_IO_ENTRY)).
	// Note the 2 below - that used to be a 1.
	//

	AsyncIoDescriptorSize = sizeof(FAT_ASYNC_IO_DESCRIPTOR) +
        ((IoLengthRemaining >> VolumeExtension->ClusterShift) + 2) *
        sizeof(FAT_ASYNC_IO_ENTRY);

    AsyncIoDescriptor = ExAllocatePoolWithTag(AsyncIoDescriptorSize, 'dAtF');

    if (AsyncIoDescriptor == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the asynchronous I/O descriptor.
    //

    AsyncIoDescriptor->MajorFunction = MajorFunction;
    AsyncIoDescriptor->IoLength = IoLength;
    AsyncIoDescriptor->IoLengthRemaining = IoLengthRemaining;
    AsyncIoDescriptor->BufferOffset = 0;
    AsyncIoDescriptor->NextAsyncIoEntry = 0;
    AsyncIoDescriptor->FileFcb = Fcb;

    //
    // Get the physical byte offset corresponding to the starting byte offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp, Fcb,
        FileByteOffset, TRUE, &PhysicalByteOffset, &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Fill in the entries of the asynchronous I/O descriptor.
    //

    AsyncIoEntry = AsyncIoDescriptor->Entries;

    do {

        StartingPhysicalByteOffset = PhysicalByteOffset;

        //
        // Compute how many physical bytes we can process in this pass.  The
        // cluster cache doesn't follow adjacent clusters that cross cache pages
        // so we handle that logic here by increasing the physical I/O length
        // until we find a non-adjacent cluster run.  This non-adjacent cluster
        // run is the starting cluster for the next iteration of the outer loop.
        //

        PhysicalIoLength = 0;

        do {

            //
            // Limit the number of bytes in the physical run to the number of
            // bytes left to process.
            //

            if (PhysicalRunLength > IoLengthRemaining) {
                PhysicalRunLength = IoLengthRemaining;
                IoLengthRemaining = 0;
            } else {
                IoLengthRemaining -= PhysicalRunLength;
            }

            //
            // Update the number of physical bytes we can process and the offset
            // into the file.
            //

            PhysicalIoLength += PhysicalRunLength;
            FileByteOffset += PhysicalRunLength;

            if (IoLengthRemaining == 0) {
                break;
            }

            //
            // Compute the physical byte offset for the adjacent run.
            //

            AdjacentPhysicalByteOffset = PhysicalByteOffset + PhysicalRunLength;

            //
            // Obtain the next physical run.
            //

            status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension,
                Irp, Fcb, FileByteOffset, TRUE, &PhysicalByteOffset,
                &PhysicalRunLength);

            if (!NT_SUCCESS(status)) {
                ExFreePool(AsyncIoDescriptor);
                return status;
            }

            //
            // If the next physical byte offset isn't adjacent to the last
            // physical run, then we're done.
            //

        } while (PhysicalByteOffset == AdjacentPhysicalByteOffset);

        ASSERT(FatxIsSectorAligned(VolumeExtension, PhysicalIoLength));

        //
        // Invalidate any file system cache buffers for this byte range if this
        // is a write operation.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            FscInvalidateByteRange(&VolumeExtension->CacheExtension,
                StartingPhysicalByteOffset, PhysicalIoLength);
        }

        //
        // Fill in the starting physical byte offset and the number of bytes to
        // transfer.
        //

        AsyncIoEntry->PhysicalSector = (ULONG)(StartingPhysicalByteOffset >>
            VolumeExtension->SectorShift);
        AsyncIoEntry->PhysicalIoLength = PhysicalIoLength;
        AsyncIoEntry++;

    } while (IoLengthRemaining > 0);

    //
    // Start transferring the first entry in the asynchronous I/O descriptor.
    //

    IoMarkIrpPending(Irp);

    FatxStartNextAsynchronousIoEntry(VolumeExtension, Irp,
        AsyncIoDescriptor);

    return STATUS_PENDING;
}

NTSTATUS
FatxFullyCachedSynchronousIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG FileByteOffset,
    IN ULONG BufferByteOffset,
    IN ULONG IoLength,
    IN BOOLEAN PartialTransfer
    )
/*++

Routine Description:

    This routine is called to synchronously read or write a buffer through the
    file system cache.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    MajorFunction - Specifies the function to be performed; either IRP_MJ_READ
        or IRP_MJ_WRITE.

    FileObject - Specifies the file object that the I/O request is for.

    FileByteOffset - Specifies the file byte offset to start the transfer from.

    BufferByteOffset - Specifies the buffer byte offset ot start the transfer
        from.

    IoLength - Specifies the number of bytes to transfer.

    PartialTransfer - TRUE if called from FatxPartiallyCachedSynchronousIo, else
        FALSE.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFAT_FCB Fcb;
    ULONG OriginalFileByteOffset;
    ULONG IoLengthRemaining;
    PVOID UserBuffer;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    ULONG PhysicalRunBytesRemaining;
    PVOID CacheBuffer;
    ULONG BytesToCopy;
    BOOLEAN MapEmptyBuffer;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    Fcb = (PFAT_FCB)FileObject->FsContext;
    OriginalFileByteOffset = FileByteOffset;
    IoLengthRemaining = IoLength;
    UserBuffer = (PUCHAR)Irp->UserBuffer + BufferByteOffset;

    ASSERT(IoLengthRemaining > 0);

    //
    // Get the physical byte offset corresponding to the starting byte offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp, Fcb,
        FileByteOffset, TRUE, &PhysicalByteOffset, &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Do the transfer.
    //

    for (;;) {

        PhysicalRunBytesRemaining = PhysicalRunLength;

        do {

            //
            // Compute the number of bytes remaining on this cache buffer.
            //

            BytesToCopy = PAGE_SIZE - BYTE_OFFSET(PhysicalByteOffset);

            //
            // Adjust the number of bytes remaining in this physical run and the
            // next cache byte offset depending on whether we're near the end of
            // the run or not.
            //

            if (BytesToCopy < PhysicalRunBytesRemaining) {
                PhysicalRunBytesRemaining -= BytesToCopy;
            } else {
                BytesToCopy = PhysicalRunBytesRemaining;
                PhysicalRunBytesRemaining = 0;
            }

            //
            // Limit the number of bytes copied to the number of bytes we
            // actually need.
            //

            if (BytesToCopy > IoLengthRemaining) {
                BytesToCopy = IoLengthRemaining;
            }

            if (MajorFunction == IRP_MJ_WRITE) {

                //
                // If we're going to be writing out an entire page or if we're
                // going to be writing to the first byte of the last page of the
                // file, then we can map in an empty cache page.
                //

                if (BytesToCopy == PAGE_SIZE) {
                    MapEmptyBuffer = TRUE;
                } else if ((BYTE_OFFSET(FileByteOffset) == 0) &&
                    (FileByteOffset + IoLengthRemaining >= Fcb->FileSize)) {
                    MapEmptyBuffer = TRUE;
                } else {
                    MapEmptyBuffer = FALSE;
                }

                //
                // Map in the next page of the physical run.
                //

                if (MapEmptyBuffer) {
                    status = FscMapEmptyBuffer(&VolumeExtension->CacheExtension,
                        PhysicalByteOffset, &CacheBuffer);
                } else {
                    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                        PhysicalByteOffset, TRUE, &CacheBuffer);
                }

                if (!NT_SUCCESS(status)) {
                    return status;
                }

                //
                // Write to the cache buffer and unmap the cache buffer.
                //

                RtlCopyMemory(CacheBuffer, UserBuffer, BytesToCopy);

                status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp,
                    PhysicalByteOffset, BytesToCopy, CacheBuffer);

                if (!NT_SUCCESS(status)) {
                    return status;
                }

            } else {

                //
                // Map in the next page of the physical run.
                //

                status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                    PhysicalByteOffset, FALSE, &CacheBuffer);

                if (!NT_SUCCESS(status)) {
                    return status;
                }

                //
                // Read from the cache buffer and unmap the cache buffer.
                //

                RtlCopyMemory(UserBuffer, CacheBuffer, BytesToCopy);
                FscUnmapBuffer(CacheBuffer);
            }

            //
            // Adjust the number of bytes remaining and check if we're through
            // with the transfer.
            //

            PhysicalByteOffset += BytesToCopy;
            IoLengthRemaining -= BytesToCopy;

            if (IoLengthRemaining == 0) {

                if (!PartialTransfer) {
                    status = FatxSynchronousIoTail(VolumeExtension, Irp,
                        MajorFunction, FileObject, OriginalFileByteOffset,
                        IoLength);
                } else {
                    status = STATUS_SUCCESS;
                }

                return status;
            }

            //
            // There's still more bytes to transfer.  Update the other loop
            // variables and continue transfering this physical run.
            //

            FileByteOffset += BytesToCopy;
            UserBuffer = (PUCHAR)UserBuffer + BytesToCopy;

        } while (PhysicalRunBytesRemaining > 0);

        //
        // Obtain the next physical run.
        //

        status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp,
            Fcb, FileByteOffset, TRUE, &PhysicalByteOffset, &PhysicalRunLength);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }
}

NTSTATUS
FatxPartiallyCachedSynchronousIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG FileByteOffset,
    IN ULONG IoLength,
    IN BOOLEAN NonCachedEndOfFileTransfer
    )
/*++

Routine Description:

    This routine is called to synchronously read or write a buffer partially
    through the file system cache and partially through direct device I/O.  This
    routine is intended for large I/O transfers where we want to maximize use of
    direct device I/O in order to avoid PAGE_SIZE I/O transfers.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    MajorFunction - Specifies the function to be performed; either IRP_MJ_READ
        or IRP_MJ_WRITE.

    FileObject - Specifies the file object that the I/O request is for.

    FileByteOffset - Specifies the file byte offset to start the transfer from.

    IoLength - Specifies the number of bytes to transfer.

    NonCachedEndOfFileTransfer - Specifies TRUE if the read is to the end of
        file and the output buffer is large enough to hold the transfer length
        rounded up to a sector boundary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    ULONG OriginalFileByteOffset;
    ULONG OriginalIoLength;
    ULONG PartialIoLength;
    ULONG BufferByteOffset;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    OriginalFileByteOffset = FileByteOffset;
    OriginalIoLength = IoLength;

    //
    // The below code assumes that the relative byte offsets into the file and
    // the file area have the same page alignment as their corresponding
    // physical byte offsets.
    //

    ASSERT(BYTE_OFFSET(VolumeExtension->FileAreaByteOffset) == 0);

    //
    // Transfer the head of the request if it's not page aligned.
    //

    if (BYTE_OFFSET(FileByteOffset) != 0) {

        PartialIoLength = PAGE_SIZE - BYTE_OFFSET(FileByteOffset);

        ASSERT(PartialIoLength < IoLength);

        status = FatxFullyCachedSynchronousIo(DeviceObject, Irp, MajorFunction,
            FileObject, FileByteOffset, 0, PartialIoLength, TRUE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        IoLength -= PartialIoLength;
        FileByteOffset += PartialIoLength;
        BufferByteOffset = PartialIoLength;

    } else {
        BufferByteOffset = 0;
    }

    //
    // If NonCachedEndOfFileTransfer is TRUE, then we're reading to the end of
    // the file and the transfer buffer is large enough to hold the transfer
    // length rounded up to a sector boundary.
    //

    if (NonCachedEndOfFileTransfer) {
        ASSERT(MajorFunction == IRP_MJ_READ);
        IoLength = FatxRoundToSectors(VolumeExtension, IoLength);
        PartialIoLength = IoLength;
    } else {
        ASSERT(IoLength >= PAGE_SIZE);
        PartialIoLength = (ULONG)PAGE_ALIGN(IoLength);
    }

    status = FatxNonCachedSynchronousIo(DeviceObject, Irp, MajorFunction,
        FileObject, FileByteOffset, BufferByteOffset, PartialIoLength, TRUE);

    //
    // Transfer the remaining non whole page of the request if necessary.
    //

    if (NT_SUCCESS(status)) {

        IoLength -= PartialIoLength;

        if (IoLength > 0) {

            FileByteOffset += PartialIoLength;
            BufferByteOffset += PartialIoLength;

            status = FatxFullyCachedSynchronousIo(DeviceObject, Irp,
                MajorFunction, FileObject, FileByteOffset, BufferByteOffset,
                IoLength, TRUE);
        }
    }

    if (NT_SUCCESS(status)) {
        status = FatxSynchronousIoTail(VolumeExtension, Irp, MajorFunction,
            FileObject, OriginalFileByteOffset, OriginalIoLength);
    }

    return status;
}

NTSTATUS
FatxFsdReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_READ and
    IRP_MJ_WRITE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    UCHAR MajorFunction;
    PFILE_OBJECT FileObject;
    PFAT_FCB Fcb;
    ULONG IoLength;
    BOOLEAN NonCachedEndOfFileTransfer;
    ULONGLONG PartitionBytesRemaining;
    ULONG FileBytesRemaining;
    BOOLEAN SynchronousIo;
    ULONG EndingByteOffset;
    ULONG ClusterNumber;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    MajorFunction = IrpSp->MajorFunction;
    FileObject = IrpSp->FileObject;
    Fcb = (PFAT_FCB)FileObject->FsContext;
    IoLength = IrpSp->Parameters.Read.Length;
    NonCachedEndOfFileTransfer = FALSE;

    //
    // Ensure that the file object is not for a directory.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto CompleteAndExit;
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (IoLength == 0) {
        Irp->IoStatus.Information = 0;
        status = STATUS_SUCCESS;
        goto CompleteAndExit;
    }

    //
    // Check if we're reading from or writing to the volume file control block.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME)) {

        if (MajorFunction == IRP_MJ_READ) {
            FatxAcquireVolumeMutexShared(VolumeExtension);
        } else {
            FatxAcquireVolumeMutexExclusive(VolumeExtension);
        }

        //
        // Check if the volume has been dismounted.
        //

        if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
            status = STATUS_VOLUME_DISMOUNTED;
            goto UnlockVolumeAndExit;
        }

        //
        // Check if the starting offset is beyond the end of the partition.
        //

        if ((ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart >=
            (ULONGLONG)VolumeExtension->PartitionLength.QuadPart) {
            status = STATUS_END_OF_FILE;
            goto UnlockVolumeAndExit;
        }

        //
        // If the number of bytes to transfer is greater than the number of
        // bytes remaining in the partition, then truncate the number of bytes
        // we'll actually transfer.
        //

        PartitionBytesRemaining =
            (ULONGLONG)VolumeExtension->PartitionLength.QuadPart -
            (ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart;

        if ((ULONGLONG)IoLength >= PartitionBytesRemaining) {
            IoLength = (ULONG)PartitionBytesRemaining;
        }

        ASSERT(IoLength > 0);

        //
        // We'll leave it to the target device's driver to validate that the
        // user's buffer, the starting byte offset, and the transfer length are
        // all properly aligned.
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // Lock the user's buffer into memory if necessary.
        //

        IoLockUserBuffer(Irp, IrpSp->Parameters.Read.Length);

        //
        // Invalidate any file system cache buffers for this byte range if this
        // is a write operation.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            FscInvalidateByteRange(&VolumeExtension->CacheExtension,
                IrpSp->Parameters.Read.ByteOffset.QuadPart, IoLength);
        }

        //
        // Limit the number of bytes physically read to the end of the volume.
        //

        NextIrpSp->Parameters.Read.Length = IoLength;

        //
        // Set a completion routine to unlock the volume mutex and update any
        // state in the file control block.
        //

        IoSetCompletionRoutine(Irp, FatxVolumeIoCompletion, NULL, TRUE, TRUE,
            TRUE);

        //
        // Call down to the target device.
        //

        status = IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

        //
        // Leave the critical region that we acquired when we took the volume
        // mutex.
        //

        KeLeaveCriticalRegion();

        return status;

UnlockVolumeAndExit:
        FatxReleaseVolumeMutex(VolumeExtension);
        goto CompleteAndExit;
    }

    //
    // Otherwise, we're reading from or writing to a standard file.
    //

    if (MajorFunction == IRP_MJ_READ) {
        FatxAcquireFileMutexShared(Fcb);
    } else {
        FatxAcquireFileMutexExclusive(Fcb);
    }

    //
    // Increment the dismount unblock count for the volume.  We won't be
    // holding the volume's mutex throughout the processing of this request,
    // so FatxDismountVolume needs to have some synchronization mechanism to
    // know when all pending read/write IRPs have completed.
    //
    // If a request enters the file system after a dismount has been
    // unblocked or completed, then the dismount flag will have been set for
    // the volume and the code below will fail the request.
    //
    // We don't need to do this for volume file control block because in
    // that code path, the volume's mutex is held for the entire operation.
    //

    FatxIncrementDismountBlockCount(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto UnlockFileAndExit;
    }

    //
    // Check if the file object has already been cleaned up.  We don't allow a
    // a file object to be modified after its handle has been closed.
    //

    if (FatxIsFlagSet(FileObject->Flags, FO_CLEANUP_COMPLETE)) {
        status = STATUS_FILE_CLOSED;
        goto UnlockFileAndExit;
    }

    if (MajorFunction == IRP_MJ_READ) {

        //
        // Check if the starting offset is beyond the end of file.
        //

        if ((IrpSp->Parameters.Read.ByteOffset.HighPart != 0) ||
            (IrpSp->Parameters.Read.ByteOffset.LowPart >= Fcb->FileSize)) {
            status = STATUS_END_OF_FILE;
            goto UnlockFileAndExit;
        }

        //
        // If the number of bytes to read is greater than the number of bytes
        // remaining in the file, then truncate the number of bytes we'll
        // actually read.
        //

        FileBytesRemaining = Fcb->FileSize -
            IrpSp->Parameters.Read.ByteOffset.LowPart;

        if (IoLength >= FileBytesRemaining) {

            //
            // If the user's buffer is large enough to hold the logical read
            // length rounded up to a sector boundary, then set a flag so that
            // the below code will potentially read this part of the file as
            // non cached.
            //

            if (IoLength >= (FatxRoundToSectors(VolumeExtension, Fcb->FileSize) -
                IrpSp->Parameters.Read.ByteOffset.LowPart)) {
                NonCachedEndOfFileTransfer = TRUE;
            }

            IoLength = FileBytesRemaining;
        }

        ASSERT(IoLength > 0);

        //
        // Check if we should do synchronous or asynchronous I/O depending on
        // how the file object was originally opened.
        //

        SynchronousIo = (BOOLEAN)FatxIsFlagSet(FileObject->Flags,
            FO_SYNCHRONOUS_IO);

    } else {

        //
        // If we're supposed to write to the end of the file, then change the
        // starting byte offset to the current end of file.
        //

        if ((IrpSp->Parameters.Read.ByteOffset.LowPart == FILE_WRITE_TO_END_OF_FILE) &&
            (IrpSp->Parameters.Read.ByteOffset.HighPart == -1)) {
            IrpSp->Parameters.Read.ByteOffset.LowPart = Fcb->FileSize;
            IrpSp->Parameters.Read.ByteOffset.HighPart = 0;
        }

        //
        // Verify that the starting or ending offset are only 32-bits.
        //

        EndingByteOffset = IrpSp->Parameters.Read.ByteOffset.LowPart + IoLength;

        if ((IrpSp->Parameters.Read.ByteOffset.HighPart != 0) ||
            (EndingByteOffset <= IrpSp->Parameters.Read.ByteOffset.LowPart)) {
            status = STATUS_DISK_FULL;
            goto UnlockFileAndExit;
        }

        //
        // Determine the number of bytes currently allocated to the file.
        //

        if (Fcb->AllocationSize == MAXULONG) {

            //
            // Attempt to find the cluster corresponding to the maximum byte
            // offset which will have the side effect of filling in the number
            // of bytes allocated.
            //

            FatxAcquireVolumeMutexShared(VolumeExtension);

            status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, Fcb,
                MAXULONG, &ClusterNumber, NULL);

            FatxReleaseVolumeMutex(VolumeExtension);

            if (!NT_SUCCESS(status) && (status != STATUS_END_OF_FILE)) {
                goto UnlockFileAndExit;
            }
        }

        //
        // If the file size is greater than the number of bytes allocated to the
        // file, then the file is corrupt and we won't allow any writes to it.
        //

        if (Fcb->FileSize > Fcb->AllocationSize) {
            status = STATUS_FILE_CORRUPT_ERROR;
            goto UnlockFileAndExit;
        }

        //
        // If the ending byte offset is greater than the number of bytes
        // allocated to the file, then we need to grow the allocation size for
        // the file.  The volume mutex must be acquired exclusively so that the
        // volume can be modified.
        //

        if (EndingByteOffset > Fcb->AllocationSize) {

            FatxAcquireVolumeMutexExclusive(VolumeExtension);

            status = FatxExtendFileAllocation(VolumeExtension, Irp, Fcb,
                FatxRoundToClusters(VolumeExtension, EndingByteOffset));

            FatxReleaseVolumeMutex(VolumeExtension);

            if (!NT_SUCCESS(status)) {
                goto UnlockFileAndExit;
            }
        }

        //
        // Check if we should do synchronous or asynchronous I/O depending on
        // how the file object was originally opened.
        //
        // If this is an asynchronous I/O operation, verify that the ending byte
        // offset is before the end of file.  If it isn't, then we can't change
        // the directory entry's file size asynchronously, so switch this back
        // to a synchronous I/O operation.
        //

        SynchronousIo = (BOOLEAN)FatxIsFlagSet(FileObject->Flags,
            FO_SYNCHRONOUS_IO);

        if (!SynchronousIo && (EndingByteOffset > Fcb->FileSize)) {
            SynchronousIo = TRUE;
        }
    }

    //
    // The upper 32-bits of the byte offset should be zero at this point.  Code
    // below this point will only look at ByteOffset.LowPart.
    //

    ASSERT(IrpSp->Parameters.Read.ByteOffset.HighPart == 0);

    //
    // Check if we're supposed to bypass the file system cache.
    //

    if (FatxIsFlagSet(Irp->Flags, IRP_NOCACHE)) {

        //
        // Verify that the starting byte offset and transfer length are sector
        // aligned.  We'll leave it to the target device's driver to validate
        // that the user's buffer is properly aligned.
        //

        if (!FatxIsSectorAligned(VolumeExtension, IrpSp->Parameters.Read.ByteOffset.LowPart) ||
            !FatxIsSectorAligned(VolumeExtension, IrpSp->Parameters.Read.Length)) {
            status = STATUS_INVALID_PARAMETER;
            goto UnlockFileAndExit;
        }

        //
        // Lock the user's buffer into memory if necessary.
        //

        IoLockUserBuffer(Irp, IrpSp->Parameters.Read.Length);

        //
        // Do the transfer depending on whether we can block waiting for the
        // I/O to complete or not.
        //

        if (SynchronousIo) {

            status = FatxNonCachedSynchronousIo(DeviceObject, Irp, MajorFunction,
                FileObject, IrpSp->Parameters.Read.ByteOffset.LowPart, 0,
                IoLength, FALSE);

        } else {

            status = FatxNonCachedAsynchronousIo(DeviceObject, Irp, MajorFunction,
                FileObject, IrpSp->Parameters.Read.ByteOffset.LowPart, IoLength);

            if (status == STATUS_PENDING) {

                //
                // Leave the critical region that we acquired when we took the
                // file mutex.
                //

                KeLeaveCriticalRegion();

                return status;
            }
        }

    } else {

        //
        // Scatter/gather operations are always non-cached.
        //

        ASSERT(FatxIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION));

        //
        // Otherwise, handle reading the data using the file cache.
        //
        // Check if this transfer should use the fully or partially cached path.
        //

        if (FscTestForFullyCachedIo(Irp, IrpSp->Parameters.Read.ByteOffset.LowPart,
            IoLength, NonCachedEndOfFileTransfer)) {

            status = FatxFullyCachedSynchronousIo(DeviceObject, Irp,
                MajorFunction, FileObject,
                IrpSp->Parameters.Read.ByteOffset.LowPart, 0, IoLength, FALSE);

        } else {

            //
            // Lock the user's buffer into memory if necessary.
            //

            IoLockUserBuffer(Irp, IrpSp->Parameters.Read.Length);

            status = FatxPartiallyCachedSynchronousIo(DeviceObject, Irp,
                MajorFunction, FileObject,
                IrpSp->Parameters.Read.ByteOffset.LowPart, IoLength,
                NonCachedEndOfFileTransfer);
        }
    }

    ASSERT(status != STATUS_PENDING);

UnlockFileAndExit:
    FatxDecrementDismountBlockCount(VolumeExtension);
    FatxReleaseFileMutex(Fcb);

CompleteAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\synch.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    synch.c

Abstract:

    This module implements routines which provide synchronization to the file
    system.

--*/

#include "fatx.h"

//
// Non volume specific file system access is guarded by this global lock.
//
INITIALIZED_CRITICAL_SECTION(FatxGlobalMutex);

VOID
FatxAcquireGlobalMutexExclusive(
    VOID
    )
/*++

Routine Description:

    This routine acquires the file system's global lock for exclusive access.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KeEnterCriticalRegion();
    RtlEnterCriticalSection(&FatxGlobalMutex);
}

VOID
FatxReleaseGlobalMutex(
    VOID
    )
/*++

Routine Description:

    This routine releases the file system's global lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RtlLeaveCriticalSection(&FatxGlobalMutex);
    KeLeaveCriticalRegion();
}

VOID
FatxAcquireVolumeMutexExclusive(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine acquires the volume's lock for exclusive access.

Arguments:

    VolumeExtension - Specifies the volume to lock.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

#if DBG
    //
    // Assert that we're not recursively entering a write lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&VolumeExtension->VolumeMutex)) {
        ASSERT(VolumeExtension->VolumeMutexExclusiveOwner != KeGetCurrentThread());
    }
#endif

    KeEnterCriticalRegion();
    ExAcquireReadWriteLockExclusive(&VolumeExtension->VolumeMutex);

#if DBG
    VolumeExtension->VolumeMutexExclusiveOwner = KeGetCurrentThread();
#endif
}

VOID
FatxAcquireVolumeMutexShared(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine acquires the volume's lock for shared access.

Arguments:

    VolumeExtension - Specifies the volume to lock.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

#if DBG
    //
    // Assert that we're not entering a read lock while owning the write lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&VolumeExtension->VolumeMutex)) {
        ASSERT(VolumeExtension->VolumeMutexExclusiveOwner != KeGetCurrentThread());
    }
#endif

    KeEnterCriticalRegion();
    ExAcquireReadWriteLockShared(&VolumeExtension->VolumeMutex);
}

VOID
FatxReleaseVolumeMutex(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine releases the volume's lock.

Arguments:

    VolumeExtension - Specifies the volume to unlock.

Return Value:

    None.

--*/
{
#if DBG
    //
    // Clear out the exclusive owner of the lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&VolumeExtension->VolumeMutex)) {
        VolumeExtension->VolumeMutexExclusiveOwner = NULL;
    }
#endif

    ExReleaseReadWriteLock(&VolumeExtension->VolumeMutex);
    KeLeaveCriticalRegion();
}

#if DBG

VOID
FatxDpcReleaseVolumeMutex(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine releases the volume's lock from an I/O completion routine.

Arguments:

    VolumeExtension - Specifies the volume to unlock.

Return Value:

    None.

--*/
{
#if DBG
    //
    // Clear out the exclusive owner of the lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&VolumeExtension->VolumeMutex)) {
        VolumeExtension->VolumeMutexExclusiveOwner = NULL;
    }
#endif

    ExReleaseReadWriteLock(&VolumeExtension->VolumeMutex);
}

#endif

VOID
FatxAcquireFileMutexExclusive(
    IN PFAT_FCB FileFcb
    )
/*++

Routine Description:

    This routine acquires the file's lock for exclusive access.

Arguments:

    FileFcb - Specifies the file control block to unlock.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));

    KeEnterCriticalRegion();
    ExAcquireReadWriteLockExclusive(&FileFcb->File.FileMutex);

#if DBG
    FileFcb->File.FileMutexExclusiveOwner = KeGetCurrentThread();
#endif
}

VOID
FatxAcquireFileMutexShared(
    IN PFAT_FCB FileFcb
    )
/*++

Routine Description:

    This routine acquires the file's lock for shared access.

Arguments:

    FileFcb - Specifies the file control block to unlock.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));

    KeEnterCriticalRegion();
    ExAcquireReadWriteLockShared(&FileFcb->File.FileMutex);
}

VOID
FatxReleaseFileMutex(
    IN PFAT_FCB FileFcb
    )
/*++

Routine Description:

    This routine releases the file's lock.

Arguments:

    FileFcb - Specifies the file control block to unlock.

Return Value:

    None.

--*/
{
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));

#if DBG
    //
    // Clear out the exclusive owner of the lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&FileFcb->File.FileMutex)) {
        FileFcb->File.FileMutexExclusiveOwner = NULL;
    }
#endif

    ExReleaseReadWriteLock(&FileFcb->File.FileMutex);
    KeLeaveCriticalRegion();
}

#if DBG

VOID
FatxDpcReleaseFileMutex(
    IN PFAT_FCB FileFcb
    )
/*++

Routine Description:

    This routine releases the file's lock from an I/O completion routine.

Arguments:

    FileFcb - Specifies the file control block to unlock.

Return Value:

    None.

--*/
{
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));

#if DBG
    //
    // Clear out the exclusive owner of the lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&FileFcb->File.FileMutex)) {
        FileFcb->File.FileMutexExclusiveOwner = NULL;
    }
#endif

    ExReleaseReadWriteLock(&FileFcb->File.FileMutex);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\create.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements routines related to handling IRP_MJ_CREATE.

--*/

#include "gdfx.h"

NTSTATUS
GdfxLookupElementNameInDirectory(
    IN PGDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PGDF_FCB DirectoryFcb,
    IN POBJECT_STRING ElementName,
    OUT PGDF_DIRECTORY_ENTRY ReturnedDirectoryEntry
    )
/*++

Routine Description:

    This routine looks up the supplied file name in the supplied directory
    file control block.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    ElementName - Specifies the name to search for in the directory.

    ReturnedDirectoryEntry - Specifies the buffer to receive the directory entry
        for the file if found.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID CacheBuffer;
    ULONG CacheBufferByteOffset;
    ULONG DirectoryByteOffset;
    PGDF_DIRECTORY_ENTRY DirectoryEntry;
    OBJECT_STRING DirectoryEntryFileName;
    LONG CompareResult;
    ULONG NewDirectoryByteOffset;

    ASSERT(GdfxIsFlagSet(DirectoryFcb->Flags, GDF_FCB_DIRECTORY));

    //
    // If this is an empty directory, then return now that the name isn't found.
    //

    if (DirectoryFcb->FileSize == 0) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    // Process the directory stream.
    //

    CacheBuffer = NULL;
    CacheBufferByteOffset = 0;
    DirectoryByteOffset = 0;

    for (;;) {

        //
        // If we haven't mapped in a cache buffer yet or if we're switching
        // sectors, then we need to switch cache buffers.
        //

        if ((CacheBuffer == NULL) ||
            (CacheBufferByteOffset != (DirectoryByteOffset & ~GDF_CD_SECTOR_MASK))) {

            if (CacheBuffer != NULL) {
                FscUnmapBuffer(CacheBuffer);
                CacheBuffer = NULL;
            }

            CacheBufferByteOffset = (DirectoryByteOffset & ~GDF_CD_SECTOR_MASK);

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                GdfxSectorToPhysicalByteOffset(DirectoryFcb->FirstSector) +
                CacheBufferByteOffset, FALSE, &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }
        }

        //
        // Make the directory byte offset relative to the current cache buffer.
        //

        DirectoryByteOffset &= GDF_CD_SECTOR_MASK;

        //
        // If there's not enough space in the current sector to hold the header
        // of a directory entry, then the directory entry is invalid and the
        // disk is corrupt.
        //
        // We check for these types of disk corruption in order to guard against
        // taking a potential page fault if we extend past the current sector.
        //

        if (DirectoryByteOffset > (GDF_CD_SECTOR_SIZE -
            FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName))) {
            GdfxDbgPrint(("GDFX: found invalid directory byte offset\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // Compute the cache buffer relative pointer to the directory entry.
        //

        DirectoryEntry = (PGDF_DIRECTORY_ENTRY)((PUCHAR)CacheBuffer +
            DirectoryByteOffset);

        //
        // If there's not enough space in the current sector to hold the header
        // and the file name, then the directory entry is invalid and the disk
        // is corrupt.
        //

        if ((DirectoryByteOffset + DirectoryEntry->FileNameLength) >
            (GDF_CD_SECTOR_SIZE - FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName))) {
            GdfxDbgPrint(("GDFX: found invalid directory byte offset\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // Check if the file name matches the name we're looking for.
        //

        DirectoryEntryFileName.Length = DirectoryEntry->FileNameLength;
        DirectoryEntryFileName.Buffer = DirectoryEntry->FileName;

        CompareResult = RtlCompareString(ElementName, &DirectoryEntryFileName,
            TRUE);

        //
        // The names match, so copy the first part of the directory entry back
        // into the caller's buffers and return.
        //

        if (CompareResult == 0) {

            //
            // Verify that the file's extents are in the bounds of the CD-ROM
            // partition.
            //

            if ((DirectoryEntry->FirstSector < VolumeExtension->PartitionSectorCount) &&
                ((VolumeExtension->PartitionSectorCount - DirectoryEntry->FirstSector) >=
                    (GDF_CD_SECTOR_ALIGN_UP(DirectoryEntry->FileSize) >> GDF_CD_SECTOR_SHIFT))) {

                *ReturnedDirectoryEntry = *DirectoryEntry;
                status = STATUS_SUCCESS;
                goto CleanupAndExit;

            } else {
                status = STATUS_DISK_CORRUPT_ERROR;
                goto CleanupAndExit;
            }
        }

        //
        // Follow the left or right link from the directory entry.  The index is
        // shifted by two bits to obtain a four byte aligned byte offset.
        //

        if (CompareResult < 0) {
            NewDirectoryByteOffset = ((ULONG)DirectoryEntry->LeftEntryIndex << 2);
        } else {
            NewDirectoryByteOffset = ((ULONG)DirectoryEntry->RightEntryIndex << 2);
        }

        //
        // If the new directory byte offset is zero, then we're at the bottom of
        // the tree and should bail out.
        //

        if (NewDirectoryByteOffset == 0) {
            status = STATUS_OBJECT_NAME_NOT_FOUND;
            goto CleanupAndExit;
        }

        //
        // To prevent loops from occurring in the tree, don't allow the byte
        // offset to move back in the directory stream.
        //

        if (NewDirectoryByteOffset < (CacheBufferByteOffset + DirectoryByteOffset)) {
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // The disk is corrupt if the new directory byte offset is beyond the
        // end of the directory stream.  If the new directory byte offset is
        // close to the end of the directory stream, we may end up accessing
        // past the end of file, but the above checks ensure that we won't
        // access past the end of a sector.
        //
        // This check protects us from accessing past the end of the disk
        // because when we create the file control block, we validate that the
        // ending sector is not beyond the end of the disk.
        //

        if (NewDirectoryByteOffset >= DirectoryFcb->FileSize) {
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        DirectoryByteOffset = NewDirectoryByteOffset;
    }

CleanupAndExit:
    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

    return status;
}

NTSTATUS
GdfxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CREATE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK DesiredAccess;
    ULONG CreateOptions;
    PFILE_OBJECT FileObject;
    OBJECT_STRING RemainingName;
    PFILE_OBJECT RelatedFileObject;
    ULONG CreateDisposition;
    PGDF_FCB CurrentFcb;
    SHARE_ACCESS ShareAccess;
    BOOLEAN TrailingBackslash;
    BOOLEAN CreateFcbCalled;
    OBJECT_STRING ElementName;
    PGDF_FCB FoundOrNewFcb;
    GDF_DIRECTORY_ENTRY DirectoryEntry;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    DesiredAccess = IrpSp->Parameters.Create.DesiredAccess;
    CreateOptions = IrpSp->Parameters.Create.Options;
    FileObject = IrpSp->FileObject;
    RemainingName = *IrpSp->Parameters.Create.RemainingName;
    RelatedFileObject = FileObject->RelatedFileObject;

    //
    // Synchronize access to the file control block lists by acquiring the
    // global mutex.
    //

    GdfxAcquireGlobalMutexExclusive();

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Don't allow the target directory to be opened.  This is only used by the
    // I/O manager when it wants to rename a file across a directory on the same
    // volume.
    //

    if (GdfxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Check the desired access mask to make sure that no write rights are being
    // requested.
    //

    if (GdfxIsFlagSet(DesiredAccess, FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA |
        FILE_WRITE_EA | FILE_ADD_FILE | FILE_ADD_SUBDIRECTORY |
        FILE_APPEND_DATA | FILE_DELETE_CHILD | DELETE | WRITE_DAC)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Don't allow a file to be opened based on its file ID.
    //

    if (GdfxIsFlagSet(CreateOptions, FILE_OPEN_BY_FILE_ID)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // Verify that the create disposition is for open access only.
    //

    CreateDisposition = (CreateOptions >> 24) & 0xFF;

    if ((CreateDisposition != FILE_OPEN) && (CreateDisposition != FILE_OPEN_IF)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Determine whether we parse the file name from the root of the volume or
    // from a subdirectory by looking at RelatedFileObject.
    //

    if (RelatedFileObject != NULL) {

        //
        // Grab the file control block out of the related file object.
        //

        CurrentFcb = (PGDF_FCB)RelatedFileObject->FsContext;

        //
        // Verify that the related file object is really a directory object.
        // Note that the file control block could be NULL if the file object was
        // opened as a result of a direct device open in the I/O manager.
        //

        if ((CurrentFcb == NULL) ||
            GdfxIsFlagClear(CurrentFcb->Flags, GDF_FCB_DIRECTORY)) {
            status = STATUS_INVALID_PARAMETER;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the related directory.
        //

        if (RemainingName.Length == 0) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }

        //
        // Verify that this is not an absolute path.
        //

        if (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

    } else {

        //
        // Check if we're supposed to open the physical volume.
        //

        if (RemainingName.Length == 0) {

            CurrentFcb = VolumeExtension->VolumeFcb;

            //
            // The caller shouldn't be expecting to see a directory file.
            //

            if (GdfxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
                status = STATUS_NOT_A_DIRECTORY;
                goto CleanupAndExit;
            }

            //
            // Physical volume access is always non-cached.  Mark the file
            // object as non-cached so that the I/O manager enforces alignment
            // requirements.
            //

            FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;

            CurrentFcb->ReferenceCount++;
            goto InitializeFileObject;
        }

        //
        // Start searching relative to the root directory.
        //

        CurrentFcb = VolumeExtension->RootDirectoryFcb;

        //
        // Verify that this is an absolute path.
        //

        if (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the root directory.
        //

        if (RemainingName.Length == sizeof(OCHAR)) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }
    }

    //
    // Check if the file name ends in a backslash.  If so, strip it off and set
    // a flag so that we can later verify that the target file is a directory.
    //
    // We've already checked for an empty file name or a file name that consists
    // of a single backslash above, so we know that before and after this check
    // that the remaining name will still have some characters in it.
    //

    ASSERT(RemainingName.Length > 0);

    if (RemainingName.Buffer[(RemainingName.Length / sizeof(OCHAR)) - 1] ==
        OBJ_NAME_PATH_SEPARATOR) {
        RemainingName.Length -= sizeof(OCHAR);
        TrailingBackslash = TRUE;
    } else {
        TrailingBackslash = FALSE;
    }

    ASSERT(RemainingName.Length > 0);

    //
    // Process the file name.  At this point, we're only walking the open file
    // control block list.
    //

    for (;;) {

        //
        // Pull off the next element of the file name.
        //

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        //
        // Verify that there aren't multiple backslashes in the name.
        //

        if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
            OBJ_NAME_PATH_SEPARATOR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            break;
        }

        //
        // Check if a file control block already exists for this file name.
        //

        if (!GdfxFindOpenChildFcb(CurrentFcb, &ElementName, &FoundOrNewFcb)) {
            break;
        }

        CurrentFcb = FoundOrNewFcb;

        //
        // If we have consumed the entire name, then the file is already open.
        // Bump up the reference count and skip past the on-disk search loop.
        //

        if (RemainingName.Length == 0) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenCurrentFcb;
        }
    }

    //
    // Continue processing the file name.  At this point, we're searching
    // directory streams for the requested file.
    //

    CreateFcbCalled = FALSE;

    do {

        //
        // On the first iteration of the loop, we've already dissected the name
        // we're looking for so don't dissect another piece of the name.
        //

        if (CreateFcbCalled) {

            //
            // Pull off the next element of the file name.
            //

            ObDissectName(RemainingName, &ElementName, &RemainingName);

            //
            // Verify that there aren't multiple backslashes in the name.
            //

            if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
                OBJ_NAME_PATH_SEPARATOR)) {
                status = STATUS_OBJECT_NAME_INVALID;
                break;
            }
        }

        //
        // Lookup the element in the directory.
        //

        status = GdfxLookupElementNameInDirectory(VolumeExtension, Irp,
            CurrentFcb, &ElementName, &DirectoryEntry);

        if (!NT_SUCCESS(status)) {

            //
            // If we failed to find the element and there's more of a path name
            // to process, then convert the error from "file not found" to
            // "path not found".
            //

            if ((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
                (RemainingName.Length != 0)) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
            }

            break;
        }

        //
        // Create a file control block for the file we found.
        //

        status = GdfxCreateFcb(CurrentFcb, &ElementName, &DirectoryEntry,
            &FoundOrNewFcb);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // If this is the second or greater iteration of this loop, then we want
        // to release the reference to the parent directory from FatxCreateFcb.
        // The parent directory already has a reference count of one from when
        // we created that file control block.
        //

        if (CreateFcbCalled) {
            ASSERT(CurrentFcb->ReferenceCount >= 2);
            CurrentFcb->ReferenceCount--;
        }

        CreateFcbCalled = TRUE;
        CurrentFcb = FoundOrNewFcb;

        //
        // If there's still more of a path name to process, then the file that
        // we found had better be a directory.
        //

        if ((RemainingName.Length != 0) &&
            GdfxIsFlagClear(CurrentFcb->Flags, GDF_FCB_DIRECTORY)) {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
            break;
        }

    } while (RemainingName.Length != 0);

    //
    // If we failed to open the file, then before bailing out, we may need to
    // dereference the current file control block.  If we haven't created any
    // file control blocks, then there's no file control blocks to clean up.
    //

    if (!NT_SUCCESS(status)) {

        if (CreateFcbCalled) {
            GdfxDereferenceFcb(CurrentFcb);
        }

        goto CleanupAndExit;
    }

    //
    // If the caller is expecting to open only a file or directory file, then
    // verify that the file type matches.
    //

OpenCurrentFcb:
    if (GdfxIsFlagSet(CurrentFcb->Flags, GDF_FCB_DIRECTORY)) {

OpenStartDirectoryFcb:
        if (GdfxIsFlagSet(CreateOptions, FILE_NON_DIRECTORY_FILE)) {
            status = STATUS_FILE_IS_A_DIRECTORY;
        }

    } else {

        if (TrailingBackslash ||
            GdfxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
            status = STATUS_NOT_A_DIRECTORY;
        }
    }

    //
    // If the resulting file looks acceptable, then fill out the file object
    // and return success.
    //

    if (NT_SUCCESS(status)) {

InitializeFileObject:
        //
        // We don't care about sharing modes for this file system.
        //

        IoSetShareAccess(DesiredAccess, 0, FileObject, &ShareAccess);

        //
        // Fill in the file object with the file control block that we
        // created.
        //

        FileObject->FsContext = CurrentFcb;
        FileObject->FsContext2 = NULL;

        VolumeExtension->FileObjectCount++;

        //
        // Indicate to the caller that we opened the file as opposed to
        // creating or overwriting the file.
        //

        Irp->IoStatus.Information = FILE_OPENED;

        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    //
    // If we reach this point, then we're going to be failing the call so
    // cleanup any file control block we're still holding on to.
    //

    GdfxDereferenceFcb(CurrentFcb);

CleanupAndExit:
    GdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\dirctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    dirctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_DIRECTORY_CONTROL.

--*/

#include "gdfx.h"

NTSTATUS
GdfxFindNextDirectoryEntry(
    IN PGDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PGDF_FCB DirectoryFcb,
    IN PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext,
    OUT PGDF_DIRECTORY_ENTRY *ReturnedDirectoryEntry,
    OUT PULONG ReturnedDirectoryByteOffset
    )
/*++

Routine Description:

    This routine finds the next directory entry that matches the query template
    specification.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    DirectoryEnumContext - Specifies the directory enumeration context.

    ReturnedDirectoryEntry - Specifies the buffer to receive the pointer to the
        directory entry for the file if found.

    ReturnedDirectoryByteOffset - Specifies the buffer to receive the byte
        offset of the entry in the directory stream.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG DirectoryByteOffset;
    POBJECT_STRING TemplateFileName;
    PVOID CacheBuffer;
    ULONG CacheBufferByteOffset;
    PGDF_DIRECTORY_ENTRY DirectoryEntry;
    OBJECT_STRING DirectoryEntryFileName;

    ASSERT(GdfxIsFlagSet(DirectoryFcb->Flags, GDF_FCB_DIRECTORY));

    DirectoryByteOffset = DirectoryEnumContext->QueryOffset;
    TemplateFileName = &DirectoryEnumContext->TemplateFileName;

    //
    // If this is an empty directory, then return now that the name isn't found.
    //

    if (DirectoryFcb->FileSize == 0) {
        return STATUS_END_OF_FILE;
    }

    //
    // Process the directory stream.
    //

    CacheBuffer = NULL;
    CacheBufferByteOffset = 0;

    while (DirectoryByteOffset < DirectoryFcb->FileSize) {

        //
        // If we haven't mapped in a cache buffer yet or if we're switching
        // sectors, then we need to switch cache buffers.
        //

        if ((CacheBuffer == NULL) ||
            (CacheBufferByteOffset != (DirectoryByteOffset & ~GDF_CD_SECTOR_MASK))) {

            if (CacheBuffer != NULL) {
                FscUnmapBuffer(CacheBuffer);
                CacheBuffer = NULL;
            }

            CacheBufferByteOffset = (DirectoryByteOffset & ~GDF_CD_SECTOR_MASK);

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                GdfxSectorToPhysicalByteOffset(DirectoryFcb->FirstSector) +
                CacheBufferByteOffset, FALSE, &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }
        }

        //
        // Make the directory byte offset relative to the current cache buffer.
        //

        DirectoryByteOffset &= GDF_CD_SECTOR_MASK;

        //
        // Compute the cache buffer relative pointer to the directory entry.
        //

        DirectoryEntry = (PGDF_DIRECTORY_ENTRY)((PUCHAR)CacheBuffer +
            DirectoryByteOffset);

        //
        // If the left and right entry indexes are negative one, then this is
        // sector padding, so we should advance to the next directory sector and
        // continue.
        //

        if ((DirectoryEntry->LeftEntryIndex == (USHORT)-1) &&
            (DirectoryEntry->RightEntryIndex == (USHORT)-1)) {
            DirectoryByteOffset = CacheBufferByteOffset + GDF_CD_SECTOR_SIZE;
            continue;
        }

        //
        // If there's not enough space in the current sector to hold the header
        // of a directory entry, then the directory entry is invalid and the
        // disk is corrupt.
        //
        // We check for these types of disk corruption in order to guard against
        // taking a potential page fault if we extend past the current sector.
        //

        if (DirectoryByteOffset > (GDF_CD_SECTOR_SIZE -
            FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName))) {
            GdfxDbgPrint(("GDFX: found invalid directory byte offset\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // If there's not enough space in the current sector to hold the header
        // and the file name, then the directory entry is invalid and the disk
        // is corrupt.
        //

        if ((DirectoryByteOffset + DirectoryEntry->FileNameLength) >
            (GDF_CD_SECTOR_SIZE - FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName))) {
            GdfxDbgPrint(("GDFX: found invalid directory byte offset\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // Check if the file name matches the name we're looking for.
        //

        DirectoryEntryFileName.Length = DirectoryEntry->FileNameLength;
        DirectoryEntryFileName.Buffer = DirectoryEntry->FileName;

        if (((TemplateFileName->Buffer == NULL) ||
            IoIsNameInExpression(TemplateFileName, &DirectoryEntryFileName))) {

            //
            // The file name matches the template file name.  Leave the cache
            // buffer mapped and return a pointer to the directory entry and its
            // directory byte offset to the caller.  The caller is responsible
            // for unmapping the cache buffer.
            //

            *ReturnedDirectoryEntry = DirectoryEntry;
            *ReturnedDirectoryByteOffset = CacheBufferByteOffset +
                DirectoryByteOffset;

            return STATUS_SUCCESS;
        }

        //
        // Advance to the next directory byte offset.
        //

        DirectoryByteOffset = CacheBufferByteOffset + DirectoryByteOffset +
            ALIGN_UP(FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName) +
            DirectoryEntry->FileNameLength, sizeof(ULONG));
    }

    //
    // We reached the end of the file without finding the template file name.
    //

    status = STATUS_END_OF_FILE;

CleanupAndExit:
    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

    return status;
}

NTSTATUS
GdfxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DIRECTORY_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PGDF_FCB DirectoryFcb;
    ULONG FileInformationClass;
    SIZE_T FileInformationBaseLength;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    POBJECT_STRING TemplateFileName;
    BOOLEAN InitialQuery;
    PGDF_DIRECTORY_ENTRY DirectoryEntry;
    ULONG DirectoryByteOffset;
    PFILE_DIRECTORY_INFORMATION DirectoryInformation;
    LARGE_INTEGER TimeStamp;
    ULONG FileSize;
    ULONG FileNameBytesToCopy;
    ULONG OutputBytesRemaining;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    DirectoryFcb = (PGDF_FCB)FileObject->FsContext;

    //
    // Synchronize the creation and access of the directory context control
    // block by acquiring the global mutex.
    //

    GdfxAcquireGlobalMutexExclusive();

    //
    // Ensure that the file object is for a directory.
    //

    if (GdfxIsFlagClear(DirectoryFcb->Flags, GDF_FCB_DIRECTORY)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Verify that this is a supported information class.
    //

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;

    switch (FileInformationClass) {

        case FileDirectoryInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_DIRECTORY_INFORMATION,
                FileName[0]);
            break;

        case FileNamesInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_NAMES_INFORMATION,
                FileName[0]);
            break;

        default:
            status = STATUS_INVALID_INFO_CLASS;
            goto CleanupAndExit;
    }

    //
    // The query cannot be started relative to a starting index.
    //

    if (GdfxIsFlagSet(IrpSp->Flags, SL_INDEX_SPECIFIED)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // If this is the first query for this directory, then prepare the template
    // file name.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext == NULL) {

        TemplateFileName = IrpSp->Parameters.QueryDirectory.FileName;

        status = IoCreateDirectoryEnumContext(TemplateFileName,
            &DirectoryEnumContext);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Connect the directory enumeration context to the file object.
        //

        FileObject->FsContext2 = DirectoryEnumContext;

        InitialQuery = TRUE;

    } else {

        InitialQuery = FALSE;
    }

    //
    // If we're to restart the directory scan, then reset the current index to
    // zero.
    //

    if (GdfxIsFlagSet(IrpSp->Flags, SL_RESTART_SCAN)) {
        DirectoryEnumContext->QueryOffset = 0;
    }

    //
    // Find the next file identifier descriptor that matches our query criteria.
    //
    // On return, DirectoryEnumContext->QueryOffset still points at the original
    // identifier.  It's only updated after we're about to successfully return
    // so that no entries are lost in the event of an invalid parameter or pool
    // allocation failure.
    //

    status = GdfxFindNextDirectoryEntry(VolumeExtension, Irp, DirectoryFcb,
        DirectoryEnumContext, &DirectoryEntry, &DirectoryByteOffset);

    if (NT_SUCCESS(status)) {

        //
        // The I/O manager has already checked that the user's buffer has enough
        // space to contain at least the header.
        //

        ASSERT(IrpSp->Parameters.QueryDirectory.Length >= FileInformationBaseLength);

        //
        // Zero out the header.
        //

        DirectoryInformation = (PFILE_DIRECTORY_INFORMATION)Irp->UserBuffer;
        RtlZeroMemory(DirectoryInformation, FileInformationBaseLength);

        //
        // For FileDirectoryInformation and FileNamesInformation, the
        // FileNameLength field is immediately before the FileName buffer.
        //

        *((PULONG)((PUCHAR)DirectoryInformation + FileInformationBaseLength -
            sizeof(ULONG))) = DirectoryEntry->FileNameLength;

        //
        // If this is a FileDirectoryInformation request, then fill in more
        // information.  We have to go to dig into the file entry descriptor
        // to get the information we need, so we'll construct a file control
        // block to get the attributes.
        //

        if (FileInformationClass == FileDirectoryInformation) {

            TimeStamp = VolumeExtension->TimeStamp;

            DirectoryInformation->CreationTime = TimeStamp;
            DirectoryInformation->LastAccessTime = TimeStamp;
            DirectoryInformation->LastWriteTime = TimeStamp;
            DirectoryInformation->ChangeTime = TimeStamp;

            if (GdfxIsFlagSet(DirectoryEntry->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

                DirectoryInformation->FileAttributes = FILE_ATTRIBUTE_READONLY |
                    FILE_ATTRIBUTE_DIRECTORY;

                DirectoryInformation->EndOfFile.QuadPart = 0;
                DirectoryInformation->AllocationSize.QuadPart = 0;

            } else {

                DirectoryInformation->FileAttributes = FILE_ATTRIBUTE_READONLY;

                FileSize = DirectoryEntry->FileSize;

                DirectoryInformation->EndOfFile.QuadPart = (ULONGLONG)FileSize;
                DirectoryInformation->AllocationSize.QuadPart = (ULONGLONG)FileSize;
            }
        }

        //
        // If nothing has gone wrong yet, then copy the file name to the user's
        // buffer.
        //

        if (NT_SUCCESS(status)) {

            OutputBytesRemaining =
                ALIGN_DOWN(IrpSp->Parameters.QueryDirectory.Length -
                FileInformationBaseLength, sizeof(OCHAR));
            FileNameBytesToCopy = DirectoryEntry->FileNameLength;

            if (FileNameBytesToCopy > OutputBytesRemaining) {
                FileNameBytesToCopy = OutputBytesRemaining;
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                status = STATUS_SUCCESS;
            }

            RtlCopyMemory((PUCHAR)DirectoryInformation + FileInformationBaseLength,
                DirectoryEntry->FileName, FileNameBytesToCopy);

            //
            // Fill in the number of bytes that we wrote to the user's buffer.
            //

            Irp->IoStatus.Information = FileInformationBaseLength +
                FileNameBytesToCopy;

            //
            // Check that we didn't overflow the user's buffer.  The I/O manager
            // does the initial check to make sure there's enough space for the
            // static structure for a given information class, but we might
            // overflow the buffer when copying in the variable length file
            // name.
            //

            ASSERT(Irp->IoStatus.Information <=
                IrpSp->Parameters.QueryDirectory.Length);

            //
            // Update the query offset.
            //

            DirectoryEnumContext->QueryOffset = DirectoryByteOffset +
                ALIGN_UP(FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName) +
                DirectoryEntry->FileNameLength, sizeof(ULONG));
        }

        //
        // Unmap the buffer holding the directory entry.
        //

        FscUnmapBuffer(DirectoryEntry);

    } else if (status == STATUS_END_OF_FILE) {

        //
        // If we hit the end of the directory stream, then return an appropriate
        // status code depending on whether this was the first pass through this
        // routine for this handle or not.
        //

        status = InitialQuery ? STATUS_NO_SUCH_FILE : STATUS_NO_MORE_FILES;
    }

CleanupAndExit:
    GdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\close.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLOSE.

--*/

#include "gdfx.h"

NTSTATUS
GdfxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLOSE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    PGDF_FCB Fcb;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // Synchronize access to the file control block lists by acquiring the
    // global mutex.
    //

    GdfxAcquireGlobalMutexExclusive();

    //
    // Delete the directory enumeration context if one exists.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext != NULL) {
        FileObject->FsContext2 = NULL;
        ExFreePool(DirectoryEnumContext);
    }

    //
    // Dereference the file control block associated with the file object.
    //

    Fcb = (PGDF_FCB)FileObject->FsContext;
    FileObject->FsContext = NULL;
    GdfxDereferenceFcb(Fcb);

    //
    // Decrement the file object count for the volume and check if we're ready
    // to delete this device object.
    //

    VolumeExtension->FileObjectCount--;

    if ((VolumeExtension->FileObjectCount == 0) && VolumeExtension->Dismounted) {
        GdfxDeleteVolumeDevice(DeviceObject);
    }

    GdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\driver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module implements routines that apply to the driver object including
    initialization and IRP dispatch routines.

--*/

#include "gdfx.h"

//
// Driver object for the GDF file system.
//
DECLSPEC_RDATA DRIVER_OBJECT GdfxDriverObject = {
    NULL,                               // DriverStartIo
    NULL,                               // DriverDeleteDevice
    GdfxDismountVolume,                 // DriverDismountVolume
    {
        GdfxFsdCreate,                  // IRP_MJ_CREATE
        GdfxFsdClose,                   // IRP_MJ_CLOSE
        GdfxFsdRead,                    // IRP_MJ_READ
        IoInvalidDeviceRequest,         // IRP_MJ_WRITE
        GdfxFsdQueryInformation,        // IRP_MJ_QUERY_INFORMATION
        GdfxFsdSetInformation,          // IRP_MJ_SET_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_FLUSH_BUFFERS
        GdfxFsdQueryVolumeInformation,  // IRP_MJ_QUERY_VOLUME_INFORMATION
        GdfxFsdDirectoryControl,        // IRP_MJ_DIRECTORY_CONTROL
        GdfxFsdFileSystemControl,       // IRP_MJ_FILE_SYSTEM_CONTROL
        GdfxFsdDeviceControl,           // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};

//
// All file system access is guarded by this single global lock.
//
INITIALIZED_CRITICAL_SECTION(GdfxGlobalMutex);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\fatx\volinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_VOLUME_INFORMATION.

--*/

#include "fatx.h"

NTSTATUS
FatxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_QUERY_VOLUME_INFORMATION requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ULONG BytesWritten;
    PFILE_FS_VOLUME_INFORMATION VolumeInformation;
    PFILE_FS_SIZE_INFORMATION SizeInformation;
    PFILE_FS_DEVICE_INFORMATION DeviceInformation;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInformation;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    FatxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryVolume.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsVolumeInformation:
            VolumeInformation = (PFILE_FS_VOLUME_INFORMATION)Irp->UserBuffer;
            VolumeInformation->VolumeSerialNumber = VolumeExtension->SerialNumber;
            BytesWritten = FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel);
            break;

        case FileFsSizeInformation:
            SizeInformation = (PFILE_FS_SIZE_INFORMATION)Irp->UserBuffer;
            SizeInformation->TotalAllocationUnits.QuadPart =
                VolumeExtension->NumberOfClusters;
            SizeInformation->AvailableAllocationUnits.QuadPart =
                VolumeExtension->NumberOfClustersAvailable;
            SizeInformation->SectorsPerAllocationUnit =
                VolumeExtension->BytesPerCluster >> VolumeExtension->SectorShift;
            SizeInformation->BytesPerSector = VolumeExtension->SectorSize;
            BytesWritten = sizeof(FILE_FS_SIZE_INFORMATION);
            break;

        case FileFsDeviceInformation:
            DeviceInformation = (PFILE_FS_DEVICE_INFORMATION)Irp->UserBuffer;
            DeviceInformation->DeviceType =
                VolumeExtension->TargetDeviceObject->DeviceType;
            DeviceInformation->Characteristics = 0;
            BytesWritten = sizeof(FILE_FS_DEVICE_INFORMATION);
            break;

        case FileFsAttributeInformation:
            AttributeInformation =
                (PFILE_FS_ATTRIBUTE_INFORMATION)Irp->UserBuffer;
            AttributeInformation->FileSystemAttributes = 0;
            AttributeInformation->MaximumComponentNameLength =
                FAT_FILE_NAME_LENGTH;
            AttributeInformation->FileSystemNameLength = sizeof(OCHAR) * 4;

            if (IrpSp->Parameters.QueryVolume.Length <
                FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                sizeof(OCHAR) * 4) {
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName);
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                RtlCopyMemory(AttributeInformation->FileSystemName, OTEXT("FATX"),
                    sizeof(OCHAR) * 4);
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName) + sizeof(OCHAR) * 4;
            }
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryVolume.Length);

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\devctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module implements routines related to handling IRP_MJ_DEVICE_CONTROL.

--*/

#include "gdfx.h"

NTSTATUS
GdfxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DEVICE_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Pass the IRP down to the target device.  We don't need to touch any of
    // the arguments.
    //

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\fcbsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fcbsup.c

Abstract:

    This module implements routines which provide support for file control
    blocks.

--*/

#include "gdfx.h"

NTSTATUS
GdfxCreateFcb(
    IN PGDF_FCB ParentFcb OPTIONAL,
    IN POBJECT_STRING FileName,
    IN PGDF_DIRECTORY_ENTRY DirectoryEntry,
    OUT PGDF_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine reads the file entry descriptor at the supplied extent and
    constructs a file control block that represents the file.

Arguments:

    ParentFcb - Specifies the parent directory that contains the supplied file.

    FileName - Specifies the name of the file.

    DirectoryEntry - Specifies the directory entry to obtain more attributes
        about the file.  The directory entry does not include the full file
        name.

    ReturnedFcb - Specifies the buffer to receive the created file control
        block.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SIZE_T FcbSize;
    ULONG FcbPoolTag;
    PGDF_FCB Fcb;

    //
    // Compute the size of the file control block.
    //

    if (GdfxIsFlagSet(DirectoryEntry->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        FcbPoolTag = 'cDxG';
    } else {
        FcbPoolTag = 'cFxG';
    }

    FcbSize = sizeof(GDF_FCB) + FileName->Length;

    //
    // Allocate the file control block.
    //

    Fcb = ExAllocatePoolWithTag(FcbSize, FcbPoolTag);

    if (Fcb != NULL) {

        //
        // Initialize the file control block.
        //

        RtlZeroMemory(Fcb, FcbSize);

        //
        // A file control block starts with the single reference for the caller.
        //

        Fcb->ReferenceCount = 1;

        //
        // Copy the file name to the file control block.
        //

        RtlCopyMemory(Fcb->FileName, FileName->Buffer, FileName->Length);
        Fcb->FileNameLength = (UCHAR)FileName->Length;

        //
        // Copy the file's starting sector and size to the file control block.
        //

        Fcb->FirstSector = DirectoryEntry->FirstSector;
        Fcb->FileSize = DirectoryEntry->FileSize;

        //
        // Increment the reference count for the parent file control block and
        // attach it to this file control block.
        //

        ParentFcb->ReferenceCount++;
        Fcb->ParentFcb = ParentFcb;
        InsertHeadList(&ParentFcb->ChildFcbList, &Fcb->SiblingFcbLink);

        //
        // For directories, mark the file control block as a directory and
        // initialize the child file control block list.
        //

        if (GdfxIsFlagSet(DirectoryEntry->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            Fcb->Flags |= GDF_FCB_DIRECTORY;
            InitializeListHead(&Fcb->ChildFcbList);
        }

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    *ReturnedFcb = Fcb;

    return status;
}

BOOLEAN
GdfxFindOpenChildFcb(
    IN PGDF_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PGDF_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine searches the child file control block for the supplied
    directory for a file that has the supplied file name.

Arguments:

    DirectoryFcb - Specifies the file control block of the directory to search.

    FileName - Specifies the name to search for in the directory.

    ReturnedFcb - Specifies the buffer to receive the found file control block.

Return Value:

    Returns TRUE if the file control block was found, else FALSE.

--*/
{
    PLIST_ENTRY NextFcbLink;
    PGDF_FCB Fcb;
    OBJECT_STRING FcbFileName;

    //
    // Walk through the file control blocks actively in use by the volume and
    // find a match.
    //

    NextFcbLink = DirectoryFcb->ChildFcbList.Flink;

    while (NextFcbLink != &DirectoryFcb->ChildFcbList) {

        Fcb = CONTAINING_RECORD(NextFcbLink, GDF_FCB, SiblingFcbLink);

        FcbFileName.Length = Fcb->FileNameLength;
        FcbFileName.Buffer = Fcb->FileName;

        if ((FcbFileName.Length == FileName->Length) &&
            RtlEqualObjectString(&FcbFileName, FileName, TRUE)) {
            *ReturnedFcb = Fcb;
            return TRUE;
        }

        NextFcbLink = Fcb->SiblingFcbLink.Flink;
    }

    *ReturnedFcb = NULL;
    return FALSE;
}

VOID
GdfxDereferenceFcb(
    IN PGDF_FCB Fcb
    )
/*++

Routine Description:

    This routine decrements the reference count on the supplied file control
    block.  If the reference count reaches zero, then the file control block is
    deleted.

Arguments:

    Fcb - Specifies the file control block to dereference.

Return Value:

    None.

--*/
{
    PGDF_FCB ParentFcb;

    ASSERT(Fcb->ReferenceCount > 0);

    do {

        //
        // Decrement the reference count and bail out if there are still
        // outstanding references to the file control block.
        //

        if (--Fcb->ReferenceCount != 0) {
            return;
        }

        //
        // Verify that the child file control block list is empty if this is a
        // directory.
        //

        if (GdfxIsFlagSet(Fcb->Flags, GDF_FCB_DIRECTORY)) {
            ASSERT(IsListEmpty(&Fcb->ChildFcbList));
        }

        //
        // Save off the parent file control block so that we can dereference it
        // in a bit.
        //

        ParentFcb = Fcb->ParentFcb;

        //
        // Remove this file control block from the list of siblings.
        //

        if (ParentFcb != NULL) {
            RemoveEntryList(&Fcb->SiblingFcbLink);
        }

        //
        // Free the file control block.
        //

        ExFreePool(Fcb);

        //
        // Switch to the parent file control block and restart the loop to
        // dereference this object.
        //

        Fcb = ParentFcb;

    } while (Fcb != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\fsctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_FILE_SYSTEM_CONTROL.

--*/

#include "gdfx.h"

NTSTATUS
GdfxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    FSCTL_DISMOUNT_VOLUME requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    KIRQL OldIrql;

    GdfxAcquireGlobalMutexExclusive();

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Check if the volume is already marked for dismount.  If not, mark it for
    // dismount.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    VolumeExtension->Dismounted = TRUE;

    //
    // Synchronize access to the MountedOrSelfDevice with the I/O manager by
    // raising to DISPATCH_LEVEL.
    //
    // Clear out the target device object's MountedOrSelfDevice field.  That
    // will cause future accesses to the target device object to mount a new
    // file system device object.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    VolumeExtension->TargetDeviceObject->MountedOrSelfDevice = NULL;

    KeLowerIrql(OldIrql);

    //
    // Delete the volume device if the file object count is zero.
    //

    if (VolumeExtension->FileObjectCount == 0) {
        GdfxDeleteVolumeDevice(DeviceObject);
    } else if (VolumeExtension->FileObjectCount > 1) {
        GdfxDbgPrint(("GDFX: dismounting volume %p with %d open file handles\n",
            VolumeExtension, VolumeExtension->FileObjectCount));
    }

    status = STATUS_SUCCESS;

CleanupAndExit:
    GdfxReleaseGlobalMutex();

    return status;
}

NTSTATUS
GdfxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_FILE_SYSTEM_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_DISMOUNT_VOLUME:
            //
            // Note that we call indirect through our driver object so that the
            // generated code ends up being identical between GDFX/RAWX/UDFX.
            //

            status = DeviceObject->DriverObject->DriverDismountVolume(DeviceObject);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\fileinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION.

--*/

#include "gdfx.h"

VOID
GdfxQueryNetworkOpenInformation(
    IN PGDF_VOLUME_EXTENSION VolumeExtension,
    IN PFILE_OBJECT FileObject,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkOpenInformation
    )
/*++

Routine Description:

    This routine fills the information structure with attributes about the
    supplied file object.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    FileObject - Specifies the file object to obtain the information from.

    NetworkOpenInformation - Specifies the buffer to receive the file
        information.

Return Value:

    None.

--*/
{
    PGDF_FCB Fcb;
    LARGE_INTEGER TimeStamp;

    Fcb = (PGDF_FCB)FileObject->FsContext;

    TimeStamp = VolumeExtension->TimeStamp;

    NetworkOpenInformation->CreationTime = TimeStamp;
    NetworkOpenInformation->LastAccessTime = TimeStamp;
    NetworkOpenInformation->LastWriteTime = TimeStamp;
    NetworkOpenInformation->ChangeTime = TimeStamp;

    if (GdfxIsFlagSet(Fcb->Flags, GDF_FCB_DIRECTORY)) {

        NetworkOpenInformation->FileAttributes = FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_DIRECTORY;
        NetworkOpenInformation->AllocationSize.QuadPart = 0;
        NetworkOpenInformation->EndOfFile.QuadPart = 0;

    } else {

        NetworkOpenInformation->FileAttributes = FILE_ATTRIBUTE_READONLY;
        NetworkOpenInformation->AllocationSize.QuadPart = (ULONGLONG)Fcb->FileSize;
        NetworkOpenInformation->EndOfFile.QuadPart = (ULONGLONG)Fcb->FileSize;
    }
}

NTSTATUS
GdfxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_QUERY_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PGDF_FCB Fcb;
    ULONG BytesWritten;
    PFILE_INTERNAL_INFORMATION InternalInformation;
    PFILE_POSITION_INFORMATION PositionInformation;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PGDF_FCB)FileObject->FsContext;

    //
    // For volume file control blocks, the only thing that can be queried is the
    // current file position.
    //

    if (GdfxIsFlagSet(Fcb->Flags, GDF_FCB_VOLUME) &&
        (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryFile.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {

        case FileInternalInformation:
            InternalInformation = (PFILE_INTERNAL_INFORMATION)Irp->UserBuffer;
            InternalInformation->IndexNumber.HighPart = PtrToUlong(VolumeExtension);
            InternalInformation->IndexNumber.LowPart = PtrToUlong(Fcb);
            BytesWritten = sizeof(FILE_INTERNAL_INFORMATION);
            break;

        case FilePositionInformation:
            PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;
            PositionInformation->CurrentByteOffset = FileObject->CurrentByteOffset;
            BytesWritten = sizeof(FILE_POSITION_INFORMATION);
            break;

        case FileNetworkOpenInformation:
            GdfxQueryNetworkOpenInformation(VolumeExtension, FileObject,
                (PFILE_NETWORK_OPEN_INFORMATION)Irp->UserBuffer);
            BytesWritten = sizeof(FILE_NETWORK_OPEN_INFORMATION);
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryFile.Length);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
GdfxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_SET_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFILE_POSITION_INFORMATION PositionInformation;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // The only thing that can be set is the current file position.
    //

    if (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;

    //
    // If the file was opened without intermediate buffering, then the byte
    // offset must be sector aligned.
    //
    // Note that we don't use GDF_SECTOR_CD_MASK here so that the generated code
    // ends up being identical to RawxFsdSetInformation.  The linker will take
    // care of collapsing the two functions.
    //

    if (GdfxIsFlagSet(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING) &&
        (PositionInformation->CurrentByteOffset.LowPart &
        (DeviceObject->SectorSize - 1)) != 0) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Update the current file position.
    //

    FileObject->CurrentByteOffset = PositionInformation->CurrentByteOffset;
    status = STATUS_SUCCESS;

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\gdfx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    gdfx.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the GDF file system driver.

--*/

#ifndef _GDFX_
#define _GDFX_

#include <ntos.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>
#include "gdformat.h"

#include <pshpack4.h>

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define GdfxDbgPrint(x)                         DbgPrint x
#else
#define GdfxDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define GdfxIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define GdfxIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Returns the number of elements in the supplied array.
//

#define ARRAY_ELEMENTS(array)                                                 \
    (sizeof((array)) / sizeof((array)[0]))

//
// Define the static drive geometry for a CD-ROM device supported by this file
// system.
//

#define GDF_CD_SECTOR_SHIFT                     11
#define GDF_CD_SECTOR_SIZE                      (1 << GDF_CD_SECTOR_SHIFT)
#define GDF_CD_SECTOR_MASK                      (GDF_CD_SECTOR_SIZE - 1)

//
// Define a macro to align the supplied number of bytes down or up to the next
// sector boundary.
//

#define GDF_CD_SECTOR_ALIGN_DOWN(cb) \
    (((SIZE_T)(cb) & (~GDF_CD_SECTOR_MASK))
#define GDF_CD_SECTOR_ALIGN_UP(cb) \
    (((SIZE_T)(cb) + GDF_CD_SECTOR_SIZE - 1) & (~GDF_CD_SECTOR_MASK))

//
// Define a macro to check if a length is sector aligned.
//

#define GdfxIsSectorAligned(value) \
    ((LOGICAL)(((ULONG)(value) & GDF_CD_SECTOR_MASK) == 0))

//
// Define a macro to map a sector number to the physical byte offset.
//

#define GdfxSectorToPhysicalByteOffset(sector) \
    ((ULONGLONG)(sector) << GDF_CD_SECTOR_SHIFT)

//
// Define file control block flags.
//

#define GDF_FCB_VOLUME                          0x01
#define GDF_FCB_DIRECTORY                       0x02
#define GDF_FCB_ROOT_DIRECTORY                  0x04

//
// File control block.
//

typedef struct _GDF_FCB {
    ULONG FirstSector;
    ULONG FileSize;
    ULONG ReferenceCount;
    struct _GDF_FCB *ParentFcb;
    LIST_ENTRY SiblingFcbLink;
    LIST_ENTRY ChildFcbList;
    UCHAR Flags;
    UCHAR FileNameLength;
    OCHAR FileName[0];
} GDF_FCB, *PGDF_FCB;

//
// Volume device extension data.
//

typedef struct _GDF_VOLUME_EXTENSION {
    union {
        FSCACHE_EXTENSION CacheExtension;
        FSCACHE_EXTENSION;
    };
    PGDF_FCB VolumeFcb;
    PGDF_FCB RootDirectoryFcb;
    ULONG PartitionSectorCount;
    LARGE_INTEGER TimeStamp;
    ULONG FileObjectCount;
    BOOLEAN Dismounted;
} GDF_VOLUME_EXTENSION, *PGDF_VOLUME_EXTENSION;

//
// File system dismount routine.
//

NTSTATUS
GdfxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// IRP dispatch routines.
//

NTSTATUS
GdfxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Cache support routines.
//

NTSTATUS
GdfxMapLogicalSector(
    IN PGDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG LogicalSectorNumber,
    OUT PVOID *CacheBuffer
    );

//
// File control block support routines.
//

NTSTATUS
GdfxCreateFcb(
    IN PGDF_FCB ParentFcb OPTIONAL,
    IN POBJECT_STRING FileName,
    IN PGDF_DIRECTORY_ENTRY DirectoryEntry,
    OUT PGDF_FCB *ReturnedFcb
    );

BOOLEAN
GdfxFindOpenChildFcb(
    IN PGDF_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PGDF_FCB *ReturnedFcb
    );

VOID
GdfxDereferenceFcb(
    IN PGDF_FCB Fcb
    );

//
// Synchronization routines.
//

#define GdfxAcquireGlobalMutexExclusive() \
    RtlEnterCriticalSectionAndRegion(&GdfxGlobalMutex)

#define GdfxReleaseGlobalMutex() \
    RtlLeaveCriticalSectionAndRegion(&GdfxGlobalMutex)

//
// Miscellaneous routines.
//

VOID
GdfxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    );

//
// External symbols.
//

extern DRIVER_OBJECT GdfxDriverObject;
extern RTL_CRITICAL_SECTION GdfxGlobalMutex;

#include <poppack.h>

#endif  // GDFX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\read.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements routines related to handling IRP_MJ_READ.

--*/

#include "gdfx.h"

NTSTATUS
GdfxNonCachedReadCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to process the completion of a non-cached file read.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    ULONG ReadLength;

    //
    // This completion routine is set to be called only on IRP success.
    //

    ASSERT(NT_SUCCESS(Irp->IoStatus.Status));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    ReadLength = IrpSp->Parameters.Read.Length;

    //
    // Assert that the device handled as many bytes as we programmed it to.
    //

    ASSERT(Irp->IoStatus.Information == GDF_CD_SECTOR_ALIGN_UP(ReadLength));

    //
    // Propagate the pending flag up the IRP stack.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Fix the number of bytes read to the number that we computed inside
    // GdfxFsdRead.  This number may be less than the actual number of bytes
    // read from the device if we're at the end of file.
    //

    Irp->IoStatus.Information = ReadLength;

    //
    // If the file is open for synchronous I/O, then we need to update the
    // current file position.
    //

    if (GdfxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
        FileObject->CurrentByteOffset.QuadPart =
            IrpSp->Parameters.Read.ByteOffset.QuadPart + ReadLength;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
GdfxFsdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_READ requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    PFILE_OBJECT FileObject;
    PGDF_FCB Fcb;
    ULONG ReadLength;
    BOOLEAN NonCachedEndOfFileTransfer;
    ULONGLONG PartitionBytesRemaining;
    ULONG FileBytesRemaining;
    ULONGLONG PhysicalByteOffset;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PGDF_FCB)FileObject->FsContext;
    ReadLength = IrpSp->Parameters.Read.Length;
    NonCachedEndOfFileTransfer = FALSE;

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Ensure that the file object is not for a directory.
    //

    if (GdfxIsFlagSet(Fcb->Flags, GDF_FCB_DIRECTORY)) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto CleanupAndExit;
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (ReadLength == 0) {
        Irp->IoStatus.Information = 0;
        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    if (GdfxIsFlagSet(Fcb->Flags, GDF_FCB_VOLUME)) {

        //
        // Check if the starting offset is beyond the end of the volume.
        //

        if ((ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart >=
            (ULONGLONG)VolumeExtension->PartitionLength.QuadPart) {
            status = STATUS_END_OF_FILE;
            goto CleanupAndExit;
        }

        //
        // If the number of bytes to read is greater than the number of bytes
        // remaining in the file, then truncate the number of bytes we'll actually
        // read.
        //

        PartitionBytesRemaining =
            (ULONGLONG)VolumeExtension->PartitionLength.QuadPart -
            (ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart;

        if ((ULONGLONG)ReadLength >= PartitionBytesRemaining) {
            ReadLength = (ULONG)PartitionBytesRemaining;
        }

    } else {

        //
        // Check if the starting offset is beyond the end of file.
        //

        if ((IrpSp->Parameters.Read.ByteOffset.HighPart != 0) ||
            (IrpSp->Parameters.Read.ByteOffset.LowPart >= Fcb->FileSize)) {
            status = STATUS_END_OF_FILE;
            goto CleanupAndExit;
        }

        //
        // If the number of bytes to read is greater than the number of bytes
        // remaining in the file, then truncate the number of bytes we'll actually
        // read.
        //

        FileBytesRemaining = Fcb->FileSize -
            IrpSp->Parameters.Read.ByteOffset.LowPart;

        if (ReadLength >= FileBytesRemaining) {

            //
            // If the user's buffer is large enough to hold the logical read
            // length rounded up to a sector boundary, then set a flag so that
            // the below code will potentially read this part of the file as
            // non cached.
            //

            if (ReadLength >= (GDF_CD_SECTOR_ALIGN_UP(Fcb->FileSize) -
                IrpSp->Parameters.Read.ByteOffset.LowPart)) {
                NonCachedEndOfFileTransfer = TRUE;
            }

            ReadLength = FileBytesRemaining;
        }
    }

    ASSERT(ReadLength > 0);

    //
    // Check if we're supposed to bypass the file system cache.
    //
    // If this is a physical volume file control block, also bypass the cache.
    // This was the behavior of the old file systems and it also let's us avoid
    // having to deal with the volume case in the cached path.
    //

    if (GdfxIsFlagSet(Irp->Flags, IRP_NOCACHE) ||
        GdfxIsFlagSet(Fcb->Flags, GDF_FCB_VOLUME)) {

        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // Lock the user's buffer into memory if necessary.
        //

        IoLockUserBuffer(Irp, IrpSp->Parameters.Read.Length);

        //
        // The file is contiguous on disk, so we can pass this IRP down to the
        // target device after adjusting the starting byte offset assuming this
        // isn't a volume file control block.
        //

        if (GdfxIsFlagClear(Fcb->Flags, GDF_FCB_VOLUME)) {
            NextIrpSp->Parameters.Read.ByteOffset.QuadPart +=
                GdfxSectorToPhysicalByteOffset(Fcb->FirstSector);
        }

        //
        // Limit the number of bytes physically read to the end of the file or
        // volume.
        //

        NextIrpSp->Parameters.Read.Length = GDF_CD_SECTOR_ALIGN_UP(ReadLength);

        //
        // If the actual number of bytes we're to read is less than the number
        // of bytes we'll read from the physical device, then set a completion
        // routine to fix IO_STATUS_BLOCK.Information to be the actual number
        // of bytes.  We'll store the actual number of bytes back in the IRP so
        // that we don't have to calculate it again.
        //
        // If this is a synchronous I/O operation, then set a completion routine
        // so that we can update the current file position.
        //
        // We don't have to do either of the above if the IRP completes with an
        // error.
        //

        if ((IrpSp->Parameters.Read.Length != ReadLength) ||
            GdfxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {

            IrpSp->Parameters.Read.Length = ReadLength;

            IoSetCompletionRoutine(Irp, GdfxNonCachedReadCompletion, NULL, TRUE,
                FALSE, FALSE);
        }

        //
        // Call down to the target device.
        //

        return IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);
    }

    //
    // Scatter/gather operations are always non-cached.
    //

    ASSERT(GdfxIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION));

    //
    // Otherwise, handle reading the data using the file cache.
    //

    PhysicalByteOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart +
        GdfxSectorToPhysicalByteOffset(Fcb->FirstSector);

    status = FscCachedRead(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, ReadLength, NonCachedEndOfFileTransfer);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\volinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_VOLUME_INFORMATION.

--*/

#include "gdfx.h"

NTSTATUS
GdfxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_QUERY_VOLUME_INFORMATION requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ULONG BytesWritten;
    PFILE_FS_SIZE_INFORMATION SizeInformation;
    PFILE_FS_DEVICE_INFORMATION DeviceInformation;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInformation;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryVolume.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsVolumeInformation:
            NOTHING;
            BytesWritten = FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel);
            break;

        case FileFsSizeInformation:
            SizeInformation = (PFILE_FS_SIZE_INFORMATION)Irp->UserBuffer;
            SizeInformation->TotalAllocationUnits.QuadPart =
                (ULONGLONG)VolumeExtension->PartitionSectorCount;
            SizeInformation->SectorsPerAllocationUnit = 1;
            SizeInformation->BytesPerSector = GDF_CD_SECTOR_SIZE;
            BytesWritten = sizeof(FILE_FS_SIZE_INFORMATION);
            break;

        case FileFsDeviceInformation:
            DeviceInformation = (PFILE_FS_DEVICE_INFORMATION)Irp->UserBuffer;
            DeviceInformation->DeviceType =
                VolumeExtension->TargetDeviceObject->DeviceType;
            DeviceInformation->Characteristics = 0;
            BytesWritten = sizeof(FILE_FS_DEVICE_INFORMATION);
            break;

        case FileFsAttributeInformation:
            AttributeInformation =
                (PFILE_FS_ATTRIBUTE_INFORMATION)Irp->UserBuffer;
            AttributeInformation->FileSystemAttributes = 0;
            AttributeInformation->MaximumComponentNameLength = 255;
            AttributeInformation->FileSystemNameLength = sizeof(OCHAR) * 4;

            if (IrpSp->Parameters.QueryVolume.Length <
                FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                sizeof(OCHAR) * 4) {
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName);
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                RtlCopyMemory(AttributeInformation->FileSystemName, OTEXT("GDFX"),
                    sizeof(OCHAR) * 4);
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName) + sizeof(OCHAR) * 4;
            }
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryVolume.Length);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\halp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    halp.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    interfaces, defines and structures.

--*/

#ifndef _HALP_
#define _HALP_

#include <ntos.h>
#include <hal.h>
#include <pci.h>
#include <smcdef.h>

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)
#pragma intrinsic(_enable,_disable)

#ifdef RtlMoveMemory
#undef RtlMoveMemory
#undef RtlCopyMemory
#undef RtlFillMemory
#undef RtlZeroMemory

#define RtlCopyMemory(Destination,Source,Length) RtlMoveMemory((Destination),(Source),(Length))

VOID
RtlMoveMemory (
   PVOID Destination,
   CONST VOID *Source,
   ULONG Length
   );

VOID
RtlFillMemory (
   PVOID Destination,
   ULONG Length,
   UCHAR Fill
   );

VOID
RtlZeroMemory (
   PVOID Destination,
   ULONG Length
   );

#endif

#include "ix8259.inc"

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define HalDbgPrint(x)                          DbgPrint x
#else
#define HalDbgPrint(x)
#endif

//
// Define function prototypes.
//

VOID
HalpSetupPCIDevices(
    VOID
    );

VOID
HalpProfileInterrupt(
    VOID
    );

VOID
HalpInitializeClock(
    VOID
    );

VOID
HalpInitializeStallExecution(
    VOID
    );

VOID
HalpInitializePICs(
    VOID
    );

VOID
HalpInitializeRealTimeClock(
    VOID
    );

VOID
HalpInitializeSystemControlInterrupt(
    VOID
    );

VOID
HalpSystemControlInterrupt(
    VOID
    );

VOID
HalpSMBusInterrupt(
    VOID
    );

VOID
HalpProcessSMCInitialState(
    VOID
    );

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrAddress
    );

VOID
WRMSR (
    IN ULONG        MsrAddress,
    IN ULONGLONG    MsrValue
    );

//
// Disable the Local APIC on UP (PIC 8259) PentiumPro systems to work around
// spurious interrupt errata.
//
#define APIC_BASE_MSR       0x1B
#define APIC_ENABLED        0x0000000000000800

//
// Definitions provided by NVidia for remapping USB ports
// between host controllers.
//

#define MCP_USB_CFG_20           0x00000050 /* RW-4R */
#define MCP_USB_CFG_20_PORT0     0x00000001 /* RWI-V */
#define MCP_USB_CFG_20_PORT1     0x00000002 /* RWI-V */
#define MCP_USB_CFG_20_PORT2     0x00000004 /* RWI-V */
#define MCP_USB_CFG_20_PORT3     0x00000008 /* RW--V */
#define MCP_USB_CFG_20_PORT4     0x00000010 /* RW--V */
#define MCP_USB_CFG_20_PORT5     0x00000020 /* RW--V */

extern KEVENT HalpTrayEjectCompleteEvent;

#endif // _HALP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\gdformat.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    gdformat.h

Abstract:

    This module defines the on-disk structure of the GDF file system.

--*/

#ifndef _GDFORMAT_
#define _GDFORMAT_

#include <pshpack1.h>

//
// Define the signature bytes that are at the head and tail of the volume
// descriptor sector.
//

#define GDF_VOLUME_DESCRIPTOR_SIGNATURE             "MICROSOFT*XBOX*MEDIA"
#define GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH      20

//
// Define the logical sector number of the volume descriptor sector.
//
// For ISO-9960 images, logical sector 16 is the start of the volume descriptor
// sequence.  For UDF images, logical sector 256 is a possible sector for the
// anchor volume descriptor pointer.  The following sector number is chosen
// such that its possible to coexist with other file systems for demo discs
// recorded on standard media.
//

#define GDF_VOLUME_DESCRIPTOR_SECTOR                32

//
// Define the structure of the GDF volume descriptor.
//
// The head and tail signature shall be set to GDF_VOLUME_DESCRIPTOR_SIGNATURE.
//
// The root directory starting sector is an absolute sector number relative to
// the start of the media.  The root directory file size is the number of bytes
// allocated to the root directory.
//
// The time stamp is the volume creation date stored as a the number of 100
// nanosecond intervals since January 1, 1601 UTC (see the documentation for
// FILETIME in the Xbox XDK or Platform SDK).  This time stamp is used as the
// time stamp for all files on the volume and is visible to the title through
// Win32 APIs such as FindFirstFile or GetFileAttributesEx.
//
// The reserved bytes shall be set to zero.
//

typedef struct _GDF_VOLUME_DESCRIPTOR {
    UCHAR HeadSignature[GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH];
    ULONG RootDirectoryFirstSector;
    ULONG RootDirectoryFileSize;
    LARGE_INTEGER TimeStamp;
    UCHAR Reserved[1992];
    UCHAR TailSignature[GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH];
} GDF_VOLUME_DESCRIPTOR, *PGDF_VOLUME_DESCRIPTOR;

//
// Define the structure of a GDF directory entry.
//
// Directory entries are stored as a binary tree with the directory entry at
// byte offset zero serving as the root node of the tree.  When searching for a
// file name in a directory, the file system will do a case insensitive
// comparison of the target name to the name stored in the directory entry.  If
// the names are equal, then the target directory entry has been found.  If the
// target name is less than the name stored in the current directory entry, then
// the left entry index is used to find the next directory entry.  If the target
// name is greater than the name stored in the current directory entry, then the
// right entry index is used to find the next directory entry.
//
// The left and right entry indexes are multiplied by four to obtain the byte
// offset of the next directory entry.  If the left or right entry indexes are
// zero, then there are no more directory entries that will satisfy the target
// name search, so the name search is stopped.  The byte offsets of the
// directory entries obtained by following the left or right entry indexes must
// be greater than the byte offset of the current directory entry; no entry
// indexes can point to a directory entry at a byte offset less than or equal to
// the current directory entry.
//
// Given that the left and right entry indexes are a 16-bit quantity and they
// are multiplied by four to obtain a byte offset, the maximum size for a GDF
// directory stream is 256K.
//
// No directory entry shall span a 2048 byte CD sector.  If a directory stream
// sector cannot be filled with directory entries, then all unused bytes shall
// be filled with GDF_DIRECTORY_STREAM_PADDING.
//
// The starting sector is an absolute sector number relative to the start of the
// media.  The file size is the number of bytes allocated to the file.  All GDF
// files are allocated as a single extent.  The file size shall be filled in for
// files and directories.
//
// The file attributes shall consist of the Win32 file attributes
// (FILE_ATTRIBUTE_*), but the only file attribute that the file system will pay
// attention to is FILE_ATTRIBUTE_DIRECTORY.
//
// The file name length is the number of bytes in the following variable length
// file name field.  The file name length shall not be zero.
//
// The file name shall be 1 to 255 characters from the first 256 entries of the
// 16-bit Unicode table.  Note that this is not equivalent to ASCII or to any of
// the Windows code pages.
//

typedef struct _GDF_DIRECTORY_ENTRY {
    USHORT LeftEntryIndex;
    USHORT RightEntryIndex;
    ULONG FirstSector;
    ULONG FileSize;
    UCHAR FileAttributes;
    UCHAR FileNameLength;
    UCHAR FileName[1];
} GDF_DIRECTORY_ENTRY, *PGDF_DIRECTORY_ENTRY;

//
// Define the byte used to fill the unused space between the last directory
// entry of a sector and the end of the sector.  When enumerating the contents
// of a directory, the file system will check for a "LeftEntryIndex ==
// RightEntryIndex == ((USHORT)-1)" in order to know that the rest of the
// directory stream sector is padding.
//

#define GDF_DIRECTORY_STREAM_PADDING                ((UCHAR)-1)

#include <poppack.h>

#endif  // GDFORMAT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\gdfx\mountvol.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    mountvol.c

Abstract:

    This module implements routines related to the mounting of a GDF volume.

--*/

#include "gdfx.h"

//
// GDF volume descriptor signature.
//
const UCHAR GdfxVolumeDescriptorSignature[] = GDF_VOLUME_DESCRIPTOR_SIGNATURE;

NTSTATUS
GdfxCreateVolumeDevice(
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PDISK_GEOMETRY DiskGeometry,
    OUT PDEVICE_OBJECT *ReturnedVolumeDeviceObject
    )
/*++

Routine Description:

    This routine creates an instance of a volume device object.

Arguments:

    TargetDeviceObject - Specifies the device object that the volume object
        sends I/O requests to.

    DiskGeometry - Specifies the disk geometry of the target device.

    ReturnedVolumeDeviceObject - Specifies the buffer to receive the created
        device object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT VolumeDeviceObject;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PGDF_FCB VolumeFcb;
    PGDF_FCB RootDirectoryFcb;

    //
    // Create the volume's device object.
    //

    status = IoCreateDevice(&GdfxDriverObject, sizeof(GDF_VOLUME_EXTENSION),
        NULL, FILE_DEVICE_CD_ROM_FILE_SYSTEM, FALSE, &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Increase the volume's IRP stack size for requests that we pass down to
    // the target device object.
    //

    VolumeDeviceObject->StackSize = (UCHAR)(VolumeDeviceObject->StackSize +
        TargetDeviceObject->StackSize);

    //
    // Ensure that the alignment for this device matches the requirements of the
    // target device.
    //

    if (VolumeDeviceObject->AlignmentRequirement < TargetDeviceObject->AlignmentRequirement) {
        VolumeDeviceObject->AlignmentRequirement = TargetDeviceObject->AlignmentRequirement;
    }

    //
    // If the target device object supports scatter gather I/O, then indicate
    // that we can as well.
    //

    if (GdfxIsFlagSet(TargetDeviceObject->Flags, DO_SCATTER_GATHER_IO)) {
        VolumeDeviceObject->Flags |= DO_SCATTER_GATHER_IO;
    }

    //
    // Set the size of a sector for this device.
    //

    VolumeDeviceObject->SectorSize = GDF_CD_SECTOR_SIZE;

    //
    // Increment the reference count on the target device object since we'll be
    // holding a pointer to it.
    //

    ObReferenceObject(TargetDeviceObject);

    //
    // Initialize the volume's device extension data.
    //

    VolumeExtension = (PGDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    VolumeExtension->TargetDeviceObject = TargetDeviceObject;
    VolumeExtension->SectorSize = GDF_CD_SECTOR_SIZE;
    VolumeExtension->PartitionSectorCount = DiskGeometry->Cylinders.LowPart;
    VolumeExtension->PartitionLength.QuadPart =
        (ULONGLONG)DiskGeometry->Cylinders.LowPart << GDF_CD_SECTOR_SHIFT;

    //
    // Allocate the file control block for the physical volume.
    //

    VolumeFcb = ExAllocatePoolWithTag(sizeof(GDF_FCB), 'cVxG');

    if (VolumeFcb == NULL) {
        GdfxDeleteVolumeDevice(VolumeDeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    VolumeExtension->VolumeFcb = VolumeFcb;

    //
    // Initialize the file control block for the physical volume.
    //

    RtlZeroMemory(VolumeFcb, sizeof(GDF_FCB));

    VolumeFcb->Flags = GDF_FCB_VOLUME;
    VolumeFcb->ReferenceCount = 1;

    InitializeListHead(&VolumeFcb->SiblingFcbLink);

    //
    // Allocate the file control block for the physical volume.
    //

    RootDirectoryFcb = ExAllocatePoolWithTag(sizeof(GDF_FCB), 'cRxG');

    if (RootDirectoryFcb == NULL) {
        GdfxDeleteVolumeDevice(VolumeDeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    VolumeExtension->RootDirectoryFcb = RootDirectoryFcb;

    //
    // Initialize the file control block for the root directory;
    //

    RtlZeroMemory(RootDirectoryFcb, sizeof(GDF_FCB));

    RootDirectoryFcb->Flags = GDF_FCB_DIRECTORY | GDF_FCB_ROOT_DIRECTORY;
    RootDirectoryFcb->ReferenceCount = 1;

    InitializeListHead(&RootDirectoryFcb->SiblingFcbLink);
    InitializeListHead(&RootDirectoryFcb->ChildFcbList);

    //
    // The device has finished initializing and is ready to accept requests.
    //

    VolumeDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Return the device object to the caller.
    //

    *ReturnedVolumeDeviceObject = VolumeDeviceObject;

    return STATUS_SUCCESS;
}

VOID
GdfxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    )
/*++

Routine Description:

    This routine deletes an instance of a volume device object.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to delete.

Return Value:

    Status of operation.

--*/
{
    PGDF_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // There shouldn't be any open files for this volume.
    //

    ASSERT(VolumeExtension->FileObjectCount == 0);

    //
    // Delete any file control blocks created by the volume.
    //

    if (VolumeExtension->VolumeFcb != NULL) {
        GdfxDereferenceFcb(VolumeExtension->VolumeFcb);
    }

    if (VolumeExtension->RootDirectoryFcb != NULL) {
        GdfxDereferenceFcb(VolumeExtension->RootDirectoryFcb);
    }

    //
    // Invalidate any file system cache buffers for this device.
    //

    FscInvalidateDevice(&VolumeExtension->CacheExtension);

    //
    // Release the reference on the target device object.
    //

    if (VolumeExtension->TargetDeviceObject != NULL) {
        ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice(VolumeDeviceObject);
}

NTSTATUS
GdfxProcessVolumeDescriptor(
    IN PDEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine reads the volume descriptor for the supplied volume device
    object, validates its structure, and caches any interesting information in
    the device extension.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to mount.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PVOID CacheBuffer;
    PGDF_VOLUME_DESCRIPTOR VolumeDescriptor;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // If the volume is too small to hold a volume descriptor sector, then bail
    // out now.
    //

    if (VolumeExtension->PartitionSectorCount <= GDF_VOLUME_DESCRIPTOR_SECTOR) {
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    // Map the volume descriptor into the cache.
    //

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
        GdfxSectorToPhysicalByteOffset(GDF_VOLUME_DESCRIPTOR_SECTOR), FALSE,
        &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    VolumeDescriptor = (PGDF_VOLUME_DESCRIPTOR)CacheBuffer;

    //
    // Validate the signature of the sector.
    //

    if (RtlEqualMemory(VolumeDescriptor->HeadSignature,
            GdfxVolumeDescriptorSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH) &&
        RtlEqualMemory(VolumeDescriptor->TailSignature,
            GdfxVolumeDescriptorSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH)) {

        //
        // Validate that the root directory is contained within the volume.
        //

        if ((VolumeDescriptor->RootDirectoryFirstSector < VolumeExtension->PartitionSectorCount) &&
            ((VolumeExtension->PartitionSectorCount - VolumeDescriptor->RootDirectoryFirstSector) >=
                (GDF_CD_SECTOR_ALIGN_UP(VolumeDescriptor->RootDirectoryFileSize) >> GDF_CD_SECTOR_SHIFT))) {

            //
            // Save the starting sector and size of the root directory in the
            // root directory file control block.
            //

            VolumeExtension->RootDirectoryFcb->FirstSector =
                VolumeDescriptor->RootDirectoryFirstSector;
            VolumeExtension->RootDirectoryFcb->FileSize =
                VolumeDescriptor->RootDirectoryFileSize;

            //
            // Save the global time stamp for the volume's files.
            //

            VolumeExtension->TimeStamp = VolumeDescriptor->TimeStamp;

            status = STATUS_SUCCESS;

        } else {
            status = STATUS_DISK_CORRUPT_ERROR;
        }

    } else {
        status = STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    // Unmap the cache buffer.
    //

    FscUnmapBuffer(CacheBuffer);

    return status;
}

NTSTATUS
GdfxMountVolume(
    IN PDEVICE_OBJECT TargetDeviceObject
    )
/*++

Routine Description:

    This routine is called by the I/O manager to attempt to mount this file
    system.

Arguments:

    TargetDeviceObject - Specifies the device object to attempt to mount.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIRP Irp;
    PDEVICE_OBJECT VolumeDeviceObject;
    DISK_GEOMETRY DiskGeometry;

    Irp = NULL;
    VolumeDeviceObject = NULL;

    GdfxAcquireGlobalMutexExclusive();

    //
    // Attempt to perform the DVD-X2 authentication sequence in order to switch
    // to the Xbox partition.  If this fails, continue using the standard
    // partition.
    //

    IoSynchronousDeviceIoControlRequest(IOCTL_CDROM_AUTHENTICATION_SEQUENCE,
        TargetDeviceObject, NULL, 0, NULL, 0, NULL, FALSE);

    //
    // Get the drive geometry from the device.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_CDROM_GET_DRIVE_GEOMETRY,
        TargetDeviceObject, NULL, 0, &DiskGeometry, sizeof(DISK_GEOMETRY), NULL,
        FALSE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    ASSERT(DiskGeometry.Cylinders.HighPart == 0);
    ASSERT(DiskGeometry.TracksPerCylinder == 1);
    ASSERT(DiskGeometry.SectorsPerTrack == 1);
    ASSERT(DiskGeometry.BytesPerSector == GDF_CD_SECTOR_SIZE);

    //
    // Create an I/O request packet in order to submit requests to the target
    // device.
    //

    Irp = IoAllocateIrp(TargetDeviceObject->StackSize);

    if (Irp == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Create the volume's device object.
    //

    status = GdfxCreateVolumeDevice(TargetDeviceObject, &DiskGeometry,
        &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Process the volume descriptor for the volume.
    //

    status = GdfxProcessVolumeDescriptor(VolumeDeviceObject, Irp);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Connect the volume device object to the target device object and return
    // success.
    //

    TargetDeviceObject->MountedOrSelfDevice = VolumeDeviceObject;
    VolumeDeviceObject = NULL;

    status = STATUS_SUCCESS;

CleanupAndExit:
    if (VolumeDeviceObject != NULL) {
        GdfxDeleteVolumeDevice(VolumeDeviceObject);
    }

    if (Irp != NULL) {
        IoFreeIrp(Irp);
    }

    GdfxReleaseGlobalMutex();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixclock.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixclock.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Environment:
;
;    Kernel mode only.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list

;
; Constants used to initialize timer 0
;

TIMER1_DATA_PORT0       EQU     40H     ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0    EQU     43H     ; Timer1, channel 0 control port

COMMAND_8254_COUNTER0   EQU     00H     ; Select count 0
COMMAND_8254_RW_16BIT   EQU     30H     ; Read/Write LSB firt then MSB
COMMAND_8254_MODE2      EQU     4       ; Use mode 2
COMMAND_8254_BCD        EQU     0       ; Binary count down
COMMAND_8254_LATCH_READ EQU     0       ; Latch read command

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Clock"
;++
;
; VOID
; HalpInitializeClock (
;    )
;
; Routine Description:
;
;    This routine initialize system time clock using 8254 timer1 counter 0
;    to generate an interrupt at every 15ms interval at 8259 irq0.
;
;    See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
;    needs to be changed.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpInitializeClock      ,0

        mov     ecx, CLOCK_ROLLOVER_COUNT

        pushfd                          ; save caller's eflag
        cli                             ; make sure interrupts are disabled

;
; Set clock rate
; (ecx) = RollOverCount
;

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        popfd                             ; restore caller's eflag

        stdRET    _HalpInitializeClock

stdENDP _HalpInitializeClock

INIT    ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixcmos.asm ===
title  "Cmos Access Routines"
;++
;
; Module Name:
;
;    ixcmos.asm
;
; Abstract:
;
;    Procedures necessary to access CMOS/ECMOS information.
;
; Author:
;
;    David Risner (o-ncrdr) 20 Apr 1992
;
; Revision History:
;
;    Landy Wang (corollary!landy) 04 Dec 1992
;    - Move much code from ixclock.asm to here so different HALs
;      can reuse the common functionality.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; Holds the value of the eflags register before a cmos spinlock is
; acquired (used in HalpAcquire/ReleaseCmosSpinLock().
;
_HalpHardwareLockFlags   dd      0

_DATA   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Read System Time"
;++
;
; BOOLEAN
; HalQueryRealTimeClock (
;    PTIME_FIELDS TimeFields
;    )
;
; Routine Description:
;
;    This routine reads current time from CMOS memory and stores it
;    in the TIME_FIELDS structure passed in by caller.
;
; Arguments:
;
;    TimeFields - A pointer to the TIME_FIELDS structure.
;
; Return Value:
;
;    If the power to the realtime clock has not failed, then the time
;    values are read from the realtime clock and a value of TRUE is
;    returned. Otherwise, a value of FALSE is returned.
;
;--

;
; Parameters:
;

KrctPTimeFields equ [esp+4]

cPublicProc _HalQueryRealTimeClock ,1

if DBG
krctwait0:
        mov     ecx, 100
krctwait:
        push    ecx
else
krctwait:
endif
        stdCall   _HalpAcquireCmosSpinLock
        mov     ecx, 100
        align   4
krct00: mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short krct10            ; if z, no, go read CMOS time
        loop    short krct00            ; otherwise, try again.

;
; CMOS is still busy. Try again ...
;

        stdCall _HalpReleaseCmosSpinLock
if DBG
        pop     ecx
        loop    short krctwait
        stdCall _DbgBreakPoint
        jmp     short krctwait0
else
        jmp     short krctwait
endif
        align   4
if DBG
krct10:
        pop     ecx
else
krct10:
endif
        mov     edx, KrctPTimeFields    ; (edx)-> TIME_FIELDS structure
        xor     eax, eax                ; (eax) = 0

        ;
        ; The RTC is only accurate within one second.  So
        ; add a half a second so that we are closer, on average,
        ; to the right answer.
        ;
        mov     word ptr [edx].TfMilliseconds, 500      ; add a half a second
        
        mov     al, RTC_OFFSET_SECOND
        CMOS_READ                       ; (al) = second in BCD form
        BCD_TO_BIN                      ; (ax) = second
        mov     [edx].TfSecond, ax      ; set second in TIME_FIELDS
        
        mov     al, RTC_OFFSET_MINUTE
        CMOS_READ                       ; (al) = minute in BCD form
        BCD_TO_BIN                      ; (ax) = Minute
        mov     [edx].TfMinute, ax      ; set minute in TIME_FIELDS

        mov     al, RTC_OFFSET_HOUR
        CMOS_READ                       ; (al) = hour in BCD form
        BCD_TO_BIN                      ; (ax) = Hour
        mov     [edx].TfHour, ax        ; set hour in TIME_FIELDS

        mov     al, RTC_OFFSET_DAY_OF_WEEK
        CMOS_READ                       ; (al) = day-of-week in BCD form
        BCD_TO_BIN                      ; (ax) = day-of-week
        mov     [edx].TfWeekday, ax     ; set Weekday in TIME_FIELDS

        mov     al, RTC_OFFSET_DATE_OF_MONTH
        CMOS_READ                       ; (al) = date-of-month in BCD form
        BCD_TO_BIN                      ; (ax) = date_of_month
        mov     [edx].TfDay, ax         ; set day in TIME_FIELDS

        mov     al, RTC_OFFSET_MONTH
        CMOS_READ                       ; (al) = month in BCD form
        BCD_TO_BIN                      ; (ax) = month
        mov     [edx].TfMonth, ax       ; set month in TIME_FIELDS

        mov     al, RTC_OFFSET_YEAR
        CMOS_READ                       ; (al) = year in BCD form
        BCD_TO_BIN                      ; (ax) = year
        push    eax                     ; save year in stack

        mov     al, RTC_OFFSET_CENTURY
        CMOS_READ                       ; (al) = century byte in BCD form
        BCD_TO_BIN                      ; (ax) = century

        mov     ah, 100
        mul     ah                      ; (ax) = century * 100
        pop     ecx                     ; (cx) = year
        add     ax, cx                  ; (ax)= year

        cmp     ax, 1900                ; Is year > 1900
        jb      short krct40
        cmp     ax, 1920                ; and < 1920
        jae     short krct40
        add     ax, 100                 ; Compensate for century field

krct40:
        mov     [edx].TfYear, ax        ; set year in TIME_FIELDS

        stdCall   _HalpReleaseCmosSpinLock

        mov     al, 1                   ; return TRUE

        stdRET    _HalQueryRealTimeClock

stdENDP _HalQueryRealTimeClock

        page ,132
        subttl  "Write System Time"
;++
;
; BOOLEAN
; HalSetRealTimeClock (
;    PTIME_FIELDS TimeFields
;    )
;
; Routine Description:
;
;    This routine writes current time from TIME_FILEDS structure
;    to CMOS memory.
;
; Arguments:
;
;    TimeFields - A pointer to the TIME_FIELDS structure.
;
; Return Value:
;
;    If the power to the realtime clock has not failed, then the time
;    values are written to the realtime clock and a value of TRUE is
;    returned. Otherwise, a value of FALSE is returned.
;
;--

;
; Parameters:
;

KrctPTimeFields equ [esp+4]

cPublicProc _HalSetRealTimeClock ,1

if DBG
kwctwait0:
        mov     ecx, 100
kwctwait:
        push    ecx
else
kwctwait:
endif
        stdCall   _HalpAcquireCmosSpinLock
        mov     ecx, 100
        align   4
kwct00: mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short kwct10            ; if z, no, go write CMOS time
        loop    short kwct00            ; otherwise, try again.

;
; CMOS is still busy. Try again ...
;

        stdCall _HalpReleaseCmosSpinLock
if DBG
        pop     ecx
        loop    short kwctwait
        stdCall _DbgBreakPoint
        jmp     short kwctwait0
else
        jmp     short kwctwait
endif
        align   4
if DBG
kwct10:
        pop     ecx
else
kwct10:
endif
        mov     edx, KrctPTimeFields    ; (edx)-> TIME_FIELDS structure

        mov     al, [edx].TfSecond      ; Read second in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_SECOND
        CMOS_WRITE

        mov     al, [edx].TfMinute      ; Read minute in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_MINUTE
        CMOS_WRITE

        mov     al, [edx].TfHour        ; Read Hour in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_HOUR
        CMOS_WRITE

        mov     al, [edx].TfWeekDay     ; Read WeekDay in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_DAY_OF_WEEK
        CMOS_WRITE

        mov     al, [edx].TfDay         ; Read day in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_DATE_OF_MONTH
        CMOS_WRITE

        mov     al, [edx].TfMonth       ; Read month in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_MONTH
        CMOS_WRITE

        mov     ax, [edx].TfYear        ; Read Year in TIME_FIELDS
        cmp     ax, 9999
        jbe     short kwct15
        mov     ax, 9999

        align   4
kwct15:
        mov     cl, 100
        div     cl                      ; [ax]/[cl]->al=quo, ah=rem
        push    eax

        BIN_TO_BCD
        mov     ah, al                  ; [ah] = Century in BCD form
        mov     al, RTC_OFFSET_CENTURY
        CMOS_WRITE

        pop     eax
        mov     al, ah                  ; [al] = Year
        BIN_TO_BCD
        mov     ah, al                  ; [ah] = year in BCD
        mov     al, RTC_OFFSET_YEAR
        CMOS_WRITE

        stdCall _HalpReleaseCmosSpinLock

        mov     al, 1                   ; return TRUE

        stdRET  _HalSetRealTimeClock

stdENDP _HalSetRealTimeClock

        page ,132
        subttl  "CMOS Subrange Validity Check"
;++
;
; BOOLEAN
; HalpIsCmosSubrangeValid(
;    IN ULONG NumberOfBytes,
;    IN ULONG RegisterNumber
;    )
;
; Routine Description:
;
;    This routine checks if the CMOS subrange data is valid.
;
; Arguments:
;
;    NumberOfBytes - Number of bytes in the subrange.
;
;    RegisterNumber - First register of the subrange to check.
;
; Return Value:
;
;    Returns ZF=1 if data stored in the CMOS subrange is valid, else ZF=0.
;
;--

cPublicFastCall HalpIsCmosSubrangeValid, 2

        mov     ah, 0AAh                ; opposite of first expected bit pattern
icsv10: mov     al, dl                  ; CMOS register to index
        ECMOS_READ
        not     ah                      ; flip bit pattern
        inc     edx
        cmp     al, ah                  ; check if the byte matches
        loope   icsv10                  ; loop while bytes remaining and equal

        fstRET  HalpIsCmosSubrangeValid

fstENDP HalpIsCmosSubrangeValid

        page ,132
        subttl  "CMOS Validity Check"
;++
;
; BOOLEAN
; HalIsCmosValid(
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks if the data stored in the CMOS is valid.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Returns TRUE if the data stored in the CMOS is valid, else FALSE.
;
;--

cPublicProc _HalIsCmosValid, 0

        stdCall _HalpAcquireCmosSpinLock

;
; Break the check of the CMOS data into two subranges, because some of the
; registers are used for the real time clock or control registers.
;

        mov     ecx, 60h
        mov     edx, 10h
        fstCall HalpIsCmosSubrangeValid
        jne     icv10

        mov     ecx, 80h
        mov     edx, ecx
        fstCall HalpIsCmosSubrangeValid

icv10:  sete    al
        stdCall _HalpReleaseCmosSpinLock

        stdRET  _HalIsCmosValid

stdENDP _HalIsCmosValid

        page ,132
        subttl  "CMOS Subrange Validity Check"
;++
;
; VOID
; HalpMarkCmosSubrangeValid(
;    IN ULONG NumberOfBytes,
;    IN ULONG RegisterNumber
;    )
;
; Routine Description:
;
;    This routine checks if the CMOS subrange data is valid.
;
; Arguments:
;
;    NumberOfBytes - Number of bytes in the subrange.
;
;    RegisterNumber - First register of the subrange to check.
;
; Return Value:
;
;    Returns ZF=1 if data stored in the CMOS subrange is valid, else ZF=0.
;
;--

cPublicFastCall HalpMarkCmosSubrangeValid, 0

        mov     ah, 055h                ; first expected bit pattern
mcrv10: mov     al, dl                  ; CMOS register to index
        ECMOS_WRITE
        not     ah                      ; flip bit pattern
        inc     edx
        loop    mcrv10

        fstRET  HalpMarkCmosSubrangeValid

fstENDP HalpMarkCmosSubrangeValid

        page ,132
        subttl  "Marks CMOS data as valid"
;++
;
; VOID
; HalMarkCmosValid(
;    VOID
;    )
;
; Routine Description:
;
;    This routine sets the real time clock data to the valid state.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalMarkCmosValid, 0

        stdCall _HalpAcquireCmosSpinLock

;
; Break the marking of the CMOS data into two subranges, because some of the
; registers are used for the real time clock or control registers.
;

        mov     ecx, 60h
        mov     edx, 10h
        fstCall HalpMarkCmosSubrangeValid

        mov     ecx, 80h
        mov     edx, ecx
        fstCall HalpMarkCmosSubrangeValid

        stdCall _HalpReleaseCmosSpinLock

        stdRET  _HalMarkCmosValid

stdENDP _HalMarkCmosValid

;++
;
; Routine Description:
;
;   Acquires a spinlock to access the cmos chip. The cmos chip is
;   accessed at different irql levels, so to be safe, we 'cli'.
;   We could replace that to raise irql to PROFILE_LEVEL, but that's
;   a lot of code.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Interrupt is disabled.
;    Irql level not affected.
;    Flags saved in _HalpHardwareLockFlags.
;--

cPublicProc _HalpAcquireCmosSpinLock  ,0

        pushfd
        cli
        pop     _HalpHardwareLockFlags          ; save flags for release S.L.
        stdRET    _HalpAcquireCmosSpinLock

stdENDP _HalpAcquireCmosSpinLock

;++
;
; Routine Description:
;
;   Release spinlock, and restore flags to the state it was before
;   acquiring the spinlock.
;
; Arguments:
;
;   None
;
; Return Value:
;
;   Interrupts restored to their state before acquiring spinlock.
;   Irql level not affected.
;
;--

cPublicProc _HalpReleaseCmosSpinLock  ,0

        ;
        ; restore eflags as it was before acquiring spinlock. Put it on
        ; stack before releasing spinlock (so other cpus cannot overwrite
        ; it with their own eflags).
        ;
        push    _HalpHardwareLockFlags          ; old eflags on stack.
        popfd                                   ; restore eflags.
        stdRET    _HalpReleaseCmosSpinLock

stdENDP _HalpReleaseCmosSpinLock

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixnmi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixnmi.c

Abstract:

    Provides standard x86 NMI handler

Author:

    kenr

Revision History:

--*/

#include "halp.h"

VOID
HalHandleNMI(
    VOID
    )
/*++

Routine Description:

    Called DURING an NMI.  The system will BugCheck when an NMI occurs.
    This function can return the proper bugcheck code, bugcheck itself,
    or return success which will cause the system to iret from the nmi.

    This function is called during an NMI - no system services are available.
    In addition, you don't want to touch any spinlock which is normally
    used since we may have been interrupted while owning it, etc, etc...

Warnings:

    Do NOT:
      Make any system calls
      Attempt to acquire any spinlock used by any code outside the NMI handler
      Change the interrupt state.  Do not execute any IRET inside this code

    Passing data to non-NMI code must be done using manual interlocked
    functions.  (xchg instructions).

Arguments:

    None.

Return Value:

    None.

--*/
{
#ifdef DEVKIT
    if ((KdDebuggerNotPresent == FALSE) && (KdDebuggerEnabled != FALSE)) {
        KeEnterKernelDebugger();
    }
#endif

    HalHaltSystem();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixcmos.inc ===
;/*
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       ixcmos.inc
;
;   Abstract:
;
;       This module contains common definitions used by the CMOS.
;
;   Author:
;
;       Landy Wang (corollary!landy) 04-Dec-1992
;
;               (Moved from ixclock.asm)
;
;--

;
;	_HalpAcquireCmosSpinLock and _HalpReleaseCmosSpinLock
;	must be called before accessing the CMOS in both uniprocessor
;	and multiprocessor systems.

RTCIRQ                  EQU     8       ; IRQ number for RTC interrupt
CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port
ECMOS_CONTROL_PORT      EQU     72h     ; extended command port for cmos

REGISTER_B_ENABLE_PERIODIC_INTERRUPT EQU     01000010B
                                        ; RT/CMOS Register 'B' Init byte
                                        ; Values for byte shown are
                                        ;  Bit 7 = Update inhibit
                                        ;  Bit 6 = Periodic interrupt enable
                                        ;  Bit 5 = Alarm interrupt disable
                                        ;  Bit 4 = Update interrupt disable
                                        ;  Bit 3 = Square wave disable
                                        ;  Bit 2 = BCD data format
                                        ;  Bit 1 = 24 hour time mode
                                        ;  Bit 0 = Daylight Savings disable

REGISTER_B_DISABLE_PERIODIC_INTERRUPT EQU    00000010B
REGISTER_B_ENABLE_ALARM_INTERRUPT     EQU    00100000B
REGISTER_B_DISABLE_ALARM_INTERRUPT    EQU    00000000B
REGISTER_B_24HOUR_MODE                EQU    00000010B

;
; CMOS_READ
;
; Description: This macro reads a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Returns: (AL) = data
;

CMOS_READ       MACRO
        OUT     CMOS_CONTROL_PORT,al    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

;
; CMOS_WRITE
;
; Description: This macro reads a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
;            (AH) = data to be written
;
; Return: None
;

CMOS_WRITE      MACRO
        OUT     CMOS_CONTROL_PORT,al    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        MOV     AL,AH                   ; (AL) = DATA
        OUT     CMOS_DATA_PORT,AL       ; PLACE IN REQUESTED CMOS LOCATION
        IODelay                         ; I/O DELAY
ENDM

;
; ECMOS_READ
;
; Description: This macro reads a byte from the ECMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Returns: (AL) = data
;

ECMOS_READ      MACRO
        OUT     ECMOS_CONTROL_PORT,al   ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

;
; ECMOS_WRITE
;
; Description: This macro reads a byte from the ECMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
;            (AH) = data to be written
;
; Return: None
;

ECMOS_WRITE     MACRO
        OUT     ECMOS_CONTROL_PORT,al   ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        MOV     AL,AH                   ; (AL) = DATA
        OUT     CMOS_DATA_PORT,AL       ; PLACE IN REQUESTED CMOS LOCATION
        IODelay                         ; I/O DELAY
ENDM


CMOS_STATUS_BUSY        EQU     80H     ; Time update in progress
RTC_OFFSET_SECOND       EQU     0       ; second field of RTC memory
RTC_OFFSET_SECOND_ALARM EQU     1       ; second alarm field of RTC memory
RTC_OFFSET_MINUTE       EQU     2       ; minute field of RTC memory
RTC_OFFSET_MINUTE_ALARM EQU     3       ; minute alarm field of RTC memory
RTC_OFFSET_HOUR         EQU     4       ; hour field of RTC memory
RTC_OFFSET_HOUR_ALARM   EQU     5       ; hour alarm field of RTC memory
RTC_OFFSET_DAY_OF_WEEK  EQU     6       ; day-of-week field of RTC memory
RTC_OFFSET_DATE_OF_MONTH EQU    7       ; date-of-month field of RTC memory
RTC_OFFSET_MONTH        EQU     8       ; month field of RTC memory
RTC_OFFSET_YEAR         EQU     9       ; year field of RTC memory
RTC_OFFSET_CENTURY      EQU     7Fh     ; Century field of RTC memory (ACPI)
BANK1                   EQU    100h

;
; BCD_TO_BIN
;
; Description: Convert BCD value to binary
;
; Parameter:
;     Input: (AL) = 2 digit BCD number to convert
;     Output: (AX) = Binary equivalent (all in AL)
;
; Return: None.
;

BCD_TO_BIN      macro

        xor     ah,ah
        rol     ax,4
        ror     al,4
        aad
endm

;
; BIN_TO_BCD
;
; Description: Convert binary value to BCD.
;
; Parameter:
;     Input: (AL) = binary value to be converted.
;     Output: (AX) = BCD (all in AL)
;
; Return: None.
;

BIN_TO_BCD      macro

        aam
        rol     al, 4
        ror     ax, 4
endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ix8259.inc ===
;/*
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       ix8259.inc
;
;   Abstract:
;
;       This module contains the definitions used by HAL to manipulate
;       8259 interrupt controller and 8259-specific constants.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;       John Vert (jvert) 31-Dec-1991
;
;               (Moved from ke\i386\kimacro.inc)
;
;--
if 0        ; Begin C only code         */

//
// 8259 defines for C code
// BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
//

#define HIGHEST_LEVEL_FOR_8259  26          // Highest level for standard 8259
#define PRIMARY_VECTOR_BASE     0x30        // Vector base for standard 8259
#define CLOCK_VECTOR            (PRIMARY_VECTOR_BASE + 0)   // standard clock
#define PROFILE_VECTOR          (PRIMARY_VECTOR_BASE + 8)   // standard profile
#define SMBUS_VECTOR            (PRIMARY_VECTOR_BASE + 11)  // standard SMBUS
#define SCI_VECTOR              (PRIMARY_VECTOR_BASE + 12)  // standard SCI
#define I386_80387_IRQ          0x0d                        // standard npx
#define I386_80387_IRQL         (HIGHEST_LEVEL_FOR_8259 - I386_80387_IRQ)
#define I386_80387_VECTOR       (PRIMARY_VECTOR_BASE + I386_80387_IRQ)
#define PIC_VECTORS             16
#define V2I(a)  (a-PRIMARY_VECTOR_BASE)     // Vector to interrupt macro

#ifndef NEC_98
#define PIC_SLAVE_IRQ           2
#define PIC_SLAVE_REDIRECT      9
#else
#define PIC_SLAVE_IRQ           7
#define PIC_SLAVE_REDIRECT      8
#endif


#define EISA_EDGE_LEVEL0        0x4D0
#define EISA_EDGE_LEVEL1        0x4D1


/*
endif

;
; Same 8259 defines for assemble code
; BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
;

HIGHEST_LEVEL_FOR_8259  equ 26
PRIMARY_VECTOR_BASE     equ 30h
CLOCK_VECTOR            equ (PRIMARY_VECTOR_BASE + 0)
PROFILE_VECTOR          equ (PRIMARY_VECTOR_BASE + 8)
SMBUS_VECTOR            equ (PRIMARY_VECTOR_BASE + 11)
SCI_VECTOR              equ (PRIMARY_VECTOR_BASE + 12)
I386_80387_IRQ          equ 0dh
I386_80387_IRQL         equ (HIGHEST_LEVEL_FOR_8259 - I386_80387_IRQ)
I386_80387_VECTOR       equ (PRIMARY_VECTOR_BASE + I386_80387_IRQ)
I386_80387_BUSY_PORT    equ 0f0h    ; port to dismiss busy error line

ifdef NEC_98
PIC_SLAVE_IRQ           equ 7
else
PIC_SLAVE_IRQ           equ 2
endif

;
; The rest of the file are macros used in assemble only.
;

;++
;
;   SET_8259_MASK
;
;   Macro Description:
;
;       This macro sets 8259 interrupt mask register with the mask
;       passed from eax register.
;
;       Note: Currently, only two 8259s are support.  As a result,
;       only ax contains valid mask.
;
;   Arguments:
;
;       (eax) = mask for setting 8259 interrupt mask register
;
;--

SET_8259_MASK   macro
local   a                               ; define local labels

        out     PIC1_PORT1, al          ; set master 8259 mask
        shr     eax, 8                  ; shift slave 8259 mask to al
        out     PIC2_PORT1, al          ; set slave 8259 mask
a:
endm

;
;  Interrupt controller register addresses
;

ifdef NEC_98
PIC1_PORT0 equ 00H
PIC1_PORT1 equ 02H
PIC2_PORT0 equ 08H
PIC2_PORT1 equ 0AH
else  ; NEC_98
PIC1_PORT0 equ 020H
PIC1_PORT1 equ 021H
PIC2_PORT0 equ 0A0H
PIC2_PORT1 equ 0A1H
endif ; NEC_98

EISA_EDGE_LEVEL0        EQU     4D0h
EISA_EDGE_LEVEL1        EQU     4D1h

;
;  Commands for Interrupt controller
;

PIC1_EOI_MASK equ 060H
ifdef NEC_98
PIC2_EOI equ 067H                       ; special EOI
else  ; NEC_98
PIC2_EOI equ 062H
endif ; NEC_98
OCW2_NON_SPECIFIC_EOI equ 020H
OCW2_SPECIFIC_EOI equ 060H
OCW3_READ_ISR equ 0BH
OCW3_READ_IRR equ 0AH


;++
;
;   IODELAY
;
;   Macro Description:
;
;       This macro simply does a jmp to next instruction to synchronize
;       IO port access.
;
;   Arguments:
;
;       None
;
;--

IODELAY         macro
ifdef NEC_98
        out     5fh,al              ; same effect with "stdcall IODelay8259"
else  ; NEC_98
        jmp     $+2
endif ; NEC_98
endm


;++
;
;   PICDELAY
;
;   Macro Description:
;
;       This macro does an inb on interrupt mask register to provide the
;       time for 8259 to get stabled.
;
;       Why do we need this?
;
;       This is because:
;       . The 80386 has a delayed write to memory and delayed output to IO
;         capability and
;       . 8259 needs some time to settle
;
;       It is possible for the actual output cycle to 8259 to occur after
;       the completion of instructions following the out instruction.  For
;       example, the STI instruction after SET_MASK and dismiss interrupt
;       macros may complete before 8259 actually drops the interrupt.  We don't
;       want this happen in MCA system.
;
;       You may argue that most OEMS add about 450ns delay to solve the
;       back-to-back IO (delay) problem.  But, remember that STI is not an IO
;       instruction.
;
;   Arguments:
;
;       None
;
;   NOTE: * The content of AL will be destroyed on return.
;
;--

PIC1DELAY       macro
        in      al, PIC1_PORT1
endm

PIC2DELAY       macro
        in      al, PIC2_PORT1
endm

;++
;
;   SOFT_INTERRUPT_EXIT
;
;   Macro Description:
;
;       This macro is executed on return from the soft interrupt
;       service routine.  Its function is to restore privileged processor
;       state, and continue thread execution.
;
;   Arguments:
;
;       (TOS) = previous irql
;       (TOS+4 ...) = machine_state frame
;
;--

SOFT_INTERRUPT_EXIT macro

        EXTRNP  _HalpEndSoftwareInterrupt,1
        cli
        call    _HalpEndSoftwareInterrupt@4     ; restore irql
        SPURIOUS_INTERRUPT_EXIT                 ; exit interrupt without EOI
endm
;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixprofil.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixprofile.asm
;
; Abstract:
;
;    This module implements the code necessary to initialize,
;    field and process the profile interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (landy@corollary.com) 26-Mar-1992
;       Move much code into separate modules for easy inclusion by various
;       HAL builds.
;
;	Add HalBeginSystemInterrupt() call at beginning of ProfileInterrupt
;	code - this must be done before any sti.
;	Also add HalpProfileInterrupt2ndEntry for additional processors to
;	join the flow of things.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include i386\ix8259.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0
        EXTRNP  HalBeginProfileInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemInterrupt,1,,FASTCALL
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        EXTRN   _KiPCR:DWORD
ifdef DEVKIT
        EXTRN   _KiDbgProfInt:DWORD
endif

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

RegisterAProfileValue   db      00101000B ; default interval = 3.90625 ms

HalpProfilingStopped    dd      1

_DATA   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

align 4
ProfileIntervalTable    dd      1221    ; unit = 100 ns
                        dd      2441
                        dd      4883
                        dd      9766
                        dd      19531
                        dd      39063
                        dd      78125
                        dd      156250
                        dd      312500
                        dd      625000
                        dd      1250000
                        dd      2500000
                        dd      5000000
                        dd      5000000 OR 80000000H

ProfileIntervalInitTable db     00100011B
                        db      00100100B
                        db      00100101B
                        db      00100110B
                        db      00100111B
                        db      00101000B
                        db      00101001B
                        db      00101010B
                        db      00101011B
                        db      00101100B
                        db      00101101B
                        db      00101110B
                        db      00101111B
                        db      00101111B

;++
;
;   HalStartProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is change the interrupt
;       rate from the slowest thing we can get away with to the value
;       that's been KeSetProfileInterval
;
;   All processors will run this routine, but it doesn't hurt to have
;   each one reinitialize the CMOS, since none of them will be let go
;   from the stall until they all finish.
;
;--

cPublicProc _HalStartProfileInterrupt    ,1

;   Mark profiling as active
;

        mov     dword ptr HalpProfilingStopped, 0
hspi100:

;
;   Set the interrupt rate to what is actually needed
;
        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     al, RegisterAProfileValue
        shl     ax, 8
        mov     al, 0AH                 ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalStartProfileInterrupt

stdENDP _HalStartProfileInterrupt



;++
;
;   HalStopProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is change the interrupt
;       rate from the high profiling rate to the slowest thing we
;       can get away with for PerformanceCounter rollover notification.
;
;--

cPublicProc _HalStopProfileInterrupt    ,1

;
;   Turn off profiling hit computation and profile interrupt
;

;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; dismiss pending profiling interrupt
        mov     dword ptr HalpProfilingStopped, 1
hspi200:

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalStopProfileInterrupt

stdENDP _HalStopProfileInterrupt

;++
;   ULONG
;   HalSetProfileInterval (
;       ULONG Interval
;       );
;
;   Routine Description:
;
;       This procedure sets the interrupt rate (and thus the sampling
;       interval) for the profiling interrupt.
;
;       If profiling is active (KiProfilingStopped == 0) the actual
;       hardware interrupt rate will be set.  Otherwise, a simple
;       rate validation computation is done.
;
;   Arguments:
;
;       (TOS+4) - Interval in 100ns unit.
;
;   Return Value:
;
;       Interval actually used by system.
;
;--

cPublicProc _HalSetProfileInterval    ,1

        mov     edx, [esp+4]            ; [edx] = interval in 100ns unit
        and     edx, 7FFFFFFFh          ; Remove highest bit.
        mov     ecx, 0                  ; index = 0

Hspi00:
        mov     eax, ProfileIntervalTable[ecx * 4]
        cmp     edx, eax                ; if request interval < suport interval
        jbe     short Hspi10            ; if be, find supported interval
        inc     ecx
        jmp     short Hspi00

Hspi10:
        and     eax, 7FFFFFFFh          ; remove highest bit from supported interval
        jecxz   short Hspi20            ; If first entry then use it

        push    esi                     ; See which is closer to requested
        mov     esi, eax                ; rate - current entry, or preceeding
        sub     esi, edx

        sub     edx, ProfileIntervalTable[ecx * 4 - 4]
        cmp     esi, edx
        pop     esi
        jc      short Hspi20

        dec     ecx                     ; use preceeding entry
        mov     eax, ProfileIntervalTable[ecx * 4]

Hspi20:
        push    eax                     ; save interval value
        mov     al, ProfileIntervalInitTable[ecx]
        mov     RegisterAProfileValue, al
        test    dword ptr HalpProfilingStopped,-1
        jnz     short Hspi90

        stdCall   _HalStartProfileInterrupt,<0> ; Re-start profile interrupt
                                        ; with the new interval

Hspi90: pop     eax
        stdRET    _HalSetProfileInterval    ; (eax) = cReturn interval

stdENDP _HalSetProfileInterval

        page ,132
        subttl  "System Profile Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a profile interrupt.
;    Its function is to dismiss the interrupt, raise system Irql to
;    PROFILE_LEVEL and transfer control to
;    the standard system routine to process any active profiles.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeProfileInterrupt, which returns
;
;    Sets Irql = PROFILE_LEVEL and dismisses the interrupt
;
;--

cPublicProc _HalpProfileInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT

;
; (esp) - base of trap frame
;
; HalBeginProfileInterrupt must be called before any sti's
;

        mov     ecx, PROFILE_VECTOR - PRIMARY_VECTOR_BASE
        mov     edx, PROFILE_LEVEL
        push    0                       ; allocate space to save OldIrql
        fstCall HalBeginProfileInterrupt

;
; This is the RTC interrupt, so we have to clear the
; interrupt flag on the RTC.
;
        stdCall	_HalpAcquireCmosSpinLock

;
; clear interrupt flag on RTC by banging on the CMOS.  On some systems this
; doesn't work the first time we do it, so we do it twice.  It is rumored that
; some machines require more than this, but that hasn't been observed with NT.
;

        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
if  DBG
	align	4
Hpi10:  test    al, 80h
        jz      short Hpi15
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        jmp     short Hpi10
Hpi15:
endif   ; DBG

        stdCall	_HalpReleaseCmosSpinLock

        sti

;
; (esp) = OldIrql
; (esp+4) = base of trap frame
;

ifdef DEVKIT
; if we have an installed handler, call it
        mov     eax, _KiDbgProfInt
        lea     ecx, [esp+4]
        test    eax, eax
        jz      Hpi20
        push    ecx
        call    eax
Hpi20:
endif

        INTERRUPT_EXIT

stdENDP _HalpProfileInterrupt

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixirql.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixirql.asm
;
; Abstract:
;
;    This module implements the code necessary to raise and lower i386
;    Irql and dispatch software interrupts with the 8259 PIC.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    John Vert (jvert) 27-Nov-1991
;       Moved from kernel into HAL
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list


        EXTRNP  _KeBugCheck,1
        EXTRNP  _KiDispatchInterrupt,0
        extrn   _HalpApcInterrupt:near
        extrn   _HalpDispatchInterrupt:near
        extrn   _KiUnexpectedInterrupt:near
        extrn   _HalpApcInterrupt2ndEntry:NEAR
        extrn   _HalpDispatchInterrupt2ndEntry:NEAR
        extrn   HalpEisaELCR:dword
        extrn   HalpIRR:dword
        extrn   HalpIRRActive:dword
        extrn   HalpIDR:dword
        extrn   _KiPCR:DWORD

;
; Initialization control words equates for the PICs
;

ICW1_ICW4_NEEDED                equ     01H
ICW1_CASCADE                    equ     00H
ICW1_INTERVAL8                  equ     00H
ICW1_LEVEL_TRIG                 equ     08H
ICW1_EDGE_TRIG                  equ     00H
ICW1_ICW                        equ     10H

ICW4_8086_MODE                  equ     001H
ICW4_NORM_EOI                   equ     000H
ICW4_NON_BUF_MODE               equ     000H
ICW4_SPEC_FULLY_NESTED          equ     010H
ICW4_NOT_SPEC_FULLY_NESTED      equ     000H

OCW2_NON_SPECIFIC_EOI           equ     020H
OCW2_SPECIFIC_EOI               equ     060H
OCW2_SET_PRIORITY               equ     0c0H

PIC_SLAVE_IRQ                   equ     2
PIC1_BASE                       equ     30H
PIC2_BASE                       equ     38H

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9

;
; Hardware irq active masks
;

IRQ_ACTIVE_MASK                 equ     0fffffff0h

_TEXT   SEGMENT DWORD PUBLIC 'CODE'

;
; PICsInitializationString - Master PIC initialization command string
;

PICsInitializationString   dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
;
; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string

            align   4
            public  KiI8259MaskTable
KiI8259MaskTable    label   dword
                dd      00000000000000000000000000000000B ; irql 0 (NORMAL)
                dd      00000000000000000000000000000000B ; irql 1 (APC)
                dd      00000000000000000000000000000000B ; irql 2 (DISPATCH)
                dd      00000000000000000000000000000000B ; irql 3
                dd      11111111110000000000000000000000B ; irql 4
                dd      11111111111000000000000000000000B ; irql 5
                dd      11111111111100000000000000000000B ; irql 6
                dd      11111111111110000000000000000000B ; irql 7
                dd      11111111111111000000000000000000B ; irql 8
                dd      11111111111111100000000000000000B ; irql 9
                dd      11111111111111110000000000000000B ; irql 10
                dd      11111111111111111000000000000000B ; irql 11
                dd      11111111111111111100000000000000B ; irql 12
                dd      11111111111111111110000000000000B ; irql 13
                dd      11111111111111111110000000000000B ; irql 14
                dd      11111111111111111110100000000000B ; irql 15
                dd      11111111111111111110110000000000B ; irql 16
                dd      11111111111111111110111000000000B ; irql 17
                dd      11111111111111111110111000000000B ; irql 18
                dd      11111111111111111110111010000000B ; irql 19
                dd      11111111111111111110111011000000B ; irql 20
                dd      11111111111111111110111011100000B ; irql 21
                dd      11111111111111111110111011110000B ; irql 22
                dd      11111111111111111110111011111000B ; irql 23
                dd      11111111111111111110111011111000B ; irql 24
                dd      11111111111111111110111011111010B ; irql 25
                dd      11111111111111111110111111111010B ; irql 26 (PROFILE)
                dd      11111111111111111111111111111010B ; irql 27 (SCI)
                dd      11111111111111111111111111111011B ; irql 28 (CLOCK)
                dd      11111111111111111111111111111011B ; irql 29 (IPI)
                dd      11111111111111111111111111111011B ; irql 30 (POWER)
                dd      11111111111111111111111111111011B ; irql 31 (HIGH)

;
; This table is used to mask all pending interrupts below a given Irql
; out of the IRR
;
        align 4

        public FindHigherIrqlMask
FindHigherIrqlMask label dword
                dd    11111111111111111111111111111110B ; irql 0 (NORMAL)
                dd    11111111111111111111111111111100B ; irql 1 (APC)
                dd    11111111111111111111111111111000B ; irql 2 (DISPATCH)
                dd    11111111111111111111111111110000B ; irql 3
                dd    00000011111111111111111111110000B ; irql 4
                dd    00000001111111111111111111110000B ; irql 5
                dd    00000000111111111111111111110000B ; irql 6
                dd    00000000011111111111111111110000B ; irql 7
                dd    00000000001111111111111111110000B ; irql 8
                dd    00000000000111111111111111110000B ; irql 9
                dd    00000000000011111111111111110000B ; irql 10
                dd    00000000000001111111111111110000B ; irql 11
                dd    00000000000000111111111111110000B ; irql 12
                dd    00000000000000011111111111110000B ; irql 13
                dd    00000000000000011111111111110000B ; irql 14
                dd    00000000000000010111111111110000B ; irql 15
                dd    00000000000000010011111111110000B ; irql 16
                dd    00000000000000010001111111110000B ; irql 17
                dd    00000000000000010001111111110000B ; irql 18
                dd    00000000000000010001011111110000B ; irql 19
                dd    00000000000000010001001111110000B ; irql 20
                dd    00000000000000010001000111110000B ; irql 21
                dd    00000000000000010001000011110000B ; irql 22
                dd    00000000000000010001000001110000B ; irql 23
                dd    00000000000000010001000000110000B ; irql 24
                dd    00000000000000010001000000010000B ; irql 25
                dd    00000000000000010000000000010000B ; irql 26 (PROFILE)
                dd    00000000000000000000000000010000B ; irql 27 (SCI)
                dd    00000000000000000000000000000000B ; irql 28 (CLOCK)
                dd    00000000000000000000000000000000B ; irql 29 (IPI)
                dd    00000000000000000000000000000000B ; irql 30 (POWER)
                dd    00000000000000000000000000000000B ; irql 31 (HIGH)

_TEXT   ends

_DATA   SEGMENT DWORD PUBLIC 'DATA'

        align   4
;
; The following tables define the addresses of software interrupt routers
;

;
; Use this table if there is NO machine state frame on stack already
;

        public  SWInterruptHandlerTable
SWInterruptHandlerTable label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt           ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2     ; irql 2
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 3
        dd      offset FLAT:HalpHardwareInterrupt00     ; 8259 irq#0
        dd      offset FLAT:HalpHardwareInterrupt01     ; 8259 irq#1
        dd      offset FLAT:HalpHardwareInterrupt02     ; 8259 irq#2
        dd      offset FLAT:HalpHardwareInterrupt03     ; 8259 irq#3
        dd      offset FLAT:HalpHardwareInterrupt04     ; 8259 irq#4
        dd      offset FLAT:HalpHardwareInterrupt05     ; 8259 irq#5
        dd      offset FLAT:HalpHardwareInterrupt06     ; 8259 irq#6
        dd      offset FLAT:HalpHardwareInterrupt07     ; 8259 irq#7
        dd      offset FLAT:HalpHardwareInterrupt08     ; 8259 irq#8
        dd      offset FLAT:HalpHardwareInterrupt09     ; 8259 irq#9
        dd      offset FLAT:HalpHardwareInterrupt10     ; 8259 irq#10
        dd      offset FLAT:HalpHardwareInterrupt11     ; 8259 irq#11
        dd      offset FLAT:HalpHardwareInterrupt12     ; 8259 irq#12
        dd      offset FLAT:HalpHardwareInterrupt13     ; 8259 irq#13
        dd      offset FLAT:HalpHardwareInterrupt14     ; 8259 irq#14
        dd      offset FLAT:HalpHardwareInterrupt15     ; 8259 irq#15

_DATA   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

;
; Use this table if there is already a machine state frame on stack
;

        public  SWInterruptHandlerTable2
SWInterruptHandlerTable2 label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt2ndEntry   ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2ndEntry ; irql 2

;
; The following table picks up the highest pending software irq level
; from software irr
;

        public  SWInterruptLookUpTable
SWInterruptLookUpTable label byte
        db      0               ; SWIRR=0, so highest pending SW irql= 0
        db      0               ; SWIRR=1, so highest pending SW irql= 0
        db      1               ; SWIRR=2, so highest pending SW irql= 1
        db      1               ; SWIRR=3, so highest pending SW irql= 1
        db      2               ; SWIRR=4, so highest pending SW irql= 2
        db      2               ; SWIRR=5, so highest pending SW irql= 2
        db      2               ; SWIRR=6, so highest pending SW irql= 2
        db      2               ; SWIRR=7, so highest pending SW irql= 2

;++
;
; KIRQL
; KfRaiseIrql (
;    IN KIRQL NewIrql,
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to the specified value.
;    Also, a mask will be used to mask off all the lower lever 8259
;    interrupts.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be raised to
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicFastCall KfRaiseIrql,1
cPublicFpo 0, 0

        xor     eax, eax        ; Eliminate partial stall on return to caller
        mov     al, PCRB[PcIrql]         ; (al) = Old Irql
        mov     PCRB[PcIrql], cl         ; set new irql

if DBG
        cmp     al, cl                   ; old > new?
        ja      short Kri99              ; yes, go bugcheck

        fstRET  KfRaiseIrql

cPublicFpo 2, 2
Kri99:
        movzx   eax, al
        movzx   ecx, cl
        push    ecx                      ; put new irql where we can find it
        push    eax                      ; put old irql where we can find it
        mov     PCRB[PcIrql],0           ; avoid recursive error
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
endif
        fstRET  KfRaiseIrql

fstENDP KfRaiseIrql

;++
;
; KIRQL
; KeRaiseIrqlToDpcLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to DPC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToDpcLevel,0
cPublicFpo 0, 0

        xor     eax, eax                ; Eliminate partial stall
        mov     al, PCRB[PcIrql]        ; (al) = Old Irql
        mov     PCRB[PcIrql], DISPATCH_LEVEL    ; set new irql

if DBG
        cmp     al, DISPATCH_LEVEL      ; old > new?
        ja      short Krid99            ; yes, go bugcheck
endif

        stdRET  _KeRaiseIrqlToDpcLevel

if DBG
cPublicFpo 0,1
Krid99: movzx   eax, al
        push    eax                     ; put old irql where we can find it
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
        stdRET  _KeRaiseIrqlToDpcLevel
endif

stdENDP _KeRaiseIrqlToDpcLevel


;++
;
; KIRQL
; KeRaiseIrqlToSynchLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to SYNC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToSynchLevel,0
cPublicFpo 0, 0

        xor     eax, eax                ; Eliminate partial stall
        mov     al, PCRB[PcIrql]        ; (al) = Old Irql
        mov     PCRB[PcIrql], SYNCH_LEVEL       ; set new irql

if DBG
        cmp     al, SYNCH_LEVEL         ; old > new?
        ja      short Kris99            ; yes, go bugcheck
endif

        stdRET  _KeRaiseIrqlToSynchLevel

if DBG
cPublicFpo 0,1
Kris99: movzx   eax, al
        push    eax                     ; put old irql where we can find it
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
        stdRET  _KeRaiseIrqlToSynchLevel
endif

stdENDP _KeRaiseIrqlToSynchLevel

;++
;
; VOID
; KfLowerIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be set.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KfLowerIrql,1
cPublicFpo 0, 0
        and     ecx, 0ffh

if DBG
        cmp     cl,PCRB[PcIrql]         ; Make sure we are not lowering to
        ja      KliBug                  ; ABOVE current level
endif
        pushfd
        cli
        mov     PCR[PcIrql], ecx
        mov     edx, HalpIRR
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        jnz     short Kli10                     ; go dispatch pending interrupts

ifdef DEVKIT
        mov     eax, PCR[PcPrcbData+PbDebugHaltThread] ; find out if the
        test    eax,eax                         ; debugger wants to break into
        jnz     Kli20                           ; this thread
endif

;
; no interrupts pending, return quickly.
;

        popfd
        fstRET    KfLowerIrql

cPublicFpo 1, 1
align 4
Kli10:

;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Kli40

        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 1, 0
        fstRET    KfLowerIrql

Kli40:
;
; Clear all the interrupt masks
;

        mov     eax, HalpIDR
        SET_8259_MASK

        mov     edx, 1
        shl     edx, cl
        xor     HalpIRR, edx                    ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 1, 0
        fstRET    KfLowerIrql

if DBG
cPublicFpo 1, 2
KliBug:
        push    ecx                             ; new irql for debugging
        push    PCR[PcIrql]                     ; old irql for debugging
        mov     PCRB[PcIrql],HIGH_LEVEL         ; avoid recursive error
        stdCall   _KeBugCheck, <IRQL_NOT_LESS_OR_EQUAL>   ; never return
endif

ifdef DEVKIT
cPublicFpo 0, 0
Kli20:
        test    ecx,ecx                         ; only break if lowering to
        jne     Kli21                           ; PASSIVE_LEVEL
        call    eax                             ; find out whether to stop
        test    al, al
        je      short Kli21
        sti
        int     3h
Kli21:
        popfd
        fstRet    KfLowerIrql
endif

fstENDP KfLowerIrql

;++
;
; VOID
; FASTCALL
; HalEndSystemLevelInterrupt(
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine acknowledges the supplied level interrupt and then falls
;    into HalEndSystemInterrupt.
;
; Arguments:
;
;    eax - BusInterruptLevel
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+4 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalEndSystemLevelInterrupt  ,1

        cmp     eax, 8                      ; EOI to master or slave?
        jae     short Heil10

        or      al, PIC1_EOI_MASK           ; create specific eoi mask for master
        out     PIC1_PORT0, al              ; dismiss the interrupt
        jmp     @HalEndSystemInterrupt@4

align 4
Heil10:
        add     al, OCW2_SPECIFIC_EOI - 8   ; specific eoi to slave
        out     PIC2_PORT0, al

;
; fall into HalEndSystemInterrupt
;

;++
;
; VOID
; FASTCALL
; HalEndSystemInterrupt(
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+4 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalEndSystemInterrupt  ,1

        mov     edx, HalpIRR
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        mov     PCR[PcIrql], ecx
        jnz     Hei10                           ; go dispatch pending interrupts

;
; no interrupts pending, fall into Kei386EoiHelper
;

;++
;
;   Kei386EoiHelper
;
;   Routine Description:
;
;       This code is transfered to at the end of an interrupt.  (via the
;       exit_interrupt macro).  It checks for user APC dispatching and
;       performs the exit_all for the interrupt.
;
;       NOTE: This code is jumped to, not called.
;
;   Arguments:
;
;       (esp) -> base of trap frame.
;       interrupts are disabled
;
;   Return Value:
;
;       None.
;
;--
cPublicProc Kei386EoiHelper, 0
;.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)
        ASSERT_FS
        EXIT_ALL    ,,NoPreviousMode
stdENDP Kei386EoiHelper

align 4
Hei10:

;
; If there is any delayed hardware interrupt being serviced, we leave
; the interrupt masked and simply return.
;

        test    HalpIRRActive, IRQ_ACTIVE_MASK
        jnz     short Hei50

        bsr     ecx, edx                        ; (eax) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jle     short Hei40

;
; Clear all the interrupt masks
;

align 4
Hei15:
        mov     eax, HalpIDR
        SET_8259_MASK
;
; The pending interrupt is a hardware interrupt.  To prevent the delayed
; interrupts from overflowing stack, we check if the pending level is already
; active.  If yes, we simply return and let the higher level EndSystemInterrupt
; handle it.
;
; (ecx) = pending vector
;

        mov     edx, 1
        shl     edx, cl
        test    HalpIRRActive, edx              ; if the pending int is being
                                                ; processed, just return.
        jne     short Hei50
        or      HalpIRRActive, edx              ; Set Active bit
        xor     HalpIRR, edx                    ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Note, it destroys eax
        xor     HalpIRRActive, edx              ; Clear bit in ActiveIrql
        mov     eax, HalpIRR                    ; Reload IRR
        mov     ecx, PCR[PcIrql]
        and     eax, FindHigherIrqlMask[ecx*4]  ; Is any interrupt pending
        jz      short Hei50                     ; (Most time it will be zero.)
        bsr     ecx, eax                        ; (edx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Hei15

Hei40:

;
; The pending interrupt is at Software Level.  We simply make current
; interrupt frame the new pending software interrupt's frame and
; jmp to the handler routine.
;

        jmp     SWInterruptHandlerTable2[ecx*4] ; Note, it destroys eax

Hei50:
        jmp     Kei386EoiHelper@0

fstENDP HalEndSystemInterrupt

fstENDP HalEndSystemLevelInterrupt

;++
;
; VOID
; HalpEndSoftwareInterrupt
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL from software interrupt
;    leverl to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+8 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HesNewIrql      equ     [esp + 4]

cPublicProc _HalpEndSoftwareInterrupt  ,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HesNewIrql        ; get new irql value
        mov     edx, HalpIRR
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        mov     PCR[PcIrql], ecx
        jnz     short Hes10

        stdRET    _HalpEndSoftwareInterrupt

align 4
Hes10:
;
; Check if any delayed hardware interrupt is being serviced.  If yes, we
; simply return.
;

        test    HalpIRRActive, IRQ_ACTIVE_MASK
        jnz     short Hes90

;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Hes20

;
; Pending interrupt is a soft interrupt. Recycle stack frame
;

        add     esp, 8
        jmp     SWInterruptHandlerTable2[ecx*4] ; Note, it destroys eax

Hes20:
;
; Clear all the interrupt masks
;

        mov     eax, HalpIDR
        SET_8259_MASK

;
; (ecx) = Pending level
;

        mov     edx, 1
        shl     edx, cl

        or      HalpIRRActive, edx              ; Set Active bit
        xor     HalpIRR, edx                    ; clear bit in IRR

        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.

        xor     HalpIRRActive, edx              ; Clear bit in ActiveIrql

        movzx   ecx, byte ptr HesNewIrql        ; get new irql value
        mov     edx, HalpIRR
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        jnz     short Hes10

Hes90:  stdRET  _HalpEndSoftwareInterrupt

stdENDP _HalpEndSoftwareInterrupt

        page ,132
        subttl  "DispatchInterrupt 2"

;++
;
; VOID
; HalpDispatchInterrupt2(
;       VOID
;       );
;
; Routine Description:
;
;   The functional description is the same as HalpDispatchInterrupt.
;
;   This function differs from HalpDispatchInterrupt in how it has been
;   optimized.  This function is optimized for dispatching dispatch interrupts
;   for LowerIrql, ReleaseSpinLock, and RequestSoftwareInterrupt.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    (edx) = 1 shl DISPATCH_LEVEL
;
; Warnings:
;
;   Not all SW int handles this hal uses save all the registers
;   callers to SWInterruptHandler for H/W interrupts assume that
;   ONLY EAX & ECX are destroyed.
;
;   Note: this function saves EBX since KiDispatchInterrupt uses
;   the value without preserving it.
;--

cPublicProc _HalpDispatchInterrupt2
cPublicFpo 0, 2

        xor     ecx, ecx
        and     dword ptr HalpIRR, not (1 shl DISPATCH_LEVEL) ; clear the pending bit in IRR

        mov     cl, PCRB[PcIrql]

        mov     PCRB[PcIrql], DISPATCH_LEVEL    ; set new irql
        push    ecx                             ; Save OldIrql

;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;
        sti

        push    ebx
        stdCall _KiDispatchInterrupt            ; Handle DispatchInterrupt
        pop     ebx
        pop     ecx                             ; (ecx) = OldIrql
        mov     edx, 1 shl DISPATCH_LEVEL

        cli

        mov     eax, HalpIRR
        mov     PCR[PcIrql], ecx                ; restore current irql

        and     eax, FindHigherIrqlMask[ecx*4]  ; (eax) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.

        jnz     short diq10                     ; go dispatch pending interrupts
        stdRET  _HalpDispatchInterrupt2

diq10:
;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, eax                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jbe     short diq20

;
; Clear all the interrupt masks
;

        mov     eax, HalpIDR
        SET_8259_MASK

        mov     edx, 1
        shl     edx, cl
        xor     HalpIRR, edx                    ; clear bit in IRR

diq20:
;
; (ecx) = Pending level
;

        jmp     SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
diq90:  stdRET  _HalpDispatchInterrupt2

stdENDP _HalpDispatchInterrupt2

        page ,132
        subttl  "Get current irql"

;++
;
; KIRQL
; KeGetCurrentIrql (VOID)
;
; Routine Description:
;
;    This routine returns to current IRQL.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The current IRQL.
;
;--

cPublicProc _KeGetCurrentIrql   ,0
cPublicFpo 0, 0

        movzx   eax, PCRB[PcIrql]           ; Current irql is in the PCR
        stdRET    _KeGetCurrentIrql
stdENDP _KeGetCurrentIrql

        page ,132
        subttl  "Postponed Hardware Interrupt Dispatcher"
;++
;
; VOID
; HalpHardwareInterruptNN (
;       VOID
;       );
;
; Routine Description:
;
;    These routines branch through the IDT to simulate the appropriate
;    hardware interrupt.  They use the "INT nn" instruction to do this.
;
; Arguments:
;
;    None.
;
; Returns:
;
;    None.
;
; Environment:
;
;    IRET frame is on the stack
;
;--
cPublicProc _HalpHardwareInterruptTable, 0
cPublicFpo 0,0

        public HalpHardwareInterrupt00
HalpHardwareInterrupt00 label byte
        int     PRIMARY_VECTOR_BASE + 0
        ret

        public HalpHardwareInterrupt01
HalpHardwareInterrupt01 label byte
        int     PRIMARY_VECTOR_BASE + 1
        ret

        public HalpHardwareInterrupt02
HalpHardwareInterrupt02 label byte
        int     PRIMARY_VECTOR_BASE + 2
        ret

        public HalpHardwareInterrupt03
HalpHardwareInterrupt03 label byte
        int     PRIMARY_VECTOR_BASE + 3
        ret

        public HalpHardwareInterrupt04
HalpHardwareInterrupt04 label byte
        int     PRIMARY_VECTOR_BASE + 4
        ret

        public HalpHardwareInterrupt05
HalpHardwareInterrupt05 label byte
        int     PRIMARY_VECTOR_BASE + 5
        ret

        public HalpHardwareInterrupt06
HalpHardwareInterrupt06 label byte
        int     PRIMARY_VECTOR_BASE + 6
        ret

        public HalpHardwareInterrupt07
HalpHardwareInterrupt07 label byte
        int     PRIMARY_VECTOR_BASE + 7
        ret

        public HalpHardwareInterrupt08
HalpHardwareInterrupt08 label byte
        int     PRIMARY_VECTOR_BASE + 8
        ret

        public HalpHardwareInterrupt09
HalpHardwareInterrupt09 label byte
        int     PRIMARY_VECTOR_BASE + 9
        ret

        public HalpHardwareInterrupt10
HalpHardwareInterrupt10 label byte
        int     PRIMARY_VECTOR_BASE + 10
        ret

        public HalpHardwareInterrupt11
HalpHardwareInterrupt11 label byte
        int     PRIMARY_VECTOR_BASE + 11
        ret

        public HalpHardwareInterrupt12
HalpHardwareInterrupt12 label byte
        int     PRIMARY_VECTOR_BASE + 12
        ret

        public HalpHardwareInterrupt13
HalpHardwareInterrupt13 label byte
        int     PRIMARY_VECTOR_BASE + 13
        ret

        public HalpHardwareInterrupt14
HalpHardwareInterrupt14 label byte
        int     PRIMARY_VECTOR_BASE + 14
        ret

        public HalpHardwareInterrupt15
HalpHardwareInterrupt15 label byte
        int     PRIMARY_VECTOR_BASE + 15
        ret

stdENDP _HalpHardwareInterruptTable

        page ,132
        subttl  "Interrupt Controller Chip Initialization"
;++
;
; VOID
; HalpInitializePICs (
;    VOID
;    )
;
; Routine Description:
;
;    This routine sends the 8259 PIC initialization commands and
;    masks all the interrupts on 8259s.
;
; Arguments:
;
;    EnableInterrupts - If this is true, then this function will
;                       explicitly enable interrupts at the end,
;                       as it always did in the past.  If this
;                       is false, then it will preserve the interrupt
;                       flag.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalpInitializePICs       ,0
cPublicFpo 0, 0

        push    esi                             ; save caller's esi
        pushfd
        cli                                     ; disable interrupt

        lea     esi, PICsInitializationString
        lodsw                                   ; (AX) = PIC port 0 address
Hip10:  movzx   edx, ax
        outsb                                   ; output ICW1
        IODelay
        inc     edx                             ; (DX) = PIC port 1 address
        outsb                                   ; output ICW2
        IODelay
        outsb                                   ; output ICW3
        IODelay
        outsb                                   ; output ICW4
        IODelay
        mov     al, 0FFH                        ; mask all 8259 irqs
        out     dx,al                           ; write mask to PIC
        lodsw
        cmp     ax, 0                           ; end of init string?
        jne     short Hip10                     ; go init next PIC

        or      [esp], EFLAGS_INTERRUPT_MASK    ; enable interrupts
        popfd
        pop     esi                             ; restore caller's esi
        stdRET    _HalpInitializePICs
stdENDP _HalpInitializePICs

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixreboot.c ===
/*++

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    ixreboot.c

Abstract:

    Provides the interface to the firmware for x86.  Since there is no
    firmware to speak of on x86, this is just reboot support.

--*/

#include "halp.h"

VOID
IdexChannelPrepareToQuickRebootSystem(
    VOID
    );

#define RESET_CONTROL_REGISTER          0xCF9

#define RESET_CONTROL_FULL_RESET        0x08
#define RESET_CONTROL_RESET_CPU         0x04
#define RESET_CONTROL_SYSTEM_RESET      0x02

//
// Linked list of routines to invoke on shutdown.
//
INITIALIZED_LIST_ENTRY(HalpShutdownRegistrationList);

//
// Private function prototypes
//

DECLSPEC_NORETURN
VOID
HalpReboot (
    VOID
    )
/*++

Routine Description:

    This procedure resets the system.

    N.B.

        Will NOT return.

--*/
{
    //
    // If we can safely use the SMBus helpers, then have the SMC do a full
    // reset.
    //

    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_RESET, SMC_RESET_ASSERT_RESET);
    }

    //
    // Poke the south bridge to do a full PCI reset.
    //

    _outp(RESET_CONTROL_REGISTER, RESET_CONTROL_FULL_RESET |
        RESET_CONTROL_RESET_CPU | RESET_CONTROL_SYSTEM_RESET);

    HalHaltSystem();
}

VOID
HalHaltSystem (
    VOID
    )
/*++

Routine Description:

    This procedure is called when the machine has crashed and is to be halted.

    N.B.

        Will NOT return.

--*/
{
    for (;;) {
        __asm {
            cli
            hlt
        }
    }
}

VOID
HalReturnToFirmware(
    IN FIRMWARE_REENTRY Routine
    )
/*++

Routine Description:

    Returns control to the firmware routine specified.  Since the x86 has
    no useful firmware, it just stops the system.

Arguments:

    Routine - Supplies a value indicating which firmware routine to invoke.

Return Value:

    Does not return.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ListEntry;
    PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration;

    if (Routine != HalQuickRebootRoutine) {

        //
        // If we're asked to reboot in order to display the univeral error
        // message, then set a flag in the SMC scratch register so that we
        // immediately display the message when the kernel boots again.
        //

        if (Routine == HalFatalErrorRebootRoutine) {
            HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_SCRATCH,
                SMC_SCRATCH_DISPLAY_FATAL_ERROR);
        }

#ifdef DEVKIT
        //
        // Notify the debugger that we're shutting down, but only if this wasn't
        // initiated by the kernel debugger.  The kernel debugger has already
        // detached from the kernel and making the following call only causes
        // the debugger to temporarily connect and disconnect again.
        //

        if (Routine != HalKdRebootRoutine) {
            DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);
        }
#endif

        //
        // Never returns.
        //

        HalpReboot();
    }

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Call out to any registered shutdown routines.
    //

    for (;;) {

        //
        // Synchronize access to the registration list by raising to
        // DISPATCH_LEVEL.
        //

        OldIrql = KeRaiseIrqlToDpcLevel();

        ListEntry = RemoveHeadList(&HalpShutdownRegistrationList);

        KeLowerIrql(OldIrql);

        //
        // If there are no more entries, break out.
        //

        if (ListEntry == &HalpShutdownRegistrationList) {
            break;
        }

        //
        // Invoke the notification procedure.
        //

        ShutdownRegistration = CONTAINING_RECORD(ListEntry,
            HAL_SHUTDOWN_REGISTRATION, ListEntry);
        ShutdownRegistration->NotificationRoutine(ShutdownRegistration);
    }

#if DBG
    //
    // Notify the IDE driver that we're about to quick reboot the system.  The
    // driver will verify that no requests are pending and that all further
    // requests will assert.
    //

    IdexChannelPrepareToQuickRebootSystem();
#endif

#ifdef DEVKIT
    //
    // When running with the kernel debugger, it can take a number of cycles for
    // the debugger to shutdown and to restart in the next instance of the
    // kernel.  When ejecting the tray from DVD video playback, the dashboard
    // will quick reboot into another instance of the dashboard.  Because the
    // system is blocked most of this time inside the debugger, the system can't
    // handle the "tray open" interrupt and the system reboots.  To workaround
    // this problem, we'll block until the tray eject is complete.
    //

    if (KdDebuggerEnabled && !KdDebuggerNotPresent) {
        KeWaitForSingleObject(&HalpTrayEjectCompleteEvent, Executive, KernelMode,
            FALSE, NULL);
    }

    //
    // Notify the debugger that we're quick rebooting.
    //

    DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);

    //
    // Delete all breakpoints so that we don't hit any lingering breakpoints in
    // the next instance of the kernel.
    //

    KdDeleteAllBreakpoints();
#endif

    //
    // Never returns.
    //

    KeQuickRebootSystem();
}

VOID
HalRegisterShutdownNotification(
    IN PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration,
    IN BOOLEAN Register
    )
/*++

Routine Description:

    This routine registers or unregisters the supplied record with the list of
    routines that should be called when the system is rebooting.

Arguments:

    ShutdownRegistration - Specifies the record to register or unregister.

    Register - Specifies whether or not to register or unregister the record.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ListEntry;

    //
    // Guard access to the shutdown registration lists by raising to
    // DISPATCH_LEVEL.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    if (Register) {

        //
        // Insert the registration record into the list in order of the
        // specified priority.
        //

        ListEntry = HalpShutdownRegistrationList.Flink;

        while (ListEntry != &HalpShutdownRegistrationList) {

            if (ShutdownRegistration->Priority > CONTAINING_RECORD(ListEntry,
                HAL_SHUTDOWN_REGISTRATION, ListEntry)->Priority) {
                InsertTailList(ListEntry, &ShutdownRegistration->ListEntry);
                break;
            }

            ListEntry = ListEntry->Flink;
        }

        if (ListEntry == &HalpShutdownRegistrationList) {
            InsertTailList(ListEntry, &ShutdownRegistration->ListEntry);
        }

    } else {

        //
        // Carefully remove the registration record by making sure that it's
        // already in the list.  If somebody else already started shutting down
        // the system, then the registration may have already been removed.
        //

        ListEntry = HalpShutdownRegistrationList.Flink;

        while (ListEntry != &HalpShutdownRegistrationList) {

            if (ShutdownRegistration == CONTAINING_RECORD(ListEntry,
                HAL_SHUTDOWN_REGISTRATION, ListEntry)) {
                RemoveEntryList(&ShutdownRegistration->ListEntry);
                break;
            }

            ListEntry = ListEntry->Flink;
        }
    }

    KeLowerIrql(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixswint.asm ===
title   "Software Interrupts"

;++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    ixswint.asm
;
; Abstract:
;
;    This module implements the software interrupt handlers
;    for x86 machines
;
; Author:
;
;    John Vert (jvert) 2-Jan-1992
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list

        EXTRNP  _KiDeliverApc,0
        EXTRNP  _KiDispatchInterrupt,0
        EXTRNP  Kei386EoiHelper,0
        extrn   SWInterruptHandlerTable:dword
        extrn   SWInterruptLookUpTable:byte
        extrn   HalpIRR:dword
        extrn   _KiPCR:DWORD

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Request Software Interrupt"

;++
;
; VOID
; HalRequestSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;    This routine is used to request a software interrupt to the
;    system. Also, this routine checks to see if any software
;    interrupt should be generated.
;    The following condition will cause software interrupt to
;    be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalRequestSoftwareInterrupt ,1
cPublicFpo 0, 1

        mov     eax,1
        shl     eax, cl                 ; convert to mask
        pushfd                          ; save interrupt mode
        cli                             ; disable interrupt
        or      HalpIRR, eax            ; set the request bit
        mov     cl, PCRB[PcIrql]        ; get current IRQL

        mov     eax, HalpIRR            ; get SW interrupt request register
        and     eax, 3                  ; mask off pending HW interrupts

        xor     edx, edx
        mov     dl, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     dl, cl                  ; Is highest SW int level > irql?
        jbe     short KsiExit           ; No, jmp ksiexit
        call    SWInterruptHandlerTable[edx*4] ; yes, simulate interrupt
                                        ; to the appropriate handler
KsiExit:
        popfd                           ; restore original interrupt mode
        fstRET  HalRequestSoftwareInterrupt

fstENDP HalRequestSoftwareInterrupt

        page ,132
        subttl  "Request Software Interrupt"

;++
;
; VOID
; HalClearSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;   This routine is used to clear a possible pending software interrupt.
;   Support for this function is optional, and allows the kernel to
;   reduce the number of spurious software interrupts it receives/
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalClearSoftwareInterrupt ,1
cPublicFpo 0, 0

        mov     eax,1
        shl     eax, cl                 ; convert to mask

        not     eax
        and     HalpIRR, eax            ; clear pending irr bit

        fstRET  HalClearSoftwareInterrupt

fstENDP HalClearSoftwareInterrupt



        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; VOID
; HalpDispatchInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is the interrupt handler for a software interrupt generated
;    at DISPATCH_LEVEL.  Its function is to save the machine state, raise
;    Irql to DISPATCH_LEVEL, dismiss the interrupt, and call the DPC
;    delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--

        align dword
        public _HalpDispatchInterrupt
_HalpDispatchInterrupt proc

;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax

;
; Save machine state on trap frame
;

        ENTER_INTERRUPT
.FPO ( FPO_LOCALS+1, 0, 0, 0, 0, FPO_TRAPFRAME )

        public  _HalpDispatchInterrupt2ndEntry
_HalpDispatchInterrupt2ndEntry:

; Save previous IRQL and set new priority level

        push    PCR[PcIrql]                       ; save previous IRQL
        mov     byte ptr PCR[PcIrql], DISPATCH_LEVEL; set new irql
        and     dword ptr HalpIRR, not (1 shl DISPATCH_LEVEL) ; clear the pending bit in IRR

;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;

        sti

;
; Go do Dispatch Interrupt processing
;
        stdCall   _KiDispatchInterrupt

;
; Do interrupt exit processing
;

        SOFT_INTERRUPT_EXIT                          ; will do an iret

_HalpDispatchInterrupt endp

        page ,132
        subttl  "APC Interrupt"
;++
;
; HalpApcInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at APC_LEVEL. Its function is to save the machine state, raise Irql to
;    APC_LEVEL, dismiss the interrupt, and call the APC delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is Disabled
;
; Return Value:
;
;    None.
;
;--

        align dword
        public _HalpApcInterrupt
_HalpApcInterrupt proc

;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax

;
; Save machine state in trap frame
;
        ENTER_INTERRUPT
.FPO ( FPO_LOCALS+1, 0, 0, 0, 0, FPO_TRAPFRAME )


        public     _HalpApcInterrupt2ndEntry
_HalpApcInterrupt2ndEntry:

;
; Save previous IRQL and set new priority level
;

        push    PCR[PcIrql]                 ; save previous Irql
        mov     PCRB[PcIrql], APC_LEVEL     ; set new Irql
        and     dword ptr HalpIRR, not (1 shl APC_LEVEL) ; dismiss pending APC
;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;

        sti

;
; call the APC delivery routine.
;

        stdCall   _KiDeliverApc

;
;
; Do interrupt exit processing
;

        SOFT_INTERRUPT_EXIT                  ; will do an iret

_HalpApcInterrupt       endp

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixstall.asm ===
title  "Stall Execution Support"
;++
;
; Copyright (c) 1989-2001  Microsoft Corporation
;
; Module Name:
;
;    ixstall.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Environment:
;
;    Kernel mode only.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0

;
; Constants used to initialize CMOS/Real Time Clock
;

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate

;
; RegisterAInitByte sets 8Hz clock rate, used during init to set up
; KeStallExecutionProcessor, etc.  (See RegASystemClockByte below.)
;

RegisterAInitByte       EQU     00101101B ; RT/CMOS Register 'A' init byte
                                        ; 32.768KHz Base divider rate
                                        ;  8Hz int rate, period = 125.0ms
PeriodInMicroSecond     EQU     125000  ;

STICKY  SEGMENT  DWORD PUBLIC 'DATA'

;
; Initialize the stall scale factor to the number required for the 733Mhz
; processor in the console.  This number can be calculated by running the
; HalpInitializeStallExecution routine from xxhal.c.
;

        public  _HalpStallScaleFactor
_HalpStallScaleFactor   dd      016Fh

STICKY  ends

INIT    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Real Time Clock"
;++
;
; VOID
; HalpInitializeRealTimeClock(
;    VOID
;    )
;
; Routine Description:
;
;    This function initializes the real time clock to a known state.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalpInitializeRealTimeClock, 0

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalpInitializeRealTimeClock

stdENDP _HalpInitializeRealTimeClock

INIT    ends

IFDEF NOT_NEEDED

INIT    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Stall Execution Counter"
;++
;
; VOID
; HalpInitializeStallExecution (
;    VOID
;    )
;
; Routine Description:
;
;    This routine initialize the per Microsecond counter for
;    KeStallExecutionProcessor
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
; Note:
;
;    Current implementation assumes that all the processors share
;    the same Real Time Clock.  So, the dispatcher database lock is
;    acquired before entering this routine to guarantee only one
;    processor can access the routine.
;
;--

KiseInterruptCount      equ     [ebp-12] ; local variable

cPublicProc _HalpInitializeStallExecution     ,0

        push    ebp                     ; save ebp
        mov     ebp, esp                ; set up 12 bytes for local use
        sub     esp, 12

        pushfd                          ; save caller's eflag

;
; Initialize Real Time Clock to interrupt us for every 125ms at
; IRQ 8.
;

        cli                             ; make sure interrupts are disabled

;
; Get and save current 8259 masks
;

        xor     eax,eax

;
; Assume there is no third and fourth PICs
;
; Get interrupt Mask on PIC2
;

        in      al,PIC2_PORT1
        shl     eax, 8

;
; Get interrupt Mask on PIC1
;

        in      al,PIC1_PORT1
        push    eax                     ; save the masks
        mov     eax, NOT (( 1 SHL PIC_SLAVE_IRQ) + (1 SHL RTCIRQ))
                                        ; Mask all the irqs except irq 2 and 8
        SET_8259_MASK                   ; Set 8259's int mask register

;
; Since RTC interrupt will come from IRQ 8, we need to
; Save original irq 8 descriptor and set the descriptor to point to
; our own handler.
;

        sidt    fword ptr [ebp-8]       ; get IDT address
        mov     ecx, [ebp-6]            ; (ecx)->IDT

        mov     eax, (RTCIRQ+PRIMARY_VECTOR_BASE)

        shl     eax, 3                  ; 8 bytes per IDT entry
        add     ecx, eax                ; now at the correct IDT RTC entry

        push    dword ptr [ecx]         ; (TOS) = original desc of IRQ 8
        push    dword ptr [ecx + 4]     ; each descriptor has 8 bytes

        ;
        ; Pushing the appropriate entry address now (instead of
        ; the IDT start address later) to make the pop at the end simpler.
        ;
        push    ecx                     ; (TOS) -> &IDT[HalProfileVector]

        mov     eax, offset FLAT:RealTimeClockHandler

        mov     word ptr [ecx], ax              ; Lower half of handler addr
        mov     word ptr [ecx+2], KGDT_R0_CODE  ; set up selector
        mov     word ptr [ecx+4], D_INT032      ; 386 interrupt gate

        shr     eax, 16                 ; (ax)=higher half of handler addr
        mov     word ptr [ecx+6], ax

        mov     dword ptr KiseinterruptCount, 0 ; set no interrupt yet

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize
        mov     dword ptr [KiseInterruptCount], 0

        stdCall   _HalpReleaseCmosSpinLock

;
; Now enable the interrupt and start the counter
; (As a matter of fact, only IRQ8 can come through.)
;
        xor     eax, eax                ; (eax) = 0, initialize loopcount
ALIGN 16
        sti
        jmp     kise10

ALIGN 16
kise10:
        sub     eax, 1                  ; increment the loopcount
        jnz     short kise10

if DBG
;
; Counter overflowed
;

        stdCall   _DbgBreakPoint
endif
        jmp     short kise10

;
; Our RealTimeClock interrupt handler.  The control comes here through
; irq 8.
; Note: we discard first real time clock interrupt and compute the
;       permicrosecond loopcount on receiving of the second real time
;       interrupt.  This is because the first interrupt is generated
;       based on the previous real time tick interval.
;

RealTimeClockHandler:

        inc     dword ptr KiseInterruptCount ; increment interrupt count
        cmp     dword ptr KiseInterruptCount,1 ; Is this the first interrupt?
        jnz     short kise25            ; no, its the second go process it
        pop     eax                     ; get rid of original ret addr
        push    offset FLAT:kise10      ; set new return addr


        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock
;
; Dismiss the interrupt.
;
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

        xor     eax, eax                ; reset loop counter

        iretd

kise25:

;
; ** temporary - check for incorrect KeStallExecutionProcessorLoopCount
;

if DBG
        cmp     eax, 0
        jnz     short kise30
        stdCall   _DbgBreakPoint

endif
                                         ; never return
;
; ** End temporay code
;

kise30:
        neg     eax
        xor     edx, edx                ; (edx:eax) = divident
        mov     ecx, PeriodInMicroSecond; (ecx) = time spent in the loop
        div     ecx                     ; (eax) = loop count per microsecond
        cmp     edx, 0                  ; Is remainder =0?
        jz      short kise40            ; yes, go kise40
        inc     eax                     ; increment loopcount by 1
kise40:
        mov     _HalpStallScaleFactor, eax

;
; Reset return address to kexit
;

        pop     eax                     ; discard original return address
        push    offset FLAT:kexit       ; return to kexit
        mov     eax, (HIGHEST_LEVEL_FOR_8259 - RTCIRQ)

;
; Shutdown periodic interrupt
;
        stdCall   _HalpAcquireCmosSpinLock
        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; dismiss pending interrupt
        stdCall   _HalpReleaseCmosSpinLock

;
; Dismiss the interrupt.
;
        mov     eax, RTCIRQ
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

        and     word ptr [esp+8], NOT 0200H ; Disable interrupt upon return
        iretd

kexit:                                  ; Interrupts are disabled
        pop     ecx                     ; (ecx) -> &IDT[HalProfileVector]
        pop     [ecx+4]                 ; restore higher half of RTC desc
        pop     [ecx]                   ; restore lower half of RTC desc

        pop     eax                     ; (eax) = origianl 8259 int masks
        SET_8259_MASK

        popfd                           ; restore caller's eflags
        mov     esp, ebp
        pop     ebp                     ; restore ebp
        stdRET    _HalpInitializeStallExecution

stdENDP _HalpInitializeStallExecution

INIT   ends

ENDIF

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Stall Execution"
;++
;
; VOID
; KeStallExecutionProcessor (
;    IN ULONG MicroSeconds
;    )
;
; Routine Description:
;
;    This function stalls execution for the specified number of microseconds.
;    KeStallExecutionProcessor
;
; Arguments:
;
;    MicroSeconds - Supplies the number of microseconds that execution is to be
;        stalled.
;
; Return Value:
;
;    None.
;
;--

MicroSeconds equ [esp + 4]

cPublicProc _KeStallExecutionProcessor       ,1
cPublicFpo 1, 0

;
; Issue a CPUID to implement a "fence"
;
        push    ebx                             ; cpuid uses eax, ebx, ecx, edx
        xor     eax, eax                        ; Processor zero
    .586p
        cpuid
    .386p
        pop     ebx

        mov     ecx, MicroSeconds               ; (ecx) = Microseconds
        jecxz   short kese10                    ; return if no loop needed

        mov     eax, _HalpStallScaleFactor      ; get per microsecond
                                                ; loop count for the processor
        mul     ecx                             ; (eax) = desired loop count

if   DBG
;
; Make sure we the loopcount is less than 4G and is not equal to zero
;

        cmp     edx, 0
        jz      short @f
        int 3

@@:     cmp     eax,0
        jnz     short @f
        int 3
@@:
endif
ALIGN 16
        jmp     kese05

ALIGN 16
kese05: sub     eax, 1                          ; (eax) = (eax) - 1
        jnz     short kese05
kese10:
        stdRET    _KeStallExecutionProcessor

stdENDP _KeStallExecutionProcessor

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixsysbus.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixsysbus.c

Abstract:

--*/

#include "halp.h"

ULONG
HalGetInterruptVector(
    IN ULONG BusInterruptLevel,
    OUT PKIRQL Irql
    )

/*++

Routine Description:

Arguments:

    BusInterruptLevel - Supplies the bus specific interrupt level.

    Irql - Returns the system request priority.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    ULONG SystemVector;

    SystemVector = BusInterruptLevel + PRIMARY_VECTOR_BASE;

    if ((SystemVector < PRIMARY_VECTOR_BASE) ||
        (SystemVector > PRIMARY_VECTOR_BASE + HIGHEST_LEVEL_FOR_8259) ) {

        //
        // This is an illegal BusInterruptLevel and cannot be connected.
        //

        return(0);
    }

    *Irql = (KIRQL)(HIGHEST_LEVEL_FOR_8259 + PRIMARY_VECTOR_BASE - SystemVector);

    return SystemVector;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\ixsysint.asm ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixsysint.asm
;
;Abstract:
;
;    This module implements the HAL routines to enable/disable system
;    interrupts.
;
;Author:
;
;    John Vert (jvert) 22-Jul-1991
;
;Environment:
;
;    Kernel Mode
;
;Revision History:
;
;--


.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list

        extrn   KiI8259MaskTable:DWORD
        extrn   _KiPCR:DWORD
        EXTRNP  Kei386EoiHelper

_DATA   SEGMENT DWORD PUBLIC 'DATA'

align   dword

;
; Interrupt 