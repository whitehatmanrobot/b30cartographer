\\%s"),
                    MEMDB_CATEGORY_NT_CHECK_FILES,
                    srcName,
                    destName
                    );
                MemDbSetValue (key, 0);
            } while (MemDbEnumNextValue (&enumFiles));
        }
    }
    __finally {
        FreeText (key);
        FreeText (dirName);
        FreeText (priorStr);
        FreeText (destName);
        FreeText (srcName);
    }
}

VOID
pPrintHeaderFileFromCategory (
    IN      HANDLE fileHandle,
    IN      PCTSTR Category
    )
{
    MEMDB_ENUM enumFiles, e1;
    PSTR key;
    PCSTR dirName;
    PSTR filePtr1 = NULL, filePtr2=NULL;
    PSTR tempStr;
    PSTR string;
    PSTR string1;
    PSTR stringPtr, stringPtr1;
    DWORD dontCare;
    PSTR destName;
    PSTR srcName;
    PSTR infName;

    __try {

        key = AllocText (MEMDB_MAX);
        tempStr = AllocText (MAX_MBCHAR_PATH);
        string = AllocText (MAX_MBCHAR_PATH);
        string1 = AllocText (MEMDB_MAX);
        destName = AllocText (MEMDB_MAX);
        srcName = AllocText (MEMDB_MAX);
        infName = AllocText (MEMDB_MAX);

        if (!key || !tempStr || !string || !string1 || !destName || !srcName || !infName) {
            __leave;
        }

        MemDbBuildKey (key, Category, TEXT("*"), NULL, NULL);

        if (MemDbEnumFirstValue (
                &enumFiles,
                key,
                MEMDB_ALL_SUBLEVELS,
                MEMDB_ENDPOINTS_ONLY
                )) {
            do {
                filePtr2 = enumFiles.szName;

                //let's skip priority number

                filePtr1 = _mbschr (filePtr2, '\\');
                if (filePtr1 == NULL) {
                    DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles.szName));
                    continue;
                }

                filePtr1 = _mbsinc (filePtr1);

                filePtr2 = _mbschr (filePtr1, '\\');
                if (filePtr2 == NULL) {
                    DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles.szName));
                    continue;
                }

                StringCopyAB (destName, filePtr1, filePtr2);

                filePtr1 = _mbsinc (filePtr2);

                filePtr2 = _mbschr (filePtr1, '\\');
                if (filePtr2 == NULL) {
                    DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles.szName));
                    continue;
                }

                StringCopyAB (srcName, filePtr1, filePtr2);

                filePtr1 = _mbsinc (filePtr2);

                filePtr2 = _mbschr (filePtr1, '\\');
                if (filePtr2 == NULL) {
                    DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles.szName));
                    continue;
                }

                StringCopyAB (infName, filePtr1, filePtr2);

                //
                // Now let's try to fix the infName if possible
                //
                MemDbBuildKey (key, MEMDB_CATEGORY_NT_CHECK_FILES, infName, TEXT("*"), NULL);
                if (MemDbEnumFirstValue (&e1, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
                    StringCopy (infName, e1.szName);
                }

                dirName = _mbsinc (filePtr2);

                if (CountInstancesOfSubString (dirName, "%Platform%")) {
                    INFCONTEXT context;
                    GROWBUFFER platforms = GROWBUF_INIT;
                    UINT index;
                    CHAR field [MAX_MBCHAR_PATH];
                    MULTISZ_ENUMA platformsEnum;
                    PCSTR newDir = NULL;

                    if (SetupFindFirstLine (g_AddnlInf, TEXT("FILELIST.MULTIPLEPLATFORMS"), g_Platform, &context)) {
                        index = 1;
                        while (SetupGetStringField (&context, index, field, MAX_MBCHAR_PATH, NULL)) {
                            MultiSzAppend (&platforms, field);
                            index++;
                        }
                    } else {
                        MultiSzAppend (&platforms, g_Platform);
                    }
                    if (EnumFirstMultiSz (&platformsEnum, platforms.Buf)) {
                        do {
                            newDir = StringSearchAndReplace (dirName, "%Platform%", platformsEnum.CurrentString);

                            if (StringIMatch (destName, srcName)) {
                                StringCopy (string, "    {NULL, ");
                            } else {
                                sprintf (string, "    {L\"%s\", ", srcName);
                            }

                            sprintf (tempStr, "L\"%s\\%s\", ", newDir, destName);
                            StringCat (string, tempStr);

                            if (StringIMatch (infName, "LAYOUT.INF") ||
                                StringIMatch (infName, "LAYOUT.INF")
                                ) {
                                StringCopy (tempStr, "NULL},\r\n");
                            } else {
                                sprintf (tempStr, "L\"%s\"},\r\n", infName);
                            }

                            StringCat (string, tempStr);

                            stringPtr = string;
                            stringPtr1= string1;
                            while (*stringPtr) {
                                if (*stringPtr == '\\') {
                                    *stringPtr1 = *stringPtr;
                                    stringPtr1++;
                                }
                                *stringPtr1 = *stringPtr;
                                if (IsLeadByte (*stringPtr)) {
                                    stringPtr ++;
                                    stringPtr1 ++;
                                    *stringPtr1 = *stringPtr;
                                }
                                stringPtr ++;
                                stringPtr1 ++;
                            }
                            *stringPtr1 = 0;
                            WriteFile (fileHandle, string1, GetEndOfStringA (string1) - string1, &dontCare, NULL);
                            FreePathString (newDir);
                        } while (EnumNextMultiSz (&platformsEnum));
                    }
                } else {

                    if (StringIMatch (destName, srcName)) {
                        StringCopy (string, "    {NULL, ");
                    } else {
                        sprintf (string, "    {L\"%s\", ", srcName);
                    }

                    sprintf (tempStr, "L\"%s\\%s\", ", dirName, destName);
                    StringCat (string, tempStr);

                    if (StringIMatch (infName, "LAYOUT.INF") ||
                        StringIMatch (infName, "LAYOUT.INF")
                        ) {
                        StringCopy (tempStr, "NULL},\r\n");
                    } else {
                        sprintf (tempStr, "L\"%s\"},\r\n", infName);
                    }

                    StringCat (string, tempStr);

                    stringPtr = string;
                    stringPtr1= string1;
                    while (*stringPtr) {
                        if (*stringPtr == '\\') {
                            *stringPtr1 = *stringPtr;
                            stringPtr1++;
                        }
                        *stringPtr1 = *stringPtr;
                        if (IsLeadByte (*stringPtr)) {
                            stringPtr ++;
                            stringPtr1 ++;
                            *stringPtr1 = *stringPtr;
                        }
                        stringPtr ++;
                        stringPtr1 ++;
                    }
                    *stringPtr1 = 0;
                    WriteFile (fileHandle, string1, GetEndOfStringA (string1) - string1, &dontCare, NULL);
                }
            } while (MemDbEnumNextValue (&enumFiles));
        }
    }
    __finally {
        FreeText (key);
        FreeText (tempStr);
        FreeText (string);
        FreeText (string1);
        FreeText (destName);
        FreeText (srcName);
        FreeText (infName);
    }
}

VOID
pPrintHeaderFile (
    VOID
    )
{
    HANDLE fileHandle;
    CHAR string [MAX_PATH];
    DWORD dontCare;

    printf ("Writing %s...", g_HeaderFile);

    fileHandle = CreateFile (g_HeaderFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fileHandle == INVALID_HANDLE_VALUE) {
        return;
    }

    StringCopyA (string, "PROTECT_FILE_ENTRY ");
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);

    StringCopyA (string, g_StructName);
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);

    StringCopyA (string, "[] =\r\n");
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);

    StringCopyA (string, "{\r\n");
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);

    pBuildHeaderFilesCategory ();
    pPrintHeaderFileFromCategory (fileHandle, MEMDB_CATEGORY_NT_HEADER_FILES);

    StringCopyA (string, "};\r\n\r\n");
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);
    StringCopyA (string, "#define Count");
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);
    StringCopyA (string, g_StructName);
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);
    StringCopyA (string, " (sizeof(");
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);
    StringCopyA (string, g_StructName);
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);
    StringCopyA (string, ")/sizeof(");
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);
    StringCopyA (string, g_StructName);
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);
    StringCopyA (string, "[0]))\r\n\r\n");
    WriteFile (fileHandle, string, GetEndOfStringA (string) - string, &dontCare, NULL);

    CloseHandle (fileHandle);

    printf ("done\n");
}

BOOL
pGetProperLayoutInf (
    VOID
    )
{
    DWORD index = 0;
    PCTSTR layoutInfName = NULL;
    PCTSTR partialName = NULL;
    INFCONTEXT context;
    TCHAR productInfDir [MAX_PATH];
    TCHAR UncompressedFile[MAX_PATH];

    if (!SetupFindFirstLine (g_AddnlInf, TEXT("FILELIST.PRODUCTS"), g_Product, &context)) {
        return FALSE;
    }
    if (!SetupGetStringField (&context, 1, productInfDir, MAX_TCHAR_PATH, NULL)) {
        return FALSE;
    }

    partialName = JoinPaths (productInfDir, TEXT("layout.inf"));

    while (index < g_SourceDirectoryCount) {

        layoutInfName = JoinPaths (g_SourceDirectories [index], partialName);
        if (DoesFileExist (layoutInfName)) {
            //
            // copy the file to temporary directory
            //
            StringCopy (UncompressedFile, g_TempDir);
            StringCopy (AppendWack (UncompressedFile), TEXT("layout.inf"));
            CopyFile (layoutInfName, UncompressedFile, FALSE);
        }
        index ++;
    }

    FreePathString (partialName);

    return TRUE;
}

DWORD
pComputeChecksum (
    PCTSTR FullPath
    )
{
    HANDLE File;
    HANDLE Map;
    PBYTE Data;
    UINT Size;
    UINT u;
    DWORD Checksum = 0;

    Data = MapFileIntoMemory (FullPath, &File, &Map);
    if (!Data) {
        return 0xFFFFFFFF;
    }

    Size = GetFileSize (File, NULL);

    for (u = 0 ; u < Size ; u++) {
        Checksum = _rotl (Checksum, 3);
        Checksum ^= Data[u];
    }

    UnmapFile (Data, Map, File);

    return Checksum;
}


VOID
pDumpFileListDat (
    IN      PCSTR DatFile
    )
{
    HANDLE datHandle;
    PDWORD versionPtr;
    DWORD dontCare;
    BOOL error = TRUE;
    HANDLE datMapping;
    PCSTR p;

    if (!DatFile) {
        fprintf (stderr, "No output file to dump.\n");
        return;
    }

    versionPtr = (PDWORD) MapFileIntoMemory (DatFile, &datHandle, &datMapping);

    if (!versionPtr) {
        fprintf (stderr, "Can't open %s. Error=%u (0x%08X).\n", DatFile, GetLastError(), GetLastError());
        return;
    }

    __try {
        __try {
            if (*versionPtr == 0 || *versionPtr > 3) {
                fprintf (stderr, "Unsupported file format: %s\n", DatFile);
                __leave;
            }

            printf ("Version: %u\n\n", *versionPtr);

            //
            // Version 1: Dump out the normal files
            //

            p = (PCSTR) (&versionPtr[1]);
            if (*p) {
                printf ("Files:\n");

                do {
                    printf ("    %s", p);
                    p = GetEndOfString (p) + 1;

                    printf ("\\%s\n", p);
                    p = GetEndOfString (p) + 1;
                } while (*p);

                printf ("\n");
            } else {
                printf ("No files to list.\n");
            }

            p++;

            //
            // Version 2: Dump out the excluded files
            //

            if (*versionPtr >= 2 && *p) {
                printf ("Excluded Files:\n");

                do {
                    printf ("    %s", p);
                    p = GetEndOfString (p) + 1;

                    printf ("\\%s\n", p);
                    p = GetEndOfString (p) + 1;
                } while (*p);

                printf ("\n");
            } else {
                printf ("No excluded files to list.\n");
            }

            p++;

            //
            // Version 3: Dump out the deleted files
            //

            if (*versionPtr >= 3 && *p) {
                printf ("Deleted Files:\n");

                do {
                    printf ("    %s", p);
                    p = GetEndOfString (p) + 1;

                    printf ("\\%s\n", p);
                    p = GetEndOfString (p) + 1;
                } while (*p);

                printf ("\n");
            } else {
                printf ("No deleted files to list.\n");
            }

            error = FALSE;
        }
        __except (TRUE) {
            fprintf (stderr, "Invalid file format: %s\n", DatFile);
        }
    }
    __finally {
        UnmapFile (versionPtr, datMapping, datHandle);
    }

    return;
}


INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    CHAR NtTree[MAX_MBCHAR_PATH];
    CHAR OutputFileBuf[MAX_MBCHAR_PATH];
    CHAR key [MEMDB_MAX];
    DWORD value;
    PSTR OutputFile;
    PSTR p;
    INT i;
    LONG rc;
    PSTR AddnlPtr;
    INFCONTEXT context;
    PCSTR infPath;
    BOOL listSwitch = FALSE;

    MypSetupGetInfSections = (PSETUPGETINFSECTIONS) GetProcAddress(GetModuleHandle("setupapi.dll"), "pSetupGetInfSections");
    if (!MypSetupGetInfSections)
        MypSetupGetInfSections = (PSETUPGETINFSECTIONS) GetProcAddress(GetModuleHandle("setupapi.dll"), "SetupGetInfSections");

#ifdef DEBUG
    //g_DoLog = TRUE;
#endif

    //
    // Get environment variables
    //

    p = getenv ("_NT386TREE");
    if (!p || !(*p)) {
        p = getenv ("_NTTREE");
    }

    if (p && *p) {
        StringCopyA (NtTree, p);
    } else {
        StringCopyA (NtTree, ".");
    }

    //
    // Set defaults
    //

    g_TempDir = NULL;
    g_TempDirWack = g_TempDirWackBuf;
    g_WinDir = g_WinDirBuf;

    StringCopyA (OutputFileBuf, NtTree);
    AppendPathWack (OutputFileBuf);
    StringCatA (OutputFileBuf, "filelist.dat");
    OutputFile = OutputFileBuf;

    StringCopyA (g_WarnFileBuf, NtTree);
    AppendPathWack (g_WarnFileBuf);
    StringCatA (g_WarnFileBuf, "DUMP\\FILELIST.WRN");
    g_WarnFile = g_WarnFileBuf;

    StringCopyA (g_HeaderFileBuf, NtTree);
    AppendPathWack (g_HeaderFileBuf);
    StringCatA (g_HeaderFileBuf, "DUMP\\FILELIST.HDR");
    g_HeaderFile = g_HeaderFileBuf;

    StringCopyA (g_PlatformBuf, "X86");
    g_Platform = g_PlatformBuf;

    StringCopyA (g_ProductBuf, "WKS");
    g_Product = g_ProductBuf;

    GetModuleFileName (g_hInst, g_AddnlFileBuf, MAX_MBCHAR_PATH);
    AddnlPtr = (PSTR)GetFileExtensionFromPath (g_AddnlFileBuf);
    if (AddnlPtr) {
        StringCopyA (AddnlPtr, "INF");
    }
    g_AddnlFile = g_AddnlFileBuf;

    //
    // Parse command line
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {
            case 'i':
                if (argv[i][2] == ':') {
                    if (g_SourceDirectoryCount < MAX_SOURCE_COUNT) {
                        StringCopy (g_SourceDirectoryBuf[g_SourceDirectoryCount], &argv[i][3]);
                        g_SourceDirectories[g_SourceDirectoryCount] = g_SourceDirectoryBuf[g_SourceDirectoryCount];
                        g_SourceDirectoryCount++;
                    }
                } else if (i + 1 < argc) {
                    i++;
                    if (g_SourceDirectoryCount < MAX_SOURCE_COUNT) {
                        StringCopy (g_SourceDirectoryBuf[g_SourceDirectoryCount], argv[i]);
                        g_SourceDirectories[g_SourceDirectoryCount] = g_SourceDirectoryBuf[g_SourceDirectoryCount];
                        g_SourceDirectoryCount++;
                    }
                } else {
                    HelpAndExit();
                }

                break;

            case 'a':
                g_AddnlFileForced = TRUE;
                if (argv[i][2] == ':') {
                    g_AddnlFile = &argv[i][3];
                } else if (i + 1 < argc) {
                    i++;
                    g_AddnlFile = argv[i];
                } else {
                    HelpAndExit();
                }

                break;

            case 'o':
                if (argv[i][2] == ':') {
                    OutputFile = &argv[i][3];
                } else if (i + 1 < argc) {
                    i++;
                    OutputFile = argv[i];
                } else {
                    HelpAndExit();
                }

                break;

            case 'w':
                g_DoWarnings = TRUE;
                if (argv[i][2] == ':') {
                    g_WarnFile = &argv[i][3];
                } else if ((i + 1 < argc) && (argv[i][0] != '/') && (argv[i][0] != '-')) {
                    i++;
                    g_WarnFile = argv[i];
                }

                break;

            case 'h':
                g_DoHeader = TRUE;
                if (argv[i][2] == ':') {
                    g_HeaderFile = &argv[i][3];
                } else if ((i + 1 < argc) && (argv[i][0] != '/') && (argv[i][0] != '-')) {
                    i++;
                    g_HeaderFile = argv[i];
                }

                break;

            case 'p':
                if (argv[i][2] == ':') {
                    g_Platform = &argv[i][3];
                } else if ((i + 1 < argc) && (argv[i][0] != '/') && (argv[i][0] != '-')) {
                    i++;
                    g_Platform = argv[i];
                }

                break;

            case 'd':
                if (argv[i][2] == ':') {
                    g_Product = &argv[i][3];
                } else if ((i + 1 < argc) && (argv[i][0] != '/') && (argv[i][0] != '-')) {
                    i++;
                    g_Product = argv[i];
                }

                break;

            case 't':
                if (argv[i][2] == ':') {
                    g_TempDir = &argv[i][3];
                } else if ((i + 1 < argc) && (argv[i][0] != '/') && (argv[i][0] != '-')) {
                    i++;
                    g_TempDir = argv[i];
                }

                break;

            case 's':
                if (argv[i][2] == ':') {
                    g_StructName = &argv[i][3];
                } else if ((i + 1 < argc) && (argv[i][0] != '/') && (argv[i][0] != '-')) {
                    i++;
                    g_StructName = argv[i];
                }

                break;

            case 'b':
                if (argv[i][2] == ':') {
                    g_InfDatabase = &argv[i][3];
                } else if ((i + 1 < argc) && (argv[i][0] != '/') && (argv[i][0] != '-')) {
                    i++;
                    g_InfDatabase = argv[i];
                }

                break;

            case 'f':
                g_ForceRescan = TRUE;
                break;

            case 'l':
                listSwitch = TRUE;
                break;

            default:
                HelpAndExit();
            }
        } else {
            HelpAndExit();
        }
    }

    //
    // Init libs
    //

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    GetWindowsDirectoryA (g_WinDir, MAX_MBCHAR_PATH);

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        fprintf (stderr, "Initialization error!\n");
        return 254;
    }

    if (!MemDb_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        fprintf (stderr, "Initialization error!\n");
        return 254;
    }

    //
    // List mode -- skip right to dumping filelist.dat
    //

    if (listSwitch && g_SourceDirectoryCount == 0) {
        pDumpFileListDat (OutputFile);
        return 0;
    }

    if (g_SourceDirectoryCount == 0) {
        StringCopyA (g_SourceDirectoryBuf[0], NtTree);
        g_SourceDirectories[0] = g_SourceDirectoryBuf[0];
        g_SourceDirectoryCount = 1;
    }

    if (g_InfDatabase && DoesFileExist (g_InfDatabase)) {
        MemDbImport (g_InfDatabase);
    }

    if (!g_AddnlFileForced) {
        // now let's try and find the newest additional file
        // we want to compare time stamps for the one that's in the same dir
        // with filegen.exe and for the one that's on NTTREE\mstools

        WIN32_FIND_DATAA findData1, findData2;
        ULARGE_INTEGER time1, time2;

        StringCopyA (g_AddnlFileAlt, NtTree);
        AppendPathWackA (g_AddnlFileAlt);
        StringCatA (g_AddnlFileAlt, "MSTOOLS\\FILEGEN.INF");
        if (DoesFileExistExA (g_AddnlFileAlt, &findData2)) {
            if (DoesFileExistExA (g_AddnlFileBuf, &findData1)) {
                time1.LowPart = findData1.ftLastWriteTime.dwLowDateTime;
                time1.HighPart = findData1.ftLastWriteTime.dwHighDateTime;
                time2.LowPart = findData2.ftLastWriteTime.dwLowDateTime;
                time2.HighPart = findData2.ftLastWriteTime.dwHighDateTime;
                if (time1.QuadPart < time2.QuadPart) {
                    g_AddnlFile = g_AddnlFileAlt;
                }
            } else {
                g_AddnlFile = g_AddnlFileAlt;
            }
        }
    }

    // let's try to see if the additional file changed since our last run
    if (!g_ForceRescan) {
        MemDbBuildKey (key, MEMDB_CATEGORY_SRC_INF_FILES, g_AddnlFile, NULL, NULL);
        if (MemDbGetValue (key, &value)) {
            if (value != pComputeChecksum (g_AddnlFile)) {
                printf ("INF changed -- rescanning\n");
                g_ForceRescan = TRUE;
            }
        }
    }

    if (g_DoHeader) {
        if (!g_StructName) {
            g_StructName = g_StructNameBuf;
        }
    }

    if (g_AddnlFile == NULL) {
        HelpAndExit();
    } else {
        g_AddnlInf = SetupOpenInfFile (g_AddnlFile, NULL, INF_STYLE_OLDNT|INF_STYLE_WIN4, NULL);
        if (g_AddnlInf == INVALID_HANDLE_VALUE) {
            fprintf (stderr, "Could not open %s, error:%d", g_AddnlFile, GetLastError());
            return 254;
        }
    }

    // validate platform
    if (!SetupFindFirstLine (g_AddnlInf, TEXT("FILELIST.PLATFORMS"), g_Platform, &context)) {
        fprintf (stderr, "Invalid platform: %s", g_Platform);
        return 254;
    }

    // validate product
    if (!SetupFindFirstLine (g_AddnlInf, TEXT("FILELIST.PRODUCTS"), g_Product, &context)) {
        fprintf (stderr, "Invalid product type: %s", g_Product);
        return 254;
    }

    //
    // get Temp dir
    //

    if (g_TempDir) {
        StringCopyA (g_TempDirBuf, g_TempDir);
        g_TempDir = g_TempDirBuf;
    } else {
        g_TempDir = g_TempDirBuf;
        GetTempPathA (MAX_MBCHAR_PATH, g_TempDir);
        StringCopy (AppendWack (g_TempDirBuf), g_Product);
    }

    StringCopyA (g_TempDirWack, g_TempDir);
    AppendWack (g_TempDirWack);

    g_TempDirWackChars = CharCountA (g_TempDirWack);

    if (!CreateDirectory (g_TempDir, NULL)) {
        DWORD error;
        error = GetLastError ();
        if (error != ERROR_ALREADY_EXISTS) {
            fprintf (stderr, "Cannot create temporary directory. Error: %d", error);
            return 254;
        }
    }

    printf ("Input path(s)   : ");
    {
        DWORD index = 0;
        while (index < g_SourceDirectoryCount) {
            if (index == 0) {
                printf ("'%s'\n", g_SourceDirectories [index]);
            } else {
                printf ("                  '%s'\n", g_SourceDirectories [index]);
            }
            index ++;
        }
    }

    printf ("Output file     : '%s'\n", OutputFile);
    printf ("Temporary dir   : '%s'\n", g_TempDir);
    if (g_DoWarnings) {
        printf ("Warnings        : '%s'\n", g_WarnFile);
    }
    if (g_DoHeader) {
        printf ("Header file     : '%s'\n", g_HeaderFile);
    }
    printf ("Additional file : '%s'\n", g_AddnlFile);
    printf ("Platform        : '%s'\n", g_Platform);
    printf ("Product         : '%s'\n", g_Product);
    if (g_InfDatabase) {
        printf ("Rescan database : '%s'\n", g_InfDatabase);
    }
    printf ("\n");

    //
    // Build filelist.dat
    //

    DISABLETRACKCOMMENT();
    g_TempPool = PoolMemInitNamedPool ("filegen");
    PoolMemDisableTracking (g_TempPool);

    if (!pLoadExcludedFiles (g_AddnlInf)) {
        rc = GetLastError();

        fprintf (stderr, "Could not read %s.  Win32 Error Code: %x\n", g_AddnlFile, rc);
        return 2;
    }

    if (!pLoadForcedFiles (g_AddnlInf)) {
        rc = GetLastError();

        fprintf (stderr, "Could not read %s.  Win32 Error Code: %x\n", g_AddnlFile, rc);
        return 2;
    }

    if (!pLoadRenamedDirs (g_AddnlInf)) {
        rc = GetLastError();

        fprintf (stderr, "Could not read %s.  Win32 Error Code: %x\n", g_AddnlFile, rc);
        return 2;
    }

    if (!pLoadHeaderFiles (g_AddnlInf)) {
        rc = GetLastError();

        fprintf (stderr, "Could not read %s.  Win32 Error Code: %x\n", g_AddnlFile, rc);
        return 2;
    }

    if (!pCreateExcludedInfsTable (g_AddnlInf)) {
        rc = GetLastError();

        fprintf (stderr, "Could not read %s.  Win32 Error Code: %x\n", g_AddnlFile, rc);
        return 2;
    }

    if (!pCreatePrivateIdInfsTable (g_AddnlInf)) {
        rc = GetLastError();

        fprintf (stderr, "Could not read %s.  Win32 Error Code: %x\n", g_AddnlFile, rc);
        return 2;
    }

    if (!pLoadExcludedDirs (g_AddnlInf)) {
        rc = GetLastError();

        fprintf (stderr, "Could not read %s.  Win32 Error Code: %x\n", g_AddnlFile, rc);
        return 2;
    }

    if (!pLoadIgnoredDirs (g_AddnlInf)) {
        rc = GetLastError();

        fprintf (stderr, "Could not read %s.  Win32 Error Code: %x\n", g_AddnlFile, rc);
        return 2;
    }

    // let's try to see if any INF files changed since our last run
    if (!g_ForceRescan) {
        printf ("Checking INF changes\n");
        if (!pShouldRescanInfs (g_SourceDirectories, g_SourceDirectoryCount)) {
            printf ("No INF file changes. Tool will not run\n");
            return 0;
        }
    }

    MemDbDeleteTree (MEMDB_CATEGORY_SRC_INF_FILES);
    MemDbBuildKey (key, MEMDB_CATEGORY_SRC_INF_FILES, g_AddnlFile, NULL, NULL);
    MemDbSetValue (key, pComputeChecksum (g_AddnlFile));

    //
    // load the INFs
    //
    printf ("Finding all INFs\n");

    if (!LocalGetFileNames (g_SourceDirectories, g_SourceDirectoryCount, FALSE)) {
        fprintf (stderr, "ERROR: Cannot get INF file list\n");
        DEBUGMSG ((DBG_WARNING, "NTFILELIST: Can't get INF file names"));
        LocalFreeFileNames (FALSE);
        return 3;
    }

    SetFileAttributes (OutputFile, FILE_ATTRIBUTE_NORMAL);
    if (!DeleteFile (OutputFile)) {
        if ((GetLastError() != ERROR_FILE_NOT_FOUND) &&
            (GetLastError() != ERROR_PATH_NOT_FOUND)
            ) {
            fprintf (stderr, "DeleteFile failed for %s.  Win32 Error Code: %x\n",
                     OutputFile, GetLastError ());
            LocalFreeFileNames (FALSE);
            return 252;
        }
    }

    if (g_DoWarnings) {
        SetFileAttributes (g_WarnFile, FILE_ATTRIBUTE_NORMAL);
        if (!DeleteFile (g_WarnFile)) {
            if ((GetLastError() != ERROR_FILE_NOT_FOUND) &&
                (GetLastError() != ERROR_PATH_NOT_FOUND)
                ) {
                fprintf (stderr, "DeleteFile failed for %s.  Win32 Error Code: %x\n",
                         g_WarnFile, GetLastError ());
                LocalFreeFileNames (FALSE);
                return 252;
            }
        }
    }

    if (g_DoHeader) {
        SetFileAttributes (g_HeaderFile, FILE_ATTRIBUTE_NORMAL);
        if (!DeleteFile (g_HeaderFile)) {
            if ((GetLastError() != ERROR_FILE_NOT_FOUND) &&
                (GetLastError() != ERROR_PATH_NOT_FOUND)
                ) {
                fprintf (stderr, "DeleteFile failed for %s.  Win32 Error Code: %x\n",
                         g_HeaderFile, GetLastError ());
                LocalFreeFileNames (FALSE);
                return 252;
            }
        }
    }

    //
    // now let's try to find the proper layout.inf
    // We will look into all source directories for a subdir with the name of the
    // product we are processing (for ENT is ENTINF etc.) and try to find layout.inf
    // there.
    //
    pGetProperLayoutInf ();

    printf ("Reading NT file list (layout.inf)\n");

    infPath = JoinPaths (g_TempDir, "layout.inf");

    if (!pLocalReadNtFiles (infPath)) {
        rc = GetLastError();

        printf ("Could not read %s.  Win32 Error Code: %x\n", infPath, rc);
        LocalFreeFileNames (FALSE);
        return 3;
    }

    FreePathString (infPath);

    printf ("Reading NT file list (intl.inf)\n");

    infPath = JoinPaths (g_TempDir, "intl.inf");

    if (!pLocalReadNtFiles (infPath)) {
        rc = GetLastError();

        printf ("Could not read %s.  Win32 Error Code: %x\n", infPath, rc);
        LocalFreeFileNames (FALSE);
        return 3;
    }

    FreePathString (infPath);

    if (!pCreateNtFileList (OutputFile)) {

        rc = GetLastError();

        printf ("Could not build complete filelist.  Win32 Error Code: %x\n", rc);
        LocalFreeFileNames (FALSE);
        return 3;
    } else {
        printf ("%s was built successfully.\n", OutputFile);

        if (listSwitch) {
            pDumpFileListDat (OutputFile);
        }
    }

    if (g_DoWarnings) {
        pPrintWarnings ();
    }

    if (g_DoHeader) {
        pLoadKnownFiles (g_AddnlInf, TRUE);
        pPrintHeaderFile ();
    }

    HtFree (g_ExcludedInfsTable);

    if (g_AddnlInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile (g_AddnlInf);
    }

    LocalFreeFileNames (FALSE);

    ENABLETRACKCOMMENT();

    //
    // Terminate libs
    //

    PoolMemEmptyPool (g_TempPool);
    PoolMemDestroyPool (g_TempPool);

    if (!MemDb_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
        fprintf (stderr, "Termination error!\n");
        return 253;
    }

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
        fprintf (stderr, "Termination error!\n");
        return 253;
    }

    return 0;
}


typedef struct _KNOWN_DIRS {
    PCSTR DirId;
    PCSTR DirValue;
}
KNOWN_DIRS, *PKNOWN_DIRS;

KNOWN_DIRS g_LocalKnownDirs [] = {
    {"10"   , "%systemroot%"},
    {"11"   , "%systemroot%\\system32"},
    {"12"   , "%systemroot%\\system32\\drivers"},
    {"17"   , "%systemroot%\\inf"},
    {"18"   , "%systemroot%\\help"},
    {"20"   , "%systemroot%\\fonts"},
    {"21"   , "%systemroot%\\system32\\viewers"},
    {"23"   , "%systemroot%\\system32\\spool\\drivers\\color"},
    {"24"   , "%systemdrive%"},
    {"25"   , "%systemroot%"},
    {"30"   , "%systemdrive%"},
    {"50"   , "%systemroot%\\system"},
    {"51"   , "%systemroot%\\system32\\spool"},
    {"52"   , "%systemroot%\\system32\\spool\\drivers"},
    {"53"   , "%systemdrive%\\Documents and Settings"},
    {"54"   , "%systemdrive%"},
    {"55"   , "%systemroot%\\system32\\spool\\prtprocs"},
    {"16422", "%ProgramFiles%"},
    {"16427", "%commonprogramfiles%"},
    {"16428", "%commonprogramfiles(x86)%"},
    {"XX001", "%ProgramFilesX86%"},
    {"66000", "%systemroot%\\system32\\spool\\drivers\\W32%Platform%\\3"},
    {"66002", "%systemroot%\\system32"},
    {"66003", "%systemroot%\\system32\\spool\\drivers\\color"},
    {NULL,  NULL}
    };

typedef struct _CONVERT_DIRS {
    PCSTR SifDir;
    PCSTR SetupDir;
}
CONVERT_DIRS, *PCONVERT_DIRS;

CONVERT_DIRS g_LocalConvertDirs [] = {
    {"1",   "10"},
    {"2",   "11"},
    {"3",   "11\\config"},
    {"4",   "12"},
    {"5",   "50"},
    {"6",   "11\\os2"},
    {"7",   "11\\ras"},
    {"8",   "11\\os2\\dll"},
    {"9",   "51"},
    {"10",  "52"},
    {"11",  "66000"},
    {"12",  "55"},

    {"14",  "11\\wins"},
    {"15",  "11\\dhcp"},
    {"16",  "10\\repair"},
    {"17",  "12\\etc"},


    {"20",  "17"},
    {"21",  "18"},
    {"22",  "20"},
    {"23",  "10\\config"},
    {"24",  "10\\msagent\\intl"},
    {"25",  "10\\Cursors"},
    {"26",  "10\\Media"},
    {"27",  "10\\java"},
    {"28",  "10\\java\\classes"},
    {"29",  "10\\java\\trustlib"},
    {"30",  "11\\ShellExt"},
    {"31",  "10\\Web"},
    {"32",  "11\\Setup"},
    {"33",  "10\\Web\\printers"},
    {"34",  "66003"},
    {"35",  "11\\wbem"},
    {"36",  "11\\wbem\\Repository"},
    {"37",  "10\\addins"},
    {"38",  "10\\Connection Wizard"},

    {"40",  "10\\security"},
    {"41",  "10\\security\\templates"},
    {"42",  "11\\npp"},
    {"43",  "11\\ias"},
    {"44",  "11\\dllcache"},
    {"45",  "10\\Temp"},
    {"46",  "10\\Web\\printers\\images"},
    {"47",  "11\\export"},
    {"48",  "11\\wbem\\mof\\good"},
    {"49",  "11\\wbem\\mof\\bad"},
    {"50",  "10\\twain_32"},
    {"51",  "10\\msapps\\msinfo"},
    {"52",  "10\\msagent"},
    {"53",  "10\\msagent\\chars"},
    {"54",  "10\\security\\logs"},
    {NULL,  NULL}
    };

VOID
pConvertSIFDir (
    IN OUT  PSTR Dir
    )
{
    PCONVERT_DIRS p = g_LocalConvertDirs;
    while (p->SifDir) {
        if (StringIMatch (Dir, p->SifDir)) {
            StringCopy (Dir, p->SetupDir);
            return;
        }
        p++;
    }
}

typedef struct _INF_DIRS {
    PCSTR InfName;
    PCSTR DirId;
    PCSTR DirValue;
} INF_DIRS, *PINF_DIRS;

BOOL
pCheckIdDir (
    IN      PCSTR IdDir
    )
{
    PKNOWN_DIRS currDir = g_LocalKnownDirs;
    while (currDir->DirId) {
        if (StringIMatch (currDir->DirId, IdDir)) {
            return TRUE;
        }
        currDir++;
    }
    return FALSE;
}

BOOL
pCheckInfIdDir (
    IN      PCSTR InfName,
    OUT     PSTR IdDir
    )
{
    PPRIVATE_ID_INFS privateIdInfs;

    if (HtFindStringAndData (g_PrivateIdInfsTable, InfName, &privateIdInfs)) {
        while (privateIdInfs) {
            if (StringIMatch (privateIdInfs->PrivateId, IdDir)) {
                StringCopy (IdDir, privateIdInfs->EquivalentId);
                return TRUE;
            }
            privateIdInfs = privateIdInfs->Next;
        }
    }
    return FALSE;
}

VOID
pMinimizeIdPath (
    IN      PCSTR SourceDirectoryWithLdirId,
    OUT     PSTR DestDirectoryWithLdirId
    )
{
    PSTR temp;
    PKNOWN_DIRS knownDir;
    UINT thisSize;
    UINT bestSize = 0;
    PKNOWN_DIRS bestMatch = NULL;
    PCSTR end;

    __try {

        temp = AllocText (MAX_PATH);
        if (!temp) {
            __leave;
        }

        //
        // Search for the longest match
        //

        pFixDir (SourceDirectoryWithLdirId, temp);

        knownDir = g_LocalKnownDirs;
        while (knownDir->DirId) {

            thisSize = TcharCount (knownDir->DirValue);

            if (thisSize > bestSize) {

                end = temp + thisSize;

                if (*end == 0 || *end == '\\') {
                    if (StringIPrefix (temp, knownDir->DirValue)) {
                        bestMatch = knownDir;
                        bestSize = thisSize;
                    }
                }
            }

            knownDir++;
        }

        //
        // Copy the shortest path to the caller's buffer
        //

        if (bestMatch) {
            end = temp + bestSize;
            StringCopy (DestDirectoryWithLdirId, bestMatch->DirId);
            if (end) {
                StringCat (DestDirectoryWithLdirId, end);
            }

        } else {
            StringCopy (DestDirectoryWithLdirId, SourceDirectoryWithLdirId);
        }
    }
    __finally {
        FreeText (temp);
    }
}

PSTR
pReadDestDir (
    IN      PCSTR FileName,
    IN      PCSTR Section,
    IN      HINF FileHandle,
    IN      PGROWBUFFER LayoutFiles,
    OUT     PDWORD badOffset
    )
{
    INFSTRUCT context = INITINFSTRUCT_POOLHANDLE;
    MULTISZ_ENUMA layoutFilesEnum;
    PCSTR localLayoutFile = NULL;
    HINF infHandle;
    PSTR idDir;
    PSTR idDirPtr;
    PSTR subDir;
    PSTR result = NULL;
    PSTR srcDir, destDir, wildCharPtr;
    PSTR resultTmp = NULL;
    PRENAMED_DIRS renamedDir;
    BOOL found;

    *badOffset = 0;

    __try {

        idDir = AllocText (MEMDB_MAX);
        if (!idDir) {
            __leave;
        }

        if (InfFindFirstLine (FileHandle, "DestinationDirs", (Section[0]=='@')?(Section+1):Section, &context) ||
            InfFindFirstLine (FileHandle, "DestinationDirs", "DefaultDestDir", &context)
            ) {
            idDirPtr  = pGetNonEmptyField (&context, 1);
            if (idDirPtr) {
                StringCopy (idDir, idDirPtr);
            } else {
                idDir [0] = 0;
            }
            subDir = pGetNonEmptyField (&context, 2);
            if (!pCheckIdDir (idDir)) {
                if (!pCheckInfIdDir (GetFileNameFromPath (FileName), idDir)) {
                    DEBUGMSG ((DBG_WARNING, "Directory ID not found for %s in %s", Section, GetFileNameFromPath (FileName)));
                    if (g_DoWarnings) {
                        MemDbSetValueEx (MEMDB_CATEGORY_NT_SECT_BADDIR, GetFileNameFromPath (FileName), Section, idDir, 0, badOffset);
                    }
                    result = NULL;
                    __leave;
                }
            }
            if (subDir != NULL) {
                result = JoinPaths (idDir, subDir);
            }
            else {
                result = DuplicatePathString (idDir, 0);
            }
            __leave;
        }
        if (LayoutFiles) {
            if (EnumFirstMultiSz (&layoutFilesEnum, LayoutFiles->Buf)) {
                do {
                    localLayoutFile = JoinPaths (g_TempDir, layoutFilesEnum.CurrentString);

                    infHandle = pOpenInfWithCache (localLayoutFile);

                    if (infHandle != INVALID_HANDLE_VALUE) {
                        result = pReadDestDir (FileName, Section, infHandle, NULL, badOffset);
                        pCloseInfWithCache (infHandle);

                        if (result != NULL) {
                            FreePathString (localLayoutFile);
                            __leave;
                        }
                    }

                    FreePathString (localLayoutFile);

                } while (EnumNextMultiSz (&layoutFilesEnum));
            }
        }
        DEBUGMSG ((DBG_WARNING, "No directory found for %s in %s", Section, GetFileNameFromPath (FileName)));
        if (g_DoWarnings) {
            MemDbSetValueEx (MEMDB_CATEGORY_NT_SECT_NODIR, GetFileNameFromPath (FileName), Section, NULL, 0, badOffset);
        }


    }
    __finally {
        if (result != NULL) {
            // let's do some dir replacement here
            found = TRUE;
            while (found) {
                renamedDir = g_RenamedDirs;
                found = FALSE;
                while ((!found) && renamedDir) {
                    if (IsPatternMatch (renamedDir->SrcDir, result)) {
                        srcDir = DuplicatePathString (renamedDir->SrcDir, 0);
                        destDir = DuplicatePathString (renamedDir->DestDir, 0);
                        wildCharPtr = _tcschr (srcDir, TEXT('*'));
                        if (wildCharPtr) {
                            *wildCharPtr = 0;
                        }
                        wildCharPtr = _tcschr (destDir, TEXT('*'));
                        if (wildCharPtr) {
                            *wildCharPtr = 0;
                        }


                        MYASSERT (!StringIPrefix (srcDir, destDir));
                        MYASSERT (!StringIPrefix (destDir, srcDir));

                        resultTmp = (PSTR)StringSearchAndReplace (result, srcDir, destDir);
                        if (resultTmp) {
                            FreePathString (result);
                            result = resultTmp;
                            found = TRUE;
                        }
                        FreePathString (destDir);
                        FreePathString (srcDir);
                    }
                    renamedDir = renamedDir->Next;
                }
            }
        }

        InfCleanUpInfStruct (&context);
        FreeText (idDir);
    }

    return result;
}

PTSTR
pGetAdditionalLocation (
    IN      PCTSTR DestFile
    )
{
    INFCONTEXT context;
    TCHAR field [MAX_MBCHAR_PATH];

    if (g_AddnlInf == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    if (SetupFindFirstLine (g_AddnlInf, SECT_KNOWN_LOCATION, DestFile, &context)) {
        if (SetupGetStringField (&context, 1, field, MAX_MBCHAR_PATH, NULL)) {
            return (DuplicatePathString (field, 0));
        }
    }
    return NULL;
}

BOOL
pFixDir (
    IN      PCSTR src,
    OUT     PSTR dest
    )
{
    PSTR tempPtr;
    PKNOWN_DIRS knownDir;
    BOOL result = FALSE;
    PSTR temp;

    __try {
        temp = AllocText (MEMDB_MAX);
        if (!temp) {
            __leave;
        }

        *dest = 0;
        tempPtr = _mbschr (src, '\\');
        if (tempPtr) {
            StringCopyABA (temp, src, tempPtr);
        } else {
            StringCopy (temp, src);
        }
        knownDir = g_LocalKnownDirs;
        while (knownDir->DirId) {
            if (StringIMatch (temp, knownDir->DirId)) {
                StringCopy (dest, knownDir->DirValue);
                break;
            }
            knownDir ++;
        }
        if (*dest == 0) {
            __leave;
        }
        if (tempPtr) {
            StringCat (dest, tempPtr);
        }

        result = TRUE;
    }
    __finally {
        FreeText (temp);
    }

    return result;
}

BOOL
DoDirsMatch (
    IN      DWORD Offset1,
    IN      DWORD Offset2
    )
{
    PSTR dir1;
    PSTR fixedDir1;
    PSTR dir2;
    PSTR fixedDir2;
    BOOL result = FALSE;

    dir1 = AllocText (MEMDB_MAX);
    fixedDir1 = AllocText (MEMDB_MAX);
    dir2 = AllocText (MEMDB_MAX);
    fixedDir2 = AllocText (MEMDB_MAX);

    if (dir1 && fixedDir1 && dir2 && fixedDir2) {

        if (MemDbBuildKeyFromOffset (Offset1, dir1, 1, NULL) &&
            MemDbBuildKeyFromOffset (Offset2, dir2, 1, NULL) &&
            pFixDir (dir1, fixedDir1) &&
            pFixDir (dir2, fixedDir1)
            ) {
            result = StringIMatch (fixedDir1, fixedDir2);
        }
    }

    FreeText (dir1);
    FreeText (fixedDir1);
    FreeText (dir2);
    FreeText (fixedDir2);

    return result;
}

PCSTR
pGetLayoutInfFile (
    IN      PCSTR FileName,
    IN      HINF FileHandle,
    IN      PGROWBUFFER LayoutFiles,
    IN      PCSTR SrcName
    )
{
    INFSTRUCT context = INITINFSTRUCT_POOLHANDLE;
    MULTISZ_ENUMA layoutFilesEnum;
    HINF layoutHandle;
    CHAR sectName [MAX_PATH];
    PCSTR result = NULL;
    PCSTR layoutFile = NULL;
    PCSTR localLayoutFile = NULL;
    GROWBUFFER layoutFiles = GROWBUF_INIT;
    UINT fieldIdx = 0;

    StringCopy (sectName, "SourceDisksFiles");
    if (InfFindFirstLine (FileHandle, sectName, SrcName, &context)) {
        InfCleanUpInfStruct (&context);
        result = DuplicatePathString (GetFileNameFromPath (FileName), 0);
    }

    if (!result) {
        StringCat (sectName, ".");
        StringCat (sectName, g_Platform);
        if (InfFindFirstLine (FileHandle, sectName, SrcName, &context)) {
            InfCleanUpInfStruct (&context);
            result = DuplicatePathString (GetFileNameFromPath (FileName), 0);
        }
    }

    if (!result) {
        if (LayoutFiles) {
            if (EnumFirstMultiSz (&layoutFilesEnum, LayoutFiles->Buf)) {
                do {
                    localLayoutFile = JoinPaths (g_TempDir, layoutFilesEnum.CurrentString);

                    layoutHandle = pOpenInfWithCache (localLayoutFile);

                    if (layoutHandle != INVALID_HANDLE_VALUE) {

                        // get all layout files in a multisz
                        if (InfFindFirstLine (layoutHandle, "Version", "LayoutFile", &context)) {
                            fieldIdx = 1;
                            layoutFile = pGetNonEmptyField (&context, fieldIdx);
                            while (layoutFile) {
                                MultiSzAppend (&layoutFiles, layoutFile);
                                fieldIdx ++;
                                layoutFile = pGetNonEmptyField (&context, fieldIdx);
                            }
                            InfCleanUpInfStruct (&context);
                        }

                        result = pGetLayoutInfFile (layoutFilesEnum.CurrentString, layoutHandle, &layoutFiles, SrcName);
                        pCloseInfWithCache (layoutHandle);

                        if (result != NULL) {
                            FreeGrowBuffer (&layoutFiles);
                            FreePathString (localLayoutFile);
                            break;
                        }
                        FreeGrowBuffer (&layoutFiles);
                    } else {
                        //MessageBox (NULL, "Layout", "Layout", MB_OK);
                    }
                    FreePathString (localLayoutFile);
                } while (EnumNextMultiSz (&layoutFilesEnum));
            }
        }
    }

    InfCleanUpInfStruct (&context);

    return result;
}

//
// Use globals for highly used memory allocations (to avoid reallocs)
//

typedef enum {
    ST_COPYFILES,
    ST_DELFILES
} SECTIONTYPE;

VOID
pProcessCopyFileSpec (
    IN      PCSTR InfFileName,
    IN      HINF InfFileHandle,
    IN      PCSTR InfSection,
    IN      PCSTR SrcFile,              OPTIONAL
    IN      PCSTR DestDirectory,
    IN      PCSTR DestFile,
    IN      BOOL NoDestDirSpec,
    IN      DWORD NoDirOffset,
    IN      PGROWBUFFER LayoutFilesBuf
    )
{
    BOOL twice = FALSE;
    BOOL removeExistingEntry = FALSE;
    BOOL outputFile = TRUE;
    PSTR key;
    MEMDB_ENUM enumFiles;
    DWORD offset;
    PCSTR layoutInfFile;
    PCSTR finalDestDir;
    PSTR tmpDest;

    __try {

        key = AllocText (MEMDB_MAX);
        if (!key) {
            __leave;
        }

        //
        // If DestFile has a subpath, join it with DestDirectory
        //

        if (_mbschr (DestFile, '\\')) {
            //
            // This dest file has a dir in it. Join it with the root,
            // then recompute the file name ptr.
            //

            finalDestDir = JoinPaths (DestDirectory, DestFile);
            tmpDest = _mbsrchr (finalDestDir, '\\');
            *tmpDest = 0;
            DestFile = tmpDest + 1;

        } else {
            finalDestDir = DestDirectory;
        }

        //
        // Make SrcFile non-NULL
        //

        if (!SrcFile || !(*SrcFile)) {
            SrcFile = DestFile;
        } else {
            if (_mbschr (SrcFile, '\\')) {
                //
                // This src file has a dir in it -- skip the
                // dir specification
                //

                SrcFile = GetFileNameFromPath (SrcFile);
            }
        }

        //
        // Now add the file spec (if it does not already exist)
        //

        if (NoDestDirSpec) {

            MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES, DestFile, SrcFile, "*");

            if (!MemDbEnumFirstValue (&enumFiles, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
                if (g_DoWarnings) {
                    //
                    // Record a "no directory spec" warning because this file is not
                    // listed in a section that is also listed in [DestinationDirs]
                    //

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_NT_FILES_NODIR_OTHER_COPY,
                        DestFile,
                        NULL,
                        NULL,
                        NoDirOffset,
                        NULL
                        );
                }
            } else {
                //
                // Already listed properly -- ignore this bad spec
                //

                return;
            }
        }

        //
        // Add the destination directory to the NtDirs category.
        //

        MemDbSetValueEx (
            MEMDB_CATEGORY_NT_DIRS,
            finalDestDir,
            NULL,
            NULL,
            0,
            &offset
            );

        //
        // Now write the file to the caller-specified category.
        //
        MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES, DestFile, SrcFile, "*");

        if (MemDbEnumFirstValue (&enumFiles, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {

            removeExistingEntry = TRUE;

            do {
                //
                // If file is marked in layout.inf as "never copy" then skip keep this file.
                //
                if (!(enumFiles.UserFlags & SRC_NEVER_COPY)) {

                    //
                    // Is there a non-identical match already in memdb?
                    //

                    if (offset != enumFiles.dwValue && !DoDirsMatch (offset, enumFiles.dwValue)) {
                        twice = TRUE;
                        removeExistingEntry = TRUE;
                        outputFile = TRUE;

                        //
                        // Add the first duplicate to the del list, so that
                        // uninstall backs it up.
                        //

                        MemDbBuildKeyFromOffset (enumFiles.dwValue, key, 1, NULL);
                        pProcessDelFileSpec (key, DestFile);

                        break;
                    } else {
                        // ignore identical duplicate
                        removeExistingEntry = FALSE;
                        outputFile = FALSE;
                    }
                }

            } while (MemDbEnumNextValue (&enumFiles));
        }

        //
        // Provide a warning when a file is listed in multiple INFs, or the
        // same INF twice. It must have a different dest directory.
        //

        if (twice) {
            DEBUGMSG ((DBG_WARNING, "File %s is listed in more that one directory.", DestFile));
            if (g_DoWarnings) {
                MemDbSetValueEx (MEMDB_CATEGORY_NT_FILES_DOUBLED_IDX_COPY, DestFile, NULL, NULL, 0, NULL);
            }
        }

        //
        // Always use the last file spec, ignoring the early dups.
        //

        if (removeExistingEntry) {
            MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES, DestFile, SrcFile, NULL);
            MemDbDeleteTree (key);
        }

        if (outputFile) {
            layoutInfFile = pGetLayoutInfFile (
                                InfFileName,
                                InfFileHandle,
                                LayoutFilesBuf,
                                SrcFile
                                );

            if (layoutInfFile) {

                MemDbSetValueEx (
                    MEMDB_CATEGORY_NT_FILES,
                    DestFile,
                    SrcFile,
                    layoutInfFile,
                    offset,
                    NULL
                    );
                FreePathString (layoutInfFile);

            } else {
                if (g_DoWarnings) {
                    MemDbSetValueEx (
                        MEMDB_CATEGORY_NT_FILES_NO_LAYOUT,
                        GetFileNameFromPath (InfFileName),
                        InfSection,
                        DestFile,
                        0,
                        NULL
                        );
                }
            }
        }

        //
        // Write the file to keep track of dups
        //

        MemDbSetValueEx (
            MEMDB_CATEGORY_NT_FILES_DOUBLED_COPY,
            DestFile,
            GetFileNameFromPath (InfFileName),
            finalDestDir,
            0,
            NULL
            );

        //
        // Remove directory warning keys when a [DestinationDirs]
        // specification exists.
        //

        if (!NoDestDirSpec) {
            MemDbBuildKey(key, MEMDB_CATEGORY_NT_FILES_NODIR_COPY, DestFile, NULL, NULL);
            MemDbDeleteTree (key);
            MemDbBuildKey(key, MEMDB_CATEGORY_NT_FILES_NODIR_OTHER_COPY, DestFile, NULL, NULL);
            MemDbDeleteValue (key);
        }
    }
    __finally {

        //
        // Clean up
        //

        if (finalDestDir != DestDirectory) {
            FreePathString (finalDestDir);
        }

        FreeText (key);
    }

}


VOID
pProcessDelFileSpec (
    IN      PCSTR DestDirectory,
    IN      PCSTR DestFile
    )
{
    PSTR key;
    PCSTR p;
    PCSTR finalDestDir;
    PSTR tmpDest;
    CHAR fixedFullPath[MAX_PATH];

    __try {
        key = AllocText (MEMDB_MAX);
        if (!key) {
            __leave;
        }

        //
        // If DestFile has a subpath, join it with DestDirectory
        //

        if (_mbschr (DestFile, '\\')) {
            //
            // This dest file has a dir in it. Join it with the root,
            // then recompute the file name ptr.
            //

            finalDestDir = JoinPaths (DestDirectory, DestFile);
            tmpDest = _mbsrchr (finalDestDir, '\\');
            *tmpDest = 0;
            DestFile = tmpDest + 1;

        } else {
            finalDestDir = DestDirectory;
        }

        //
        // Minimize the destination path
        //

        pMinimizeIdPath (DestDirectory, fixedFullPath);

        //
        // Record the spec in the DelFiles category
        //

        MemDbBuildKey (key, MEMDB_CATEGORY_DEL_FILES, fixedFullPath, DestFile, NULL);
        MemDbSetValue (key, 0);
    }
    __finally {
        if (finalDestDir != DestDirectory) {
            FreePathString (finalDestDir);
        }

        FreeText (key);
    }
}


VOID
pProcessFileSpec (
    IN      PCSTR InfFileName,
    IN      HINF InfFileHandle,
    IN      PCSTR InfSection,
    IN      SECTIONTYPE SectionType,
    IN      PCSTR SrcFile,              OPTIONAL
    IN      PCSTR DestDirectory,
    IN      PCSTR DestFile,
    IN      BOOL NoDestDirSpec,
    IN      DWORD NoDirOffset,
    IN      PGROWBUFFER LayoutFilesBuf
    )
{
    if (SectionType == ST_COPYFILES) {
        pProcessCopyFileSpec (
            InfFileName,
            InfFileHandle,
            InfSection,
            SrcFile,
            DestDirectory,
            DestFile,
            NoDestDirSpec,
            NoDirOffset,
            LayoutFilesBuf
            );
    } else if (SectionType == ST_DELFILES) {
        if (!NoDestDirSpec) {
            pProcessDelFileSpec (DestDirectory, DestFile);
        }
    }
}

BOOL
pProcessInfCommand (
    IN      PCSTR InfFileName,
    IN      PCSTR SectionMultiSz,
    IN      HINF InfFileHandle,
    IN      SECTIONTYPE SectionType,
    IN      PGROWBUFFER LayoutFilesBuf
    )
{
    MULTISZ_ENUM multiSz;
    BOOL done;
    PCSTR destDirectory;
    PCSTR knownDestDir;
    PCSTR srcFile;
    PCSTR destFile;
    DWORD noDirOffset;
    INFSTRUCT context;

    //
    // Evaluate the INF section
    //

    if (EnumFirstMultiSz (&multiSz, SectionMultiSz)) {
        do {
            //
            // If this section is excluded, continue without processing it.
            //

            if (pIsExcludedInfSection (GetFileNameFromPath (InfFileName), multiSz.CurrentString)) {
                continue;
            }

            //
            // Read destination directory for this particular copy section. This comes
            // from the INF's [DestinationDirs] section.
            //

            destDirectory = pReadDestDir (
                                InfFileName,
                                multiSz.CurrentString,
                                InfFileHandle,
                                LayoutFilesBuf,
                                &noDirOffset
                                );

            //
            // read all the lines that contain destination file name and source file name
            //

            InitInfStruct (&context, NULL, g_TempPool);

            if (multiSz.CurrentString[0] == '@' ||
                InfFindFirstLine (InfFileHandle, multiSz.CurrentString, NULL, &context)
                ) {

                done = FALSE;

                do {
                    //
                    // Get the dest and src file names
                    //

                    if (multiSz.CurrentString[0]=='@') {
                        destFile = multiSz.CurrentString + 1;
                    } else {
                        destFile = pGetNonEmptyField (&context, 1);
                    }

                    if (multiSz.CurrentString[0]=='@') {
                        srcFile = NULL;
                    } else {
                        srcFile = pGetNonEmptyField (&context, 2);
                    }

                    if (destDirectory) {

                        //
                        // Perform processing to ensure that the file spec is
                        // unique, that it is fully formed, and that it gets
                        // written to filelist.dat.
                        //

                        pProcessFileSpec (
                            InfFileName,
                            InfFileHandle,
                            multiSz.CurrentString,
                            SectionType,
                            srcFile,
                            destDirectory,
                            destFile,
                            FALSE,
                            noDirOffset,
                            LayoutFilesBuf
                            );
                    } else if (destFile) {
                        knownDestDir = pGetAdditionalLocation (GetFileNameFromPath (destFile));

                        if (knownDestDir) {

                            pProcessFileSpec (
                                InfFileName,
                                InfFileHandle,
                                multiSz.CurrentString,
                                SectionType,
                                srcFile,
                                knownDestDir,
                                destFile,
                                TRUE,
                                noDirOffset,
                                LayoutFilesBuf
                                );

                            FreePathString (knownDestDir);
                        }
                    }

                    if (multiSz.CurrentString[0]=='@') {
                        done = TRUE;
                    } else if (!InfFindNextLine (&context)) {
                        done = TRUE;
                    }

                } while (!done);

                InfCleanUpInfStruct (&context);
            }

            if (destDirectory != NULL) {
                FreePathString (destDirectory);
            }
        } while (EnumNextMultiSz (&multiSz));
    }

    return TRUE;
}


BOOL
pProcessFile (
    IN      PCSTR FileName
    )
{
    GROWBUFFER sectionNamesBuf = GROWBUF_INIT;
    PWSTR sectBuffer = NULL;
    PWSTR currentSect;
    HINF fileHandle;
    UINT sizeNeeded = 0;
    UINT fieldIdx = 0;
    CHAR section[MAX_MBCHAR_PATH];
    MULTISZ_ENUMA sectionEnum;
    PCSTR layoutFile;
    PCSTR cmdSection;
    INFSTRUCT context = INITINFSTRUCT_POOLHANDLE;
    GROWBUFFER layoutFilesBuf = GROWBUF_INIT;

    fileHandle = InfOpenInfFile (FileName);

    if (fileHandle == INVALID_HANDLE_VALUE) {
        fprintf (stderr, "WARNING: Cannot open inf file:%s\n", FileName);
        return TRUE;
    }

    __try {
        //
        // get all layout files in a multisz
        //

        if (InfFindFirstLine (fileHandle, "Version", "LayoutFile", &context)) {
            fieldIdx = 1;
            layoutFile = pGetNonEmptyField (&context, fieldIdx);

            while (layoutFile) {
                MultiSzAppend (&layoutFilesBuf, layoutFile);
                fieldIdx ++;
                layoutFile = pGetNonEmptyField (&context, fieldIdx);
            }
        } else {
            // put layout.inf in the list, because it is the default layout file
            MultiSzAppend (&layoutFilesBuf, "layout.inf");
        }

        InfResetInfStruct (&context);

        //
        // get all the sections
        //

        if (!(*MypSetupGetInfSections) (fileHandle, NULL, 0, &sizeNeeded)) {
            fprintf (stderr, "WARNING: Error processing inf file:%s\n", FileName);
            __leave;
        }
        if (sizeNeeded == 0) {
            __leave;
        }

        sectBuffer = AllocPathStringW (sizeNeeded + 1);
        if (!(*MypSetupGetInfSections) (fileHandle, (PSTR)sectBuffer, sizeNeeded, NULL)) {
            fprintf (stderr, "WARNING: Error processing inf file:%s\n", FileName);
            __leave;
        }

        //
        // enumerate all sections looking for CopyFiles key
        //

        currentSect = sectBuffer;
        while (*currentSect) {

            sprintf (section, "%S", currentSect);

            //
            // get all sections that copy files in a multisz
            //

            if (InfFindFirstLine (fileHandle, section, "CopyFiles", &context)) {

                do {
                    fieldIdx = 1;

                    cmdSection = pGetNonEmptyField (&context, fieldIdx);
                    while (cmdSection) {
                        MultiSzAppend (&sectionNamesBuf, cmdSection);
                        fieldIdx ++;
                        cmdSection = pGetNonEmptyField (&context, fieldIdx);
                    }

                    //
                    // enumerate all sections that copy files
                    //

                    if (EnumFirstMultiSz (&sectionEnum, sectionNamesBuf.Buf)) {
                        do {

                            if (!pProcessInfCommand (
                                    FileName,
                                    sectionEnum.CurrentString,
                                    fileHandle,
                                    ST_COPYFILES,
                                    &layoutFilesBuf
                                    )) {
                                __leave;
                            }
                        } while (EnumNextMultiSz (&sectionEnum));
                    }

                    FreeGrowBuffer (&sectionNamesBuf);

                } while (InfFindNextLine (&context));
            }

            InfResetInfStruct (&context);

            //
            // get all sections that delete files in a multisz
            //

            if (InfFindFirstLine (fileHandle, section, "DelFiles", &context)) {

                do {
                    fieldIdx = 1;

                    cmdSection = pGetNonEmptyField (&context, fieldIdx);
                    while (cmdSection) {
                        MultiSzAppend (&sectionNamesBuf, cmdSection);
                        fieldIdx ++;
                        cmdSection = pGetNonEmptyField (&context, fieldIdx);
                    }

                    //
                    // enumerate all sections that delete files
                    //

                    if (EnumFirstMultiSz (&sectionEnum, sectionNamesBuf.Buf)) {
                        do {

                            if (!pProcessInfCommand (
                                    FileName,
                                    sectionEnum.CurrentString,
                                    fileHandle,
                                    ST_DELFILES,
                                    &layoutFilesBuf
                                    )) {
                                __leave;
                            }
                        } while (EnumNextMultiSz (&sectionEnum));
                    }

                    FreeGrowBuffer (&sectionNamesBuf);

                } while (InfFindNextLine (&context));
            }

            InfResetInfStruct (&context);

            currentSect = GetEndOfStringW (currentSect) + 1;
        }
    }
    __finally {
        FreePathStringW (sectBuffer);
        FreeGrowBuffer (&layoutFilesBuf);
        InfCleanUpInfStruct (&context);
        InfCloseInfFile (fileHandle);
    }

    return TRUE;
}


typedef struct {
    CHAR FilePath[MAX_PATH];
    UINT ThreadNumber;
    HANDLE GoEvent;
    HANDLE DoneEvent;
} THREADARGS, *PTHREADARGS;

HANDLE g_Semaphores[4];
HANDLE g_FileThreads[4];
THREADARGS g_FileThreadInfo[4];
HANDLE g_DoneEvent;


DWORD
WINAPI
pProcessFileThread (
    IN      PVOID ThreadInfo
    )
{
    HANDLE array[2];
    PTHREADARGS threadInfo = (PTHREADARGS) ThreadInfo;
    DWORD rc;

    array[0] = threadInfo->GoEvent;
    array[1] = threadInfo->DoneEvent;

    for (;;) {
        rc = WaitForMultipleObjects (2, array, FALSE, INFINITE);

        if (rc == WAIT_OBJECT_0) {
            pProcessFile (threadInfo->FilePath);
            ReleaseSemaphore (g_Semaphores[threadInfo->ThreadNumber], 1, NULL);
        } else {
            break;
        }
    }

    return 0;

}

BOOL
pProcessFileDispatcher (
    IN      PCSTR FileName
    )
{
    DWORD rc;

    //
    // Wait for a thread to become availble
    //

    rc = WaitForMultipleObjects (4, g_Semaphores, FALSE, INFINITE);

    if (rc <= WAIT_OBJECT_0 + 3) {
    } else {
        fprintf (stderr, "Failed to acquire thread\n");
        exit (1);
    }

    //
    // Put file name in thread's struct
    //

    rc -= WAIT_OBJECT_0;
    StringCopy (g_FileThreadInfo[rc].FilePath, FileName);

    //
    // Start the thread
    //

    SetEvent (g_FileThreadInfo[rc].GoEvent);

    return TRUE;
}


VOID
pInitFileThreads (
    VOID
    )
{
    UINT u;

    g_DoneEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

    if (!g_DoneEvent) {
        fprintf (stderr, "Failed to init completion event\n");
    }

    for (u = 0 ; u < 4 ; u++) {
        g_Semaphores[u] = CreateSemaphore (NULL, 1, 1, NULL);
        if (!g_Semaphores[u]) {
            fprintf (stderr, "Failed to init semaphores\n");
            exit (1);
        }

        g_FileThreadInfo[u].ThreadNumber = u;
        g_FileThreadInfo[u].GoEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        g_FileThreadInfo[u].DoneEvent = g_DoneEvent;
        if (!g_FileThreadInfo[u].GoEvent) {
            fprintf (stderr, "Failed to init thread info\n");
            exit (1);
        }

        g_FileThreads[u] = CreateThread (NULL, 0, pProcessFileThread, &g_FileThreadInfo[u], 0, NULL);
        if (!g_FileThreads[u]) {
            fprintf (stderr, "Failed to init threads\n");
            exit (1);
        }
    }
}


VOID
pStopFileThreads (
    VOID
    )
{
    SetEvent (g_DoneEvent);
    WaitForMultipleObjects (4, g_FileThreads, TRUE, INFINITE);
}


BOOL
pIsExcludedDir (
    IN      PCTSTR DirName
    )
{
    TCHAR DirId [MAX_PATH];
    PCTSTR NextPtr = NULL;

    NextPtr = _mbschr (DirName, '\\');
    if (!NextPtr) {
        NextPtr = GetEndOfString (DirName);
    }
    StringCopyAB (DirId, DirName, NextPtr);
    return (HtFindString (g_ExcludedDirsTable, DirId) != NULL);
}

BOOL
pCreateNtFileList (
    IN      PCSTR FileListDatPath
    )
{
    MEMDB_ENUM enumFiles;
    PSTR currentFile;
    BOOL result = FALSE;
    PSTR filePtr1 = NULL, filePtr2 = NULL;
    DWORD version = FILEGEN_VERSION;
    INT ExcludeType;
    INFCONTEXT context;
    BOOL found = FALSE;
    PSTR platform;
    PSTR product;
    PSTR destName;
    PSTR srcName;
    PSTR temp;
    PSTR key2;
    PSTR key3;
    PSTR extPtr;
    BOOL process = TRUE;
    DWORD offset;
    BOOL b;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    MEMDB_ENUM enumFiles2;
    CHAR string [MAX_MBCHAR_PATH];
    DWORD dontCare;
    PSTR fileSpec;
    HASHTABLE dupTable;

    __try {

        platform = AllocText (MAX_PATH);
        product = AllocText (MAX_PATH);
        destName = AllocText (MEMDB_MAX);
        srcName = AllocText (MEMDB_MAX);
        temp = AllocText (MEMDB_MAX);
        key2 = AllocText (MEMDB_MAX);
        key3 = AllocText (MEMDB_MAX);

        dupTable = HtAlloc();

        if (!platform || !product || !destName || !srcName || !temp || !key2 || !key3 || !dupTable) {
            __leave;
        }

        //pInitFileThreads();


        if (MemDbEnumFirstValue (
                &enumFiles,
                MEMDB_CATEGORY_INF_FILES TEXT("\\*"),
                MEMDB_ALL_SUBLEVELS,
                MEMDB_ENDPOINTS_ONLY
                )) {
            do {
                currentFile = enumFiles.szName;

                if (!StringMatch (currentFile, S_IGNORE_THIS_FILE)) {
                    process = TRUE;
                    if (g_StrictInfs) {
                        StringCopy (srcName, GetFileNameFromPath (currentFile));
                        extPtr = (PSTR)GetFileExtensionFromPath (srcName);
                        if (!StringIMatch (extPtr, "INF")) {
                            extPtr = _mbsdec (srcName, extPtr);
                            if (extPtr) {
                                *extPtr = 0;
                            }
                        }
                        MemDbBuildKey (temp, MEMDB_CATEGORY_NT_INSTALLED_INFS, srcName, NULL, NULL);
                        if (!MemDbGetValue (temp, NULL)) {
                            process = FALSE;
                        }
                    }

                    if (process) {
                        PEXCLUDED_INF_FILES excludedInf;

                        if (HtFindStringAndData (g_ExcludedInfsTable, currentFile, &excludedInf)) {
                            if (!excludedInf) {
                                //this means that the whole INF is excluded
                                printf ("Excluded: %s\n", currentFile);
                                process = FALSE;
                            }
                        }
                    }

                    if (process) {
                        printf ("Processing file : %s", currentFile);
                        //if (!pProcessFileDispatcher (currentFile)) {
                        if (!pProcessFile (currentFile)) {
                            DEBUGMSG ((DBG_ERROR, "Error while processing: %s", currentFile));
                        }
                        printf("\n");
                    }
                }

            } while (MemDbEnumNextValue (&enumFiles));
        }

        //pStopFileThreads();

        pLoadKnownFiles (g_AddnlInf, FALSE);

        // now let's write the filelist.dat file if we are on the right platform and product
        found = FALSE;
        if (SetupFindFirstLine (g_AddnlInf, TEXT("FILELIST.GENERATE"), NULL, &context)) {
            do {
                if (SetupGetStringField (&context, 1, platform, MAX_TCHAR_PATH, NULL) &&
                    SetupGetStringField (&context, 2, product, MAX_TCHAR_PATH, NULL) &&
                    StringIMatch (g_Platform, platform) &&
                    StringIMatch (g_Product, product)
                    ) {
                    found = TRUE;
                    break;
                }
            } while (SetupFindNextLine (&context, &context));
        }
        if (found) {

            fileHandle = CreateFile (
                            FileListDatPath,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
            if (fileHandle == INVALID_HANDLE_VALUE) {
                fprintf (stderr, "Cannot create output file : %s\n", FileListDatPath);
                __leave;
            }

            if (!WriteFile (fileHandle, &version, sizeof (DWORD), &dontCare, NULL)) {
                printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                __leave;
            }

            if (MemDbEnumFirstValue (
                    &enumFiles2,
                    MEMDB_CATEGORY_NT_KNOWN_FILES TEXT("\\*"),
                    MEMDB_ALL_SUBLEVELS,
                    MEMDB_ENDPOINTS_ONLY
                    )) {
                do {
                    MemDbBuildKeyFromOffset (enumFiles2.dwValue, key3, 1, NULL);

                    if (!pIsExcludedDir (key3)) {

                        filePtr1 = enumFiles2.szName;

                        //let's skip priority number

                        filePtr2 = _mbschr (filePtr1, '\\');
                        if (filePtr2 == NULL) {
                            DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles2.szName));
                            continue;
                        }

                        filePtr1 = _mbsinc (filePtr2);

                        filePtr2 = _mbschr (filePtr1, '\\');

                        if (filePtr2 == NULL) {
                            DEBUGMSG ((DBG_WARNING, "Bogus name found in NT_FILES: %S", enumFiles2.szName));
                            continue;
                        }

                        StringCopyAB (destName, filePtr1, filePtr2);

                        ExcludeType = pIsExcludedFile (destName);
                        if ((ExcludeType == -1) || (ExcludeType == 1)){

                            wsprintf (temp, "%s\\%s", key3, destName);

                            if (!HtFindString (dupTable, temp)) {
                                if (!WriteFile (fileHandle, key3, SizeOfString (key3), &dontCare, NULL)) {
                                    printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                                    __leave;
                                }

                                if (!WriteFile (fileHandle, destName, SizeOfString (destName), &dontCare, NULL)) {
                                    printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                                    __leave;
                                }

                                HtAddString (dupTable, temp);
                            }
                        }
                    }
                } while (MemDbEnumNextValue (&enumFiles2));
            }


            if (MemDbEnumFirstValue (
                    &enumFiles2,
                    TEXT(MEMDB_CATEGORY_NT_FILESA)TEXT("\\*"),
                    MEMDB_ALL_SUBLEVELS,
                    MEMDB_ENDPOINTS_ONLY
                    )) {
                do {
                    MemDbBuildKeyFromOffset (enumFiles2.dwValue, key3, 1, NULL);

                    if (!pIsExcludedDir (key3)) {

                        filePtr1 = enumFiles2.szName;

                        filePtr2 = _mbschr (filePtr1, '\\');
                        if (filePtr2 == NULL) {
                            StringCopy (destName, filePtr1);
                        } else {
                            StringCopyAB (destName, filePtr1, filePtr2);
                        }
                        ExcludeType = pIsExcludedFile (destName);
                        if ((ExcludeType == -1) || (ExcludeType == 1)){

                            if (!pIsKnownFile (key3, destName)) {

                                wsprintf (temp, "%s\\%s", key3, destName);

                                if (!HtFindString (dupTable, temp)) {
                                    //
                                    // Write file to list
                                    //

                                    if (!WriteFile (fileHandle, key3, SizeOfString (key3), &dontCare, NULL)) {
                                        printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                                        __leave;
                                    }

                                    if (!WriteFile (fileHandle, destName, SizeOfString (destName), &dontCare, NULL)) {
                                        printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                                        __leave;
                                    }

                                    HtAddString (dupTable, temp);
                                }

                            } else {
                                //
                                // Put overridden location in DelFiles list
                                //

                                pProcessDelFileSpec (key3, destName);
                            }
                        }
                    }
                } while (MemDbEnumNextValue (&enumFiles2));
            }
            * string = 0;
            if (!WriteFile (fileHandle, string, 1, &dontCare, NULL)) {
                printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                __leave;
            }

            // now it's the time to write the excluded files
            if (MemDbEnumFirstValue (
                    &enumFiles2,
                    TEXT(MEMDB_CATEGORY_NT_FILESA)TEXT("\\*"),
                    MEMDB_ALL_SUBLEVELS,
                    MEMDB_ENDPOINTS_ONLY
                    )) {
                do {

                    filePtr1 = enumFiles2.szName;

                    filePtr2 = _mbschr (filePtr1, '\\');
                    if (filePtr2 == NULL) {
                        StringCopy (destName, filePtr1);
                    } else {
                        StringCopyAB (destName, filePtr1, filePtr2);
                    }
                    ExcludeType = pIsExcludedFile (destName);
                    if (ExcludeType == 1) {
                        if (!WriteFile (fileHandle, destName, SizeOfString (destName), &dontCare, NULL)) {
                            printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                            __leave;
                        }
                    }
                } while (MemDbEnumNextValue (&enumFiles2));
            }
            * string = 0;
            if (!WriteFile (fileHandle, string, 1, &dontCare, NULL)) {
                printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                __leave;
            }

            // now it's the time to write the deleted files
            if (MemDbEnumFirstValue (
                    &enumFiles2,
                    MEMDB_CATEGORY_DEL_FILES TEXT("\\*"),
                    MEMDB_ALL_SUBLEVELS,
                    MEMDB_ENDPOINTS_ONLY
                    )) {
                do {

                    if (HtFindString (dupTable, enumFiles2.szName)) {
                        continue;
                    }

                    StringCopy (key3, enumFiles2.szName);
                    fileSpec = (PSTR) GetFileNameFromPath (key3);

                    if (!fileSpec) {
                        continue;
                    }

                    *_mbsdec (key3, fileSpec) = 0;

                    if (!WriteFile (fileHandle, key3, SizeOfString (key3), &dontCare, NULL)) {
                        printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                        __leave;
                    }

                    if (!WriteFile (fileHandle, fileSpec, SizeOfString (fileSpec), &dontCare, NULL)) {
                        printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                        __leave;
                    }
                } while (MemDbEnumNextValue (&enumFiles2));
            }

            *string = 0;
            if (!WriteFile (fileHandle, string, 1, &dontCare, NULL)) {
                printf ("Error writing to %s. Error=%u\n", FileListDatPath, GetLastError());
                __leave;
            }

        } else {
            fprintf (
                stderr,
                "Not generating %s.\nDid not find %s,%s in [FileList.Generate] section of %s.\n",
                FileListDatPath,
                g_Platform,
                g_Product,
                g_AddnlFile
                );
            // assume success
        }

        result = TRUE;
    }
    __finally {
        FreeText (platform);
        FreeText (product);
        FreeText (destName);
        FreeText (srcName);
        FreeText (temp);
        FreeText (key2);
        FreeText (key3);

        HtFree (dupTable);

        pCloseCachedHandles();

        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
    }

    return result;
}

BOOL
pLocalReadNtFileSection (
    IN      PCTSTR InfPath,
    IN      HINF  InfHandle,
    IN      HASHTABLE DirsTable,
    IN      PCTSTR SectName
    )
{
    INFCONTEXT context;
    PSTR fileName;
    PSTR dirNumber;
    PSTR destName;
    PSTR key;
    INT dispNumber;
    WORD userFlags;
    DWORD offset;
    BOOL result = TRUE;

    __try {

        fileName = AllocText (MAX_PATH);
        dirNumber = AllocText (MAX_PATH);
        destName = AllocText (MAX_PATH);
        key = AllocText (MEMDB_MAX);

        if (!fileName || !dirNumber || !destName || !key) {
            __leave;
        }

        if (SetupFindFirstLine (InfHandle, SectName, NULL, &context)) {
            do {
                if (!SetupGetOemStringField (&context, 0, fileName, MAX_TCHAR_PATH, NULL)) {
                    return result;
                }
                if (!SetupGetStringField (&context, DIRS_FIELD, dirNumber, MAX_TCHAR_PATH, NULL)) {
                    return result;
                }
                if (!SetupGetIntField (&context, DISP_FIELD, &dispNumber)) {
                    dispNumber = 3;
                }
                if (!SetupGetStringField (&context, DEST_FIELD, destName, MAX_TCHAR_PATH, NULL)) {
                    StringCopy (destName, fileName);
                }
                if (destName [0] == 0) {
                    StringCopy (destName, fileName);
                }
                if (dispNumber!=3) {

                    if (HtFindStringAndData (DirsTable, dirNumber, &offset)) {

                        userFlags = (dispNumber == 3) ? SRC_NEVER_COPY : 0;

                        pConvertSIFDir (dirNumber);
                        MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES, destName, fileName, GetFileNameFromPath (InfPath));
                        MemDbSetValueAndFlags (key, offset, userFlags, 0);
                        MemDbSetValueEx (
                            MEMDB_CATEGORY_NT_FILES_DOUBLED_COPY,
                            fileName,
                            GetFileNameFromPath (InfPath),
                            //TEXT("LAYOUT.INF"),
                            dirNumber,
                            0,
                            NULL
                            );
                        if (g_StrictInfs) {
                            MemDbSetValueEx (
                                MEMDB_CATEGORY_NT_INSTALLED_INFS,
                                fileName,
                                NULL,
                                NULL,
                                0,
                                NULL
                                );
                        }
                    }
                    else {
                        if (g_DoWarnings) {
                            MemDbSetValueEx (MEMDB_CATEGORY_NT_FILES_NODIR_COPY, fileName, NULL, NULL, 0, NULL);
                        }
                    }
                }
            } while (SetupFindNextLine (&context, &context));
        }
    }
    __finally {
        FreeText (fileName);
        FreeText (dirNumber);
        FreeText (destName);
        FreeText (key);
    }

    return result;
}

BOOL
pLocalReadNtDirs (
    IN      HINF  InfHandle,
    IN OUT  HASHTABLE DirsTable
    )
{
    INFCONTEXT context;
    TCHAR dirNumber[MAX_TCHAR_PATH];
    TCHAR dirString[MAX_TCHAR_PATH];
    PCTSTR dirStringPtr;
    PCTSTR fullPath;
    DWORD offset;
    BOOL result = TRUE;
    PSTR srcDir, destDir, wildCharPtr;
    PSTR resultTmp = NULL;
    PRENAMED_DIRS renamedDir;
    BOOL found;

    if (SetupFindFirstLine (InfHandle, TEXT("WinntDirectories"), NULL, &context)) {
        do {
            if (!SetupGetOemStringField (&context, 0, dirNumber, MAX_TCHAR_PATH, NULL)) {
                return result;
            }
            if (!SetupGetOemStringField (&context, 1, dirString, MAX_TCHAR_PATH, NULL)) {
                return result;
            }
            if (_tcsnextc (dirString) == TEXT('\\')) {
                dirStringPtr = _tcsinc (dirString);
            }
            else {
                dirStringPtr = dirString;
            }
            if (*dirStringPtr) {
                fullPath = JoinPaths ("10", dirStringPtr);
            }
            else {
                fullPath = DuplicatePathString ("10", 0);
            }
            // let's do some dir replacement here
            found = TRUE;
            while (found) {
                renamedDir = g_RenamedDirs;
                found = FALSE;
                while ((!found) && renamedDir) {
                    if (IsPatternMatch (renamedDir->SrcDir, fullPath)) {
                        srcDir = DuplicatePathString (renamedDir->SrcDir, 0);
                        destDir = DuplicatePathString (renamedDir->DestDir, 0);
                        wildCharPtr = _tcschr (srcDir, TEXT('*'));
                        if (wildCharPtr) {
                            *wildCharPtr = 0;
                        }
                        wildCharPtr = _tcschr (destDir, TEXT('*'));
                        if (wildCharPtr) {
                            *wildCharPtr = 0;
                        }
                        resultTmp = (PSTR)StringSearchAndReplace (fullPath, srcDir, destDir);
                        if (resultTmp) {
                            FreePathString (fullPath);
                            fullPath = resultTmp;
                            found = TRUE;
                        }
                        FreePathString (destDir);
                        FreePathString (srcDir);
                    }
                    renamedDir = renamedDir->Next;
                }
            }

            MemDbSetValueEx (
                MEMDB_CATEGORY_NT_DIRS,
                fullPath,
                NULL,
                NULL,
                0,
                &offset
                );
            HtAddStringAndData (DirsTable, dirNumber, &offset);
            FreePathString (fullPath);
        } while (SetupFindNextLine (&context, &context));
    }
    return result;
}

HASHTABLE g_DirsTable;

BOOL
pLocalReadNtFiles (
    IN      PCTSTR InfPath
    )
{
    BOOL result = TRUE;
    HINF infHandle;
    PCTSTR platformSect = NULL;

    infHandle = SetupOpenInfFile (InfPath, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (infHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    __try {
        if (!g_DirsTable) {
            g_DirsTable = HtAllocWithData (sizeof (DWORD));
        }
        if (g_DirsTable == NULL) {
            result = FALSE;
            __leave;
        }
        if (!pLocalReadNtDirs (infHandle, g_DirsTable)) {
            result = FALSE;
            __leave;
        }
        if (!pLocalReadNtFileSection (InfPath, infHandle, g_DirsTable, TEXT("SourceDisksfiles"))) {
            result = FALSE;
            __leave;
        }
        platformSect = JoinTextEx (NULL, TEXT("SourceDisksfiles"), g_Platform, TEXT("."), 0, NULL);
        if (!pLocalReadNtFileSection (InfPath, infHandle, g_DirsTable, platformSect)) {
            result = FALSE;
            __leave;
        }
    }
    __finally {
        if (platformSect) {
            FreeText (platformSect);
            platformSect = NULL;
        }
        SetupCloseInfFile (infHandle);
    }
    return result;
}



// the following functions are copied from hwcomp.c and slightly modified to allow recursive search
// and to bypass the exclusion list.

BOOL
LocalGetFileNames (
    IN      PCTSTR *InfDirs,
    IN      UINT InfDirCount,
    IN      BOOL QueryFlag
    )

/*++

Routine Description:

  LocalGetFileNames searches InfDirs for any file that ends with .INF or .IN_.
  It builds a MULTI_SZ list of file names that may contain PNP IDs.  All
  compressed INFs are decompressed into a temporary directory.

  If the QueryFlag is set, the file name list is prepared but no files
  are decompressed.

Arguments:

  InfDirs - A list of paths to the directory containing INFs, either
            compressed or non-compressed.

  InfDirCount - Specifies the number of dirs in the InfDirs array.

  QueryFlag - QUERYONLY if the function should build the file list but
              should not decompress; PERFORMCOMPLETEOP if the function
              should build the file list and decompress as needed.

Return Value:

  TRUE if successfull, FALSE if not.
  Call GetLastError for an error code.

--*/

{
    UINT u;

    //
    // Add list of files for each directory
    //

    g_TotalInfFiles = 0;

    for (u = 0 ; u < InfDirCount ; u++) {
        if (!pLocalGetFileNamesWorker (InfDirs[u], QueryFlag)) {
            return FALSE;
        }
    }

    MemDbSetValue (MEMDB_CATEGORY_SRC_INF_FILES_NR, g_TotalInfFiles);

    if (g_InfDatabase) {
        MemDbExport (MEMDB_CATEGORY_SRC_INF_FILES, g_InfDatabase, TRUE);
    }

    return TRUE;
}

BOOL
pIsDirectorySuppressed (
    IN      PCTSTR SubDirName
    )
{
    return (HtFindString (g_IgnoredDirsTable, SubDirName) != NULL);
}

BOOL
pSameInfFiles (
    IN      PCTSTR InfDir
    )
{
    TREE_ENUM e;
    PSTR key;
    PTSTR p;
    DWORD value;
    DWORD totalInfFiles = 0;
    BOOL result = TRUE;

    __try {

        key = AllocText (MEMDB_MAX);
        if (!key) {
            __leave;
        }

        if (EnumFirstFileInTreeEx (&e, InfDir, TEXT("*.in?"), FALSE, FALSE, 1)) {
            do {
                if (e.Directory) {
                    if (pIsDirectorySuppressed (e.SubPath)) {
                        AbortEnumCurrentDir (&e);
                    }

                } else if (IsPatternMatch (TEXT("*.in?"), e.Name)) {

                    //
                    // Make sure file has _ or f at the end.
                    //

                    p = GetEndOfString (e.FindData->cFileName);
                    MYASSERT (p != e.FindData->cFileName);
                    p = _tcsdec2 (e.FindData->cFileName, p);
                    MYASSERT (p);

                    if (!p) {
                        continue;
                    }

                    if (*p != TEXT('_') && _totlower (*p) != TEXT('f')) {
                        continue;
                    }

                    g_TotalInfFiles ++;
                    MemDbBuildKey (key, MEMDB_CATEGORY_SRC_INF_FILES, e.FullPath, NULL, NULL);
                    if (MemDbGetValue (key, &value)) {
                        if (*p == TEXT('_')) {
                            result = (value == e.FindData->nFileSizeLow);
                        } else {
                            result = (value == pComputeChecksum (e.FullPath));
                        }
                        if (!result) {
                            AbortEnumFileInTree (&e);
                            break;
                        }
                    } else {
                        result = FALSE;
                        AbortEnumFileInTree (&e);
                        break;
                    }
                }
            } while (EnumNextFileInTree (&e));
        }
    }
    __finally {
        FreeText (key);
    }

    return result;
}

BOOL
pShouldRescanInfs (
    IN      PCTSTR *InfDirs,
    IN      UINT InfDirCount
    )
{
    UINT u;
    DWORD value;
    BOOL result = FALSE;

    g_TotalInfFiles = 0;
    for (u = 0 ; u < InfDirCount ; u++) {
        if (!pSameInfFiles (InfDirs[u])) {
            return TRUE;
        }
    }

    if (MemDbGetValue (MEMDB_CATEGORY_SRC_INF_FILES_NR, &value)) {
        result = (value != g_TotalInfFiles);
    } else {
        result = TRUE;
    }

    return result;
}

BOOL
pLocalGetFileNamesWorker (
    IN      PCTSTR InfDir,
    IN      BOOL QueryFlag
    )

/*++

Routine Description:

  pLocalGetFileNamesWorker gets the file names for a single directory.
  See LocalGetFileNames for more details.

Arguments:

  InfDir - Specifies directory holding zero or more INFs (either
           compressed or non-compressed).

  QueryFlag - Specifies TRUE if INF list is to be queried, or
              FALSE if the list is to be fully processed.  When
              QueryFlag is TRUE, files are not decompressed or
              opened.

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    TREE_ENUM e;
    PSTR key;
    PTSTR p;
    PSTR ActualFile;
    PSTR AnsiFileName;
    PTSTR FileNameOnDisk;
    HANDLE hFile;
    DWORD BytesRead;
    PSTR UncompressedFile;
    PSTR CompressedFile;
    BOOL DecompressFlag;
    DWORD rc = ERROR_SUCCESS;
    BYTE BufForSp[2048];
    PSP_INF_INFORMATION psp;
    BOOL result = FALSE;

    __try {

        key = AllocText (MEMDB_MAX);
        ActualFile = AllocText (MAX_PATH);
        AnsiFileName = AllocText (MAX_PATH);
        UncompressedFile = AllocText (MAX_PATH);
        CompressedFile = AllocText (MAX_PATH);

        if (!key || !ActualFile || !AnsiFileName || !UncompressedFile || !CompressedFile) {
            __leave;
        }

        psp = (PSP_INF_INFORMATION) BufForSp;

        DEBUGMSG ((DBG_WARNING, "Enumerating %s", InfDir));

        //
        // Get file names
        //

        if (EnumFirstFileInTreeEx (&e, InfDir, TEXT("*.in?"), FALSE, FALSE, 1)) {

            rc = ERROR_SUCCESS;

            do {
                if (e.Directory) {
                    if (pIsDirectorySuppressed (e.SubPath)) {
                        AbortEnumCurrentDir (&e);
                    }

                } else if (IsPatternMatch (TEXT("*.in?"), e.Name)) {

                    //
                    // Make sure file has _ or f at the end.
                    //

                    p = GetEndOfString (e.FindData->cFileName);
                    MYASSERT (p != e.FindData->cFileName);
                    p = _tcsdec2 (e.FindData->cFileName, p);
                    MYASSERT (p);

                    if (!p) {
                        continue;
                    }

                    if (*p != TEXT('_') && _totlower (*p) != TEXT('f')) {
                        continue;
                    }

                    //
                    // add the file to the database list
                    //
                    g_TotalInfFiles ++;
                    MemDbBuildKey (key, MEMDB_CATEGORY_SRC_INF_FILES, e.FullPath, NULL, NULL);
                    if (*p == TEXT('_')) {
                        MemDbSetValue (key, e.FindData->nFileSizeLow);
                    } else {
                        MemDbSetValue (key, pComputeChecksum (e.FullPath));
                    }

                    //
                    // Default actual file to uncompressed name
                    //

                    StringCopy (ActualFile, e.FindData->cFileName);

                    //
                    // Build source file (CompressedFile)
                    //

                    StringCopy (CompressedFile, InfDir);
                    StringCopy (AppendWack (CompressedFile), e.SubPath);

                    //
                    // Build destination file (UncompressedFile) and detect collisions
                    //

                    StringCopy (UncompressedFile, g_TempDir);

                    //
                    // Create uncompressed file path
                    //

                    if (*p == TEXT('_')) {

                        //
                        // Extract real name from INF file at offset 0x3c
                        //

                        ActualFile[0] = 0;
                        hFile = CreateFile (
                                    CompressedFile,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

                        if (hFile != INVALID_HANDLE_VALUE) {

                            if (0xffffffff != SetFilePointer (hFile, 0x3c, NULL, FILE_BEGIN)) {

                                if (ReadFile (
                                        hFile,
                                        AnsiFileName,
                                        MAX_PATH,
                                        &BytesRead,
                                        NULL
                                        )) {

                                    if (BytesRead >= SizeOfString (e.FindData->cFileName)) {
                                        FileNameOnDisk = ConvertAtoT (AnsiFileName);

                                        if (StringIMatchCharCount (
                                                e.FindData->cFileName,
                                                FileNameOnDisk,
                                                CharCount (e.FindData->cFileName) - 1
                                                )) {

                                            //
                                            // Real name found -- use it as ActualFile
                                            //

                                            StringCopy (ActualFile, FileNameOnDisk);
                                            StringCopy (AppendWack (UncompressedFile), ActualFile);
                                        }

                                        FreeAtoT (FileNameOnDisk);
                                    }
                                }
                            }

                            CloseHandle (hFile);
                        }

                        //
                        // If file name could not be found, discard this file
                        //

                        if (!ActualFile[0]) {
                            DEBUGMSG ((DBG_WARNING, "%s is not an INF file", e.FindData->cFileName));
                            continue;
                        }

                        DecompressFlag = TRUE;

                    } else {
                        StringCopy (AppendWack (UncompressedFile), ActualFile);

                        DecompressFlag = FALSE;
                    }

                    //
                    // Skip excluded files
                    //

                    if (!QueryFlag) {

                        //
                        // Uncompress file if necessary
                        //

    /*
                        DEBUGMSG_IF ((
                            DoesFileExist (UncompressedFile),
                            DBG_WARNING,
                            "%s already exists and will be deleted",
                            UncompressedFile
                            ));
    */

                        if (DecompressFlag) {

                            SetFileAttributes (UncompressedFile, FILE_ATTRIBUTE_NORMAL);
                            DeleteFile (UncompressedFile);

                            rc = SetupDecompressOrCopyFile (CompressedFile, UncompressedFile, 0);

                            if (rc != ERROR_SUCCESS) {
                                DEBUGMSG ((DBG_WARNING, "pLocalGetFileNamesWorker: Could not decompress %s to %s", CompressedFile, UncompressedFile));
                                fprintf (
                                    stderr,
                                    "Could not copy %s to %s. Error %u.",
                                    CompressedFile,
                                    UncompressedFile,
                                    GetLastError()
                                    );
                                break;
                            }
                        } else {
                            CopyFile (CompressedFile, UncompressedFile, FALSE);
                        }

                        //
                        // Determine if this is an NT 4 INF
                        //

                        if (!SetupGetInfInformation (
                                UncompressedFile,
                                INFINFO_INF_NAME_IS_ABSOLUTE,
                                psp,
                                sizeof (BufForSp),
                                NULL) ||
                                psp->InfStyle != INF_STYLE_WIN4
                            ) {

                            //DEBUGMSG ((DBG_WARNING, "%s is not a WIN4 INF file", UncompressedFile));

                            if (!QueryFlag) {
                                DeleteFile (UncompressedFile);
                            }
                            StringCopy (UncompressedFile, S_IGNORE_THIS_FILE);
                        }

                    }

                    //
                    // Add file to grow buffer
                    //
                    MemDbSetValueEx (MEMDB_CATEGORY_INF_FILES, UncompressedFile, NULL, NULL, 0, NULL);
                }

                MYASSERT (rc == ERROR_SUCCESS);

            } while (EnumNextFileInTree (&e));
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            DEBUGMSG ((DBG_WARNING, "pLocalGetFileNamesWorker: Error encountered in loop"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        FreeText (key);
        FreeText (ActualFile);
        FreeText (AnsiFileName);
        FreeText (UncompressedFile);
        FreeText (CompressedFile);
    }

    return result;
}


VOID
LocalFreeFileNames (
    IN      BOOL QueryFlag
    )

/*++

Routine Description:

  LocalFreeFileNames cleans up the list generated by LocalGetFileNames.  If
  QueryFlag is set to PERFORMCOMPLETEOP, all temporary decompressed
  files are deleted.

Arguments:

  FileNames - The same grow buffer passed to LocalGetFileNames
  QueryFlag - The same flag passed to LocalGetFileNames

Return Value:

  none

--*/

{
    MEMDB_ENUM enumFiles;

    if (MemDbEnumFirstValue (
            &enumFiles,
            MEMDB_CATEGORY_INF_FILES TEXT("\\*"),
            MEMDB_ALL_SUBLEVELS,
            MEMDB_ENDPOINTS_ONLY
            )) {
        do {
            if (StringIMatchCharCount (enumFiles.szName, g_TempDirWack, g_TempDirWackChars)) {
                SetFileAttributes (enumFiles.szName, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (enumFiles.szName);
            }
        } while (MemDbEnumNextValue (&enumFiles));
    }
    MemDbDeleteTree (MEMDB_CATEGORY_INF_FILES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\extract\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDD_COMPARE                     101
#define IDC_ICON1                       200
#define IDC_ICON2                       201
#define IDC_FILE_NAME1                  1001
#define IDC_FILE_NAME2                  1003
#define IDC_RESOURCE_ID                 1004
#define IDC_PREV                        1005
#define IDC_NEXT                        1006
#define IDC_MATCH                       1007
#define IDC_PARTIAL                     1008
#define IDC_NO_MATCH                    1009
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hkcrtool\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\filegen\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\ftp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDD_STATUS                      101
#define IDC_URL                         1000
#define IDC_MSG2                        1001
#define IDC_RETRIES                     1002
#define IDC_MSG1                        -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hkcrtool\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\ftp\ftp.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    TODO: cmntool.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "resource.h"
#include <wininet.h>

typedef enum {
    DOWNLOAD_CONNECTING,
    DOWNLOAD_GETTING_FILE,
    DOWNLOAD_DISCONNECTING
} DOWNLOADSTATE;



typedef HINTERNET (WINAPI * INTERNETOPEN) (
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxyName,
    IN LPCSTR lpszProxyBypass,
    IN DWORD dwFlags
    );

typedef BOOL (WINAPI * INTERNETCLOSEHANDLE) (
    IN HINTERNET Handle
    );

typedef HINTERNET (WINAPI * INTERNETOPENURL) (
    IN HINTERNET hInternetSession,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

typedef BOOL (WINAPI * INTERNETREADFILE) (
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpNumberOfBytesRead
    );

typedef BOOL (WINAPI * INTERNETCANONICALIZEURLA) (
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );

typedef DWORD (WINAPI * INTERNETSETFILEPOINTER) (
    IN HINTERNET hFile,
    IN LONG lDistanceToMove,
    IN PVOID pReserved,
    IN DWORD dwMoveMethod,
    IN DWORD dwContext
    );

typedef BOOL (WINAPI * INTERNETHANGUP) (
    IN DWORD dwConnection,
    IN DWORD dwReserved
    );

typedef DWORD (WINAPI * INTERNETDIALA) (
    IN HWND hwndParent,
    IN PCSTR lpszConnectoid,
    IN DWORD dwFlags,
    OUT LPDWORD lpdwConnection,
    IN DWORD dwReserved
    );

static HINSTANCE g_Lib;
static INTERNETOPEN g_InternetOpenA;
static INTERNETCLOSEHANDLE g_InternetCloseHandle;
static INTERNETOPENURL g_InternetOpenUrlA;
static INTERNETREADFILE g_InternetReadFile;
static INTERNETCANONICALIZEURLA g_InternetCanonicalizeUrlA;
static INTERNETSETFILEPOINTER g_InternetSetFilePointer;
static INTERNETDIALA g_InternetDialA;
static INTERNETHANGUP g_InternetHangUp;

static BOOL g_Dialed;
static DWORD g_Cxn;

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

PCSTR g_AppName = TEXT("FTP Download Engine");
//PCSTR g_DirFile = TEXT("ftp://jimschm-dev/upgdir.inf");
PCSTR g_DirFile = TEXT("file://popcorn/public/jimschm/upgdir.inf");

BOOL
DownloadUpdates (
    HANDLE CancelEvent,             OPTIONAL
    HANDLE WantToRetryEvent,        OPTIONAL
    HANDLE OkToRetryEvent,          OPTIONAL
    PCSTR *Url                      OPTIONAL
    );

BOOL
pDownloadUpdatesWithUi (
    VOID
    );

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    //
    // TODO: Add others here if needed (don't forget to prototype above)
    //

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        TEXT("  cmntool [/F:file]\n")

        TEXT("\nDescription:\n\n")

        //
        // TODO: Describe tool, indent 2 spaces
        //

        TEXT("  cmntool is a stub!\n")

        TEXT("\nArguments:\n\n")

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        TEXT("  /F  Specifies optional file name\n")

        );

    exit (1);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('f'):
                //
                // Sample option - /f:file
                //

                if (argv[i][2] == TEXT(':')) {
                    FileArg = &argv[i][3];
                } else if (i + 1 < argc) {
                    FileArg = argv[++i];
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            // None
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // TODO: Do work here
    //

    pDownloadUpdatesWithUi();

    //
    // End of processing
    //

    Terminate();

    return 0;
}

typedef struct {
    HANDLE CancelEvent;
    HANDLE WantToRetryEvent;
    HANDLE OkToRetryEvent;
    HANDLE CloseEvent;
    PCSTR Url;
} EVENTSTRUCT, *PEVENTSTRUCT;


BOOL
CALLBACK
pUiDlgProc (
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PEVENTSTRUCT eventStruct;
    static UINT retries;
    DWORD rc;
    CHAR lastUrl[256];
    CHAR text[256];

    switch (msg) {

    case WM_INITDIALOG:
        eventStruct = (PEVENTSTRUCT) lParam;
        retries = 0;
        lastUrl[0] = 0;
        SetTimer (hdlg, 1, 100, NULL);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDCANCEL:
            ShowWindow (GetDlgItem (hdlg, IDC_MSG2), SW_HIDE);
            ShowWindow (GetDlgItem (hdlg, IDC_URL), SW_HIDE);
            ShowWindow (GetDlgItem (hdlg, IDC_RETRIES), SW_HIDE);

            SetDlgItemTextA (hdlg, IDC_MSG1, "Stopping download...");

            SetFocus (GetDlgItem (hdlg, IDC_MSG1));
            EnableWindow (GetDlgItem (hdlg, IDCANCEL), FALSE);

            SetEvent (eventStruct->CancelEvent);

            break;
        }

        break;

    case WM_TIMER:
        //
        // Check the events
        //

        rc = WaitForSingleObject (eventStruct->WantToRetryEvent, 0);

        if (rc == WAIT_OBJECT_0) {
            //
            // A download failed.  Try again?
            //

            if (StringCompareA (lastUrl, eventStruct->Url)) {
                retries = 0;
            }

            StackStringCopy (lastUrl, eventStruct->Url);

            retries++;

            if (retries > 5) {
                //
                // Too many retries -- give up!
                //

                SetEvent (eventStruct->CancelEvent);

            } else {
                //
                // Retry
                //

                wsprintfA (text, "on attempt %u.  Retrying.", retries);
                SetDlgItemText (hdlg, IDC_RETRIES, text);

                if (eventStruct->Url) {
                    SetDlgItemText (hdlg, IDC_URL, eventStruct->Url);
                }

                ShowWindow (GetDlgItem (hdlg, IDC_MSG2), SW_SHOW);
                ShowWindow (GetDlgItem (hdlg, IDC_URL), SW_SHOW);
                ShowWindow (GetDlgItem (hdlg, IDC_RETRIES), SW_SHOW);

                SetEvent (eventStruct->OkToRetryEvent);
            }
        }

        rc = WaitForSingleObject (eventStruct->CloseEvent, 0);

        if (rc == WAIT_OBJECT_0) {
            EndDialog (hdlg, IDCANCEL);
        }

        return TRUE;

    case WM_DESTROY:
        KillTimer (hdlg, 1);
        break;

    }

    return FALSE;
}



DWORD
WINAPI
pUiThread (
    PVOID   Arg
    )
{
    DialogBoxParam (
        g_hInst,
        (PCTSTR) IDD_STATUS,
        NULL,
        pUiDlgProc,
        (LPARAM) Arg
        );

    return 0;
}

HANDLE
pCreateUiThread (
    PEVENTSTRUCT EventStruct
    )
{
    HANDLE h;
    DWORD threadId;

    h = CreateThread (NULL, 0, pUiThread, EventStruct, 0, &threadId);

    return h;
}


BOOL
pDownloadUpdatesWithUi (
    VOID
    )
{
    EVENTSTRUCT es;
    BOOL b = FALSE;
    HANDLE h;

    //
    // Create the events
    //

    es.CancelEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    es.WantToRetryEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    es.OkToRetryEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    es.CloseEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

    es.Url = NULL;

    if (!es.CancelEvent || !es.WantToRetryEvent ||
        !es.OkToRetryEvent || !es.CloseEvent
        ) {
        DEBUGMSG ((DBG_ERROR, "Can't create events"));
        return FALSE;
    }

    //
    // Start the UI
    //

    h = pCreateUiThread (&es);

    if (!h) {
        DEBUGMSG ((DBG_ERROR, "Can't create UI thread"));
    } else {

        //
        // Perform the download
        //

        b = DownloadUpdates (
                es.CancelEvent,
                es.WantToRetryEvent,
                es.OkToRetryEvent,
                &es.Url
                );

        //
        // End the UI
        //

        SetEvent (es.CloseEvent);
        WaitForSingleObject (h, INFINITE);
    }

    //
    // Cleanup & exit
    //

    CloseHandle (es.CancelEvent);
    CloseHandle (es.WantToRetryEvent);
    CloseHandle (es.OkToRetryEvent);
    CloseHandle (es.CloseEvent);

    return b;
}


BOOL
pOpenWinInetSupport (
    VOID
    )
{
    g_Lib = LoadLibrary (TEXT("wininet.dll"));

    if (!g_Lib) {
        return FALSE;
    }

    (FARPROC) g_InternetOpenA = GetProcAddress (g_Lib, "InternetOpenA");
    (FARPROC) g_InternetCloseHandle = GetProcAddress (g_Lib, "InternetCloseHandle");
    (FARPROC) g_InternetOpenUrlA = GetProcAddress (g_Lib, "InternetOpenUrlA");
    (FARPROC) g_InternetReadFile = GetProcAddress (g_Lib, "InternetReadFile");
    (FARPROC) g_InternetCanonicalizeUrlA = GetProcAddress (g_Lib, "InternetCanonicalizeUrlA");
    (FARPROC) g_InternetSetFilePointer = GetProcAddress (g_Lib, "InternetSetFilePointer");
    (FARPROC) g_InternetHangUp = GetProcAddress (g_Lib, "InternetHangUp");
    (FARPROC) g_InternetDialA = GetProcAddress (g_Lib, "InternetDialA");

    if (!g_InternetOpenA || !g_InternetOpenUrlA || !g_InternetReadFile ||
        !g_InternetCloseHandle || !g_InternetCanonicalizeUrlA ||
        !g_InternetSetFilePointer || !g_InternetDialA || !g_InternetHangUp
        ) {
        return FALSE;
    }

    return TRUE;
}


VOID
pCloseWinInetSupport (
    VOID
    )
{
    FreeLibrary (g_Lib);
    g_Lib = NULL;
    g_InternetOpenA = NULL;
    g_InternetOpenUrlA = NULL;
    g_InternetReadFile = NULL;
    g_InternetCloseHandle = NULL;
    g_InternetCanonicalizeUrlA = NULL;
    g_InternetSetFilePointer = NULL;
    g_InternetDialA = NULL;
    g_InternetHangUp = NULL;
}


BOOL
pDownloadFile (
    HINTERNET Session,
    PCSTR RemoteFileUrl,
    PCSTR LocalFile,
    HANDLE CancelEvent
    )
{
    HINTERNET connection;
    PBYTE buffer = NULL;
    UINT size = 65536;
    DWORD bytesRead;
    DWORD dontCare;
    HANDLE file = INVALID_HANDLE_VALUE;
    BOOL b = FALSE;

    //
    // Establish connection to the file
    //

    connection = g_InternetOpenUrlA (
                        Session,
                        RemoteFileUrl,
                        NULL,
                        0,
                        INTERNET_FLAG_RELOAD,   //INTERNET_FLAG_NO_UI
                        0
                        );

    if (!connection) {
        DEBUGMSGA ((DBG_ERROR "Can't connect to %s", RemoteFileUrl));
        return FALSE;
    }

    __try {

        //
        // Create the local file
        //

        file = CreateFileA (
                    LocalFile,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        if (file == INVALID_HANDLE_VALUE) {
            DEBUGMSGA ((DBG_ERROR, "Can't create %s", LocalFile));
            __leave;
        }

        //
        // Allocate a big buffer for downloading
        //

        buffer = MemAlloc (g_hHeap, 0, size);
        if (!buffer) {
            __leave;
        }

        //
        // Download the file
        //

        for (;;) {

            if (WAIT_OBJECT_0 == WaitForSingleObject (CancelEvent, 0)) {
                DEBUGMSG ((DBG_VERBOSE, "User cancellation detected"));
                __leave;
            }

            if (!g_InternetReadFile (connection, buffer, size, &bytesRead)) {
                DEBUGMSGA ((DBG_ERROR, "Error downloading %s", RemoteFileUrl));
                __leave;
            }

            if (!bytesRead) {
                break;
            }

            if (!WriteFile (file, buffer, bytesRead, &dontCare, NULL)) {
                DEBUGMSGA ((DBG_ERROR, "Error writing to %s", LocalFile));
                __leave;
            }
        }

        b = TRUE;
    }
    __finally {

        g_InternetCloseHandle (connection);

        CloseHandle (file);

        if (!b) {
            DeleteFileA (LocalFile);
        }

        if (buffer) {
            MemFree (g_hHeap, 0, buffer);
        }
    }

    return b;
}



BOOL
pDownloadFileWithRetry (
    IN      HINTERNET Session,
    IN      PCSTR Url,
    IN      PCSTR DestFile,
    IN      HANDLE CancelEvent,             OPTIONAL
    IN      HANDLE WantToRetryEvent,        OPTIONAL
    IN      HANDLE OkToRetryEvent           OPTIONAL
    )

/*++

Routine Description:

  pDownloadFileWithRetry downloads a URL to a local file, as specified by the
  caller.  If CancelEvent is specified, then the caller can stop the download
  by setting the event.

  This function implements a retry mechanism via events.  If the caller
  specifies WantToRetryEvent and OkToRetryEvent, then this routine will allow
  the caller an opportunity to retry a failed download.

  The retry protocol is as follows:

    - Caller establishes a wait on WantToRetryEvent, then calls DownloadUpdates
    - Error occurs downloading one of the files
    - WantToRetryEvent is set by this routine
    - Caller's wait wakes up
    - Caller asks user if they want to retry
    - Caller sets CancelEvent or OkToRetryEvent, depending on user choice
    - This routine wakes up and either retries or aborts

  The caller must create all three events as auto-reset events in the
  non-signaled state.

Arguments:

  Session          - Specifies the handle to an open internet session.
  Url              - Specifies the URL to download.
  DestFile         - Specifies the local path to download the file to.
  CancelEvent      - Specifies the handle to a caller-owned event. When this
                     event is set, the function will return FALSE and
                     GetLastError will return ERROR_CANCELLED.
  WantToRetryEvent - Specifies the caller-owned event that is set when a
                     download error occurs.  The caller should be waiting on
                     this event before calling DownloadUpdates.
  OkToRetry        - Specifies the caller-owned event that will be set in
                     response to a user's request to retry.

Return Value:

  TRUE if the file was downloaded, FALSE if the user decides to cancel the
  download.

--*/

{
    BOOL fail;
    HANDLE waitArray[2];
    DWORD rc;

    //
    // Loop until success, user decides to cancel, or user decides
    // not to retry on error
    //

    for (;;) {

        fail = FALSE;

        if (!pDownloadFile (Session, Url, DestFile, CancelEvent)) {

            fail = TRUE;

            if (GetLastError() != ERROR_CANCELLED &&
                CancelEvent && WantToRetryEvent && OkToRetryEvent
                ) {

                //
                // We set the WantToRetryEvent.  The UI thread should
                // be waiting on this.  The UI thread will then ask
                // the user if they want to retry or cancel.  If the
                // user wants to retry, the UI thread will set the
                // OkToRetryEvent.  If the user wants to cancel, the
                // UI thread will set the CancelEvent.
                //

                SetEvent (WantToRetryEvent);

                waitArray[0] = CancelEvent;
                waitArray[1] = OkToRetryEvent;

                rc = WaitForMultipleObjects (2, waitArray, FALSE, INFINITE);

                if (rc == WAIT_OBJECT_0 + 1) {
                    continue;
                }

                //
                // We fail
                //

                SetLastError (ERROR_CANCELLED);
            }
        }

        break;
    }

    return !fail;
}


VOID
pGoOffline (
    VOID
    )
{
    if (g_Dialed) {
        g_Dialed = FALSE;

        g_InternetHangUp (g_Cxn, 0);
    }
}


BOOL
pGoOnline (
    HINTERNET Session
    )
{
    HINTERNET connection;

    if (g_Dialed) {
        pGoOffline();
    }

    //
    // Check if we are online
    //

    connection = g_InternetOpenUrlA (
                        Session,
                        "http://www.microsoft.com/",
                        NULL,
                        0,
                        INTERNET_FLAG_RELOAD,
                        0
                        );

    if (connection) {
        DEBUGMSG ((DBG_VERBOSE, "Able to connect to www.microsoft.com"));
        g_InternetCloseHandle (connection);
        return TRUE;
    }

    //
    // Unable to contact www.microsoft.com.  Possibilities:
    //
    //  - net cable unplugged
    //  - firewall without a proxy
    //  - no online connection (i.e., need to dial ISP)
    //  - www.microsoft.com or some part of the Internet is down
    //  - user has no Internet access at all
    //
    // Try RAS, then try connection again.
    //

    g_InternetDialA (NULL, NULL, INTERNET_AUTODIAL_FORCE_ONLINE, &g_Cxn, 0);

    g_Dialed = TRUE;

    connection = g_InternetOpenUrlA (
                        Session,
                        "http://www.microsoft.com/",
                        NULL,
                        0,
                        INTERNET_FLAG_RELOAD,
                        0
                        );

    if (connection) {
        DEBUGMSG ((DBG_VERBOSE, "Able to connect to www.microsoft.com via RAS"));
        g_InternetCloseHandle (connection);
        return TRUE;
    }

    pGoOffline();

    return FALSE;
}


BOOL
DownloadUpdates (
    HANDLE CancelEvent,             OPTIONAL
    HANDLE WantToRetryEvent,        OPTIONAL
    HANDLE OkToRetryEvent,          OPTIONAL
    PCSTR *StatusUrl                OPTIONAL
    )
{
    HINTERNET session;
    CHAR url[MAX_PATH];
    DWORD size;
    BOOL b = FALSE;
    CHAR tempPath[MAX_TCHAR_PATH];
    CHAR dirFile[MAX_TCHAR_PATH];
    HINF inf;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCSTR p;
    PCSTR q;

    if (!pOpenWinInetSupport()) {
        DEBUGMSG ((DBG_ERROR, "Can't open wininet.dll"));
        return FALSE;
    }

    __try {

        session = g_InternetOpenA (
                        g_AppName,
                        INTERNET_OPEN_TYPE_PRECONFIG,
                        NULL,
                        NULL,
                        0
                        );

        if (!session) {
            DEBUGMSG ((DBG_ERROR, "InternetOpen returned NULL"));
            SetLastError (ERROR_NOT_CONNECTED);
            __leave;
        }

        if (!pGoOnline (session)) {
            DEBUGMSG ((DBG_ERROR, "Can't go online"));
            SetLastError (ERROR_NOT_CONNECTED);
            __leave;
        }

        size = ARRAYSIZE(url);

        if (!g_InternetCanonicalizeUrlA (g_DirFile, url, &size, 0)) {
            DEBUGMSGA ((DBG_ERROR, "Can't canonicalize %s", g_DirFile));
            SetLastError (ERROR_CONNECTION_ABORTED);
            __leave;
        }

        GetTempPathA (ARRAYSIZE(tempPath), tempPath);
        GetTempFileNameA (tempPath, "ftp", 0, dirFile);

        if (StatusUrl) {
            *StatusUrl = url;
        }

        if (!pDownloadFileWithRetry (
                session,
                url,
                dirFile,
                CancelEvent,
                WantToRetryEvent,
                OkToRetryEvent
                )) {

            DEBUGMSGA ((DBG_ERROR, "Can't download %s", url));

            // last error set to a valid return condition

            __leave;
        }

        inf = InfOpenInfFileA (dirFile);

        if (inf == INVALID_HANDLE_VALUE) {
            DEBUGMSGA ((DBG_ERROR, "Can't open %s", dirFile));

            // last error set to the reason of the INF failure

            __leave;
        }

        __try {
            if (InfFindFirstLineA (inf, "Win9xUpg", NULL, &is)) {

                do {

                    p = InfGetStringFieldA (&is, 1);
                    q = InfGetStringFieldA (&is, 2);

                    if (!p || !q) {
                        continue;
                    }

                    q = ExpandEnvironmentTextA (q);

                    size = ARRAYSIZE(url);

                    if (!g_InternetCanonicalizeUrlA (p, url, &size, 0)) {
                        DEBUGMSGA ((DBG_ERROR, "Can't canonicalize INF-specified URL: %s", p));
                        SetLastError (ERROR_CONNECTION_ABORTED);
                        __leave;
                    }

                    if (!pDownloadFileWithRetry (
                            session,
                            url,
                            q,
                            CancelEvent,
                            WantToRetryEvent,
                            OkToRetryEvent
                            )) {

                        FreeTextA (q);

                        DEBUGMSGA ((DBG_ERROR, "Can't download INF-specified URL: %s", url));

                        // last error set to a valid return code

                        __leave;

                    }

                    FreeTextA (q);

                } while (InfFindNextLine (&is));
            }

        }
        __finally {
            InfCloseInfFile (inf);
        }

    }
    __finally {
        if (session) {
            g_InternetCloseHandle (session);
        }

        InfCleanUpInfStruct (&is);
        DeleteFileA (dirFile);

        pGoOffline();

        pCloseWinInetSupport();
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\ftp\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hashpwd\hashpwd.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hashpwd.c

Abstract:

    Implements a tool that outputs the encrypted form of an input clear-text password

Author:

    Ovidiu Temereanca (ovidiut) 27-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include "encrypt.h"

INT
__cdecl
_tmain (
    INT argc,
    TCHAR *argv[]
    )
{
    LONG rc;
    TCHAR owfPwd[STRING_ENCODED_PASSWORD_SIZE];

    if (argc < 2 ||
        ((argv[1][0] == TEXT('/') || argv[1][0] == TEXT('-')) && argv[1][1] == TEXT('?'))) {
        _tprintf (TEXT("Usage:\n")
                  TEXT("    hashpwd <password>\n")
                  TEXT("Use quotes if <password> contains spaces\n")
                  );
        return 1;
    }

    if (StringEncodeOwfPassword (argv[1], owfPwd, NULL)) {
        _tprintf (TEXT("%s=%s\n"), argv[1], owfPwd);
    } else {
        _ftprintf (stderr, TEXT("StringEncodeOwfPassword failed\n"));
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hashpwd\pch.h ===
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hugecopy\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hwdatdmp\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hwdatgen\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hwwiz\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hwwiz\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hkcrtool\hkcrtool.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hkcrtool.c

Abstract:

    Implements a stub tool that is designed to run with NT-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();
}


INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{
    REGKEY_ENUM e1, e;
    HKEY Key;
    BOOL b;
    PCTSTR Data;
    TCHAR KeyName[MAX_REGISTRY_KEY];

    if (!Init()) {
        wprintf (L"Unable to initialize!\n");
        return 255;
    }

    if (1) {
        _tprintf (TEXT("Keys in CLSID that are in TypeLib too:\n\n"));

        if (EnumFirstRegKeyStr (&e1, TEXT("HKLM\\Software\\Classes\\CLSID"))) {
            do {
                wsprintf (KeyName, TEXT("HKLM\\Software\\Classes\\TypeLib\\%s"), e1.SubKeyName);
                Key = OpenRegKeyStr (KeyName);

                if (Key) {
                    _tprintf (TEXT("%s\n"), e1.SubKeyName);
                    CloseRegKey (Key);
                }
            } while (EnumNextRegKey (&e1));
        }
    }

    else if (0) {

        _tprintf (TEXT("Overwritable GUIDs:\n\n"));

        if (EnumFirstRegKeyStr (&e1, TEXT("HKLM\\Software\\Classes\\CLSID"))) {
            do {
                Key = OpenRegKey (e1.KeyHandle, e1.SubKeyName);
                b = TRUE;

                if (EnumFirstRegKey (&e, Key)) {
                    do {
                        if (StringIMatchCharCount (e.SubKeyName, TEXT("Inproc"), 6) ||
                            StringIMatch (e.SubKeyName, TEXT("LocalServer")) ||
                            StringIMatch (e.SubKeyName, TEXT("LocalServer32")) ||
                            StringIMatch (e.SubKeyName, TEXT("ProxyStubClsid32"))
                            ) {
                            b = FALSE;
                            break;
                        }
                    } while (EnumNextRegKey (&e));
                }

                if (b) {
                    Data = (PCTSTR) GetRegKeyData (e1.KeyHandle, e1.SubKeyName);
                    if (Data && *Data) {
                        _tprintf (TEXT("  %s\n"), Data);
                        MemFree (g_hHeap, 0, Data);
                    } else {
                        _tprintf (TEXT("  GUID: %s\n"), e1.SubKeyName);
                    }

                    if (EnumFirstRegKey (&e, Key)) {
                        do {
                            _tprintf (TEXT("    %s\n"), e.SubKeyName);
                        } while (EnumNextRegKey (&e));
                    }
                }

                CloseRegKey (Key);
            } while (EnumNextRegKey (&e1));
        }
    }


    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hwdatdmp\pch.h ===
#include "master.h"
#include "masterhw.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hugecopy\hugecopy.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hugecopy.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    //
    // TODO: Add others here if needed (don't forget to prototype above)
    //

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        TEXT("  hugecopy <source> <destination>\n")

        TEXT("\nDescription:\n\n")

        //
        // TODO: Describe tool, indent 2 spaces
        //

        TEXT("  hugecopy copies a file that has a path longer than MAX_PATH\n")

        TEXT("\nArguments:\n\n")

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        TEXT("  source      - Specifies the file to copy\n")
        TEXT("  destination - Specifies the name and path of the new copy\n")
        TEXT("\n")
        TEXT("NOTE: both source and destination must contain a file name, and\n")
        TEXT("      they cannot contain wildcard characters\n")

        );

    exit (1);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR src = NULL;
    PCTSTR dest = NULL;
    PCWSTR decoratedSrc;
    PCWSTR decoratedDest;
    WCHAR bigSrc[MAX_PATH * 8];
    WCHAR bigDest[MAX_PATH * 8];
    BOOL b;
    PCWSTR unicodeSrc;
    PCWSTR unicodeDest;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (!src) {
                src = argv[i];
            } else if (!dest) {
                dest = argv[i];
            } else {
                HelpAndExit();
            }
        }
    }

    if (!dest) {
        HelpAndExit();
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    unicodeSrc = CreateUnicode (src);
    unicodeDest = CreateUnicode (dest);

    if (!GetFullPathNameW (unicodeSrc, ARRAYSIZE(bigSrc), bigSrc, NULL)) {
        StackStringCopyW (bigSrc, unicodeSrc);
    }

    if (!GetFullPathNameW (unicodeDest, ARRAYSIZE(bigDest), bigDest, NULL)) {
        StackStringCopyW (bigDest, unicodeDest);
    }

    decoratedSrc = JoinPathsW (L"\\\\?", bigSrc);
    decoratedDest = JoinPathsW (L"\\\\?", bigDest);

    b = CopyFileW (decoratedSrc, decoratedDest, FALSE);
    if (b) {
        printf ("%s -> %s\n", src, dest);
    } else {
        wprintf (L"%s -> %s\n", decoratedSrc, decoratedDest);
        printf ("Copy failed, error=%u\n", GetLastError());
    }

    DestroyUnicode (unicodeSrc);
    DestroyUnicode (unicodeDest);

    FreePathStringW (decoratedSrc);
    FreePathStringW (decoratedDest);

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hwdatdmp\hwdatdmp.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hwdatgen.c

Abstract:

    This module creates a tool that generates hwcomp.dat and is designed for us by
    the NT build lab.  It simply calls the code in hwcomp.lib, the same code that
    the Win9x upgrade uses to determine incompatibilities.

Author:

    Jim Schmidt (jimschm) 12-Oct-1996

Revision History:

    <alias> <date> <comments>

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "miglib.h"

VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "hwdatdmp [<hwcomp.dat path>] [/i]\n\n"
            "Optional Arguments:\n"
            "  <hwcomp.dat path>  - Specifies path to hwcomp.dat\n\n"
            "  /i Shows PNP IDs only without the INF file\n"
            "\n");

    exit(255);
}




INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    PSTR InputPath = NULL;
    INT i;
    BOOL ShowInfs = TRUE;

    //
    // Parse command line
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {

            switch (tolower (argv[i][1])) {

            case 'i':
                ShowInfs = FALSE;
                break;

            default:
                HelpAndExit();
            }

        } else {
            if (InputPath) {
                HelpAndExit();
            }

            InputPath = argv[i];
        }
    }

    if (!InputPath) {
        InputPath = "hwcomp.dat";
    }

    printf ("Input path: '%s'\n\n", InputPath);

    //
    // Init migutil.lib
    //

    InitializeMigLib();

    //
    // Dump hwcomp.dat
    //

    DumpHwCompDat (InputPath, ShowInfs);

    //
    // Cleanup
    //

    TerminateMigLib();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\initool\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\initool\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hwdatgen\pch.h ===
#include "master.h"
#include "masterhw.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\isudump\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\killfile\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\inc\badapp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    badapp.h

Abstract:

    Declares the structures used for CheckBadApps data.

Author:

    Calin Negreanu (calinn) 01/20/1999

Revision History:

--*/

#pragma once

#define APPTYPE_TYPE_MASK     0x000000FF

#define APPTYPE_INC_NOBLOCK   0x00000001
#define APPTYPE_INC_HARDBLOCK 0x00000002
#define APPTYPE_MINORPROBLEM  0x00000003
#define APPTYPE_REINSTALL     0x00000004

#define APPTYPE_FLAG_MASK     0xFFFFFF00

#define APPTYPE_FLAG_NONET    0x00000100
#define APPTYPE_FLAG_FAT32    0x00000200
#define APPTYPE_FLAG_NTFS     0x00000400

typedef struct {
    DWORD Size;
    DWORD MsgId;
    DWORD AppType;
} BADAPP_PROP, *PBADAPP_PROP;

typedef struct {
    DWORD Size;
    PCWSTR FilePath;
    PBYTE Blob;
} BADAPP_DATA, *PBADAPP_DATA;

BOOL
IsBadApp (
    IN      PBADAPP_DATA Data,
    OUT     PBADAPP_PROP Prop
    );

#define EDIT    TRUE
#define NOEDIT  FALSE

#define ALLFILES      TRUE
#define NOT4MAINFILE  FALSE

//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,

    // add new versions here

    VTID_LASTID
};

#define VERSION_STAMPS \
    LIBARGS(VTID_FILESIZE, CheckFileSize) \
    TOOLARGS(TEXT("FILESIZE"), TEXT("File Size:"), ALLFILES, NOEDIT, QueryFileSize, OutputHexValue)\
    \
    LIBARGS(VTID_EXETYPE, CheckModuleType) \
    TOOLARGS(TEXT("EXETYPE"), TEXT("Module Type:"), NOT4MAINFILE, NOEDIT, QueryModuleType, OutputModuleTypeValue)\
    \
    LIBARGS(VTID_BINFILEVER, CheckBinFileVer) \
    TOOLARGS(TEXT("BINFILEVER"), TEXT("Binary File Version:"), ALLFILES, EDIT, QueryBinFileVer, OutputBinVerValue)\
    \
    LIBARGS(VTID_BINPRODUCTVER, CheckBinProductVer) \
    TOOLARGS(TEXT("BINPRODUCTVER"), TEXT("Binary Product Version:"), ALLFILES, EDIT, QueryBinProductVer, OutputBinVerValue)\
    \
    LIBARGS(VTID_FILEDATEHI, CheckFileDateHi) \
    TOOLARGS(TEXT("FILEDATEHI"), TEXT("File Date (HI):"), ALLFILES, NOEDIT, QueryFileDateHi, OutputHexValue)\
    \
    LIBARGS(VTID_FILEDATELO, CheckFileDateLo) \
    TOOLARGS(TEXT("FILEDATELO"), TEXT("File Date (LO):"), ALLFILES, NOEDIT, QueryFileDateLo, OutputHexValue)\
    \
    LIBARGS(VTID_FILEVEROS, CheckFileVerOs) \
    TOOLARGS(TEXT("FILEVEROS"), TEXT("File OS Version:"), ALLFILES, NOEDIT, QueryFileVerOs, OutputHexValue)\
    \
    LIBARGS(VTID_FILEVERTYPE, CheckFileVerType) \
    TOOLARGS(TEXT("FILEVERTYPE"), TEXT("File Type:"), ALLFILES, NOEDIT, QueryFileVerType, OutputHexValue)\
    \
    LIBARGS(VTID_CHECKSUM, CheckFileCheckSum) \
    TOOLARGS(TEXT("CHECKSUM"), TEXT("File CheckSum:"), ALLFILES, NOEDIT, QueryFileCheckSum, OutputHexValue)\
    \
    LIBARGS(VTID_PECHECKSUM, CheckFilePECheckSum) \
    TOOLARGS(TEXT("PECHECKSUM"), TEXT("File Header CheckSum:"), ALLFILES, NOEDIT, QueryFilePECheckSum, OutputHexValue)\
    \
    LIBARGS(VTID_COMPANYNAME, CheckCompanyName) \
    TOOLARGS(TEXT("COMPANYNAME"), TEXT("Company Name:"), ALLFILES, EDIT, QueryCompanyName, OutputStrValue)\
    \
    LIBARGS(VTID_PRODUCTVERSION, CheckProductVersion) \
    TOOLARGS(TEXT("PRODUCTVERSION"), TEXT("Product Version:"), ALLFILES, EDIT, QueryProductVersion, OutputStrValue)\
    \
    LIBARGS(VTID_PRODUCTNAME, CheckProductName) \
    TOOLARGS(TEXT("PRODUCTNAME"), TEXT("Product Name:"), ALLFILES, EDIT, QueryProductName, OutputStrValue)\
    \
    LIBARGS(VTID_FILEDESCRIPTION, CheckFileDescription) \
    TOOLARGS(TEXT("FILEDESCRIPTION"), TEXT("File Description:"), ALLFILES, EDIT, QueryFileDescription, OutputStrValue)\
    \
    LIBARGS(VTID_FILEVERSION, CheckFileVersion) \
    TOOLARGS(TEXT("FILEVERSION"), TEXT("File Version:"), ALLFILES, EDIT, QueryFileVersion, OutputStrValue)\
    \
    LIBARGS(VTID_ORIGINALFILENAME, CheckOriginalFileName) \
    TOOLARGS(TEXT("ORIGINALFILENAME"), TEXT("Original File Name:"), ALLFILES, EDIT, QueryOriginalFileName, OutputStrValue)\
    \
    LIBARGS(VTID_INTERNALNAME, CheckInternalName) \
    TOOLARGS(TEXT("INTERNALNAME"), TEXT("Internal Name:"), ALLFILES, EDIT, QueryInternalName, OutputStrValue)\
    \
    LIBARGS(VTID_LEGALCOPYRIGHT, CheckLegalCopyright) \
    TOOLARGS(TEXT("LEGALCOPYRIGHT"), TEXT("Legal Copyright:"), ALLFILES, EDIT, QueryLegalCopyright, OutputStrValue)\
    \
    LIBARGS(VTID_16BITDESCRIPTION, Check16BitDescription) \
    TOOLARGS(TEXT("DESCRIPTION"), TEXT("16 Bit Description:"), ALLFILES, EDIT, Query16BitDescription, OutputStrValue)\
    \
    LIBARGS(VTID_UPTOBINPRODUCTVER, CheckUpToBinProductVer) \
    TOOLARGS(TEXT("UPTOBINPRODUCTVER"), TEXT("Up To Binary Product Version:"), ALLFILES, NOEDIT, QueryBinProductVer, OutputUpToBinVerValue)\
    \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\killfile\pch.h ===
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hwwiz\hwwiz.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hwwiz.c

Abstract:

    Implements a upgwiz wizard for obtaining hardware information.

Author:

    Jim Schmidt (jimschm)  05-Oct-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "..\inc\dgdll.h"


DATATYPE g_DataTypes[] = {
    {UPGWIZ_VERSION,
        "PNP Device Should Be Compatible",
        "You specify the PNP device or devices that were incorrectly reported as incompatible.",
        0
    },

    {UPGWIZ_VERSION,
        "PNP Device Should Be Incompatible",
        "You specify the PNP device or devices that need to be reported as incompatible.",
        0
    },

    {UPGWIZ_VERSION,
        "PNP Device Has Loss of Functionality",
        "A device is compatible, but some functionality is lost.",
        0,
        DTF_REQUIRE_TEXT|DTF_ONE_SELECTION,
        1024,
        NULL,
        "&Text For Incompatibility:"
    },

    {UPGWIZ_VERSION,
        "Compatible Windows 3.1 Driver",
        "Use this to completely suppress the generic Win3.1 driver warning for a .386 file.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_ONE_SELECTION,
        1024,
        "&Name of Device that Driver Controls:"
    },

    {UPGWIZ_VERSION,
        "Incompatible Windows 3.1 Driver",
        "Use this to give a better problem description to a driver that causes the generic Win3.1 driver warning.",
        0,
        DTF_REQUIRE_TEXT|DTF_REQUIRE_DESCRIPTION|DTF_ONE_SELECTION,
        1024,
        "&Name of Device that Driver Controls:",
        "&Describe The Problem:"
    },

    {UPGWIZ_VERSION,
        "Compatible TWAIN Data Sources",
        "Removes the incompatible warning caused by an unknown TWAIN data source."
    },

    {UPGWIZ_VERSION,
        "Compatible Joysticks",
        "Removes the incompatible warning caused by an unknown joysticks."
    }

};


GROWBUFFER g_DataObjects = GROWBUF_INIT;
POOLHANDLE g_DataObjectPool;

typedef struct {
    PCSTR Description;
    PCSTR FullPath;
} TWAINPARAM, *PTWAINPARAM;

BOOL
pGeneratePnpOutput (
    IN      POUTPUTARGS Args,
    IN      HANDLE File
    );

BOOL
pGenerateWin31DriverOutput (
    IN      POUTPUTARGS Args,
    IN      HANDLE File
    );

BOOL
pGenerateTwainOutput (
    IN      POUTPUTARGS Args,
    IN      HANDLE File
    );

BOOL
pGenerateJoystickOutput (
    IN      POUTPUTARGS Args,
    IN      HANDLE File
    );


HINSTANCE g_OurInst;

BOOL
Init (
    VOID
    )
{
#ifndef UPGWIZ4FLOPPY
    return InitToolMode (g_OurInst);
#else
    return TRUE;
#endif
}

VOID
Terminate (
    VOID
    )
{
    //
    // Local cleanup
    //

    FreeGrowBuffer (&g_DataObjects);

    if (g_DataObjectPool) {
        PoolMemDestroyPool (g_DataObjectPool);
    }

#ifndef UPGWIZ4FLOPPY
    TerminateToolMode (g_OurInst);
#endif
}


BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_DETACH) {
        MYASSERT (g_OurInst == hInstance);
        Terminate();
    }

    g_OurInst = hInstance;

    return TRUE;
}


UINT
GiveVersion (
    VOID
    )
{
    Init();

    return UPGWIZ_VERSION;
}


PDATATYPE
GiveDataTypeList (
    OUT     PUINT Count
    )
{
    UINT u;

    *Count = sizeof (g_DataTypes) / sizeof (g_DataTypes[0]);

    for (u = 0 ; u < *Count ; u++) {
        g_DataTypes[u].DataTypeId = u;
    }

    return g_DataTypes;
}


PDATAOBJECT
GiveDataObjectList (
    IN      UINT DataTypeId,
    OUT     PUINT Count
    )
{
    HARDWARE_ENUM e;
    PDATAOBJECT Data;
    HINF Inf;
    TCHAR Path[MAX_TCHAR_PATH];
    TCHAR FullPath[MAX_TCHAR_PATH];
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR DriverPath;
    PCTSTR DriverFile;
    TWAINDATASOURCE_ENUM te;
    JOYSTICK_ENUM je;
    TWAINPARAM TwainParam;

    g_DataObjectPool = PoolMemInitNamedPool ("Data Objects");

    if (DataTypeId < 3) {
        //
        // Enumerate the PNP devices
        //

        if (EnumFirstHardware (&e, ENUM_ALL_DEVICES, ENUM_WANT_DEV_FIELDS)) {
            do {
                if (!e.Driver || !e.DeviceDesc || !e.InstanceId) {
                    continue;
                }

                Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));

                Data->Version = UPGWIZ_VERSION;
                Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, e.DeviceDesc);
                Data->Flags = 0;
                Data->DllParam = PoolMemDuplicateString (g_DataObjectPool, e.FullKey);

            } while (EnumNextHardware (&e));
        }

    } else if (DataTypeId >= 3 && DataTypeId < 5) {
        //
        // Enumerate the .386 candidates
        //

        wsprintf (Path, TEXT("%s\\system.ini"), g_WinDir);

        Inf = InfOpenInfFile (Path);
        if (Inf != INVALID_HANDLE_VALUE) {
            if (InfFindFirstLine (Inf, TEXT("386Enh"), NULL, &is)) {
                do {
                    DriverPath = InfGetStringField (&is, 1);
                    if (DriverPath) {
                        //
                        // Determine if device driver is known
                        //

                        if (_tcsnextc (DriverPath) != TEXT('*')) {
                            DriverFile = GetFileNameFromPath (DriverPath);

                            if (!_tcschr (DriverPath, TEXT(':'))) {
                                if (!SearchPath (
                                        NULL,
                                        DriverFile,
                                        NULL,
                                        MAX_TCHAR_PATH,
                                        FullPath,
                                        NULL
                                        )) {
                                    _tcssafecpy (FullPath, DriverPath, MAX_TCHAR_PATH);
                                }
                            } else {
                                _tcssafecpy (FullPath, DriverPath, MAX_TCHAR_PATH);
                            }

                            if (!_tcschr (FullPath, TEXT(':'))) {
                                continue;
                            }

                            Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));

                            Data->Version = UPGWIZ_VERSION;
                            Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, DriverFile);
                            Data->Flags = 0;
                            Data->DllParam = PoolMemDuplicateString (g_DataObjectPool, FullPath);
                        }
                    }

                } while (InfFindNextLine (&is));
            }

            InfCloseInfFile (Inf);
            InfCleanUpInfStruct (&is);
        }

    } else if (DataTypeId == 5) {
        //
        // Enumerate the TWAIN devices
        //

        if (EnumFirstTwainDataSource (&te)) {
            do {
                Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));

                Data->Version = UPGWIZ_VERSION;
                Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, te.DisplayName);
                Data->Flags = 0;

                TwainParam.Description = PoolMemDuplicateString (g_DataObjectPool, te.DisplayName);
                TwainParam.FullPath = PoolMemDuplicateString (g_DataObjectPool, te.DataSourceModule);

                Data->DllParam = PoolMemGetAlignedMemory (g_DataObjectPool, sizeof (TWAINPARAM));

                CopyMemory (Data->DllParam, &TwainParam, sizeof (TWAINPARAM));

            } while (EnumNextTwainDataSource (&te));
        }

    } else if (DataTypeId == 6) {
        //
        // Enumerate the Joystick
        //

        if (EnumFirstJoystick (&je)) {
            do {

                if (!_mbschr (je.JoystickDriver, ':')) {
                    if (!SearchPath (
                            NULL,
                            je.JoystickDriver,
                            NULL,
                            MAX_TCHAR_PATH,
                            Path,
                            NULL
                            )) {
                        continue;
                    }
                } else {
                    StringCopy (Path, je.JoystickDriver);
                }

                Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));

                Data->Version = UPGWIZ_VERSION;
                Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, je.JoystickName);
                Data->Flags = 0;

                TwainParam.Description = PoolMemDuplicateString (g_DataObjectPool, je.JoystickName);
                TwainParam.FullPath = PoolMemDuplicateString (g_DataObjectPool, Path);

                Data->DllParam = PoolMemGetAlignedMemory (g_DataObjectPool, sizeof (TWAINPARAM));

                CopyMemory (Data->DllParam, &TwainParam, sizeof (TWAINPARAM));

            } while (EnumNextJoystick (&je));
        }
    }

    *Count = g_DataObjects.End / sizeof (DATAOBJECT);

    return (PDATAOBJECT) g_DataObjects.Buf;
}

BOOL
OldGenerateOutput (
    IN      POUTPUTARGS Args
    )
{
    return TRUE;
}

//#if 0

BOOL
pWritePnpIdRule (
    IN      HANDLE File,
    IN      PHARDWARE_ENUM EnumPtr,
    IN      PCSTR Description           OPTIONAL
    )
{
    CHAR Path[MAX_MBCHAR_PATH];
    CHAR DriverKey[MAX_REGISTRY_KEY];
    HKEY Key = NULL;
    BOOL b = FALSE;
    PCSTR InfPath = NULL;
    WIN32_FIND_DATA fd;
    HANDLE Find = INVALID_HANDLE_VALUE;
    CHAR Buf[2048];
    CHAR WinDir[MAX_MBCHAR_PATH];
    CHAR StringSectKey[256];

    GetWindowsDirectory (WinDir, MAX_MBCHAR_PATH);

    if (Description && *Description == 0) {
        Description = NULL;
    }

    //
    // Get the driver
    //

    __try {
        if (!EnumPtr->Driver || !EnumPtr->DeviceDesc || !EnumPtr->InstanceId) {
            DEBUGMSG ((DBG_WHOOPS, "Enum field missing; should have been screened out of object list"));
            __leave;
        }

        wsprintf (DriverKey, "HKLM\\System\\CurrentControlSet\\Services\\Class\\%s", EnumPtr->Driver);

        Key = OpenRegKeyStr (DriverKey);
        if (!Key) {
            DEBUGMSG ((DBG_WHOOPS, "Can't open %s", DriverKey));
            __leave;
        }

        InfPath = GetRegValueString (Key, "InfPath");
        if (!InfPath || *InfPath == 0) {
            DEBUGMSG ((DBG_WHOOPS, "No InfPath in %s", DriverKey));
            MessageBox (NULL, "Selected device does not have an INF path.  The INF path is required.", NULL, MB_OK);
            __leave;
        }

        if (!_mbschr (InfPath, '\\')) {
            wsprintf (Path, "%s\\inf\\%s", WinDir, InfPath);
        } else {
            StringCopy (Path, InfPath);
        }

        Find = FindFirstFile (Path, &fd);
        if (Find == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_WHOOPS, "Can't find %s", Path));
            __leave;
        }

        if (!Description) {
            wsprintf (Buf, "%s,,", EnumPtr->DeviceDesc);
        } else {
            GenerateUniqueStringSectKey ("DV", StringSectKey);
            wsprintf (Buf, "%s, %%%s%%,", EnumPtr->DeviceDesc, StringSectKey);
        }

        if (!WizardWriteColumn (File, Buf, 45)) {
            __leave;
        }

        wsprintf (Buf, "%s,", fd.cFileName);
        if (!WizardWriteColumn (File, Buf, 15)) {
            __leave;
        }

        wsprintf (Buf, "FILESIZE(%u),", fd.nFileSizeLow);
        if (!WizardWriteRealString (File, Buf)) {
            __leave;
        }

        if (!WizardWriteRealString (File, " PNPID(")) {
            __leave;
        }

        if (!WizardWriteQuotedString (File, EnumPtr->InstanceId)) {
            __leave;
        }

        if (!WizardWriteRealString (File, ")\r\n")) {
            __leave;
        }

        if (Description) {
            if (!WizardWriteRealString (File, "[Strings]\r\n")) {
                __leave;
            }

            WriteStringSectKey (File, StringSectKey, Description);
        }

        b = TRUE;
    }
    __finally {
        if (Key) {
            CloseRegKey (Key);
        }

        if (InfPath) {
            MemFree (g_hHeap, 0, InfPath);
        }

        if (Find != INVALID_HANDLE_VALUE) {
            FindClose (Find);
        }
    }

    return b;
}


BOOL
GenerateOutput (
    IN      POUTPUTARGS Args
    )
{
    BOOL b = FALSE;
    HANDLE File;
    CHAR Path[MAX_MBCHAR_PATH];

    switch (Args->DataTypeId) {

    case 0:
        wsprintf (Path, "%s\\comphw.txt", Args->OutboundDir);
        break;

    case 1:
        wsprintf (Path, "%s\\incomphw.txt", Args->OutboundDir);
        break;

    case 2:
        wsprintf (Path, "%s\\hwfnloss.inx", Args->OutboundDir);
        break;

    case 3:
    case 4:
        wsprintf (Path, "%s\\win31drv.inx", Args->OutboundDir);
        break;

    case 5:
        wsprintf (Path, "%s\\twain.inx", Args->OutboundDir);
        break;

    case 6:
        wsprintf (Path, "%s\\joystick.inx", Args->OutboundDir);
        break;

    default:
        wsprintf (Path, "%s\\unknown.txt", Args->OutboundDir);
        break;
    }

    printf ("Saving data to %s\n\n", Path);

    File = CreateFile (
                Path,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (File == INVALID_HANDLE_VALUE) {
        printf ("Can't open file for output.\n");
        return FALSE;
    }

    __try {
        SetFilePointer (File, 0, NULL, FILE_END);

        //
        // Write [Identification] for all .inx files
        //

        switch (Args->DataTypeId) {

        case 0:
        case 1:
            break;

        default:
            if (!WizardWriteRealString (File, "[Identification]\r\n")) {
                __leave;
            }
            break;
        }

        //
        // Write user name and date/time
        //

        if (!WriteHeader (File)) {
            __leave;
        }

        //
        // Generate output depending on the type
        //

        switch (Args->DataTypeId) {

        case 0:
        case 1:
        case 2:
            b = pGeneratePnpOutput (Args, File);
            break;

        case 3:
        case 4:
            b = pGenerateWin31DriverOutput (Args, File);
            break;

        case 5:
            b = pGenerateTwainOutput (Args, File);
            break;

        case 6:
            b = pGenerateJoystickOutput (Args, File);
            break;
        }

        //
        // Write a final blank line
        //

        b = b & WizardWriteRealString (File, "\r\n");
    }
    __finally {
        CloseHandle (File);
    }

    return b;
}


BOOL
pGeneratePnpOutput (
    IN      POUTPUTARGS Args,
    IN      HANDLE File
    )
{
    PDATAOBJECT Data;
    UINT Count;
    UINT Pos;
    HARDWARE_ENUM e;
    BOOL b = FALSE;

    __try {
        Count = g_DataObjects.End / sizeof (DATAOBJECT);

        if (EnumFirstHardware (&e, ENUM_ALL_DEVICES, ENUM_WANT_DEV_FIELDS)) {
            do {
                Data = (PDATAOBJECT) g_DataObjects.Buf;

                for (Pos = 0 ; Pos < Count ; Pos++) {

                    if (StringIMatch ((PCSTR) Data->DllParam, e.FullKey)) {

                        if (Data->Flags & DOF_SELECTED) {

                            if (Args->DataTypeId == 2) {
                                if (!WizardWriteRealString (File, "[MinorProblems]\r\n")) {
                                    __leave;
                                }

                                if (!pWritePnpIdRule (File, &e, Args->OptionalText)) {
                                    __leave;
                                }

                            } else {

                                if (!pWritePnpIdRule (File, &e, NULL)) {
                                    __leave;
                                }
                            }
                        }

                        break;
                    }

                    Data++;
                }

            } while (EnumNextHardware (&e));
        }

        b = TRUE;
    }
    __finally {
        if (!b) {
            AbortHardwareEnum (&e);
        }
    }

    return b;
}


BOOL
pGenerateWin31DriverOutput (
    IN      POUTPUTARGS Args,
    IN      HANDLE File
    )
{
    PDATAOBJECT Data;
    UINT Pos;
    UINT Count;
    BOOL b = FALSE;

    Data = (PDATAOBJECT) g_DataObjects.Buf;
    Count = g_DataObjects.End / sizeof (DATAOBJECT);

    for (Pos = 0 ; Pos < Count ; Pos++) {

        if (Data->Flags & DOF_SELECTED) {

            b = WriteFileAttributes (
                    Args,
                    NULL,
                    File,
                    (PCSTR) Data->DllParam,
                    Args->OptionalText ? "[NonPnpDrivers]" : "[NonPnpDrivers_NoMessage]"
                    );

            break;
        }

        Data++;
    }

    return b;
}



BOOL
pGenerateTwainOutput (
    IN      POUTPUTARGS Args,
    IN      HANDLE File
    )
{
    PDATAOBJECT Data;
    UINT Pos;
    UINT Count;
    BOOL b = FALSE;
    PTWAINPARAM TwainParam;

    Data = (PDATAOBJECT) g_DataObjects.Buf;
    Count = g_DataObjects.End / sizeof (DATAOBJECT);

    for (Pos = 0 ; Pos < Count ; Pos++) {

        if (Data->Flags & DOF_SELECTED) {

            TwainParam = (PTWAINPARAM) Data->DllParam;

            b = WriteFileAttributes (
                    Args,
                    TwainParam->Description,
                    File,
                    TwainParam->FullPath,
                    "[CompatibleFiles]"
                    );

            break;
        }

        Data++;
    }

    return b;
}


BOOL
pGenerateJoystickOutput (
    IN      POUTPUTARGS Args,
    IN      HANDLE File
    )
{
    PDATAOBJECT Data;
    UINT Pos;
    UINT Count;
    BOOL b = FALSE;
    PTWAINPARAM TwainParam;

    Data = (PDATAOBJECT) g_DataObjects.Buf;
    Count = g_DataObjects.End / sizeof (DATAOBJECT);

    for (Pos = 0 ; Pos < Count ; Pos++) {

        if (Data->Flags & DOF_SELECTED) {

            TwainParam = (PTWAINPARAM) Data->DllParam;

            b = WriteFileAttributes (
                    Args,
                    TwainParam->Description,
                    File,
                    TwainParam->FullPath,
                    "[CompatibleFiles]"
                    );

            break;
        }

        Data++;
    }

    return b;
}

//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\hwdatgen\hwdatgen.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hwdatgen.c

Abstract:

    This module creates a tool that generates hwcomp.dat and is designed for us by
    the NT build lab.  It simply calls the code in hwcomp.lib, the same code that
    the Win9x upgrade uses to determine incompatibilities.

Author:

    Jim Schmidt (jimschm) 12-Oct-1996

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

#ifdef UNICODE
#error UNICODE not allowed
#endif

#define MAX_SOURCE_DIRS     10

BOOL CancelFlag = FALSE;
BOOL *g_CancelFlagPtr = &CancelFlag;

#ifdef PRERELEASE
BOOL g_Stress;
#endif

#ifdef DEBUG
extern BOOL g_DoLog;
#endif

HANDLE g_hHeap;
HINSTANCE g_hInst;

CHAR   g_TempDirBuf[MAX_MBCHAR_PATH];      // location for hwcomp.dat
CHAR   g_TempDirWackBuf[MAX_MBCHAR_PATH];
PSTR   g_TempDir;
PSTR   g_TempDirWack;
INT    g_TempDirWackChars;
PSTR   g_WinDir;
CHAR   g_WinDirBuf[MAX_MBCHAR_PATH];
PCSTR  g_SourceDirectories[MAX_SOURCE_COUNT];    // location of INFs
DWORD  g_SourceDirectoryCount;
USEROPTIONS g_ConfigOptions;

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved
    );


VOID
pInitProgBarVars (
    VOID
    );

VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "hwdatgen [-i:<infdir>] [-o:<outputfile>] [-c] [-v]\n\n"
            "Optional Arguments:\n"
            "  -i:<infdir>     - Specifies input directory containing INF files.\n"
            "                    If -i is not specified, the default is %_NTTREE%\n"
            "  -o:<outputfile> - Specifies path and file name of DAT file.  By\n"
            "                    default, this file is %_NTTREE%\\hwcomp.dat\n"
            "  -c              - Clean build (deletes <outputfile>)\n"
            "  -v              - Verbose output\n"
            "\n"
            "A maximum of %u input directories can be specified.\n"
            "\n",
            MAX_SOURCE_DIRS
            );

    exit(255);
}

INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    CHAR NtTree[MAX_MBCHAR_PATH];
    CHAR InputPathBuf[MAX_SOURCE_DIRS][MAX_MBCHAR_PATH];
    UINT SourceDirs = 0;
    CHAR OutputFileBuf[MAX_MBCHAR_PATH];
    PSTR OutputFile;
    PSTR p;
    INT i;
    LONG rc;
    INT UIMode;
    BOOL CleanBuild;
    DWORD d;    // for debugging only
    UINT u;
    DWORD Attribs;

    //
    // Get environment variables
    //

    p = getenv ("_NTx86TREE");
    if (!p || !(*p)) {
        p = getenv ("_NTTREE");
    }

    if (p && *p) {
        StringCopyA (NtTree, p);
    } else {
        StringCopyA (NtTree, ".");
    }

    //
    // Set defaults
    //

    g_TempDir = g_TempDirBuf;
    g_TempDirWack = g_TempDirWackBuf;
    g_WinDir = g_WinDirBuf;

    StringCopyA (OutputFileBuf, NtTree);
    AppendPathWack (OutputFileBuf);
    StringCatA (OutputFileBuf, "hwcomp.dat");
    OutputFile = OutputFileBuf;

    StringCopyA (InputPathBuf[0], NtTree);

    UIMode = REGULAR_OUTPUT;
    CleanBuild = FALSE;

    ZeroMemory (&g_ConfigOptions, sizeof (g_ConfigOptions));

    //
    // Parse command line
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {
            case 'i':

                if (SourceDirs == MAX_SOURCE_DIRS) {
                    HelpAndExit();
                }

                if (argv[i][2] == ':') {
                    StringCopyA (InputPathBuf[SourceDirs], &argv[i][3]);
                } else if (i + 1 < argc) {
                    i++;
                    StringCopyA (InputPathBuf[SourceDirs], argv[i]);
                } else {
                    HelpAndExit();
                }

                Attribs = GetFileAttributes (InputPathBuf[SourceDirs]);
                if (Attribs == INVALID_ATTRIBUTES || !(Attribs & FILE_ATTRIBUTE_DIRECTORY)) {
                    HelpAndExit();
                }

                SourceDirs++;

                break;

            case 'o':
                if (argv[i][2] == ':') {
                    OutputFile = &argv[i][3];
                } else if (i + 1 < argc) {
                    i++;
                    OutputFile = argv[i];
                } else {
                    HelpAndExit();
                }

                break;

            case 'c':
                CleanBuild = TRUE;
                break;

            case 'v':
                UIMode = VERBOSE_OUTPUT;
                break;


            default:
                HelpAndExit();
            }
        } else {
            HelpAndExit();
        }
    }

    if (SourceDirs == 0) {
        SourceDirs = 1;
    }

    printf ("Building database of all NT-supported PNP IDs... Please wait.\n\n");

    g_SourceDirectoryCount = SourceDirs;

    for (u = 0 ; u < SourceDirs ; u++) {

        g_SourceDirectories[u] = InputPathBuf[u];

        if (!u) {
            printf ("Input path%s ", SourceDirs == 1 ? ": " : "s:");
        } else {
            printf ("             ");
        }

        printf ("%s\n", g_SourceDirectories[u]);
    }

    //
    // Init hwcomp.lib
    //

    pInitProgBarVars();

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    GetTempPathA (MAX_MBCHAR_PATH, g_TempDir);
    StringCopyA (g_TempDirWack, g_TempDir);
    AppendWack (g_TempDirWack);

    g_TempDirWackChars = CharCountA (g_TempDirWack);

    if (!GetWindowsDirectoryA (g_WinDir, MAX_MBCHAR_PATH)) {
        printf ("Memory allocation failure!\n");
        return 254;
    }

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        printf ("Initialization error!\n");
        return 254;
    }

    if (!HwComp_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        printf ("Initialization error!\n");
        return 254;
    }

#ifdef DEBUG
    g_DoLog = TRUE;
#endif

    //
    // Build hwcomp.dat
    //

    if (CleanBuild) {
        SetFileAttributes (OutputFile, FILE_ATTRIBUTE_NORMAL);
        if (!DeleteFile (OutputFile)) {
            if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                printf ("DeleteFile failed for %s.  Win32 Error Code: %x\n",
                         OutputFile, GetLastError ());
                return 252;
            }
        }
    }

    if (!CreateNtHardwareList (g_SourceDirectories, g_SourceDirectoryCount, OutputFile, UIMode)) {

        rc = GetLastError();

        printf ("Could not build complete device.  Win32 Error Code: %x\n", rc);
        return 1;
    } else {
        printf ("%s was built successfully.\n", OutputFile);
    }

    //
    // Terminate hwcomp.lib
    //

    if (!HwComp_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
        printf ("Termination error!\n");
        return 253;
    }

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
        printf ("Termination error!\n");
        return 253;
    }

    return 0;
}


//
// Stubs
//

HWND    g_Component;
HWND    g_SubComponent;
HANDLE  g_ComponentCancelEvent;
HANDLE  g_SubComponentCancelEvent;

VOID
pInitProgBarVars (
    VOID
    )
{
    g_Component = NULL;
    g_SubComponent = NULL;
    g_ComponentCancelEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    g_SubComponentCancelEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
}


BOOL
ProgressBar_SetWindowStringA (
    IN HWND Window,
    IN HANDLE CancelEvent,
    IN PCSTR Message,            OPTIONAL
    IN DWORD MessageId           OPTIONAL
    )
{

    return TRUE;
}


BOOL
TickProgressBar (
    VOID
    )
{
    return TRUE;
}


BOOL
TickProgressBarDelta (
    IN      UINT TickCount
    )
{
    return TRUE;
}

VOID
InitializeProgressBar (
    IN      HWND ProgressBar,
    IN      HWND Component,             OPTIONAL
    IN      HWND SubComponent,          OPTIONAL
    IN      BOOL *CancelFlagPtr         OPTIONAL
    )
{
    return;
}

VOID
TerminateProgressBar (
    VOID
    )
{
    return;
}

VOID
EndSliceProcessing (
    VOID
    )
{
    return;
}

UINT
RegisterProgressBarSlice (
    IN      UINT InitialEstimate
    )
{
    return 0;
}


VOID
ReviseSliceEstimate (
    IN      UINT SliceId,
    IN      UINT RevisedEstimate
    )
{
    return;
}


VOID
BeginSliceProcessing (
    IN      UINT SliceId
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\inc\dgdll.h ===
#pragma once

#define UPGWIZ_VERSION      1

#define DTF_ONE_SELECTION           0x0001
#define DTF_REQUEST_TEXT            0x0002
#define DTF_REQUEST_DESCRIPTION     0x0004
#define DTF_REQUIRE_TEXT            0x000a
#define DTF_REQUIRE_DESCRIPTION     0x0014
#define DTF_NO_DATA_OBJECT          0x0020

typedef struct {
    // filled in by the DLL
    DWORD Version;
    PCSTR Name;
    PCSTR Description;
    UINT DataTypeId;
    DWORD Flags;

    // if DTF_REQUEST_TEXT specified in Flags...
    UINT MaxTextSize;
    PCSTR OptionalDescTitle;        OPTIONAL
    PCSTR OptionalTextTitle;        OPTIONAL

    // wizard private use
    PVOID Reserved;
} DATATYPE, *PDATATYPE;



#define DOF_SELECTED                0x0001
#define DOF_NO_SPLIT_ON_WACK        0x0002
#define DOF_NO_SORT                 0x0004


typedef struct {
    // filled in by the DLL
    DWORD Version;
    PCSTR NameOrPath;
    PVOID DllParam;                 // for private use by the DLL

    // filled in by the DLL, altered by the wizard
    DWORD Flags;
} DATAOBJECT, *PDATAOBJECT;

typedef struct {
    // filled in by wizard, modified by optional UI page
    PBOOL StartOverFlag;

    // filled in by the wizard
    DWORD Version;
    PCSTR InboundInfDir;
    PCSTR OutboundDir;
    UINT DataTypeId;
    PCSTR OptionalText;
    PCSTR OptionalDescription;
} OUTPUTARGS, *POUTPUTARGS;

UINT
GiveVersion (
    VOID
    );

PDATATYPE
GiveDataTypeList (
    OUT     PUINT Count
    );

PDATAOBJECT
GiveDataObjectList (
    IN      UINT DataTypeId,
    OUT     PUINT Count
    );

BOOL
GenerateOutput (
    IN      POUTPUTARGS Args
    );


//
// Routines in wiztools.dll
//

VOID
WizToolsMain (
    IN      DWORD dwReason
    );

BOOL
WizardWriteRealString (
    IN      HANDLE File,
    IN      PCSTR String
    );


VOID
GenerateUniqueStringSectKey (
    IN      PCSTR TwoLetterId,
    OUT     PSTR Buffer
    );

BOOL
WriteHeader (
    IN      HANDLE File
    );

BOOL
WriteStringSectKey (
    IN      HANDLE File,
    IN      PCSTR KeyName,
    IN      PCSTR String
    );

BOOL
WriteFileAttributes (
    IN      POUTPUTARGS Args,
    IN      PCSTR NonLocalizedName, OPTIONAL
    IN      HANDLE FileHandle,
    IN      PCSTR FileSpec,
    IN      PCSTR Section           OPTIONAL
    );

BOOL
GetFileAttributesLine (
    IN      PCTSTR FileName,
    OUT     PTSTR Buffer,
    IN      DWORD  BufferSize
    );

BOOL
WizardWriteInfString (
    IN      HANDLE File,
    IN      PCSTR String,
    IN      BOOL Quoted,
    IN      BOOL SkipCRLF,
    IN      BOOL ReplaceSpace,
    IN      CHAR SpaceReplacement,
    IN      DWORD ColumnWidth
    );

#define WizardWriteQuotedString(File,String)        WizardWriteInfString(File,String,TRUE,FALSE,FALSE,0,0)
#define WizardWriteQuotedColumn(File,String,ColW)   WizardWriteInfString(File,String,TRUE,FALSE,FALSE,0,ColW)
#define WizardWriteString(File,String)              WizardWriteInfString(File,String,FALSE,FALSE,FALSE,0,0)
#define WizardWriteColumn(File,String,ColW)         WizardWriteInfString(File,String,FALSE,FALSE,FALSE,0,ColW)





/* OvidiuT */

#ifdef UPGWIZ4FLOPPY

extern OSVERSIONINFOA   g_OsInfo;
extern PTSTR            g_WinDir;
extern PTSTR            g_SystemDir;
extern HANDLE           g_hHeap;

#define g_OsInfo            Get_g_OsInfo()
#define g_WinDir            Get_g_WinDir()
#define g_SystemDir         Get_g_SystemDir()
#define g_hHeap             Get_g_hHeap()

OSVERSIONINFOA Get_g_OsInfo (VOID);
PCTSTR Get_g_WinDir (VOID);
PCTSTR Get_g_SystemDir (VOID);
HANDLE Get_g_hHeap(VOID);

#endif // UPGWIZ4FLOPPY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\locinfo\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\loctool\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\isudump\isudump.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    isudump.c

Abstract:

    Calls InstallShield APIs to dump out an install log file (foo.isu)

Author:

    Jim Schmidt (jimschm)  19-Feb-1999

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "ismig.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        TEXT("  isudump <file>\n")

        TEXT("\nDescription:\n\n")

        TEXT("  isudump dumps an InstallShield log file.  It requires ismig.dll.\n")

        TEXT("\nArguments:\n\n")

        TEXT("  <file>  Specifies full path to InstallShield log file\n")

        );

    exit (1);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg = NULL;
    PISUGETALLSTRINGS ISUGetAllStrings;
    HANDLE Lib;
    BOOL LoadError = FALSE;
    HGLOBAL List;
    PCSTR MultiSz;
    MULTISZ_ENUMA e;
    PCSTR AnsiFileName;
    INT Count;

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            HelpAndExit();
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (FileArg) {
                HelpAndExit();
            }

            FileArg = argv[i];
        }
    }

    if (!FileArg) {
        HelpAndExit();
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    Lib = LoadLibrary (TEXT("ismig.dll"));

    if (Lib) {
        ISUGetAllStrings = (PISUGETALLSTRINGS) GetProcAddress (Lib, "ISUGetAllStrings");
        if (!ISUGetAllStrings) {
            LoadError = TRUE;
        }
    } else {
        LoadError = TRUE;
    }

    if (!LoadError) {

        AnsiFileName = CreateDbcs (FileArg);

        List = ISUGetAllStrings (AnsiFileName);

        if (!List) {
            fprintf (
                stderr,
                "ERROR: Can't get strings from %s (rc=%u)\n",
                AnsiFileName,
                GetLastError()
                );
        } else {
            MultiSz = (PCSTR) GlobalLock (List);
            Count = 0;

            if (EnumFirstMultiSzA (&e, MultiSz)) {
                do {
                    Count++;
                    printf ("%s\n", e.CurrentString);
                } while (EnumNextMultiSzA (&e));
            }

            printf ("\n%i total string%s\n", Count, i == 1 ? "" : "s");

            GlobalUnlock (List);
            GlobalFree (List);
        }

        DestroyDbcs (AnsiFileName);

    } else {
        _ftprintf (stderr, TEXT("ERROR: Can't load ISMIG.DLL (rc=%u)\n"), GetLastError());
    }

    if (Lib) {
        FreeLibrary (Lib);
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\lookup\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\initool\initool.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    nttool.c

Abstract:

    Implements a stub tool that is designed to run with NT-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

BOOL
ProcessIniFileMapping (
    IN      BOOL UserMode
    );

BOOL
ConvertIniFiles (
    VOID
    );

BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();
}



INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{
    LONG rc;

    if (!Init()) {

        wprintf (L"Unable to initialize!\n");
        return 255;
    }

    g_UserMigInf = InfOpenInfFile (TEXT("d:\\i386\\usermig.inf"));

    //
    // Initialize Win95Reg
    //

    rc = Win95RegInit (TEXT("c:\\windows\\setup\\defhives"), TRUE);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((LOG_ERROR, "Init Processor: Win95RegInit failed, check your temp files in c:\\windows\\setup"));
        return FALSE;
    }

    if (!MemDbLoad (TEXT("c:\\windows\\setup\\ntsetup.dat"))) {
        LOG ((LOG_ERROR, "Init Processor: MemDbLoad failed, check your temp files in c:\\windows\\setup"));
        return FALSE;
    }

    g_DomainUserName = TEXT("NTDEV\\marcw");
    g_Win9xUserName  = TEXT("marcw");
    g_FixedUserName  = TEXT("marcw");

    g_hKeyRootNT = HKEY_CURRENT_USER;
    g_hKeyRoot95 = HKEY_CURRENT_USER;
    SetRegRoot (g_hKeyRoot95);


    ConvertIniFiles();
    ProcessIniFileMapping (TRUE);

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\memdbren\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\killfile\killfile.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    killfile.c

Abstract:

    Performs a test of the file enumeration code.

Author:

    Jim Schmidt (jimschm)   14-Jan-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

BOOL
pKillEverything (
    PCTSTR Pattern,
    BOOL Root
    );


UINT g_Dirs, g_Files;

VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "kf [-sf|-sd|-s] [-l] <pattern>\n\n"
            "<pattern>  Specifies pattern of file(s) or dir(s)\n"
            "\n"
            "Options:\n"
            "\n"
            "-sf    Search all subdirs for matching files, then kill them\n"
            "-sd    Search all subdirs for matching dirs, then kill them\n"
            "-s     Kill all matches of <pattern> in any subdir\n"
            "-l     List kill candidates; don't kill them\n"
            );

    exit(0);
}


HANDLE g_hHeap;
HINSTANCE g_hInst;
BOOL g_DeleteFile = TRUE;
BOOL g_DeleteDir = FALSE;
BOOL g_Recursive = FALSE;
BOOL g_ListOnly = FALSE;

INT
__cdecl
_tmain (
    INT argc,
    TCHAR *argv[]
    )
{
    PCTSTR Pattern = NULL;
    PCTSTR FilePattern = NULL;
    INT i;
    DWORD d;
    BOOL DefaultOptions = TRUE;

    g_hHeap = GetProcessHeap();

    for (i = 1 ; i < argc ; i++) {

        if (argv[i][0] == TEXT('-') || argv[i][0] == TEXT('/')) {
            switch (_totlower (argv[i][1])) {

            case TEXT('s'):
                if (g_Recursive) {
                    HelpAndExit();
                }

                g_Recursive = TRUE;
                switch (_totlower (argv[i][2])) {

                case TEXT('f'):
                    g_DeleteFile = TRUE;
                    g_DeleteDir = FALSE;
                    DefaultOptions = FALSE;
                    break;

                case TEXT('d'):
                    g_DeleteFile = FALSE;
                    g_DeleteDir = TRUE;
                    DefaultOptions = FALSE;
                    break;

                case 0:
                    g_DeleteFile = TRUE;
                    g_DeleteDir = TRUE;
                    DefaultOptions = FALSE;
                    break;

                default:
                    HelpAndExit();
                }

                break;


            case TEXT('l'):
                g_ListOnly = TRUE;
                break;

            default:
                HelpAndExit();
            }
        }

        else if (Pattern) {
            HelpAndExit();
        }

        else {
            Pattern = argv[i];
        }
    }

    if (!Pattern || !Pattern[0]) {
        HelpAndExit();
    }

    d = GetFileAttributes (Pattern);
    if (d != INVALID_ATTRIBUTES && (d & FILE_ATTRIBUTE_DIRECTORY)) {
        if (DefaultOptions) {
            g_DeleteDir = TRUE;
        }
    }

    pKillEverything (Pattern, TRUE);

    printf ("\nFiles: %u  Dirs: %u\n\n", g_Files, g_Dirs);

    return 0;
}


BOOL
pKillPattern (
    PCTSTR Pattern
    )
{
    FILE_ENUM e;
    TCHAR CurrentDir[MAX_TCHAR_PATH];

    GetCurrentDirectory (MAX_TCHAR_PATH, CurrentDir);

    if (EnumFirstFile (&e, CurrentDir, Pattern)) {
        do {
            if (e.Directory && !g_DeleteDir) {
                continue;
            }

            if (!e.Directory && !g_DeleteFile) {
                continue;
            }

            if (e.Directory) {
                g_Dirs++;
            } else {
                g_Files++;
            }

            if (g_ListOnly) {
                _tprintf (TEXT("%s\n"), e.FullPath);
            } else {
                SetCurrentDirectory (CurrentDir);
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);

                if (e.Directory) {

                    if (!RemoveCompleteDirectory (e.FullPath)) {
                        _tprintf (TEXT("Can't kill directory %s, GLE=%u\n"), e.FullPath, GetLastError());
                    }
                } else if (!DeleteFile (e.FullPath)) {
                    _tprintf (TEXT("Can't kill %s, GLE=%u\n"), e.FullPath, GetLastError());
                }
            }
        } while (EnumNextFile (&e));
    }

    SetCurrentDirectory (CurrentDir);

    return TRUE;
}


BOOL
pKillEverything (
    PCTSTR Pattern,
    BOOL Root
    )
{
    TCHAR FilePattern[MAX_TCHAR_PATH];
    TCHAR SubPattern[MAX_TCHAR_PATH];
    TCHAR CurrentDir[MAX_TCHAR_PATH];
    PCTSTR p;
    PCTSTR q;
    PCTSTR NextPattern;
    FILE_ENUM e;
    DWORD d;
    TCHAR c = TEXT('\\');

    GetCurrentDirectory (MAX_TCHAR_PATH, CurrentDir);

    if (!Pattern || !Pattern[0]) {
        lstrcpy (FilePattern, TEXT("*.*"));
        NextPattern = NULL;
    } else {
        p = _tcschr (Pattern, TEXT('\\'));
        if (!p) {
            p = GetEndOfString (Pattern);
        } else {
            q = _tcschr (Pattern, TEXT(':'));
            if (q && p > q) {
                if (Root) {
                    p++;
                    c = 0;
                } else {
                    _tprintf (TEXT("Pattern is bad: %s\n"), Pattern);
                    return FALSE;
                }
            } else if (p == Pattern) {
                if (Root) {
                    p++;
                    c = 0;
                } else {
                    _tprintf (TEXT("Pattern is bad: %s\n"), Pattern);
                    return FALSE;
                }
            }
        }

        StringCopyAB (FilePattern, Pattern, p);

        if (*p) {
            NextPattern = p;
            if (*NextPattern == c) {
                NextPattern++;
            }
        } else {
            NextPattern = NULL;
        }
    }

    //
    // If NextPattern is NULL, then we must delete this pattern
    //

    if (!NextPattern) {
        if (g_Recursive) {
            wsprintf (SubPattern, TEXT("*.*\\%s"), Pattern);
            if (!pKillEverything (SubPattern, FALSE)) {
                return FALSE;
            }
        }
        pKillPattern (Pattern);
    }

    //
    // Otherwise we enumerate the files and dirs at this level,
    // and apply the rest of the pattern to the subdirs
    //

    else {
        d = GetFileAttributes (FilePattern);

        if (d != INVALID_ATTRIBUTES && (d & FILE_ATTRIBUTE_DIRECTORY)) {
            if (!SetCurrentDirectory (FilePattern)) {
                _tprintf (TEXT("Can't change dir to %s\n"), FilePattern);
                return FALSE;
            }

            if (!pKillEverything (NextPattern, FALSE)) {
                return FALSE;
            }

        } else if (EnumFirstFile (&e, TEXT("."), FilePattern)) {

            do {
                if (e.Directory) {
                    SetCurrentDirectory (CurrentDir);

                    if (SetCurrentDirectory (e.FileName)) {
                        if (!pKillEverything (NextPattern, FALSE)) {
                            AbortFileEnum (&e);
                            return FALSE;
                        }
                    }
                }
            } while (EnumNextFile (&e));
        }
    }

    SetCurrentDirectory (CurrentDir);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\lookup\lookup.c ===
#include "pch.h"
#include "..\..\w95upgnt\migmain\migmainp.h"

INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    if (!MyInitLibs (argc >= 2 ? argv[1] : NULL)) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    MemDbSetValue (TEXT("KnownDomain\\Redmond\\jimschm"), 0);
    MemDbSetValue (TEXT("KnownDomain\\Redmond\\marcw"), 0);
    MemDbSetValue (TEXT("KnownDomain\\Redmond\\mikeco"), 0);
    MemDbSetValue (TEXT("KnownDomain\\Red-Mo\\joehol"), 0);
    MemDbSetValue (TEXT("KnownDomain\\Red-Mo\\Administrator"), 0);
    MemDbSetValue (TEXT("AutosearchDomain\\w95mig1"), 0);
    MemDbSetValue (TEXT("AutosearchDomain\\w95mig5"), 0);
    MemDbSetValue (TEXT("AutosearchDomain\\fooacct"), 0);

    if (!SearchDomainsForUserAccounts()) {
        printf ("SearchDomainsForUserAccounts failed.  Error=%u\n", GetLastError());
    }

    MyTerminateLibs();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\locinfo\locinfo.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    locinfo.c

Abstract:

    Implements a tool that displays various localization details.

Author:

    Jim Schmidt (jimschm) 26-Feb-1999

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    //
    // TODO: Add others here if needed (don't forget to prototype above)
    //

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        //
        // Describe command line syntax(es), indent 2 spaces
        //

        TEXT("  locinfo [-c] [-s] [-v]\n")

        TEXT("\nDescription:\n\n")

        TEXT("  locinfo displays details about localization.\n")

        TEXT("\nArguments:\n\n")

        TEXT("  -c  Displays CP_ACP, CP_OEMCP and the default LCID\n")
        TEXT("  -s  Displays startup info\n")
        TEXT("  -v  Displays version info\n")

        );

    exit (1);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg;
    BOOL DisplayCp = FALSE;
    UINT Cp;
    LCID LcId;
    BOOL DisplayStartUpInfo = FALSE;
    BOOL DisplayVersionInfo = FALSE;
    STARTUPINFO si;

    //
    // Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('c'):
                if (DisplayCp) {
                    HelpAndExit();
                }

                DisplayCp = TRUE;
                break;

            case TEXT('s'):
                if (DisplayStartUpInfo) {
                    HelpAndExit();
                }

                DisplayStartUpInfo = TRUE;
                break;

            case TEXT('v'):
                if (DisplayVersionInfo) {
                    HelpAndExit();
                }

                DisplayVersionInfo = TRUE;
                break;

            case TEXT('f'):
                //
                // Sample option - /f:file
                //

                HelpAndExit();      // remove this

                if (argv[i][2] == TEXT(':')) {
                    FileArg = &argv[i][3];
                } else if (i + 1 < argc) {
                    FileArg = argv[++i];
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            // None
            HelpAndExit();
        }
    }

    //
    // Verify a valid option is specified, otherwise default to
    // DisplayCp
    //

    if (!DisplayCp && !DisplayStartUpInfo && !DisplayVersionInfo) {
        DisplayCp = TRUE;
    }

    if (DisplayCp && DisplayStartUpInfo) {
        HelpAndExit();
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // Do work here
    //

    if (DisplayCp) {
        Cp = GetACP();
        _tprintf (TEXT("ANSI Code Page: %u (0x%04X)\n"), Cp, Cp);

        Cp = GetOEMCP();
        _tprintf (TEXT("OEM Code Page:  %u (0x%04X)\n"), Cp, Cp);

        LcId = GetThreadLocale();
        _tprintf (TEXT("Thread Locale:  %u (0x%04X)\n"), LcId, LcId);

        LcId = GetSystemDefaultLCID();
        _tprintf (TEXT("System Locale:  %u (0x%04X)\n"), LcId, LcId);

        LcId = GetUserDefaultLCID();
        _tprintf (TEXT("User Locale:    %u (0x%04X)\n"), LcId, LcId);

        _tprintf (TEXT("\n"));
    }

    if (DisplayStartUpInfo) {

        si.cb = sizeof (si);
        GetStartupInfo (&si);

        _tprintf (TEXT("lpDesktop       %s\n"), si.lpDesktop);
        _tprintf (TEXT("lpTitle         %s\n"), si.lpTitle);
        _tprintf (TEXT("dwX             %u\n"), si.dwX);
        _tprintf (TEXT("dwY             %u\n"), si.dwY);
        _tprintf (TEXT("dwXSize         %u\n"), si.dwXSize);
        _tprintf (TEXT("dwYSize         %u\n"), si.dwYSize);
        _tprintf (TEXT("dwXCountChars   %u\n"), si.dwXCountChars);
        _tprintf (TEXT("dwYCountChars   %u\n"), si.dwYCountChars);
        _tprintf (TEXT("dwFillAttribute %u\n"), si.dwFillAttribute);
        _tprintf (TEXT("dwFlags         %u\n"), si.dwFlags);
        _tprintf (TEXT("wShowWindow     %u\n"), si.wShowWindow);
        _tprintf (TEXT("hStdInput       %u\n"), si.hStdInput);
        _tprintf (TEXT("hStdOutput      %u\n"), si.hStdOutput);
        _tprintf (TEXT("hStdError       %u\n"), si.hStdError);

        _tprintf (TEXT("\n"));
        Sleep (10000);
    }

    if (DisplayVersionInfo) {
        DWORD result;
        OSVERSIONINFO info;

        result = GetVersion ();
        _tprintf (TEXT("GetVersion result   0x%08X\n"), result);
        _tprintf (TEXT("OS major            0x%02X\n"), (DWORD)(LOBYTE(LOWORD(result))));
        _tprintf (TEXT("OS minor            0x%02X\n"), (DWORD)(HIBYTE(LOWORD(result))));
        _tprintf (TEXT("OS HI word          0x%04X\n"), (DWORD)(HIWORD(result)));

        info.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (GetVersionEx (&info)) {
            _tprintf (TEXT("\nGetVersionEx result\n"));
            _tprintf (TEXT("OS major            0x%08X\n"), info.dwMajorVersion);
            _tprintf (TEXT("OS minor            0x%08X\n"), info.dwMinorVersion);
            _tprintf (TEXT("OS Build nr.        0x%08X\n"), info.dwBuildNumber);
            _tprintf (TEXT("OS Platform ID      0x%08X\n"), info.dwPlatformId);
            _tprintf (TEXT("OS CSD version      %s\n"), info.szCSDVersion);

        }

    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\lookup\pch.h ===
#define CONSOLE
#include "master.h"
#include "masternt.h"


BOOL
MyInitLibs (
    PCSTR Path      OPTIONAL
    );

VOID
MyTerminateLibs (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\memdbren\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\lookup\init.c ===
#include "pch.h"
#include "resource.h"

extern PCTSTR GetMemDbDat (VOID);

HANDLE g_hHeap;
HWND g_ParentWnd;
HINSTANCE g_hInst;
HINF g_Win95UpgInf;

TCHAR g_WinDir[MAX_TCHAR_PATH];
TCHAR g_System32Dir[MAX_TCHAR_PATH];
TCHAR g_TempDir[MAX_TCHAR_PATH];
TCHAR g_ProfileDir[MAX_TCHAR_PATH];
PCTSTR g_SourceDir;
static TCHAR WinDir[MAX_TCHAR_PATH];
static TCHAR TempDir[MAX_TCHAR_PATH];
static TCHAR ProfileDir[MAX_TCHAR_PATH];
static TCHAR System32Dir[MAX_TCHAR_PATH];
static TCHAR WkstaMigInf[MAX_TCHAR_PATH];

//
// Define structure we pass around to describe a billboard.
//
typedef struct _BILLBOARD_PARAMS {
    LPCTSTR Message;
    HWND Owner;
    DWORD NotifyThreadId;
} BILLBOARD_PARAMS, *PBILLBOARD_PARAMS;

//
// Custom window messages
//
#define WMX_BILLBOARD_DISPLAYED     (WM_USER+243)
#define WMX_BILLBOARD_TERMINATE     (WM_USER+244)

BOOL
BillboardDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(msg) {

    case WM_INITDIALOG:
        {
            PBILLBOARD_PARAMS BillParams = (PBILLBOARD_PARAMS) lParam;
            PWSTR p;
            BOOL b;

            g_ParentWnd = hdlg;

            SetDlgItemText (hdlg, IDT_STATIC_1, BillParams->Message);
            CenterWindow (hdlg, NULL);
            PostMessage(hdlg,WMX_BILLBOARD_DISPLAYED,0,(LPARAM)BillParams->NotifyThreadId);
        }
        break;

    case WMX_BILLBOARD_DISPLAYED:

        PostThreadMessage(
            (DWORD)lParam,
            WMX_BILLBOARD_DISPLAYED,
            TRUE,
            (LPARAM)hdlg
            );

        break;

    case WMX_BILLBOARD_TERMINATE:

        EndDialog(hdlg,0);
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


DWORD
BillboardThread(
    IN PVOID ThreadParam
    )
{
    PBILLBOARD_PARAMS BillboardParams;
    int i;

    BillboardParams = ThreadParam;

    i = DialogBoxParam(
            g_hInst,
            MAKEINTRESOURCE(IDD_BILLBOARD1),
            BillboardParams->Owner,
            BillboardDlgProc,
            (LPARAM)BillboardParams
            );

    return(0);
}


HWND
DisplayBillboard(
    IN HWND Owner,
    IN LPCTSTR Message
    )
{
    HANDLE ThreadHandle;
    DWORD ThreadId;
    BILLBOARD_PARAMS ThreadParams;
    HWND hwnd;
    MSG msg;

    hwnd = NULL;

    //
    // The billboard will exist in a separate thread so it will
    // always be responsive.
    //
    ThreadParams.Message = Message;
    ThreadParams.Owner = Owner;
    ThreadParams.NotifyThreadId = GetCurrentThreadId();

    ThreadHandle = CreateThread(
                        NULL,
                        0,
                        BillboardThread,
                        &ThreadParams,
                        0,
                        &ThreadId
                        );

    if(ThreadHandle) {
        //
        // Wait for the billboard to tell us its window handle
        // or that it failed to display the billboard dialog.
        //
        do {
            GetMessage(&msg,NULL,0,0);
            if(msg.message == WMX_BILLBOARD_DISPLAYED) {
                if(msg.wParam) {
                    hwnd = (HWND)msg.lParam;
                    Sleep(1500);        // let the user see it even on fast machines
                }
            } else {
                DispatchMessage(&msg);
            }
        } while(msg.message != WMX_BILLBOARD_DISPLAYED);

        CloseHandle(ThreadHandle);
    }

    return(hwnd);
}


VOID
KillBillboard(
    IN HWND BillboardWindowHandle
    )
{
    if(IsWindow(BillboardWindowHandle)) {
        PostMessage(BillboardWindowHandle,WMX_BILLBOARD_TERMINATE,0,0);
    }
}



BOOL
MyInitLibs (
    PCSTR Path     OPTIONAL
    )
{
    DWORD ThreadId;
    PCWSTR UnicodePath;
    CHAR TempDirA[MAX_MBCHAR_PATH];

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle(NULL);

    if (!Path) {
        GetWindowsDirectoryA (TempDirA, MAX_MBCHAR_PATH);
        Path = TempDirA;
    }

    DisplayBillboard (GetDesktopWindow(), TEXT("Test application started"));

    //
    // Official init
    //

    FirstInitRoutine (g_hInst);

    InitLibs (g_hInst, DLL_PROCESS_ATTACH, NULL);

    FinalInitRoutine();

    //
    // Redirect settings
    //

    UnicodePath = ConvertAtoW (Path);

    StringCopy (WinDir, UnicodePath);

    StringCopy (TempDir, WinDir);
    StringCopy (AppendWack (TempDir), TEXT("setup"));

    StringCopy (ProfileDir, WinDir);
    StringCopy (AppendWack (ProfileDir), TEXT("Profiles"));

    StringCopy (System32Dir, WinDir);
    StringCopy (AppendWack (System32Dir), TEXT("system32"));

    StringCopy (WkstaMigInf, UnicodePath);
    StringCopy (AppendWack (WkstaMigInf), TEXT("wkstamig.inf"));

    StringCopy (g_WinDir, WinDir);
    StringCopy (g_TempDir, TempDir);
    g_SourceDir = WinDir;
    StringCopy (g_ProfileDir, ProfileDir);
    StringCopy (g_System32Dir, System32Dir);
    g_WkstaMigInf = WinDir;

    MemDbLoad (GetMemDbDat());

    FreeConvertedStr (UnicodePath);

    return TRUE;
}


VOID
MyTerminateLibs (
    VOID
    )
{
    FirstCleanupRoutine();
    TerminateLibs (g_hInst, DLL_PROCESS_DETACH, NULL);
    FinalCleanupRoutine();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\lookup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by billbrd.rc
//
#define IDD_BILLBOARD1                  62
#define IDI_SETUP                       81
#define IDT_STATIC_1                    1017
#define IDC_ICON1                       1025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\migid\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\loctool\loctool.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    loctool.c

Abstract:

    Loctool provides a platform for various localized version testing.

Author:

    Marc R. Whitten (marcw) 24-Mar-1999

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    //
    // TODO: Add others here if needed (don't forget to prototype above)
    //

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        TEXT("  cmntool [/F:file]\n")

        TEXT("\nDescription:\n\n")

        //
        // TODO: Describe tool, indent 2 spaces
        //

        TEXT("  cmntool is a stub!\n")

        TEXT("\nArguments:\n\n")

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        TEXT("  /F  Specifies optional file name\n")

        );

    exit (1);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg;
    HKEY key;
    PTSTR p;
    TCHAR buffer[MEMDB_MAX];


    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('f'):
                //
                // Sample option - /f:file
                //

                if (argv[i][2] == TEXT(':')) {
                    FileArg = &argv[i][3];
                } else if (i + 1 < argc) {
                    FileArg = argv[++i];
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            // None
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }


    printf (
        "GetKeyboardType (0) : %u\n"
        "GetKeyboardType (1) : %u\n",
        GetKeyboardType(0),
        GetKeyboardType(1)
        );

    printf ("ACP: %u\n", GetACP ());
    printf (
        "Version Info:\n"
        "MajorVersion: %u\n"
        "MinorVersion: %u\n"
        "Build (High/Low): %u (%u/%u)\n"
        "PlatformID %u\n"
        "VerString %s\n",
        g_OsInfo.dwMajorVersion,
        g_OsInfo.dwMinorVersion,
        g_OsInfo.dwBuildNumber,
        HIWORD(g_OsInfo.dwBuildNumber),
        LOWORD(g_OsInfo.dwBuildNumber),
        g_OsInfo.dwPlatformId,
        g_OsInfo.szCSDVersion
        );



    printf ("Build: %u/%u\n", HIWORD(g_OsInfo.dwBuildNumber), LOWORD(g_OsInfo.dwBuildNumber));

    key = OpenRegKeyStr ("HKCU\\Control Panel\\desktop\\ResourceLocale");
    if (key) {
        p = GetRegValueString (key, "");
        CloseRegKey (key);
    }

    printf ("Default locale (registry): %s\n", p);


    GetLocaleInfo (
        LOCALE_SYSTEM_DEFAULT,
        LOCALE_IDEFAULTLANGUAGE,
        buffer,
        MEMDB_MAX
        );

    printf ("LOCALE_SYSTEM_DEFAULT: %s\n", buffer);

    GetLocaleInfo (
        LOCALE_USER_DEFAULT,
        LOCALE_IDEFAULTLANGUAGE,
        buffer,
        MEMDB_MAX
        );

    printf ("LOCALE_USER_DEFAULT: %s\n", buffer);


    GetLocaleInfo (
        LOCALE_SYSTEM_DEFAULT,
        LOCALE_IDEFAULTCODEPAGE,
        buffer,
        MEMDB_MAX
        );

    printf ("IDEFAULTCODEPAGE: %s\n", buffer);


    GetLocaleInfo (
        LOCALE_SYSTEM_DEFAULT,
        LOCALE_IDEFAULTANSICODEPAGE,
        buffer,
        MEMDB_MAX
        );

    printf ("IDEFAULTANSICODEPAGE: %s\n", buffer);


    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\migid\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\memdbt\pch.h ===
#define COMMON_INCLUDES
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\migfiles\makefile.inc ===
obj\$(TARGET_DIRECTORY)\migfiles.res: migfiles.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\memdbt\memdbt.c ===
#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

#ifndef DEBUG
#error MemDbt must be built with DEBUG defined
#endif

#define ONEBITSET(x)    ((x) && !((x) & ((x) - 1)))

typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);

INITROUTINE_PROTOTYPE MigUtil_Entry;
INITROUTINE_PROTOTYPE MemDb_Entry;
INITROUTINE_PROTOTYPE FileEnum_Entry;


typedef struct {
    DWORD Bit;
    PCSTR Name;
} PROPNAME, *PPROPNAME;

#define DEFMAC(opbit,name,memdbname,prop_ct)  {opbit,#name},

PROPNAME g_PropNames[] = {
    PATH_OPERATIONS /* , */
    {0, NULL}
};


VOID
HelpAndExit (
    VOID
    )
{
    printf ("Brief Help:\n\n"
        "/A      All values (or export as ANSI)\n"
        "/C      Check internal consistency of memdb.\n"
        "/D:<n>  Enumeration depth\n"
        "/E      Dump file operation reference help.\n"
        "/E:<n>  List all files in operation n.\n"
        "/ER:<r> Specifies export root\n"
        "/EF:<f> Specifies export file\n"
        "/F      Find keys that have values equal to <value>\n"
        "/I      Import an exported file\n"
        "/L:<f>  List operations for file f\n"
        "/N      GetFileStatusOnNt for <value>\n"
        "/NP     GetFilePathOnNt for <value>\n"
        "/O      List offsets in enumeration.\n"
        "/O:<n>  Display key at offset n.\n"
        "/P:<p>  Search pattern is p.\n"
        "/S      Start level for enumeration.\n"
        "\n"
        "/??     Full Help\n"
        );

    exit(1);
}

VOID
FullHelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
        "memdbt [file] [/P:pattern] [/D:depth] [/A] [/Z] [/H] [/K]\n"
        "       [/F[U|A|O]:<value>] [/O]\n"
        "memdbt [file] /T\n"
        "memdbt [file] /O:<n> [/Z] [/K]\n"
        "memdbt [file] /G:<key> [/Z] [/K]\n"
        "memdbt [file] /C [/P:pattern]\n"
        "memdbt [file] /$\n"
        "memdbt [file] /[B|X]:<root1>,<root2> [/D:depth] [/A] [/Z] [/H] [/K]\n"
        "memdbt [file] /L:<9x_file>\n"
        "memdbt [file] /E:<fileop>\n"
        "memdbt [file] /N[P]:<path>\n"
        "memdbt [file] /ER:<root> /EF:<file> [/A]\n"
        "memdbt /I:<filename> [file to update]\n"
        "\n"
        "/A      If specified, all levels are enumerated, including those\n"
        "        that are not endpoints.  If specified with /EX, export is\n"
        "        saved in ANSI format."
        "/B      Show keys in both <root1> and <root2>\n"
        "/C      Check internal consistency of memdb.\n"
        "/D      Specifies how many levels in the database to enumarate.\n"
        "        If 0 (or not specified), all levels are enumarated.\n"
        "/E      If <n> is specified, enumerates all entries in fileop.\n"
        "        fileop is a numeric value.\n"
        "        If <n> is not specified, lists all operation names with vals\n"
        "/ER     Specifies root key to export\n"
        "/EF     Specifies export output file\n"
        "/F      Find keys that have values equal to <value>\n"
        "/FU     Find keys that have user flags equal to <value>\n"
        "/FA     Find keys that have user flags set to <value>\n"
        "/FO     Find keys that have user flags not set to <value>\n"
        "/G      MemDbGetValue <key>\n"
        "/H      Hide binary dump\n"
        "/I      Import an exported file\n"
        "/K      Show only keys, not values or user flags.\n"
        "/L      List operations for 9x_file\n"
        "/N      GetFileStatusOnNt for <value>\n"
        "/NP     GetFilePathOnNt for <value>\n"
        "/O      If <n> is specified, dumps key at offset <n>\n"
        "        If <n> is not specified, displays offset for each key\n"
        "/P      Specifies the search pattern for enumaration, and can\n"
        "        include a starting path (i.e. HKLM\\*)\n"
        "/S      Specifies the starting level (the minimum number of levels\n"
        "        before an entry is displayed).  Must be less than /D option\n"
        "        when a non-zero value is specified for /D.  If not specified,\n"
        "        all levels are displayed.\n"
        "/V      Displays version of ntsetup.dat.\n"
        "/X      Show keys in <root1> but not in <root2>\n"
        "/Z      Show zero values (default is to show only non-zero values)\n"
        "/$      Dump the hash table\n"
        );

    exit(1);
}

VOID
DumpData (
    BYTE const * Data,
    DWORD Count
    );

DWORD
pGetValue (
    IN      PCSTR Arg
    )
{
    INT Base = 10;
    PCSTR p;
    DWORD Value;

    if (Arg[0] == '0' && tolower (Arg[1]) == 'x') {
        Base = 16;
    } else {
        p = GetEndOfStringA (Arg);
        if (p > Arg) {
            p--;
            if (tolower (*p) == 'h') {
                Base = 16;
            }
        }
    }

    Value = strtoul (Arg, NULL, Base);

    return Value;
}


INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    MEMDB_ENUMA e;
    CHAR *szDepth;
    INT nDepth;
    INT nStartDepth;
    CHAR *szPattern;
    BOOL bNodesOnly = TRUE;
    CHAR *FileSpec;
    INT i;
    INT j;
    MEMDB_VERSION Version;
    DWORD dwReason = DLL_PROCESS_ATTACH;
    BOOL ShowZVals = FALSE;
    BOOL HideDump = FALSE;
    PCSTR NumericalArg;
    BOOL Offset = FALSE;
    DWORD OffsetVal;
    CHAR Key[MEMDB_MAX];
    DWORD RetVal;
    DWORD Flags;
    BOOL GetVal = FALSE;
    PCSTR GetValStr;
    BOOL Check = FALSE;
    PSTR p;
    BOOL KeysOnly = FALSE;
    PSTR DiffRootA = NULL;
    PSTR DiffRootB = NULL;
    BOOL DiffNot = FALSE;
    CHAR RootBuf[MEMDB_MAX * 2];
    CHAR RootPattern[MEMDB_MAX];
    CHAR CompareNode[MEMDB_MAX];
    BOOL Match;
    BOOL DumpHashTable = FALSE;
    BOOL DumpVersion = FALSE;
    HASHENUM HashEnum;
    BOOL FindValue = FALSE;
    DWORD ValueToFind;
    BOOL DisplayOffset = FALSE;
    BOOL UserFlags = FALSE;
    BOOL AndFlags = FALSE;
    BOOL NandFlags = FALSE;
    PCSTR ExportRoot = NULL;
    PCSTR ExportFile = NULL;
    PCSTR File9x = NULL;
    BOOL ListFileOps = FALSE;
    ALL_FILEOPS_ENUM FileOpEnum;
    FILEOP_ENUM eOp;
    FILEOP_PROP_ENUM eOpProp;
    OPERATION LastOperation;
    DWORD EnumOperation = 0;
    PCSTR ImportFile = NULL;
    BOOL AnsiFormat = FALSE;
    PCSTR FileStatusValue = NULL;
    BOOL FilePathWithStatus = FALSE;
    DWORD Status;

    //
    // Init
    //

    SuppressAllLogPopups (TRUE);

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle(NULL);

    if (!MigUtil_Entry (g_hInst, dwReason, NULL)) {
        fprintf (stderr, "MigUtil could not init\n");
        return FALSE;
    }

    if (!MemDb_Entry (g_hInst, dwReason, NULL)) {
        fprintf (stderr, "MemDb could not init\n");
        return FALSE;
    }

    FileSpec = NULL;
    szPattern = "*";
    nDepth = 0;
    nStartDepth = 0;

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {

            case '?':
                if (argv[i][2] == '?') {
                    FullHelpAndExit();
                }

                HelpAndExit();
                break;

            case '$':
                if (argv[i][2]) {
                    HelpAndExit();
                }

                if (DumpHashTable) {
                    HelpAndExit();
                }

                DumpHashTable = TRUE;
                break;

            case 'i':
                if (ImportFile) {
                    HelpAndExit();
                }

                if (argv[i][2] == ':') {
                    ImportFile = &argv[i][3];
                } else {
                    i++;
                    if (i < argc) {
                        ImportFile = argv[i];
                    } else {
                        HelpAndExit();
                    }
                }

                break;

            case 'k':
                if (argv[i][2]) {
                    HelpAndExit();
                }

                if (KeysOnly) {
                    HelpAndExit();
                }

                KeysOnly = TRUE;
                break;

            case 'l':
                if (ListFileOps) {
                    HelpAndExit();
                }

                ListFileOps = TRUE;

                if (argv[i][2] == ':') {
                    File9x = &argv[i][3];
                } else {
                    i++;
                    if (i < argc) {
                        File9x = argv[i];
                    } else {
                        HelpAndExit();
                    }
                }

                break;

            case 'n':
                if (FileStatusValue) {
                    HelpAndExit();
                }

                if (tolower (argv[i][2]) == 'p') {
                    p = &argv[i][3];
                    FilePathWithStatus = TRUE;
                } else {
                    p = &argv[i][2];
                }

                if (*p == ':') {
                    FileStatusValue = p + 1;
                } else {
                    i++;
                    if (i < argc) {
                        FileStatusValue = argv[i];
                    } else {
                        HelpAndExit();
                    }
                }

                break;

            case 'p':
                if (DiffRootA) {
                    HelpAndExit();
                }

                if (argv[i][2] == ':') {
                    szPattern = &argv[i][3];
                } else {
                    i++;
                    if (i < argc) {
                        szPattern = argv[i];
                    } else {
                        HelpAndExit();
                    }
                }
                break;

            case 'd':
                if (argv[i][2] == ':') {
                    szDepth = &argv[i][3];
                } else {
                    i++;
                    if (i < argc) {
                        szDepth = argv[i];
                    } else {
                        HelpAndExit();
                    }
                }

                nDepth = pGetValue (szDepth);
                break;

            case 's':
                if (argv[i][2] == ':') {
                    szDepth = &argv[i][3];
                } else {
                    i++;
                    if (i < argc) {
                        szDepth = argv[i];
                    } else {
                        HelpAndExit();
                    }
                }

                nStartDepth = pGetValue (szDepth);
                break;

            case 'x':
                DiffNot = TRUE;

                // fall through

            case 'b':
                if (DiffRootA) {
                    HelpAndExit();
                }

                if (argv[i][2] != ':') {
                    HelpAndExit();
                }

                StringCopy (RootBuf, &argv[i][3]);

                DiffRootA = RootBuf;
                DiffRootB = _mbschr (DiffRootA, ',');
                if (!DiffRootB) {
                    HelpAndExit();
                }

                *DiffRootB = 0;
                DiffRootB++;
                while (*DiffRootB == ' ') {
                    DiffRootB++;
                }

                StringCopy (RootPattern, DiffRootA);
                StringCopy (AppendWackA (RootPattern), "*");
                szPattern = RootPattern;

                break;

            case 'a':
                if (!bNodesOnly) {
                    HelpAndExit();
                }

                if (argv[i][2]) {
                    HelpAndExit();
                }

                bNodesOnly = FALSE;
                break;

            case 'o':
                if (Offset || DisplayOffset) {
                    HelpAndExit();
                }

                if (argv[i][2] == ':') {
                    OffsetVal = pGetValue (&argv[i][3]);
                    Offset = TRUE;
                } else {
                    DisplayOffset = TRUE;
                }

                break;

            case 'e':
                if (tolower (argv[i][2]) == 'r') {
                    if (ExportRoot) {
                        HelpAndExit();
                    }

                    if (argv[i][3] == ':') {
                        ExportRoot = &argv[i][4];
                    } else {
                        i++;
                        if (i < argc) {
                            ExportRoot = argv[i];
                        } else {
                            HelpAndExit();
                        }
                    }

                    break;
                }

                if (tolower (argv[i][2]) == 'f') {
                    if (ExportFile) {
                        HelpAndExit();
                    }

                    if (argv[i][3] == ':') {
                        ExportFile = &argv[i][4];
                    } else {
                        i++;
                        if (i < argc) {
                            ExportFile = argv[i];
                        } else {
                            HelpAndExit();
                        }
                    }

                    break;
                }

                if (EnumOperation) {
                    HelpAndExit();
                }

                if (argv[i][2] == ':') {

                    for (j = 0 ; g_PropNames[j].Bit ; j++) {
                        if (StringIMatch (&argv[i][3], g_PropNames[j].Name)) {
                            EnumOperation = g_PropNames[j].Bit;
                            break;
                        }
                    }

                    if (!g_PropNames[j].Bit) {
                        EnumOperation = pGetValue (&argv[i][3]);
                    }
                } else {
                    printf ("Operations:\n\n");

                    for (j = 0 ; g_PropNames[j].Bit ; j++) {
                        printf ("  0x%06X: %s\n", g_PropNames[j].Bit, g_PropNames[j].Name);
                    }

                    return 0;
                }

                if (!ONEBITSET (EnumOperation)) {
                    HelpAndExit();
                }

                break;

            case 'f':
                if (FindValue) {
                    HelpAndExit();
                }

                FindValue = TRUE;

                NumericalArg = &argv[i][2];

                switch (tolower (*NumericalArg)) {

                case 'o':
                    NandFlags = TRUE;
                    NumericalArg++;
                    break;

                case 'a':
                    AndFlags = TRUE;
                    NumericalArg++;
                    break;

                case 'u':
                    UserFlags = TRUE;
                    NumericalArg++;
                    break;
                }

                if (*NumericalArg == ':') {
                    NumericalArg++;
                } else {
                    i++;
                    if (i < argc) {
                        NumericalArg = argv[i];
                    } else {
                        HelpAndExit();
                    }
                }

                ValueToFind = pGetValue (NumericalArg);
                break;

            case 'z':
                if (argv[i][2]) {
                    HelpAndExit();
                }

                if (ShowZVals) {
                    HelpAndExit();
                }

                ShowZVals = TRUE;
                break;

            case 'h':
                if (argv[i][2]) {
                    HelpAndExit();
                }

                if (HideDump) {
                    HelpAndExit();
                }

                HideDump = TRUE;
                break;

            case 'c':
                if (argv[i][2]) {
                    HelpAndExit();
                }

                if (Check) {
                    HelpAndExit();
                }

                Check = TRUE;
                break;

            case 'g':
                if (GetVal) {
                    HelpAndExit();
                }

                GetVal = TRUE;

                if (argv[i][2] == ':') {
                    GetValStr = &argv[i][3];
                } else {
                    i++;
                    if (i < argc) {
                        GetValStr = argv[i];
                    } else {
                        HelpAndExit();
                    }
                }

                break;

            case 'v':
                if (argv[i][2]) {
                    HelpAndExit();
                }

                if (DumpVersion) {
                    HelpAndExit();
                }

                DumpVersion = TRUE;

                break;

            default:
                HelpAndExit();
            }
        } else {
            if (FileSpec) {
                HelpAndExit();
            }

            FileSpec = argv[i];
        }
    }

    if (!FileSpec) {
        if (ImportFile) {
            FileSpec = "";
        } else {
            FileSpec = "ntsetup.dat";
        }
    }

    if (nDepth < nStartDepth)
        HelpAndExit();

    if (!DumpVersion && !MemDbLoad(FileSpec) && !ImportFile) {
        fprintf(stderr, "MemDbLoad failed. Error: %d\n", GetLastError());
        return 0;
    }

    if (ExportRoot) {
        AnsiFormat = !bNodesOnly;
    }

    //
    // Validate combinations
    //

    // Mutually exclusive options, only one can be TRUE:
    if ((
         (EnumOperation != 0) +
         ListFileOps +
         DumpVersion +
         Offset +
         FindValue +
         GetVal +
         DumpHashTable +
         Check +
         (ImportFile != NULL) +
         (ExportRoot != NULL) +
         (FileStatusValue != NULL)
         ) > 1) {

        HelpAndExit();
    }

    // Strange combinations
    if (DiffRootA && FindValue) {
        HelpAndExit();
    }

    if (!ListFileOps && File9x) {
        HelpAndExit();
    }

    if ((ExportRoot && !ExportFile) ||
        (!ExportFile && ExportRoot)
        ) {
        HelpAndExit();
    }

    //
    // memdbt /n (NT file status)
    //

    if (FileStatusValue) {

        Status = GetFileStatusOnNt (FileStatusValue);

        if (Status & FILESTATUS_DELETED) {
            printf ("FILESTATUS_DELETED\n");
        }

        if (Status & FILESTATUS_MOVED) {
            printf ("FILESTATUS_MOVED\n");
        }

        if (Status & FILESTATUS_REPLACED) {
            printf ("FILESTATUS_REPLACED\n");
        }

        if (Status & FILESTATUS_NTINSTALLED) {
            printf ("FILESTATUS_NTINSTALLED\n");
        }

        if (FilePathWithStatus) {
            p = GetPathStringOnNt (FileStatusValue);

            if (p) {
                printf ("\nPath: %s\n\n", p);
                FreePathString (p);
            } else {
                printf ("\nPath: <not found>\n\n");
            }
        }

        return 0;
    }

    //
    // memdbt /i (import)
    //

    if (ImportFile) {

        if (!MemDbImport (ImportFile)) {
            fprintf (stderr, "MemDbImport failed for %s. Error: %d\n", ImportFile, GetLastError());
            return 0;
        }

        if (*FileSpec) {
            if (!MemDbSave (FileSpec)) {
                fprintf (stderr, "MemDbSave failed for %s. Error: %d\n", FileSpec, GetLastError());
                return 0;
            }
        }

        return 0;
    }

    //
    // memdbt /x (export)
    //

    if (ExportRoot) {

        if (!MemDbExport (ExportRoot, ExportFile, AnsiFormat)) {
            fprintf (stderr, "MemDbExport failed to export %s to %s. Error: %d\n", ExportRoot, FileSpec, GetLastError());
            return 0;
        }

        return 0;
    }

    //
    // memdbt /e (enumerate file ops)
    //

    if (EnumOperation) {
        for (i = 0 ; g_PropNames[i].Bit ; i++) {
            if (g_PropNames[i].Bit & EnumOperation) {
                printf ("Enumeration of %s (0x%06X)\n", g_PropNames[i].Name, g_PropNames[i].Bit);
                break;
            }
        }

        if (!g_PropNames[i].Bit) {
            HelpAndExit();
        }

        if (EnumFirstPathInOperation (&eOp, EnumOperation)) {
            i = 0;

            do {
                if (i) {
                    printf ("\n");
                }

                i++;
                printf ("  %s (seq: %u)\n", eOp.Path, eOp.Sequencer);

                if (EnumFirstFileOpProperty (&eOpProp, eOp.Sequencer, EnumOperation)) {
                    do {
                        printf ("    %s=%s\n", eOpProp.PropertyName, eOpProp.Property);
                    } while (EnumNextFileOpProperty (&eOpProp));
                }
            } while (EnumNextPathInOperation (&eOp));
        }

        return 0;
    }

    //
    // memdbt /l (list file ops)
    //

    if (ListFileOps) {
        //
        // Enumerate all the properties
        //

        if (EnumFirstFileOp (&FileOpEnum, ALL_OPERATIONS, File9x)) {

            CompareNode[0] = 0;

            do {
                if (!StringMatch (CompareNode, FileOpEnum.Path)) {

                    //
                    // Begin processing a new path
                    //

                    printf ("\n%s:\n", FileOpEnum.Path);
                    StringCopy (CompareNode, FileOpEnum.Path);
                    LastOperation = 0;

                }

                //
                // Print the operation name
                //

                if (LastOperation != FileOpEnum.CurrentOperation) {

                    LastOperation = FileOpEnum.CurrentOperation;

                    for (i = 0 ; g_PropNames[i].Bit ; i++) {
                        if (g_PropNames[i].Bit & FileOpEnum.CurrentOperation) {
                            printf ("  %s (0x%06X)\n", g_PropNames[i].Name, g_PropNames[i].Bit);
                            break;
                        }
                    }
                }

                //
                // Print the property value
                //

                if (FileOpEnum.PropertyValid) {
                    printf ("    %u: %s\n",   FileOpEnum.PropertyNum, FileOpEnum.Property);
                }

            } while (EnumNextFileOp (&FileOpEnum));

        } else {
            printf ("%s:\n\n  No operations.", File9x);
        }

        printf ("\n");
        return 0;
    }

    //
    // memdbt /v (dump version)
    //

    if (DumpVersion) {

        if (MemDbQueryVersion (FileSpec, &Version)) {
            printf (
                "Version:  %u %s\n"
                    "Type:     %s\n",
                Version.Version,
                Version.CurrentVersion ? "(same as memdbt)" : "(not the same as memdbt)",
                Version.Debug ? "Checked Build" : "Free Build"
                );

        } else {
            fprintf (stderr, "%s is not a valid memdb file\n", FileSpec);
        }

        return 0;
    }

    //
    // memdbt /o:<offset> usage. (Get Key by offset)
    //
    if (Offset) {
        if (!MemDbBuildKeyFromOffset (OffsetVal, Key, 0, &RetVal)) {
            fprintf(stderr, "No key at specified offset.\n");
        } else {
            printf("%s", Key);
            if (RetVal || ShowZVals) {
                printf (" = %u (0x%X)", RetVal, RetVal);
            }

            printf ("\n");
        }

        return 0;
    }

    //
    // memdbt /g:<key> usage. (Get value of key)
    //
    if (GetVal) {
        if (!MemDbGetValue (GetValStr, &RetVal)) {
            fprintf (stderr, "%s does not exist", GetValStr);
        } else {
            printf ("Value of %s: %u\n", GetValStr, RetVal);
        }

        return 0;
    }

    //
    // memdbt /$ usage.  (Dump hash table)
    //
    if (DumpHashTable) {
        if (EnumFirstHashEntry (&HashEnum)) {
            do {
                if (!MemDbBuildKeyFromOffset (HashEnum.BucketPtr->Offset, Key, 0, &RetVal)) {
                    fprintf(stderr, "No key at offset %u.\n", HashEnum.BucketPtr->Offset);
                } else {
                    printf("%s", Key);
                    if (RetVal || ShowZVals) {
                        printf (" = %u (0x%X)", RetVal, RetVal);
                    }

                    printf ("\n");
                }

            } while (EnumNextHashEntry (&HashEnum));
        }

        return 0;
    }

    //
    // memdbt /c usage. (Check consistency)
    //
    if (Check) {
        if (MemDbEnumFirstValue(&e, szPattern, 0, MEMDB_ENDPOINTS_ONLY)) {

            BOOL NoProblems = TRUE;

            do {

                if (!MemDbGetValueAndFlags(e.szName, &RetVal, &Flags)) {
                    fprintf(stderr, "Error - MemDbGetValueAndFlags failed for %s.\n",e.szName);
                    NoProblems = FALSE;
                }


            } while (MemDbEnumNextValue(&e));

            if (NoProblems) {
                fprintf(stderr, "Memdb consistency check completed. No problems detected.\n");
            }
            else {
                fprintf(stderr, "One or more problems were found during the memdb consistency check.\n");
            }

        }
        else {
            fprintf(stderr, "Memdb empty. Nothing to check.\n");
        }
        return 0;
    }

    //
    // normal usage and comparison option
    //
    if (MemDbEnumFirstValue (
            &e,
            szPattern,
            nDepth,
            bNodesOnly ? MEMDB_ENDPOINTS_ONLY : NO_FLAGS
            )) {

        do {
            //
            // Comparison option
            //

            if (DiffRootA) {
                //
                // Do a MemDbGetValue
                //

                StringCopy (CompareNode, DiffRootB);
                StringCopy (AppendWack (CompareNode), e.szName);

                Match = MemDbGetValue (CompareNode, NULL);

                //
                // Skip if (A) DiffNot is FALSE and no match
                //         (B) DiffNot is TRUE and match
                //

                if (Match == DiffNot) {
                    continue;
                }
            }

            //
            // Normal usage/find value
            //

            if (e.PosCount >= nStartDepth) {
                //
                // Find value option
                //

                if (FindValue) {
                    if (UserFlags) {
                        if (e.UserFlags != ValueToFind) {
                            continue;
                        }
                    } else if (AndFlags) {
                        if ((e.UserFlags & ValueToFind) == 0) {
                            continue;
                        }
                    } else if (NandFlags) {
                        if (e.UserFlags & ValueToFind) {
                            continue;
                        }
                    } else if (e.dwValue != ValueToFind) {
                        continue;
                    }
                }

                //
                // Key output
                //

                if (DisplayOffset) {
                    printf ("[%08X] ", e.Offset);
                }

                if (e.bBinary && !KeysOnly) {
                    if (!HideDump) {
                        printf ("%s: (%u byte%s)\n", e.szName, e.BinarySize, e.BinarySize == 1 ? "" : "s");
                        DumpData (e.BinaryPtr, e.BinarySize);
                        printf ("\n");
                    } else {
                        printf ("%s (%u byte%s)\n", e.szName, e.BinarySize, e.BinarySize == 1 ? "" : "s");
                    }
                } else {
                    if (!KeysOnly) {
                        if (e.dwValue || ShowZVals) {
                            printf("%s = 0x%02lX", e.szName, e.dwValue);
                        } else {
                            printf("%s", e.szName);
                        }

                        if (e.UserFlags || ShowZVals) {
                            printf(", Flags: %04x", e.UserFlags);
                        }
                    } else {
                        printf("%s", e.szName);
                    }

                    printf ("\n");
                }
            }
        } while (MemDbEnumNextValue(&e));
    }

    dwReason = DLL_PROCESS_DETACH;
    MemDb_Entry (g_hInst, dwReason, NULL);
    MigUtil_Entry (g_hInst, dwReason, NULL);

    return 0;
}


VOID
DumpData (
    IN      BYTE const * Data,
    IN      DWORD Count
    )
{
    DWORD i, j, k;

    for (i = 0 ; i < Count ; i = k) {
        printf ("  %08X ", i);
        k = i + 16;
        for (j = i ; j < k && j < Count ; j++) {
            printf ("%02X ", Data[j]);
        }

        while (j < k) {
            printf ("   ");
            j++;
        }

        for (j = i ; j < k && j < Count ; j++) {
            if (isprint (Data[j])) {
                printf ("%c", Data[j]);
            } else {
                printf (".");
            }
        }

        printf ("\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\nttool\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\memdbren\memdbren.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    memdbren.c

Abstract:

    Implements a stub tool that is designed to run with NT-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

VOID
pFixUpMemDb2 (
    VOID
    );

BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();
}


INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{
    TREE_ENUM te;
    DWORD Value, Flags;
    DWORD Offset;
    TCHAR Node[MEMDB_MAX];
    FILEOP_ENUM e;
    FILEOP_PROP_ENUM eOpProp;
    PTSTR NewDest;
    TCHAR node[MEMDB_MAX];

    if (!Init()) {
        wprintf (L"Unable to initialize!\n");
        return 255;
    }

    CopyFile (TEXT("c:\\public\\ntsetup.bak"), TEXT("c:\\public\\ntsetup.dat"), FALSE);
    MemDbLoad (TEXT("c:\\public\\ntsetup.dat"));
    MemDbSave (TEXT("c:\\public\\ntsetup.dat"));

    pFixUpMemDb2();

    if (EnumFirstPathInOperation (&e, OPERATION_SHELL_FOLDER)) {
        do {
            wprintf (L"Operation %u\n", e.Sequencer);

            if (EnumFirstFileOpProperty (&eOpProp, e.Sequencer, OPERATION_SHELL_FOLDER)) {

                do {
                    wprintf (L"  %s: %s\n", eOpProp.PropertyName, eOpProp.Property);

                } while (EnumNextFileOpProperty (&eOpProp));
            }

        } while (EnumNextPathInOperation (&e));
    }

    MemDbSave (TEXT("c:\\public\\ntsetup.new"));

    MemDbValidateDatabase();

    Terminate();

    return 0;
}


PCTSTR
GetProfilePathForUser2 (
    PCTSTR User
    )
{
    static TCHAR Path[MAX_TCHAR_PATH];

    wsprintf (Path, TEXT("c:\\Documents and Settings\\%s"), User);

    return Path;
}



VOID
pFixUpDynamicPaths2 (
    PCTSTR Category
    )
{
    MEMDB_ENUM e;
    TCHAR Pattern[MEMDB_MAX];
    PTSTR p;
    GROWBUFFER Roots = GROWBUF_INIT;
    MULTISZ_ENUM e2;
    TCHAR NewRoot[MEMDB_MAX];
    TCHAR AllProfilePath[MAX_TCHAR_PATH];
    PCTSTR ProfilePath;
    DWORD Size;
    PTSTR UserName;
    HKEY sfKey = NULL;
    PCTSTR sfPath = NULL;
    PTSTR NtLocation;
    PCTSTR tempExpand;
    BOOL regFolder;

    //
    // Collect all the roots that need to be renamed
    //

    StringCopy (Pattern, Category);
    p = AppendWack (Pattern);
    StringCopy (p, TEXT("*"));

    if (MemDbEnumFirstValue (&e, Pattern, MEMDB_THIS_LEVEL_ONLY, MEMDB_ALL_BUT_PROXY)) {
        do {
            if ((_tcsnextc (e.szName) == TEXT('>')) ||
                (_tcsnextc (e.szName) == TEXT('<'))
                ) {
                StringCopy (p, e.szName);
                MultiSzAppend (&Roots, Pattern);
            }
        } while (MemDbEnumNextValue (&e));
    }

    //
    // Now change each root
    //

    if (EnumFirstMultiSz (&e2, (PCTSTR) Roots.Buf)) {
        do {
            //
            // Compute NewRoot
            //

            StringCopy (NewRoot, e2.CurrentString);

            p = _tcschr (NewRoot, TEXT('<'));

            if (p) {

                UserName = _tcschr (p, TEXT('>'));
                MYASSERT (UserName);
                StringCopyAB (Pattern, _tcsinc (p), UserName);
                UserName = _tcsinc (UserName);

                regFolder = TRUE;
                if (StringIMatch (Pattern, TEXT("Profiles"))) {
                    regFolder = FALSE;
                }
                if (StringIMatch (Pattern, TEXT("Common Profiles"))) {
                    regFolder = FALSE;
                }

                if (StringIMatch (UserName, S_DOT_ALLUSERS)) {
                    Size = MAX_TCHAR_PATH;
                    if (regFolder) {
                        if (!GetAllUsersProfileDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get All Users profile path."));
                            continue;
                        }
                        sfKey = OpenRegKeyStr (S_USHELL_FOLDERS_KEY_SYSTEM);
                    } else {
                        if (!GetProfilesDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get All Users profile path."));
                            continue;
                        }
                    }
                }
                else if (StringIMatch (UserName, S_DEFAULT_USER)) {
                    Size = MAX_TCHAR_PATH;
                    if (regFolder) {
                        if (!GetDefaultUserProfileDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get Default User profile path."));
                            continue;
                        }
                        sfKey = OpenRegKey (HKEY_CURRENT_USER, S_USHELL_FOLDERS_KEY_USER);
                    } else {
                        if (!GetProfilesDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get All Users profile path."));
                            continue;
                        }
                    }
                }
                else {
                    ProfilePath = GetProfilePathForUser2 (UserName);
                    if (!ProfilePath) {
                        DEBUGMSG ((DBG_WHOOPS, "Cannot get profile path for user:%s", UserName));
                        continue;
                    }
                    StringCopy (AllProfilePath, ProfilePath);
                    if (regFolder) {
                        sfKey = OpenRegKey (HKEY_CURRENT_USER, S_USHELL_FOLDERS_KEY_USER);
                    }
                }
                if (regFolder) {
                    if (!sfKey) {
                        DEBUGMSG ((DBG_ERROR, "Could not open Shell folders key."));
                        continue;
                    }
                    sfPath = GetRegValueString (sfKey, Pattern);
                    CloseRegKey (sfKey);
                    if (!sfPath) {
                        DEBUGMSG ((DBG_WHOOPS, "Could not get Shell Folder path for: %s", Pattern));
                        continue;
                    }
                    tempExpand = StringSearchAndReplace (
                                    sfPath,
                                    S_USERPROFILE_ENV,
                                    AllProfilePath
                                    );

                    if (!tempExpand) {
                        tempExpand = DuplicatePathString (sfPath, 0);
                    }
                } else {
                    tempExpand = DuplicatePathString (AllProfilePath, 0);
                }

                NtLocation = ExpandEnvironmentText (tempExpand);

                StringCopy (p, NtLocation);

                MemDbMoveTree (e2.CurrentString, NewRoot);

                FreeText (NtLocation);

                FreePathString (tempExpand);

                if (regFolder) {
                    MemFree (g_hHeap, 0, sfPath);
                }
            }
            else {

                p = _tcschr (NewRoot, TEXT('>'));
                MYASSERT (p);

                if (StringIMatch (_tcsinc (p), S_DOT_ALLUSERS)) {
                    Size = MAX_TCHAR_PATH;
                    if (!GetAllUsersProfileDirectory (AllProfilePath, &Size)) {
                        DEBUGMSG ((DBG_WARNING, "Dynamic path for %s could not be resolved", e2.CurrentString));
                    }
                    else {
                        StringCopy (p, AllProfilePath);
                        MemDbMoveTree (e2.CurrentString, NewRoot);
                    }
                } else if (StringIMatch (_tcsinc (p), S_DEFAULT_USER)) {
                    Size = MAX_TCHAR_PATH;
                    if (!GetDefaultUserProfileDirectory (AllProfilePath, &Size)) {
                        DEBUGMSG ((DBG_WARNING, "Dynamic path for %s could not be resolved", e2.CurrentString));
                    }
                    else {
                        StringCopy (p, AllProfilePath);
                        MemDbMoveTree (e2.CurrentString, NewRoot);
                    }
                } else {
                    ProfilePath = GetProfilePathForUser2 (_tcsinc (p));
                    if (ProfilePath) {
                        StringCopy (p, ProfilePath);
                        MemDbMoveTree (e2.CurrentString, NewRoot);
                    }
                    else {
                        DEBUGMSG ((DBG_WARNING, "Dynamic path for %s could not be resolved", e2.CurrentString));
                    }
                }

            }

        } while (EnumNextMultiSz (&e2));
    }

    FreeGrowBuffer (&Roots);
}


VOID
pFixUpMemDb2 (
    VOID
    )
{
    pFixUpDynamicPaths2 (MEMDB_CATEGORY_PATHROOT);
    pFixUpDynamicPaths2 (MEMDB_CATEGORY_DATA);
    pFixUpDynamicPaths2 (MEMDB_CATEGORY_USERFILEMOVE_DEST);
    pFixUpDynamicPaths2 (MEMDB_CATEGORY_SHELLFOLDERS_DEST);
    pFixUpDynamicPaths2 (MEMDB_CATEGORY_SHELLFOLDERS_SRC);
    pFixUpDynamicPaths2 (MEMDB_CATEGORY_LINKEDIT_TARGET);
    pFixUpDynamicPaths2 (MEMDB_CATEGORY_LINKEDIT_WORKDIR);
    pFixUpDynamicPaths2 (MEMDB_CATEGORY_LINKEDIT_ICONPATH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\migfiles\pch.h ===
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\nttool\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\pipe\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\migupd\pch.h ===
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\migfiles\migfiles.c ===
#include "pch.h"

#include <advpub.h>

#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <tchar.h>
#include <locale.h>

#include <winnt32p.h>
#include <init9x.h>
#include <migdb.h>
#include <sysmig.h>
#include "..\..\w95upg\migapp\migdbp.h"

typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);

INITROUTINE_PROTOTYPE MigUtil_Entry;
INITROUTINE_PROTOTYPE MemDb_Entry;
INITROUTINE_PROTOTYPE MigApp_Entry;
INITROUTINE_PROTOTYPE FileEnum_Entry;

HINSTANCE g_hInst;
HANDLE g_hHeap;

BOOL g_CancelFlag = FALSE;

#define ATTR_FILESIZE       0x1
#define ATTR_CHECKSUM       0x2
#define ATTR_COMPNAME       0x4
#define ATTR_FILEDESC       0x8
#define ATTR_FILEVER       0x10
#define ATTR_INTNAME       0x20
#define ATTR_LEGAL         0x40
#define ATTR_ORIGNAME      0x80
#define ATTR_PRODNAME     0x100
#define ATTR_PRODVER      0x200
#define ATTR_EXETYPE      0x400
#define ATTR_DESCR16      0x800

#ifdef DEBUG
extern BOOL            g_DoLog;
#endif
extern POOLHANDLE      g_MigDbPool;
extern PMIGDB_CONTEXT  g_ContextList;
extern VOID           *g_FileTable;
extern BOOL           *g_CancelFlagPtr = &g_CancelFlag;
extern POOLHANDLE      g_PathsPool;

extern PMIGDB_HOOK_PROTOTYPE g_MigDbHook;

typedef struct _PATTERN_FILE {
    PCTSTR Pattern;
    PMIGDB_ATTRIB PatternAttr;
    struct _PATTERN_FILE *Next;
} PATTERN_FILE, *PPATTERN_FILE;

PPATTERN_FILE g_AttrPatterns = NULL;

BOOL
pScanForFile (
    IN      PINFCONTEXT Context,
    IN      DWORD FieldIndex
    );


PMIGDB_ATTRIB
pLoadAttribData (
    IN      PCSTR MultiSzStr
    );


BOOL
CallAttribute (
    IN      PMIGDB_ATTRIB MigDbAttrib,
    IN      PDBATTRIB_PARAMS AttribParams
    );

BOOL
pWorkerFn (
    VOID
    );

BOOL
pLoadGoodFiles (
    IN      HINF ConfigHandle
    );

BOOL
pLoadAttributes (
    IN      HINF ConfigHandle
    );

BOOL
pLoadPatterns (
    IN      HINF ConfigHandle
    );

BOOL
pHandleSection (
    IN      PCTSTR SectionName,
    IN      HINF ConfigHandle
    );

BOOL
pWriteMemdbSection (
    IN      PCTSTR FileName,
    IN      PCTSTR MemDbCategory,
    IN      PCTSTR SectName,
    IN      BOOL WriteByValue
    );

BOOL
pArrangeMigDbFile (
    IN      PCTSTR SrcFile,
    IN      PCTSTR DestFile
    );

VOID
pUsage (
    VOID
    )
{
    _tprintf (TEXT ("\nCommand line syntax:\n\n"
                    "migfiles [/B:BaseDir] [/T:TempDir] [/F[:SectionName]]\n\n"
                    "/B    Specifies the base directory where all migdb files are\n"
                    "      located. (migdb.inx, migdb.cfg)\n"
                    "/L    Specifies full path to FILELIST.DAT\n"
                    "/T    Specifies the temporary directory used for unpacking\n"
                    "      cabinet files\n"
                    "/F    Forces rescanning a particular section or all sections\n"));
}

PTSTR g_ConfigFile = NULL;
PTSTR g_TempDir    = NULL;
PTSTR g_BaseDir    = NULL;
PTSTR g_MessageFile= NULL;
PTSTR g_MigdbSrc   = NULL;
PTSTR g_MigdbDest  = NULL;
PTSTR g_MigdbDump  = NULL;
PTSTR g_HistoryFile= NULL;
PTSTR g_RescanSect = NULL;
BOOL  g_RescanFlag = FALSE;
extern HINF  g_MigDbInf;
GROWBUFFER g_SectFiles = GROWBUF_INIT;
PTSTR g_FileListName = NULL;

#define MEMDB_CATEGORY_SECTFILES       TEXT("SectFiles")
#define MEMDB_CATEGORY_GOODFILES       TEXT("GoodFiles")
#define MEMDB_CATEGORY_WARNFILES       TEXT("WarnFiles")
#define MEMDB_CATEGORY_DUPLFILES       TEXT("DuplFiles")
#define MEMDB_CATEGORY_ACTION          TEXT("Action")
#define MEMDB_CATEGORY_ATTRIBUTES      TEXT("Attributes")
#define MEMDB_CATEGORY_RENAME_SRC      TEXT("RenameSrc")
#define MEMDB_CATEGORY_RENAME_DEST     TEXT("RenameDest")
#define MEMDB_CATEGORY_REQFILES        TEXT("RequiredFiles")

void
__cdecl
main (
    int argc,
    CHAR *argv[]
    )
{

    INT argidx, index;
    INT nextArg = 0;
    LONG rc;

#ifdef DEBUG
    g_DoLog = TRUE;
#endif

    g_hInst = GetModuleHandle (NULL);
    g_hHeap = GetProcessHeap();

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        _tprintf (TEXT("MigUtil failed initializing\n"));
        exit (1);
    }

    if (!MemDb_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        _tprintf (TEXT("MemDb failed initializing\n"));
        exit(1);
    }

    if (!MigApp_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        _tprintf (TEXT("MigApp failed initializing\n"));
        exit (1);
    }

    for (argidx = 1; argidx < argc; argidx++) {
        if ((argv[argidx][0] != '-') &&
            (argv[argidx][0] != '/')
            ) {
            if (nextArg == 0) {
                pUsage ();
                exit (1);
            }
            switch (nextArg) {
            case 1:
                index = 0;
                goto label1;
            case 2:
                index = 0;
                goto label2;
            case 3:
                index = 0;
                goto label3;
            case 4:
                index = 0;
                goto label4;
            }
        }
        switch (toupper(argv[argidx][1])) {
        case 'B':
            if (argv[argidx][2] == 0) {
                nextArg = 1;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label1:
                nextArg = 0;
                g_BaseDir = AllocPathString (MAX_TCHAR_PATH);
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, argv[argidx]+index, -1, g_BaseDir, MAX_TCHAR_PATH);
#else
                _tcsncpy (g_BaseDir, argv[argidx]+index, MAX_TCHAR_PATH);
#endif
            }
            break;

        case 'T':
            if (argv[argidx][2] == 0) {
                nextArg = 2;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label2:
                nextArg = 0;
                g_TempDir = AllocPathString (MAX_TCHAR_PATH);
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, argv[argidx]+index, -1, g_TempDir, MAX_TCHAR_PATH);
#else
                _tcsncpy (g_TempDir, argv[argidx]+index, MAX_TCHAR_PATH);
#endif
            }
            break;

        case 'F':
            g_RescanFlag = TRUE;
            if (argv[argidx][2] == 0) {
                nextArg = 3;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label3:
                nextArg = 0;
                g_RescanSect = AllocPathString (MAX_TCHAR_PATH);
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, argv[argidx]+index, -1, g_RescanSect, MAX_TCHAR_PATH);
#else
                _tcsncpy (g_RescanSect, argv[argidx]+index, MAX_TCHAR_PATH);
#endif
            }
            break;

        case 'L':
            if (argv[argidx][2] == 0) {
                nextArg = 4;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label4:
                nextArg = 0;
                g_FileListName = AllocPathString (MAX_TCHAR_PATH);
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, argv[argidx]+index, -1, g_FileListName, MAX_TCHAR_PATH);
#else
                _tcsncpy (g_FileListName, argv[argidx]+index, MAX_TCHAR_PATH);
#endif
            }
            break;

        default:
            pUsage ();
            exit (1);
        }
    }
    if (g_BaseDir == NULL) {
        g_BaseDir = AllocPathString (MAX_TCHAR_PATH);
        _tcsncpy (g_BaseDir, TEXT(".\\"), MAX_TCHAR_PATH);
    }
    if (g_TempDir == NULL) {
        g_TempDir = AllocPathString (MAX_TCHAR_PATH);
        if (GetEnvironmentVariable (TEXT("TEMP"), g_TempDir, MAX_TCHAR_PATH) == 0) {
            GetTempPath (MAX_TCHAR_PATH, g_TempDir);
        }
    }
    g_ConfigFile  = JoinPaths (g_BaseDir, TEXT("migdb.cfg"));
    g_MessageFile = JoinPaths (g_BaseDir, TEXT("migdb.msg"));
    g_HistoryFile = JoinPaths (g_BaseDir, TEXT("migdb.hst"));
    g_MigdbSrc    = JoinPaths (g_BaseDir, TEXT("migdb.inx"));
    g_MigdbDest   = JoinPaths (g_BaseDir, TEXT("migdb.tmp"));
    g_MigdbDump   = JoinPaths (g_BaseDir, TEXT("migdb.dmp"));

    if (!DoesFileExist (g_FileListName)) {
        _tprintf (TEXT("\nNT file list file not found. Exiting.\n"));
        exit (1);
    }

    if (!DoesFileExist (g_MigdbSrc)) {
        _tprintf (TEXT("\nSource file not found. Exiting.\n"));
        exit (1);
    }

    if (!DoesFileExist (g_ConfigFile)) {
        _tprintf (TEXT("\nConfiguration file not found. Exiting.\n"));
        exit (1);
    }

    if (SearchPath (NULL, TEXT("extract.exe"), NULL, 0, NULL, NULL) == 0) {
        _tprintf (TEXT("\nCannot find extract.exe. Exiting.\n"));
        exit (1);
    }

    CopyFile (g_MigdbSrc, g_MigdbDest, FALSE);
    DeleteFile (g_MessageFile);
    DeleteFile (g_MigdbDump);

    DISABLETRACKCOMMENT();

    g_InAnyDir = TRUE;

    _tprintf (TEXT("\nReading NT file list: %s"), g_FileListName);

    if (!ReadNtFilesEx (g_FileListName, FALSE)) {
        rc = GetLastError();

        printf ("Could not read %s.  Win32 Error Code: %x\n", g_FileListName, rc);
        exit (1);
    }

    _tprintf (TEXT("\nReading configuration files..."));

    if (!InitMigDbEx (g_MigdbSrc)) {
        rc = GetLastError();

        printf ("Could not read %s.  Win32 Error Code: %x\n", g_MigdbSrc, rc);
        exit (1);
    }

    DEBUGMSG ((DBG_ERROR , "TEST"));
    DEBUGMSG ((DBG_WHOOPS, "TEST"));

    pWorkerFn ();

    if (g_MigDbInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile (g_MigDbInf);
    }

    pWriteMemdbSection (g_MessageFile, MEMDB_CATEGORY_GOODFILES, TEXT("KNOWN GOOD - FILES FOUND"), FALSE);
    pWriteMemdbSection (g_MessageFile, MEMDB_CATEGORY_WARNFILES, TEXT("KNOWN GOOD - NAME COLLISIONS"), FALSE);
    pWriteMemdbSection (g_MessageFile, MEMDB_CATEGORY_DUPLFILES, TEXT("DUPLICATE FILES"), FALSE);

    // we need now to arrange a little bit the MIGDB.INX file
    pArrangeMigDbFile (g_MigdbDest, g_MigdbSrc);

    DeleteFile (g_MigdbDest);

    if (g_FileTable != NULL) {
        HtFree (g_FileTable);
    }
    if (g_MigDbPool != NULL) {
        PoolMemDestroyPool (g_MigDbPool);
    }

    FreePathString (g_ConfigFile);
    FreePathString (g_TempDir);
    FreePathString (g_BaseDir);
    FreePathString (g_MessageFile);
    FreePathString (g_MigdbSrc);
    FreePathString (g_MigdbDest);
    FreePathString (g_MigdbDump);
    FreePathString (g_HistoryFile);

    g_InAnyDir = FALSE;

    ENABLETRACKCOMMENT();

    if (!MigApp_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
        _tprintf (TEXT("MigApp failed initializing\n"));
        exit(1);
    }

    if (!MemDb_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
        _tprintf (TEXT("MemDb failed initializing\n"));
        exit(1);
    }

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
        _tprintf (TEXT("MigUtil failed initializing\n"));
        exit (1);
    }

}

UINT CALLBACK
pCabinetCallback (
    IN      PVOID Context,          //context used by the callback routine
    IN      UINT Notification,      //notification sent to callback routine
    IN      UINT Param1,            //additional notification information
    IN      UINT Param2             //additional notification information );
    )
{
    PCTSTR tempDir  = Context;
    PCTSTR fileName = (PCTSTR)Param2 ;
    PFILE_IN_CABINET_INFO fileInfo = (PFILE_IN_CABINET_INFO)Param1;
    PCTSTR fromPtr, toPtr;
    TCHAR tempStr [MEMDB_MAX];

    if (Notification == SPFILENOTIFY_FILEINCABINET) {
        if (toPtr = _tcschr (fileInfo->NameInCabinet, TEXT('\\'))) {
            _tcscpy (fileInfo->FullTargetName, tempDir);
            fromPtr = fileInfo->NameInCabinet;
            while (toPtr) {
                StringCopyAB (tempStr, fromPtr, toPtr);
                _tcscat (fileInfo->FullTargetName, TEXT("\\"));
                _tcscat (fileInfo->FullTargetName, tempStr);
                CreateDirectory (fileInfo->FullTargetName, NULL);
                toPtr   = _tcsinc (toPtr);
                fromPtr = toPtr;
                toPtr   = _tcschr (toPtr, TEXT('\\'));
            }
        }
        _stprintf (fileInfo->FullTargetName, TEXT("%s\\%s"), tempDir, fileInfo->NameInCabinet);
        return FILEOP_DOIT;
    }
    return NO_ERROR;
}

BOOL
pWorkerFn (
    VOID
    )
{
    HINF configHandle = INVALID_HANDLE_VALUE;
    INFCONTEXT context;
    TCHAR fileName [MAX_TCHAR_PATH] = "";
    TCHAR sectName [MAX_TCHAR_PATH];
    PTSTR dontCare;

    configHandle = SetupOpenInfFile (g_ConfigFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (configHandle == INVALID_HANDLE_VALUE) {
        SearchPath (NULL, g_ConfigFile, NULL, MAX_TCHAR_PATH, fileName, &dontCare);
        configHandle = SetupOpenInfFile (fileName, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
        if (configHandle == INVALID_HANDLE_VALUE) {
            _tprintf (TEXT("\nCannot open configuration file %s. Exiting.\n"), g_ConfigFile);
            return FALSE;
        }
    }

    g_ContextList = (PMIGDB_CONTEXT) PoolMemGetMemory (g_MigDbPool, sizeof (MIGDB_CONTEXT));
    if (g_ContextList == NULL) {
        DEBUGMSG ((DBG_ERROR, "Unable to create empty context"));
        return FALSE;
    }
    ZeroMemory (g_ContextList, sizeof (MIGDB_CONTEXT));

    if (!pLoadGoodFiles (configHandle)) {
        _tprintf (TEXT("\nUnable to load good files section. Exiting.\n"));
        return FALSE;
    }
    if (!pLoadAttributes (configHandle)) {
        _tprintf (TEXT("\nUnable to load attributes section.\n"));
    }

    if (!pLoadPatterns (configHandle)) {
        _tprintf (TEXT("\nUnable to load patterns section.\n"));
    }
    else {
        _tprintf (TEXT("done\n\n"));
    }

    if (SetupFindFirstLine (configHandle, TEXT("sections"), NULL, &context)) {
        do {
            if (!SetupGetStringField (&context, 1, sectName, MAX_TCHAR_PATH, NULL)) {
                _tprintf (TEXT("\nBad section [SECTIONS] in %s. Exiting.\n"), g_ConfigFile);
                return FALSE;
            }
            if (!pHandleSection (sectName, configHandle)) {
                return FALSE;
            }
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}

BOOL
pLoadGoodFiles (
    IN      HINF ConfigHandle
    )
{
    INFCONTEXT context;

    if (SetupFindFirstLine (ConfigHandle, TEXT("good files"), NULL, &context)) {
        do {
            if (!pScanForFile (&context, 1)) {
                DEBUGMSG ((DBG_WARNING, "Scan for file failed:%d", GetLastError()));
                return FALSE;
            }
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}

BOOL
pLoadAttributes (
    IN      HINF ConfigHandle
    )
{
    TCHAR fileName  [MEMDB_MAX];
    TCHAR attribStr [MEMDB_MAX];
    PCTSTR currAttr;
    DWORD attributes;
    DWORD dontCare;
    INFCONTEXT context;

    if (SetupFindFirstLine (ConfigHandle, TEXT("Attributes"), NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 1, fileName, MAX_TCHAR_PATH, NULL)) {
                if (!SetupGetStringField (&context, 2, attribStr, MAX_TCHAR_PATH, NULL)) {
                    attribStr [0] = 0;
                }
                currAttr = attribStr;
                attributes = 0;
                while (*currAttr) {
                    switch (toupper(*currAttr)) {
                    case 'S':
                        attributes |= ATTR_FILESIZE;
                        break;

                    case 'C':
                        attributes |= ATTR_CHECKSUM;
                        break;

                    case 'N':
                        attributes |= ATTR_COMPNAME;
                        break;

                    case 'F':
                        attributes |= ATTR_FILEDESC;
                        break;

                    case 'V':
                        attributes |= ATTR_FILEVER;
                        break;

                    case 'I':
                        attributes |= ATTR_INTNAME;
                        break;

                    case 'L':
                        attributes |= ATTR_LEGAL;
                        break;

                    case 'O':
                        attributes |= ATTR_ORIGNAME;
                        break;

                    case 'P':
                        attributes |= ATTR_PRODNAME;
                        break;

                    case 'E':
                        attributes |= ATTR_PRODVER;
                        break;

                    case 'T':
                        attributes |= ATTR_EXETYPE;
                        break;

                    case 'D':
                        attributes |= ATTR_DESCR16;
                        break;

                    default:
                        _tprintf (TEXT("\nInvalid attributes:%s\n"), currAttr);
                    }
                    currAttr = _tcsinc (currAttr);
                }
                MemDbSetValueEx (
                    MEMDB_CATEGORY_ATTRIBUTES,
                    fileName,
                    NULL,
                    NULL,
                    attributes,
                    &dontCare
                    );
            }
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}


BOOL
pLoadPatterns (
    IN      HINF ConfigHandle
    )
{
    TCHAR patternFile [MEMDB_MAX];
    TCHAR patternStr  [MEMDB_MAX];
    INFCONTEXT context;
    PPATTERN_FILE fileStruct;

    if (SetupFindFirstLine (ConfigHandle, TEXT("Patterns"), NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 1, patternFile, MAX_TCHAR_PATH, NULL) &&
                SetupGetMultiSzField (&context, 2, patternStr, MAX_TCHAR_PATH, NULL)
                ) {
                fileStruct = (PPATTERN_FILE) PoolMemGetMemory (g_MigDbPool, sizeof (PATTERN_FILE));
                fileStruct->Pattern = PoolMemDuplicateString (g_MigDbPool, patternFile);
                fileStruct->PatternAttr = pLoadAttribData (patternStr);
                fileStruct->Next = g_AttrPatterns;
                g_AttrPatterns = fileStruct;
            }
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}


BOOL
pDeleteAllFiles (
    IN      PCTSTR DirPath
    )
{
    TREE_ENUM e;
    BOOL dirsFirst = FALSE;

    if (EnumFirstFileInTree (&e, DirPath, TEXT("*"), dirsFirst)) {
        do {
            if (e.Directory) {
                pDeleteAllFiles (e.FullPath);
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                RemoveDirectory (e.FullPath);
            }
            else {
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (e.FullPath);
            }
        } while (EnumNextFileInTree (&e));
    }
    return TRUE;
}

BOOL
pSelected (
    IN      PCTSTR FileName
    )
{
    MULTISZ_ENUM patternEnum;

    if (EnumFirstMultiSz (&patternEnum, g_SectFiles.Buf)) {
        do {
            if (IsPatternMatch (patternEnum.CurrentString, FileName)) {
                return TRUE;
            }
        }
        while (EnumNextMultiSz (&patternEnum));
    }
    return FALSE;
}

BOOL
pSpecialSelected (
    IN      PCTSTR FileName,
    OUT     PTSTR NewName
    )
{
    MULTISZ_ENUM patternEnum;
    PTSTR endPtr, endPtr1;
    TCHAR savedVal;

    if (EnumFirstMultiSz (&patternEnum, g_SectFiles.Buf)) {
        do {
            endPtr  = _tcsdec (patternEnum.CurrentString, GetEndOfString (patternEnum.CurrentString));
            savedVal = *endPtr;
            *endPtr = TEXT('_');
            if (IsPatternMatch (patternEnum.CurrentString, FileName)) {
                StringCopy (NewName, FileName);
                endPtr1  = _tcsdec (NewName, GetEndOfString (NewName));
                *endPtr1 = savedVal;

                *endPtr = savedVal;
                return TRUE;
            }
            *endPtr = savedVal;
        }
        while (EnumNextMultiSz (&patternEnum));
    }
    StringCopy (NewName, FileName);
    endPtr  = _tcsdec (NewName, GetEndOfString (NewName));
    *endPtr = TEXT('-');

    return FALSE;
}

DWORD g_DirSequencer = 0;
DWORD g_FileSequencer = 0;

BOOL
pCabinetFile (
    IN      PCTSTR FileName
    )
{
    PCTSTR extPtr;

    extPtr = GetFileExtensionFromPath (FileName);
    if ((extPtr != NULL) &&
        StringIMatch (extPtr, TEXT("CAB"))
        ) {
        return TRUE;
    }
    return FALSE;
}

#define ATTR_FILESIZE       0x1
#define ATTR_CHECKSUM       0x2
#define ATTR_COMPNAME       0x4
#define ATTR_FILEDESC       0x8
#define ATTR_FILEVER       0x10
#define ATTR_INTNAME       0x20
#define ATTR_LEGAL         0x40
#define ATTR_ORIGNAME      0x80
#define ATTR_PRODNAME     0x100
#define ATTR_PRODVER      0x200
#define ATTR_EXETYPE      0x400
#define ATTR_DESCR16      0x800

typedef struct _VERSION_DATA {
    PCSTR   versionValue;
    PCSTR   versionName;
    DWORD   attrib;
} VERSION_DATA, *PVERSION_DATA;

VERSION_DATA verData [] =  {{NULL, "COMPANYNAME", ATTR_COMPNAME},
                            {NULL, "FILEDESCRIPTION", ATTR_FILEDESC},
                            {NULL, "FILEVERSION", ATTR_FILEVER},
                            {NULL, "INTERNALNAME", ATTR_INTNAME},
                            {NULL, "LEGALCOPYRIGHT", ATTR_LEGAL},
                            {NULL, "ORIGINALFILENAME", ATTR_ORIGNAME},
                            {NULL, "PRODUCTNAME", ATTR_PRODNAME},
                            {NULL, "PRODUCTVERSION", ATTR_PRODVER},
                            {NULL, NULL, 0}};

extern PSTR g_ExeTypes[4];


BOOL
pCheckForPattern (
    IN      PCTSTR FileName,
    PFILE_HELPER_PARAMS Params,
    OUT     PTSTR FileAttr,
    IN OUT  PGROWBUFFER AttrList
    )
{
    PPATTERN_FILE patternFile;
    PMIGDB_ATTRIB migDbAttrib;
    DBATTRIB_PARAMS attribParams;
    BOOL fileSelected;
    BOOL found;
    TCHAR temp [MEMDB_MAX];
    MULTISZ_ENUMA multiSzEnum;
    BOOL first;

    patternFile = g_AttrPatterns;

    found = FALSE;
    while (patternFile) {
        if (IsPatternMatch (patternFile->Pattern, FileName)) {
            fileSelected = TRUE;
            migDbAttrib = patternFile->PatternAttr;
            while (migDbAttrib) {
                attribParams.FileParams = Params;
                attribParams.ExtraData = NULL;
                if (!CallAttribute (migDbAttrib, &attribParams)) {
                    fileSelected = FALSE;
                    break;
                }
                migDbAttrib = migDbAttrib->Next;
            }
            if (fileSelected) {
                found = TRUE;
                break;
            }
        }
        patternFile = patternFile->Next;
    }
    if (found) {
        migDbAttrib = patternFile->PatternAttr;
        while (migDbAttrib) {
            _tcscpy (temp, MigDb_GetAttributeName (migDbAttrib->AttribIndex));
            first = TRUE;
            if (EnumFirstMultiSz (&multiSzEnum, migDbAttrib->Arguments)) {
                _tcscat (temp, TEXT("("));
                do {
                    if (!first) {
                        _tcscat (FileAttr, TEXT(","));
                        _tcscat (FileAttr, temp);
                        if (AttrList) {
                            MultiSzAppend (AttrList, temp);
                        }
                        *temp = 0;
                    }
                    first = FALSE;
                    _tcscat (temp, TEXT("\""));
                    _tcscat (temp, multiSzEnum.CurrentString);
                    _tcscat (temp, TEXT("\""));
                }
                while (EnumNextMultiSz (&multiSzEnum));
                _tcscat (temp, TEXT(")"));
            }
            _tcscat (FileAttr, TEXT(","));
            _tcscat (FileAttr, temp);
            if (AttrList) {
                MultiSzAppend (AttrList, temp);
            }
            migDbAttrib = migDbAttrib->Next;
        }
        return TRUE;
    }
    return FALSE;
}


PSTR
MyQueryVersionEntry (
    IN      PCSTR FileName,
    IN      PCSTR VersionEntry
    )
{
    VERSION_STRUCTW Version;
    PCWSTR CurrentStr;
    PSTR ConvCurrentStr = NULL;
    PSTR result = NULL;
    PCWSTR ConvFileName = NULL;
    PCWSTR ConvVerEntry = NULL;

    MYASSERT (VersionEntry);

    ConvFileName = ConvertAtoW (FileName);
    ConvVerEntry = ConvertAtoW (VersionEntry);

    if (CreateVersionStructW (&Version, ConvFileName)) {
        __try {
            CurrentStr = EnumFirstVersionValueW (&Version, ConvVerEntry);
            if (CurrentStr) {
                CurrentStr = SkipSpaceW (CurrentStr);
                ConvCurrentStr = UnicodeToCcs (CurrentStr);
                TruncateTrailingSpace ((PSTR) ConvCurrentStr);
                result = ConvCurrentStr;
            }
            else {
                __leave;
            }
        }
        __finally {
            DestroyVersionStructW (&Version);
        }
    }
    if (ConvVerEntry) {
        FreeConvertedStr (ConvVerEntry);
    }
    if (ConvFileName) {
        FreeConvertedStr (ConvFileName);
    }
    return result;
}


BOOL
pPrintLine (
    IN      PTREE_ENUM e,
    OUT     PTSTR FileAttr,
    IN OUT  PGROWBUFFER AttrList
    )
{
    FILE_HELPER_PARAMS Params;
    UINT checkSum;
    DWORD exeType;
    PCSTR fileDesc16;
    INT numAttribs;
    DWORD listedAttr;
    TCHAR ekey [MEMDB_MAX];
    TCHAR temp [MEMDB_MAX];

    PVERSION_DATA p;

    Params.Handled = 0;
    Params.FullFileSpec = e->FullPath;
    _tcsncpy (Params.DirSpec, e->RootPath, MAX_TCHAR_PATH);
    Params.IsDirectory = FALSE;
    Params.Extension = GetFileExtensionFromPath (e->Name);
    Params.FindData = e->FindData;
    Params.VirtualFile = FALSE;
    Params.CurrentDirData = NULL;

    FileAttr [0] = 0;

    if (!StringIMatch (e->Name, TEXT("kernel32.dll"))) {
        if (pCheckForPattern (e->Name, &Params, FileAttr, AttrList)) {
            return TRUE;
        }
    }

    numAttribs = 0;

    MemDbBuildKey (ekey, MEMDB_CATEGORY_ATTRIBUTES, e->Name, NULL, NULL);
    if (!MemDbGetPatternValue (ekey, &listedAttr)) {
        listedAttr = ATTR_COMPNAME | ATTR_PRODVER;
    }

    if (listedAttr & ATTR_FILESIZE) {
        _stprintf (
            temp,
            TEXT(",FILESIZE(0x%08lX)"),
            e->FindData->nFileSizeLow);
        _tcscat (FileAttr, temp);
        if (AttrList) {
            _stprintf (
                temp,
                TEXT("FILESIZE(0x%08lX)"),
                e->FindData->nFileSizeLow);
            MultiSzAppend (AttrList, temp);
        }
        numAttribs ++;
    }
    if (listedAttr & ATTR_CHECKSUM) {
        checkSum = ComputeCheckSum (&Params);
        _stprintf (
            temp,
            TEXT(",CHECKSUM(0x%08lX)"),
            checkSum);
        _tcscat (FileAttr, temp);
        if (AttrList) {
            _stprintf (
                temp,
                TEXT("CHECKSUM(0x%08lX)"),
                checkSum);
            MultiSzAppend (AttrList, temp);
        }
        numAttribs ++;
    }
    if (listedAttr & ATTR_EXETYPE) {
        exeType = GetModuleType (e->FullPath);
        _stprintf (
            temp,
            TEXT(",EXETYPE(\"%s\")"),
            g_ExeTypes[exeType]);
        _tcscat (FileAttr, temp);
        if (AttrList) {
            _stprintf (
                temp,
                TEXT("EXETYPE(%s)"),
                g_ExeTypes[exeType]);
            MultiSzAppend (AttrList, temp);
        }
        numAttribs ++;
    }
    if (listedAttr & ATTR_DESCR16) {
        fileDesc16 = Get16ModuleDescription (e->FullPath);
        if (fileDesc16 != NULL) {
            _stprintf (
                temp,
                TEXT(",DESCRIPTION(\"%s\")"),
                fileDesc16);
            _tcscat (FileAttr, temp);
            if (AttrList) {
                _stprintf (
                    temp,
                    TEXT("DESCRIPTION(%s)"),
                    fileDesc16);
                MultiSzAppend (AttrList, temp);
            }
            numAttribs ++;
            FreePathString (fileDesc16);
        }
    }
    p = verData;
    while (p->versionName) {
        if (listedAttr & p->attrib) {
            p->versionValue = MyQueryVersionEntry (e->FullPath, p->versionName);
        }
        p++;
    }
    p = verData;
    while (p->versionName) {
        if ((listedAttr & p->attrib) && (p->versionValue)) {
            _stprintf (
                temp,
                TEXT(",%s(\"%s\")"),
                p->versionName,
                p->versionValue);
            _tcscat (FileAttr, temp);
            if (AttrList) {
                _stprintf (
                    temp,
                    TEXT("%s(%s)"),
                    p->versionName,
                    p->versionValue);
                MultiSzAppend (AttrList, temp);
            }
            FreePathString (p->versionValue);
            numAttribs ++;
        }
        p++;
    }
    if (numAttribs == 0) {
        checkSum = ComputeCheckSum (&Params);
        _stprintf (
            temp,
            TEXT(",FC(%ld,%lX)"),
            e->FindData->nFileSizeLow,
            checkSum
            );
        _tcscat (FileAttr, temp);
        if (AttrList) {
            _stprintf (
                temp,
                TEXT("FC(%ld"),
                e->FindData->nFileSizeLow
                );
            MultiSzAppend (AttrList, temp);
            _stprintf (
                temp,
                TEXT("%lX)"),
                checkSum
                );
            MultiSzAppend (AttrList, temp);
        }
    }
    return TRUE;
}


BOOL
pHandleAppFile (
    IN      PTREE_ENUM e,
    IN      PCTSTR Action,
    IN      PCTSTR Section,
    IN      PCTSTR Message,
    IN      PCTSTR SrcPath
    )
{
    TCHAR msgStr  [MEMDB_MAX] = "";
    FILE_HELPER_PARAMS Params;

    TCHAR line [MEMDB_MAX];
    TCHAR key [MEMDB_MAX] = "";
    DWORD offset;

    Params.Handled = 0;
    Params.FullFileSpec = e->FullPath;
    _tcsncpy (Params.DirSpec, SrcPath, MAX_TCHAR_PATH);
    Params.IsDirectory = FALSE;
    Params.Extension = GetFileExtensionFromPath (e->Name);
    Params.FindData = e->FindData;
    Params.VirtualFile = FALSE;
    Params.CurrentDirData = NULL;

    pPrintLine (e, line, NULL);

    MemDbBuildKey (key, MEMDB_CATEGORY_RENAME_SRC, e->Name, NULL, NULL);
    if (MemDbGetValue (key, &offset)) {
        if (!MemDbBuildKeyFromOffset (offset, key, 1, NULL)) {
            *key = 0;
        }
    } else {
        *key = 0;
    }

    _stprintf (
        msgStr,
        TEXT("%s\\%s%s)"),
        MEMDB_CATEGORY_SECTFILES,
        *key?key:e->Name,
        line);
    MemDbSetValue (msgStr, 0);
    return TRUE;
}


BOOL
pHandleSysFile (
    IN      PTREE_ENUM e,
    IN      PCTSTR Action,
    IN      PCTSTR Section,
    IN      PCTSTR Message,
    IN      PCTSTR SrcPath
    )
{
    TCHAR msgStr  [MEMDB_MAX] = "";
    FILE_HELPER_PARAMS Params;
    HASHITEM stringId;
    PMIGDB_FILE   migDbFile;
    FILE_LIST_STRUCT fileList;
    PMIGDB_ATTRIB migDbAttrib;
    DBATTRIB_PARAMS attribParams;
    BOOL fileSelected = FALSE;
    PCTSTR actionTmp;
    TCHAR line [MEMDB_MAX];
    TCHAR key [MEMDB_MAX] = "";
    DWORD offset;

    GROWBUFFER attrList = GROWBUF_INIT;

    // this is not a cabinet file, let's do something with it.
    Params.Handled = 0;
    Params.FullFileSpec = e->FullPath;
    _tcsncpy (Params.DirSpec, SrcPath, MAX_TCHAR_PATH);
    Params.IsDirectory = FALSE;
    Params.Extension = GetFileExtensionFromPath (e->Name);
    Params.FindData = e->FindData;
    Params.VirtualFile = FALSE;
    Params.CurrentDirData = NULL;

    pPrintLine (e, line, &attrList);

    if (StringIMatch (e->Name, TEXT("kernel32.dll"))) {
        _stprintf (
            msgStr,
            TEXT("%s\\%s%s"),
            MEMDB_CATEGORY_REQFILES,
            e->Name,
            line);
        MemDbSetValue (msgStr, fileSelected);
    };

    // first check if this file is in "known good" list or is already listed in migdb.inx
    // with same action
    stringId = HtFindString (g_FileTable, e->Name);
    if (stringId) {

        //The string table has extra data (a pointer to a FILE_LIST_STRUCT node)
        HtCopyStringData (g_FileTable, stringId, &fileList);
        migDbFile = fileList.First;

        while (migDbFile) {
            //check all attributes for this file
            migDbAttrib = migDbFile->Attributes;
            fileSelected = TRUE;
            while (migDbAttrib != NULL) {
                attribParams.FileParams = &Params;
                attribParams.ExtraData = NULL;
                if (!CallAttribute (migDbAttrib, &attribParams)) {
                    fileSelected = FALSE;
                    break;
                }
                migDbAttrib = migDbAttrib->Next;
            }
            if ((!fileSelected) &&
                (migDbFile->Section == NULL)
                ) {
                // there was a name collision with a "known good" file. We will send a message
                _stprintf (msgStr, TEXT("%s\\%s"), MEMDB_CATEGORY_WARNFILES, e->Name);
                MemDbSetValue (msgStr, 0);
            }
            if ((fileSelected) &&
                (migDbFile->Section == NULL)
                ) {
                // this file is "known good". We will send a message
                _stprintf (msgStr, TEXT("%s\\%s"), MEMDB_CATEGORY_GOODFILES, e->Name);
                MemDbSetValue (msgStr, 0);
                break;
            }
            if ((fileSelected) && (!StringIMatch (Section, migDbFile->Section->Context->SectName))){
                actionTmp = MigDb_GetActionName (migDbFile->Section->Context->ActionIndex);
                if ((actionTmp != NULL) && StringIMatch (actionTmp, Action)) {
                    // this file was already listed in migdb.inx with the same action
                    _stprintf (
                        msgStr,
                        TEXT("%s\\%s\\%-14s%s"),
                        MEMDB_CATEGORY_DUPLFILES,
                        Action,
                        e->Name,
                        line);
                    MemDbSetValue (msgStr, 0);
                    break;
                }
            }
            fileSelected = FALSE;
            migDbFile = migDbFile->Next;
        }
    }
    if (!fileSelected) {

        // one more check. If this file is in FILELIST.DAT (but not in the EXCEPTED section)
        // and COMPANYNAME attribute has Microsoft somewhere inside we'll put it in a different
        // place
        MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES, e->Name, NULL, NULL);
        if (MemDbGetValue (key, NULL)) {
            MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES_EXCEPT, e->Name, NULL, NULL);
            if (!MemDbGetValue (key, NULL)) {
                if (GlobalVersionCheck (e->FullPath, "COMPANYNAME", "*MICROSOFT*")) {
                    fileSelected = TRUE;
                }
            }
        }

        // this file is not in the list or attributes do not match
        // we will add in incompatibility list.

        //creating MIGDB_FILE structure for current file
        migDbFile = (PMIGDB_FILE) PoolMemGetMemory (g_MigDbPool, sizeof (MIGDB_FILE));
        if (migDbFile != NULL) {
            ZeroMemory (migDbFile, sizeof (MIGDB_FILE));
            migDbFile->Section = g_ContextList->Sections;
            migDbFile->Attributes = pLoadAttribData (attrList.Buf);
            if (g_MigDbHook != NULL) {
                migDbAttrib = migDbFile->Attributes;
                while (migDbAttrib) {
                    g_MigDbHook (e->Name, g_ContextList, g_ContextList->Sections, migDbFile, migDbAttrib);
                    migDbAttrib = migDbAttrib->Next;
                }
            }

            //adding this file into string table and create a MIGDB_FILE node. If file
            //already exists in string table then just create another MIGDB_FILE node
            //chained with already existing ones.
            stringId = HtFindString (g_FileTable, e->Name);
            if (stringId) {

                HtCopyStringData (g_FileTable, stringId, &fileList);

                fileList.Last->Next = migDbFile;
                fileList.Last = migDbFile;

                HtSetStringData (g_FileTable, stringId, &fileList);
            }
            else {
                fileList.First = fileList.Last = migDbFile;
                HtAddStringAndData (g_FileTable, e->Name, &fileList);
            }
        }
        else {
            DEBUGMSG ((DBG_ERROR, "Unable to allocate file node for %s", e->Name));
        }

        MemDbBuildKey (key, MEMDB_CATEGORY_RENAME_SRC, e->Name, NULL, NULL);
        if (MemDbGetValue (key, &offset)) {
            if (!MemDbBuildKeyFromOffset (offset, key, 1, NULL)) {
                *key = 0;
            }
        } else {
            *key = 0;
        }

        _stprintf (
            msgStr,
            TEXT("%s\\%s%s"),
            MEMDB_CATEGORY_SECTFILES,
            *key?key:e->Name,
            line);
        MemDbSetValue (msgStr, fileSelected);
    }
    FreeGrowBuffer (&attrList);
    return TRUE;
}

BOOL
pCompressedFile (
    IN      PTREE_ENUM e
    )
{
    PCTSTR extPtr;

    extPtr = GetFileExtensionFromPath (e->FullPath);
    if (extPtr == NULL) {
        return FALSE;
    }
    if (_tcslen (extPtr) != 3) {
        return FALSE;
    }
    return (extPtr [2] == TEXT('_'));
}

BOOL
pExeFile (
    IN      PTREE_ENUM e
    )
{
    PCTSTR extPtr;

    extPtr = GetFileExtensionFromPath (e->FullPath);
    if ((extPtr != NULL) &&
        (StringIMatch (extPtr, TEXT("EXE")))
        ) {
        return TRUE;
    }
    return FALSE;
}

BOOL
pCopyAndHandleCabResource (
    IN      PVOID Source,
    IN      DWORD Size,
    IN      PCTSTR DirName
    )
{
    TCHAR cabDir   [MAX_TCHAR_PATH] = "";
    HANDLE hFile;
    DWORD dontCare;

    if (Size < 4) {
        return TRUE;
    }
    if (*((PDWORD)Source) != 0x4643534D) {
        return TRUE;
    }

    g_FileSequencer ++;
    _stprintf (cabDir, TEXT("%s\\MIGDB%03u.CAB"), DirName, g_FileSequencer);

    hFile = CreateFile (cabDir, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_ERROR, "Cannot create file %s", cabDir));
        return FALSE;
    }
    if (!WriteFile (hFile, Source, Size, &dontCare, NULL)) {
        DEBUGMSG ((DBG_ERROR, "Cannot write to file %s", cabDir));
        return FALSE;
    }
    CloseHandle (hFile);

    return TRUE;
}

BOOL CALLBACK
EnumResNameProc (
    IN      HANDLE hModule,   // module handle
    IN      LPCTSTR lpszType, // pointer to resource type
    IN      LPTSTR lpszName,  // pointer to resource name
    IN      LONG lParam       // application-defined parameter
    )
{
    HRSRC hResource;
    DWORD size;
    HGLOBAL hGlobal;
    PVOID srcBytes;

    hResource = FindResource (hModule, lpszName, lpszType);
    if (hResource) {
        size = SizeofResource (hModule, hResource);
        if (size) {
            hGlobal = LoadResource (hModule, hResource);
            if (hGlobal) {
                srcBytes = LockResource (hGlobal);
                if (srcBytes) {
                    pCopyAndHandleCabResource (srcBytes, size, (PCTSTR)lParam);
                }
            }
        }
    }
    return TRUE;
}


BOOL CALLBACK
EnumResTypeProc (
    IN      HANDLE hModule,  // resource-module handle
    IN      LPTSTR lpszType, // pointer to resource type
    IN      LONG lParam      // application-defined parameter
    )
{
    if ((lpszType != RT_ACCELERATOR  ) &&
        (lpszType != RT_ANICURSOR    ) &&
        (lpszType != RT_ANIICON      ) &&
        (lpszType != RT_BITMAP       ) &&
        (lpszType != RT_CURSOR       ) &&
        (lpszType != RT_DIALOG       ) &&
        (lpszType != RT_FONT         ) &&
        (lpszType != RT_FONTDIR      ) &&
        (lpszType != RT_GROUP_CURSOR ) &&
        (lpszType != RT_GROUP_ICON   ) &&
        (lpszType != RT_HTML         ) &&
        (lpszType != RT_ICON         ) &&
        (lpszType != RT_MENU         ) &&
        (lpszType != RT_MESSAGETABLE ) &&
        (lpszType != RT_PLUGPLAY     ) &&
        (lpszType != RT_STRING       ) &&
        (lpszType != RT_VERSION      ) &&
        (lpszType != RT_VXD          ) &&
        (lpszType != RT_HTML         )
        ) {
        // we found an unknown type. Let's enumerate all resources of this type
        if (EnumResourceNames (hModule, lpszType, EnumResNameProc, lParam) == 0) {
            DEBUGMSG ((DBG_ERROR, "Error enumerating names:%ld", GetLastError ()));
        }
    }
    return TRUE;
}

BOOL
pHandleAllFiles (
    IN      BOOL AppMode,
    IN      PCTSTR Action,
    IN      PCTSTR Section,
    IN      PCTSTR Message,
    IN      PCTSTR SrcPath
    )
{
    TCHAR tempDir [MAX_TCHAR_PATH] = "";
    TCHAR cmdLine [MAX_TCHAR_PATH] = "";
    TCHAR newName [MAX_TCHAR_PATH] = "";
    TREE_ENUM e;
    DWORD error;
    HMODULE exeModule;

    PROCESS_INFORMATION processInfo;
    STARTUPINFO startupInfo;

    if (EnumFirstFileInTree (&e, SrcPath, TEXT("*"), FALSE)) {
        do {
            if (!e.Directory) {
                if (pCabinetFile (e.Name)) {
                    if ((AppMode) ||
                        (!pSelected (e.Name))
                        ) {
                        // cabinet file
                        g_DirSequencer++;
                        _stprintf (tempDir, TEXT("%s\\MIGDB%03u"), g_TempDir, g_DirSequencer);
                        if (CreateDirectory (tempDir, NULL) == 0) {
                            error = GetLastError ();
                            if (error == ERROR_ALREADY_EXISTS) {
                                pDeleteAllFiles (tempDir);
                            }
                            ELSE_DEBUGMSG ((DBG_ERROR, "Cannot create directory %s", tempDir));
                        }

                        _tprintf (TEXT("    Extracting cabinet file ... %s"), e.Name);

                        // we need to expand the cabinet file
                        SetLastError (0);
                        if (!SetupIterateCabinet (e.FullPath, 0, pCabinetCallback, tempDir)) {
                            _tprintf (TEXT("...error %ld\n"), GetLastError());
                            DEBUGMSG((DBG_ERROR, "Could not iterate cabinet file:%s\nError:%ld", e.FullPath, GetLastError ()));
                        }
                        else {
                            _tprintf (TEXT("...done\n"));
                        }

                        if (!pHandleAllFiles (AppMode, Action, Section, Message, tempDir)) {
                            return FALSE;
                        }

                        pDeleteAllFiles (tempDir);
                        RemoveDirectory (tempDir);
                        g_DirSequencer--;
                    }
                }
                else if (pCompressedFile (&e)) {
                    if (AppMode) {
                        if (!pSpecialSelected (e.Name, newName)) {
                            continue;
                        }
                    }
                    else {
                        if (pSpecialSelected (e.Name, newName)) {
                            continue;
                        }
                    }
                    // compressed file
                    g_DirSequencer++;
                    _stprintf (tempDir, TEXT("%s\\MIGDB%03u"), g_TempDir, g_DirSequencer);
                    if (CreateDirectory (tempDir, NULL) == 0) {
                        error = GetLastError ();
                        if (error == ERROR_ALREADY_EXISTS) {
                            pDeleteAllFiles (tempDir);
                        }
                        ELSE_DEBUGMSG ((DBG_ERROR, "Cannot create directory %s", tempDir));
                    }

                    _stprintf (cmdLine, TEXT("expand /r %s %s"), e.FullPath, tempDir);
                    ZeroMemory (&startupInfo, sizeof (STARTUPINFO));
                    startupInfo.cb = sizeof (STARTUPINFO);
                    if (CreateProcess (NULL, cmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo)) {
                        WaitForSingleObject (processInfo.hProcess, INFINITE);
                        CloseHandle (processInfo.hProcess);
                        CloseHandle (processInfo.hThread);
                        if (!pHandleAllFiles (AppMode, Action, Section, Message, tempDir)) {
                            return FALSE;
                        }
                        pDeleteAllFiles (tempDir);
                    }
                    else {
                        DEBUGMSG ((DBG_ERROR, "Could not decompress:%s, Error:%ld", e.Name, GetLastError()));
                    }

                    RemoveDirectory (tempDir);
                    g_DirSequencer--;
                }
                else {
                    if (pExeFile (&e)) {

                        g_FileSequencer = 0;
                        g_DirSequencer++;
                        _stprintf (tempDir, TEXT("%s\\MIGDB%03u"), g_TempDir, g_DirSequencer);
                        if (CreateDirectory (tempDir, NULL) == 0) {
                            error = GetLastError ();
                            if (error == ERROR_ALREADY_EXISTS) {
                                pDeleteAllFiles (tempDir);
                            }
                            ELSE_DEBUGMSG ((DBG_ERROR, "Cannot create directory %s", tempDir));
                        }

                        exeModule = LoadLibraryEx (e.FullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
                        EnumResourceTypes (exeModule, EnumResTypeProc, (LONG)tempDir);
                        FreeLibrary (exeModule);

                        if (!pHandleAllFiles (AppMode, Action, Section, Message, tempDir)) {
                            return FALSE;
                        }

                        pDeleteAllFiles (tempDir);
                        RemoveDirectory (tempDir);
                        g_DirSequencer--;
                    }

                    if (AppMode) {
                        if (pSelected (e.Name)) {
                            if (!pHandleAppFile (&e, Action, Section, Message, SrcPath)) {
                                return FALSE;
                            }
                        }
                    }
                    else {
                        if (!pSelected (e.Name)) {
                            if (!pHandleSysFile (&e, Action, Section, Message, SrcPath)) {
                                return FALSE;
                            }
                        }
                    }
                }
            }
        } while (EnumNextFileInTree (&e));
    }
    return TRUE;
}

BOOL
pHandleSection (
    IN      PCTSTR SectionName,
    IN      HINF ConfigHandle
    )
{
    PMIGDB_CONTEXT migDbContext = NULL;
    INFCONTEXT context;
    TCHAR action  [MAX_TCHAR_PATH] = "";
    TCHAR section [MAX_TCHAR_PATH] = "";
    TCHAR message [MAX_TCHAR_PATH] = "";
    TCHAR srcPath [MAX_TCHAR_PATH] = "";
    TCHAR msgStr  [MAX_TCHAR_PATH] = "";
    TCHAR sectTmp [MAX_TCHAR_PATH] = "";
    TCHAR renSect [MAX_TCHAR_PATH] = "";
    TCHAR srcFile [MAX_TCHAR_PATH] = "";
    TCHAR destFile[MAX_TCHAR_PATH] = "";
    BOOL forced = FALSE;
    INT field;
    TCHAR excludePattern [MAX_TCHAR_PATH] = "";
    BOOL appMode = FALSE;
    TCHAR sectPatterns [MAX_TCHAR_PATH] = "";
    DWORD offset;

    _tprintf (TEXT("Processing section : %s ... "), SectionName);

    if (!SetupFindFirstLine (ConfigHandle, SectionName, TEXT("action"), &context)) {
        _tprintf (TEXT("\nCannot find Action= line in %s.\n"), SectionName);
        return FALSE;
    }
    if (!SetupGetStringField (&context, 1, action, MAX_TCHAR_PATH, NULL)) {
        _tprintf (TEXT("\nCannot read action name in %s.\n"), SectionName);
        return FALSE;
    }

    if (!SetupFindFirstLine (ConfigHandle, SectionName, TEXT("section"), &context)) {
        _tprintf (TEXT("\nCannot find Section= line in %s.\n"), SectionName);
        return FALSE;
    }
    if (!SetupGetStringField (&context, 1, section, MAX_TCHAR_PATH, NULL)) {
        _tprintf (TEXT("\nCannot read section name in %s.\n"), SectionName);
        return FALSE;
    }

    if (!SetupFindFirstLine (ConfigHandle, SectionName, TEXT("sourcepath"), &context)) {
        _tprintf (TEXT("\nCannot find SourcePath= line in %s.\n"), SectionName);
        return FALSE;
    }
    if (!SetupGetStringField (&context, 1, srcPath, MAX_TCHAR_PATH, NULL)) {
        _tprintf (TEXT("\nCannot read source path name in %s.\n"), SectionName);
        return FALSE;
    }
    if (SetupFindFirstLine (ConfigHandle, SectionName, TEXT("message"), &context)) {
        SetupGetStringField (&context, 1, message, MAX_TCHAR_PATH, NULL);
    }

    if (SetupFindFirstLine (ConfigHandle, SectionName, TEXT("RenameSection"), &context)) {
        SetupGetStringField (&context, 1, renSect, MAX_TCHAR_PATH, NULL);
    }

    g_SectFiles.Buf       = NULL;
    g_SectFiles.Size      = 0;
    g_SectFiles.End       = 0;
    g_SectFiles.GrowSize  = 0;
    g_SectFiles.UserIndex = 0;

    if (SetupFindFirstLine (ConfigHandle, SectionName, TEXT("ExcludeFiles"), &context)) {
        field = 1;
        while (SetupGetStringField (&context, field, excludePattern, MAX_TCHAR_PATH, NULL)) {
            MultiSzAppend (&g_SectFiles, excludePattern);
            field ++;
        }
        appMode = FALSE;
    }

    if (SetupFindFirstLine (ConfigHandle, SectionName, TEXT("SpecifiedFiles"), &context)) {
        field = 1;
        while (SetupGetStringField (&context, field, excludePattern, MAX_TCHAR_PATH, NULL)) {
            MultiSzAppend (&g_SectFiles, excludePattern);
            field ++;
        }
        appMode = TRUE;
    }

    // let's try to find if this section was already processed in migdb.inx
    if (SetupFindFirstLine (g_MigDbInf, action, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 1, sectTmp, MAX_TCHAR_PATH, NULL) &&
                (StringIMatch (section, sectTmp))
                ) {
                if ((!g_RescanFlag) ||
                    ((g_RescanSect != NULL) && (!StringIMatch (g_RescanSect, section)))
                    ) {
                    _tprintf (TEXT("skipped\n"));
                    return TRUE;
                }
                WritePrivateProfileString (section, NULL, NULL, g_MigdbDest);
                WritePrivateProfileString (NULL, NULL, NULL, g_MigdbDest);
                _tprintf (TEXT("forced ..."));
                forced = TRUE;
            }
        }
        while (SetupFindNextLine (&context, &context));
    }

    if (SetupFindFirstLine (ConfigHandle, renSect, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 0, srcFile, MAX_TCHAR_PATH, NULL) &&
                SetupGetStringField (&context, 1, destFile, MAX_TCHAR_PATH, NULL)
                ) {
                MemDbSetValueEx (MEMDB_CATEGORY_RENAME_DEST, destFile, NULL, NULL, 0, &offset);
                MemDbSetValueEx (MEMDB_CATEGORY_RENAME_SRC, srcFile, NULL, NULL, offset, NULL);
            }
        } while (SetupFindNextLine (&context, &context));
    }

    _tprintf (TEXT("\n"));

    migDbContext = (PMIGDB_CONTEXT) PoolMemGetMemory (g_MigDbPool, sizeof (MIGDB_CONTEXT));
    if (migDbContext == NULL) {
        DEBUGMSG ((DBG_ERROR, "Unable to create context for %s", action));
        return FALSE;
    }

    ZeroMemory (migDbContext, sizeof (MIGDB_CONTEXT));
    migDbContext->Next = g_ContextList;
    g_ContextList = migDbContext;

    // update ActionIndex with known value
    migDbContext->ActionIndex = MigDb_GetActionIdx (action);
    DEBUGMSG_IF(((migDbContext->ActionIndex == -1), DBG_ERROR, "Unable to identify action index for %s", action));

    // update SectName field
    migDbContext->SectName = PoolMemDuplicateString (g_MigDbPool, section);

    if (!pHandleAllFiles (appMode, action, section, message, srcPath)) {
        return FALSE;
    }

    FreeGrowBuffer (&g_SectFiles);

    if (!forced) {
        // now let's add the action section and the line within it
        _stprintf (msgStr, TEXT("%s\\%s,%s"),
            MEMDB_CATEGORY_ACTION,
            section,
            message);
        MemDbSetValue (msgStr, 0);

        pWriteMemdbSection (g_MigdbDest, MEMDB_CATEGORY_ACTION, action, FALSE);
    }

    pWriteMemdbSection (g_MigdbDest, MEMDB_CATEGORY_SECTFILES, section, TRUE);

    pWriteMemdbSection (g_MigdbDest, MEMDB_CATEGORY_REQFILES, TEXT("Windows 9x Required Files"), TRUE);

    MemDbDeleteTree (MEMDB_CATEGORY_SECTFILES);
    MemDbDeleteTree (MEMDB_CATEGORY_ACTION);
    MemDbDeleteTree (MEMDB_CATEGORY_RENAME_SRC);
    MemDbDeleteTree (MEMDB_CATEGORY_RENAME_DEST);
    MemDbDeleteTree (MEMDB_CATEGORY_REQFILES);

    return TRUE;
}

BOOL
pWriteMemdbSection (
    IN      PCTSTR FileName,
    IN      PCTSTR MemDbCategory,
    IN      PCTSTR SectName,
    IN      BOOL WriteByValue
    )
{
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    TCHAR line [MAX_TCHAR_PATH] = "";
    DWORD dontCare;
    MEMDB_ENUM e;
    PCTSTR pattern;

    fileHandle = CreateFile (FileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        _tprintf (TEXT("\nCannot open %s.\n"), FileName);
        return FALSE;
    }

    SetFilePointer (fileHandle, 0, 0, FILE_END);

    _stprintf (line, TEXT("[%s]\r\n"), SectName);
    WriteFile (fileHandle, line, GetEndOfString (line) - line, &dontCare, NULL);

    pattern = JoinPaths (MemDbCategory, TEXT("\\*"));
    if (MemDbEnumFirstValue (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if (!WriteByValue || !e.dwValue) {
                _stprintf (line, TEXT("%s\r\n"), e.szName);
                if (!WriteFile (fileHandle, line, GetEndOfString (line) - line, &dontCare, NULL)) {
                    DEBUGMSG ((DBG_ERROR, "Error while writing information."));
                }
            }
        }
        while (MemDbEnumNextValue (&e));
    }

    _stprintf (line, TEXT("\r\n\r\n"), SectName);
    WriteFile (fileHandle, line, GetEndOfString (line) - line, &dontCare, NULL);

    if (!CloseHandle (fileHandle)) {
        DEBUGMSG ((DBG_ERROR, "Error while closing file %s.", FileName));
    }

    if (WriteByValue) {

        fileHandle = CreateFile (g_MigdbDump, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);
        if (fileHandle == INVALID_HANDLE_VALUE) {
            _tprintf (TEXT("\nCannot open %s.\n"), g_MigdbDump);
            return FALSE;
        }

        SetFilePointer (fileHandle, 0, 0, FILE_END);

        _stprintf (line, TEXT("[\n%s.obsolete]\r\n"), SectName);
        WriteFile (fileHandle, line, GetEndOfString (line) - line, &dontCare, NULL);

        if (MemDbEnumFirstValue (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            do {
                if (e.dwValue) {
                    _stprintf (line, TEXT("%s\r\n"), e.szName);
                    if (!WriteFile (fileHandle, line, GetEndOfString (line) - line, &dontCare, NULL)) {
                        DEBUGMSG ((DBG_ERROR, "Error while writing information."));
                    }
                }
            }
            while (MemDbEnumNextValue (&e));
        }
        if (!CloseHandle (fileHandle)) {
            DEBUGMSG ((DBG_ERROR, "Error while closing file %s.", FileName));
        }

    }

    FreePathString (pattern);

    return TRUE;
}

BOOL
pArrangeMigDbFile (
    IN      PCTSTR SrcFile,
    IN      PCTSTR DestFile
    )
{
    return CopyFile (SrcFile, DestFile, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\pnpids\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\migupd\makefile.inc ===
obj\$(TARGET_DIRECTORY)\MigUpd.res: MigUpd.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\migid\migid.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migid.c

Abstract:

    Implements a small program that loads a migration DLL and prints
    its vendor info.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command Line Syntax:\n\n"
            "migid [directory]\n\n"
            "directory - Specifies the directory migrate.dll is in.\n"
            "            If not specified, the current directory is\n"
            "            used.\n"
            );

    exit (1);
}


INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    HANDLE Library;
    TCHAR Path[MAX_TCHAR_PATH];
    DWORD d;
    P_QUERY_VERSION QueryVersion;
    PCSTR ProductID = NULL;
    UINT DllVersion = 0;
    PINT CodePageArray;
    PCSTR ExeNamesBuf;
    PVENDORINFO VendorInfo = NULL;
    BOOL SpecCompliant = TRUE;

    if (argc == 0 || argc > 2) {
        HelpAndExit();
    }

    if (argc == 2) {
        d = GetFileAttributes (argv[1]);
        if (d == INVALID_ATTRIBUTES) {
            HelpAndExit();
        }

        if (!(d & FILE_ATTRIBUTE_DIRECTORY)) {
            HelpAndExit();
        }

        lstrcpy (Path, argv[1]);
        lstrcat (Path, TEXT("\\"));
    } else {
        lstrcpy (Path, TEXT(".\\"));
    }

    lstrcat (Path, TEXT("migrate.dll"));

    Library = LoadLibrary (Path);
    if (!Library) {
        fprintf (stderr, "Can't open %s\n", Path);
        return 1;
    }

    (FARPROC) QueryVersion = GetProcAddress (Library, "QueryVersion");
    if (!QueryVersion) {
        fprintf (stderr, "%s is not spec-compliant\n", Path);
        return 1;
    }


    __try {
        QueryVersion (&ProductID, &DllVersion, &CodePageArray, &ExeNamesBuf, &VendorInfo);

        if (!ProductID || !VendorInfo) {
            SpecCompliant = FALSE;
        }

        printf ("Product ID:        %s\n"
                "DLL Version:       %u\n"
                "Company Name:      %s\n"
                "Support Number:    %s\n"
                "Support URL:       %s\n"
                "Failure Help:      %s\n",
                ProductID ? ProductID : "(nul)",
                DllVersion,
                VendorInfo ? VendorInfo->CompanyName : "(nul)",
                VendorInfo ? VendorInfo->SupportNumber : "(nul)",
                VendorInfo ? VendorInfo->SupportUrl : "(nul)",
                VendorInfo ? VendorInfo->InstructionsToUser : "(nul)"
                );

    }

    __except (TRUE) {
        SpecCompliant = FALSE;
    }

    if (!SpecCompliant) {
        fprintf (stderr, "%s is not spec-compliant\n", Path);
        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\pnprept\pch.h ===
#include "master.h"
#include "masterhw.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\rasdump\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\migupd\migupd.c ===
#include "pch.h"

#include <advpub.h>

#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <tchar.h>
#include <locale.h>

#include <winnt32p.h>
#include <init9x.h>
#include <migdb.h>
#include <sysmig.h>
#include "..\..\w95upg\migapp\migdbp.h"

typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);

INITROUTINE_PROTOTYPE MigUtil_Entry;
INITROUTINE_PROTOTYPE MemDb_Entry;
INITROUTINE_PROTOTYPE MigApp_Entry;
INITROUTINE_PROTOTYPE FileEnum_Entry;

HINSTANCE g_hInst;
HANDLE g_hHeap;

BOOL g_CancelFlag = FALSE;

#define ATTR_FILESIZE       0x1
#define ATTR_CHECKSUM       0x2
#define ATTR_COMPNAME       0x4
#define ATTR_FILEDESC       0x8
#define ATTR_FILEVER       0x10
#define ATTR_INTNAME       0x20
#define ATTR_LEGAL         0x40
#define ATTR_ORIGNAME      0x80
#define ATTR_PRODNAME     0x100
#define ATTR_PRODVER      0x200
#define ATTR_EXETYPE      0x400
#define ATTR_DESCR16      0x800

#ifdef DEBUG
extern BOOL            g_DoLog;
#endif
extern POOLHANDLE      g_MigDbPool;
extern PMIGDB_CONTEXT  g_ContextList;
extern VOID           *g_FileTable;
extern BOOL           *g_CancelFlagPtr = &g_CancelFlag;
extern POOLHANDLE      g_PathsPool;

extern PMIGDB_HOOK_PROTOTYPE g_MigDbHook;

typedef struct _PATTERN_FILE {
    PCTSTR Pattern;
    PMIGDB_ATTRIB PatternAttr;
    struct _PATTERN_FILE *Next;
} PATTERN_FILE, *PPATTERN_FILE;

PPATTERN_FILE g_AttrPatterns = NULL;

BOOL
pReadNtFilesEx (
    IN      PCSTR FileListName
    );

BOOL
pScanForFile (
    IN      PINFCONTEXT Context,
    IN      DWORD FieldIndex
    );


PMIGDB_ATTRIB
pLoadAttribData (
    IN      PCSTR MultiSzStr
    );


BOOL
CallAttribute (
    IN      PMIGDB_ATTRIB MigDbAttrib,
    IN      PDBATTRIB_PARAMS AttribParams
    );

BOOL
pWorkerFn (
    VOID
    );

BOOL
pLoadGoodFiles (
    IN      HINF ConfigHandle
    );

BOOL
pLoadAttributes (
    IN      HINF ConfigHandle
    );

BOOL
pLoadPatterns (
    IN      HINF ConfigHandle
    );

BOOL
pHandleSection (
    IN      PCTSTR SectionName,
    IN      HINF ConfigHandle
    );

BOOL
pWriteMemdbSection (
    IN      PCTSTR FileName,
    IN      PCTSTR MemDbCategory,
    IN      PCTSTR SectName,
    IN      BOOL WriteByValue
    );

BOOL
pArrangeMigDbFile (
    IN      PCTSTR SrcFile,
    IN      PCTSTR DestFile
    );

VOID
pUsage (
    VOID
    )
{
    _tprintf (TEXT ("\nCommand line syntax:\n\n"
                    "MigUpd [/B:BaseDir] [/O:OutputFile] [/T:TempDir]\n\n"
                    "  /B    Specifies the directory where source files are located (defaults to current dir)\n"
                    "  /O    Specifies the name of the output file (defaults to .\\MIGDB.ADD)\n"
                    "  /T    Specifies the temporary directory used for unpacking\n"
                    "        cabinet files (defaults to temp dir)\n"
                    ));
}

PTSTR g_TempDir    = NULL;
PTSTR g_BaseDir    = NULL;
PTSTR g_ConfigFile = NULL;
PTSTR g_MessageFile= NULL;
PTSTR g_MigdbSrc   = NULL;
PTSTR g_MigdbDest  = NULL;
PTSTR g_MigdbDump  = NULL;
PTSTR g_InfTemplate = NULL;
PTSTR g_FileListName = NULL;
extern HINF  g_MigDbInf;
GROWBUFFER g_SectFiles = GROWBUF_INIT;

#define MEMDB_CATEGORY_SECTFILES       TEXT("SectFiles")
#define MEMDB_CATEGORY_GOODFILES       TEXT("GoodFiles")
#define MEMDB_CATEGORY_WARNFILES       TEXT("WarnFiles")
#define MEMDB_CATEGORY_DUPLFILES       TEXT("DuplFiles")
#define MEMDB_CATEGORY_ACTION          TEXT("Action")
#define MEMDB_CATEGORY_ATTRIBUTES      TEXT("Attributes")
#define MEMDB_CATEGORY_RENAME_SRC      TEXT("RenameSrc")
#define MEMDB_CATEGORY_RENAME_DEST     TEXT("RenameDest")
#define MEMDB_CATEGORY_REQFILES        TEXT("RequiredFiles")

INT
__cdecl
main (
    int argc,
    CHAR *argv[]
    )
{

    INT argidx, index;
    INT nextArg = 0;
    LONG rc;
    BOOL b = FALSE;
    BOOL b2 = FALSE;
    BOOL b3 = FALSE;
    TCHAR dirUpgInfs[MAX_PATH];
    TCHAR dirUpgInfs2[MAX_PATH];
    DWORD attrib;
    PTSTR p;
    TCHAR buf[12];
    DWORD seq;
    INT retcode = 1;

#ifdef DEBUG
    g_DoLog = TRUE;
#endif

    g_hInst = GetModuleHandle (NULL);
    g_hHeap = GetProcessHeap();

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        _tprintf (TEXT("MigUtil failed initializing\n"));
        exit (1);
    }

    if (!MemDb_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        _tprintf (TEXT("MemDb failed initializing\n"));
        exit(1);
    }

    if (!MigApp_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        _tprintf (TEXT("MigApp failed initializing\n"));
        exit (1);
    }

    for (argidx = 1; argidx < argc; argidx++) {
        if ((argv[argidx][0] != '-') &&
            (argv[argidx][0] != '/')
            ) {
            if (nextArg == 0) {
                pUsage ();
                exit (1);
            }
            switch (nextArg) {
            case 1:
                index = 0;
                goto label1;
            case 2:
                index = 0;
                goto label2;
            case 3:
                index = 0;
                goto label3;
            }
        }
        switch (toupper(argv[argidx][1])) {
        case 'B':
            if (argv[argidx][2] == 0) {
                nextArg = 1;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label1:
                nextArg = 0;
                g_BaseDir = argv[argidx]+index;
            }
            break;

        case 'O':
            if (argv[argidx][2] == 0) {
                nextArg = 2;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label2:
                nextArg = 0;
                g_MigdbDest = argv[argidx]+index;
            }
            break;

        case 'T':
            if (argv[argidx][2] == 0) {
                nextArg = 3;
            }
            else {
                if (argv[argidx][2] != ':') {
                    index = 2;
                }
                else {
                    index = 3;
                }
label3:
                nextArg = 0;
                g_TempDir = argv[argidx]+index;
            }
            break;

        default:
            pUsage ();
            exit (1);
        }
    }
    if (g_TempDir == NULL) {
        g_TempDir = AllocPathString (MAX_TCHAR_PATH);
        if (GetEnvironmentVariable (TEXT("TEMP"), g_TempDir, MAX_TCHAR_PATH) == 0) {
            GetTempPath (MAX_TCHAR_PATH, g_TempDir);
        }
        b = TRUE;
    }
    if (!g_BaseDir) {
        g_BaseDir = TEXT(".");
    }

    if (!g_MigdbDest) {
        g_MigdbDest = JoinPaths (g_BaseDir, TEXT("migdb.add"));
        b2 = TRUE;
    }
    g_ConfigFile = JoinPaths (g_BaseDir, TEXT("migdb.cfg"));
    g_MessageFile = JoinPaths (g_BaseDir, TEXT("migdb.msg"));
    g_MigdbSrc = JoinPaths (g_BaseDir, TEXT("migdb.inf"));
    g_MigdbDump = JoinPaths (g_BaseDir, TEXT("migdb.dmp"));
    g_InfTemplate = JoinPaths (g_BaseDir, TEXT("header.inf"));
    g_FileListName = JoinPaths (g_BaseDir, TEXT("filelist.dat"));

    try {
        if (!DoesFileExist (g_FileListName)) {
            _tprintf (TEXT("\nNT file list file not found (%s). Exiting.\n"), g_FileListName);
            __leave;
        }

        if (!DoesFileExist (g_MigdbSrc)) {
            _tprintf (TEXT("\nSource file not found (%s). Exiting.\n"), g_MigdbSrc);
            __leave;
        }

        if (!DoesFileExist (g_ConfigFile)) {
            _tprintf (TEXT("\nConfiguration file not found (%s). Exiting.\n"), g_ConfigFile);
            __leave;
        }

        if (SearchPath (NULL, TEXT("expand.exe"), NULL, 0, NULL, NULL) == 0) {
            _tprintf (TEXT("\nCannot find expand.exe in path. Assuming there are no compressed files.\n"));
        }

        if (!CopyFile (g_InfTemplate, g_MigdbDest, FALSE)) {
            printf ("Could not copy %s to %s. Error Code: %x\n", g_InfTemplate, g_MigdbDest, GetLastError ());
            __leave;
        }

        DeleteFile (g_MessageFile);
        DeleteFile (g_MigdbDump);

        DISABLETRACKCOMMENT();

        g_InAnyDir = TRUE;

        if (!GetWindowsDirectory (dirUpgInfs, MAX_PATH)) {
            __leave;
        }
        StringCat (dirUpgInfs, TEXT("\\UpgInfs"));

        StringCopy (dirUpgInfs2, dirUpgInfs);
        seq = 2;
        p = GetEndOfString (dirUpgInfs2);
        do {
            wsprintf (p, TEXT("%u"), seq++);
        } while (GetFileAttributes (dirUpgInfs2) != -1);

        attrib = GetFileAttributes (dirUpgInfs);
        if (attrib != -1 && (attrib & FILE_ATTRIBUTE_DIRECTORY) != 0) {
            b3 = MoveFile (dirUpgInfs, dirUpgInfs2);
        }

        _tprintf (TEXT("\nReading NT file list: %s"), g_FileListName);

        if (!pReadNtFilesEx (g_FileListName)) {
            rc = GetLastError();

            printf ("Could not read %s.  Win32 Error Code: %x\n", g_FileListName, rc);
            __leave;
        }

        _tprintf (TEXT("\nReading configuration files..."));

        if (!InitMigDbEx (g_MigdbSrc)) {
            rc = GetLastError();

            printf ("Could not read %s.  Win32 Error Code: %x\n", g_MigdbSrc, rc);
            __leave;
        }

        if (!pWorkerFn ()) {
            __leave;
        }

        retcode = 0;
    }
    __finally {

        if (g_MigDbInf != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (g_MigDbInf);
        }

        pWriteMemdbSection (g_MessageFile, MEMDB_CATEGORY_GOODFILES, TEXT("KNOWN GOOD - FILES FOUND"), FALSE);
        pWriteMemdbSection (g_MessageFile, MEMDB_CATEGORY_WARNFILES, TEXT("KNOWN GOOD - NAME COLLISIONS"), FALSE);
        pWriteMemdbSection (g_MessageFile, MEMDB_CATEGORY_DUPLFILES, TEXT("DUPLICATE FILES"), FALSE);

        if (g_FileTable != NULL) {
            HtFree (g_FileTable);
        }
        if (g_MigDbPool != NULL) {
            PoolMemDestroyPool (g_MigDbPool);
        }

        FreePathString (g_ConfigFile);
        FreePathString (g_MessageFile);
        FreePathString (g_MigdbSrc);
        FreePathString (g_MigdbDump);
        FreePathString (g_InfTemplate);
        FreePathString (g_FileListName);
        if (b2) {
            FreePathString (g_MigdbDest);
        }
        if (b) {
            FreePathString (g_TempDir);
        }

        if (b3) {
            MoveFile (dirUpgInfs2, dirUpgInfs);
        }

        g_InAnyDir = FALSE;

        ENABLETRACKCOMMENT();

        MigApp_Entry (g_hInst, DLL_PROCESS_DETACH, NULL);
        MemDb_Entry (g_hInst, DLL_PROCESS_DETACH, NULL);
        MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL);
    }

    return retcode;
}

UINT CALLBACK
pCabinetCallback (
    IN      PVOID Context,          //context used by the callback routine
    IN      UINT Notification,      //notification sent to callback routine
    IN      UINT Param1,            //additional notification information
    IN      UINT Param2             //additional notification information );
    )
{
    PCTSTR tempDir  = Context;
    PCTSTR fileName = (PCTSTR)Param2 ;
    PFILE_IN_CABINET_INFO fileInfo = (PFILE_IN_CABINET_INFO)Param1;
    PCTSTR fromPtr, toPtr;
    TCHAR tempStr [MEMDB_MAX];

    if (Notification == SPFILENOTIFY_FILEINCABINET) {
        if (toPtr = _tcschr (fileInfo->NameInCabinet, TEXT('\\'))) {
            _tcscpy (fileInfo->FullTargetName, tempDir);
            fromPtr = fileInfo->NameInCabinet;
            while (toPtr) {
                StringCopyAB (tempStr, fromPtr, toPtr);
                _tcscat (fileInfo->FullTargetName, TEXT("\\"));
                _tcscat (fileInfo->FullTargetName, tempStr);
                CreateDirectory (fileInfo->FullTargetName, NULL);
                toPtr   = _tcsinc (toPtr);
                fromPtr = toPtr;
                toPtr   = _tcschr (toPtr, TEXT('\\'));
            }
        }
        _stprintf (fileInfo->FullTargetName, TEXT("%s\\%s"), tempDir, fileInfo->NameInCabinet);
        return FILEOP_DOIT;
    }
    return NO_ERROR;
}

BOOL
pWorkerFn (
    VOID
    )
{
    HINF configHandle = INVALID_HANDLE_VALUE;
    INFCONTEXT context;
    TCHAR fileName [MAX_TCHAR_PATH] = "";
    TCHAR sectName [MAX_TCHAR_PATH];
    PTSTR dontCare;

    configHandle = SetupOpenInfFile (g_ConfigFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (configHandle == INVALID_HANDLE_VALUE) {
        SearchPath (NULL, g_ConfigFile, NULL, MAX_TCHAR_PATH, fileName, &dontCare);
        configHandle = SetupOpenInfFile (fileName, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
        if (configHandle == INVALID_HANDLE_VALUE) {
            _tprintf (TEXT("\nCannot open configuration file %s. Exiting.\n"), g_ConfigFile);
            return FALSE;
        }
    }

    g_ContextList = (PMIGDB_CONTEXT) PoolMemGetMemory (g_MigDbPool, sizeof (MIGDB_CONTEXT));
    if (g_ContextList == NULL) {
        DEBUGMSG ((DBG_ERROR, "Unable to create empty context"));
        return FALSE;
    }
    ZeroMemory (g_ContextList, sizeof (MIGDB_CONTEXT));

    if (!pLoadGoodFiles (configHandle)) {
        _tprintf (TEXT("\nUnable to load good files section. Exiting.\n"));
        return FALSE;
    }
    if (!pLoadAttributes (configHandle)) {
        _tprintf (TEXT("\nUnable to load attributes section.\n"));
    }

    if (!pLoadPatterns (configHandle)) {
        _tprintf (TEXT("\nUnable to load patterns section.\n"));
    }
    else {
        _tprintf (TEXT("done\n\n"));
    }

    if (SetupFindFirstLine (configHandle, TEXT("sections"), NULL, &context)) {
        do {
            if (!SetupGetStringField (&context, 1, sectName, MAX_TCHAR_PATH, NULL)) {
                _tprintf (TEXT("\nBad section [SECTIONS] in %s. Exiting.\n"), g_ConfigFile);
                return FALSE;
            }
            if (!pHandleSection (sectName, configHandle)) {
                return FALSE;
            }
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}

BOOL
pLoadGoodFiles (
    IN      HINF ConfigHandle
    )
{
    INFCONTEXT context;

    if (SetupFindFirstLine (ConfigHandle, TEXT("good files"), NULL, &context)) {
        do {
            if (!pScanForFile (&context, 1)) {
                DEBUGMSG ((DBG_WARNING, "Scan for file failed:%d", GetLastError()));
                return FALSE;
            }
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}

BOOL
pLoadAttributes (
    IN      HINF ConfigHandle
    )
{
    TCHAR fileName  [MEMDB_MAX];
    TCHAR attribStr [MEMDB_MAX];
    PCTSTR currAttr;
    DWORD attributes;
    DWORD dontCare;
    INFCONTEXT context;

    if (SetupFindFirstLine (ConfigHandle, TEXT("Attributes"), NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 1, fileName, MAX_TCHAR_PATH, NULL)) {
                if (!SetupGetStringField (&context, 2, attribStr, MAX_TCHAR_PATH, NULL)) {
                    attribStr [0] = 0;
                }
                currAttr = attribStr;
                attributes = 0;
                while (*currAttr) {
                    switch (toupper(*currAttr)) {
                    case 'S':
                        attributes |= ATTR_FILESIZE;
                        break;

                    case 'C':
                        attributes |= ATTR_CHECKSUM;
                        break;

                    case 'N':
                        attributes |= ATTR_COMPNAME;
                        break;

                    case 'F':
                        attributes |= ATTR_FILEDESC;
                        break;

                    case 'V':
                        attributes |= ATTR_FILEVER;
                        break;

                    case 'I':
                        attributes |= ATTR_INTNAME;
                        break;

                    case 'L':
                        attributes |= ATTR_LEGAL;
                        break;

                    case 'O':
                        attributes |= ATTR_ORIGNAME;
                        break;

                    case 'P':
                        attributes |= ATTR_PRODNAME;
                        break;

                    case 'E':
                        attributes |= ATTR_PRODVER;
                        break;

                    case 'T':
                        attributes |= ATTR_EXETYPE;
                        break;

                    case 'D':
                        attributes |= ATTR_DESCR16;
                        break;

                    default:
                        _tprintf (TEXT("\nInvalid attributes:%s\n"), currAttr);
                    }
                    currAttr = _tcsinc (currAttr);
                }
                MemDbSetValueEx (
                    MEMDB_CATEGORY_ATTRIBUTES,
                    fileName,
                    NULL,
                    NULL,
                    attributes,
                    &dontCare
                    );
            }
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}


BOOL
pLoadPatterns (
    IN      HINF ConfigHandle
    )
{
    TCHAR patternFile [MEMDB_MAX];
    TCHAR patternStr  [MEMDB_MAX];
    INFCONTEXT context;
    PPATTERN_FILE fileStruct;

    if (SetupFindFirstLine (ConfigHandle, TEXT("Patterns"), NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 1, patternFile, MAX_TCHAR_PATH, NULL) &&
                SetupGetMultiSzField (&context, 2, patternStr, MAX_TCHAR_PATH, NULL)
                ) {
                fileStruct = (PPATTERN_FILE) PoolMemGetMemory (g_MigDbPool, sizeof (PATTERN_FILE));
                fileStruct->Pattern = PoolMemDuplicateString (g_MigDbPool, patternFile);
                fileStruct->PatternAttr = pLoadAttribData (patternStr);
                fileStruct->Next = g_AttrPatterns;
                g_AttrPatterns = fileStruct;
            }
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}


BOOL
pDeleteAllFiles (
    IN      PCTSTR DirPath
    )
{
    TREE_ENUM e;
    BOOL dirsFirst = FALSE;

    if (EnumFirstFileInTree (&e, DirPath, TEXT("*"), dirsFirst)) {
        do {
            if (e.Directory) {
                pDeleteAllFiles (e.FullPath);
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                RemoveDirectory (e.FullPath);
            }
            else {
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (e.FullPath);
            }
        } while (EnumNextFileInTree (&e));
    }
    return TRUE;
}

BOOL
pSelected (
    IN      PCTSTR FileName
    )
{
    MULTISZ_ENUM patternEnum;

    if (EnumFirstMultiSz (&patternEnum, g_SectFiles.Buf)) {
        do {
            if (IsPatternMatch (patternEnum.CurrentString, FileName)) {
                return TRUE;
            }
        }
        while (EnumNextMultiSz (&patternEnum));
    }
    return FALSE;
}

BOOL
pSpecialSelected (
    IN      PCTSTR FileName,
    OUT     PTSTR NewName
    )
{
    MULTISZ_ENUM patternEnum;
    PTSTR endPtr, endPtr1;
    TCHAR savedVal;

    if (EnumFirstMultiSz (&patternEnum, g_SectFiles.Buf)) {
        do {
            endPtr  = _tcsdec (patternEnum.CurrentString, GetEndOfString (patternEnum.CurrentString));
            savedVal = *endPtr;
            *endPtr = TEXT('_');
            if (IsPatternMatch (patternEnum.CurrentString, FileName)) {
                StringCopy (NewName, FileName);
                endPtr1  = _tcsdec (NewName, GetEndOfString (NewName));
                *endPtr1 = savedVal;

                *endPtr = savedVal;
                return TRUE;
            }
            *endPtr = savedVal;
        }
        while (EnumNextMultiSz (&patternEnum));
    }
    StringCopy (NewName, FileName);
    endPtr  = _tcsdec (NewName, GetEndOfString (NewName));
    *endPtr = TEXT('-');

    return FALSE;
}

DWORD g_DirSequencer = 0;
DWORD g_FileSequencer = 0;

BOOL
pCabinetFile (
    IN      PCTSTR FileName
    )
{
    PCTSTR extPtr;

    extPtr = GetFileExtensionFromPath (FileName);
    if ((extPtr != NULL) &&
        StringIMatch (extPtr, TEXT("CAB"))
        ) {
        return TRUE;
    }
    return FALSE;
}

#define ATTR_FILESIZE       0x1
#define ATTR_CHECKSUM       0x2
#define ATTR_COMPNAME       0x4
#define ATTR_FILEDESC       0x8
#define ATTR_FILEVER       0x10
#define ATTR_INTNAME       0x20
#define ATTR_LEGAL         0x40
#define ATTR_ORIGNAME      0x80
#define ATTR_PRODNAME     0x100
#define ATTR_PRODVER      0x200
#define ATTR_EXETYPE      0x400
#define ATTR_DESCR16      0x800

typedef struct _VERSION_DATA {
    PCSTR   versionValue;
    PCSTR   versionName;
    DWORD   attrib;
} VERSION_DATA, *PVERSION_DATA;

VERSION_DATA verData [] =  {{NULL, "COMPANYNAME", ATTR_COMPNAME},
                            {NULL, "FILEDESCRIPTION", ATTR_FILEDESC},
                            {NULL, "FILEVERSION", ATTR_FILEVER},
                            {NULL, "INTERNALNAME", ATTR_INTNAME},
                            {NULL, "LEGALCOPYRIGHT", ATTR_LEGAL},
                            {NULL, "ORIGINALFILENAME", ATTR_ORIGNAME},
                            {NULL, "PRODUCTNAME", ATTR_PRODNAME},
                            {NULL, "PRODUCTVERSION", ATTR_PRODVER},
                            {NULL, NULL, 0}};

extern PSTR g_ExeTypes[4];


BOOL
pCheckForPattern (
    IN      PCTSTR FileName,
    PFILE_HELPER_PARAMS Params,
    OUT     PTSTR FileAttr,
    IN OUT  PGROWBUFFER AttrList
    )
{
    PPATTERN_FILE patternFile;
    PMIGDB_ATTRIB migDbAttrib;
    DBATTRIB_PARAMS attribParams;
    BOOL fileSelected;
    BOOL found;
    TCHAR temp [MEMDB_MAX];
    MULTISZ_ENUMA multiSzEnum;
    BOOL first;

    patternFile = g_AttrPatterns;

    found = FALSE;
    while (patternFile) {
        if (IsPatternMatch (patternFile->Pattern, FileName)) {
            fileSelected = TRUE;
            migDbAttrib = patternFile->PatternAttr;
            while (migDbAttrib) {
                attribParams.FileParams = Params;
                attribParams.ExtraData = NULL;
                if (!CallAttribute (migDbAttrib, &attribParams)) {
                    fileSelected = FALSE;
                    break;
                }
                migDbAttrib = migDbAttrib->Next;
            }
            if (fileSelected) {
                found = TRUE;
                break;
            }
        }
        patternFile = patternFile->Next;
    }
    if (found) {
        migDbAttrib = patternFile->PatternAttr;
        while (migDbAttrib) {
            _tcscpy (temp, MigDb_GetAttributeName (migDbAttrib->AttribIndex));
            first = TRUE;
            if (EnumFirstMultiSz (&multiSzEnum, migDbAttrib->Arguments)) {
                _tcscat (temp, TEXT("("));
                do {
                    if (!first) {
                        _tcscat (FileAttr, TEXT(","));
                        _tcscat (FileAttr, temp);
                        if (AttrList) {
                            MultiSzAppend (AttrList, temp);
                        }
                        *temp = 0;
                    }
                    first = FALSE;
                    _tcscat (temp, TEXT("\""));
                    _tcscat (temp, multiSzEnum.CurrentString);
                    _tcscat (temp, TEXT("\""));
                }
                while (EnumNextMultiSz (&multiSzEnum));
                _tcscat (temp, TEXT(")"));
            }
            _tcscat (FileAttr, TEXT(","));
            _tcscat (FileAttr, temp);
            if (AttrList) {
                MultiSzAppend (AttrList, temp);
            }
            migDbAttrib = migDbAttrib->Next;
        }
        return TRUE;
    }
    return FALSE;
}


BOOL
pPrintLine (
    IN      PTREE_ENUM e,
    OUT     PTSTR FileAttr,
    IN OUT  PGROWBUFFER AttrList
    )
{
    FILE_HELPER_PARAMS Params;
    UINT checkSum;
    DWORD exeType;
    PCSTR fileDesc16;
    INT numAttribs;
    DWORD listedAttr;
    TCHAR ekey [MEMDB_MAX];
    TCHAR temp [MEMDB_MAX];

    PVERSION_DATA p;

    Params.Handled = 0;
    Params.FullFileSpec = e->FullPath;
    _tcsncpy (Params.DirSpec, e->RootPath, MAX_TCHAR_PATH);
    Params.IsDirectory = FALSE;
    Params.Extension = GetFileExtensionFromPath (e->Name);
    Params.FindData = e->FindData;
    Params.VirtualFile = FALSE;

    FileAttr [0] = 0;

    if (!StringIMatch (e->Name, TEXT("kernel32.dll"))) {
        if (pCheckForPattern (e->Name, &Params, FileAttr, AttrList)) {
            return TRUE;
        }
    }

    numAttribs = 0;

    MemDbBuildKey (ekey, MEMDB_CATEGORY_ATTRIBUTES, e->Name, NULL, NULL);
    if (!MemDbGetPatternValue (ekey, &listedAttr)) {
        listedAttr = ATTR_COMPNAME | ATTR_PRODVER;
    }

    if (listedAttr & ATTR_FILESIZE) {
        _stprintf (
            temp,
            TEXT(",FILESIZE(0x%08lX)"),
            e->FindData->nFileSizeLow);
        _tcscat (FileAttr, temp);
        if (AttrList) {
            _stprintf (
                temp,
                TEXT("FILESIZE(0x%08lX)"),
                e->FindData->nFileSizeLow);
            MultiSzAppend (AttrList, temp);
        }
        numAttribs ++;
    }
    if (listedAttr & ATTR_CHECKSUM) {
        checkSum = ComputeCheckSum (&Params);
        _stprintf (
            temp,
            TEXT(",CHECKSUM(0x%08lX)"),
            checkSum);
        _tcscat (FileAttr, temp);
        if (AttrList) {
            _stprintf (
                temp,
                TEXT("CHECKSUM(0x%08lX)"),
                checkSum);
            MultiSzAppend (AttrList, temp);
        }
        numAttribs ++;
    }
    if (listedAttr & ATTR_EXETYPE) {
        exeType = GetModuleType (e->FullPath);
        _stprintf (
            temp,
            TEXT(",EXETYPE(\"%s\")"),
            g_ExeTypes[exeType]);
        _tcscat (FileAttr, temp);
        if (AttrList) {
            _stprintf (
                temp,
                TEXT("EXETYPE(%s)"),
                g_ExeTypes[exeType]);
            MultiSzAppend (AttrList, temp);
        }
        numAttribs ++;
    }
    if (listedAttr & ATTR_DESCR16) {
        fileDesc16 = Get16ModuleDescription (e->FullPath);
        if (fileDesc16 != NULL) {
            _stprintf (
                temp,
                TEXT(",DESCRIPTION(\"%s\")"),
                fileDesc16);
            _tcscat (FileAttr, temp);
            if (AttrList) {
                _stprintf (
                    temp,
                    TEXT("DESCRIPTION(%s)"),
                    fileDesc16);
                MultiSzAppend (AttrList, temp);
            }
            numAttribs ++;
            FreePathString (fileDesc16);
        }
    }
    p = verData;
    while (p->versionName) {
        if (listedAttr & p->attrib) {
            p->versionValue = QueryVersionEntry (e->FullPath, p->versionName);
        }
        p++;
    }
    p = verData;
    while (p->versionName) {
        if ((listedAttr & p->attrib) && (p->versionValue)) {
            _stprintf (
                temp,
                TEXT(",%s(\"%s\")"),
                p->versionName,
                p->versionValue);
            _tcscat (FileAttr, temp);
            if (AttrList) {
                _stprintf (
                    temp,
                    TEXT("%s(%s)"),
                    p->versionName,
                    p->versionValue);
                MultiSzAppend (AttrList, temp);
            }
            FreePathString (p->versionValue);
            numAttribs ++;
        }
        p++;
    }
    if (numAttribs == 0) {
        checkSum = ComputeCheckSum (&Params);
        _stprintf (
            temp,
            TEXT(",FC(%ld,%lX)"),
            e->FindData->nFileSizeLow,
            checkSum
            );
        _tcscat (FileAttr, temp);
        if (AttrList) {
            _stprintf (
                temp,
                TEXT("FC(%ld"),
                e->FindData->nFileSizeLow
                );
            MultiSzAppend (AttrList, temp);
            _stprintf (
                temp,
                TEXT("%lX)"),
                checkSum
                );
            MultiSzAppend (AttrList, temp);
        }
    }
    return TRUE;
}


BOOL
pHandleAppFile (
    IN      PTREE_ENUM e,
    IN      PCTSTR Action,
    IN      PCTSTR Section,
    IN      PCTSTR Message,
    IN      PCTSTR SrcPath
    )
{
    TCHAR msgStr  [MEMDB_MAX] = "";
    FILE_HELPER_PARAMS Params;

    TCHAR line [MEMDB_MAX];
    TCHAR key [MEMDB_MAX] = "";
    DWORD offset;

    Params.Handled = 0;
    Params.FullFileSpec = e->FullPath;
    _tcsncpy (Params.DirSpec, SrcPath, MAX_TCHAR_PATH);
    Params.IsDirectory = FALSE;
    Params.Extension = GetFileExtensionFromPath (e->Name);
    Params.FindData = e->FindData;
    Params.VirtualFile = FALSE;

    pPrintLine (e, line, NULL);

    MemDbBuildKey (key, MEMDB_CATEGORY_RENAME_SRC, e->Name, NULL, NULL);
    if (MemDbGetValue (key, &offset)) {
        if (!MemDbBuildKeyFromOffset (offset, key, 1, NULL)) {
            *key = 0;
        }
    } else {
        *key = 0;
    }

    _stprintf (
        msgStr,
        TEXT("%s\\%s%s)"),
        MEMDB_CATEGORY_SECTFILES,
        *key?key:e->Name,
        line);
    MemDbSetValue (msgStr, 0);
    return TRUE;
}


BOOL
pHandleSysFile (
    IN      PTREE_ENUM e,
    IN      PCTSTR Action,
    IN      PCTSTR Section,
    IN      PCTSTR Message,
    IN      PCTSTR SrcPath
    )
{
    TCHAR msgStr  [MEMDB_MAX] = "";
    FILE_HELPER_PARAMS Params;
    HASHITEM stringId;
    PMIGDB_FILE   migDbFile;
    FILE_LIST_STRUCT fileList;
    PMIGDB_ATTRIB migDbAttrib;
    DBATTRIB_PARAMS attribParams;
    BOOL fileSelected = FALSE;
    PCTSTR actionTmp;
    TCHAR line [MEMDB_MAX];
    TCHAR key [MEMDB_MAX] = "";
    DWORD offset;

    GROWBUFFER attrList = GROWBUF_INIT;

    // this is not a cabinet file, let's do something with it.
    Params.Handled = 0;
    Params.FullFileSpec = e->FullPath;
    _tcsncpy (Params.DirSpec, SrcPath, MAX_TCHAR_PATH);
    Params.IsDirectory = FALSE;
    Params.Extension = GetFileExtensionFromPath (e->Name);
    Params.FindData = e->FindData;
    Params.VirtualFile = FALSE;

    pPrintLine (e, line, &attrList);

    if (StringIMatch (e->Name, TEXT("kernel32.dll"))) {
        _stprintf (
            msgStr,
            TEXT("%s\\%s%s"),
            MEMDB_CATEGORY_REQFILES,
            e->Name,
            line);
        MemDbSetValue (msgStr, fileSelected);
    };

    // first check if this file is in "known good" list or is already listed in migdb.inf
    // with same action
    stringId = HtFindString (g_FileTable, e->Name);
    if (stringId) {

        //The string table has extra data (a pointer to a FILE_LIST_STRUCT node)
        HtCopyStringData (g_FileTable, stringId, &fileList);
        migDbFile = fileList.First;

        while (migDbFile) {
            //check all attributes for this file
            migDbAttrib = migDbFile->Attributes;
            fileSelected = TRUE;
            while (migDbAttrib != NULL) {
                attribParams.FileParams = &Params;
                attribParams.ExtraData = NULL;
                if (!CallAttribute (migDbAttrib, &attribParams)) {
                    fileSelected = FALSE;
                    break;
                }
                migDbAttrib = migDbAttrib->Next;
            }
            if ((!fileSelected) &&
                (migDbFile->Section == NULL)
                ) {
                // there was a name collision with a "known good" file. We will send a message
                _stprintf (msgStr, TEXT("%s\\%s"), MEMDB_CATEGORY_WARNFILES, e->Name);
                MemDbSetValue (msgStr, 0);
            }
            if ((fileSelected) &&
                (migDbFile->Section == NULL)
                ) {
                // this file is "known good". We will send a message
                _stprintf (msgStr, TEXT("%s\\%s"), MEMDB_CATEGORY_GOODFILES, e->Name);
                MemDbSetValue (msgStr, 0);
                break;
            }
            if ((fileSelected) && (!StringIMatch (Section, migDbFile->Section->Context->SectName))){
                actionTmp = MigDb_GetActionName (migDbFile->Section->Context->ActionIndex);
                if ((actionTmp != NULL) && StringIMatch (actionTmp, Action)) {
                    // this file was already listed in migdb.inf with the same action
                    _stprintf (
                        msgStr,
                        TEXT("%s\\%s\\%-14s%s"),
                        MEMDB_CATEGORY_DUPLFILES,
                        Action,
                        e->Name,
                        line);
                    MemDbSetValue (msgStr, 0);
                    break;
                }
            }
            fileSelected = FALSE;
            migDbFile = migDbFile->Next;
        }
    }
    if (!fileSelected) {

        // one more check. If this file is in FILELIST.DAT (but not in the EXCEPTED section)
        // and COMPANYNAME attribute has Microsoft somewhere inside we'll put it in a different
        // place
        MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES, e->Name, NULL, NULL);
        if (MemDbGetValue (key, NULL)) {
            MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES_EXCEPT, e->Name, NULL, NULL);
            if (!MemDbGetValue (key, NULL)) {
                if (GlobalVersionCheck (e->FullPath, "COMPANYNAME", "*MICROSOFT*")) {
                    fileSelected = TRUE;
                }
            }
        }

        // this file is not in the list or attributes do not match
        // we will add in incompatibility list.

        //creating MIGDB_FILE structure for current file
        migDbFile = (PMIGDB_FILE) PoolMemGetMemory (g_MigDbPool, sizeof (MIGDB_FILE));
        if (migDbFile != NULL) {
            ZeroMemory (migDbFile, sizeof (MIGDB_FILE));
            migDbFile->Section = g_ContextList->Sections;
            migDbFile->Attributes = pLoadAttribData (attrList.Buf);
            if (g_MigDbHook != NULL) {
                migDbAttrib = migDbFile->Attributes;
                while (migDbAttrib) {
                    g_MigDbHook (e->Name, g_ContextList, g_ContextList->Sections, migDbFile, migDbAttrib);
                    migDbAttrib = migDbAttrib->Next;
                }
            }

            //adding this file into string table and create a MIGDB_FILE node. If file
            //already exists in string table then just create another MIGDB_FILE node
            //chained with already existing ones.
            stringId = HtFindString (g_FileTable, e->Name);
            if (stringId) {

                HtCopyStringData (g_FileTable, stringId, &fileList);

                fileList.Last->Next = migDbFile;
                fileList.Last = migDbFile;

                HtSetStringData (g_FileTable, stringId, &fileList);
            }
            else {
                fileList.First = fileList.Last = migDbFile;
                HtAddStringAndData (g_FileTable, e->Name, &fileList);
            }
        }
        else {
            DEBUGMSG ((DBG_ERROR, "Unable to allocate file node for %s", e->Name));
        }

        MemDbBuildKey (key, MEMDB_CATEGORY_RENAME_SRC, e->Name, NULL, NULL);
        if (MemDbGetValue (key, &offset)) {
            if (!MemDbBuildKeyFromOffset (offset, key, 1, NULL)) {
                *key = 0;
            }
        } else {
            *key = 0;
        }

        _stprintf (
            msgStr,
            TEXT("%s\\%s%s"),
            MEMDB_CATEGORY_SECTFILES,
            *key?key:e->Name,
            line);
        MemDbSetValue (msgStr, fileSelected);
    }
    FreeGrowBuffer (&attrList);
    return TRUE;
}

BOOL
pCompressedFile (
    IN      PTREE_ENUM e
    )
{
    PCTSTR extPtr;

    extPtr = GetFileExtensionFromPath (e->FullPath);
    if (extPtr == NULL) {
        return FALSE;
    }
    if (_tcslen (extPtr) != 3) {
        return FALSE;
    }
    return (extPtr [2] == TEXT('_'));
}

BOOL
pExeFile (
    IN      PTREE_ENUM e
    )
{
    PCTSTR extPtr;

    extPtr = GetFileExtensionFromPath (e->FullPath);
    if ((extPtr != NULL) &&
        (StringIMatch (extPtr, TEXT("EXE")))
        ) {
        return TRUE;
    }
    return FALSE;
}

BOOL
pCopyAndHandleCabResource (
    IN      PVOID Source,
    IN      DWORD Size,
    IN      PCTSTR DirName
    )
{
    TCHAR cabDir   [MAX_TCHAR_PATH] = "";
    HANDLE hFile;
    DWORD dontCare;

    if (Size < 4) {
        return TRUE;
    }
    if (*((PDWORD)Source) != 0x4643534D) {
        return TRUE;
    }

    g_FileSequencer ++;
    _stprintf (cabDir, TEXT("%s\\MIGDB%03u.CAB"), DirName, g_FileSequencer);

    hFile = CreateFile (cabDir, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_ERROR, "Cannot create file %s", cabDir));
        return FALSE;
    }
    if (!WriteFile (hFile, Source, Size, &dontCare, NULL)) {
        DEBUGMSG ((DBG_ERROR, "Cannot write to file %s", cabDir));
        return FALSE;
    }
    CloseHandle (hFile);

    return TRUE;
}

BOOL CALLBACK
EnumResNameProc (
    IN      HANDLE hModule,   // module handle
    IN      LPCTSTR lpszType, // pointer to resource type
    IN      LPTSTR lpszName,  // pointer to resource name
    IN      LONG lParam       // application-defined parameter
    )
{
    HRSRC hResource;
    DWORD size;
    HGLOBAL hGlobal;
    PVOID srcBytes;

    hResource = FindResource (hModule, lpszName, lpszType);
    if (hResource) {
        size = SizeofResource (hModule, hResource);
        if (size) {
            hGlobal = LoadResource (hModule, hResource);
            if (hGlobal) {
                srcBytes = LockResource (hGlobal);
                if (srcBytes) {
                    pCopyAndHandleCabResource (srcBytes, size, (PCTSTR)lParam);
                }
            }
        }
    }
    return TRUE;
}


BOOL CALLBACK
EnumResTypeProc (
    IN      HANDLE hModule,  // resource-module handle
    IN      LPTSTR lpszType, // pointer to resource type
    IN      LONG lParam      // application-defined parameter
    )
{
    if ((lpszType != RT_ACCELERATOR  ) &&
        (lpszType != RT_ANICURSOR    ) &&
        (lpszType != RT_ANIICON      ) &&
        (lpszType != RT_BITMAP       ) &&
        (lpszType != RT_CURSOR       ) &&
        (lpszType != RT_DIALOG       ) &&
        (lpszType != RT_FONT         ) &&
        (lpszType != RT_FONTDIR      ) &&
        (lpszType != RT_GROUP_CURSOR ) &&
        (lpszType != RT_GROUP_ICON   ) &&
        (lpszType != RT_HTML         ) &&
        (lpszType != RT_ICON         ) &&
        (lpszType != RT_MENU         ) &&
        (lpszType != RT_MESSAGETABLE ) &&
        (lpszType != RT_PLUGPLAY     ) &&
        (lpszType != RT_STRING       ) &&
        (lpszType != RT_VERSION      ) &&
        (lpszType != RT_VXD          ) &&
        (lpszType != RT_HTML         )
        ) {
        // we found an unknown type. Let's enumerate all resources of this type
        if (EnumResourceNames (hModule, lpszType, EnumResNameProc, lParam) == 0) {
            DEBUGMSG ((DBG_ERROR, "Error enumerating names:%ld", GetLastError ()));
        }
    }
    return TRUE;
}

BOOL
pHandleAllFiles (
    IN      BOOL AppMode,
    IN      PCTSTR Action,
    IN      PCTSTR Section,
    IN      PCTSTR Message,
    IN      PCTSTR SrcPath
    )
{
    TCHAR tempDir [MAX_TCHAR_PATH] = "";
    TCHAR cmdLine [MAX_TCHAR_PATH] = "";
    TCHAR newName [MAX_TCHAR_PATH] = "";
    TREE_ENUM e;
    DWORD error;
    HMODULE exeModule;

    PROCESS_INFORMATION processInfo;
    STARTUPINFO startupInfo;

    if (EnumFirstFileInTree (&e, SrcPath, TEXT("*"), FALSE)) {
        do {
            if (!e.Directory) {
                if (pCabinetFile (e.Name)) {
                    if ((AppMode) ||
                        (!pSelected (e.Name))
                        ) {
                        // cabinet file
                        g_DirSequencer++;
                        _stprintf (tempDir, TEXT("%s\\MIGDB%03u"), g_TempDir, g_DirSequencer);
                        if (CreateDirectory (tempDir, NULL) == 0) {
                            error = GetLastError ();
                            if (error == ERROR_ALREADY_EXISTS) {
                                pDeleteAllFiles (tempDir);
                            }
                            ELSE_DEBUGMSG ((DBG_ERROR, "Cannot create directory %s", tempDir));
                        }

                        _tprintf (TEXT("    Extracting cabinet file ... %s"), e.Name);

                        // we need to expand the cabinet file
                        SetLastError (0);
                        if (!SetupIterateCabinet (e.FullPath, 0, pCabinetCallback, tempDir)) {
                            _tprintf (TEXT("...error %ld\n"), GetLastError());
                            DEBUGMSG((DBG_ERROR, "Could not iterate cabinet file:%s\nError:%ld", e.FullPath, GetLastError ()));
                        }
                        else {
                            _tprintf (TEXT("...done\n"));
                        }

                        if (!pHandleAllFiles (AppMode, Action, Section, Message, tempDir)) {
                            return FALSE;
                        }

                        pDeleteAllFiles (tempDir);
                        RemoveDirectory (tempDir);
                        g_DirSequencer--;
                    }
                }
                else if (pCompressedFile (&e)) {
                    if (AppMode) {
                        if (!pSpecialSelected (e.Name, newName)) {
                            continue;
                        }
                    }
                    else {
                        if (pSpecialSelected (e.Name, newName)) {
                            continue;
                        }
                    }
                    // compressed file
                    g_DirSequencer++;
                    _stprintf (tempDir, TEXT("%s\\MIGDB%03u"), g_TempDir, g_DirSequencer);
                    if (CreateDirectory (tempDir, NULL) == 0) {
                        error = GetLastError ();
                        if (error == ERROR_ALREADY_EXISTS) {
                            pDeleteAllFiles (tempDir);
                        }
                        ELSE_DEBUGMSG ((DBG_ERROR, "Cannot create directory %s", tempDir));
                    }

                    _stprintf (cmdLine, TEXT("expand /r \"%s\" \"%s\""), e.FullPath, tempDir);
                    ZeroMemory (&startupInfo, sizeof (STARTUPINFO));
                    startupInfo.cb = sizeof (STARTUPINFO);
                    if (CreateProcess (NULL, cmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo)) {
                        WaitForSingleObject (processInfo.hProcess, INFINITE);
                        CloseHandle (processInfo.hProcess);
                        CloseHandle (processInfo.hThread);
                        if (!pHandleAllFiles (AppMode, Action, Section, Message, tempDir)) {
                            return FALSE;
                        }
                        pDeleteAllFiles (tempDir);
                    }
                    else {
                        DEBUGMSG ((DBG_ERROR, "Could not decompress:%s, Error:%ld", e.Name, GetLastError()));
                    }

                    RemoveDirectory (tempDir);
                    g_DirSequencer--;
                }
                else {
                    if (pExeFile (&e)) {

                        g_FileSequencer = 0;
                        g_DirSequencer++;
                        _stprintf (tempDir, TEXT("%s\\MIGDB%03u"), g_TempDir, g_DirSequencer);
                        if (CreateDirectory (tempDir, NULL) == 0) {
                            error = GetLastError ();
                            if (error == ERROR_ALREADY_EXISTS) {
                                pDeleteAllFiles (tempDir);
                            }
                            ELSE_DEBUGMSG ((DBG_ERROR, "Cannot create directory %s", tempDir));
                        }

                        exeModule = LoadLibraryEx (e.FullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
                        EnumResourceTypes (exeModule, EnumResTypeProc, (LONG)tempDir);
                        FreeLibrary (exeModule);

                        if (!pHandleAllFiles (AppMode, Action, Section, Message, tempDir)) {
                            return FALSE;
                        }

                        pDeleteAllFiles (tempDir);
                        RemoveDirectory (tempDir);
                        g_DirSequencer--;
                    }

                    if (AppMode) {
                        if (pSelected (e.Name)) {
                            if (!pHandleAppFile (&e, Action, Section, Message, SrcPath)) {
                                return FALSE;
                            }
                        }
                    }
                    else {
                        if (!pSelected (e.Name)) {
                            if (!pHandleSysFile (&e, Action, Section, Message, SrcPath)) {
                                return FALSE;
                            }
                        }
                    }
                }
            }
        } while (EnumNextFileInTree (&e));
    }
    return TRUE;
}

BOOL
pHandleSection (
    IN      PCTSTR SectionName,
    IN      HINF ConfigHandle
    )
{
    PMIGDB_CONTEXT migDbContext = NULL;
    INFCONTEXT context;
    TCHAR action  [MAX_TCHAR_PATH] = "";
    TCHAR section [MAX_TCHAR_PATH] = "";
    TCHAR message [MAX_TCHAR_PATH] = "";
    TCHAR srcPath [MAX_TCHAR_PATH] = "";
    TCHAR msgStr  [MAX_TCHAR_PATH] = "";
    TCHAR sectTmp [MAX_TCHAR_PATH] = "";
    TCHAR renSect [MAX_TCHAR_PATH] = "";
    TCHAR srcFile [MAX_TCHAR_PATH] = "";
    TCHAR destFile[MAX_TCHAR_PATH] = "";
    BOOL forced = FALSE;
    INT field;
    TCHAR excludePattern [MAX_TCHAR_PATH] = "";
    BOOL appMode = FALSE;
    TCHAR sectPatterns [MAX_TCHAR_PATH] = "";
    DWORD offset;

    _tprintf (TEXT("Processing section : %s ... "), SectionName);

    if (!SetupFindFirstLine (ConfigHandle, SectionName, TEXT("action"), &context)) {
        _tprintf (TEXT("\nCannot find Action= line in %s.\n"), SectionName);
        return FALSE;
    }
    if (!SetupGetStringField (&context, 1, action, MAX_TCHAR_PATH, NULL)) {
        _tprintf (TEXT("\nCannot read action name in %s.\n"), SectionName);
        return FALSE;
    }

    if (!SetupFindFirstLine (ConfigHandle, SectionName, TEXT("section"), &context)) {
        _tprintf (TEXT("\nCannot find Section= line in %s.\n"), SectionName);
        return FALSE;
    }
    if (!SetupGetStringField (&context, 1, section, MAX_TCHAR_PATH, NULL)) {
        _tprintf (TEXT("\nCannot read section name in %s.\n"), SectionName);
        return FALSE;
    }

    if (!SetupFindFirstLine (ConfigHandle, SectionName, TEXT("sourcepath"), &context)) {
        _tprintf (TEXT("\nCannot find SourcePath= line in %s.\n"), SectionName);
        return FALSE;
    }
    if (!SetupGetStringField (&context, 1, srcPath, MAX_TCHAR_PATH, NULL)) {
        _tprintf (TEXT("\nCannot read source path name in %s.\n"), SectionName);
        return FALSE;
    }
    if (SetupFindFirstLine (ConfigHandle, SectionName, TEXT("message"), &context)) {
        SetupGetStringField (&context, 1, message, MAX_TCHAR_PATH, NULL);
    }

    if (SetupFindFirstLine (ConfigHandle, SectionName, TEXT("RenameSection"), &context)) {
        SetupGetStringField (&context, 1, renSect, MAX_TCHAR_PATH, NULL);
    }

    g_SectFiles.Buf       = NULL;
    g_SectFiles.Size      = 0;
    g_SectFiles.End       = 0;
    g_SectFiles.GrowSize  = 0;
    g_SectFiles.UserIndex = 0;

    if (SetupFindFirstLine (ConfigHandle, SectionName, TEXT("ExcludeFiles"), &context)) {
        field = 1;
        while (SetupGetStringField (&context, field, excludePattern, MAX_TCHAR_PATH, NULL)) {
            MultiSzAppend (&g_SectFiles, excludePattern);
            field ++;
        }
        appMode = FALSE;
    }

    if (SetupFindFirstLine (ConfigHandle, SectionName, TEXT("SpecifiedFiles"), &context)) {
        field = 1;
        while (SetupGetStringField (&context, field, excludePattern, MAX_TCHAR_PATH, NULL)) {
            MultiSzAppend (&g_SectFiles, excludePattern);
            field ++;
        }
        appMode = TRUE;
    }

    // let's try to find if this section was already processed in migdb.inf
    if (SetupFindFirstLine (g_MigDbInf, action, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 1, sectTmp, MAX_TCHAR_PATH, NULL) &&
                (StringIMatch (section, sectTmp))
                ) {
                _tprintf (TEXT("\n Section already present in %s; please choose another name\n"));
                return FALSE;
            }
        }
        while (SetupFindNextLine (&context, &context));
    }

    if (SetupFindFirstLine (ConfigHandle, renSect, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 0, srcFile, MAX_TCHAR_PATH, NULL) &&
                SetupGetStringField (&context, 1, destFile, MAX_TCHAR_PATH, NULL)
                ) {
                MemDbSetValueEx (MEMDB_CATEGORY_RENAME_DEST, destFile, NULL, NULL, 0, &offset);
                MemDbSetValueEx (MEMDB_CATEGORY_RENAME_SRC, srcFile, NULL, NULL, offset, NULL);
            }
        } while (SetupFindNextLine (&context, &context));
    }

    _tprintf (TEXT("\n"));

    migDbContext = (PMIGDB_CONTEXT) PoolMemGetMemory (g_MigDbPool, sizeof (MIGDB_CONTEXT));
    if (migDbContext == NULL) {
        DEBUGMSG ((DBG_ERROR, "Unable to create context for %s", action));
        return FALSE;
    }

    ZeroMemory (migDbContext, sizeof (MIGDB_CONTEXT));
    migDbContext->Next = g_ContextList;
    g_ContextList = migDbContext;

    // update ActionIndex with known value
    migDbContext->ActionIndex = MigDb_GetActionIdx (action);
    DEBUGMSG_IF(((migDbContext->ActionIndex == -1), DBG_ERROR, "Unable to identify action index for %s", action));

    // update SectName field
    migDbContext->SectName = PoolMemDuplicateString (g_MigDbPool, section);

    if (!pHandleAllFiles (appMode, action, section, message, srcPath)) {
        return FALSE;
    }

    FreeGrowBuffer (&g_SectFiles);

    if (!forced) {
        // now let's add the action section and the line within it
        _stprintf (msgStr, TEXT("%s\\%s,%s"),
            MEMDB_CATEGORY_ACTION,
            section,
            message);
        MemDbSetValue (msgStr, 0);

        pWriteMemdbSection (g_MigdbDest, MEMDB_CATEGORY_ACTION, action, FALSE);
    }

    pWriteMemdbSection (g_MigdbDest, MEMDB_CATEGORY_SECTFILES, section, TRUE);

    pWriteMemdbSection (g_MigdbDest, MEMDB_CATEGORY_REQFILES, TEXT("Windows 9x Required Files"), TRUE);

    MemDbDeleteTree (MEMDB_CATEGORY_SECTFILES);
    MemDbDeleteTree (MEMDB_CATEGORY_ACTION);
    MemDbDeleteTree (MEMDB_CATEGORY_RENAME_SRC);
    MemDbDeleteTree (MEMDB_CATEGORY_RENAME_DEST);
    MemDbDeleteTree (MEMDB_CATEGORY_REQFILES);

    return TRUE;
}

BOOL
pWriteMemdbSection (
    IN      PCTSTR FileName,
    IN      PCTSTR MemDbCategory,
    IN      PCTSTR SectName,
    IN      BOOL WriteByValue
    )
{
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    TCHAR line [MAX_TCHAR_PATH] = "";
    DWORD dontCare;
    MEMDB_ENUM e;
    PCTSTR pattern;

    fileHandle = CreateFile (FileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        _tprintf (TEXT("\nCannot open %s.\n"), FileName);
        return FALSE;
    }

    SetFilePointer (fileHandle, 0, 0, FILE_END);

    _stprintf (line, TEXT("[%s]\r\n"), SectName);
    WriteFile (fileHandle, line, GetEndOfString (line) - line, &dontCare, NULL);

    pattern = JoinPaths (MemDbCategory, TEXT("\\*"));
    if (MemDbEnumFirstValue (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if (!WriteByValue || !e.dwValue) {
                _stprintf (line, TEXT("%s\r\n"), e.szName);
                if (!WriteFile (fileHandle, line, GetEndOfString (line) - line, &dontCare, NULL)) {
                    DEBUGMSG ((DBG_ERROR, "Error while writing information."));
                }
            }
        }
        while (MemDbEnumNextValue (&e));
    }

    _stprintf (line, TEXT("\r\n\r\n"), SectName);
    WriteFile (fileHandle, line, GetEndOfString (line) - line, &dontCare, NULL);

    if (!CloseHandle (fileHandle)) {
        DEBUGMSG ((DBG_ERROR, "Error while closing file %s.", FileName));
    }

    if (WriteByValue) {

        fileHandle = CreateFile (g_MigdbDump, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);
        if (fileHandle == INVALID_HANDLE_VALUE) {
            _tprintf (TEXT("\nCannot open %s.\n"), g_MigdbDump);
            return FALSE;
        }

        SetFilePointer (fileHandle, 0, 0, FILE_END);

        _stprintf (line, TEXT("\n[%s.obsolete]\r\n"), SectName);
        WriteFile (fileHandle, line, GetEndOfString (line) - line, &dontCare, NULL);

        if (MemDbEnumFirstValue (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            do {
                if (e.dwValue) {
                    _stprintf (line, TEXT("%s\r\n"), e.szName);
                    if (!WriteFile (fileHandle, line, GetEndOfString (line) - line, &dontCare, NULL)) {
                        DEBUGMSG ((DBG_ERROR, "Error while writing information."));
                    }
                }
            }
            while (MemDbEnumNextValue (&e));
        }
        if (!CloseHandle (fileHandle)) {
            DEBUGMSG ((DBG_ERROR, "Error while closing file %s.", FileName));
        }

    }

    FreePathString (pattern);

    return TRUE;
}

BOOL
pArrangeMigDbFile (
    IN      PCTSTR SrcFile,
    IN      PCTSTR DestFile
    )
{
    return CopyFile (SrcFile, DestFile, FALSE);
}

BOOL
pReadNtFilesEx (
    IN      PCSTR FileListName
    )
{
    PCSTR fileListName = NULL;
    PCSTR fileListTmp = NULL;
    HANDLE fileHandle = NULL;
    HANDLE mapHandle = NULL;
    PCSTR filePointer = NULL;
    PCSTR filePtr = NULL;
    DWORD offset;
    DWORD version;
    BOOL result = TRUE;
    CHAR dirName [MEMDB_MAX];

    __try {

        //
        // add to this list the dirs listed in [WinntDirectories] section of txtsetup.sif
        //

        if (FileListName != NULL) {
            filePointer = MapFileIntoMemory (FileListName, &fileHandle, &mapHandle);
        }
        filePtr = filePointer;
        if (filePointer == NULL) {
            result = FALSE;
            __leave;
        }
        version = *((PDWORD) filePointer);
        filePointer += sizeof (DWORD);
        __try {
            if (version >= 1) {
                while (*filePointer != 0) {
                    StringCopy (dirName, filePointer);
                    MemDbSetValueEx (
                        MEMDB_CATEGORY_NT_DIRS,
                        dirName,
                        NULL,
                        NULL,
                        0,
                        &offset
                        );
                    filePointer = _mbsinc (GetEndOfString (filePointer));
                    MemDbSetValueEx (
                        MEMDB_CATEGORY_NT_FILES,
                        filePointer,
                        NULL,
                        NULL,
                        offset,
                        NULL
                        );
                    filePointer = _mbsinc( GetEndOfString (filePointer));
                }
                if (version >= 2) {
                    filePointer ++;
                    while (*filePointer != 0) {
                        MemDbSetValueEx (
                            MEMDB_CATEGORY_NT_FILES_EXCEPT,
                            filePointer,
                            NULL,
                            NULL,
                            0,
                            NULL
                            );
                        filePointer = _mbsinc (GetEndOfString (filePointer));
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER){
            LOG ((LOG_ERROR, "Access violation while reading NT file list."));
        }
    }
    __finally {
        UnmapFile ((PVOID)filePtr, fileHandle, mapHandle);
        if (fileListTmp) {
            DeleteFile (fileListTmp);
            FreePathString (fileListTmp);
            fileListTmp = NULL;
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\rasdump\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\nttool\nttool.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    usermig.c

Abstract:

    User migration test tool

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();
}


INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{
    LONG rc;
    REGTREE_ENUM e;
    MIGRATE_USER_ENUM e2;

    if (!Init()) {
        wprintf (L"Unable to initialize!\n");
        return 255;
    }

    //
    // To use this tool, first run an upgrade with /#u:keeptempfiles and with
    // %windir% equal to c:\windows. Then add test code below. Finally, run
    // this tool on the upgraded machine.
    //

    //
    // Initialize Win95Reg
    //

    rc = Win95RegInit (TEXT("c:\\windows\\setup\\defhives"), FALSE);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((LOG_ERROR, "Init Processor: Win95RegInit failed, check Win9x windir in code"));
        return FALSE;
    }

    MemDbLoad (TEXT("c:\\windows\\setup\\ntsetup.dat"));

    g_DomainUserName = NULL;
    g_Win9xUserName  = NULL;
    g_FixedUserName  = NULL;

    g_hKeyRootNT = HKEY_LOCAL_MACHINE;
    g_hKeyRoot95 = HKEY_LOCAL_MACHINE;
    SetRegRoot (g_hKeyRoot95);

    //
    // Put your test code here
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\regdmp95\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\regdmp95\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\pnpids\pnpids.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    pnpids.c

Abstract:

    Dumps out the PNP IDs of one or more INFs

Author:

    Jim Schmidt (jimschm) 10-Jun-1999

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        TEXT("  pnpids [directory|file]\n")

        TEXT("\nDescription:\n\n")

        TEXT("  PNPIDS.EXE lists the Plug-and-Play IDs found in an installer INF.\n")

        TEXT("\nArguments:\n\n")

        TEXT("  directory - OPTIONAL: Specifies a directory to process\n")
        TEXT("  file      - OPTIONAL: Specifies a specific INF file to process\n\n")

        TEXT("If no arguments are specified, all INFs in the current directory are\n")
        TEXT("processed.\n")

        );

    exit (1);
}


BOOL
pProcessInf (
    IN      PCTSTR FileSpec
    )
{
    HINF Inf;
    INFSTRUCT isMfg = INITINFSTRUCT_GROWBUFFER;
    INFSTRUCT isDev = INITINFSTRUCT_GROWBUFFER;
    PCTSTR Str;
    UINT u, v;
    UINT Devices;
    UINT Ids;

    Inf = InfOpenInfFile (FileSpec);

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (InfFindFirstLine (Inf, "Manufacturer", NULL, &isMfg)) {

        do {
            Str = InfGetStringField (&isMfg, 0);
            if (!Str) {
                continue;
            }

            _tprintf (
                TEXT("[%s] Manufacturer: %s\n\n"),
                GetFileNameFromPath (FileSpec),
                Str
                );

            u = 1;
            Devices = 0;

            for (;;) {
                Str = InfGetStringField (&isMfg, u);
                u++;

                if (!Str) {
                    break;
                }

                if (!*Str) {
                    continue;
                }

                if (InfFindFirstLine (Inf, Str, NULL, &isDev)) {

                    Ids = 0;

                    do {

                        Str = InfGetStringField (&isDev, 0);
                        if (!Str) {
                            continue;
                        }

                        _tprintf (TEXT("  %s:\n"), Str);
                        Devices++;

                        v = 2;
                        for (;;) {
                            Str = InfGetStringField (&isDev, v);
                            v++;

                            if (!Str) {
                                break;
                            }

                            if (!*Str) {
                                continue;
                            }

                            Ids++;

                            _tprintf (TEXT("    %s\n"), Str);
                        }

                    } while (InfFindNextLine (&isDev));

                    if (!Ids) {
                        _tprintf (TEXT("    (no PNP IDs)\n"));
                    }
                }
            }

            if (!Devices) {
                printf ("  (no devices)\n\n");
            } else {
                printf ("\n  %u device%s listed\n\n", Devices, Devices == 1 ? "" : "s");
            }

        } while (InfFindNextLine (&isMfg));
    }


    InfCleanUpInfStruct (&isMfg);
    InfCleanUpInfStruct (&isDev);

    return TRUE;
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg = NULL;
    DWORD Attribs;
    FILE_ENUM e;
    UINT Processed = 0;
    PCTSTR Pattern = TEXT("*.INF");

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            HelpAndExit();
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (FileArg) {
                HelpAndExit();
            } else {
                FileArg = argv[i];
            }
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    if (!FileArg) {
        FileArg = TEXT(".");
    }

    if (_tcschr (FileArg, '*') || _tcschr (FileArg, '?')) {

        if (_tcschr (FileArg, TEXT('\\'))) {
            HelpAndExit();
        }

        Pattern = FileArg;
        Attribs = FILE_ATTRIBUTE_DIRECTORY;
        FileArg = TEXT(".");

    } else {
        Attribs = GetFileAttributes (FileArg);
        if (Attribs == INVALID_ATTRIBUTES) {
            _ftprintf (stderr, TEXT("%s is not valid.\n\n"), FileArg);
            HelpAndExit();
        }
    }

    if (Attribs & FILE_ATTRIBUTE_DIRECTORY) {
        if (EnumFirstFile (&e, FileArg, Pattern)) {
            do {

                if (pProcessInf (e.FullPath)) {
                    Processed++;
                }

            } while (EnumNextFile (&e));
        }

    } else {

        if (pProcessInf (FileArg)) {
            Processed++;
        }

    }

    _ftprintf (
        stderr,
        TEXT("%u file%s processed.\n"),
        Processed,
        Processed == 1 ? TEXT("") : TEXT("s")
        );

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\pnprept\pnprept.c ===
#include "pch.h"

#ifdef UNICODE
#error UNICODE not allowed
#endif

#define PNPREPT_HWND    (HWND)1

BOOL
WINAPI
MemDb_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD dwReason,
    IN LPVOID lpv
    );

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved
    );


VOID
pInitProgBarVars (
    VOID
    );

INT
pCallMains (
    DWORD Reason
    )
{
    if (!MigUtil_Entry (g_hInst, Reason, NULL)) {
        fprintf (stderr, "MigUtil_Entry error!\n");
        return 254;
    }

    if (!MemDb_Entry (g_hInst, Reason, NULL)) {
        fprintf (stderr, "MemDb_Entry error!\n");
        return 254;
    }

    if (!HwComp_Entry (g_hInst, Reason, NULL)) {
        fprintf (stderr, "HwComp_Entry error!\n");
        return 254;
    }

    pInitProgBarVars();

    return 0;
}

BOOL CancelFlag = FALSE;
BOOL *g_CancelFlagPtr = &CancelFlag;

#ifdef PRERELEASE
BOOL g_Stress;
#endif

HANDLE g_hHeap;
HINSTANCE g_hInst;
HINF g_OverrideInf = INVALID_HANDLE_VALUE;
BOOL g_ManualOverrideMode = FALSE;

CHAR   g_TempDirBuf[MAX_MBCHAR_PATH];      // location for hwcomp.dat
CHAR   g_TempDirWackBuf[MAX_MBCHAR_PATH];
CHAR   g_WinDirBuf[MAX_MBCHAR_PATH];
INT    g_TempDirWackChars;
PCSTR  g_SourceDirectories[MAX_SOURCE_COUNT];    // location of INFs
DWORD  g_SourceDirectoryCount;
PSTR g_TempDir;
PSTR g_TempDirWack;
PSTR g_WinDir;

USEROPTIONS g_ConfigOptions; // Needed by migutil. Unused.

extern HWND g_Component, g_SubComponent;

void
HelpAndExit (
    void
    )
{
    fprintf (stderr,
        "Command line syntax:\n\n"
        "pnprept {-a|-s|-u|-c} [-e<n>] <Inf Dir 1> <Inf Dir 2>\n\n"
        "Optional Arguments:\n"
        "  <Inf Dir 1> - Specifies the directory containing the first set of INFs\n"
        "  <Inf Dir 2> - Specifies the directory containing the second set of INFs\n"
        "\nOutput Options (specify at least one):\n"
        "  -a    - Dumps all devices for both Dir 1 and Dir 2.\n"
        "  -1    - Dumps devices supported by Dir 1 only (devices unsupported by Dir 2)\n"
        "  -2    - Dumps devices supported by Dir 2 only (devices unsupported by Dir 1)\n"
        "  -c    - Dumps devices common to Dir 1 and Dir 2\n"
        "\nOther Options:\n"
        "  -i:<path> - Specifies path to win95upg.inf for override list\n"
        "  -m        - Dumps only PNP IDs that are manually overridden (requires -i)\n"
        "  -e<n>     - Puts an equals instead of a tab after column <n>\n"
        "\n"
        );

    exit(255);
}

DWORD g_Mode = 0;
#define MODE_DIR1       0x0001
#define MODE_DIR2       0x0002

#define MAX_SEPARATORS 3
CHAR g_Separators[MAX_SEPARATORS];
LPSTR g_Dir1Path, g_Dir2Path;

VOID
Dump (
    DWORD MustHave,
    DWORD MustNotHave
    )
{
    MEMDB_ENUM e, e2;
    CHAR PnpOutput[MAX_ENCODED_PNPID_LENGTH];
    CHAR DescOutput[MAX_INF_DESCRIPTION*2];
    BOOL IsDir1, IsDir2;
    LPSTR Dir1File, Dir2File;
    GROWBUFFER Dir1List = GROWBUF_INIT;
    GROWBUFFER Dir2List = GROWBUF_INIT;
    BOOL Dir1Flag, Dir2Flag;
    DWORD Flags;
    CHAR Node[MEMDB_MAX];
    INFCONTEXT ic;

    if (!g_ManualOverrideMode) {
        printf ("%s%c%s%cPNP ID\tDevice Description%c\n",
                g_Dir1Path, g_Separators[0], g_Dir2Path, g_Separators[1], g_Separators[2]);
    } else {
        printf ("Overridden PNP IDs\n");
    }

    if (MemDbEnumFirstValue (&e, TEXT("Devices\\*"), MEMDB_THIS_LEVEL_ONLY, MEMDB_ALL_BUT_PROXY)) {

        do {
            //
            // Test this PNP ID to see if it should be displayed
            //

            if (((e.dwValue & MustHave) == MustHave) &&
                ((e.dwValue & MustNotHave) == 0)) {

                //
                // Prepare display string for PNP ID
                //

                StringCopyA (PnpOutput, e.szName);
                DecodePnpId (PnpOutput);

                //
                // Is PNP ID suppressed?  If so, continue memdb enum.
                //

                if (g_OverrideInf != INVALID_HANDLE_VALUE) {
                    if (SetupFindFirstLine (
                            g_OverrideInf,
                            "Standard PNP IDs",
                            PnpOutput,
                            &ic
                            )) {
                        if (g_ManualOverrideMode) {
                            printf ("%s\n", PnpOutput);
                        }
                        continue;
                    }
                }

                //
                // If only dumping manually overridden PNP IDs, continue.
                //

                if (g_ManualOverrideMode) {
                    continue;
                }

                //
                // Enumerate each description for the PNP ID
                //

                IsDir1 = (e.dwValue & MODE_DIR1) != 0;
                IsDir2 = (e.dwValue & MODE_DIR2) != 0;

                wsprintf (Node, TEXT("Devices\\%s\\*"), e.szName);

                if (MemDbEnumFirstValue (
                        &e2,
                        Node,
                        MEMDB_ALL_SUBLEVELS,
                        MEMDB_ENDPOINTS_ONLY
                        )) {

                    //
                    // Prepare display string for description by stripping off
                    // the sequencer and decoding it, then reset INF file name
                    // buffers.
                    //

                    StringCopyA (DescOutput, e2.szName);
                    *_mbschr (DescOutput, '\\') = 0;
                    DecodePnpId (DescOutput);

                    Dir1List.End = 0;
                    Dir2List.End = 0;

                    do {
                        //
                        // For each description, get the value of the string
                        // specified by the description sequencer's offset.
                        //
                        // We store the file names in a table, so we can organize
                        // matches correctly.  After the table is complete, we
                        // then dump it out.
                        //

                        MemDbBuildKeyFromOffset (e2.dwValue, Node, 1, &Flags);

                        if (((Flags & MustHave) || !MustHave) &&
                            ((Flags & MustNotHave) == 0)) {

                            Dir1Flag = (Flags & MODE_DIR1) != 0;
                            Dir2Flag = (Flags & MODE_DIR2) != 0;

                            if (Dir1Flag) {
                                MultiSzAppend (&Dir1List, Node);
                            }
                            if (Dir2Flag) {
                                MultiSzAppend (&Dir2List, Node);
                            }
                        }
                    } while (MemDbEnumNextValue (&e2));

                    MultiSzAppend (&Dir1List, "");
                    MultiSzAppend (&Dir2List, "");

                    //
                    // Dump all matches
                    //

                    Dir1File = (LPSTR) Dir1List.Buf;
                    if (!Dir1File) {
                        Dir1File = "";
                    }
                    Dir2File = (LPSTR) Dir2List.Buf;
                    if (!Dir2File) {
                        Dir2File = "";
                    }

                    while (*Dir1File || *Dir2File) {

                        printf (
                            "%s%c%s%c%s%c%s\n",
                            Dir1File,
                            g_Separators[0],
                            Dir2File,
                            g_Separators[1],
                            PnpOutput,
                            g_Separators[2],
                            DescOutput
                            );

                        if (*Dir1File) {
                            Dir1File = GetEndOfStringA (Dir1File) + 1;
                        }
                        if (*Dir2File) {
                            Dir2File = GetEndOfStringA (Dir2File) + 1;
                        }
                    }
                }
            }
        } while (MemDbEnumNextValue (&e));
    } else {
        printf ("No devices found.\n");
    }

    FreeGrowBuffer (&Dir1List);
    FreeGrowBuffer (&Dir2List);
}

int
__cdecl
main (
    int argc,
    char *argv[]
    )
{
    LPSTR Dir1InputPath;
    LPSTR Dir2InputPath;
    INT i, j;
    LONG rc;
    INT UIMode;
    BOOL AllFlag = FALSE;
    BOOL Dir2Only = FALSE;
    BOOL Dir1Only = FALSE;
    BOOL Common = FALSE;
    PCSTR OverrideList = NULL;
    DWORD Count;

    //
    // Init project globals
    //

    GetTempPathA (MAX_MBCHAR_PATH, g_TempDirBuf);
    g_TempDir = g_TempDirBuf;

    StringCopyA (g_TempDirWackBuf, g_TempDir);
    AppendWack (g_TempDirWackBuf);
    g_TempDirWackChars = CharCountA (g_TempDirWackBuf);
    g_TempDirWack = g_TempDirWackBuf;

    GetWindowsDirectoryA (g_WinDirBuf, MAX_MBCHAR_PATH);
    g_WinDir = g_WinDirBuf;

    ZeroMemory(&g_ConfigOptions,sizeof(USEROPTIONS));

    UIMode = PNPREPT_OUTPUT;
    g_Component = NULL;
    g_SubComponent = PNPREPT_HWND;

    //
    // Parse command line
    //

    Dir1InputPath = NULL;
    Dir2InputPath = NULL;

    for (i = 0 ; i < MAX_SEPARATORS ; i++) {
        g_Separators[i] = '\t';
    }

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {
            case 'a':
                AllFlag = TRUE;
                break;

            case '2':
                Dir2Only = TRUE;
                break;

            case '1':
                Dir1Only = TRUE;
                break;

            case 'c':
                Common = TRUE;
                break;

            case 'm':
                g_ManualOverrideMode = TRUE;
                break;

            case 'e':
                j = atoi (&argv[i][2]);
                if (j < 1 || j > MAX_SEPARATORS) {
                    HelpAndExit();
                }
                g_Separators[j] = '=';
                break;

            case 'i':
                if (!argv[i][2] && (i + 1) < argc) {
                    i++;
                    OverrideList = argv[i];
                } else if (argv[i][2] == ':') {
                    OverrideList = &argv[i][3];
                } else {
                    HelpAndExit();
                }
                break;

            default:
                HelpAndExit();
            }
        } else {
            if (Dir1InputPath && Dir2InputPath) {
                HelpAndExit();
            } else if (Dir1InputPath) {
                Dir2InputPath = argv[i];
            } else {
                Dir1InputPath = argv[i];
            }
        }
    }

    if (!AllFlag && !Dir2Only && !Dir1Only && !Common) {
        HelpAndExit();
    }

    if (g_ManualOverrideMode && !OverrideList) {
        HelpAndExit();
    }

    if (!Dir2InputPath) {
        HelpAndExit();
    }

    //
    // Init globals and libs
    //

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    g_SourceDirectories[0]   = Dir1InputPath;
    Count = 1;
    g_SourceDirectoryCount = Count;

    if (pCallMains (DLL_PROCESS_ATTACH)) {
        fprintf (stderr, "Initialization error!\n");
        return 254;
    }

    g_Dir1Path = _mbsrchr (Dir1InputPath, '\\');
    if (!g_Dir1Path) {
        g_Dir1Path = Dir1InputPath;
    } else {
        g_Dir2Path++;
    }

    g_Dir2Path = _mbsrchr (Dir2InputPath, '\\');
    if (!g_Dir2Path) {
        g_Dir2Path = Dir2InputPath;
    } else {
        g_Dir2Path++;
    }

    if (StringIMatch (g_Dir1Path, g_Dir2Path)) {
        g_Dir1Path = Dir1InputPath;
        g_Dir2Path = Dir2InputPath;
    }

    if (StringIMatch (g_Dir1Path, g_Dir2Path)) {
        fprintf (stderr, "Dir 1 and Dir 2 must be different\n");
        return 247;
    }

    if (OverrideList) {
        CHAR FullPath[MAX_MBCHAR_PATH];
        PSTR DontCare;

        if (!SearchPathA (NULL, OverrideList, NULL, MAX_MBCHAR_PATH, FullPath, &DontCare)) {
            StringCopyA (FullPath, OverrideList);
        }

        g_OverrideInf = SetupOpenInfFile (
                            FullPath,
                            NULL,
                            INF_STYLE_OLDNT|INF_STYLE_WIN4,
                            NULL
                            );
        if (g_OverrideInf == INVALID_HANDLE_VALUE) {
            fprintf (stderr, "Cannot open %s\n", FullPath);
            return 246;
        }
    }

    __try {
        //
        // Generate memdb entries for Dir 1 INFs
        //

        fprintf (stderr, "Processing...\n", Dir1InputPath);

        g_Mode = MODE_DIR1;
        if (!CreateNtHardwareList (&Dir1InputPath, 1, NULL, UIMode)) {
            rc = GetLastError();
            fprintf (stderr, "Could not build complete %s device list.  Win32 Error Code: %xh\n", Dir1InputPath, rc);
            return 1;
        } else {
            fprintf (stderr, "   %s processed\n", Dir1InputPath);
        }

        //
        // Restart hwcomp.lib
        //

        if (!HwComp_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
            fprintf (stderr, "Termination error!\n");
            return 253;
        }

        if (!HwComp_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
            fprintf (stderr, "Initialization error!\n");
            return 252;
        }

        //
        // Generate memdb entries for Dir 2 INFs
        //

        g_Mode = MODE_DIR2;
        if (!CreateNtHardwareList (&Dir2InputPath, 1, NULL, UIMode)) {
            rc = GetLastError();
            fprintf (stderr, "Could not build complete %s device list.  Win32 Error Code: %xh\n", Dir2InputPath, rc);
            return 2;
        } else {
            fprintf (stderr, "   %s processed\n", Dir2InputPath);
        }

        //
        // Dump output
        //

        if (AllFlag) {
            Dump (0, 0);
        }

        if (Dir2Only) {
            Dump (MODE_DIR2, MODE_DIR1);
        }

        if (Dir1Only) {
            Dump (MODE_DIR1, MODE_DIR2);
        }

        if (Common) {
            Dump (MODE_DIR2|MODE_DIR1, 0);
        }

        //
        // Terminate hwcomp.lib
        //

        if (pCallMains (DLL_PROCESS_DETACH)) {
            fprintf (stderr, "Initialization error!\n");
            return 251;
        }

        fprintf (stderr, "Done\n");
    }

    __finally {
        if (g_OverrideInf != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (g_OverrideInf);
        }
    }

    return 0;
}

BOOL
ProcessPnpId (
    IN PCSTR  SubComponent
    )
{
    DWORD Value;
    TCHAR Node[MEMDB_MAX];
    LPTSTR PnpId, Desc, File;
    LPTSTR p;
    DWORD FileOffset;
    static DWORD d = 0;

    if (SubComponent) {
        PnpId = (LPTSTR) SubComponent;

        p = _tcschr (PnpId, TEXT('\\'));
        if (!p) {
            return TRUE;
        }
        *p = 0;
        Desc = p+1;

        p = _tcschr (Desc, TEXT('\\'));
        if (!p) {
            return TRUE;
        }
        *p = 0;
        File = p+1;

        //
        // Add the file (it may already exist) and remember the offset.
        // Keep the files in two separate lists.
        //

        MemDbSetValueEx (
            g_Mode == MODE_DIR1 ? TEXT("Dir1") : TEXT("Dir2"),
            File,
            NULL,
            NULL,
            g_Mode,
            &FileOffset
            );

        //
        // Add the PNP ID and OR the mode
        //

        wsprintf (Node, TEXT("Devices\\%s"), PnpId);
        if (!MemDbGetValue (Node, &Value)) {
            Value = 0;
        }

        Value |= g_Mode;

        MemDbSetValue (Node, Value);

        //
        // Add the description, and attach a sequencer to make sure
        // the description is unique.  Make the description point
        // to the file offset.
        //

        d++;
        wsprintf (Node, TEXT("Devices\\%s\\%s\\%u"), PnpId, Desc, d);
        MemDbSetValue (Node, FileOffset);
    }

    return TRUE;
}

//
// Stubs
//

HWND    g_Component;
HWND    g_SubComponent;
HANDLE  g_ComponentCancelEvent;
HANDLE  g_SubComponentCancelEvent;

VOID
pInitProgBarVars (
    VOID
    )
{
    g_Component = NULL;
    g_SubComponent = NULL;
    g_ComponentCancelEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    g_SubComponentCancelEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
}


BOOL
ProgressBar_SetWindowStringA (
    IN HWND Window,
    IN HANDLE CancelEvent,
    IN PCSTR Message,            OPTIONAL
    IN DWORD MessageId           OPTIONAL
    )
{

    return TRUE;
}


BOOL
TickProgressBar (
    VOID
    )
{
    return TRUE;
}


BOOL
TickProgressBarDelta (
    IN      UINT TickCount
    )
{
    return TRUE;
}

VOID
InitializeProgressBar (
    IN      HWND ProgressBar,
    IN      HWND Component,             OPTIONAL
    IN      HWND SubComponent,          OPTIONAL
    IN      BOOL *CancelFlagPtr         OPTIONAL
    )
{
    return;
}

VOID
TerminateProgressBar (
    VOID
    )
{
    return;
}

VOID
EndSliceProcessing (
    VOID
    )
{
    return;
}

UINT
RegisterProgressBarSlice (
    IN      UINT InitialEstimate
    )
{
    return 0;
}


VOID
ReviseSliceEstimate (
    IN      UINT SliceId,
    IN      UINT RevisedEstimate
    )
{
    return;
}


VOID
BeginSliceProcessing (
    IN      UINT SliceId
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\reged95\ansi\pch.h ===
#include "..\pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\reged95\unicode\pch.h ===
#include "..\pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\regrep\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\pipe\pipe.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    pipe.c

Abstract:

    Implements IPC pipe to support migisol.exe.

Author:

    Jim Schmidt (jimschm)   21-Sept-1998

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

static PCTSTR g_Mode;
static HANDLE g_ProcessHandle;
static BOOL g_Host;

VOID
pCloseIpcData (
    VOID
    );

BOOL
pOpenIpcData (
    VOID
    );

BOOL
pCreateIpcData (
    IN      PSECURITY_ATTRIBUTES psa
    );

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

VOID
pTestPipeMechanism (
    VOID
    );


BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        TEXT("  pipe/F:file]\n")

        TEXT("\nDescription:\n\n")

        TEXT("  PIPE is a test tool of the IPC mechanism for migration\n")
        TEXT("  DLLs.\n")

        TEXT("\nArguments:\n\n")

        TEXT("  (none)\n")

        );

    exit (1);
}


OUR_CRITICAL_SECTION g_cs;
CHAR g_Buf[2048];

VOID
Dump (
    PCSTR Str
    )
{
    EnterOurCriticalSection (&g_cs);

    printf ("%s\n", Str);

    LeaveOurCriticalSection (&g_cs);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg;

    InitializeOurCriticalSection (&g_cs);

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('f'):
                //
                // Sample option - /f:file
                //

                if (argv[i][2] == TEXT(':')) {
                    FileArg = &argv[i][3];
                } else if (i + 1 < argc) {
                    FileArg = argv[++i];
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            // None
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    pTestPipeMechanism();

    //
    // End of processing
    //

    Terminate();

    return 0;
}


BOOL
pOpenIpcA (
    IN      BOOL Win95Side,
    IN      PCSTR ExePath,                  OPTIONAL
    IN      PCSTR MigrationDllPath,         OPTIONAL
    IN      PCSTR WorkingDir                OPTIONAL
    )

/*++

Routine Description:

  OpenIpc has two modes of operation, depending on who the caller is.  If the
  caller is w95upg.dll or w95upgnt.dll, then the IPC mode is called "host mode."
  If the caller is migisol.exe, then the IPC mode is called "remote mode."

  In host mode, OpenIpc creates all of the objects necessary to implement
  the IPC.  This includes two events, DoCommand and GetResults, and a
  file mapping.  After creating the objects, the remote process is launched.

  In remote mode, OpenIpc opens the existing objects that have already
  been created.

Arguments:

  Win95Side - Used in host mode only.  Specifies that w95upg.dll is running
              when TRUE, or that w95upgnt.dll is running when FALSE.

  ExePath   - Specifies the command line for migisol.exe.  Specifies NULL
              to indicate remote mode.

  MigrationDllPath - Used in host mode only.  Specifies the migration DLL
                     path.  Ignored in remote mode.

  WorkingDir - Used in host mode only.  Specifies the working directory path
               for the migration DLL.  Ignored in remote mode.

Return value:

  TRUE if the IPC channel was opened.  If host mode, TRUE indicates that
  migisol.exe is up and running.  If remote mode, TRUE indicates that
  migisol is ready for commands.

--*/

{
    CHAR CmdLine[MAX_CMDLINE];
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    BOOL ProcessResult;
    HANDLE SyncEvent = NULL;
    HANDLE ObjectArray[2];
    DWORD rc;
    PSECURITY_DESCRIPTOR psd = NULL;
    SECURITY_ATTRIBUTES sa, *psa;
    BOOL Result = FALSE;

#ifdef DEBUG
    g_Mode = ExePath ? TEXT("host") : TEXT("remote");
#endif

    __try {

        g_ProcessHandle = NULL;

        g_Host = (ExePath != NULL);

        if (ISNT()) {
            //
            // Create nul DACL for NT
            //

            ZeroMemory (&sa, sizeof (sa));

            psd = (PSECURITY_DESCRIPTOR) MemAlloc (g_hHeap, 0, SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION)) {
                __leave;
            }

            if (!SetSecurityDescriptorDacl (psd, TRUE, (PACL) NULL, FALSE)) {
                 __leave;
            }

            sa.nLength = sizeof (sa);
            sa.lpSecurityDescriptor = psd;

            psa = &sa;

        } else {
            psa = NULL;
        }

        if (g_Host) {
            //
            // Create the IPC objects
            //

            if (!pCreateIpcData (psa)) {
                DEBUGMSG ((DBG_ERROR, "Cannot create IPC channel"));
                __leave;
            }

            g_ProcessHandle = CreateEvent (NULL, TRUE, TRUE, NULL);

        } else {        // !g_Host
            //
            // Open the IPC objects
            //

            if (!pOpenIpcData()) {
                DEBUGMSG ((DBG_ERROR, "Cannot open IPC channel"));
                __leave;
            }

            //
            // Set event notifying setup that we've created our mailslot
            //

            SyncEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE, TEXT("win9xupg"));
            SetEvent (SyncEvent);
        }

        Result = TRUE;
    }

    __finally {
        //
        // Cleanup code
        //

        PushError();

        if (!Result) {
            CloseIpc();
        }

        if (SyncEvent) {
            CloseHandle (SyncEvent);
        }

        if (psd) {
            MemFree (g_hHeap, 0, psd);
        }

        PopError();
    }

    return Result;

}








DWORD
WINAPI
pHostThread (
    PVOID Arg
    )
{
    CHAR Buf[2048];
    PBYTE Data;
    DWORD DataSize;
    DWORD ResultCode;
    DWORD LogId;
    DWORD LogId2;
    BOOL b;

    if (pOpenIpcA (FALSE, TEXT("*"), TEXT("*"), TEXT("*"))) {

        Dump ("Host: SendIpcCommand");

        StringCopyA (Buf, "This is a test command");
        b = SendIpcCommand (IPC_QUERY, Buf, SizeOfString (Buf));

        wsprintfA (g_Buf, "Host: b=%u  rc=%u", b, GetLastError());
        Dump (g_Buf);

        Dump ("Host: GetIpcCommandResults");

        b = GetIpcCommandResults (15000, &Data, &DataSize, &ResultCode, &LogId, &LogId2);

        wsprintfA (
            g_Buf,
            "Host: b=%u  rc=%u\n"
                "      Data=%s\n"
                "      DataSize=%u\n"
                "      ResultCode=%u\n"
                "      LogId=%u\n",
            b,
            GetLastError(),
            Data,
            DataSize,
            ResultCode,
            LogId
            );
        Dump (g_Buf);

    } else {
        Dump ("Host: CreateIpcData failed!");
    }

    return 0;
}


DWORD
WINAPI
pRemoteThread (
    PVOID Arg
    )
{
    CHAR Buf[2048];
    PBYTE Data;
    DWORD DataSize;
    DWORD Command;
    BOOL b;

    Sleep (1000);

    if (pOpenIpcA (FALSE, NULL, NULL, NULL)) {

        Dump ("Remote: GetIpcCommand");

        b = GetIpcCommand (15000, &Command, &Data, &DataSize);

        wsprintfA (
            g_Buf,
            "Remote: b=%u  rc=%u\n"
                "      Data=%s\n"
                "      DataSize=%u\n"
                "      Command=%u\n",
            b,
            GetLastError(),
            Data,
            DataSize,
            Command
            );
        Dump (g_Buf);

        Dump ("Remote: SendIpcCommandResults");

        StringCopyA (Buf, "Results are positive!");
        b = SendIpcCommandResults (ERROR_SUCCESS, 100, 0, Buf, SizeOfString (Buf));

        wsprintfA (g_Buf, "Remote: b=%u  rc=%u", b, GetLastError());
        Dump (g_Buf);

    } else {
        Dump ("Remote: OpenIpcData failed!");
    }

    return 0;
}


VOID
pTestPipeMechanism (
    VOID
    )
{
    HANDLE Threads[2];

    Threads[0] = StartThread (pHostThread, NULL);
    Threads[1] = StartThread (pRemoteThread, NULL);

    WaitForMultipleObjects (2, Threads, TRUE, INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\regdmp95\regdmp95.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    enumtree.c

Abstract:

    Performs a test of the file enumeration code.

Author:

    Jim Schmidt (jimschm)   14-Jan-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


VOID
DumpValue (
    PCTSTR ValName,
    PBYTE Val,
    UINT ValSize,
    DWORD Type
    );


VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "regdmp95 <win95path> <root> [-u:userpath] [-b]\n\n"
            "<win95path>    Specifies path to Win95 %%windir%%\n"
            "<root>         Specifies root key to enumerate\n"
            "-u             Specifies optional path to user.dat (excluding file name)\n"
            "-b             Force values to be displayed as binary\n"
            );

    exit(0);
}


BOOL
WINAPI
Win95Reg_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD dwReason,
    IN LPVOID lpv
    );

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved
    );

HANDLE g_hHeap;
HINSTANCE g_hInst;


INT
pCallMains (
    DWORD Reason
    )
{
    if (!MigUtil_Entry (g_hInst, Reason, NULL)) {
        _ftprintf (stderr, TEXT("MigUtil_Entry error!\n"));
        return 254;
    }

    if (!Win95Reg_Entry (g_hInst, Reason, NULL)) {
        _ftprintf (stderr, TEXT("Win95Reg_Entry error!\n"));
        return 254;
    }

    return 0;
}


INT
__cdecl
_tmain (
    INT argc,
    TCHAR *argv[]
    )
{
    PCTSTR Path = NULL, Root = NULL;
    PCTSTR UserPath = NULL;
    INT i;
    BOOL EnumFlag = TRUE;
    REGTREE_ENUM e;
    REGVALUE_ENUM ev;
    PBYTE Data;
    BOOL AllBinary = FALSE;

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('-') || argv[i][0] == TEXT('/')) {
            switch (tolower (argv[i][1])) {

            case TEXT('b'):
                AllBinary = TRUE;
                break;

            case TEXT('u'):
                if (UserPath) {
                    HelpAndExit();
                }

                if (argv[i][2] == TEXT(':')) {
                    UserPath = &argv[i][3];
                } else {
                    i++;
                    if (i == argc) {
                        HelpAndExit();
                    }

                    UserPath = argv[i];
                }
                break;

            default:
                HelpAndExit();
            }
        } else if (!Path) {
            Path = argv[i];
        } else if (!Root) {
            Root = argv[i];
        } else {
            HelpAndExit();
        }
    }

    if (!Root) {
        HelpAndExit();
    }

    //
    // Init migutil and win95reg
    //

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    pCallMains (DLL_PROCESS_ATTACH);

    //
    // Map in the Win95 registry
    //

    if (Win95RegInit (Path, TRUE) != ERROR_SUCCESS) {
        _ftprintf (stderr, TEXT("Can't map in Win98 registry at %s\n"), Path);
        EnumFlag = FALSE;
    } else {
        if (UserPath) {
            if (Win95RegSetCurrentUser (NULL, UserPath, NULL) != ERROR_SUCCESS) {
                _ftprintf (stderr, TEXT("Can't map in Win95 user hive path %s\n"), UserPath);
                EnumFlag = FALSE;
            }
        }
    }

    if (EnumFlag) {
        if (EnumFirstRegKeyInTree95 (&e, Root)) {

            do {

                _tprintf (TEXT("%s\n"), e.FullKeyName);

                //
                // Enumerate all values
                //

                if (EnumFirstRegValue95 (&ev, e.CurrentKey->KeyHandle)) {
                    do {
                        Data = GetRegValueData95 (ev.KeyHandle, ev.ValueName);
                        if (Data) {
                            DumpValue (
                                ev.ValueName,
                                Data,
                                ev.DataSize,
                                AllBinary ? REG_BINARY : ev.Type
                                );
                            MemFree (g_hHeap, 0, Data);
                        }
                    } while (EnumNextRegValue95 (&ev));
                }

            } while (EnumNextRegKeyInTree95 (&e));

        } else {
            _ftprintf (stderr, TEXT("%s not found\n"), Root);
        }
    }

    //
    // Terminate libs and exit
    //

    pCallMains (DLL_PROCESS_DETACH);

    return 0;
}


VOID
DumpValue (
    PCTSTR ValName,
    PBYTE Val,
    UINT ValSize,
    DWORD Type
    )
{
    PBYTE Array;
    UINT j, k, l;
    PCTSTR p;

    if (!ValName[0]) {
        if (!ValSize) {
            return;
        }
        ValName = TEXT("[Default Value]");
    }


    if (Type == REG_DWORD) {
        _tprintf (TEXT("    REG_DWORD     %s=%u (0%Xh)\n"), ValName, *((DWORD *) Val), *((DWORD *) Val));
    } else if (Type == REG_SZ) {
        _tprintf (TEXT("    REG_SZ        %s=%s\n"), ValName, Val);
    } else if (Type == REG_EXPAND_SZ) {
        _tprintf (TEXT("    REG_EXPAND_SZ %s=%s\n"), ValName, Val);
    } else if (Type == REG_MULTI_SZ) {
        _tprintf (TEXT("    REG_MULTI_SZ  %s:\n"), ValName);
        p = (PCTSTR) Val;
        while (*p) {
            _tprintf (TEXT("        %s\n"), p);
            p = GetEndOfString (p) + 1;
        }

        _tprintf (TEXT("\n"));
    } else if (Type == REG_LINK) {
        _tprintf (TEXT("    REG_LINK      %s=%s\n"), ValName, Val);
    } else {
        if (Type == REG_NONE) {
            _tprintf (TEXT("    REG_NONE      %s"), ValName);
        } else if (Type == REG_BINARY) {
            _tprintf (TEXT("    REG_NONE      %s"), ValName);
        } else {
            _tprintf (TEXT("    Unknown reg type %s"), ValName);
        }

        _tprintf (TEXT(" (%u byte%s)\n"), ValSize, ValSize == 1 ? "" : "s");

        Array = Val;

        for (j = 0 ; j < ValSize ; j += 16) {
            _tprintf(TEXT("        %04X "), j);

            l = min (j + 16, ValSize);
            for (k = j ; k < l ; k++) {
                _tprintf (TEXT("%02X "), Array[k]);
            }

            for ( ; k < j + 16 ; k++) {
                _tprintf (TEXT("   "));
            }

            for (k = j ; k < l ; k++) {
                _tprintf (TEXT("%c"), isprint(Array[k]) ? Array[k] : TEXT('.'));
            }

            _tprintf (TEXT("\n"));
        }

        _tprintf (TEXT("\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\report\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\report\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\regdump\regdump.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    enumtree.c

Abstract:

    Performs a test of the file enumeration code.

Author:

    Jim Schmidt (jimschm)   14-Jan-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


VOID
DumpValue (
    PCTSTR ValName,
    PBYTE Val,
    UINT ValSize,
    DWORD Type
    );


VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "regdump <root> [-b]\n\n"
            "<root>         Specifies root key to enumerate, such as HKCU\\Control Panel\n"
            "-b             Forces keys to be dumped as binary values\n"
            );

    exit(0);
}


BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved
    );

HANDLE g_hHeap;
HINSTANCE g_hInst;


INT
pCallMains (
    DWORD Reason
    )
{
    if (!MigUtil_Entry (g_hInst, Reason, NULL)) {
        _ftprintf (stderr, TEXT("MigUtil_Entry error!\n"));
        return 254;
    }

    return 0;
}


INT
__cdecl
_tmain (
    INT argc,
    TCHAR *argv[]
    )
{
    PCTSTR Root = NULL;
    INT i;
    REGTREE_ENUM e;
    REGVALUE_ENUM ev;
    PBYTE Data;
    BOOL AllBinary = FALSE;

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('-') || argv[i][0] == TEXT('/')) {
            switch (tolower (argv[i][1])) {
            case TEXT('b'):
                if (AllBinary) {
                    HelpAndExit();
                }

                AllBinary = TRUE;
                break;

            default:
                HelpAndExit();
            }
        } else if (!Root) {
            Root = argv[i];
        } else {
            HelpAndExit();
        }
    }

    if (!Root) {
        HelpAndExit();
    }

    //
    // Init migutil
    //

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    pCallMains (DLL_PROCESS_ATTACH);

    //
    // Enumerate via reg wrappers
    //

    if (EnumFirstRegKeyInTree (&e, Root)) {

        do {

            _tprintf (TEXT("%s\n"), e.FullKeyName);

            //
            // Enumerate all values
            //

            if (EnumFirstRegValue (&ev, e.CurrentKey->KeyHandle)) {
                do {
                    Data = GetRegValueData (ev.KeyHandle, ev.ValueName);
                    if (Data) {
                        DumpValue (
                            ev.ValueName,
                            Data,
                            ev.DataSize,
                            AllBinary ? REG_BINARY : ev.Type
                            );

                        MemFree (g_hHeap, 0, Data);
                    }
                } while (EnumNextRegValue (&ev));
            }

        } while (EnumNextRegKeyInTree (&e));

    } else {
        _ftprintf (stderr, TEXT("%s not found\n"), Root);
    }

    //
    // Terminate libs and exit
    //

    pCallMains (DLL_PROCESS_DETACH);

    return 0;
}


VOID
DumpValue (
    PCTSTR ValName,
    PBYTE Val,
    UINT ValSize,
    DWORD Type
    )
{
    PBYTE Array;
    UINT j, k, l;
    PCTSTR p;

    if (!ValName[0]) {
        if (!ValSize) {
            return;
        }
        ValName = TEXT("[Default Value]");
    }


    if (Type == REG_DWORD) {
        _tprintf (TEXT("    REG_DWORD     %s=%u (0%Xh)\n"), ValName, *((DWORD *) Val), *((DWORD *) Val));
    } else if (Type == REG_SZ) {
        _tprintf (TEXT("    REG_SZ        %s=%s\n"), ValName, Val);
    } else if (Type == REG_EXPAND_SZ) {
        _tprintf (TEXT("    REG_EXPAND_SZ %s=%s\n"), ValName, Val);
    } else if (Type == REG_MULTI_SZ) {
        _tprintf (TEXT("    REG_MULTI_SZ  %s:\n"), ValName);
        p = (PCTSTR) Val;
        while (*p) {
            _tprintf (TEXT("        %s\n"), p);
            p = GetEndOfString (p) + 1;
        }

        _tprintf (TEXT("\n"));
    } else if (Type == REG_LINK) {
        _tprintf (TEXT("    REG_LINK      %s=%s\n"), ValName, Val);
    } else {
        if (Type == REG_NONE) {
            _tprintf (TEXT("    REG_NONE      %s"), ValName);
        } else if (Type == REG_BINARY) {
            _tprintf (TEXT("    REG_NONE      %s"), ValName);
        } else {
            _tprintf (TEXT("    Unknown reg type %s"), ValName);
        }

        _tprintf (TEXT(" (%u byte%s)\n"), ValSize, ValSize == 1 ? "" : "s");

        Array = Val;

        for (j = 0 ; j < ValSize ; j += 16) {
            _tprintf(TEXT("        %04X "), j);

            l = min (j + 16, ValSize);
            for (k = j ; k < l ; k++) {
                _tprintf (TEXT("%02X "), Array[k]);
            }

            for ( ; k < j + 16 ; k++) {
                _tprintf (TEXT("   "));
            }

            for (k = j ; k < l ; k++) {
                _tprintf (TEXT("%c"), isprint(Array[k]) ? Array[k] : TEXT('.'));
            }

            _tprintf (TEXT("\n"));
        }

        _tprintf (TEXT("\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\rasdump\rasdump.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    w9xtool.c

Abstract:

    Implements a stub tool that is designed to run with Win9x-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

typedef struct _IPData   {
    DWORD     dwSize;
    DWORD     fdwTCPIP;
    DWORD     dwIPAddr;
    DWORD     dwDNSAddr;
    DWORD     dwDNSAddrAlt;
    DWORD     dwWINSAddr;
    DWORD     dwWINSAddrAlt;
}   IPDATA, *PIPDATA;

typedef struct  _AddrEntry     {
    DWORD       dwVersion;
    DWORD       dwCountryCode;
    UINT        uOffArea;
    UINT        uOffPhone;
    DWORD       dwCountryID;
    UINT        uOffSMMCfg;
    UINT        uOffSMM;
    UINT        uOffDI;
}   ADDRENTRY, *PADDRENTRY;


typedef struct _SubConnEntry {
    DWORD       dwSize;
    DWORD       dwFlags;
    char        szDeviceType[RAS_MaxDeviceType+1];
    char        szDeviceName[RAS_MaxDeviceName+1];
    char        szLocal[RAS_MaxPhoneNumber+1];
}   SUBCONNENTRY, *PSUBCONNENTRY;


typedef struct  _DEVICEINFO  {
    DWORD       dwVersion;
    UINT        uSize;
    char        szDeviceName[RAS_MaxDeviceName+1];
    char        szDeviceType[RAS_MaxDeviceType+1];
}   DEVICEINFO, *PDEVICEINFO;


typedef struct  _SMMCFG  {
    DWORD       dwSize;
    DWORD       fdwOptions;
    DWORD       fdwProtocols;
}   SMMCFG, *PSMMCFG;

typedef struct {
    DWORD Size;
    DWORD Unknown1;
    DWORD ModemUiOptions; // num seconds in high byte.
    DWORD Unknown2;
    DWORD Unknown3;
    DWORD Unknown4;
    DWORD ConnectionSpeed;
    DWORD UnknownFlowControlData; //Somehow related to flow control.
    DWORD Unknown5;
    DWORD Unknown6;
    DWORD Unknown7;
    DWORD Unknown8;
    DWORD Unknown9;
    DWORD Unknown10;
    DWORD Unknown11;
    DWORD Unknown12;
    DWORD Unknown13;
    DWORD Unknown14;
    DWORD Unknown15;
    DWORD CancelSeconds; //Num seconds to wait before cancel if not connected. (0xFF equals off.)
    DWORD IdleDisconnectSeconds; // 0 = Not Set.
    DWORD Unknown16;
    DWORD SpeakerVolume; // 0|1
    DWORD ConfigOptions;
    DWORD Unknown17;
    DWORD Unknown18;
    DWORD Unknown19;
} MODEMDEVINFO, *PMODEMDEVINFO;

#define RAS_UI_FLAG_TERMBEFOREDIAL      0x1
#define RAS_UI_FLAG_TERMAFTERDIAL       0x2
#define RAS_UI_FLAG_OPERATORASSISTED    0x4
#define RAS_UI_FLAG_MODEMSTATUS         0x8

#define RAS_CFG_FLAG_HARDWARE_FLOW_CONTROL  0x00000010
#define RAS_CFG_FLAG_SOFTWARE_FLOW_CONTROL  0x00000020
#define RAS_CFG_FLAG_STANDARD_EMULATION     0x00000040
#define RAS_CFG_FLAG_COMPRESS_DATA          0x00000001
#define RAS_CFG_FLAG_USE_ERROR_CONTROL      0x00000002
#define RAS_CFG_FLAG_ERROR_CONTROL_REQUIRED 0x00000004
#define RAS_CFG_FLAG_USE_CELLULAR_PROTOCOL  0x00000008
#define RAS_CFG_FLAG_NO_WAIT_FOR_DIALTONE   0x00000200


PCTSTR g_User = NULL;
PCTSTR g_Setting = NULL;
PCTSTR g_Entry = NULL;
BOOL   g_ShowBinary = FALSE;



#define S_REMOTE_ACCESS_KEY TEXT("RemoteAccess")
#define S_PROFILE_KEY       TEXT("RemoteAccess\\Profile")
#define S_ADDRESSES_KEY     TEXT("RemoteAccess\\Addresses")
#define S_DIALUI            TEXT("DialUI")
#define S_ENABLE_REDIAL     TEXT("EnableRedial")
#define S_REDIAL_WAIT       TEXT("RedialWait")
#define S_REDIAL_TRY        TEXT("RedialTry")
#define S_ENABLE_IMPLICIT   TEXT("EnableImplicit")
#define S_TERMINAL          TEXT("Terminal")
#define S_MODE              TEXT("Mode")
#define S_MULTILINK         TEXT("MultiLink")

#define DIALUI_DONT_PROMPT_FOR_INFO         0x01
#define DIALUI_DONT_SHOW_CONFIRM_DIALOG     0x02
#define DIALUI_DONT_SHOW_ICON               0x04

#define SMMCFG_TCPIP_PROTOCOL               0x04
#define SMMCFG_NETBEUI_PROTOCOL             0x01
#define SMMCFG_IPXSPX_PROTOCOL              0x02


#define PAESMMCFG(pAE) ((PSMMCFG)(((PBYTE)pAE)+(pAE->uOffSMMCfg)))
#define PAESMM(pAE) ((PSTR)(((PBYTE)pAE)+(pAE->uOffSMM)))
#define PAEDI(pAE) ((PDEVICEINFO)(((PBYTE)pAE)+(pAE->uOffDI    )))
#define PAEAREA(pAE)    ((PSTR)(((PBYTE)pAE)+(pAE->uOffArea)))
#define PAEPHONE(pAE)   ((PSTR)(((PBYTE)pAE)+(pAE->uOffPhone)))
#define DECRYPTENTRY(x, y, z)   EnDecryptEntry(x, (LPBYTE)y, z)



static BYTE NEAR PASCAL GenerateEncryptKey (LPSTR szKey)
{
    BYTE   bKey;
    LPBYTE lpKey;

    for (bKey = 0, lpKey = (LPBYTE)szKey; *lpKey != 0; lpKey++)
    {
        bKey += *lpKey;
    };

    return bKey;
}


DWORD NEAR PASCAL EnDecryptEntry (LPSTR szEntry, LPBYTE lpEnt,
                                  DWORD cb);


VOID
pDumpPerUserSettings (
    IN HKEY   UserKey
    )
{
    HKEY    settingsKey;
    PDWORD  data;

    printf("\n*** Ras Per User Setting Information ***\n");


    settingsKey = OpenRegKey(UserKey,S_REMOTE_ACCESS_KEY);


    if (settingsKey) {

        //
        // Get UI settings.
        //
        data = (PDWORD) GetRegValueBinary(settingsKey,S_DIALUI);

        printf("\n\t** Dialup UI Information **\n");

        if (data) {



            printf("\t\t%sprompt for information before dialing.\n",
                DIALUI_DONT_PROMPT_FOR_INFO & *data ? "Don't " :""
                );
            printf("\t\t%sshow confirmation dialog after connected.\n",
                DIALUI_DONT_SHOW_CONFIRM_DIALOG & *data ? "Don't ":""
                );
            printf("\t\t%sshow an icon on the taskbar after connected.\n",
                DIALUI_DONT_SHOW_ICON & *data ? "Don't ":""
                );


            MemFree(g_hHeap,0,data);
        }
        else {
            printf("\t\tNo user UI Settings found..\n");
        }



        //
        // Get Redial information.
        //

        printf("\n\t** Redialing Information **\n");
        data = (PDWORD) GetRegValueBinary(settingsKey,S_ENABLE_REDIAL);

        if (data) {

            printf("\t\tRedialing %s.\n",*data ? "Enabled." : "Disabled.");

            MemFree(g_hHeap,0,data);
        }
        else {
            printf("\t\tNo Redial information found.\n");
        }

        data = (PDWORD) GetRegValueBinary(settingsKey,S_REDIAL_TRY);

        if (data) {

            printf("\t\tNumber of redial tries: %u.\n", *data);

            MemFree(g_hHeap,0,data);

        }

        data = (PDWORD) GetRegValueBinary(settingsKey,S_REDIAL_WAIT);

        if (data) {

            printf("\t\tRedial time in seconds: %u\n", HIWORD(*data) * 60 + LOWORD(*data));


            MemFree(g_hHeap,0,data);
        }

        //
        // Get implicit connection information.
        //
        data = (PDWORD) GetRegValueBinary(settingsKey,S_ENABLE_IMPLICIT);

        if (data) {

            printf("\n\t%sprompt with dial-up networking to establish connection.\n",
                *data ? "" : "Don't "
                );


            MemFree(g_hHeap,0,data);
        }

        CloseRegKey(settingsKey);
    }

    printf("\n***\n");

}


PTSTR
pIpAddressAsString(
    DWORD dwAddress
    )
{
  BYTE bAddress[4];
  static TCHAR address[30];

  *((LPDWORD)bAddress) = dwAddress;
  sprintf(address,"%d.%d.%d.%d", bAddress[0], bAddress[1], bAddress[2],bAddress[3]);

  return address;
}

VOID
pDumpBinaryData(
    IN PBYTE Data,
    IN UINT  Size
    )
{

    UINT i,j;

    TCHAR hexArray[40];
    TCHAR strArray[20];
    TCHAR buf[20];

    printf("\n\t\tBinary Dump...\n");

    for (j = 0;j<Size + Size % 8;j +=8) {

        *hexArray = 0;
        *strArray = 0;

        for (i = 0;i < 8;i++) {
            sprintf(buf," %02x",i + j < Size ? Data[i+j] : 0x00);
            _tcscat(hexArray,buf);
            sprintf(buf," %c",isprint(Data[i+j]) && i + j < Size ? Data[i+j] : TEXT('.'));
            _tcscat(strArray,buf);
        }

        printf("\n\t\t%s\t%s",hexArray,strArray);
    }

    printf("\n\n");
}


VOID
pDumpIpInformation (
    IN PIPDATA IpData
    )
{

    printf("\t\t<IPINFO> fTcpIp = %u\n",IpData -> fdwTCPIP);
    printf("\t\t<IPINFO> IP Address = %s\n",pIpAddressAsString(IpData -> dwIPAddr));
    printf("\t\t<IPINFO> DNS Address = %s\n",pIpAddressAsString(IpData -> dwDNSAddr));
    printf("\t\t<IPINFO> Alternate DNS Address = %s\n",pIpAddressAsString(IpData -> dwDNSAddrAlt));
    printf("\t\t<IPINFO> WINS Address = %s\n",pIpAddressAsString(IpData -> dwWINSAddr));
    printf("\t\t<IPINFO> Alternate WINS Address = %s\n",pIpAddressAsString(IpData -> dwWINSAddrAlt));


}

VOID
pDumpConnectionSettings (
    IN HANDLE Key,
    IN PCTSTR Name
    )
{

    REGVALUE_ENUM e;
    PBYTE         curData;

    printf("\n\t** %s Setting.. **\n",Name);

    if (EnumFirstRegValue(&e,Key)) {

        do {

            //
            // Get the data for this entry.
            //
            curData = GetRegValueData(Key,e.ValueName);

            if (curData) {

                if (!g_Setting || StringIMatch(g_Setting,e.ValueName)) {

                    switch (e.Type) {

                    case REG_SZ:
                    case REG_MULTI_SZ:
                    case REG_EXPAND_SZ:

                        printf("\t\t<STRING DATA> %s = %s\n",e.ValueName,(PCTSTR) curData);
                        break;
                    case REG_DWORD:
                        printf("\t\t<DWORD DATA> %s = %u\n",e.ValueName,*((PDWORD) curData));
                        break;
                    case REG_BINARY:
                        if (StringIMatch(S_IPINFO,e.ValueName)) {

                            pDumpIpInformation((PIPDATA) curData);

                        }
                        else if (StringIMatch(S_TERMINAL,e.ValueName)) {

                            PWINDOWPLACEMENT wp = (PWINDOWPLACEMENT) curData;
                            PCTSTR           showStr = NULL;

                            switch(wp -> showCmd) {
                                case SW_HIDE:
                                    showStr = "SW_HIDE";
                                    break;
                                case SW_MINIMIZE:
                                    showStr = "SW_MINIMIZE";
                                    break;
                                case SW_RESTORE:
                                    showStr = "SW_RESTORE";
                                    break;
                                case SW_SHOW:
                                    showStr = "SW_SHOW";
                                    break;
                                case SW_SHOWMAXIMIZED:
                                    showStr = "SW_SHOWMAXIMIZED";
                                    break;
                                case SW_SHOWMINIMIZED:
                                    showStr = "SW_SHOWMINIMIZED";
                                    break;
                                case SW_SHOWMINNOACTIVE:
                                    showStr = "SW_SHOWMINNOACTIVE";
                                    break;
                                case SW_SHOWNA:
                                    showStr = "SW_SHOWNA";
                                    break;
                                case SW_SHOWNOACTIVATE:
                                    showStr = "SW_SHOWNOACTIVATE";
                                    break;
                                case SW_SHOWNORMAL:
                                    showStr = "SW_SHOWNORMAL";
                                    break;
                                default:
                                    showStr = "Unknown SHOW FLAG!";
                                    break;
                            }


                            printf("\t\tTerminal Window Show Flag: %s\n", showStr);



                        } else if (StringIMatch(S_MODE,e.ValueName)) {

                            if (*curData) {
                                printf("\t\tStep through script. (Testing Mode..)\n");
                            }
                            else {
                                printf("\t\tScript should be run in normal mode.\n");
                            }


                        } else if (StringIMatch(S_MULTILINK,e.ValueName)) {

                            printf("\t\tMultilink is %s.\n",*curData ? "ENABLED" : "DISABLED");


                        } else {

                            printf("\t\t<!!UNKNOWN BINARY DATA!!> %s = <BINARY BLOB>\n",e.ValueName);
                        }

                        if (g_ShowBinary) {
                            pDumpBinaryData(curData,e.DataSize);
                        }


                        break;
                     default:
                        printf("\t\t<UNKNOWN DATA TYPE> %s = <UNKNOWN DATA TYPE>\n",e.ValueName);
                        break;
                    }
                }

                MemFree(g_hHeap,0,curData);
            }

        } while (EnumNextRegValue(&e));
    }
}

VOID
pDumpDevInfo (
    IN PDEVICEINFO Info
    )
{
    UINT size;
    UINT i;
    PMODEMDEVINFO caps;

    printf ("** Device Info: \n"
            "\t\tVersion: %u \n"
            "\t\tSize: %u\n"
            "\t\tDevice Name: %s\n"
            "\t\tDevice Type: %s\n",
            Info->dwVersion,
            Info->uSize,
            Info->szDeviceName,
            Info->szDeviceType
            );


    size = Info->uSize - ((PBYTE) (Info->szDeviceType + RAS_MaxDeviceType + 1) - (PBYTE) Info);

    caps = (PMODEMDEVINFO) (Info->szDeviceType + RAS_MaxDeviceType + 3);
#if 0
    pDumpBinaryData ((PBYTE) caps, sizeof (REGDEVCAPS));


    printf ("As Dwords..\n");

    for (i = 0; i < 27; i++) {
        printf ("Dword %u = %u (%x)\n",i, caps->foo[i], caps->foo[i]);
    }
#endif

    printf (
        "\tCaps Size: %u\n"
        "\tStart Term Before Redial? %s\n"
        "\tStart Term After  Redial? %s\n"
        "\tOperator Assited Dial? %s\n"
        "\tShow Modem Status? %s\n"
        "\tUI Options: %u (%x)\n"
        "\tConnection Speed: %u\n"
        "\tCancel if not connected within %u seconds.\n"
        "\tDisconnect if Idle for %u seconds.\n"
        "\tSpeaker %s.\n"
        "\tHardware Flow Control? %s\n"
        "\tSoftware Flow Control? %s\n"
        "\tStandard Emulation? %s\n"
        "\tCompress Data? %s\n"
        "\tUse Error Control? %s\n"
        "\tError Control Required? %s\n"
        "\tUse Cellular  Protocol? %s\n"
        "\tWait for Dialtone? %s\n"
        "\tConfig Options: %u (%x)\n",
        caps->Size,
        caps->ModemUiOptions & RAS_UI_FLAG_TERMBEFOREDIAL ? "Yes" : "No",
        caps->ModemUiOptions & RAS_UI_FLAG_TERMAFTERDIAL ? "Yes" : "No",
        caps->ModemUiOptions & RAS_UI_FLAG_OPERATORASSISTED ? "Yes" : "No",
        caps->ModemUiOptions & RAS_UI_FLAG_MODEMSTATUS ? "Yes" : "No",
        caps->ModemUiOptions,
        caps->ModemUiOptions,
        caps->ConnectionSpeed,
        caps->CancelSeconds,
        caps->IdleDisconnectSeconds,
        caps->SpeakerVolume ? "Yes" : "No",
        caps->ConfigOptions & RAS_CFG_FLAG_HARDWARE_FLOW_CONTROL ? "Yes" : "No",
        caps->ConfigOptions & RAS_CFG_FLAG_SOFTWARE_FLOW_CONTROL ? "Yes" : "No",
        caps->ConfigOptions & RAS_CFG_FLAG_STANDARD_EMULATION ? "Yes" : "No",
        caps->ConfigOptions & RAS_CFG_FLAG_COMPRESS_DATA ? "Yes" : "No",
        caps->ConfigOptions & RAS_CFG_FLAG_USE_ERROR_CONTROL ? "Yes" : "No",
        caps->ConfigOptions & RAS_CFG_FLAG_ERROR_CONTROL_REQUIRED ? "Yes" : "No",
        caps->ConfigOptions & RAS_CFG_FLAG_USE_CELLULAR_PROTOCOL ? "Yes" : "No",
        caps->ConfigOptions & RAS_CFG_FLAG_NO_WAIT_FOR_DIALTONE ? "No" : "Yes",
        caps->ConfigOptions,
        caps->ConfigOptions
        );
}


VOID
pDumpAddressInfo (
    IN HKEY AddressKey,
    IN PCTSTR SubKeyName
    )
{

    PBYTE           data = NULL;
    UINT            count = 0;
    UINT            type  = 0;
    PADDRENTRY      entry;
    PSMMCFG         smmCfg;
    PDEVICEINFO     devInfo;
    UINT            sequencer = 0;
    HKEY            subEntriesKey;
    PTSTR           subEntriesKeyStr;
    REGVALUE_ENUM   eSubEntries;
    PSUBCONNENTRY   subEntry;

    if (RegQueryValueEx(AddressKey, SubKeyName, NULL, &type, NULL, &count) == ERROR_SUCCESS) {

        data = MemAlloc(g_hHeap,0,count);
        if (data) {

            if (RegQueryValueEx(AddressKey, SubKeyName, NULL, &type, (LPBYTE)data,&count) == ERROR_SUCCESS) {

                entry   = (PADDRENTRY) data;

                DECRYPTENTRY((PTSTR)SubKeyName, entry, count);

                smmCfg  = PAESMMCFG(entry);
                devInfo = PAEDI(entry);

                pDumpDevInfo (devInfo);

                if (!g_Setting || StringMatch(g_Setting,"AddressData")) {

                    printf("\t\t<AddressData> Phone Number = %s\n",PAEPHONE(entry));
                    printf("\t\t<AddressData> Area Code    = %s\n",PAEAREA(entry));
                    printf("\t\t<AddressData> SMM          = %s\n",PAESMM(entry));
                    printf("\t\t<AddressData> Country Code = %u\n",entry -> dwCountryCode);
                    printf("\t\t<AddressData> Country Id   = %u\n",entry -> dwCountryID);

                    printf("\t\t<Device Info> DeviceName   = %s\n",devInfo -> szDeviceName);
                    printf("\t\t<Device Info> DeviceType   = %s\n",devInfo -> szDeviceType);
                    printf("\t\t<SMM Cfg>     Options      = %u\n",smmCfg  -> fdwOptions);
                    printf("\t\t<SMM Cfg>     TCPIP is %s.\n",
                        smmCfg -> fdwProtocols & SMMCFG_TCPIP_PROTOCOL ? "ENABLED" : "DISABLED");
                    printf("\t\t<SMM Cfg>     NETBEUI is %s.\n",
                        smmCfg -> fdwProtocols & SMMCFG_NETBEUI_PROTOCOL ? "ENABLED" : "DISABLED");
                    printf("\t\t<SMM Cfg>     IPX/SPX is %s.\n",
                        smmCfg -> fdwProtocols & SMMCFG_IPXSPX_PROTOCOL ? "ENABLED" : "DISABLED");



                    if (g_ShowBinary) {
                        pDumpBinaryData((PBYTE) entry,count);
                    }
                }

            }

            MemFree(g_hHeap,0,data);

            subEntriesKeyStr = JoinPaths ("SubEntries", SubKeyName);
            subEntriesKey = OpenRegKey (AddressKey, subEntriesKeyStr);
            FreePathString (subEntriesKeyStr);
            sequencer = 0;

            if (subEntriesKey) {

                if (EnumFirstRegValue (&eSubEntries, subEntriesKey)) {

                    do {

                        data = GetRegValueBinary (subEntriesKey, eSubEntries.ValueName);

                        if (data) {

                            subEntry = (PSUBCONNENTRY) data;
                            DECRYPTENTRY ((PTSTR) SubKeyName, subEntry, eSubEntries.DataSize);

                            printf ("\tSub Entry Device Type: %s\n", subEntry->szDeviceType);
                            printf ("\tSub Entry Device Name: %s\n", subEntry->szDeviceName);
                            printf ("\tSub Entry Phone Number: %s\n", subEntry->szDeviceName);
                            printf ("\tSub Entry Flags: %u (%x)\n", subEntry->dwFlags);
                            printf ("\tSub Entry Size: %u\n", subEntry->dwSize);

                            pDumpBinaryData ((PBYTE) subEntry, subEntry->dwSize);

                            MemFree (g_hHeap, 0, data);
                        }

                        sequencer++;

                    } while (EnumNextRegValue (&eSubEntries));
                }

                CloseRegKey (subEntriesKey);
            }
        }
    }
}



VOID
pDumpPerConnectionSettings (
    IN HKEY UserKey
    )
{

    REGKEY_ENUM e;
    HKEY        profileKey;
    HKEY        entryKey        = NULL;
    HKEY        addressKey      = NULL;


    printf("\n*** Ras Per Connection Setting Information ***\n");


    profileKey = OpenRegKey (UserKey,S_PROFILE_KEY);
    addressKey = OpenRegKey (UserKey,S_ADDRESSES_KEY);

    if (profileKey && addressKey) {

        if (EnumFirstRegKey(&e,addressKey)) {
            do {

                if (!g_Entry || StringIMatch(g_Entry,e.SubKeyName)) {

                    pDumpAddressInfo(addressKey,e.SubKeyName);
                    entryKey = OpenRegKey(profileKey,e.SubKeyName);

                    if (entryKey ) {

                        pDumpConnectionSettings (entryKey, e.SubKeyName);
                        CloseRegKey(entryKey);
                    }

                }

            } while (EnumNextRegKey(&e));
        }

    }

    CloseRegKey(addressKey);
    CloseRegKey(profileKey);

    printf("\n***\n");
}


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    return InitToolMode (hInstance);
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    TerminateToolMode (hInstance);
}



VOID
pShowHelp (
    VOID
    )
{
    printf("\nUsage: RasDump [-h?b] [-u:<UserName>] [-e:<EntryName>] [-s:<SettingName>]\n"
           "\n\t\t -h - Display this message."
           "\n\t\t -? - Display this message."
           "\n\t\t -u - Dump information for user <UserName>."
           "\n\t\t -b - Dump raw binary data."
           "\n\t\t -e - Dump Entry infor for DialUp Connection <EntryName>.\n");


    exit(0);
}


VOID
pProcessCommandLine (
    UINT argc,
    PTSTR * argv
    )
{


    UINT i;
    PTSTR p;

    for (i = 1;i < argc; i++) {

        p = argv[i];

        if (*p != TEXT('-') && *p != TEXT('/')) {
            pShowHelp();

        }

        p++;

        switch(tolower(*p)) {


        case TEXT('u'):
            if (*++p != ':') {
                pShowHelp();
            }
            g_User = ++p;
            break;

        case TEXT('s'):
            if (*++p != ':') {
                pShowHelp();
            }
            g_Setting = ++p;
            break;


        case TEXT('h'): case TEXT('?'):
            pShowHelp();
            break;


        case TEXT('e'):
            if (*++p != ':') {
                pShowHelp();
            }
            g_Entry = ++p;
            break;

        case TEXT('b') :
            g_ShowBinary = TRUE;
            break;

        default:
            pShowHelp();
            break;
        }
    }
}


INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    USERENUM e;
    TCHAR    buf[MEMDB_MAX];




    if (!Init()) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    //
    // needed by enumuser..
    //

    GetWindowsDirectory(buf,MAX_PATH);
    g_WinDir = buf;
    Win95RegInit(g_WinDir,NULL);

    pProcessCommandLine(argc,argv);


    if (EnumFirstUser (&e, ENUMUSER_ENABLE_NAME_FIX)) {

        do {

            if (!g_User || StringIMatch(g_User,e.UserName)) {
                printf("Dumping ras settings for user %s..\n",*e.UserName ? e.UserName : "<Default>");
                __try {
                pDumpPerUserSettings(e.UserRegKey);
                pDumpPerConnectionSettings(e.UserRegKey);
                }
                except (1) {
                    printf("Caught an exception..");
                }
            }

        } while (EnumNextUser(&e));
    }


    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\sfspace\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\sharegen\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\sharegen\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\regdmp95\regdump.c ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>

void DumpKeyRecursive (HKEY hKey, LPCSTR RootName);

void main (int argc, char *argv[])
{
    HKEY hKeyRoot, hKey;
    LPCSTR Arg;
    DWORD rc;

    if (argc != 2 || (argv[1][0] == '-' || argv[1][0] == '/')) {
        printf ("Usage:\n\nregdump <rootkey>\n");
        return;
    }

    Arg = argv[1];

    if (!strnicmp (Arg, "HKLM\\", 5)) {
        hKeyRoot = HKEY_LOCAL_MACHINE;
        Arg += 5;
    } else if (!strnicmp (Arg, "HKCU\\", 5)) {
        hKeyRoot = HKEY_CURRENT_USER;
        Arg += 5;
    } else if (!strnicmp (Arg, "HKU\\", 4)) {
        hKeyRoot = HKEY_USERS;
        Arg += 4;
    } else if (!strnicmp (Arg, "HKCC\\", 5)) {
        hKeyRoot = HKEY_CURRENT_CONFIG;
        Arg += 5;
    } else if (!strnicmp (Arg, "HKCR\\", 5)) {
        hKeyRoot = HKEY_CLASSES_ROOT;
        Arg += 5;
    } else if (!strnicmp (Arg, "HKEY_LOCAL_MACHINE\\", 19)) {
        hKeyRoot = HKEY_LOCAL_MACHINE;
        Arg += 19;
    } else if (!strnicmp (Arg, "HKEY_CURRENT_USER\\", 18)) {
        hKeyRoot = HKEY_CURRENT_USER;
        Arg += 18;
    } else if (!strnicmp (Arg, "HKEY_USERS\\", 11)) {
        hKeyRoot = HKEY_USERS;
        Arg += 11;
    } else if (!strnicmp (Arg, "HKEY_CURRENT_CONFIG\\", 20)) {
        hKeyRoot = HKEY_CURRENT_CONFIG;
        Arg += 20;
    } else if (!strnicmp (Arg, "HKEY_CLASSES_ROOT\\", 18)) {
        hKeyRoot = HKEY_CLASSES_ROOT;
        Arg += 18;
    } else {
        printf ("Please specify registry root.\n");
        return;
    }

    rc = RegOpenKeyEx (hKeyRoot, Arg, 0, KEY_READ, &hKey);
    if (rc != ERROR_SUCCESS) {
        printf ("RegOpenKeyEx failed with error %u for %s\n", rc, Arg);
        return;
    }

    DumpKeyRecursive (hKey, Arg);

    RegCloseKey (hKey);
}


void DumpKeyRecursive (HKEY hKey, LPCSTR RootName)
{
    DWORD ClassSize;
    CHAR Class[256];
    DWORD SubKeyCount;
    DWORD MaxSubKeyLen;
    DWORD MaxClassLen;
    DWORD ValCount;
    DWORD MaxValLen;
    DWORD MaxValNameLen;
    FILETIME LastWriteTime;
    DWORD i;
    HKEY hSubKey;
    DWORD rc;
    CHAR SubKeyName[256];
    CHAR SubKeyPath[MAX_PATH];
    static DWORD ValNameSize;
    static DWORD Type;
    static DWORD ValSize;
    static CHAR ValName[MAX_PATH];
    static CHAR Val[16384];
    static LPCSTR p;
    static DWORD j, k, l;
    static LPBYTE Array;

    ClassSize = sizeof (Class);
    rc = RegQueryInfoKey (hKey,
                          Class,
                          &ClassSize,
                          NULL,
                          &SubKeyCount,
                          &MaxSubKeyLen,
                          &MaxClassLen,
                          &ValCount,
                          &MaxValNameLen,
                          &MaxValLen,
                          NULL,
                          &LastWriteTime
                          );

    if (rc != ERROR_SUCCESS) {
        printf ("RegQueryInfoKey failed with error %u for %s\n", rc, RootName);
        return;
    }

    //
    // Print root name
    //

    printf ("%s\n", RootName);

    //
    // Dump values
    //

    for (i = 0 ; i < ValCount ; i++) {
        ValNameSize = sizeof (ValName);
        ValSize = sizeof (Val);
        rc = RegEnumValue (hKey, i, ValName, &ValNameSize, NULL, &Type, (LPBYTE) Val, &ValSize);
        if (rc != ERROR_SUCCESS) {
            printf ("RegEnumValue failed with error %u for value %u\n\n", rc, i);
            return;
        }

        if (!ValName[0]) {
            if (!ValSize) {
                continue;
            }
            strcpy (ValName, "[Default Value]");
        }


        if (Type == REG_DWORD) {
            printf ("    REG_DWORD     %s=%u (0%Xh)\n", ValName, *((DWORD *) Val), *((DWORD *) Val));
        } else if (Type == REG_SZ) {
            printf ("    REG_SZ        %s=%s\n", ValName, Val);
        } else if (Type == REG_EXPAND_SZ) {
            printf ("    REG_EXPAND_SZ %s=%s\n", ValName, Val);
        } else if (Type == REG_MULTI_SZ) {
            printf ("    REG_MULTI_SZ  %s:\n", ValName);
            p = Val;
            while (*p) {
                printf ("        %s\n", p);
                p = strchr (p, 0) + 1;
            }

            printf ("\n");
        } else if (Type == REG_LINK) {
            printf ("    REG_LINK      %s=%S\n", ValName, Val);
        } else {
            if (Type == REG_NONE) {
                printf ("    REG_NONE      %s", ValName);
            } else if (Type == REG_BINARY) {
                printf ("    REG_NONE      %s", ValName);
            } else {
                printf ("    Unknown reg type %s", ValName);
            }

            printf (" (%u byte%s)\n", ValSize, ValSize == 1 ? "" : "s");

            Array = (LPBYTE) Val;

            for (j = 0 ; j < ValSize ; j += 16) {
                printf("        %04X ", j);

                l = min (j + 16, ValSize);
                for (k = j ; k < l ; k++) {
                    printf ("%02X ", Array[k]);
                }

                for ( ; k < j + 16 ; k++) {
                    printf ("   ");
                }

                for (k = j ; k < l ; k++) {
                    printf ("%c", isprint(Array[k]) ? Array[k] : '.');
                }

                printf ("\n");
            }

            printf ("\n");
        }
    }

    printf ("\n");

    //
    // Dump subkeys
    //

    for (i = 0 ; i < SubKeyCount ; i++) {
        rc = RegEnumKey (hKey, i, SubKeyName, sizeof (SubKeyName));
        if (rc == ERROR_SUCCESS) {
        } else {
            printf ("RegEnumKey failed with error %u for %s\n", rc, RootName);
        }

        wsprintf (SubKeyPath, "%s\\%s", RootName, SubKeyName);

        rc = RegOpenKeyEx (hKey, SubKeyName, 0, KEY_READ, &hSubKey);
        if (rc != ERROR_SUCCESS) {
            printf ("RegOpenKeyEx failed with error %u for %s\n", rc, SubKeyName);
            return;
        }

        DumpKeyRecursive (hSubKey, SubKeyPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\signcabs\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\signcabs\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\sethashpwd\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\stftest\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\stftest\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\strmap\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\report\report.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    w9xtool.c

Abstract:

    Implements a stub tool that is designed to run with Win9x-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "shellapi.h"

typedef enum {
    HW_INCOMPATIBLE,
    HW_REINSTALL,
    HW_UNSUPPORTED
} HWTYPES;

#define REPORTLEVEL_NONE                    0
#define REPORTLEVEL_BLOCKING                1
#define REPORTLEVEL_ERROR                   2
#define REPORTLEVEL_WARNING                 3
#define REPORTLEVEL_INFORMATION             4
#define REPORTLEVEL_VERBOSE                 5

BOOL
SaveReport (
    IN      HWND Parent,    OPTIONAL
    IN      PCTSTR Path    OPTIONAL
    );
BOOL
InitCompatTable (
    VOID
    );

VOID
pExcludeDrive (
    IN PTSTR Drive,
    IN DWORD MsgId  OPTIONAL
    );

VOID
pAddIncompatibilityAlert (
    DWORD MessageId,
    PCTSTR Share,
    PCTSTR Path
    );

VOID
MsgSettingsIncomplete (
    IN      PCTSTR UserDatPath,
    IN      PCTSTR UserName,            OPTIONAL
    IN      BOOL CompletelyBusted
    );

BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    return InitToolMode (hInstance);
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    TerminateToolMode (hInstance);
}

VOID RegisterTextViewer (VOID);

WNDPROC g_Proc;

LRESULT
pWrapperProc (
    IN      HWND Hwnd,
    IN      UINT Msg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )
{

    if (Msg == WM_CLOSE) {
        PostQuitMessage (0);
    }

    return g_Proc (Hwnd, Msg, wParam, lParam);
}


VOID
pAddChangedUserName (
    PCTSTR DisplayGroupName,
    PCTSTR OriginalName,
    PCTSTR NewName
    )
{
    PCTSTR argArray[3];
    PCTSTR blank;
    PCTSTR rootGroup;
    PCTSTR nameSubGroup;
    PCTSTR baseGroup;
    PCTSTR fullGroupName;
    TCHAR encodedName[256];

    argArray[0] = DisplayGroupName;
    argArray[1] = OriginalName;
    argArray[2] = NewName;

    blank = GetStringResource (MSG_BLANK_NAME);

    if (argArray[1][0] == 0) {
        argArray[1] = blank;
    }

    if (argArray[2][0] == 0) {
        argArray[2] = blank;
    }

    rootGroup = GetStringResource (MSG_INSTALL_NOTES_ROOT);
    nameSubGroup = ParseMessageID (MSG_NAMECHANGE_WARNING_GROUP, argArray);
    baseGroup = JoinPaths (rootGroup, nameSubGroup);

    FreeStringResource (rootGroup);
    FreeStringResource (nameSubGroup);

    nameSubGroup = ParseMessageID (MSG_NAMECHANGE_WARNING_SUBCOMPONENT, argArray);
    fullGroupName = JoinPaths (baseGroup, nameSubGroup);
    FreePathString (baseGroup);
    FreeStringResource (nameSubGroup);

    encodedName[0] = TEXT('|');
    StringCopy (encodedName + 1, OriginalName);

    MsgMgr_ObjectMsg_Add(
        encodedName,        // Object name, prefixed with a pipe symbol
        fullGroupName,      // Message title
        S_EMPTY             // Message text
        );

    FreePathString (fullGroupName);
    FreeStringResource (blank);
}


VOID
pAddDevice (
    PCTSTR RegistryKey,
    HWTYPES SupportedType,
    PCTSTR DeviceDesc,
    BOOL Online,
    PCTSTR Class,
    PCTSTR Mfg,
    PCTSTR HardwareID,
    PCTSTR FriendlyClass
    )
{
    PCTSTR argArray[6];
    PCTSTR classAndName;
    PCTSTR group;
    UINT subGroup;
    PCTSTR message;
    BOOL unknownClass = FALSE;
    PCTSTR modifiedDescription = NULL;

    if (!Class) {
        Class = GetStringResource (MSG_UNKNOWN_DEVICE_CLASS);
        unknownClass = TRUE;
    }

    if (!Online) {
        argArray[0] = DeviceDesc;
        modifiedDescription = ParseMessageID (MSG_OFFLINE_DEVICE, argArray);
    }

    if (SupportedType == HW_INCOMPATIBLE) {
        subGroup =  MSG_INCOMPATIBLE_HARDWARE_PNP_SUBGROUP;
    } else if (SupportedType == HW_REINSTALL) {
        subGroup =  MSG_REINSTALL_HARDWARE_PNP_SUBGROUP;
    } else {
        subGroup =  MSG_UNSUPPORTED_HARDWARE_PNP_SUBGROUP;
    }

    argArray[0] = modifiedDescription ? modifiedDescription : DeviceDesc;
    argArray[1] = S_EMPTY;         // formerly Enumerator Text
    argArray[2] = Class;
    argArray[3] = Mfg;
    argArray[4] = HardwareID;
    argArray[5] = FriendlyClass;

    classAndName = JoinPaths (argArray[5], argArray[0]);

    group = BuildMessageGroup (
                MSG_INCOMPATIBLE_HARDWARE_ROOT,
                subGroup,
                classAndName
                );

    FreePathString (classAndName);

    message = ParseMessageID (MSG_HARDWARE_MESSAGE, argArray);

    MsgMgr_ObjectMsg_Add (RegistryKey, group, message);

    FreeStringResource (modifiedDescription);
    FreeText (group);
    FreeStringResource (message);

    if (unknownClass) {
        FreeStringResource (Class);
    }
}


VOID
pBadOsVersion (
    VOID
    )
{
    PCTSTR group = NULL;
    PCTSTR message = NULL;

    //
    // Add a message to the Incompatibility Report.
    //

    group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_UNKNOWN_OS_WARNING_SUBGROUP, NULL);
    message = GetStringResource (MSG_UNKNOWN_OS);

    MsgMgr_ObjectMsg_Add (TEXT("*UnknownOs"), group, message);

    FreeText (group);
    FreeStringResource (message);
}


VOID
pBlockingFile (
    PCTSTR FileName,
    PCTSTR SectNameForDisplay,
    PCTSTR Message
    )
{

    PCTSTR group;

    group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_MUST_UNINSTALL_ROOT, SectNameForDisplay);
    MsgMgr_ObjectMsg_Add (FileName, group, Message);
    FreeText (group);
}

VOID
pBlockingHardware (
    PCTSTR FileName,
    PCTSTR SectNameForDisplay,
    PCTSTR Message
    )
{
    PCTSTR group;

    group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_BLOCKING_HARDWARE_SUBGROUP, SectNameForDisplay);
    MsgMgr_ObjectMsg_Add (FileName, group, Message);
    FreeText (group);
}


VOID
pBackupDirs (
    PCTSTR DirPath
    )
{
    PCTSTR backupDirsGroup;

    backupDirsGroup = BuildMessageGroup (
                            MSG_INSTALL_NOTES_ROOT,
                            MSG_BACKUP_DETECTED_LIST_SUBGROUP,
                            DirPath
                            );
    MsgMgr_ObjectMsg_Add(
        DirPath,
        backupDirsGroup,
        S_EMPTY
        );

    FreeText (backupDirsGroup);
}


VOID
pManyBackupDirs (
    UINT DirCount
    )
{
    PCTSTR backupDirsGroup;
    PCTSTR argArray[2];
    TCHAR buffer[32];
    PCTSTR msg;

    backupDirsGroup = BuildMessageGroup (
                            MSG_INSTALL_NOTES_ROOT,
                            MSG_BACKUP_DETECTED_SUBGROUP,
                            NULL
                            );
    argArray[0] = "Windows 9X";
    wsprintf (buffer, "%lu", DirCount);
    argArray[1] = buffer;
    msg = ParseMessageID (MSG_BACKUP_DETECTED, argArray);

    MsgMgr_ObjectMsg_Add (
        TEXT("*BackupDetected"),
        backupDirsGroup,
        msg
        );

    FreeStringResource (msg);
}


VOID
pHlpFile (
    PCTSTR ModuleName,
    PCTSTR HlpName,
    PCTSTR FriendlyName,
    PCTSTR Text
    )
{
    PCTSTR argList[3];
    PCTSTR comp;

    argList[0] = ModuleName;
    argList[1] = HlpName;
    argList[2] = FriendlyName;

    comp = BuildMessageGroup (MSG_MINOR_PROBLEM_ROOT, MSG_HELPFILES_SUBGROUP, argList[2]);

    MsgMgr_ObjectMsg_Add (HlpName, comp, Text);
    FreeText (comp);
}


VOID
pProfileDir (
    PCTSTR DirPath,
    PCTSTR NewName
    )
{
    PCTSTR argArray[3];
    PCTSTR message;
    PCTSTR group;

    argArray[0] = DirPath;
    argArray[1] = NewName;
    message = ParseMessageID (MSG_DIRECTORY_COLLISION_SUBCOMPONENT, argArray);

    group = BuildMessageGroup (
                MSG_INSTALL_NOTES_ROOT,
                MSG_DIRECTORY_COLLISION_SUBGROUP,
                message
                );

    MsgMgr_ObjectMsg_Add (TEXT("*RenameFolders"), group, S_EMPTY);

    FreeText (group);
    FreeStringResource (message);
}


VOID
pBadShell (
    VOID
    )
{
    PCTSTR object;
    PCTSTR message;

    object = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_REPORT_SHELL_SUBGROUP, NULL);
    message = GetStringResource (MSG_REPORT_SHELL_INCOMPATIBLE);

    MsgMgr_ObjectMsg_Add (TEXT("*BadShell"), object, message);

    FreeText (object);
    FreeStringResource (message);
}


VOID
pBadScr (
    PCTSTR FilePath,
    PCTSTR SectLocalizedName,   OPTIONAL
    WORD ActType,
    PCTSTR Message              OPTIONAL
    )
{
    PTSTR friendlyName = NULL;
    PTSTR extPtr = NULL;
    PTSTR displayName = NULL;
    PCTSTR reportEntry = NULL;
    PTSTR component = NULL;
    PCTSTR temp1, temp2;
    BOOL reportEntryIsResource = TRUE;

    if (SectLocalizedName) {
        friendlyName = DuplicatePathString (SectLocalizedName, 0);
    } else {
        friendlyName = DuplicatePathString (GetFileNameFromPath (FilePath), 0);
        extPtr = (PTSTR) GetFileExtensionFromPath (friendlyName);
        if (extPtr != NULL) {
            extPtr = _tcsdec (friendlyName, extPtr);
            if (extPtr != NULL) {
                *extPtr = 0;
            }
        }

        displayName = (PTSTR)ParseMessageID (MSG_NICE_PATH_SCREEN_SAVER, &friendlyName);

        FreePathString (friendlyName);
        friendlyName = NULL;
    }

    switch (ActType) {

    case ACT_REINSTALL:
        temp1 = GetStringResource (MSG_REINSTALL_ROOT);
        temp2 = GetStringResource (Message ? MSG_REINSTALL_DETAIL_SUBGROUP : MSG_REINSTALL_LIST_SUBGROUP);

        reportEntry = JoinPaths (temp1, temp2);
        reportEntryIsResource = FALSE;

        FreeStringResource (temp1);
        FreeStringResource (temp2);
        break;

    case ACT_REINSTALL_BLOCK:
        temp1 = GetStringResource (MSG_BLOCKING_ITEMS_ROOT);
        temp2 = GetStringResource (MSG_REINSTALL_BLOCK_ROOT);

        reportEntry = JoinPaths (temp1, temp2);
        reportEntryIsResource = FALSE;

        FreeStringResource (temp1);
        FreeStringResource (temp2);
        break;

    case ACT_MINORPROBLEMS:
        reportEntry = GetStringResource (MSG_MINOR_PROBLEM_ROOT);
        break;

    case ACT_INCOMPATIBLE:
    case ACT_INC_NOBADAPPS:

        temp1 = GetStringResource (MSG_INCOMPATIBLE_ROOT);
        temp2 = GetStringResource (Message ? MSG_INCOMPATIBLE_DETAIL_SUBGROUP : MSG_TOTALLY_INCOMPATIBLE_SUBGROUP);
        reportEntry = JoinPaths (temp1, temp2);
        reportEntryIsResource = FALSE;

        FreeStringResource (temp1);
        FreeStringResource (temp2);

        break;
    }

    component = JoinPaths (reportEntry, displayName?displayName:friendlyName);

    MsgMgr_ObjectMsg_Add (FilePath, component, Message);

    FreePathString (component);

    if (reportEntryIsResource) {
        FreeStringResource (reportEntry);
    } else {
        FreePathString (reportEntry);
    }

    if (displayName) {
        FreeStringResourcePtrA (&displayName);
    }

    FreePathString (friendlyName);
}


VOID
pBadCpl (
    PCTSTR FilePath,
    PCTSTR FriendlyNameMultiSz,
    PCTSTR SectLocalizedName,   OPTIONAL
    WORD ActType,
    PCTSTR Message              OPTIONAL
    )
{
    GROWBUFFER friendlyName = GROWBUF_INIT;
    MULTISZ_ENUM namesEnum;
    PTSTR displayName = NULL;
    PCTSTR reportEntry = NULL;
    PTSTR component = NULL;
    BOOL reportEntryIsResource = TRUE;
    BOOL padName = FALSE;
    PCTSTR temp1, temp2;

    if (SectLocalizedName) {
        MultiSzAppend (&friendlyName, SectLocalizedName);
    }

    if (friendlyName.Buf == NULL) {
        while (*FriendlyNameMultiSz) {
            MultiSzAppend (&friendlyName, FriendlyNameMultiSz);
            FriendlyNameMultiSz = GetEndOfString (FriendlyNameMultiSz) + 1;
        }

        padName = TRUE;
    }

    if (EnumFirstMultiSz (&namesEnum, friendlyName.Buf)) {
        do {
            if (padName) {
                displayName = (PTSTR)ParseMessageID (MSG_NICE_PATH_CONTROL_PANEL, &namesEnum.CurrentString);
            } else {
                displayName = DuplicatePathString (namesEnum.CurrentString, 0);
            }

            switch (ActType) {

            case ACT_MINORPROBLEMS:
                reportEntry = GetStringResource (MSG_MINOR_PROBLEM_ROOT);
                break;

            case ACT_INCOMPATIBLE:
            case ACT_INC_NOBADAPPS:
            case ACT_INC_IHVUTIL:
            case ACT_INC_PREINSTUTIL:
            case ACT_INC_SIMILAROSFUNC:

                temp1 = GetStringResource (MSG_INCOMPATIBLE_ROOT);
                if (!temp1) {
                    break;
                }

                switch (ActType) {

                case ACT_INC_SIMILAROSFUNC:
                    temp2 = GetStringResource (MSG_INCOMPATIBLE_UTIL_SIMILAR_FEATURE_SUBGROUP);
                    break;

                case ACT_INC_PREINSTUTIL:
                    temp2 = GetStringResource (MSG_INCOMPATIBLE_PREINSTALLED_UTIL_SUBGROUP);
                    break;

                case ACT_INC_IHVUTIL:
                    temp2 = GetStringResource (MSG_INCOMPATIBLE_HW_UTIL_SUBGROUP);
                    break;

                default:
                    temp2 = GetStringResource (Message ? MSG_INCOMPATIBLE_DETAIL_SUBGROUP : MSG_TOTALLY_INCOMPATIBLE_SUBGROUP);
                    break;
                }

                if (!temp2) {
                    break;
                }

                reportEntry = JoinPaths (temp1, temp2);
                reportEntryIsResource = FALSE;

                FreeStringResource (temp1);
                FreeStringResource (temp2);
                break;

            case ACT_INC_SAFETY:
                temp1 = GetStringResource (MSG_INCOMPATIBLE_ROOT);
                if (!temp1) {
                    break;
                }
                temp2 = GetStringResource (MSG_REMOVED_FOR_SAFETY_SUBGROUP);
                if (!temp2) {
                    break;
                }

                reportEntry = JoinPaths (temp1, temp2);
                reportEntryIsResource = FALSE;

                FreeStringResource (temp1);
                FreeStringResource (temp2);
                break;

            case ACT_REINSTALL:
                temp1 = GetStringResource (MSG_REINSTALL_ROOT);
                if (!temp1) {
                    break;
                }
                temp2 = GetStringResource (Message ? MSG_REINSTALL_DETAIL_SUBGROUP : MSG_REINSTALL_LIST_SUBGROUP);
                if (!temp2) {
                    break;
                }

                reportEntry = JoinPaths (temp1, temp2);
                reportEntryIsResource = FALSE;

                FreeStringResource (temp1);
                FreeStringResource (temp2);
                break;

            case ACT_REINSTALL_BLOCK:
                temp1 = GetStringResource (MSG_BLOCKING_ITEMS_ROOT);
                if (!temp1) {
                    break;
                }
                temp2 = GetStringResource (MSG_REINSTALL_BLOCK_ROOT);
                if (!temp2) {
                    break;
                }

                reportEntry = JoinPaths (temp1, temp2);
                reportEntryIsResource = FALSE;

                FreeStringResource (temp1);
                FreeStringResource (temp2);
                break;
            }

            component = JoinPaths (reportEntry, displayName);

            MsgMgr_ObjectMsg_Add (FilePath, component, Message);

            FreePathString (component);

            if (reportEntryIsResource) {
                FreeStringResource (reportEntry);
            } else {
                FreePathString (reportEntry);
                reportEntryIsResource = TRUE;
            }

            if (padName) {
                FreeStringResourcePtrA (&displayName);
            } else {
                FreePathString (displayName);
            }

        } while (EnumNextMultiSz (&namesEnum));
    }
    FreeGrowBuffer (&friendlyName);
}

VOID
pShowPacks (
    PCTSTR UpgradePackName
    )
{
    PCTSTR group;

    group = BuildMessageGroup (
            MSG_INSTALL_NOTES_ROOT,
            MSG_RUNNING_MIGRATION_DLLS_SUBGROUP,
            UpgradePackName
            );

    MsgMgr_ObjectMsg_Add (
        UpgradePackName,
        group,
        S_EMPTY
        );
}


VOID
pOutOfDiskSpace (
    VOID
    )
{
    PCTSTR group;
    PCTSTR args[5];
    PCTSTR msg;

    args[0] = TEXT("C:\\");
    args[1] = TEXT("300");
    args[2] = TEXT("220");
    args[3] = TEXT("120");
    args[4] = TEXT("250");

    msg = ParseMessageID (MSG_NOT_ENOUGH_DISK_SPACE_WITH_LOCALSOURCE_AND_BACKUP, args);

    group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_NOT_ENOUGH_DISKSPACE_SUBGROUP, NULL);
    MsgMgr_ObjectMsg_Add (TEXT("*DiskSpace"), group, msg);
    FreeText (group);

    FreeStringResource (msg);
}


VOID
pOutOfRam (
    VOID
    )
{
    PCTSTR args[3];
    PCTSTR group;
    PCTSTR message;

    args[0] = TEXT("64");
    args[1] = TEXT("48");
    args[2] = TEXT("16");

    group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_NOT_ENOUGH_RAM_SUBGROUP, NULL);
    message = ParseMessageID (MSG_NOT_ENOUGH_RAM, args);

    MsgMgr_ObjectMsg_Add (TEXT("*Ram"), group, message);

    FreeText (group);
    FreeStringResource (message);
}

VOID
pMapi (
    VOID
    )
{
    PCTSTR group;
    PCTSTR message;

    group = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_MAPI_NOT_HANDLED_SUBGROUP, NULL);
    message = GetStringResource (MSG_MAPI_NOT_HANDLED);

    MsgMgr_ObjectMsg_Add (TEXT("*MapiNotHandled"), group, message);

    FreeText (group);
    FreeStringResource (message);
}

VOID
pDarwin (
    VOID
    )
{
    PCTSTR group;
    PCTSTR message;

    group = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_DARWIN_NOT_HANDLED_SUBGROUP, NULL);
    message = GetStringResource (MSG_DARWIN_NOT_HANDLED);

    MsgMgr_ObjectMsg_Add (TEXT("*DarwinNotHandled"), group, message);

    FreeText (group);
    FreeStringResource (message);
}

VOID
pRas (
    PCTSTR EntryName
    )
{
    PCTSTR group;

    group = BuildMessageGroup (
                MSG_INSTALL_NOTES_ROOT,
                MSG_CONNECTION_PASSWORD_SUBGROUP,
                EntryName
                );
    MsgMgr_ObjectMsg_Add ( EntryName, group, S_EMPTY);
    FreeText (group);

    group = BuildMessageGroup (
                MSG_LOSTSETTINGS_ROOT,
                MSG_CONNECTION_BADPROTOCOL_SUBGROUP,
                EntryName
                );

    MsgMgr_ObjectMsg_Add (
        EntryName,
        group,
        S_EMPTY
        );

    FreeText (group);
}


VOID
pMultiMon (
    BOOL Per
    )
{
    PCTSTR group;
    PCTSTR message;

    group = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_MULTI_MONITOR_UNSUPPORTED_SUBGROUP, NULL);
    message = GetStringResource (Per?
                                    MSG_MULTI_MONITOR_UNSUPPORTED_PER:
                                    MSG_MULTI_MONITOR_UNSUPPORTED);

    MsgMgr_ObjectMsg_Add (TEXT("*MultiMonitor"), group, message);

    FreeText (group);
    FreeStringResource (message);
}


VOID
pJoysticks (
    PCTSTR FullPath,
    PCTSTR JoystickName
    )
{
    PCTSTR group;

    group = BuildMessageGroup (
                MSG_INCOMPATIBLE_HARDWARE_ROOT,
                MSG_JOYSTICK_SUBGROUP,
                JoystickName
                );

    MsgMgr_ObjectMsg_Add (
        FullPath,
        group,
        NULL
        );

    FreeText (group);
}


VOID
pTwain (
    PCTSTR DataSourceModule,
    PCTSTR DisplayName
    )
{
    PCTSTR group;

    group = BuildMessageGroup (
                MSG_INCOMPATIBLE_HARDWARE_ROOT,
                MSG_TWAIN_SUBGROUP,
                DisplayName
                );

    MsgMgr_ObjectMsg_Add (
        DataSourceModule,
        group,
        NULL
        );

    FreeText (group);
}

VOID
pRecycleBin (
    PCTSTR Recycled
    )
{
    PCTSTR args[1];
    PCTSTR group;
    PCTSTR message;

    args[0] = Recycled;

    group = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_RECYCLE_BIN_SUBGROUP, NULL);
    message = ParseMessageID (MSG_RECYCLED_FILES_WILL_BE_DELETED, args);

    MsgMgr_ObjectMsg_Add (TEXT("*RECYCLEBIN"), group, message);

    FreeText (group);
    FreeStringResource (message);
}


VOID
pTimeZone (
    PCTSTR CurTimeZone      // can be empty string
    )
{
    PCTSTR args[1];
    PCTSTR component;
    PCTSTR warning;

    args[0] = CurTimeZone;

    component = GetStringResource (MSG_TIMEZONE_COMPONENT);

    if (*CurTimeZone) {
        warning = ParseMessageID (MSG_TIMEZONE_WARNING, args);
    }
    else {
        warning = GetStringResource (MSG_TIMEZONE_WARNING_UNKNOWN);
    }

    MYASSERT (component);
    MYASSERT (warning);

    MsgMgr_ObjectMsg_Add (TEXT("*TIMEZONE"), component, warning);
    FreeStringResource (component);
    FreeStringResource (warning);
}


VOID
pLostRasPassword (
    PCTSTR EntryName
    )
{
    PCTSTR group;

    group = BuildMessageGroup (
                MSG_MISC_WARNINGS_ROOT,
                MSG_CONNECTION_PASSWORD_SUBGROUP,
                EntryName
                );

    MsgMgr_ObjectMsg_Add (EntryName, group, S_EMPTY);
    FreeText (group);
}


VOID
pGenReport (
    VOID
    )
{

    //
    // Changed names
    //

    pAddChangedUserName ("User Name", "Guest", "Guest-1");
    pAddChangedUserName ("Computer Name", "My Bad Computer Name", "MyBadComputerNa");

    //
    // Hardware
    //

    pAddDevice (
        "HKLM\\Enum\\Key1",
        HW_INCOMPATIBLE,
        "PCMCIA Interrupt Sequencer",
        TRUE,
        "SysDevs",
        "Texas Instruments",
        "PCMCIA\\TI004000&DEV_1234",
        "System Devices"
        );

    pAddDevice (
        "HKLM\\Enum\\Key2",
        HW_INCOMPATIBLE,
        "PCMCIA Mass Storage Device",
        FALSE,
        "DiskDrives",
        "Texas Instruments",
        "PCMCIA\\TI005000&DEV_2000",
        "Hard Disk Drives"
        );

    pAddDevice (
        "HKLM\\Enum\\Key1A",
        HW_INCOMPATIBLE,
        "Matrox Century 1",
        TRUE,
        "Video",
        "Matrox Inc.",
        "PCI\\VEN_0010&DEV_0020",
        "Display Devices"
        );

    pAddDevice (
        "HKLM\\Enum\\Key2B",
        HW_INCOMPATIBLE,
        "Microsoft Enhanced Keyboard",
        TRUE,
        "Input",
        "Microsoft Corporation",
        "*PNP091C",
        "Input Devices"
        );

    pAddDevice (
        "HKLM\\Enum\\Key3",
        HW_REINSTALL,
        "Cannon Digital Camera",
        FALSE,
        "MF",
        "Cannon",
        "USB\\CANNON_DC_VID_0100&PID_0105&RID_6500",
        "Multi Function Devices"
        );

    pAddDevice (
        "HKLM\\Enum\\Key4",
        HW_REINSTALL,
        "Cannon Digital Camera Docking Station",
        TRUE,
        "MF",
        "Cannon",
        "USB\\CANNON_DC_VID_0100&PID_0105&RID_6501",
        "Multi Function Devices"
        );

    pAddDevice (
        "HKLM\\Enum\\Key5",
        HW_UNSUPPORTED,
        "Adaptec XX00",
        FALSE,
        "SCSI",
        "Texas Instruments",
        "PCMCIA\\TI004000&DEV_1234",
        "SCSI Controllers"
        );

    //
    // Bad OS version (Win95?)
    //

    pBadOsVersion();

    //
    // Blocking file
    //

    pBlockingFile (
        "c:\\program files\\nueo\\DLAPP.EXE",
        "Norton Your Eyes Only",
        "Norton Your Eyes Only can cause serious problems during the upgrade to "
            "Windows XP. Because of these incompatibilities, "
            "you must uninstall this program from your system before continuing."
        );

    pBlockingFile (
        "c:\\program files\\Sysmon32.exe",
        "V3Pro 98",
        "This virus scanner can cause serious problems during the upgrade to Windows XP. You must "
        "uninstall V3 Professional 98 before continuing."
        );

    //
    // Blocking hardware
    //

    pBlockingHardware (
        "c:\\windows\\system\\NVARCH32.DLL",
        "ALi AGP Controller",
        "Setup has detected an incompatibility between your video card & computer's mainboard. "
            "Because of this, your computer may not start up after the upgrade. Contact the "
            "manufacturer of your hardware for technical assistance."
        );

    //
    // Backup dirs
    //

    pBackupDirs ("c:\\myfiles");
    pManyBackupDirs (55);

    //
    // HLP files
    //

    pHlpFile ("c:\\my app\\foo.hlp", "foo.hlp", "Foo Help File", NULL);
    pHlpFile ("c:\\my app\\foo.hlp2", "foo.hlp2", "Foo Help File 2", "Test text");

    //
    // Dir collisions
    //

    pProfileDir ("c:\\Documents and Settings", "c:\\Documents and Settings.001");

    //
    // Replacement shell
    //

    pBadShell();

    //
    // Bad SCR
    //

    pBadScr ("c:\\windows\\system\\disney.scr", NULL, ACT_REINSTALL, NULL);
    pBadScr ("c:\\windows\\system\\Clifford.scr", NULL, ACT_REINSTALL_BLOCK, NULL);
    pBadScr ("c:\\windows\\system\\Stars and Stripes.scr", NULL, ACT_MINORPROBLEMS, "The animation mode will not work on Windows XP");
    pBadScr ("c:\\windows\\system\\Light Tracer.scr", NULL, ACT_INCOMPATIBLE, NULL);
    pBadScr ("c:\\windows\\system\\Big Fish.scr", NULL, ACT_INC_NOBADAPPS, NULL);
    pBadScr ("c:\\windows\\system\\disney gfy.scr", "Disney's Goofy", ACT_REINSTALL, NULL);


    //
    // Bad CPL
    //

    pBadCpl (
        "c:\\windows\\system\\chipcontrol.cpl",
        "Chip Control\0Cache\0",
        NULL,
        ACT_REINSTALL,
        NULL
        );

    pBadCpl (
        "c:\\windows\\system\\antivirus.cpl",
        "AntiVirus",
        NULL,
        ACT_REINSTALL_BLOCK,
        NULL
        );

    pBadCpl (
        "c:\\windows\\system\\antivirus2.cpl",
        "Symantec AntiVirus",
        NULL,
        ACT_REINSTALL_BLOCK,
        NULL
        );

    pBadCpl (
        "c:\\windows\\system\\crash.cpl",
        "Crash Applet",
        NULL,
        ACT_INC_SAFETY,
        NULL
        );

    pBadCpl (
        "c:\\windows\\system\\findfast.cpl",
        "FindFast",
        NULL,
        ACT_INC_SIMILAROSFUNC,
        NULL
        );

    pBadCpl (
        "c:\\windows\\system\\easyaccess.cpl",
        "Compaq EasyAccess",
        NULL,
        ACT_INC_PREINSTUTIL,
        NULL
        );

    pBadCpl (
        "c:\\windows\\system\\vdesk.cpl",
        "Matrox Virtual Desktop",
        NULL,
        ACT_INC_IHVUTIL,
        NULL
        );

    pBadCpl (
        "c:\\windows\\system\\quicktime.cpl",
        "Apple QuickTime 1.0",
        NULL,
        ACT_INC_NOBADAPPS,
        NULL
        );

    pBadCpl (
        "c:\\windows\\system\\celldialer.cpl",
        "Motorola Cell Phone Dialer",
        NULL,
        ACT_MINORPROBLEMS,
        "After upgrading, the Motorola Cell Phone Dialer won't redial if a busy signal is detected"
        );

    //
    // Mig Dll IDs
    //

    pShowPacks ("Microsoft Upgrade Pack 2");
    pShowPacks ("Front Page Server Extensions");

    //
    // Excluded drives
    //

    pExcludeDrive (TEXT("C:\\"), MSG_DRIVE_EXCLUDED_SUBGROUP);
    pExcludeDrive (TEXT("D:\\"), MSG_DRIVE_INACCESSIBLE_SUBGROUP);
    pExcludeDrive (TEXT("E:\\"), MSG_DRIVE_RAM_SUBGROUP);
    pExcludeDrive (TEXT("F:\\"), MSG_DRIVE_NETWORK_SUBGROUP);
    pExcludeDrive (TEXT("G:\\"), MSG_DRIVE_SUBST_SUBGROUP);

    //
    // Out of disk space or RAM
    //

    pOutOfDiskSpace();
    pOutOfRam();

    //
    // MAPI and Darwin
    //

    pMapi();
    pDarwin ();

    //
    // RAS
    //

    pRas(TEXT("My ISP"));

    //
    // Shares
    //

    pAddIncompatibilityAlert (MSG_INVALID_ACL_LIST, TEXT("MyShare"), TEXT("c:\\my share"));
    pAddIncompatibilityAlert (MSG_LOST_SHARE_PASSWORDS, TEXT("MyShare2"), TEXT("c:\\my share2"));
    pAddIncompatibilityAlert (MSG_LOST_ACCESS_FLAGS, TEXT("MyShare3"), TEXT("c:\\my share3"));

    //
    // Multiple monitors
    //

    pMultiMon (TRUE);       // per
    pMultiMon (FALSE);      // pro

    //
    // Joysticks
    //

    pJoysticks ("c:\\windows\\system\\joy.vxd", "Microsoft Sidewinder");

    //
    // TWAIN
    //

    pTwain ("c:\\windows\\twain_32\\xeotec.ds", "Xeotec Digital Camera");

    //
    // Recycle Bin
    //

    pRecycleBin ("30");

    //
    // Bad user accounts
    //

    MsgSettingsIncomplete ("c:\\windows\\profiles\\joeuser", "joeuser", FALSE);
    MsgSettingsIncomplete ("c:\\windows\\profiles\\maryuser", "maryuser", TRUE);
    MsgSettingsIncomplete ("c:\\windows\\profiles\\a?b", NULL, TRUE);

    //
    // Time zone
    //

    pTimeZone ("");
    pTimeZone ("Pacific Time (GMT -08:00)");

    //
    // Lost RAS password
    //

    pLostRasPassword ("AOL");

}


BOOL
pFillListControl (
    IN      HWND ListHandle
    );

INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{

    HWND hwnd;
    UINT rc;

    SuppressAllLogPopups (TRUE);
    if (!Init()) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    //
    // TODO: Put your code here
    //

    RegisterTextViewer();



    {
        MSG msg;
        PCTSTR text;
        HANDLE file;
        HANDLE map;
        UINT size;
        PTSTR textBuf;

        MsgMgr_Init();
        InitCompatTable();
        pGenReport();
        MsgMgr_Resolve();

        SaveReport (NULL, TEXT("C:\\test.htm"));
        SaveReport (NULL, TEXT("C:\\test.txt"));

        pFillListControl (NULL);

        text = (PCTSTR) MapFileIntoMemory (TEXT("C:\\test.htm"), &file, &map);
        size = GetFileSize (file, NULL);
        textBuf = AllocText (size + 1);
        CopyMemory (textBuf, text, size);
        textBuf[size] = 0;

        hwnd = CreateWindowEx (
                    WS_EX_APPWINDOW|WS_EX_PALETTEWINDOW,
                    S_TEXTVIEW_CLASS,
                    textBuf,
                    WS_OVERLAPPED|WS_BORDER|WS_SYSMENU|WS_VISIBLE|WS_VSCROLL,
                    100, 100,
                    418, 215,
                    NULL,
                    NULL,
                    GetModuleHandle (NULL),
                    NULL
                    );

        g_Proc = (WNDPROC) GetWindowLong (hwnd, GWL_WNDPROC);
        SetWindowLong (hwnd, GWL_WNDPROC, (LONG) pWrapperProc);

        while (GetMessage (&msg, NULL, 0, 0)) {

            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }


    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\sfspace\sfspace.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    sfspace.c

Abstract:

    sfspace calculates the amount of space required for shell folders in a clean install of
    Windows 2000 and outputs the results in a form which can be copied into win95upg.inf.

Author:

    Marc R. Whitten (marcw) 24-Mar-1999

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "shlobj.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);
//BOOL WINAPI MemDb_Entry (HINSTANCE, DWORD, PVOID);



#define SFLIST \
    DEFMAC(AppData, CSIDL_APPDATA) \
    DEFMAC(Cache, CSIDL_INTERNET_CACHE) \
    DEFMAC(Cookies, CSIDL_COOKIES) \
    DEFMAC(Desktop, CSIDL_DESKTOPDIRECTORY) \
    DEFMAC(Favorites, CSIDL_FAVORITES) \
    DEFMAC(History, CSIDL_HISTORY) \
    DEFMAC(Local AppData, CSIDL_LOCAL_APPDATA) \
    DEFMAC(Local Settings, CSIDL_LOCAL_APPDATA) \
    DEFMAC(My Pictures, CSIDL_MYPICTURES) \
    DEFMAC(NetHood, CSIDL_NETHOOD) \
    DEFMAC(Personal, CSIDL_PERSONAL) \
    DEFMAC(PrintHood, CSIDL_PRINTHOOD) \
    DEFMAC(Programs, CSIDL_PROGRAMS) \
    DEFMAC(Recent, CSIDL_RECENT) \
    DEFMAC(SendTo, CSIDL_SENDTO) \
    DEFMAC(Start Menu, CSIDL_STARTMENU) \
    DEFMAC(StartUp, CSIDL_STARTUP) \
    DEFMAC(Templates, CSIDL_TEMPLATES) \
    DEFMAC(Common AppData, CSIDL_COMMON_APPDATA) \
    DEFMAC(Common Desktop, CSIDL_COMMON_DESKTOPDIRECTORY) \
    DEFMAC(Common Personal, CSIDL_COMMON_DOCUMENTS) \
    DEFMAC(Common Favorites, CSIDL_COMMON_FAVORITES) \
    DEFMAC(Common Programs, CSIDL_COMMON_PROGRAMS) \
    DEFMAC(Common Start Menu, CSIDL_COMMON_STARTMENU) \
    DEFMAC(Common StartUp, CSIDL_COMMON_STARTUP) \
    DEFMAC(Common Templates, CSIDL_COMMON_TEMPLATES) \


enum {
    CS_512 = 0,
    CS_1024,
    CS_2048,
    CS_4096,
    CS_8192,
    CS_16384,
    CS_32768,
    CS_65536,
    CS_131072,
    CS_262144,
    LAST_CLUSTER_SIZE
};

typedef struct {

    PCTSTR RegKey;
    UINT Csidl;
    PCTSTR Path;
    LONG TableOffset;
    LONG SpaceNeeded[LAST_CLUSTER_SIZE];
    LONG RawSize;
    UINT FileCount;
    UINT DirectoryCount;
} SFDATA, *PSFDATA;

#define DEFMAC(regName, csidl) {TEXT(#regName),(csidl)},

SFDATA g_Data[] = {SFLIST /*, */ {NULL,0}};
HASHTABLE g_Table;
POOLHANDLE g_Pool;
BOOL g_Verbose = FALSE;
UINT g_ClusterTable[LAST_CLUSTER_SIZE] =
    {512,1024,2048,4096,8192,16384,32768,65536,131072,262144};


#define DIRECTORY_SIZE 512

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }
/*
    if (!MemDb_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }
*/


    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}

BOOL
pInitShellFolderData (
    VOID
    )
{
    PSFDATA sf;
    TCHAR buffer[MAX_TCHAR_PATH];
    PTSTR p;

    sf = g_Data;

    while (sf->RegKey) {


        if (SHGetFolderPath (NULL, sf->Csidl, NULL, 0, buffer) != S_OK) {
            _ftprintf (stderr, TEXT("sfspace: Unable to retrieve folder path for %s.\n"), sf->RegKey);
            return FALSE;

        }

        sf->Path = PoolMemDuplicateString (g_Pool, buffer);

        //
        // We don't have a CSIDL for the local settings directory. We need to hack it.
        //
        if (StringIMatch (sf->RegKey, TEXT("Local Settings"))) {

            p = _tcsrchr (sf->Path, TEXT('\\'));
            MYASSERT (p);

            *p = 0;
            if (g_Verbose) {
                _tprintf (TEXT("sfspace: Hacked path of local settings to %s.\n"), sf->Path);
            }
        }


        sf->TableOffset = HtAddString (g_Table, sf->Path);

        if (g_Verbose) {
            _tprintf (TEXT("sfspace: Shell folder %s has path %s.\n"), sf->RegKey, sf->Path);
        }
        sf++;


    }


    return TRUE;
}

BOOL
pGatherSpaceRequirements (
    VOID
    )
{
    PSFDATA sf;
    UINT i;
    TREE_ENUM e;
    LONG offset;

    sf = g_Data;


    while (sf->RegKey) {

        if (EnumFirstFileInTree (&e, sf->Path, NULL, FALSE)) {

            do {

                if (e.Directory) {

                    //
                    // Check to see if this is a different shell folder.
                    //
                    offset = HtFindString (g_Table, e.FullPath);
                    if (offset && offset != sf->TableOffset) {

                        //
                        // This is actually another shell folder. Don't enumerate
                        // it.
                        //
                        if (g_Verbose) {

                            _tprintf (TEXT("sfspace: %s is handled by another shell folder.\n"), e.FullPath);
                        }
                        AbortEnumCurrentDir (&e);
                    }
                    else {

                        //
                        // Increment directory count for this shell folder.
                        //
                        sf->DirectoryCount++;
                    }
                }
                else {

                    //
                    // this is a file. Add its data to our structure.
                    //
                    sf->FileCount++;
                    sf->RawSize += e.FindData->nFileSizeLow;
                    for (i=0; i<LAST_CLUSTER_SIZE; i++) {

                        //
                        // We assume NT doesn't install any massively large files by default.
                        //
                        MYASSERT (!e.FindData->nFileSizeHigh);
                        sf->SpaceNeeded[i] += ((e.FindData->nFileSizeLow / g_ClusterTable[i]) * g_ClusterTable[i]) + g_ClusterTable[i];
                    }
                }

            } while (EnumNextFileInTree (&e));
        }


        //
        // Add the space for all of the directories we found in this shell folder.
        //
        for (i=0; i<LAST_CLUSTER_SIZE; i++) {

            sf->SpaceNeeded[i] += (((sf->DirectoryCount * DIRECTORY_SIZE) / g_ClusterTable[i]) * g_ClusterTable[i]) + g_ClusterTable[i];
        }

        if (g_Verbose) {
            _tprintf (
                TEXT("sfspace: %u files and %u directories enumerated for shell folder %s. Space needed (512k cluster size): %u Raw Space: %u\n"),
                sf->FileCount,
                sf->DirectoryCount,
                sf->RegKey,
                sf->SpaceNeeded[CS_512],
                sf->RawSize
                );
        }

        sf++;
    }

    return TRUE;
}

PCTSTR
pLeftJustify (
    IN PCTSTR String,
    IN UINT FieldWidth
    )
{
    static TCHAR rBuffer[MAX_TCHAR_PATH];
    UINT length;
    UINT i;


    MYASSERT(String);
    length = CharCount (String);
    MYASSERT(FieldWidth < MAX_TCHAR_PATH && length < FieldWidth);

    StringCopy (rBuffer,String);
    for (i=length; i<FieldWidth; i++) {
        rBuffer[i] = TEXT(' ');
    }
    rBuffer[i] = 0;

    return rBuffer;
}

VOID
pOutputSpaceTable (
    VOID
    )
{

    PSFDATA sf;
    UINT i;
    TCHAR buffer[20];

    _tprintf (TEXT("[%s]\n"), S_SHELL_FOLDERS_DISK_SPACE);
    _tprintf (
        TEXT("@*:                                                                                \n")
        TEXT("@*: Disk space requirements for each shell folder.  The key name is a registry     \n")
        TEXT("@*: value name.                                                                    \n")
        TEXT("@*:                                                                                \n")
        );

    sf = g_Data;
    while (sf->RegKey) {

        _tprintf (TEXT("%s"),pLeftJustify (sf->RegKey,20));

        for (i=0; i<LAST_CLUSTER_SIZE; i++) {
            _tprintf (TEXT("%s %u"),i ? TEXT(",") : TEXT("="), sf->SpaceNeeded[i]);
        }
        _tprintf (TEXT("\n"));

        sf++;
    }
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")
        TEXT("  sfspace [/V]\n")
        TEXT("\nDescription:\n\n")
        TEXT("  sfspace gathers the space requirements for the default\n")
        TEXT("  shell folders installed by Windows 2000. It should be\n")
        TEXT("  run against a clean install of Windows 2000.\n")
        TEXT("\nArguments:\n\n")
        TEXT("  /V  Instructs sfspace to generate verbose output.\n")
        );

    exit (1);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('v'):
                //
                // Verbose output wanted.
                //
                g_Verbose = TRUE;
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            //
            // None
            //
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // Initialize data structures.
    //
    g_Table = HtAlloc ();
    g_Pool = PoolMemInitPool ();
    _try {

        if (!pInitShellFolderData ()) {
            _ftprintf (stderr, TEXT("sfspace: Unable to initialize shell folder data. Exiting.\n"));
            __leave;
        }

        if (!pGatherSpaceRequirements ()) {
            _ftprintf (stderr, TEXT("sfspace: Unable to gather space requirements for shell folders. Exiting.\n"));
            __leave;
        }

        pOutputSpaceTable ();
    }
    __finally {
        HtFree (g_Table);
        PoolMemDestroyPool (g_Pool);
    }
    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\strtabs\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\sharegen\sharegen.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    sharegen.c

Abstract:

    Implements a stub tool that is designed to run with NT-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


#define W95_ACCESS_READ      0x1
#define W95_ACCESS_WRITE     0x2
#define W95_ACCESS_CREATE    0x4
#define W95_ACCESS_EXEC      0x8
#define W95_ACCESS_DELETE    0x10
#define W95_ACCESS_ATRIB     0x20
#define W95_ACCESS_PERM      0x40
#define W95_ACCESS_FINDFIRST 0x80
#define W95_ACCESS_FULL      0xff
#define W95_ACCESS_GROUP     0x8000

#define W95_GENERIC_READ    (W95_ACCESS_READ|W95_ACCESS_EXEC|W95_ACCESS_FINDFIRST)
#define W95_GENERIC_WRITE   (W95_ACCESS_FULL ^ W95_GENERIC_READ)
#define W95_GENERIC_FULL    (W95_ACCESS_FULL)
#define W95_GENERIC_NONE    0


#define SHI50F_RDONLY       0x0001
#define SHI50F_FULL         0x0002
#define SHI50F_DEPENDSON    (SHI50F_RDONLY|SHI50F_FULL)
#define SHI50F_ACCESSMASK   (SHI50F_RDONLY|SHI50F_FULL)


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();

}


VOID
HelpAndExit (
    VOID
    )
{
    wprintf (L"Command Line Syntax:\n\n"
             L"sharegen <sharename>\n\n"
             L"<sharename>  - Specifies the share to create\n"
             );
    exit (-1);
}


VOID
BuildMemDbTestData (
    VOID
    );

BOOL
SearchDomainsForUserAccounts (
    VOID
    );

VOID
DoCreateShares (
    VOID
    );


INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{
    INT i;
    PCWSTR ShareName = NULL;
    PCWSTR p;
    PCWSTR Path = L"C:\\TEMP";
    PCWSTR Remark = L"ShareGen test share";
    PCWSTR Password = L"";
    DWORD Members;
    GROWBUFFER NameList = GROWBUF_INIT;

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {
            case 'i':
                if (!argv[i][2] && (i + 1) < argc) {
                    i++;
                    p = argv[i];
                } else if (argv[i][2] == ':') {
                    p = &argv[i][3];
                } else {
                    HelpAndExit();
                }
                break;

            default:
                HelpAndExit();
            }
        } else {
            if (ShareName) {
                HelpAndExit();
            } else {
                ShareName = argv[i];
            }
        }
    }

    if (!ShareName) {
        HelpAndExit();
    }

    if (!Init()) {
        wprintf (L"Unable to initialize!\n");
        return 255;
    }

    //
    // Generate data as it would be generated during the report phase
    //

    BuildMemDbTestData();

    //
    // Call the routines that do migration based on memdb
    //

    SearchDomainsForUserAccounts();
    DoCreateShares();

    Terminate();

    return 0;
}



typedef struct {
    WCHAR UserName[64];
    DWORD Permissions;
} USERATTRIBS, *PUSERATTRIBS;

VOID
pAddShare (
    PCWSTR ShareName,
    PCWSTR Remark,
    PCWSTR Path,
    DWORD AccessFlags,
    PCWSTR RoPassword,              OPTIONAL
    PCWSTR RwPassword,              OPTIONAL
    PUSERATTRIBS UserList           OPTIONAL
    )
{
    //
    // Add each field to memdb
    //

    MemDbSetValueEx (
        MEMDB_CATEGORY_NETSHARES,
        ShareName,
        MEMDB_FIELD_REMARK,
        Remark,
        0,
        NULL
        );

    MemDbSetValueEx (
        MEMDB_CATEGORY_NETSHARES,
        ShareName,
        MEMDB_FIELD_PATH,
        Path,
        0,
        NULL
        );

    if (UserList) {
        while (*UserList->UserName) {

            MemDbSetValueEx (
                MEMDB_CATEGORY_NETSHARES,
                ShareName,
                MEMDB_FIELD_ACCESS_LIST,
                UserList->UserName,
                UserList->Permissions,
                NULL
                );

            UserList++;
        }

        AccessFlags |= SHI50F_ACLS;
    }

    MemDbSetValueEx (
        MEMDB_CATEGORY_NETSHARES,
        ShareName,
        NULL,
        NULL,
        AccessFlags,
        NULL
        );

    if (RoPassword) {
        MemDbSetValueEx (
            MEMDB_CATEGORY_NETSHARES,
            ShareName,
            MEMDB_FIELD_RO_PASSWORD,
            RoPassword,
            0,
            NULL
            );
    }

    if (RwPassword) {
        MemDbSetValueEx (
            MEMDB_CATEGORY_NETSHARES,
            ShareName,
            MEMDB_FIELD_RW_PASSWORD,
            RwPassword,
            0,
            NULL
            );
    }
}


VOID
pAddUserToList (
    IN OUT  PGROWBUFFER List,
    IN      PCWSTR UserName,
    IN      DWORD Win9xAccessFlags
    )
{
    PUSERATTRIBS User;

    User = (PUSERATTRIBS) GrowBuffer (List, sizeof (USERATTRIBS));
    if (!User) {
        wprintf (L"Can't alloc memory!\n");
        exit (-1);
    }

    StringCopyW (User->UserName, UserName);
    User->Permissions = Win9xAccessFlags;

    if (*UserName) {
        if (wcschr (UserName, L'\\')) {
            MemDbSetValueEx (
                MEMDB_CATEGORY_KNOWNDOMAIN,
                User->UserName,
                NULL,
                NULL,
                0,
                NULL
                );
        } else {
            MemDbSetValueEx (
                MEMDB_CATEGORY_KNOWNDOMAIN,
                L"",
                !StringCompare (User->UserName, L"*") ? L"Everyone" : User->UserName,
                NULL,
                0,
                NULL
                );
        }

    }

}


VOID
pAddShareLevelShare (
    IN      PCWSTR ShareName,
    IN      PCWSTR Remark,
    IN      PCWSTR Path,
    IN      DWORD Win9xAccessFlags,
    IN      PCWSTR RoPassword,      OPTIONAL
    IN      PCWSTR RwPassword
    )
{
    //
    // Add the share to memdb
    //

    pAddShare (
        ShareName,
        Remark,
        Path,
        Win9xAccessFlags,
        RoPassword,
        RwPassword,
        NULL
        );
}

VOID
pAddUserLevelShare (
    IN      PCWSTR ShareName,
    IN      PCWSTR Remark,
    IN      PCWSTR Path,
    IN      PCWSTR UserMultiSz
    )
{
    GROWBUFFER List = GROWBUF_INIT;
    MULTISZ_ENUM e;
    PWSTR p;
    DWORD Win9xAccessFlags;
    PWSTR DupStr;
    PCWSTR q;

    DupStr = DuplicateText (UserMultiSz);
    p = wcschr (DupStr, L'|');
    while (p) {
        *p = 0;
        p = wcschr (p + 1, L'|');
    }


    //
    // Convert multi-sz of user names (with optional attributes)
    // into simple structure
    //

    q = DupStr;
    while (*q) {

        p = wcschr (q, L'=');

        if (p) {
            *p = 0;
            p++;
            Win9xAccessFlags = _wtoi (p);
        } else {
            p = (PWSTR) q;
            Win9xAccessFlags = 0;
        }

        pAddUserToList (&List, q, Win9xAccessFlags);

        q = GetEndOfStringW (p) + 1;
    }

    pAddUserToList (&List, L"", 0);

    //
    // Add the share to memdb
    //

    pAddShare (
        ShareName,
        Remark,
        Path,
        0,
        NULL,
        NULL,
        (PUSERATTRIBS) List.Buf
        );

    FreeGrowBuffer (&List);
    FreeText (DupStr);
}


VOID
BuildMemDbTestData (
    VOID
    )
{
    WCHAR AccessStr[1024];

#if 0
    pAddShareLevelShare (L"TestRO", L"sharegen test", L"c:\\temp", SHI50F_RDONLY, NULL, NULL);
    pAddShareLevelShare (L"TestRW", L"sharegen test", L"c:\\temp", SHI50F_FULL, NULL, NULL);
    pAddShareLevelShare (L"TestNone", L"sharegen test", L"c:\\temp", 0, NULL, NULL);

    wsprintfW (AccessStr, L"read=%u|write=%u|all=%u|mrnone=0|", W95_GENERIC_READ, W95_GENERIC_WRITE, W95_GENERIC_FULL);
    pAddUserLevelShare (L"User1", L"remark", L"c:\\temp", AccessStr);

#endif

    wsprintfW (AccessStr, L"*=%u|", 0xb7);
    pAddUserLevelShare (L"User2", L"remark", L"c:\\temp", AccessStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\strtabs\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\regrep\regrep.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    regrep.c

Abstract:

    Implements a registry search/replace tool.

Author:

    Jim Schmidt (jimschm) 19-Apr-1999

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

#ifdef DEBUG

#pragma message ("WARNING: Checked builds are very slow")

#endif

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        TEXT("  regrep <srch> <rep> [-r:root] [-p]\n")

        TEXT("\nDescription:\n\n")

        TEXT("  RegRep implements a registry search and replace.  It updates\n")
        TEXT("  all instances of <srch> with <rep>.\n")

        TEXT("\nArguments:\n\n")

        TEXT("  <srch>  Specifies the search text\n")
        TEXT("  <rep>   Specifies the replace text\n")
        TEXT("  -r      Specifies the root key to process, such as HKLM\\Software.\n")
        TEXT("          If not specified, the entire registry is processed.\n")
        TEXT("  -p      Enables progress output\n")

        );

    exit (1);
}


VOID
pUpdateKeyNames (
    IN      PCTSTR Search,
    IN      PCTSTR Replace,
    IN      PCTSTR RootKey
    );

VOID
pUpdateValueNames (
    IN      PCTSTR Search,
    IN      PCTSTR Replace,
    IN      PCTSTR RootKey
    );

VOID
pUpdateValueData (
    IN      PCTSTR Search,
    IN      PCTSTR Replace,
    IN      PCTSTR RootKey
    );


BOOL g_ShowProgress = FALSE;


VOID
pProgress (
    VOID
    )
{
    static CHAR String[] = "...... ";
    static DWORD Ticks = 0;
    PSTR p;

    if (GetTickCount() - Ticks < 500) {
        return;
    }

    Ticks = GetTickCount();

    if (!g_ShowProgress) {
        return;
    }

    p = strchr (String, ' ');
    *p = '.';
    p++;
    if (!*p) {
        p = String;
    }
    *p = ' ';

    printf ("%s\r", String);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR Root = NULL;
    PCTSTR Search = NULL;
    PCTSTR Replace = NULL;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('r'):

                if (Root) {
                    HelpAndExit();
                }

                if (argv[i][2] == TEXT(':')) {
                    Root = &argv[i][3];
                } else if (i + 1 < argc) {
                    Root = argv[++i];
                } else {
                    HelpAndExit();
                }

                break;

            case TEXT('p'):
                if (g_ShowProgress) {
                    HelpAndExit();
                }

                g_ShowProgress = TRUE;
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (!Search) {
                Search = argv[i];
            } else if (!Replace) {
                Replace = argv[i];
            } else {
                HelpAndExit();
            }
        }
    }

    if (!Replace) {
        HelpAndExit();
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // Pass one - fix all the registry key names
    //

    if (!Root) {
        pUpdateKeyNames (Search, Replace, TEXT("HKLM"));
        pUpdateKeyNames (Search, Replace, TEXT("HKU"));
    } else {
        pUpdateKeyNames (Search, Replace, Root);
    }

    //
    // Pass two - fix all value names
    //

    if (!Root) {
        pUpdateValueNames (Search, Replace, TEXT("HKLM"));
        pUpdateValueNames (Search, Replace, TEXT("HKU"));
    } else {
        pUpdateValueNames (Search, Replace, Root);
    }

    //
    // Pass three - fix all value data
    //

    if (!Root) {
        pUpdateValueData (Search, Replace, TEXT("HKLM"));
        pUpdateValueData (Search, Replace, TEXT("HKU"));
    } else {
        pUpdateValueData (Search, Replace, Root);
    }


    //
    // End of processing
    //

    Terminate();

    return 0;
}



VOID
pMoveKey (
    IN      PCTSTR SourceKey,
    IN      PCTSTR DestKey
    )
{
    HKEY Src;
    HKEY Dest;
    REGVALUE_ENUM e;
    DWORD Size;
    PBYTE Data;
    LONG rc;
    GROWBUFFER Buf = GROWBUF_INIT;

    Src = OpenRegKeyStr (SourceKey);
    Dest = CreateRegKeyStr (DestKey);

    pProgress();

    if (Src && Dest) {
        if (EnumFirstRegValue (&e, Src)) {

            Buf.End = 0;
            Data = GrowBuffer (&Buf, e.DataSize);
            if (Data) {

                Size = e.DataSize;
                rc = RegQueryValueEx (
                        Src,
                        e.ValueName,
                        NULL,
                        NULL,
                        Data,
                        &Size
                        );

                if (rc == ERROR_SUCCESS) {

                    rc = RegSetValueEx (Dest, e.ValueName, 0, e.Type, Data, Size);
                }
            }
        }
    }

    CloseRegKey (Src);
    CloseRegKey (Dest);

    FreeGrowBuffer (&Buf);
}


VOID
pMoveKeyTree (
    IN      PCTSTR SourceKey,
    IN      PCTSTR DestKey
    )
{
    REGTREE_ENUM e;
    TCHAR DestSubKey[MAX_REGISTRY_KEY];
    PTSTR p;
    GROWLIST List = GROWLIST_INIT;
    UINT Count;
    UINT u;
    PCTSTR Item;
    DWORD Len;

    StringCopy (DestSubKey, DestKey);
    p = AppendWack (DestSubKey);

    if (EnumFirstRegKeyInTree (&e, SourceKey)) {

        do {

            StringCopy (p, (PCTSTR) ((PBYTE) e.FullKeyName + e.EnumBaseBytes));
            pMoveKey (e.FullKeyName, DestSubKey);
            GrowListAppendString (&List, e.FullKeyName);

        } while (EnumNextRegKeyInTree (&e));
    }

    Count = GrowListGetSize (&List);

    u = Count;
    while (u > 0) {
        u--;

        Item = GrowListGetString (&List, u);

        ConvertRootStringToKey (Item, &Len);
        RegDeleteKey (ConvertRootStringToKey (Item, NULL), Item + Len);
    }

    FreeGrowList (&List);
}


VOID
pUpdateKeyNames (
    IN      PCTSTR Search,
    IN      PCTSTR Replace,
    IN      PCTSTR RootKey
    )
{
    REGTREE_ENUM e;
    GROWLIST List = GROWLIST_INIT;
    UINT Count;
    UINT u;
    PCTSTR OldKey;
    PCTSTR NewKey;

    if (g_ShowProgress) {
        _tprintf ("Scanning for keys to update\n");
    }

    if (EnumFirstRegKeyInTree (&e, RootKey)) {
        do {
            pProgress();

            if (_tcsistr (e.CurrentKey->KeyName, Search)) {
                GrowListAppendString (&List, e.FullKeyName);
            }
        } while (EnumNextRegKeyInTree (&e));
    }

    Count = GrowListGetSize (&List);
    u = Count;

    if (g_ShowProgress) {
        _tprintf ("Updating %u keys\n", Count);
    }

    while (u > 0) {
        u--;

        _tprintf (TEXT("%s\n"), GrowListGetString (&List, u));

        OldKey = GrowListGetString (&List, u);
        NewKey = StringSearchAndReplace (
                    OldKey,
                    Search,
                    Replace
                    );

        pMoveKeyTree (OldKey, NewKey);
    }

    FreeGrowList (&List);
}


VOID
pUpdateValueNames (
    IN      PCTSTR Search,
    IN      PCTSTR Replace,
    IN      PCTSTR RootKey
    )
{
    REGTREE_ENUM e;
    REGVALUE_ENUM ev;
    GROWLIST List = GROWLIST_INIT;
    HKEY Key;
    UINT Count;
    UINT u;
    PBYTE Data;
    DWORD Type;
    DWORD Size;
    PCTSTR ValueName;
    PCTSTR NewValueName;
    BOOL b;
    LONG rc;

    if (g_ShowProgress) {
        _tprintf ("Processing all value names in the keys\n");
    }

    if (EnumFirstRegKeyInTree (&e, RootKey)) {

        do {
            pProgress();

            Key = OpenRegKeyStr (e.FullKeyName);

            if (Key) {
                if (EnumFirstRegValue (&ev, Key)) {
                    do {
                        if (_tcsistr (ev.ValueName, Search)) {
                            GrowListAppendString (&List, ev.ValueName);
                        }
                    } while (EnumNextRegValue (&ev));

                    Count = GrowListGetSize (&List);
                    u = Count;

                    while (u > 0) {
                        u--;

                        ValueName = GrowListGetString (&List, u);

                        b = FALSE;

                        if (GetRegValueTypeAndSize (Key, ValueName, &Type, &Size)) {

                            Data = GetRegValueData (Key, ValueName);
                            if (Data) {
                                NewValueName = StringSearchAndReplace (
                                                    ValueName,
                                                    Search,
                                                    Replace
                                                    );

                                rc = RegSetValueEx (Key, NewValueName, 0, Type, Data, Size);

                                if (rc == ERROR_SUCCESS) {
                                    if (!StringIMatch (ValueName, NewValueName)) {
                                        rc = RegDeleteValue (Key, ValueName);
                                    }
                                }

                                MemFree (g_hHeap, 0, Data);
                                FreePathString (NewValueName);
                                SetLastError (rc);

                                b = (rc == ERROR_SUCCESS);
                            }
                        }

                        if (b) {
                            _tprintf (TEXT("%s [%s]\n"), e.FullKeyName, ValueName);
                        } else {
                            _ftprintf (stderr, TEXT("Error %u updating %s [%s]\n"), GetLastError(), e.FullKeyName, ValueName);
                        }
                    }
                }

                FreeGrowList (&List);
                CloseRegKey (Key);

            } else {
                _ftprintf (stderr, TEXT("Can't open %s\n"), Key);
            }

        } while (EnumNextRegKeyInTree (&e));
    }
}


VOID
pUpdateValueData (
    IN      PCTSTR Search,
    IN      PCTSTR Replace,
    IN      PCTSTR RootKey
    )
{
    REGTREE_ENUM e;
    REGVALUE_ENUM ev;
    HKEY Key;
    PCTSTR Data;
    PCTSTR NewData;
    LONG rc;

    if (g_ShowProgress) {
        _tprintf ("Processing all value data\n");
    }

    if (EnumFirstRegKeyInTree (&e, RootKey)) {

        do {
            pProgress();

            Key = OpenRegKeyStr (e.FullKeyName);

            if (Key) {
                if (EnumFirstRegValue (&ev, Key)) {
                    do {
                        Data = GetRegValueString (Key, ev.ValueName);

                        if (Data) {
                            if (_tcsistr (Data, Search)) {

                                NewData = StringSearchAndReplace (Data, Search, Replace);
                                rc = RegSetValueEx (Key, ev.ValueName, 0, ev.Type, NewData, SizeOfString (NewData));

                                if (rc == ERROR_SUCCESS) {
                                    _tprintf (TEXT("%s [%s] %s\n"), e.FullKeyName, ev.ValueName, Data);
                                } else {
                                    _ftprintf (stderr, TEXT("Error %u updating %s [%s] %s\n"), GetLastError(), e.FullKeyName, ev.ValueName, Data);
                                }

                                FreePathString (NewData);
                            }

                            MemFree (g_hHeap, 0, Data);
                        }

                    } while (EnumNextRegValue (&ev));
                }

                CloseRegKey (Key);

            } else {
                _ftprintf (stderr, TEXT("Can't open %s\n"), Key);
            }
        } while (EnumNextRegKeyInTree (&e));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\sysmig\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\sysmig\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\sethashpwd\setpwd.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    setpwd.c

Abstract:

    Test for SamiChangePasswordUser NT security API.

Author:

    Ovidiu Temereanca   17-Mar-2000     Initial implementation

Revision History:



--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>

#include <windef.h>
#include <winbase.h>

#include <align.h>
#include <lm.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <limits.h>
#include <rpcutil.h>
#include <secobj.h>
#include <stddef.h>
#include <ntdsapi.h>
#include <dsgetdc.h>

#include <windows.h>
#include <setupapi.h>

#include "common.h"
#include "migutil.h"
#include "encrypt.h"

#include <ntsamp.h>


DWORD
CreateLocalAccount (
    IN      PWSTR User,
    IN      PWSTR OldPassword,
    IN      PWSTR NewPassword,
    IN      BOOL EncryptedPwd
   );


HINSTANCE g_hInst;
HANDLE g_hHeap;

typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);

INITROUTINE_PROTOTYPE MigUtil_Entry;

BOOL
Init (
    VOID
   )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    g_hInst = GetModuleHandle (NULL);
    g_hHeap = GetProcessHeap();

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        _tprintf (TEXT("MigUtil failed initializing\n"));
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
   )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the exit routine that requires library APIs
    //

    MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL);
}


INT
__cdecl
_tmain (
    INT argc,
    TCHAR *argv[]
   )
{
    NTSTATUS rc;
    PWSTR oldHash, newHash;
    BOOL encrypted;
    INT i;

    if (argc < 4) {
        _tprintf (TEXT("Usage:\n")
                  TEXT("    setpwd [/e] <LocalUserName> <oldpwd_hash> <newpwd_hash>\n")
                  TEXT("    /e - if specified, password is a hash value; otherwise it's in clear")
                  TEXT("Use quotes if any arg contains spaces\n")
                  TEXT("Use dot as a placeholder for the empty password hash value\n")
                 );
        return 1;
    }

    if (!Init()) {
        _tprintf (TEXT("Unable to initialize!\n"));
        return 2;
    }

    if ((argv[1][0] == TEXT('/') || argv[1][0] == TEXT('-')) &&
        _totlower(argv[1][1]) == TEXT('e')
       ) {
        encrypted = TRUE;
        i = 2;
    } else {
        encrypted = FALSE;
        i = 1;
    }

    if (StringMatch (argv[i + 1], TEXT("."))) {
        oldHash = NULL;
    } else {
        oldHash = argv[i + 1];
    }
    if (StringMatch (argv[i + 2], TEXT("."))) {
        newHash = NULL;
    } else {
        newHash = argv[i + 2];
    }

    rc = CreateLocalAccount (argv[i], oldHash, newHash, encrypted);
    if (rc != NO_ERROR) {
        _tprintf (TEXT("CreateLocalAccount failed (status = %lu)\n"), rc);
    }

    Terminate();

    return rc;
}


DWORD
CreateLocalAccount (
    IN      PWSTR User,
    IN      PWSTR OldPassword,
    IN      PWSTR NewPassword,
    IN      BOOL EncryptedPwd
   )

/*++

Routine Description:

    CreateLocalAccount creates an account for a local user

Arguments:

    Properties  - Specifies a set of attributes for a user

    User        - An optional name to override Properties->User

Return value:

    A Win32 error code

--*/

{
    USER_INFO_3 ui;
    PUSER_INFO_3 ExistingInfo;
    DWORD rc;
    LONG ErrParam;

    //
    // Create local account
    //

    ZeroMemory (&ui, sizeof (ui));
    ui.usri3_name       = User;
    ui.usri3_password   = EncryptedPwd ? TEXT("GigiMarga@123456") : NewPassword;
    ui.usri3_comment    = TEXT("TestAccount");
    ui.usri3_full_name  = TEXT("Full name");

    ui.usri3_priv         = USER_PRIV_USER;
    ui.usri3_flags        = UF_SCRIPT|UF_NORMAL_ACCOUNT;
    ui.usri3_acct_expires = TIMEQ_FOREVER;
    ui.usri3_max_storage  = USER_MAXSTORAGE_UNLIMITED;

    ui.usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;
    ui.usri3_max_storage = USER_MAXSTORAGE_UNLIMITED;
    ui.usri3_acct_expires = TIMEQ_FOREVER;

    ui.usri3_password_expired = FALSE;

    rc = NetUserDel (NULL, User);
    rc = NetUserAdd (NULL, 3, (PBYTE) &ui, &ErrParam);

    if (rc == ERROR_SUCCESS) {
        if (EncryptedPwd) {
            //
            // change user's password using encrypted password APIs
            //
            rc = SetLocalUserEncryptedPassword (
                    User,
                    TEXT("aad3b435b51404eeaad3b435b51404ee64d208a23ff2f0482eb02f6f267e97ea"),
                    TRUE,
                    NewPassword,
                    TRUE
                   );
            if (rc != ERROR_SUCCESS) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "Can't set encrypted password on user %s, rc=%u",
                    User,
                    rc
                   ));

                rc = ERROR_SUCCESS;
            }
        }
    } else {
        if (rc == NERR_UserExists) {
            //
            // Try to change password if user already exists and this is the intent
            //

            DEBUGMSG ((DBG_WARNING, "User %s already exists", User));

            if (EncryptedPwd) {
            rc = SetLocalUserEncryptedPassword (
                    User,
                    TEXT("65c5c4e1e98d8bada13f0882c43aca5810fec09fb8c9d1b9d065c2d6d75fc582"),
                    TRUE,
                    NewPassword,
                    TRUE
                   );
                if (rc != ERROR_SUCCESS) {
                    DEBUGMSG ((
                        DBG_WARNING,
                        "Can't set encrypted password on user %s, rc=%u",
                        User,
                        rc
                       ));

                    rc = ERROR_SUCCESS;
                }
            } else {
                rc = NetUserGetInfo (NULL, User, 3, (PBYTE *) &ExistingInfo);
                if (rc == ERROR_SUCCESS) {
                    ExistingInfo->usri3_password  = ui.usri3_password;
                    ExistingInfo->usri3_comment   = ui.usri3_comment;
                    ExistingInfo->usri3_full_name = ui.usri3_full_name;
                    ExistingInfo->usri3_flags     = ui.usri3_flags;
                    ExistingInfo->usri3_password_expired = ui.usri3_password_expired;

                    rc = NetUserSetInfo (NULL, User, 3, (PBYTE) ExistingInfo, &ErrParam);

                    NetApiBufferFree ((PVOID) ExistingInfo);

                    if (rc != ERROR_SUCCESS) {
                        DEBUGMSG ((
                            DBG_WARNING,
                            "Can't set info on user %s, rc=%u, ErrParam=%u",
                            User,
                            rc,
                            ErrParam
                           ));

                        rc = ERROR_SUCCESS;
                    }
                } else {
                    DEBUGMSG ((DBG_WARNING, "Can't get info for user %s, rc=%u", User, rc));
                    rc = ERROR_SUCCESS;
                }
            }
        }
    }

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((LOG_ERROR, "NetUserAdd failed for %s. ErrParam=%i.", User, ErrParam));
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\tztest\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\tztest\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\signcabs\signcabs.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    signcabs.c

Abstract:

    Signcabs enumerates all of the cabinet files in a directory, expands them, and creates the .lst file
    neeeded by the build signing tools.

Author:

    Marc R. Whitten (marcw) 31-Jul-1998

Revision History:



--*/

#include "pch.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);
}


BOOL
pDeleteAllFiles (
    IN PCWSTR DirPath
    )
{
    TREE_ENUM e;
    BOOL dirsFirst = FALSE;

    if (EnumFirstFileInTree (&e, DirPath, TEXT("*"), dirsFirst)) {
        do {
            if (e.Directory) {
                pDeleteAllFiles (e.FullPath);
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                RemoveDirectory (e.FullPath);
            }
            else {
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (e.FullPath);
            }
        } while (EnumNextFileInTree (&e));
    }
    return TRUE;
}

void
usage (
    VOID
    )
{

    printf (
        "Command Line Usage:\n"
        "signcabs [-ch] [filedir] [tempdir]\n\n"
        "   -c      - Clean out temporary directory if it exists.\n"
        "   -h      - This message.\n"
        "   filedir - Directory containing files to be processed.\n"
        "   tempdir - Directory to store results.\n"
        );
}


INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{
    PWSTR tempDir = NULL;
    PWSTR fileDir = NULL;
    TREE_ENUM e;
    HANDLE h = INVALID_HANDLE_VALUE;
    PWSTR listFilePath;
    BOOL clean = FALSE;
    INT i;

    if (!Init()) {
        wprintf (L"Unable to initialize!\n");
        return 255;
    }


    //
    //  Parse command line.
    //
    for (i = 1; i < argc; i++) {

        if (argv[i][0] == L'-' || argv[i][0] == L'\\') {
            switch (argv[i][1]) {

            case L'c': case L'C':
                clean = TRUE;
                break;
            default:
                usage();
                return 0;
                break;
            }

        }
        else if (!fileDir) {
            fileDir = argv[i];
        }
        else if (!tempDir) {
            tempDir = argv[i];
        }
        else {
            usage();
            return 0;
        }
    }

    //
    // One of the nice things about writing the tool is that you get to create silly
    // defaults that only work for you.
    //
    if (!tempDir) tempDir = L"e:\\signcabs";
    if (!fileDir) fileDir = L"e:\\nt\\private\\redist\\migdlls\\mapi";


    //
    // First, check to see if the temporary directory exists.
    //
    if (CreateDirectory (tempDir, NULL) == 0) {

        if (GetLastError () == ERROR_ALREADY_EXISTS) {
            if (clean) {
                pDeleteAllFiles (tempDir);
            }
        }
        else {
            wprintf (L"SIGNCABS: Cannot create directory %ws. (gle: %d)\n", tempDir, GetLastError ());
        }
    }

    wprintf (L"SIGNCABS: Creating .lst file for all cabs found under %ws.\n",fileDir);

    if (!ExpandAllFiles (fileDir, tempDir)) {
        wprintf (L"SIGNCABS: Error while expanding cabinet files from %ws to %ws (%d)\n",fileDir, tempDir, GetLastError ());
    }

    //
    // Now, enumerate through all of the files and create the lst file.
    //
    listFilePath = JoinPaths (tempDir, L"cabs.lst");

    h = CreateFile (listFilePath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (h == INVALID_HANDLE_VALUE) {
        wprintf (L"SIGNCABS: Error while trying to create %ws. (%d)\n", listFilePath, GetLastError());
        return GetLastError();
    }

    FreePathString (listFilePath);

    if (EnumFirstFileInTree (&e, tempDir, TEXT("*"), FALSE)) {
        do {
            if (!e.Directory) {
                WriteFileString (h, L"<hash>");
                WriteFileString (h, e.FullPath);
                WriteFileString (h, L"=");
                WriteFileString (h, e.FullPath);
                WriteFileString (h, L"\r\n");
            }
        } while (EnumNextFileInTree (&e));
    }

    CloseHandle (h);

    wprintf (L"SIGNCABS: Done.\n");


    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\upgwiz\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\strmap\strmap.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    strmap.c

Abstract:

    Tests the string mapping mechanism for correctness and performance.

Author:

    Jim Schmidt (jimschm)   19-Aug-1998

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pTheFooFilter (
    IN OUT  PREG_REPLACE_DATA Data
    );


VOID
pStandardSearchAndReplace (
    IN      PGROWBUFFER Pairs,
    IN OUT  PTSTR Buffer,
    IN      UINT BufferSize
    );


BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (!MigUtil_Entry (Instance, Reason, NULL)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    _ftprintf (
        stderr,
        TEXT("Command Line Syntax:\n\n")

        TEXT("  strmap [/D] [/N:<strings>] [/T[:<count>]] [/M|/S] [/F]\n")

        TEXT("\nDescription:\n\n")

        TEXT("  strmap tests CreateStringMapping and MappingSearchAndReplace.\n")

        TEXT("\nArguments:\n\n")

        TEXT("  /D  Dump out string before and after test\n")
        TEXT("  /N  Specifies the number of strings to map\n")
        TEXT("  /T  Enables timing mode, <count> specifies number of tests to time\n")
        TEXT("  /M  Times the mapping APIs\n")
        TEXT("  /S  Times standard strnicmp and strcpy method\n")
        TEXT("  /F  Enables the FOO filter function\n")

        );

    exit (1);
}


PCTSTR
pGenerateRandomString (
    OUT     PTSTR Ptr,
    IN      INT MinLength,
    IN      INT MaxLength
    )
{
    INT Length;
    INT i;
    PTSTR p;

    Length = rand() * MaxLength / RAND_MAX;
    Length = max (MinLength, Length);

    p = Ptr;

    for (i = 0 ; i < Length ; i++) {
        //*p++ = rand() * 224 / RAND_MAX + 32;
        *p++ = rand() * 26 / RAND_MAX + 65;
    }

    *p = 0;

    return Ptr;
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR NumberArg;
    INT Strings = 10;
    INT TestCount = 0;
    PMAPSTRUCT Map;
    TCHAR Old[256];
    TCHAR New[256];
    TCHAR Buffer[256];
    DWORD StartTick;
    GROWBUFFER Pairs = GROWBUF_INIT;
    BOOL TestMapApi = TRUE;
    BOOL Dump = FALSE;
    BOOL FooFilter = FALSE;

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower ((CHARTYPE) _tcsnextc (&argv[i][1]))) {

            case TEXT('d'):
                //
                // /d (dump on)
                //

                Dump = TRUE;
                break;

            case TEXT('f'):
                //
                // /f (enable the FOO filter function)
                //

                FooFilter = TRUE;
                break;

            case TEXT('m'):
                //
                // /m (test map api)
                //

                TestMapApi = TRUE;
                break;

            case TEXT('s') :
                //
                // /s (test normal string apis)
                //

                TestMapApi = FALSE;
                break;


            case TEXT('n'):
                //
                // /n:<strings>
                //

                if (argv[i][2] == TEXT(':')) {
                    NumberArg = &argv[i][3];
                } else if (i + 1 < argc) {
                    NumberArg = argv[++i];
                } else {
                    HelpAndExit();
                }

                Strings = _ttoi (NumberArg);
                if (Strings < 1) {
                    HelpAndExit();
                }

                break;

            case TEXT('t'):
                //
                // /t[:<count>]
                //

                if (argv[i][2] == TEXT(':')) {

                    NumberArg = &argv[i][3];
                    TestCount = _ttoi (NumberArg);
                    if (TestCount < 1) {
                        HelpAndExit();
                    }

                } else if (argv[i][2]) {
                    HelpAndExit();
                } else {
                    TestCount = 1000;
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // Create mapping
    //

    Map = CreateStringMapping();

    //
    // Generate random mapping pairs
    //

    for (i = 0 ; i < Strings ; i++) {
        AddStringMappingPair (
            Map,
            pGenerateRandomString (Old, 1, 20),
            pGenerateRandomString (New, 0, 20)
            );

        _tprintf (TEXT("From: %s\nTo: %s\n\n"), Old, New);

        CharLower (Old);

        GrowBufAppendDword (&Pairs, ByteCount (Old));
        MultiSzAppend (&Pairs, Old);
        GrowBufAppendDword (&Pairs, ByteCount (New));
        MultiSzAppend (&Pairs, New);
    }

    if (FooFilter) {
        AddStringMappingPairEx (Map, TEXT("FOO"), TEXT("**BAR**"), pTheFooFilter);
    }

    StartTick = GetTickCount();

    if (TestMapApi) {
        for (i = 0 ; i < TestCount ; i++) {
            StringCopy (Buffer, pGenerateRandomString (Old, 10, sizeof (Buffer) / (4 * sizeof (TCHAR))));
            MappingSearchAndReplace (Map, Buffer, sizeof (Buffer));

            if (Dump) {
                _tprintf (TEXT("Old: %s\nNew: %s\n\n"), Old, Buffer);
            }
        }

        if (TestCount) {
            _tprintf (TEXT("\nMappingSearchAndReplace: Test of %i strings took %u ms\n"), TestCount, GetTickCount() - StartTick);
        }
    } else {

        StartTick = GetTickCount();

        for (i = 0 ; i < TestCount ; i++) {
            StringCopy (Buffer, pGenerateRandomString (Old, 10, sizeof (Buffer) / (4 * sizeof (TCHAR))));

            pStandardSearchAndReplace (&Pairs, Buffer, sizeof (Buffer));

            if (Dump) {
                _tprintf (TEXT("Old: %s\nNew: %s\n\n"), Old, Buffer);
            }
        }

        if (TestCount) {
            _tprintf (TEXT("\nStandard stricmp: Test of %i strings took %u ms\n"), TestCount, GetTickCount() - StartTick);
        }
    }

    //
    // Clean up mapping
    //

    DestroyStringMapping (Map);
    FreeGrowBuffer (&Pairs);

    //
    // End of processing
    //

    Terminate();

    return 0;
}


VOID
pStandardSearchAndReplace (
    IN      PGROWBUFFER Pairs,
    IN OUT  PTSTR Buffer,
    IN      UINT BufferSize
    )
{
    TCHAR WorkBuffer[256];
    TCHAR LowerBuffer[256];
    PCTSTR Src;
    PCTSTR RealSrc;
    PTSTR Dest;
    PDWORD OldByteCount;
    PDWORD NewByteCount;
    PCTSTR Old;
    PCTSTR New;
    UINT u;
    UINT OutboundLen;
    UINT a, b;

    RealSrc = Buffer;
    Src = LowerBuffer;
    Dest = WorkBuffer;
    OutboundLen = ByteCount (Buffer);

    StringCopy (LowerBuffer, Buffer);
    CharLower (LowerBuffer);

    BufferSize -= sizeof (TCHAR);

    while (*Src) {
        u = 0;
        while (u < Pairs->End) {
            OldByteCount = (PDWORD) (Pairs->Buf + u);
            Old = (PCTSTR) (OldByteCount + 1);
            NewByteCount = (PDWORD) ((PBYTE) OldByteCount + *OldByteCount + sizeof (DWORD) + sizeof (TCHAR));
            New = (PCTSTR) (NewByteCount + 1);

            if (!_tcsncmp (Src, Old, *OldByteCount / sizeof (TCHAR))) {
                break;
            }

            u += *OldByteCount + *NewByteCount + sizeof (DWORD) * 2 + sizeof (TCHAR) * 2;
        }

        if (u < Pairs->End) {
            OutboundLen = OutboundLen - *OldByteCount + *NewByteCount;
            if (OutboundLen > BufferSize) {
                DEBUGMSG ((DBG_WHOOPS, "String got too long!"));
                OutboundLen = Dest - WorkBuffer;
                break;
            }

            CopyMemory (Dest, New, *NewByteCount);
            Dest = (PTSTR) ((PBYTE) Dest + *NewByteCount);

            Src = (PCTSTR) ((PBYTE) Src + *OldByteCount);
            RealSrc = (PCTSTR) ((PBYTE) RealSrc + *OldByteCount);
        } else {
            *Dest++ = *RealSrc++;
            Src++;
        }
    }

    *Dest = 0;
    StringCopy (Buffer, WorkBuffer);
}


BOOL
pTheFooFilter (
    IN OUT  PREG_REPLACE_DATA Data
    )
{
    //
    // FOO was found in the string
    //

    _tprintf (TEXT("\"FOO\" was found in the string!!\n\n"));
    _tprintf (
        TEXT("  OriginalString: %s\n")
        TEXT("  CurrentString:  %s\n")
        TEXT("  OldSubString: %s\n")
        TEXT("  NewSubString: %s\n")
        TEXT("  NewSubStringSizeInBytes: %u\n\n"),
        Data->Ansi.OriginalString,
        Data->Ansi.CurrentString,
        Data->Ansi.OldSubString,
        Data->Ansi.NewSubString,
        Data->Ansi.NewSubStringSizeInBytes
        );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\stftest\stftest.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stftest.c

Abstract:

    Runs the STF migration code for development purposes.

Author:

    Jim Schmidt (jimschm)   28-Sep-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();
}


BOOL
ProcessStfFiles (
    VOID
    );


INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{
    if (!Init()) {
        wprintf (L"Unable to initialize!\n");
        return 255;
    }

    MemDbLoad (TEXT("c:\\public\\ntsetup.dat"));
    MemDbDeleteTree (MEMDB_CATEGORY_STF);
    MemDbSetValueEx (MEMDB_CATEGORY_STF, TEXT("c:\\public\\stftest.stf"), NULL, NULL, 0, NULL);

    ProcessStfFiles();

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\usermig\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\usermig\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\upgwiz\pch.h ===
#include "master.h"
#include "master9x.h"
#include "dialogs.h"
#include "..\inc\dgdll.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\upgwiz\dialogs.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dialogs.rc
//
#define IDC_START_OVER                  3
#define IDB_TREE_IMAGES                 133
#define IDD_DATA_TYPE                   200
#define IDD_DATA_OBJECTS                201
#define IDD_SUPPLY_TEXT                 202
#define IDD_DONE                        203
#define IDC_DT_LIST                     1000
#define IDC_TEXT_TITLE                  1050
#define IDC_OBJECTS                     1116
#define IDC_DESCRIPTION                 1117
#define IDC_TEXT_MSG                    1118
#define IDC_DESC_TITLE                  1119
#define IDC_DATA_TYPE                   1120
#define IDC_SELECTION                   1121
#define IDC_SELECTION_TITLE             1122
#define IDC_DONT_SAVE                   1125
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1126
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\strtabs\strtabs.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    strtabs.c

Abstract:

    Tests string table routines.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

#ifdef UNICODE
#pragma message ("You must use UNICODE version of setupapi.dll")
#else
#pragma message ("You must use ANSI version of setupapi.dll")
#endif


BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

HANDLE g_hHeap;
HINSTANCE g_hInst;


VOID
pTest1 (
    VOID
    )
{
    HASHTABLE Table;
    TREE_ENUM e;
    GROWBUFFER Buf = GROWBUF_INIT;
    LONG rc;
    PDWORD dptr;
    DWORD Data;
    HASHTABLE DupTable;

    Table = HtAlloc();

    _tprintf (TEXT("Testing full paths...  "));

    if (EnumFirstFileInTree (&e, TEXT("C:\\"), NULL, FALSE)) {
        do {
            rc = HtAddString (Table, e.FullPath);

            GrowBufAppendDword (&Buf, (DWORD) rc);
            MYASSERT (rc);

        } while (EnumNextFileInTree (&e));
    }

    dptr = (PDWORD) Buf.Buf;

    if (EnumFirstFileInTree (&e, TEXT("C:\\"), NULL, FALSE)) {
        do {
            rc = HtFindString (Table, e.FullPath);

            MYASSERT (rc);
            MYASSERT (*dptr == (DWORD) rc);
            dptr++;
        } while (EnumNextFileInTree (&e));
    }

    _tprintf (TEXT("Done\n"));

    HtFree (Table);


    _tprintf (TEXT("Testing extra data and collisions... "));

    Table = HtAllocWithData (sizeof (DWORD));

    DupTable = HtAlloc();

    Buf.End = 0;

    if (EnumFirstFileInTree (&e, TEXT("C:\\"), NULL, FALSE)) {
        do {
            if (HtFindString (Table, e.Name)) {
                HtAddString (DupTable, e.Name);
            }

            rc = HtAddStringAndData (Table, e.Name, &e.FindData->nFileSizeLow);

            GrowBufAppendDword (&Buf, (DWORD) rc);
            MYASSERT (rc);

        } while (EnumNextFileInTree (&e));
    }

    dptr = (PDWORD) Buf.Buf;

    if (EnumFirstFileInTree (&e, TEXT("C:\\"), NULL, FALSE)) {
        do {
            rc = HtFindStringAndData (Table, e.Name, &Data);

            MYASSERT (rc);

            if (!HtFindString (DupTable, e.Name)) {
                MYASSERT (*dptr == (DWORD) rc);
                MYASSERT (Data == e.FindData->nFileSizeLow);
            }

            dptr++;

        } while (EnumNextFileInTree (&e));
    }

    HtFree (DupTable);
    HtFree (Table);

    _tprintf (TEXT("Done\n"));


    FreeGrowBuffer (&Buf);
}


VOID
pTest2 (
    VOID
    )
{
    HASHTABLE Table;
    TREE_ENUM e;
    INT Count;
    LONG rc;
    HASHTABLE_ENUM e2;
    WIN32_FIND_DATA fd;

    _tprintf (TEXT("Testing enumeration... "));

    Count = 0;

    Table = HtAlloc();

    if (EnumFirstFileInTree (&e, TEXT("C:\\"), NULL, FALSE)) {
        do {
            rc = HtAddString (Table, e.FullPath);

            Count++;
            MYASSERT (rc);

        } while (EnumNextFileInTree (&e));
    }

    if (EnumFirstHashTableString (&e2, Table)) {
        do {
            MYASSERT (DoesFileExistEx (e2.String, &fd));
            Count--;
        } while (EnumNextHashTableString (&e2));
    }

    MYASSERT (Count == 0);

    _tprintf (TEXT("Done\n"));

    HtFree (Table);
}


VOID
pTest3 (
    VOID
    )
{
    HASHTABLE Table;
    LONG rc;
    LONG rc2;
    BOOL Pass = TRUE;
    TCHAR String[6];
    INT i;
    UINT u = 0;
    ZeroMemory (String, sizeof (String));
    String[0] = 1;

    _tprintf (TEXT("Testing every character combination..."));

    while (String[4] == 0) {
        if (Pass) {
            u++;

            if ((u % 10000) == 0) {
                _tprintf (TEXT("."));
            }

            if (!u) {
                break;
            }
        }

#if 0
        Table = StringTableInitialize();

        rc = StringTableAddString(
                Table,
                String,
                STRTAB_CASE_INSENSITIVE
                );

        rc2 = StringTableLookUpString (Table, String, STRTAB_CASE_INSENSITIVE);

        StringTableDestroy (Table);
#endif

        Table = HtAlloc();

        rc = HtAddString (Table, String);

        rc2 = HtFindString (Table, String);

        HtFree (Table);

        if (!Pass) {
            break;
        }

        if (rc != rc2) {
            Pass = FALSE;

            //
            // We go through this loop once more against the same string,
            // to make debugging easy.
            //

        } else {
            for (i = 0 ; i < 5 ; i++) {
                String[i]++;
                if (String[i] != 0) {
                    break;
                }
                String[i]++;
            }
        }

    }

    _tprintf (TEXT("\n"));

    if (!Pass) {
        _tprintf (TEXT("Test Failed on test %u!\nString: ["), u, String);

        for (i = 0 ; i < 5 ; i++) {
            _tprintf (TEXT("%c"), String[i]);
        }

        _tprintf (TEXT("]   "));

        for (i = 0 ; i < 5 ; i++) {
#ifdef UNICODE
            _tprintf (TEXT(" %04X"), (WORD) String[i]);
#else
            _tprintf (TEXT(" %02X"), (BYTE) String[i]);
#endif
        }

        _tprintf (TEXT("\n"));

    } else {
        _tprintf (TEXT("Test Passed!\n"));
    }

}


PCTSTR
pStrToHex (
    PTSTR Hex,
    PCTSTR Str
    )
{
    PTSTR p;
    PCTSTR q;

    p = Hex;

    for (q = Str ; *q ; q++) {
#ifdef UNICODE
        p += wsprintf (p, TEXT("%04X "), (WORD) *q);
#else
        p += wsprintf (p, TEXT("%02X "), (BYTE) *q);
#endif
    }

    *p++ = TEXT('\"');
    for (q = Str ; *q ; q++) {
        if (*q < 32 || *q > 255 || *q >= 127) {
            *p++ = TEXT('.');
        } else {
            *p++ = *q;
        }
    }
    *p++ = TEXT('\"');

    *p = 0;

    return Hex;
}


VOID
pTest4 (
    VOID
    )
{
    TCHAR Str[2];
    TCHAR Lower[5];
    INT Result;
    TCHAR Hex1[80];
    TCHAR Hex2[80];
    INT i;
    INT j;

#ifdef UNICODE
    printf ("Testing UNICODE\n\n");
#else
    printf ("Testing DBCS\n\n");
#endif

    ZeroMemory (Str, sizeof (Str));
    Str[0] = 1;

    j = (sizeof (Str) / sizeof (Str[0])) - 1;

    for (;;) {

        lstrcpy (Lower, Str);
        CharLower (Lower);

        Result = CompareString (
                    LOCALE_SYSTEM_DEFAULT,
                    NORM_IGNORECASE,
                    Str,
                    -1,
                    Lower,
                    -1
                    );

        if (Result != CSTR_EQUAL) {
            _tprintf (
                TEXT("ERROR: %s does not match %s, Result=%i\n"),
                pStrToHex (Hex1, Str),
                pStrToHex (Hex2, Lower),
                Result
                );

        } else {

            Result = CompareString (
                        LOCALE_SYSTEM_DEFAULT,
                        NORM_IGNORECASE,
                        Lower,
                        -1,
                        Str,
                        -1
                        );

            if (Result != CSTR_EQUAL) {
                _tprintf (
                    TEXT("ERROR: %s does not match %s, Result=%i\n"),
                    pStrToHex (Hex1, Str),
                    pStrToHex (Hex2, Lower),
                    Result
                    );
            }
        }

        i = 0;
        do {
            Str[i]++;

            if (Str[i] == 0) {
                Str[i]++;
            } else {
                break;
            }

            i++;
        } while (i < j);

        if (i == j) {
            break;
        }
    }
}

VOID
pSimplePrimeOutput (
    VOID
    )
{
    double dbl;
    int i;
    int j;

    for (i = 1 ; i < 1200 ; i++) {
        for (j = 2 ; j < i ; j++) {
            dbl = (DOUBLE) i / (DOUBLE) j;
            if ((DOUBLE) ((INT) dbl) == dbl) {
                break;      // not prime
            }
        }

        if (j >= i) {
            _tprintf (TEXT("Likely prime: %i\n"), i);
        }
    }

}

INT
__cdecl
_tmain (
    INT argc,
    TCHAR *argv[]
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL);

    //pSimplePrimeOutput();

    //pTest1();
    //pTest2();
    //pTest3();
    pTest4();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\sysmig\sysmig.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    usermig.c

Abstract:

    User migration test tool

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();
}


INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{
    LONG rc;
    REGTREE_ENUM e;

    if (!Init()) {
        wprintf (L"Unable to initialize!\n");

        return 255;
    }

    InitializeProgressBar (NULL, NULL, NULL, NULL);

    //
    // Initialize Win95Reg
    //

    rc = Win95RegInit (TEXT("c:\\windows\\setup\\defhives"), TRUE);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((LOG_ERROR, "Init Processor: Win95RegInit failed, check Win9x windir in code"));
        return FALSE;
    }

    MemDbLoad (TEXT("c:\\windows\\setup\\ntsetup.dat"));

    g_DomainUserName = NULL;
    g_Win9xUserName  = NULL;
    g_FixedUserName  = NULL;

    g_hKeyRootNT = HKEY_LOCAL_MACHINE;
    g_hKeyRoot95 = HKEY_LOCAL_MACHINE;
    SetRegRoot (g_hKeyRoot95);

    MergeRegistry (TEXT("d:\\i386\\wkstamig.inf"), NULL);

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\ansi.c ===
#include "..\..\common\fileenum\ansi.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\tztest\tztest.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tztest.c

Abstract:

    Tztest checks the timezone information stored in win95upg.inf and hivesft.inf against
    the actual information on a win9x machine. This way, discrepencies in our database can
    be rooted out and fixed.

Author:

    Marc R. Whitten (marcw) Jul-29-1998

Revision History:



--*/

#include "pch.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    return InitToolMode (hInstance);
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    TerminateToolMode (hInstance);
}



BOOL
pInitTimeZoneData (
    VOID
    );


extern HANDLE g_TzTestHiveSftInf;

VOID
Usage (
    VOID
    )
{
    printf (
        "Usage:\n\n"
        "tztest [-?v] [-h:<path>] [-w:<path>]\n\n"
        "\t-?           - This message.\n"
        "\t-v           - Verbose messages.\n"
        "\t-h:<path>    - Specify full path for hivesft.inf file.\n"
        "\t-w:<path>    - Specify full path for win95upg.inf file.\n"
        "\n\n"
        );
}

INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    REGTREE_ENUM eTree;
    PCTSTR displayName;
    TCHAR path[MAX_TCHAR_PATH];
    TCHAR key[MEMDB_MAX];
    UINT count;
    INT i;
    BOOL verbose = FALSE;
    PCTSTR win9xUpgPath;
    PCTSTR hiveSftPath;
    PCTSTR dbPath;
    PTSTR p;
    MEMDB_ENUM e;
    MEMDB_ENUM e2;
    PTSTR end;
    HASHTABLE tab;
    HASHTABLE_ENUM eTab;
    TCHAR buffer[MAX_PATH];


    if (!Init()) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    //
    // Set path defaults.
    //
    if (!GetModuleFileName (NULL, path, MAX_TCHAR_PATH)) {
        printf ("TZTEST: Error during initialization (rc %d).", GetLastError());
        return GetLastError();
    }

    p = _tcsrchr(path, TEXT('\\'));
    if (p) {
        *p = 0;
    }

    win9xUpgPath = JoinPaths (path, TEXT("win95upg.inf"));
    hiveSftPath = JoinPaths (path, TEXT("hivesft.inf"));
    dbPath = JoinPaths (path, TEXT("badPaths.dat"));

    //
    // Parse command line parameters.
    //
    for (i = 1; i < argc; i++) {


        if (argv[i][0] == TEXT('-') || argv[i][0] == TEXT('\\')) {

            switch (argv[i][1]) {

            case TEXT('v'): case TEXT('V'):
                verbose = TRUE;
                break;
            case TEXT('w'): case TEXT('W'):
                if (argv[i][2] == TEXT(':')) {
                    win9xUpgPath = argv[i] + 3;
                }
                else {
                    Usage();
                    return 0;
                }
                break;
            case TEXT('h'): case TEXT('H'):
                if (argv[i][2] == TEXT(':')) {
                    hiveSftPath = argv[i] + 3;
                }
                else {
                    Usage();
                    return 0;
                }
                break;
            default:
                Usage();
                return 0;
                break;

            }
        }
    }

    //
    // Load in current bad path information.
    //
    MemDbLoad (dbPath);

    printf("TZTEST: path for win95upg.inf is %s.\n", win9xUpgPath);
    printf("TZTEST: path for hivesft.inf is %s.\n", hiveSftPath);

    g_Win95UpgInf = InfOpenInfFile (win9xUpgPath);


    if (g_Win95UpgInf == INVALID_HANDLE_VALUE || !g_Win95UpgInf) {
        printf("TZTEST: Unable to open %s (rc %d)\n", win9xUpgPath, GetLastError());
        return GetLastError();
    }

    g_TzTestHiveSftInf = InfOpenInfFile (hiveSftPath);

    if (g_TzTestHiveSftInf == INVALID_HANDLE_VALUE || !g_TzTestHiveSftInf) {
        printf("TZTEST: Unable to open %s (rc %d)\n", win9xUpgPath, GetLastError());
        InfCloseInfFile (g_Win95UpgInf);
        return GetLastError();
    }

    pInitTimeZoneData ();

    printf("TZTEST: Checking all timezones on system.\n\n");

    if (EnumFirstRegKeyInTree (&eTree, S_TIMEZONES)) {
        do {

            displayName = GetRegValueString (eTree.CurrentKey->KeyHandle, S_DISPLAY);

            if (!displayName) {
                continue;
            }

            MemDbBuildKey (key, MEMDB_CATEGORY_9X_TIMEZONES, displayName, MEMDB_FIELD_COUNT, NULL);

            if (!MemDbGetValue (key, &count)) {
                printf ("TZTEST: Timezone not in win9upg.inf - %s\n", displayName);
                MemDbSetValueEx(TEXT("NoMatch"), displayName, NULL, NULL, 0, NULL);
            }
            else if (verbose) {
                printf ("TZTEST: %s found in win95upg.inf. %d NT timezones match.\n", displayName, count);
            }

            MemFree (g_hHeap, 0, displayName);

        } while (EnumNextRegKeyInTree (&eTree));
    }

    //
    // Save bad path information.
    //
    MemDbSave (dbPath);

    //
    // Do exhaustive search for indexes:
    //
    if (MemDbEnumItems (&e, MEMDB_CATEGORY_9X_TIMEZONES)) {

        do {
            tab = HtAlloc ();
            printf ("9x Timezone %s matches:\n", e.szName);
            p = _tcschr (e.szName, TEXT(')'));
            if (p) {
                p+=1;
            }

            while (p) {
                end = _tcschr (p, TEXT(','));
                if (end) {
                    *end = 0;
                }
                p = (PTSTR) SkipSpace (p);

                if (MemDbEnumItems (&e2, MEMDB_CATEGORY_NT_TIMEZONES)) {

                    do {
                        if (MemDbGetEndpointValueEx (MEMDB_CATEGORY_NT_TIMEZONES, e2.szName, NULL, key)) {

                            if (_tcsistr (key, p)) {
                                wsprintf (buffer, "%s (%s)\n", key, e2.szName);
                                HtAddString (tab, buffer);
                            }
                        }

                    } while (MemDbEnumNextValue (&e2));
                }

                p = end;
                if (p) {
                    p++;
                }
            }

            if (EnumFirstHashTableString (&eTab, tab)) {
                do {

                  printf (eTab.String);

                } while (EnumNextHashTableString (&eTab));
            }
            else {
                printf ("Nothing.\n");
            }

            HtFree (tab);
            printf ("\n");

        } while (MemDbEnumNextValue (&e));
    }


    printf("TZTEST: Done.\n\n");




    InfCloseInfFile (g_Win95UpgInf);
    InfCloseInfFile (g_TzTestHiveSftInf);

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\upgwiz\upgwiz.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    upgwiz.c

Abstract:

    Implements a stub tool that is designed to run with Win9x-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    ovidiut     01/14/99    Reverted calls to underlying libs in pCallEntryPoints ()
                            when Reason == DLL_PROCESS_DETACH

--*/

#include "pch.h"

typedef UINT (GIVEVERSION_PROTOTYPE) (VOID);
typedef GIVEVERSION_PROTOTYPE * GIVEVERSION;
typedef PDATATYPE (GIVEDATATYPELIST_PROTOTYPE)(PUINT Count);
typedef BOOL (GATHERINFOUI_PROTOTYPE)(HINSTANCE LocalDllInstance, UINT DataTypeId);
typedef GATHERINFOUI_PROTOTYPE * GATHERINFOUI;
typedef GIVEDATATYPELIST_PROTOTYPE * GIVEDATATYPELIST;
typedef PDATAOBJECT (GIVEDATAOBJECTLIST_PROTOTYPE)(UINT DataTypeId, PUINT Count);
typedef GIVEDATAOBJECTLIST_PROTOTYPE * GIVEDATAOBJECTLIST;
typedef BOOL (HANDLE_RMOUSE_PROTOTYPE)(HINSTANCE LocalDllInstance, HWND Owner, PDATAOBJECT DataObject, PPOINT pt);
typedef HANDLE_RMOUSE_PROTOTYPE * HANDLE_RMOUSE;
typedef BOOL (DISPLAYOPTIONALUI_PROTOTYPE)(POUTPUTARGS Args);
typedef DISPLAYOPTIONALUI_PROTOTYPE * DISPLAYOPTIONALUI;
typedef BOOL (GENERATEOUTPUT_PROTOTYPE)(POUTPUTARGS Args);
typedef GENERATEOUTPUT_PROTOTYPE * GENERATEOUTPUT;

typedef VOID (WIZTOOLSMAIN_PROTOTYPE)(DWORD Reason);
typedef WIZTOOLSMAIN_PROTOTYPE * WIZTOOLSMAIN;

typedef struct {
    UINT Selection;
    PDATATYPE *DataTypePtrs;
    UINT PtrCount;
    BOOL NoSave;
} SELECTDATAARGS, *PSELECTDATAARGS;

typedef struct {
    PDATAOBJECT DataObjectArray;
    UINT ArraySize;
    PCSTR Name;
    BOOL SelectOneOnly;
    PBOOL StartOverFlag;
} SELECTOBJECTSARGS, *PSELECTOBJECTSARGS;

typedef struct {
    PCSTR TextTitle;
    PCSTR DescTitle;
    PCSTR *NewText;
    PCSTR *NewDesc;
    UINT MaxSize;
    PCSTR DataTypeName;
    PCSTR DataObjectName;
    BOOL NoDesc;
    BOOL ReqDesc;
    BOOL NoText;
    BOOL ReqText;
    PBOOL StartOverFlag;
} SUPPLYTEXTARGS, *PSUPPLYTEXTARGS;


typedef struct {
    HANDLE Library;
    GIVEVERSION GiveVersion;
    GIVEDATATYPELIST GiveDataTypeList;
    GATHERINFOUI GatherInfoUI;
    GIVEDATAOBJECTLIST GiveDataObjectList;
    HANDLE_RMOUSE Handle_RMouse;
    DISPLAYOPTIONALUI DisplayOptionalUI;
    GENERATEOUTPUT GenerateOutput;
    PDATATYPE DataTypes;
    UINT DataTypeCount;
    PDATAOBJECT DataObjects;
    UINT DataObjectCount;
} DGDLL, *PDGDLL;


UINT g_Selections;
CHAR g_Msg[2048];
PCSTR g_DataPath = "\\\\popcorn\\public\\win9xupg";
GROWBUFFER g_DllList;
POOLHANDLE g_DllListData;
PCSTR g_SrcInfPath = NULL;
PCSTR g_DestPath = NULL;
static CHAR g_ModulePath[MAX_MBCHAR_PATH];
static CHAR g_CleanThisDir[MAX_MBCHAR_PATH];
BOOL g_DontSave;
PDGDLL g_CurrentDll = NULL;


WIZTOOLSMAIN g_WizToolsMainProc = NULL;

UINT
pSelectDataType (
    IN      PDATATYPE *DataTypePtrs,
    IN      UINT PtrCount,
    OUT     PBOOL DontSave
    );

BOOL
pSelectDataObjects (
    IN OUT  PDATAOBJECT DataObjectArray,
    IN      UINT ArraySize,
    IN      PDATATYPE DataType,
    OUT     PBOOL StartOverFlag
    );

BOOL
pGetOptionalText (
    IN      PCSTR TextTitle,            OPTIONAL
    IN      PCSTR DescTitle,            OPTIONAL
    IN      PCSTR *NewDesc,
    IN      PCSTR *Buffer,
    IN      UINT MaxSize,
    IN      PDATATYPE DataType,
    IN      PDATAOBJECT DataObject,     OPTIONAL
    OUT     PBOOL StartOverFlag
    );


VOID
pThankYouBox (
    IN      PBOOL StartOverFlag
    );


VOID
pFreeDllList (
    IN OUT  PGROWBUFFER List,
    IN      POOLHANDLE Buffer
    );


HANDLE g_hHeap;
HINSTANCE g_hInst;
PSTR g_WinDir;

BOOL WINAPI MemDb_Entry (HINSTANCE, DWORD, PVOID);
BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);
BOOL WINAPI FileEnum_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    HINSTANCE Instance;
    static CHAR WinDir[MAX_PATH];

    GetWindowsDirectory (WinDir, MAX_PATH);
    g_WinDir = WinDir;

    //
    // Simulate DllMain
    //

    Instance = g_hInst;

    //
    // Initialize the common libs
    //

    if (Reason == DLL_PROCESS_ATTACH) {

        if (!MigUtil_Entry (Instance, Reason, NULL)) {
            return FALSE;
        }

        if (!MemDb_Entry (Instance, Reason, NULL)) {
            return FALSE;
        }

        if (!FileEnum_Entry (Instance, Reason, NULL)) {
            return FALSE;
        }
    } else if (Reason == DLL_PROCESS_DETACH) {

        if (!FileEnum_Entry (Instance, Reason, NULL)) {
            return FALSE;
        }

        if (!MemDb_Entry (Instance, Reason, NULL)) {
            return FALSE;
        }

        if (!MigUtil_Entry (Instance, Reason, NULL)) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL CALLBACK
pSetDefGuiFontProc(
    IN      HWND hwnd,
    IN      LPARAM lParam)
{
    SendMessage(hwnd, WM_SETFONT, lParam, 0L);
    return TRUE;
}


void
pSetDefGUIFont(
    IN      HWND hdlg
    )
{
    EnumChildWindows(hdlg, pSetDefGuiFontProc, (LPARAM)GetStockObject(DEFAULT_GUI_FONT));
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    if (g_CleanThisDir[0]) {
        DeleteDirectoryContents (g_CleanThisDir);
        RemoveDirectory (g_CleanThisDir);
    }

    pCallEntryPoints (DLL_PROCESS_DETACH);
}


BOOL
pLoadDataGatherDlls (
    BOOL FirstTimeInit,
    BOOL Local
    );

VOID
pTryToLoadNewUpgWiz (
    VOID
    );

BOOL
pDoTheWizard (
    VOID
    );


VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command Line Syntax:\n\n"
            "upgwiz [-l] [-n:path] [-i:src_inf_path] [-d:path]\n\n"
            "-l     Specifies local mode\n"
            "-n     Specifies network path\n"
            "-i     Specifies the source INF path\n"
            "-d     Specifies destination path\n"
            );

    exit(1);
}


INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    CHAR ModulePath[MAX_MBCHAR_PATH];
    BOOL Local = FALSE;
    INT i;
    PSTR p;
    BOOL Loop;
    BOOL FirstTimeInit = TRUE;

    if (!Init()) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    GetCurrentDirectory (MAX_MBCHAR_PATH, ModulePath);

    GetModuleFileName (g_hInst, g_ModulePath, MAX_MBCHAR_PATH);
    p = _mbsrchr (g_ModulePath, '\\');
    *p = 0;

    wsprintf (ModulePath, TEXT("%s\\wiztools.dll"), g_ModulePath);
    if (DoesFileExist (ModulePath)) {
        Local = TRUE;
    }

    if (GetDriveType (g_ModulePath) == DRIVE_REMOVABLE) {
        Local = TRUE;
    }

    if (StringIMatch (g_ModulePath, g_DataPath)) {
        wsprintf (g_Msg, "This tool cannot be run from %s.", g_DataPath);
        MessageBox (NULL, g_Msg, NULL, MB_OK);
        return 255;
    }

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {

            case 'l':
                Local = TRUE;
                g_DataPath = g_ModulePath;
                break;

            case 'n':
                if (argv[i][2] == ':') {
                    g_DataPath = &argv[i][3];
                } else if (i + 1 < argc) {
                    g_DataPath = argv[i + 1];
                } else {
                    HelpAndExit();
                }

                if (!DoesFileExist (g_DataPath)) {
                    printf ("Can't access %s\n", g_DataPath);
                    exit (2);
                }
                break;

            case 'i':
                if (argv[i][2] == ':') {
                    g_SrcInfPath = &argv[i][3];
                } else if (i + 1 < argc) {
                    g_SrcInfPath = argv[i + 1];
                } else {
                    HelpAndExit();
                }

                if (!DoesFileExist (g_SrcInfPath)) {
                    printf ("Can't access %s\n", g_SrcInfPath);
                    exit (2);
                }
                break;

            case 'd':
                if (argv[i][2] == ':') {
                    g_DestPath = &argv[i][3];
                } else if (i + 1 < argc) {
                    g_DestPath = argv[i + 1];
                } else {
                    HelpAndExit();
                }

                if (!DoesFileExist (g_DestPath)) {
                    printf ("Can't access %s\n", g_DestPath);
                    exit (2);
                }
                break;

            default:
                HelpAndExit();

            }
        } else {
            HelpAndExit();
        }
    }


    if (!g_SrcInfPath) {
        g_SrcInfPath = g_DataPath;
    }

    if (!g_DestPath) {
        g_DestPath = g_DataPath;
    }

    printf ("Src Path: %s\n", g_SrcInfPath);
    printf ("Dest Path: %s\n", g_DestPath);

    Loop = FALSE;

    do {
        if (!pLoadDataGatherDlls (FirstTimeInit, Local)) {
            wsprintf (g_Msg, "Can't load any DLLs from %s.", g_DataPath);
            MessageBox (NULL, g_Msg, NULL, MB_OK);
        } else {
            FirstTimeInit = FALSE;
            Loop = pDoTheWizard();
        }
    } while (Loop);

    Terminate();

    if (g_WizToolsMainProc) {
        g_WizToolsMainProc (DLL_PROCESS_DETACH);
    }

    return 0;
}

VOID
pCreateDllList (
    OUT     PGROWBUFFER List,
    OUT     POOLHANDLE *Buffer
    )
{
    ZeroMemory (List, sizeof (GROWBUFFER));
    *Buffer = PoolMemInitNamedPool ("DLL List");
}


BOOL
pCopyBinaryToTemp (
    IN      PCSTR DllPath,
    OUT     PSTR TempPath
    )
{
    if (!g_CleanThisDir[0]) {
        StringCopy (TempPath, g_WinDir);
        StringCopy (AppendWack (TempPath), "upgwiz");

        MakeSurePathExists (TempPath, TRUE);

        StringCopy (g_CleanThisDir, TempPath);
    } else {
        StringCopy (TempPath, g_CleanThisDir);
    }

    StringCopy (AppendWack (TempPath), GetFileNameFromPath (DllPath));

    if (DoesFileExist (TempPath)) {
        return TRUE;
    }

    if (!CopyFile (DllPath, TempPath, FALSE)) {
        wsprintf (
            g_Msg,
            "Can't copy %s to %s.  If the network is working fine, the file "
                "may already have been copied and is running already, or you "
                "may need to update your copy of upgwiz.exe.",
            DllPath,
            TempPath
            );

        MessageBox (NULL, g_Msg, NULL, MB_OK);
        return FALSE;
    } else {
        printf ("%s copied to %s\n", DllPath, TempPath);
    }

    return TRUE;
}


BOOL
pPutDllInList (
    IN OUT  PGROWBUFFER List,
    IN OUT  POOLHANDLE Buffer,
    IN      PCSTR DllPath
    )
{
    DGDLL Dll;
    PDGDLL FinalDll;
    BOOL b = FALSE;
    CHAR TempPath[MAX_MBCHAR_PATH];

    ZeroMemory (&Dll, sizeof (Dll));

    __try {
        pCopyBinaryToTemp (DllPath, TempPath);

        Dll.Library = LoadLibraryEx (TempPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

        if (!Dll.Library) {
            DWORD rc;

            rc = GetLastError();
            __leave;
        }

        Dll.GiveVersion = (GIVEVERSION) GetProcAddress (Dll.Library, "GiveVersion");
        Dll.GiveDataTypeList = (GIVEDATATYPELIST) GetProcAddress (Dll.Library, "GiveDataTypeList");
        Dll.GatherInfoUI = (GATHERINFOUI) GetProcAddress (Dll.Library, "GatherInfoUI");
        Dll.GiveDataObjectList = (GIVEDATAOBJECTLIST) GetProcAddress (Dll.Library, "GiveDataObjectList");
        Dll.Handle_RMouse = (HANDLE_RMOUSE) GetProcAddress (Dll.Library, "Handle_RMouse");
        Dll.DisplayOptionalUI = (DISPLAYOPTIONALUI) GetProcAddress (Dll.Library, "DisplayOptionalUI");
        Dll.GenerateOutput = (GENERATEOUTPUT) GetProcAddress (Dll.Library, "GenerateOutput");

        if (!Dll.GiveVersion || !Dll.GiveDataTypeList ||
            !Dll.GiveDataObjectList || !Dll.GenerateOutput
            ) {
            __leave;
        }

        if (Dll.GiveVersion() != UPGWIZ_VERSION) {
            __leave;
        }

        b = TRUE;
    }
    __finally {
        if (!b) {
            if (Dll.Library) {
                FreeLibrary (Dll.Library);
            }
        }
    }

    if (b) {
        FinalDll = (PDGDLL) GrowBuffer (List, sizeof (DGDLL));
        CopyMemory (FinalDll, &Dll, sizeof (Dll));
    }

    return b;
}


VOID
pFreeDllList (
    IN OUT  PGROWBUFFER List,
    IN      POOLHANDLE Buffer
    )
{
    UINT Count;
    PDGDLL Dll;

    Dll = (PDGDLL) List->Buf;
    Count = List->End / sizeof (DGDLL);

    while (Count > 0) {
        Count--;
        FreeLibrary (Dll->Library);
        Dll++;
    }

    FreeGrowBuffer (List);
    PoolMemDestroyPool (Buffer);
}


BOOL
pLoadDataGatherDlls (
    BOOL FirstTimeInit,
    BOOL Local
    )
{
    FILE_ENUM e;
    BOOL b = FALSE;
    CHAR HelperBin[MAX_MBCHAR_PATH];
    CHAR TempPath[MAX_MBCHAR_PATH];
    HINSTANCE Library;
    CHAR wiztoolsPath[MAX_MBCHAR_PATH];

    if (Local || !DoesFileExist (g_DataPath)) {

        g_DataPath = g_ModulePath;

    }

    pCreateDllList (&g_DllList, &g_DllListData);

    wsprintf (wiztoolsPath, "%s\\wiztools.dll", g_DataPath);

    if (!Local) {
        //
        // Copy everything that is needed to run this app
        //

        wsprintf (HelperBin, "%s\\msvcrt.dll", g_DataPath);
        pCopyBinaryToTemp (HelperBin, TempPath);

        wsprintf (HelperBin, "%s\\twid.exe", g_DataPath);
        pCopyBinaryToTemp (HelperBin, TempPath);

        wsprintf (HelperBin, "%s\\setupapi.dll", g_DataPath);
        pCopyBinaryToTemp (HelperBin, TempPath);

        wsprintf (HelperBin, "%s\\cfgmgr32.dll", g_DataPath);
        pCopyBinaryToTemp (HelperBin, TempPath);

        wsprintf (HelperBin, "%s\\imagehlp.dll", g_DataPath);
        pCopyBinaryToTemp (HelperBin, TempPath);

        wsprintf (HelperBin, "%s\\wiztools.dll", g_DataPath);
        pCopyBinaryToTemp (HelperBin, TempPath);
        StringCopy (wiztoolsPath, TempPath);
    }


    if (FirstTimeInit) {
        Library = LoadLibraryEx (wiztoolsPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

        g_WizToolsMainProc = (WIZTOOLSMAIN) GetProcAddress (Library, "WizToolsMain");

        if (g_WizToolsMainProc) {
            g_WizToolsMainProc (DLL_PROCESS_ATTACH);
        }
    }

    if (EnumFirstFile (&e, g_DataPath, "*.dll")) {
        do {
            if (StringIMatch (e.FileName, "setupapi.dll") ||
                StringIMatch (e.FileName, "cfgmgr32.dll") ||
                StringIMatch (e.FileName, "wiztools.dll") ||
                StringIMatch (e.FileName, "msvcrt.dll") ||
                StringIMatch (e.FileName, "imagehlp.dll")
                ) {
                continue;
            }

            if (pPutDllInList (&g_DllList, g_DllListData, e.FullPath)) {
                b = TRUE;
            }
        } while (EnumNextFile (&e));
    }

    if (!b) {
        pFreeDllList (&g_DllList, g_DllListData);
        g_DllListData = NULL;
    }

    return b;
}


VOID
pTryToLoadNewUpgWiz (
    VOID
    )
{
    CHAR TempExe[MAX_MBCHAR_PATH];
    CHAR PopcornExe[MAX_MBCHAR_PATH];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    StringCopy (PopcornExe, g_DataPath);
    StringCopy (AppendWack (PopcornExe), "upgwiz.exe");

    if (!pCopyBinaryToTemp (PopcornExe, TempExe)) {
        return;
    }

    ZeroMemory (&si, sizeof (si));
    si.cb = sizeof (si);
    si.dwFlags = STARTF_FORCEOFFFEEDBACK;

    CreateProcessA (
        NULL,
        TempExe,
        NULL,
        NULL,
        FALSE,
        CREATE_DEFAULT_ERROR_MODE,
        NULL,
        g_DataPath,
        &si,
        &pi
        );
}


BOOL
pDoTheWizard (
    VOID
    )
{
    GROWBUFFER DataTypes = GROWBUF_INIT;
    UINT Count;
    UINT Pos;
    PDGDLL Dll;
    PDATATYPE DataTypeList;
    PDATATYPE *Ptr;
    PDATAOBJECT DataObjectList;
    UINT DataObjectCount;
    UINT DataTypeListSize;
    UINT u;
    OUTPUTARGS Args;
    PDATAOBJECT SelectedDataObject;
    BOOL StartOverFlag = FALSE;
    BOOL Saved;

    ZeroMemory (&Args, sizeof (Args));

    Dll = (PDGDLL) g_DllList.Buf;
    Count = g_DllList.End / sizeof (DGDLL);

    for (Pos = 0 ; Pos < Count ; Pos++) {
        DataTypeListSize = 0;


        DataTypeList = Dll[Pos].GiveDataTypeList (&DataTypeListSize);

        if (!DataTypeList) {
            DataTypeListSize = 0;
        }

        for (u = 0 ; u < DataTypeListSize ; u++) {
            Ptr = (PDATATYPE *) GrowBuffer (&DataTypes, sizeof (PDATATYPE));
            *Ptr = &DataTypeList[u];
            (*Ptr)->Reserved = (PVOID) Pos;
        }
    }

    if (DataTypes.End == 0) {
        MessageBox (NULL, "No data type DLLs to select from.  There may be network access problems.", NULL, MB_OK);
        return FALSE;
    }

    __try {

        //
        // User selects data type
        //

        Pos = pSelectDataType ((PDATATYPE *) DataTypes.Buf, DataTypes.End / sizeof (PDATATYPE), &g_DontSave);
        if (Pos == 0xffffffff) {
            __leave;
        }

        DataTypeList = ((PDATATYPE *) DataTypes.Buf)[Pos];

        //
        // Get the data objects
        //

        DataObjectCount = 0;

        Dll = (PDGDLL) g_DllList.Buf;
        Dll += (UINT) DataTypeList->Reserved;

        g_CurrentDll = Dll;

        //
        // Gather Info UI
        //

        if (Dll->GatherInfoUI) {
            if (!Dll->GatherInfoUI (Dll->Library, DataTypeList->DataTypeId)) {
                __leave;
            }
        }

        if (!(DataTypeList->Flags & (DTF_NO_DATA_OBJECT))) {

            TurnOnWaitCursor();
            DataObjectList = Dll->GiveDataObjectList (DataTypeList->DataTypeId, &DataObjectCount);
            TurnOffWaitCursor();

            if (!DataObjectList || !DataObjectCount) {
                MessageBox (NULL, "There are no items of this type to choose from.", NULL, MB_OK);
                StartOverFlag = TRUE;
                __leave;
            }

            //
            // User selects them here
            //

            if (!pSelectDataObjects (DataObjectList, DataObjectCount, DataTypeList, &StartOverFlag)) {
                __leave;
            }
        }

        //
        // Display Optional UI
        //

        Args.Version = UPGWIZ_VERSION;
        Args.InboundInfDir = g_SrcInfPath;
        Args.OutboundDir = g_DestPath;
        Args.DataTypeId = DataTypeList->DataTypeId;
        Args.StartOverFlag = &StartOverFlag;

        if (Dll->DisplayOptionalUI) {
            if (!Dll->DisplayOptionalUI (&Args)) {
                __leave;
            }
        }

        //
        // Optional text
        //

        if (DataTypeList->Flags & (DTF_REQUEST_TEXT|DTF_REQUEST_DESCRIPTION)) {

            SelectedDataObject = NULL;
            for (u = 0 ; u < DataObjectCount ; u++) {
                if (DataObjectList[u].Flags & DOF_SELECTED) {
                    if (SelectedDataObject) {
                        SelectedDataObject = NULL;
                        break;
                    }

                    SelectedDataObject = &DataObjectList[u];
                }
            }

            Args.OptionalText = MemAlloc (g_hHeap, 0, DataTypeList->MaxTextSize + 1);
            Args.OptionalDescription = MemAlloc (g_hHeap, 0, 81);

            if (!pGetOptionalText (
                    DataTypeList->OptionalTextTitle,
                    DataTypeList->OptionalDescTitle,
                    &Args.OptionalDescription,
                    &Args.OptionalText,
                    DataTypeList->MaxTextSize,
                    DataTypeList,
                    SelectedDataObject,
                    &StartOverFlag
                    )) {
                __leave;
            }

            if (*Args.OptionalText == 0) {
                MemFree (g_hHeap, 0, Args.OptionalText);
                Args.OptionalText = NULL;
            }

            if (*Args.OptionalDescription == 0) {
                MemFree (g_hHeap, 0, Args.OptionalDescription);
                Args.OptionalDescription = NULL;
            }
        }

        //
        // Generate the output
        //

        Args.Version = UPGWIZ_VERSION;
        Args.InboundInfDir = g_SrcInfPath;
        Args.OutboundDir = g_DestPath;
        Args.DataTypeId = DataTypeList->DataTypeId;

        if (!g_DontSave) {

            TurnOnWaitCursor();
            if (Dll->GenerateOutput (&Args)) {
                Saved = TRUE;
                TurnOffWaitCursor();
            } else {
                TurnOffWaitCursor();
                MessageBox (NULL, "An error occurred while trying to save the report information.", "Report Not Saved", MB_OK);
                Saved = FALSE;
            }
        } else {
            Saved = TRUE;
        }

        if (Saved) {
            pThankYouBox (&StartOverFlag);
        }

        if (Args.OptionalText) {
            MemFree (g_hHeap, 0, Args.OptionalText);
        }

        if (Args.OptionalDescription) {
            MemFree (g_hHeap, 0, Args.OptionalDescription);
        }

        g_CurrentDll = NULL;
    }
    __finally {

        //
        // Done
        //

        pFreeDllList (&g_DllList, g_DllListData);
        FreeGrowBuffer (&DataTypes);
    }

    return StartOverFlag;
}


BOOL
CALLBACK
pDataTypeProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PSELECTDATAARGS Args;
    PDATATYPE DataType;
    UINT u;
    HWND List;
    UINT Index;

    switch (uMsg) {
    case WM_INITDIALOG:
        pSetDefGUIFont(hdlg);

        Args = (PSELECTDATAARGS) lParam;

        List = GetDlgItem (hdlg, IDC_DT_LIST);

        for (u = 0 ; u < Args->PtrCount ; u++) {
            DataType = Args->DataTypePtrs[u];

            Index = SendMessage (List, LB_ADDSTRING, 0, (LPARAM) DataType->Name);
            SendMessage (List, LB_SETITEMDATA, Index, u);
        }

        CheckDlgButton (hdlg, IDC_DONT_SAVE, Args->NoSave ? BST_CHECKED : BST_UNCHECKED);

        EnableWindow (GetDlgItem (hdlg, IDOK), FALSE);
        return FALSE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDC_DT_LIST:

            if (HIWORD (wParam) == LBN_SELCHANGE) {

                EnableWindow (GetDlgItem (hdlg, IDOK), TRUE);

                List = GetDlgItem (hdlg, IDC_DT_LIST);
                Index = SendMessage (List, LB_GETCURSEL, 0, 0);
                u = SendMessage (List, LB_GETITEMDATA, Index, 0);

                DataType = Args->DataTypePtrs[u];

                SetDlgItemText (hdlg, IDC_DESCRIPTION, DataType->Description);

            } else if (HIWORD (wParam) == LBN_DBLCLK) {

                PostMessage (hdlg, WM_COMMAND, MAKELPARAM(IDOK,BN_CLICKED), 0);

            }

            break;

        case IDOK:
            List = GetDlgItem (hdlg, IDC_DT_LIST);
            Index = SendMessage (List, LB_GETCURSEL, 0, 0);
            Args->Selection = SendMessage (List, LB_GETITEMDATA, Index, 0);

            Args->NoSave = IsDlgButtonChecked (hdlg, IDC_DONT_SAVE);

            EndDialog (hdlg, LOWORD (wParam));
            break;

        case IDCANCEL:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        }

        break;
    }

    return FALSE;
}


UINT
pSelectDataType (
    IN      PDATATYPE *DataTypePtrs,
    IN      UINT PtrCount,
    IN OUT  PBOOL DontSave
    )
{
    SELECTDATAARGS Args;

    Args.Selection = 0xffffffff;
    Args.DataTypePtrs = DataTypePtrs;
    Args.PtrCount = PtrCount;
    Args.NoSave = *DontSave;

    DialogBoxParam (g_hInst, MAKEINTRESOURCE(IDD_DATA_TYPE), NULL, pDataTypeProc, (LPARAM) &Args);

    *DontSave = Args.NoSave;

    return Args.Selection;
}


VOID
pToggleSelection (
    HWND TreeView,
    HTREEITEM TreeItem,
    BOOL OneSelection
    )
{
    static HTREEITEM LastSet;
    UINT State;
    PDATAOBJECT DataObject;
    TVITEM Item;

    Item.mask = TVIF_HANDLE|TVIF_STATE|TVIF_PARAM;
    Item.hItem = TreeItem;
    Item.stateMask = TVIS_STATEIMAGEMASK;

    TreeView_GetItem (TreeView, &Item);

    State = Item.state & TVIS_STATEIMAGEMASK;
    DataObject = (PDATAOBJECT) Item.lParam;

    if (State) {
        if (((State >> 12) & 0x03) == 2) {
            State = INDEXTOSTATEIMAGEMASK(1);
            g_Selections--;
            DataObject->Flags &= ~DOF_SELECTED;
        } else {
            if (OneSelection && g_Selections == 1) {
                pToggleSelection (TreeView, LastSet, FALSE);
            }

            State = INDEXTOSTATEIMAGEMASK(2);
            g_Selections++;
            DataObject->Flags |= DOF_SELECTED;

            LastSet = TreeItem;
        }

        Item.mask = TVIF_HANDLE|TVIF_STATE;
        Item.hItem = TreeItem;
        Item.state = State;
        Item.stateMask = TVIS_STATEIMAGEMASK;

        TreeView_SetItem (TreeView, &Item);
        InvalidateRect (TreeView, NULL, TRUE);
    }
}


HTREEITEM
TreeView_FindItem (
    IN      HWND TreeView,
    IN      PCSTR String,
    IN      HTREEITEM Parent        OPTIONAL
    )
{
    HTREEITEM Child;
    TVITEM Item;
    CHAR Buffer[1024];

    if (!Parent) {
        Child = TreeView_GetRoot (TreeView);
    } else {
        Child = TreeView_GetChild (TreeView, Parent);
    }

    while (Child) {

        Item.mask = TVIF_TEXT|TVIF_HANDLE;
        Item.hItem = Child;
        Item.pszText = Buffer;
        Item.cchTextMax = 1024;

        TreeView_GetItem (TreeView, &Item);

        if (StringIMatch (String, Buffer)) {
            break;
        }

        Child = TreeView_GetNextSibling (TreeView, Child);
    }

    return Child;
}





VOID
pAddSubStringToTreeControl (
    IN      HWND TreeView,
    IN      PSTR Path,
    IN      BOOL Checked,
    IN      HTREEITEM Parent,       OPTIONAL
    IN      LPARAM lParam
    )
{
    TVINSERTSTRUCT is;
    PSTR p;
    HTREEITEM Child;
    BOOL CheckThis = FALSE;
    BOOL HasBitmap = FALSE;
    HTREEITEM ExistingItem;
    PDATAOBJECT d = (PDATAOBJECT) lParam;


    p = _mbschr (Path, '\\');
    if (p && !(d->Flags & DOF_NO_SPLIT_ON_WACK)) {
        *p = 0;
    } else {
        CheckThis = Checked;
        HasBitmap = TRUE;
    }

    RestoreWacks (Path);

    is.hParent = Parent;
    is.hInsertAfter = d->Flags & DOF_NO_SORT ? TVI_LAST : TVI_SORT;

    ExistingItem = TreeView_FindItem (TreeView, Path, Parent);

    is.item.mask = 0;
    if (!ExistingItem) {
        is.item.mask = TVIF_TEXT;
        is.item.pszText = Path;
    } else {
        is.item.mask = TVIF_HANDLE;
        is.item.hItem = ExistingItem;
    }

    if (HasBitmap) {
        is.item.mask |= TVIF_STATE|TVIF_IMAGE|TVIF_SELECTEDIMAGE|TVIF_PARAM;
        is.item.iImage = 0;
        is.item.iSelectedImage = 1;
        is.item.state = CheckThis ? INDEXTOSTATEIMAGEMASK(2) : INDEXTOSTATEIMAGEMASK(1);
        is.item.stateMask = TVIS_STATEIMAGEMASK;
        is.item.lParam = lParam;

        if (CheckThis) {
            g_Selections++;
        }
    }

    if (ExistingItem) {
        if (is.item.mask) {
            TreeView_SetItem (TreeView, &is.item);
        }

        Child = ExistingItem;
    } else {
        Child = TreeView_InsertItem (TreeView, &is);
    }

    if (p && !(d->Flags & DOF_NO_SPLIT_ON_WACK)) {
        pAddSubStringToTreeControl (TreeView, p + 1, Checked, Child, lParam);
    }
}


VOID
pAddStringToTreeControl (
    IN      HWND TreeView,
    IN      PCSTR Path,
    IN      BOOL Checked,
    IN      LPARAM lParam
    )
{
    PSTR PathCopy;

    PathCopy = DuplicateText (Path);

    pAddSubStringToTreeControl (TreeView, PathCopy, Checked, NULL, lParam);

    FreeText (PathCopy);
}


BOOL
CALLBACK
pDataObjectProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PSELECTOBJECTSARGS Args;
    static HIMAGELIST ImageList;
    static BOOL OneSelection;
    UINT u;
    HWND TreeView;
    LPNMHDR pnmh;
    TVHITTESTINFO HitTest;
    HTREEITEM TreeItem;
    LPNMTVKEYDOWN KeyDown;
    TVITEM Item;
    PDATAOBJECT DataObject;
    POINT pt;

    switch (uMsg) {
    case WM_INITDIALOG:
        pSetDefGUIFont(hdlg);

        Args = (PSELECTOBJECTSARGS) lParam;
        OneSelection = Args->SelectOneOnly;

        if (OneSelection) {
            SetDlgItemText (hdlg, IDC_DESCRIPTION, "&Select the Item to Report:");
        }

        SetWindowText (hdlg, Args->Name);

        g_Selections = 0;

        TreeView = GetDlgItem (hdlg, IDC_OBJECTS);

        ImageList = ImageList_LoadImage (
                        g_hInst,
                        MAKEINTRESOURCE(IDB_TREE_IMAGES),
                        16,
                        0,
                        CLR_DEFAULT,
                        IMAGE_BITMAP,
                        LR_LOADTRANSPARENT
                        );


        TreeView_SetImageList (TreeView, ImageList, TVSIL_STATE);

        for (u = 0 ; u < Args->ArraySize ; u++) {
            pAddStringToTreeControl (
                TreeView,
                Args->DataObjectArray[u].NameOrPath,
                OneSelection ? FALSE : (Args->DataObjectArray[u].Flags & DOF_SELECTED) ? TRUE : FALSE,
                (LPARAM) (&Args->DataObjectArray[u])
                );
        }

        InvalidateRect (TreeView, NULL, TRUE);
        EnableWindow (GetDlgItem (hdlg, IDOK), g_Selections != 0);
        return FALSE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDC_START_OVER:
            *Args->StartOverFlag = TRUE;
            EndDialog (hdlg, LOWORD (wParam));
            break;

        case IDOK:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        case IDCANCEL:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        }

        break;

    case WM_NOTIFY:
        pnmh = (LPNMHDR) lParam;

        if (pnmh->code == NM_CLICK) {
            GetCursorPos (&HitTest.pt);
            ScreenToClient (pnmh->hwndFrom, &HitTest.pt);

            TreeView_HitTest (pnmh->hwndFrom, &HitTest);

            if (HitTest.flags & TVHT_ONITEMSTATEICON) {

                pToggleSelection (pnmh->hwndFrom, HitTest.hItem, OneSelection);
                EnableWindow (GetDlgItem (hdlg, IDOK), g_Selections != 0);
            }
        }

        else if (pnmh->code == NM_RCLICK) {
            GetCursorPos (&HitTest.pt);
            pt.x = HitTest.pt.x;
            pt.y = HitTest.pt.y;
            ScreenToClient (pnmh->hwndFrom, &HitTest.pt);

            TreeView_HitTest (pnmh->hwndFrom, &HitTest);

            Item.mask = TVIF_HANDLE|TVIF_PARAM;
            Item.hItem = HitTest.hItem;

            TreeView_GetItem (pnmh->hwndFrom, &Item);

            TreeView_SelectItem (pnmh->hwndFrom, HitTest.hItem);

            DataObject = (PDATAOBJECT) Item.lParam;

            if (g_CurrentDll->Handle_RMouse) {
                if (g_CurrentDll->Handle_RMouse (g_CurrentDll->Library, pnmh->hwndFrom, DataObject, &pt)) {

                    Item.pszText = (PSTR)DataObject->NameOrPath;
                    Item.cchTextMax = strlen (DataObject->NameOrPath);
                    Item.mask = TVIF_HANDLE|TVIF_TEXT;
                    TreeView_SetItem (pnmh->hwndFrom, &Item);
                    InvalidateRect (pnmh->hwndFrom, NULL, TRUE);
                }
            }
        }

        //
        // The tree control beeps with keyboard input; we have no way
        // to eat the messages.  This codes is disabled.
        //

        else if (pnmh->code == TVN_KEYDOWN && pnmh->code == 0) {

            KeyDown = (LPNMTVKEYDOWN) pnmh;

            if (KeyDown->wVKey == VK_SPACE) {

                TreeItem = TreeView_GetSelection (pnmh->hwndFrom);

                if (TreeItem) {
                    pToggleSelection (pnmh->hwndFrom, TreeItem, OneSelection);
                    EnableWindow (GetDlgItem (hdlg, IDOK), g_Selections != 0);
                }
            }
        }

        break;

    case WM_DESTROY:
        ImageList_Destroy (ImageList);
        break;

    }

    return FALSE;
}


BOOL
pSelectDataObjects (
    IN OUT  PDATAOBJECT DataObjectArray,
    IN      UINT ArraySize,
    IN      PDATATYPE DataType,
    OUT     PBOOL StartOverFlag
    )
{
    SELECTOBJECTSARGS Args;

    Args.DataObjectArray = DataObjectArray;
    Args.ArraySize = ArraySize;
    Args.Name = DataType->Name;
    Args.SelectOneOnly = (DataType->Flags & DTF_ONE_SELECTION) != 0;
    Args.StartOverFlag = StartOverFlag;

    return IDOK == DialogBoxParam (
                        g_hInst,
                        MAKEINTRESOURCE(IDD_DATA_OBJECTS),
                        NULL,
                        pDataObjectProc,
                        (LPARAM) &Args
                        );
}


BOOL
CALLBACK
pSupplyTextProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PSUPPLYTEXTARGS Args;
    BOOL b;
    CHAR name[MEMDB_MAX];

    switch (uMsg) {
    case WM_INITDIALOG:
        pSetDefGUIFont(hdlg);

        Args = (PSUPPLYTEXTARGS) lParam;

        if (Args->TextTitle) {
            SetDlgItemText (hdlg, IDC_TEXT_TITLE, Args->TextTitle);
        }

        if (Args->DescTitle) {
            SetDlgItemText (hdlg, IDC_DESC_TITLE, Args->DescTitle);
        }

        SetDlgItemText (hdlg, IDC_DATA_TYPE, Args->DataTypeName);
        if (Args->DataObjectName) {

            StringCopy (name, Args->DataObjectName);
            RestoreWacks(name);

            SetDlgItemText (hdlg, IDC_SELECTION, name);
        }

        SendMessage (GetDlgItem (hdlg, IDC_DESCRIPTION), EM_LIMITTEXT, 80, 0);
        SendMessage (GetDlgItem (hdlg, IDC_TEXT_MSG), EM_LIMITTEXT, Args->MaxSize, 0);

        if (Args->NoText) {

            SetDlgItemText (hdlg, IDC_TEXT_MSG, "(not applicable)");
            EnableWindow (GetDlgItem (hdlg, IDC_TEXT_MSG), FALSE);

        } else if (Args->NoDesc) {

            SetDlgItemText (hdlg, IDC_DESCRIPTION, "(not applicable)");
            EnableWindow (GetDlgItem (hdlg, IDC_DESCRIPTION), FALSE);
        }

        if (Args->ReqDesc || Args->ReqText) {
            EnableWindow (GetDlgItem (hdlg, IDOK), FALSE);
        }

        return FALSE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDC_DESCRIPTION:
        case IDC_TEXT_MSG:
            if (HIWORD (wParam) == EN_CHANGE) {
                b = !Args->ReqDesc || GetWindowTextLength (GetDlgItem (hdlg, IDC_DESCRIPTION)) != 0;
                b &= !Args->ReqText || GetWindowTextLength (GetDlgItem (hdlg, IDC_TEXT_MSG)) != 0;

                EnableWindow (GetDlgItem (hdlg, IDOK), b);
            }
            break;

        case IDC_START_OVER:
            *Args->StartOverFlag = TRUE;
            EndDialog (hdlg, LOWORD (wParam));
            break;

        case IDOK:
            if (Args->NoDesc) {
                *((PSTR) (*Args->NewDesc)) = 0;
            } else {
                GetDlgItemText (hdlg, IDC_DESCRIPTION, (PSTR) (*Args->NewDesc), 81);
            }

            if (Args->NoText) {
                *((PSTR) (*Args->NewText)) = 0;
            } else {
                GetDlgItemText (hdlg, IDC_TEXT_MSG, (PSTR) (*Args->NewText), Args->MaxSize + 1);
            }

            EndDialog (hdlg, LOWORD (wParam));
            break;

        case IDCANCEL:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        }

        break;
    }

    return FALSE;
}


BOOL
pGetOptionalText (
    IN      PCSTR TextTitle,            OPTIONAL
    IN      PCSTR DescTitle,
    IN      PCSTR *NewDesc,
    IN      PCSTR *NewText,
    IN      UINT MaxSize,
    IN      PDATATYPE DataType,
    IN      PDATAOBJECT DataObject,     OPTIONAL
    OUT     PBOOL StartOverFlag
    )
{
    SUPPLYTEXTARGS Args;
    BOOL b = FALSE;

    Args.TextTitle = TextTitle;
    Args.DescTitle = DescTitle;
    Args.NewText = NewText;
    Args.NewDesc = NewDesc;
    Args.MaxSize = MaxSize;
    Args.DataTypeName = DataType->Name;

    if (DataObject) {
        Args.DataObjectName = DataObject->NameOrPath;
    } else {
        Args.DataObjectName = NULL;
    }

    Args.NoDesc = ((DataType->Flags & DTF_REQUEST_DESCRIPTION) == 0);
    Args.NoText = ((DataType->Flags & DTF_REQUEST_TEXT) == 0);
    Args.ReqDesc = ((DataType->Flags & DTF_REQUIRE_TEXT) == DTF_REQUIRE_TEXT);
    Args.ReqText = ((DataType->Flags & DTF_REQUIRE_DESCRIPTION) == DTF_REQUIRE_DESCRIPTION);
    Args.StartOverFlag = StartOverFlag;

    if (IDOK == DialogBoxParam (
                    g_hInst,
                    MAKEINTRESOURCE(IDD_SUPPLY_TEXT),
                    NULL,
                    pSupplyTextProc,
                    (LPARAM) &Args
                    )) {
        b = TRUE;
    }

    return b;
}


BOOL
CALLBACK
pThankYouProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg) {

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDC_START_OVER:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        case IDCANCEL:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        }

        break;
    }

    return FALSE;
}


VOID
pThankYouBox (
    IN      PBOOL StartOverFlag
    )
{
    if (IDC_START_OVER == DialogBox (g_hInst, MAKEINTRESOURCE(IDD_DONE), NULL, pThankYouProc)) {
        *StartOverFlag = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\binvals.c ===
#include "..\..\common\memdb\binvals.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\usermig\usermig.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    usermig.c

Abstract:

    User migration test tool

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (hInstance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (hInstance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (hInstance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();
}


INT
__cdecl
wmain (
    INT argc,
    WCHAR *argv[]
    )
{
    LONG rc;
    TCHAR DefaultUserHive[MAX_TCHAR_PATH];
    DWORD Size;

    if (!Init()) {
        wprintf (L"Unable to initialize!\n");
        return 255;
    }

    //
    // Initialize Win95Reg
    //

    rc = Win95RegInit (TEXT("c:\\windows\\setup\\defhives"), TRUE);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((LOG_ERROR, "Init Processor: Win95RegInit failed, check your temp files in c:\\windows\\setup"));
        return FALSE;
    }

    if (!MemDbLoad (TEXT("c:\\windows\\setup\\ntsetup.dat"))) {
        LOG ((LOG_ERROR, "Init Processor: MemDbLoad failed, check your temp files in c:\\windows\\setup"));
        return FALSE;
    }

    g_DomainUserName = TEXT("NTDEV\\jimschm");
    g_Win9xUserName  = TEXT("jimschm");
    g_FixedUserName  = TEXT("jimschm");

    //
    // Logon prompt -- make everything NULL
    //

    if (0) {
        g_DomainUserName = NULL;
        g_Win9xUserName  = NULL;
        g_FixedUserName  = NULL;
    }

    //
    // Map in the default user hive
    //

    Size = ARRAYSIZE(DefaultUserHive)- 12;
    if (!GetDefaultUserProfileDirectory (DefaultUserHive, &Size)) {
        LOG ((
            LOG_ERROR,
            "Process User: Can't get default user profile directory",
            DefaultUserHive
            ));

        return FALSE;
    }

    StringCopy (AppendWack (DefaultUserHive), TEXT("ntuser.dat"));

    pSetupEnablePrivilege (SE_BACKUP_NAME, TRUE);
    pSetupEnablePrivilege (SE_RESTORE_NAME, TRUE);

    RegUnLoadKey (HKEY_LOCAL_MACHINE, S_MAPPED_DEFAULT_USER_KEY);
    rc = RegLoadKey (
            HKEY_LOCAL_MACHINE,
            S_MAPPED_DEFAULT_USER_KEY,
            DefaultUserHive
            );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((
            LOG_ERROR,
            "Process User: RegLoadKey could not load NT Default User from %s",
            DefaultUserHive
            ));
        return FALSE;
    }

    InitializeProgressBar (NULL, NULL, NULL, NULL);

    g_hKeyRootNT = HKEY_CURRENT_USER;
    g_hKeyRoot95 = HKEY_CURRENT_USER;
    SetRegRoot (g_hKeyRoot95);

    MergeRegistry (TEXT("d:\\i386\\usermig.inf"), g_DomainUserName ? g_DomainUserName : TEXT(""));

    RegUnLoadKey (HKEY_LOCAL_MACHINE, S_MAPPED_DEFAULT_USER_KEY);

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\fileenum.c ===
#if 0
#include "..\..\common\fileenum\fileenum.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\bintree.c ===
#include "..\..\common\memdb\bintree.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\debug.c ===
#undef UNICODE
#include "..\..\common\migutil\debug.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\file.c ===
#include "..\..\common\migutil\file.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\fileops.c ===
#include "..\..\common\memdb\fileops.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\copyfile.c ===
#ifndef UNICODE
#define UNICODE
#endif

#include "..\..\common\fileenum\copyfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\growlist.c ===
#include "..\..\common\migutil\growlist.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\log.c ===
#undef UNICODE
#include "..\..\common\migutil\log.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\growbuf.c ===
#include "..\..\common\migutil\growbuf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\memdb.c ===
#include "..\..\common\memdb\memdb.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\inf.c ===
#undef UNICODE
#include "..\..\common\migutil\inf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\mdbhash.c ===
#include "..\..\common\memdb\hash.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\main.c ===
#include "..\..\common\migutil\main.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\memdbex.c ===
#include "..\..\common\memdb\memdbex.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\vcc\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\vcc\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\poolmem.c ===
#undef UNICODE
#include "..\..\common\migutil\poolmem.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\vswiz\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\vswiz\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\regops.c ===
#include "..\..\common\memdb\regops.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\strings.c ===
#undef UNICODE
#include "..\..\common\migutil\strings.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\regtrack.c ===
#undef UNICODE
#include "..\..\common\migutil\regtrack.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\w9xtool\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\reg.c ===
#include "..\..\common\migutil\reg.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\w9xtool\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\winntsif\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\winntsif\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\utilslib\unicode.c ===
#include "..\..\common\migutil\unicode.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\wiztools\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\wiztools\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\wiztools\libexp.c ===
#include "pch.h"

#ifdef UPGWIZ4FLOPPY

#undef UPGWIZ4FLOPPY
#include "..\inc\dgdll.h"
#define UPGWIZ4FLOPPY

HINSTANCE g_LocalInst = NULL;

OSVERSIONINFOA
Get_g_OsInfo (
    VOID
    )
{
    return g_OsInfo;
}

PCTSTR
Get_g_WinDir (
    VOID
    )
{
    return g_WinDir;
}

PCTSTR
Get_g_SystemDir (
    VOID
    )
{
    return g_SystemDir;
}

HANDLE
Get_g_hHeap (
    VOID
    )
{
    return g_hHeap;
}

#endif // UPGWIZ4FLOPPY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\vcc\vcc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    vcc.c

Abstract:

    Proof of concept tool for win9x virus check checker.
    Enumerates the active processes on the machine looking for virus scanners that
    can cause problems when upgrading (or clean installing) NT 5.0 on a win9x system
    (Examples are virus scanners that lock the MBR, etc..)

Author:

    Marc R. Whitten (marcw) 11-Sept-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "tlhelp32.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    return InitToolMode (hInstance);
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    TerminateToolMode (hInstance);
}




BOOL
InitMigDbEx (
    PCSTR MigDbFile
    );

BOOL
MigDbTestFile (
    IN OUT PFILE_HELPER_PARAMS Params
    );







INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{

    HANDLE h;
    PROCESSENTRY32 pe;
    FILE_HELPER_PARAMS fileParams;
    PTSTR p;
    WIN32_FIND_DATA fd;
    HANDLE findHandle;
    PTSTR fileString;

    fileParams.VirtualFile = FALSE;

    if (!Init()) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    //
    // Gather information on all the
    //
    h = CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);

    if (h != -1) {

        //
        // Initialize the virus scanner database.
        //
        fileString = JoinPaths (g_DllDir, TEXT("vscandb.inf"));

        if (!InitMigDbEx (fileString)) {
            printf ("vcc - Could not initialeze virus scanner database. (GLE: %d)\n", GetLastError());
            CloseHandle(h);
            return 255;
        }

        FreePathString (fileString);

        SetLastError(ERROR_SUCCESS);

        pe.dwSize = sizeof (PROCESSENTRY32);

        if (Process32First (h, &pe)) {

            do {

                printf ("*** ProcessInfo for process %x\n", pe.th32ProcessID);
                printf ("\tExeName: %s\n", pe.szExeFile);
                printf ("\tThread Count: %d\n\n",pe.cntThreads);

                //
                // Fill in the file helper params for this file..
                //
                ZeroMemory (&fileParams, sizeof(FILE_HELPER_PARAMS));
                fileParams.FullFileSpec = pe.szExeFile;

                p = _tcsrchr (pe.szExeFile, TEXT('\\'));
                if (p) {
                    *p = 0;
                    StringCopy (fileParams.DirSpec, pe.szExeFile);
                    *p = TEXT('\\');
                }

                fileParams.Extension = GetFileExtensionFromPath (pe.szExeFile);

                findHandle = FindFirstFile (pe.szExeFile, &fd);
                if (findHandle != INVALID_HANDLE_VALUE) {

                    fileParams.FindData = &fd;
                    FindClose (findHandle);
                }

                MigDbTestFile (&fileParams);


            } while (Process32Next (h, &pe));
        }
        else {
            printf ("No processes to enumerate..(GLE: %d)\n", GetLastError());
        }

        DoneMigDb (REQUEST_RUN);
        CloseHandle (h);
    }
    else {
        printf ("Snapshot failed.\n");
    }


    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\w9xtool\w9xtool.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    w9xtool.c

Abstract:

    Implements a stub tool that is designed to run with Win9x-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "shellapi.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    return InitToolMode (hInstance);
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    TerminateToolMode (hInstance);
}

INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    SuppressAllLogPopups (TRUE);
    if (!Init()) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    //
    // TODO: Put your code here
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\vswiz\vswiz.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hwwiz.c

Abstract:

    Implements an upgrade wizard for gathering virus scanner information.

Author:

    Marc Whitten (marcw)  16-Oct-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "..\inc\dgdll.h"
#include "..\..\w95upg\migapp\migdbp.h"


DATATYPE g_DataTypes[] = {
    {UPGWIZ_VERSION,
        "Virus Scanner should be detected",
        "You identify running executables that correspond with installed virus scanners on your system.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_ONE_SELECTION,
        1024,
        "&Name of Virus Scanner (<company> <product> <version>)"
    }
};


GROWBUFFER g_DataObjects = GROWBUF_INIT;
POOLHANDLE g_DataObjectPool;
HINSTANCE g_OurInst;
BOOL g_GoodVersion = FALSE;

BOOL
Init (
    VOID
    )
{
#ifndef UPGWIZ4FLOPPY
    return InitToolMode (g_OurInst);
#else
    return TRUE;
#endif
}

VOID
Terminate (
    VOID
    )
{
    //
    // Local cleanup
    //

    FreeGrowBuffer (&g_DataObjects);

    if (g_DataObjectPool) {
        PoolMemDestroyPool (g_DataObjectPool);
    }

#ifndef UPGWIZ4FLOPPY
    TerminateToolMode (g_OurInst);
#endif
}


BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_DETACH) {
        MYASSERT (g_OurInst == hInstance);
        Terminate();
    }

    g_OurInst = hInstance;

    return TRUE;
}


UINT
GiveVersion (
    VOID
    )
{
    Init();

    return UPGWIZ_VERSION;
}


PDATATYPE
GiveDataTypeList (
    OUT     PUINT Count
    )
{
    UINT u;

    *Count = sizeof (g_DataTypes) / sizeof (g_DataTypes[0]);

    for (u = 0 ; u < *Count ; u++) {
        g_DataTypes[u].DataTypeId = u;
    }

    return g_DataTypes;
}


BOOL ParseDosFiles (VOID);


PDATAOBJECT
GiveDataObjectList (
    IN      UINT DataTypeId,
    OUT     PUINT Count
    )
{
    PDATAOBJECT data;
    HANDLE snapShot;
    PROCESSENTRY32 process;
    CHAR name[MEMDB_MAX];
    CHAR fixedPath[MAX_MBCHAR_PATH];
    PSTR company;
    PSTR product;
    PSTR version;

    g_DataObjectPool = PoolMemInitNamedPool ("Data Objects");
    g_GoodVersion = FALSE;


    //
    // Get list of currently running applications.
    //
    snapShot = CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);

    if (snapShot != INVALID_HANDLE_VALUE) {

        //
        // Enumerate all the processes running and retrieve their executables.
        //
        process.dwSize = sizeof (PROCESSENTRY32);
        if (Process32First (snapShot, &process)) {

            do {

                //
                // Get version information if it exists.
                //
                company = QueryVersionEntry (process.szExeFile, "COMPANYNAME");
                product = QueryVersionEntry (process.szExeFile, "PRODUCTNAME");
                version = QueryVersionEntry (process.szExeFile, "PRODUCTVERSION");

                StringCopy (fixedPath, process.szExeFile);
                ReplaceWacks (fixedPath);

                wsprintf (
                    name,
                    "%s\\%s %s\\%s",
                    company ? company : "<unknown>",
                    product ? product : "<unknown>",
                    version ? version : "<unknown>",
                    fixedPath
                    );

                //
                // Create data object for this executable.
                //
                data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof(DATAOBJECT));
                data -> Version = UPGWIZ_VERSION;
                data -> NameOrPath = PoolMemDuplicateString (g_DataObjectPool, name);
                data -> Flags = 0;
                data -> DllParam = PoolMemDuplicateString (g_DataObjectPool, process.szExeFile);

                //
                // Clean up version resources.
                //
                FreePathString (company);
                FreePathString (product);
                FreePathString (version);

            } while (Process32Next (snapShot, &process));
        }
    }

    *Count = g_DataObjects.End / sizeof (DATAOBJECT);

    return (PDATAOBJECT) g_DataObjects.Buf;
}

BOOL
DisplayOptionalUI (
    IN      POUTPUTARGS Args
    )
{
    PDATAOBJECT data = (PDATAOBJECT) g_DataObjects.Buf;
    UINT count = g_DataObjects.End / sizeof (DATAOBJECT);
    UINT i;

    for (i = 0; i < count; i++) {

        if (data -> Flags & DOF_SELECTED) {

            //
            // If we got good version info, don't worry about the text. We'll use
            // what we have.
            //
            if (!IsPatternMatch("<unknown>\\<unknown> <unknown>*",data->NameOrPath)) {

                g_DataTypes[0].Flags &= ~DTF_REQUIRE_DESCRIPTION;
                g_GoodVersion = TRUE;
            }
            break;
        }

        data++;
    }

    return TRUE;
}



BOOL
GenerateOutput (
    IN      POUTPUTARGS Args
    )
{
    BOOL rSuccess = FALSE;
    HANDLE file;
    CHAR path[MAX_MBCHAR_PATH];
    PSTR p;
    PDATAOBJECT data  = (PDATAOBJECT) g_DataObjects.Buf;
    UINT count = g_DataObjects.End / sizeof (DATAOBJECT);
    UINT i;

    //
    // create outbound file path.
    //
    wsprintf (
        path,
        "%s\\vscan.txt",
        Args -> OutboundDir
        );


    //
    // open file.
    //
    printf ("Saving data to %s\n\n", path);

    file = CreateFile (
                path,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (file == INVALID_HANDLE_VALUE) {
        printf ("Can't open file for output.\n");
        return FALSE;
    }

    __try {

         SetFilePointer (file, 0, NULL, FILE_END);

        //
        // log user name and date/time
        //
        if (!WriteHeader (file)) {
            __leave;
        }

        //
        // write data.
        //
        rSuccess = TRUE;
        for (i = 0; i < count; i++) {

            if (data -> Flags & DOF_SELECTED) {

                if (g_GoodVersion) {
                    //
                    // Use the data that we have.
                    //
                    p = _mbsrchr (data -> NameOrPath, '\\');
                    MYASSERT (p);

                    *p = 0;
                }

                //
                // Ask for info if we didn't get any version info, otherwise,
                // we'll use what we got.
                //

                rSuccess &= WriteFileAttributes (
                    Args,
                    g_GoodVersion ? data -> NameOrPath : NULL,
                    file,
                    data -> DllParam,
                    NULL
                    );
            }

            data++;
        }

        //
        // write a final blank line.
        //
        WizardWriteRealString (file, "\r\n\r\n");
    }
    __finally {

        //
        // Don't forget to cleanup resources.
        //
        CloseHandle (file);
    }

    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\cleanup.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    Code to remove an uninstall image

Author:

    Jim Schmidt (jimschm) 19-Jan-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include <shlwapi.h>
#include "undop.h"


BOOL
DoCleanup (
    VOID
    )
{
    TCHAR path[MAX_PATH];
    PCTSTR backUpPath;
    BOOL result = FALSE;

    //
    // Remove the backup files
    //

    backUpPath = GetUndoDirPath();

    if (!backUpPath) {
        DEBUGMSG ((DBG_VERBOSE, "Can't get backup path"));
        return FALSE;
    }

    if (RemoveCompleteDirectory (backUpPath)) {
        result = TRUE;
    } else {
        DEBUGMSG ((DBG_VERBOSE, "Can't delete uninstall backup files"));
    }

    MemFree (g_hHeap, 0, backUpPath);

    //
    // Remove the Add/Remove Programs key and setup reg entries
    //

    if (ERROR_SUCCESS != SHDeleteKey (
                            HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows")
                            )) {
        DEBUGMSG ((DBG_VERBOSE, "Can't delete uninstall key"));
        result = FALSE;
    }

    if (ERROR_SUCCESS != SHDeleteValue (
                            HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                            S_REG_KEY_UNDO_PATH
                            )) {
        DEBUGMSG ((DBG_VERBOSE, "Can't delete %s value", S_REG_KEY_UNDO_PATH));
        result = FALSE;
    }

    if (ERROR_SUCCESS != SHDeleteValue (
                            HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                            S_REG_KEY_UNDO_APP_LIST
                            )) {
        DEBUGMSG ((DBG_VERBOSE, "Can't delete %s value", S_REG_KEY_UNDO_APP_LIST));
        result = FALSE;
    }

    if (ERROR_SUCCESS != SHDeleteValue (
                            HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                            S_REG_KEY_UNDO_INTEGRITY
                            )) {
        DEBUGMSG ((DBG_VERBOSE, "Can't delete %s value", S_REG_KEY_UNDO_INTEGRITY));
        result = FALSE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\wiztools\wiztools.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wiztools.c

Abstract:

    Implements common code for upgwiz wizard plugins.

Author:

    Jim Schmidt (jimschm)  07-Oct-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "..\inc\dgdll.h"
#include "..\..\w95upg\migapp\migdbp.h"

HINSTANCE g_OurInst;

BOOL
Init (
    VOID
    )
{
    return InitToolMode (g_OurInst);
}

VOID
Terminate (
    VOID
    )
{
    TerminateToolMode (g_OurInst);
}


BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    g_OurInst = hInstance;
    return TRUE;
}


VOID
WizToolsMain (
    IN      DWORD dwReason
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        Init();
    } else if (dwReason == DLL_PROCESS_DETACH) {
        Terminate();
    }
}


BOOL
WizardWriteRealString (
    IN      HANDLE File,
    IN      PCSTR String
    )
{
    if (!WriteFileString (File, String)) {
        return FALSE;
    }

    printf ("%s", String);
    return TRUE;
}


VOID
GenerateUniqueStringSectKey (
    IN      PCSTR TwoLetterId,
    OUT     PSTR Buffer
    )
{
    SYSTEMTIME Time;
    DWORD TimeLow, TimeHigh;
    DWORD UserHash;
    DWORD Size;
    CHAR UserName[MAX_USER_NAME];
    PCSTR p;

    Size = MAX_USER_NAME;
    GetUserName (UserName, &Size);

    p = UserName;
    UserHash = 0;
    while (*p) {
        UserHash = _rotl (UserHash, 1) ^ (*p & 0x3f);
        p++;
    }

    GetLocalTime (&Time);

    TimeLow = Time.wMilliseconds +
              Time.wSecond * 1000 +
              Time.wMinute * 60000;

    TimeHigh = Time.wHour +
               Time.wDay * 24 +
               Time.wMonth * 744 +
               Time.wYear * 8928;

    wsprintf (Buffer, "%s%x%x%x", TwoLetterId, TimeLow, TimeHigh, UserHash);
}



BOOL
WriteHeader (
    IN      HANDLE File
    )
{
    CHAR Msg[256];
    CHAR UserName[64];
    DWORD Size = 64;
    SYSTEMTIME SysTime;
    SYSTEMTIME LocTime;
    static PCSTR Month[12] = {"JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"};

    GetUserName (UserName, &Size);
    GetSystemTime (&SysTime);
    GetLocalTime (&LocTime);

    wsprintf (
        Msg,
        "Report From %s on %u:%02u (%u:%02u) %02u-%s-%04u:\r\n\r\n",
        UserName,
        LocTime.wHour,
        LocTime.wMinute,
        SysTime.wHour,
        SysTime.wMinute,
        LocTime.wDay,
        Month[LocTime.wMonth - 1],
        LocTime.wYear
        );

    return WizardWriteRealString (File, Msg);
}


BOOL
pWriteAdditionalSpaces (
    IN      HANDLE File,
    IN      DWORD SpacesWritten,
    IN      DWORD SpacesNeeded
    )
{
    while (SpacesWritten < SpacesNeeded) {
        if (!WizardWriteRealString (File, " ")) {
            return FALSE;
        }
        SpacesWritten ++;
    }
    return TRUE;
}

BOOL
WizardWriteInfString (
    IN      HANDLE File,
    IN      PCSTR String,
    IN      BOOL Quoted,
    IN      BOOL SkipCRLF,
    IN      BOOL ReplaceSpace,
    IN      CHAR SpaceReplacement,
    IN      DWORD ColumnWidth
    )
{
    PCSTR s;
    PSTR d;
    CHAR Buf[2048];
    BOOL quoteMode = FALSE;
    BOOL replaceMode = FALSE;
    DWORD columnWidth = 0;

    if (!String) {
        if (!WizardWriteRealString (File, "\"\"")) {
            return FALSE;
        }
        columnWidth +=2;
        return pWriteAdditionalSpaces (File, columnWidth, ColumnWidth);
    }
    if (Quoted) {
        if (!WizardWriteRealString (File, "\"")) {
            return FALSE;
        }
        columnWidth ++;
    }

    s = String;
    d = Buf;

    while (*s) {
        if (SkipCRLF && ((*s == '\r') || (*s == '\n'))) {
            s++;
            continue;
        }
        if (ReplaceSpace && (*s == ' ')) {
            *d++ = SpaceReplacement;
            s++;
            columnWidth ++;
            continue;
        }
        if (*s == '\"') {
            if (Quoted) {
                *d++ = '\"';
                columnWidth ++;
            } else if (!replaceMode) {
                quoteMode = !quoteMode;
            }
        }
        if (*s == '%') {
            if (!quoteMode && !Quoted) {
                replaceMode = !replaceMode;
                *d++ = '%';
                columnWidth ++;
            }
        }

        *d++ = *s++;
        columnWidth ++;
    }
    if (Quoted) {
        *d++ = '\"';
        columnWidth ++;
    }

    *d = 0;

    if (!WizardWriteRealString (File, Buf)) {
        return FALSE;
    }
    return pWriteAdditionalSpaces (File, columnWidth, ColumnWidth);
}

BOOL
WriteStringSectKey (
    IN      HANDLE File,
    IN      PCSTR KeyName,
    IN      PCSTR String
    )
{
    if (!WizardWriteQuotedString (File, KeyName)) {
        return FALSE;
    }

    if (!WizardWriteRealString (File, " = ")) {
        return FALSE;
    }

    if (!WizardWriteQuotedString (File, String)) {
        return FALSE;
    }

    if (!WizardWriteRealString (File, "\r\n")) {
        return FALSE;
    }

    return TRUE;
}


BOOL
WriteFileAttributes (
    IN      POUTPUTARGS Args,
    IN      PCSTR NonLocalizedName, OPTIONAL
    IN      HANDLE FileHandle,
    IN      PCSTR FileSpec,
    IN      PCSTR Section           OPTIONAL
    )
{
    BOOL b = FALSE;
    WIN32_FIND_DATA fd;
    HANDLE FindHandle;
    CHAR Buf[2048];
    CHAR NameKey[64];
    CHAR TextKey[64];

    FindHandle = FindFirstFile (FileSpec, &fd);
    if (FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    __try {
        GenerateUniqueStringSectKey ("WN", NameKey);
        GenerateUniqueStringSectKey ("WD", TextKey);

        if (Section) {
            if (!WizardWriteRealString (FileHandle, Section)) {
                __leave;
            }

            if (!WizardWriteRealString (FileHandle, "\r\n")) {
                __leave;
            }
        }

        Buf[0] = 0;

        if (NonLocalizedName) {
            wsprintf (Buf, "%s,", NonLocalizedName);
            NameKey[0] = 0;
        } else {
            wsprintf (Buf, "%%%s%%,", NameKey);
        }

        if (Args->OptionalText) {

            wsprintf (_mbschr (Buf, 0), " %%%s%%,", TextKey);

        } else {

            StringCat (Buf, ",");
            TextKey[0] = 0;
        }

        if (!WizardWriteColumn (FileHandle, Buf, 45)) {
            __leave;
        }

        if (GetFileAttributesLine (FileSpec, Buf, 2048)) {

            if (!WizardWriteColumn (FileHandle, Buf, 0)) {
                __leave;
            }

        } else {

            wsprintf (Buf, "%s,", GetFileNameFromPath (FileSpec));
            if (!WizardWriteColumn (FileHandle, Buf, 14)) {
                __leave;
            }

            wsprintf (Buf, "FILESIZE(%u)", fd.nFileSizeLow);

            if (!WizardWriteRealString (FileHandle, Buf)) {
                __leave;
            }
        }

        if (NameKey[0] || TextKey[0]) {
            if (!WizardWriteRealString (FileHandle, "\r\n\r\n[Strings]\r\n")) {
                __leave;
            }
        }

        if (NameKey[0]) {
            if (!WriteStringSectKey (FileHandle, NameKey, Args->OptionalDescription)) {
                __leave;
            }
        }

        if (TextKey[0]) {
            if (!WriteStringSectKey (FileHandle, TextKey, Args->OptionalText)) {
                __leave;
            }
        }

        b = TRUE;
    }
    __finally {
        FindClose (FindHandle);
    }

    return b;
}


#define ATTR_FILESIZE       0x1
#define ATTR_CHECKSUM       0x2
#define ATTR_COMPNAME       0x4
#define ATTR_FILEDESC       0x8
#define ATTR_FILEVER       0x10
#define ATTR_INTNAME       0x20
#define ATTR_LEGAL         0x40
#define ATTR_ORIGNAME      0x80
#define ATTR_PRODNAME     0x100
#define ATTR_PRODVER      0x200
#define ATTR_EXETYPE      0x400
#define ATTR_DESCR16      0x800
#define ATTR_HLPTITLE    0x1000

DWORD g_ListedAttr = 0xFFFFFFFF;

typedef struct _VERSION_DATA {
    PCSTR   versionValue;
    PCSTR   versionName;
    DWORD   attrib;
} VERSION_DATA, *PVERSION_DATA;

VERSION_DATA verData [] =  {{NULL, "COMPANYNAME", ATTR_COMPNAME},
                            {NULL, "PRODUCTVERSION", ATTR_PRODVER},
                            {NULL, "PRODUCTNAME", ATTR_PRODNAME},
                            {NULL, "FILEDESCRIPTION", ATTR_FILEDESC},
                            {NULL, "FILEVERSION", ATTR_FILEVER},
                            {NULL, "ORIGINALFILENAME", ATTR_ORIGNAME},
                            {NULL, "INTERNALNAME", ATTR_INTNAME},
                            {NULL, "LEGALCOPYRIGHT", ATTR_LEGAL},
                            {NULL, NULL, 0}};

extern PSTR g_ExeTypes[4];

BOOL
GetFileAttributesLine (
    IN      PCTSTR FileName,
    OUT     PTSTR Buffer,
    IN      DWORD  BufferSize
    )
{
    FILE_HELPER_PARAMS Params;
    PCTSTR extPtr;
    TCHAR result[MAX_TCHAR_PATH];
    PTSTR resultPtr;
    UINT checkSum;
    DWORD exeType;
    PCSTR fileDesc16;
    PCSTR hlpTitle;
    DWORD listedAttr = 0;
    PVERSION_DATA p;
    WIN32_FIND_DATA FindData;
    BOOL goOn = FALSE;

    while (!goOn) {
        if (!DoesFileExistEx (FileName, &FindData)) {
            sprintf (result, "Target file does not exist: %s", FileName);
            if (MessageBox (NULL, result, "Error", MB_RETRYCANCEL) != IDRETRY) {
                *Buffer = 0;
                return TRUE;
            }
            goOn = FALSE;
        } else {
            goOn = TRUE;
        }
    }
    Params.FindData = &FindData;

    Params.Handled = 0;
    Params.FullFileSpec = FileName;
    extPtr = GetFileNameFromPath (FileName);
    MYASSERT (extPtr);
    StringCopyAB (Params.DirSpec, FileName, extPtr);
    Params.IsDirectory = FALSE;
    Params.Extension = GetFileExtensionFromPath (FileName);
    Params.VirtualFile = FALSE;
    Params.CurrentDirData = NULL;

    _stprintf (
        result,
        TEXT("%-14s"),
        extPtr);
    resultPtr = GetEndOfString (result);

    listedAttr = 0;

    p = verData;
    while (p->versionName) {
        if (((g_ListedAttr == 0xFFFFFFFF) && (listedAttr < 2)) || ((g_ListedAttr != 0xFFFFFFFF) && (g_ListedAttr & p->attrib))) {
            p->versionValue = QueryVersionEntry (FileName, p->versionName);
            if (p->versionValue) {
                listedAttr ++;
            }
        }
        else {
            p->versionValue = NULL;
        }
        p++;
    }
    p = verData;
    while (p->versionName) {
        if (p->versionValue) {
            _stprintf (
                resultPtr,
                TEXT(", %s(\"%s\")"),
                p->versionName,
                p->versionValue);
            resultPtr = GetEndOfString (resultPtr);
        }
        p++;
    }
    if (((g_ListedAttr == 0xFFFFFFFF) && (listedAttr < 2)) || ((g_ListedAttr != 0xFFFFFFFF) && (g_ListedAttr & ATTR_DESCR16))) {
        fileDesc16 = Get16ModuleDescription (FileName);
        if (fileDesc16 != NULL) {
            listedAttr ++;
            _stprintf (
                resultPtr,
                TEXT(", DESCRIPTION(\"%s\")"),
                fileDesc16);
            resultPtr = GetEndOfString (resultPtr);
            FreePathString (fileDesc16);
        }
    }
    if (((g_ListedAttr == 0xFFFFFFFF) && (listedAttr < 2)) || ((g_ListedAttr != 0xFFFFFFFF) && (g_ListedAttr & ATTR_EXETYPE))) {
        exeType = GetModuleType (FileName);
        if (exeType != UNKNOWN_MODULE) {
            listedAttr ++;
            _stprintf (
                resultPtr,
                TEXT(", EXETYPE(\"%s\")"),
                g_ExeTypes[exeType]);
            resultPtr = GetEndOfString (resultPtr);
        }
    }
    if (((g_ListedAttr == 0xFFFFFFFF) && (listedAttr < 2)) || ((g_ListedAttr != 0xFFFFFFFF) && (g_ListedAttr & ATTR_HLPTITLE))) {
        hlpTitle = GetHlpFileTitle (FileName);
        if (hlpTitle != NULL) {
            listedAttr ++;
            _stprintf (
                resultPtr,
                TEXT(", HLPTITLE(\"%s\")"),
                hlpTitle);
            resultPtr = GetEndOfString (resultPtr);
            FreePathString (hlpTitle);
        }
    }
    if (((g_ListedAttr == 0xFFFFFFFF) && (listedAttr < 2)) || ((g_ListedAttr != 0xFFFFFFFF) && (g_ListedAttr & ATTR_FILESIZE))) {
        listedAttr ++;
        _stprintf (
            resultPtr,
            TEXT(", FILESIZE(0x%08lX)"),
            Params.FindData->nFileSizeLow);
        resultPtr = GetEndOfString (resultPtr);
    }
    if (((g_ListedAttr == 0xFFFFFFFF) && (listedAttr < 2)) || ((g_ListedAttr != 0xFFFFFFFF) && (g_ListedAttr & ATTR_CHECKSUM))) {
        listedAttr ++;
        checkSum = ComputeCheckSum (&Params);
        _stprintf (
            resultPtr,
            TEXT(", CHECKSUM(0x%08lX)"),
            checkSum);
        resultPtr = GetEndOfString (resultPtr);
    }

    _tcssafecpy (Buffer, result, BufferSize / sizeof (TCHAR));
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\alert.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    alert.c

Abstract:

    Implements the code to alert the user to problems that might be
    left on the system after uninstall.

Author:

    Jim Schmidt (jimschm)   07-Mar-2001

Revision History:

--*/

#include "pch.h"
#include "undop.h"
#include "resource.h"

typedef struct {
    ULONGLONG Checksum;
    BOOL InOldList;
    BOOL InNewList;
    BOOL ChangedFlag;
    BOOL Duplicate;
    UINT OldReferences;
    UINT NewReferences;
    WCHAR DisplayString[];
} APPLISTITEM, *PAPPLISTITEM;

typedef enum {
    OLD_LIST,
    NEW_LIST
} APPLIST;

BOOL
pAppendAppToGrowList (
    IN OUT  PGROWLIST List,
    IN      PCWSTR DisplayString,
    IN      ULONGLONG Checksum,
    IN      APPLIST WhichList
    )

/*++

Routine Description:

  pAppendAppToGrowList manages a private list of installed apps. The list
  contains information about the app, such as if it was installed originally,
  if it is installed now, what its name is, and if it has changed.

Arguments:

  List - Specifies the grow list containing items; receives the updated list

  DisplayString - Specifies the Add/Remove Programs display string

  Checksum - Specifies the checksum of the Add/Remove Programs config data

  WhichList - Specifies OLD_LIST for an app that was originally on the
      Add/Remove Programs list, or NEW_LIST for an app that is now on the
      ARP list.

Return Value:

  TRUE - Success
  FALSE - Memory alloc failure (might not even be possible; see mem fns)

--*/

{
    PAPPLISTITEM appListItem;
    UINT itemSize;
    PBYTE result;
    UINT count;
    UINT u;

    //
    // Search for an existing identical list item, and update it if found
    //

    count = GrowListGetSize (List);

    for (u = 0 ; u < count ; u++) {
        appListItem = (PAPPLISTITEM) GrowListGetItem (List, u);
        if (StringIMatchW (DisplayString, appListItem->DisplayString)) {
            if (appListItem->Checksum == Checksum) {
                break;
            }
        }
    }

    if (u < count) {
        if (WhichList == OLD_LIST) {
            appListItem->OldReferences += 1;
            appListItem->InOldList = TRUE;
        } else {
            appListItem->NewReferences += 1;
            appListItem->InNewList = TRUE;
        }
        return TRUE;
    }

    //
    // This item is not on the list; add it now. First construct a structure
    // in a temporary buffer, then put it in the list.
    //

    itemSize = SizeOfStringW (DisplayString) + sizeof (APPLISTITEM);
    appListItem = (PAPPLISTITEM) MemAllocZeroed (itemSize);

    if (!appListItem) {
        return FALSE;
    }

    appListItem->Checksum = Checksum;
    if (WhichList == OLD_LIST) {
        appListItem->OldReferences = 1;
        appListItem->InOldList = TRUE;
    } else {
        appListItem->NewReferences = 1;
        appListItem->InNewList = TRUE;
    }
    StringCopyW (appListItem->DisplayString, DisplayString);

    result = GrowListAppend (List, (PBYTE) appListItem, itemSize);
    FreeMem (appListItem);

    return result != NULL;
}


VOID
pIdentifyDuplicates (
    IN OUT  PGROWLIST List
    )

/*++

Routine Description:

  pIdentifyDuplicates scans the apps in the specified list, and merges them so
  that duplicates are ignored. Duplicates are determined by comparing the
  application title name only. When they are found, the flags are merged into
  the first instance.

  When merging the first instance with a duplicate, the following combinations
  are possible:

  unchanged = InOldList && InNewList && !ChangedFlag
  new = !InOldList && InNewList         (force ChangedFlag=TRUE)
  removed = InOldList && !InNewList     (force ChangedFlag=TRUE)
  changed = InOldList && InNewList && ChangedFlag

                  |             Dup Inst
  1st Inst        |  unchanged  |    new    |   removed   |   changed
  -----------------------------------------------------------------------
    unchanged     |  UNCHANGED  |  changed  |  changed    |   changed
  -----------------------------------------------------------------------
    new           |  changed    |  NEW      |  changed    |   changed
  -----------------------------------------------------------------------
    removed       |  changed    |  changed  |  REMOVED    |   changed
  -----------------------------------------------------------------------
    changed       |  changed    |  changed  |  changed    |   CHANGED
  -----------------------------------------------------------------------

  Any time there is a conflict between two identically named entries, we have
  to assume "changed" because we cannot tell exactly what happened.


Arguments:

  List - Specifies the list of apps. Receives updated flags.

Return Value:

  None.

--*/

{
    UINT count;
    UINT u;
    UINT v;
    PAPPLISTITEM appListItem;
    PAPPLISTITEM lookAheadItem;

    count = GrowListGetSize (List);

    for (u = 0 ; u < count ; u++) {
        appListItem = (PAPPLISTITEM) GrowListGetItem (List, u);
        if (appListItem->Duplicate) {
            continue;
        }

        if (appListItem->InOldList != appListItem->InNewList) {
            appListItem->ChangedFlag = TRUE;
        }

        for (v = u + 1 ; v < count ; v++) {
            lookAheadItem = (PAPPLISTITEM) GrowListGetItem (List, v);
            if (lookAheadItem->Duplicate) {
                continue;
            }

            if (StringIMatchW (appListItem->DisplayString, lookAheadItem->DisplayString)) {
                lookAheadItem->Duplicate = TRUE;
                appListItem->InOldList |= lookAheadItem->InOldList;
                appListItem->InNewList |= lookAheadItem->InNewList;
                appListItem->ChangedFlag |= lookAheadItem->ChangedFlag;

                if (lookAheadItem->InOldList != lookAheadItem->InNewList) {
                    appListItem->ChangedFlag = TRUE;
                }
            }
        }
    }
}


INT_PTR
CALLBACK
pDisplayProgramsProc (
    IN      HWND hwndDlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )
{
    PCWSTR text;

    switch (uMsg) {

    case WM_INITDIALOG:
        text = (PCWSTR) lParam;
        MYASSERT (text);

        SetDlgItemTextW (hwndDlg, IDC_EDIT1, text);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDOK:
            EndDialog (hwndDlg, IDOK);
            break;

        case IDCANCEL:
            EndDialog (hwndDlg, IDCANCEL);
            break;
        }
    }

    return FALSE;
}


BOOL
pDisplayProgramsDlg (
    IN      HWND UiParent,
    IN      PCWSTR ReportText
    )
{
    INT_PTR result;

    result = DialogBoxParam (
                g_hInst,
                MAKEINTRESOURCE(IDD_APP_CHANGES),
                UiParent,
                pDisplayProgramsProc,
                (LPARAM) ReportText
                );

    return result == IDOK;
}


BOOL
pProvideAppInstallAlert (
    IN      HWND UiParent
    )

/*++

Routine Description:

  pProvideAppInstallAlert generates a dialog whenever the Add/Remove Programs
  list is different from what exists at the time of the upgrade. The user has
  the ability to quit uninstall.

Arguments:

  UiParent - Specifies the HWND of the parent window, typically the desktop

Return Value:

  TRUE to continue with uninstall
  FALSE to quit uninstall

--*/

{
    GROWLIST appList = GROWLIST_INIT;
    GROWBUFFER installedApps = GROWBUF_INIT;
    GROWBUFFER newBuf = GROWBUF_INIT;
    GROWBUFFER changedBuf = GROWBUF_INIT;
    GROWBUFFER delBuf = GROWBUF_INIT;
    BOOL result = FALSE;
    GROWBUFFER completeText = GROWBUF_INIT;
    WCHAR titleBuffer[256];
    PINSTALLEDAPPW installedAppList;
    UINT appCount;
    UINT count;
    UINT u;
    PAPPLISTITEM appListItem;
    HKEY key = NULL;
    PBYTE data;
    PCWSTR nextStr;
    ULONGLONG *ullPtr;
    BOOL failed;
    UINT size;
    PBYTE endOfLastString;

    //
    // Provide an alert whenever entries in Add/Remove Programs have changed.
    // Get the original list from the registry. Then compare that list to what
    // is presently installed.
    //

    __try {
        //
        // Add the apps recorded in the registry
        //

        key = OpenRegKeyStr (S_REGKEY_WIN_SETUP);
        if (!key) {
            DEBUGMSG ((DBG_ERROR, "Can't open %s", S_REGKEY_WIN_SETUP));
            __leave;            // fail uninstall; this should never happen
        }

        if (!GetRegValueTypeAndSize (key, S_REG_KEY_UNDO_APP_LIST, NULL, &size)) {

            DEBUGMSG ((DBG_ERROR, "Can't query app list in %s", S_REGKEY_WIN_SETUP));
            result = TRUE;
            __leave;            // continue with uninstall skipping the app alert

        } else {

            data = GetRegValueBinary (key, S_REG_KEY_UNDO_APP_LIST);

            if (!data) {
                result = TRUE;
                __leave;        // continue with uninstall skipping the app alert
            }

            //
            // Compute the address of the first byte beyond the nul terminator for
            // the last printable display name string, so we can protect ourselves
            // from bad registry data.
            //

            endOfLastString = data + size - sizeof (ULONGLONG) - sizeof (WCHAR);
        }

        __try {
            //
            // Read in the app list stored in our registry blob
            //

            failed = FALSE;

            nextStr = (PCWSTR) data;
            while (*nextStr) {
                // this might throw an exception:
                ullPtr = (ULONGLONG *) (GetEndOfStringW (nextStr) + 1);

                //
                // ensure the checksum pointer is not beyond what we expect to be
                // the first byte past the last non-empty display name string
                //

                if ((PBYTE) ullPtr > endOfLastString) {
                    failed = TRUE;
                    break;
                }

                DEBUGMSGW ((DBG_NAUSEA, "Original app: %s", nextStr));

                pAppendAppToGrowList (
                    &appList,
                    nextStr,
                    *ullPtr,
                    OLD_LIST
                    );

                nextStr = (PCWSTR) (ullPtr + 1);
            }
        }
        __except (TRUE) {
            failed = TRUE;
        }

        FreeMem (data);
        if (failed) {
            DEBUGMSG ((DBG_ERROR, "App key in %s is invalid", S_REGKEY_WIN_SETUP));
            result = TRUE;
            __leave;        // continue with uninstall skipping the app alert
        }

        //
        // Add all the *current* apps to the list
        //

        CoInitialize (NULL);
        installedAppList = GetInstalledAppsW (&installedApps, &appCount);

        if (installedAppList) {
            for (u = 0 ; u < appCount ; u++) {

                DEBUGMSGW ((DBG_NAUSEA, "Identified %s", installedAppList->DisplayName));

                pAppendAppToGrowList (
                    &appList,
                    installedAppList->DisplayName,
                    installedAppList->Checksum,
                    NEW_LIST
                    );

                installedAppList++;
            }
        } else {
            result = TRUE;
            __leave;        // continue with uninstall skipping the app alert
        }

        //
        // Compute the overlap of the original and current apps
        //

        pIdentifyDuplicates (&appList);

        //
        // Produce a formatted list for each of the three possible cases
        // (new, remove, change)
        //

        count = GrowListGetSize (&appList);

        for (u = 0 ; u < count ; u++) {
            appListItem = (PAPPLISTITEM) GrowListGetItem (&appList, u);

            if (appListItem->Duplicate) {
                continue;
            }

            DEBUGMSGW ((DBG_NAUSEA, "Processing %s", appListItem->DisplayString));

            if (appListItem->InOldList && appListItem->InNewList) {
                if (appListItem->ChangedFlag ||
                    (appListItem->OldReferences != appListItem->NewReferences)
                    ) {

                    DEBUGMSG_IF ((
                        appListItem->ChangedFlag,
                        DBG_VERBOSE,
                        "%ws has change flag",
                        appListItem->DisplayString
                        ));

                    DEBUGMSG_IF ((
                        appListItem->OldReferences != appListItem->NewReferences,
                        DBG_VERBOSE,
                        "%ws has different ref count (old=%u vs new=%u)",
                        appListItem->DisplayString,
                        appListItem->OldReferences,
                        appListItem->NewReferences
                        ));

                    GrowBufAppendStringW (&changedBuf, L"  ");
                    GrowBufAppendStringW (&changedBuf, appListItem->DisplayString);
                    GrowBufAppendStringW (&changedBuf, L"\r\n");

                } else {
                    DEBUGMSG ((DBG_VERBOSE, "%ws has not changed", appListItem->DisplayString));
                }
            } else if (appListItem->InOldList) {

                DEBUGMSG ((DBG_VERBOSE, "%ws was removed", appListItem->DisplayString));
                GrowBufAppendStringW (&delBuf, L"  ");
                GrowBufAppendStringW (&delBuf, appListItem->DisplayString);
                GrowBufAppendStringW (&delBuf, L"\r\n");

            } else if (appListItem->InNewList) {

                DEBUGMSG ((DBG_VERBOSE, "%ws was added", appListItem->DisplayString));
                GrowBufAppendStringW (&newBuf, L"  ");
                GrowBufAppendStringW (&newBuf, appListItem->DisplayString);
                GrowBufAppendStringW (&newBuf, L"\r\n");

            } else {
                MYASSERT (FALSE);
            }
        }

        //
        // Build the report text in a single buffer
        //

        if (newBuf.End) {
            //
            // Append software that is newly installed
            //

            __try {
                if (!LoadStringW (g_hInst, IDS_NEW_PROGRAMS, titleBuffer, ARRAYSIZE(titleBuffer))) {
                    DEBUGMSG ((DBG_ERROR, "Can't load New Programs heading text"));
                    __leave;
                }

                GrowBufAppendStringW (&completeText, titleBuffer);
                GrowBufAppendStringW (&completeText, L"\r\n");
                GrowBufAppendStringW (&completeText, (PCWSTR) newBuf.Buf);
            }
            __finally {
            }
        }

        if (delBuf.End) {
            //
            // Append software that was removed
            //

            __try {
                if (!LoadStringW (g_hInst, IDS_DELETED_PROGRAMS, titleBuffer, ARRAYSIZE(titleBuffer))) {
                    DEBUGMSG ((DBG_ERROR, "Can't load Deleted Programs heading text"));
                    __leave;
                }

                if (completeText.End) {
                    GrowBufAppendStringW (&completeText, L"\r\n");
                }

                GrowBufAppendStringW (&completeText, titleBuffer);
                GrowBufAppendStringW (&completeText, L"\r\n");
                GrowBufAppendStringW (&completeText, (PCWSTR) delBuf.Buf);
            }
            __finally {
            }
        }

        if (changedBuf.End) {
            //
            // Append software that was altered
            //

            __try {
                if (!LoadStringW (g_hInst, IDS_CHANGED_PROGRAMS, titleBuffer, ARRAYSIZE(titleBuffer))) {
                    DEBUGMSG ((DBG_ERROR, "Can't load Changed Programs heading text"));
                    __leave;
                }

                if (completeText.End) {
                    GrowBufAppendStringW (&completeText, L"\r\n");
                }

                GrowBufAppendStringW (&completeText, titleBuffer);
                GrowBufAppendStringW (&completeText, L"\r\n");
                GrowBufAppendStringW (&completeText, (PCWSTR) changedBuf.Buf);
            }
            __finally {
            }
        }

        //
        // Display UI
        //

        if (completeText.End) {
            result = pDisplayProgramsDlg (UiParent, (PCWSTR) completeText.Buf);
        } else {
            DEBUGMSG ((DBG_VERBOSE, "No app conflicts; continuing without UI alert"));
            result = TRUE;
        }
    }
    __finally {

        //
        // Done
        //

        FreeGrowBuffer (&newBuf);
        FreeGrowBuffer (&changedBuf);
        FreeGrowBuffer (&delBuf);
        FreeGrowBuffer (&completeText);
        FreeGrowBuffer (&installedApps);

        FreeGrowList (&appList);

        CloseRegKey (key);
    }

    return result;
}


BOOL
ProvideUiAlerts (
    IN      HWND ParentWindow
    )

/*++

Routine Description:

  ProvideUiAlerts executes the functions that produce UI after the user has
  chosen to uninstall the current operating system. The goal is to warn the
  user about problems known to exist after the uninstall is complete.

  This function is called before any changes are made to the system.

Arguments:

  ParentWindow - Specifies the HWND to the parent for the UI, normally the
        desktop window

Return Value:

  TRUE - Continue with uninstall
  FALSE - Quit uninstall

--*/

{
    DeferredInit();

    //
    // Add other UI alerts here
    //

    return pProvideAppInstallAlert (ParentWindow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\tools\winntsif\winntsif.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    winntsif.c

Abstract:

    Implements a stub tool that is designed to run with Win9x-side
    upgrade code.

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    return InitToolMode (hInstance);
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;

    hInstance = GetModuleHandle (NULL);

    TerminateToolMode (hInstance);
}


INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    if (!Init()) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    g_SourceDirectories[0] = TEXT("d:\\i386");
    g_SourceDirectoryCount = 1;

    GetNeededLangDirs ();

    BuildWinntSifFile(REQUEST_RUN);
    WriteInfToDisk(TEXT("c:\\output.sif"));
    printf("Answer File Data written to c:\\output.sif.\n");

    //MemDbSave(TEXT("c:\\ntsetup.dat"));




    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\com.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    com.h

Abstract:

    Declares interfaces for our COM objects.

Author:

    Jim Schmidt (jimschm) 21-Feb-2001

Revision History:

    <alias> <date> <comments>

--*/

#include <emptyvc.h>

extern INT g_DllObjects;
extern INT g_DllLocks;

class CUninstallClassFactory : public IClassFactory
{
private:
protected:
    ULONG _References;

public:
    //
    // Constructors
    //
    CUninstallClassFactory (VOID);
    ~CUninstallClassFactory (VOID);

    //
    // IUnknown interface members
    //
    STDMETHODIMP QueryInterface (REFIID, PVOID *);
    STDMETHODIMP_(ULONG) AddRef (VOID);
    STDMETHODIMP_(ULONG) Release (VOID);

    //
    // IClassFactory interface members
    //
    STDMETHODIMP CreateInstance (LPUNKNOWN, REFIID, PVOID *);
    STDMETHODIMP LockServer (BOOL);
};

typedef CUninstallClassFactory *PUNINSTALLCLASSFACTORY;



class CUninstallDiskCleaner : public IEmptyVolumeCache
{
private:
protected:
    //
    // Data
    //
    ULONG _References;
    BOOL _Purged;

public:
    //
    // Constructors
    //
    CUninstallDiskCleaner (VOID);
    ~CUninstallDiskCleaner (VOID);

    //
    // IUnknown interface members
    //
    STDMETHODIMP QueryInterface (REFIID, PVOID *);
    STDMETHODIMP_(ULONG) AddRef (VOID);
    STDMETHODIMP_(ULONG) Release (VOID);

    //
    // IEmptyVolumeCache interface members
    //
    STDMETHODIMP
    Initialize (
        IN      HKEY hRegKey,
        IN      PCWSTR Volume,
        OUT     PWSTR *DisplayName,
        OUT     PWSTR *Description,
        OUT     DWORD *Flags
        );

    STDMETHODIMP
    GetSpaceUsed (
        OUT     DWORDLONG *SpaceUsed,
        OUT     IEmptyVolumeCacheCallBack *Callback
        );

    STDMETHODIMP
    Purge (
        IN      DWORDLONG SpaceToFree,
        OUT     IEmptyVolumeCacheCallBack *Callback
        );

    STDMETHODIMP
    ShowProperties (
        IN      HWND hwnd
        );

    STDMETHODIMP
    Deactivate (
        OUT     DWORD *Flags
        );
};

typedef CUninstallDiskCleaner *PUNINSTALLDISKCLEANER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDS_TITLE                       100
#define IDD_APP_CHANGES                 101
#define IDS_NEW_PROGRAMS                101
#define IDS_CHANGED_PROGRAMS            102
#define IDI_WARNICON                    102
#define IDS_DELETED_PROGRAMS            103
#define IDC_TEXT1                       201
#define IDC_TEXT2                       202
#define IDC_TEXT3                       203
#define IDC_TEXT4                       204
#define IDC_EDIT1                       1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\makefile.inc ===
!if !defined(CLEANINF_FLAGS)
CLEANINF_FLAGS = -w
!endif

CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

undo.rc : $(SELFREGNAME)

$(SELFREGNAME) : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\diskcleaner.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    diskcleaner.c

Abstract:

    Implements the code specific to the disk cleaner COM server.

Author:

    Jim Schmidt (jimschm) 21-Jan-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "undop.h"
#include "com.h"

/*++

Routine Descriptions:

  This constructor is a generic class factory that supports multiple object
  types. Upon creation, the object interface pointer ref count is set to zero,
  and the global number of objects for the dll is incremented.

  The destructor simply decrements the DLL object count.

Arguments:

  None.

Return Value:

  None.

--*/

CUninstallDiskCleaner::CUninstallDiskCleaner (
    VOID
    )

{
    //
    // -Initialize the interface pointer count
    // -Increment the DLL's global count of objects
    //
    _References = 0;
    g_DllObjects++;
}

CUninstallDiskCleaner::~CUninstallDiskCleaner (
    VOID
    )
{
    g_DllObjects--;
}


STDMETHODIMP
CUninstallDiskCleaner::QueryInterface (
    IN      REFIID InterfaceIdRef,
    OUT     PVOID *InterfacePtr
    )
{
    HRESULT hr = S_OK;

    DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Entering"));

    __try {
        //
        // Initialize out arg
        //

        __try {
            *InterfacePtr = NULL;
        }
        __except(1) {
            hr = E_INVALIDARG;
        }

        if (hr != S_OK) {
            DEBUGMSG ((DBG_ERROR, __FUNCTION__ ": Invalid InterfacePtr arg"));
            __leave;
        }

        //
        // Test for the supported interface
        //
        if (IsEqualIID (InterfaceIdRef, IID_IUnknown)) {
            DEBUGMSG ((DBG_VERBOSE, "Caller requested IUnknown"));
            *InterfacePtr = (LPUNKNOWN) this;
            AddRef();
            __leave;
        }

        if (IsEqualIID (InterfaceIdRef, IID_IEmptyVolumeCache)) {
            DEBUGMSG ((DBG_VERBOSE, "Caller requested IEmptyVolumeCache"));
            *InterfacePtr = (IEmptyVolumeCache*) this;
            AddRef();
            __leave;
        }

        DEBUGMSG ((DBG_WARNING, "Caller requested unknown interface"));
        hr = E_NOINTERFACE;
    }
    __finally {
    }

    DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Leaving"));

    return hr;
}


/*++

Routine Description:

  AddRef is the standard IUnknown member function that increments the object
  reference count.

  Release is the standard IUnknown member function that decrements the object
  reference count.

Arguments:

  None.

Return Value:

  The number of interface references.

--*/

STDMETHODIMP_(ULONG)
CUninstallDiskCleaner::AddRef (
    VOID
    )
{
    return ++_References;
}


STDMETHODIMP_(ULONG)
CUninstallDiskCleaner::Release (
    VOID
    )
{
    if (!_References) {
        DEBUGMSG ((DBG_ERROR, "Can't release because there are no references"));
    } else {
        _References--;

        if (!_References) {
            delete this;
            return 0;
        }
    }

    return _References;
}


STDMETHODIMP
CUninstallDiskCleaner::Initialize (
    IN      HKEY hRegKey,
    IN      PCWSTR VolumePath,
    OUT     PWSTR *DisplayName,
    OUT     PWSTR *Description,
    IN OUT  DWORD *Flags
    )

/*++

Routine Description:

  The Initialize member function does most of the work for the disk cleaner.
  It evaluates the backup files, and if they all exist, and the user has the
  right to execute an uninstall, and if they are at least 7 days old, then
  show the backup items in the list box.

Arguments:

  hRegKey - Specifies the registry key for this object, used to store
        properties and settings

  VolumePath - Specifies the volume path selected by the user when they launch
        disk cleanup

  DisplayName - Receives the name to put in the disk cleaner list box, or NULL
        to use the name stored in the registry

  Description - Receives the verbose description to put in the disk cleaner
        Details text control, or NULL to use the description stored in the
        registry

  Flags - Specifies flags that influence the behavior of this disk cleaner
        object and flags that indicate which mode the disk cleaner is running
        in. Receivies flags that control how the disk cleaner displays this
        object's info in its UI.

Return Value:

  S_FALSE - The disk cleaner will skip this object
  S_OK - The disk cleaner will include this object in its UI

--*/

{
    HRESULT hr = S_FALSE;
    DWORD inFlags = *Flags;
    ULONGLONG diskSpace;
    UNINSTALLSTATUS status;

    DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Entering"));

    __try {
        //
        // Initialize
        //

        _Purged = FALSE;

        *DisplayName = NULL;    // use the display name stored in the registry
        *Description = NULL;    // use the description stored in the registry
        *Flags = 0;             // unchecked by default, no property page

        //
        // Check undo files. If they are not at least 7 days old, don't
        // recommend them to be deleted.
        //

        status = SanityCheck (FAIL_IF_NOT_OLD, VolumePath, &diskSpace);
        if (status == Uninstall_NewImage) {
            DEBUGMSG ((DBG_WARNING, "OS Backup Image is too new to be listed in the disk cleaner"));
            __leave;
        }

        if (diskSpace == 0) {
            DEBUGMSG ((DBG_WARNING, "OS Backup Image is not present, isn't valid, can't be removed, or has missing registry entries"));
            __leave;
        }

        //
        // Files are old enough and are present on the machine. Initialize the
        // IEmptyVolumeCache interface
        //

        if (inFlags & EVCF_SETTINGSMODE) {
            DEBUGMSG ((DBG_VERBOSE, "We don't support settings mode"));
            __leave;
        }

        hr = S_OK;
        DEBUGMSG ((DBG_VERBOSE, "Successful initialization"));
    }
    __finally {
    }

    DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Leaving"));

    return hr;
}


STDMETHODIMP
CUninstallDiskCleaner::GetSpaceUsed (
    OUT     DWORDLONG *SpaceUsed,
    IN      IEmptyVolumeCacheCallBack *Callback
    )

/*++

Routine Description:

  GetSpaceUsed is called by the disk cleaner after this object has
  successfully initialized. Our job is to return the amount of disk space we
  can clean up. Since all undo files are on the same drive, we don't care
  about the volume restriction passed to the Initialize member function.

Arguments:

  SpaceUsed - Receives the amount of disk space that we can recover upon
        deletion. We don't take into account cluster savings, but maybe we
        should.

  Callback - Specifies an object that provides a progress interface. We don't
        use this.

Return Value:

  S_FALSE - Failed to get disk space values
  S_OK - Success

--*/

{
    ULONGLONG diskSpace;
    HRESULT hr = S_FALSE;

    DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Entering"));

    __try {

        if (SanityCheck (QUICK_CHECK, NULL, &diskSpace) == Uninstall_NewImage) {
            DEBUGMSG ((DBG_ERROR, "Sanity check failed"));
            __leave;
        }

        DEBUGMSG ((DBG_VERBOSE, "Disk space: %I64u", diskSpace));
        *SpaceUsed = (DWORDLONG) diskSpace;
        hr = S_OK;
    }
    __finally {
    }

    DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Leaving"));
    return hr;
}


STDMETHODIMP
CUninstallDiskCleaner::Purge (
    IN      DWORDLONG SpaceToFree,
    IN      IEmptyVolumeCacheCallBack *Callback
    )

/*++

Routine Description:

  Purge does the deletion. We don't care about the inbound arguments. If we
  are called, it is because Initialize succeeded, and GetSpaceUsed returned a
  valid number. These two things mean it is OK to remove uninstall capability.

Arguments:

  SpaceToFree - Specifies the space to free. We expect this to equal the
        value provided in GetSpaceUsed.

  Callback - Specifies an interface for progress updates. We don't use this.

Return Value:

  S_OK - Success
  S_FALSE - Failed

--*/

{
    HRESULT hr = S_FALSE;

    DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Entering"));

    __try {
        if (!DoCleanup()) {
            __leave;
        }

        _Purged = TRUE;
        hr = S_OK;
    }
    __finally {
    }

    DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Leaving"));

    return hr;
}


//
// NO-OP property page stub
//

STDMETHODIMP
CUninstallDiskCleaner::ShowProperties (
    IN      HWND hwnd
    )
{
    MYASSERT (FALSE);
    return S_FALSE;
}


STDMETHODIMP
CUninstallDiskCleaner::Deactivate (
    OUT     DWORD *Flags
    )

/*++

Routine Description:

  Deactivate indicates if the uninstall list item should be permanently
  removed from the disk cleaner or not, based on a successful deletion of the
  backup image.

Arguments:

  Flags - Receives the indicator to remove the list item from the disk
          cleaner list

Return Value:

  Always S_OK

--*/

{
    //
    // Done -- if we deleted uninstall, remove the list item
    //

    *Flags = _Purged ? EVCF_REMOVEFROMLIST : 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\interface.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    interface.c

Abstract:

    Implements the APIs exposed by osuninst.dll

Author:

    Jim Schmidt (jimschm) 19-Jan-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "undop.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

#ifndef UNICODE
#error UNICODE required
#endif

BOOL g_Initialized = FALSE;


//
// Entry point for DLL
//

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    SuppressAllLogPopups (TRUE);

    if (!MigUtil_Entry (g_hInst, Reason, NULL)) {
        return FALSE;
    }

    //
    // Add others here if needed (don't forget to prototype above)
    //

    return TRUE;
}


BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )

{
    switch (dwReason)  {

    case DLL_PROCESS_ATTACH:
        g_hInst = hInstance;
        break;

    case DLL_PROCESS_DETACH:
        if (g_Initialized) {
            pCallEntryPoints (DLL_PROCESS_DETACH);
            g_Initialized = FALSE;
            break;
        }
    }

    return TRUE;
}


VOID
DeferredInit (
    VOID
    )
{

    if (g_Initialized) {
        return;
    }

    g_Initialized = TRUE;

    g_hHeap = GetProcessHeap();

    pCallEntryPoints (DLL_PROCESS_ATTACH);
}


DWORD
pUninstallStatusToWin32Error (
    UNINSTALLSTATUS Status
    )
{
    DWORD result = E_UNEXPECTED;

    switch (Status) {

    case Uninstall_Valid:
        result = ERROR_SUCCESS;
        break;

    case Uninstall_DidNotFindRegistryEntries:
        result = ERROR_RESOURCE_NOT_PRESENT;
        break;

    case Uninstall_DidNotFindDirOrFiles:
        result = ERROR_FILE_NOT_FOUND;
        break;

    case Uninstall_InvalidOsVersion:
        result = ERROR_OLD_WIN_VERSION;
        break;

    case Uninstall_NotEnoughPrivileges:
        result = ERROR_ACCESS_DENIED;
        break;

    case Uninstall_FileWasModified:
        result = ERROR_FILE_INVALID;
        break;

    case Uninstall_Unsupported:
        result = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    case Uninstall_NewImage:
        result = ERROR_INVALID_TIME;
        break;

    case Uninstall_Exception:
        result = ERROR_NOACCESS;
        break;

    case Uninstall_OldImage:
        result = ERROR_TIMEOUT;
        break;

    case Uninstall_NotEnoughMemory:
        result = ERROR_NOT_ENOUGH_MEMORY;
        break;

    default:
        break;
    }

    SetLastError (result);
    return result;
}


BOOL
pGetVersionDword (
    IN      HKEY Key,
    IN      PCTSTR ValueName,
    OUT     PDWORD ValueData
    )
{
    PDWORD data;

    data = (PDWORD) GetRegValueDword (Key, ValueName);
    if (!data) {
        return FALSE;
    }

    *ValueData = *data;
    MemFree (g_hHeap, 0, data);

    return TRUE;
}


UNINSTALLSTATUS
IsUninstallImageValid (
    UNINSTALLTESTCOMPONENT ComponentType,
    OSVERSIONINFOEX *BackedUpOsVersion          OPTIONAL
    )
{
    UNINSTALLSTATUS status = Uninstall_Valid;
    DWORD orgVersionSize;
    HKEY key = NULL;
    ULONG error;
    PDWORD value;
    HKEY versionKey = NULL;
    OSVERSIONINFOEX ourVersion = {
        sizeof (OSVERSIONINFOEX),
        4,
        10,
        1998,
        VER_PLATFORM_WIN32_NT,
        TEXT(""),
        0,
        0,
        0,
        0
        };

    DeferredInit();

    __try {
        //
        // Fill in version structure if possible, default to Win98 gold if not
        //

        key = OpenRegKeyStr (S_WINLOGON_REGKEY);
        if (key) {
            value = (PDWORD) GetRegValueDword (key, S_WIN9XUPG_FLAG_VALNAME);
            if (!value) {
                //
                // It is not looking like a Win9x upgrade!
                //

                DEBUGMSG ((DBG_VERBOSE, "Can't find %s in WinLogon reg key", S_WIN9XUPG_FLAG_VALNAME));
                status = Uninstall_DidNotFindRegistryEntries;
            } else {
                if (*value) {
                    //
                    // Version info should be present
                    //

                    versionKey = OpenRegKey (key, TEXT("PrevOsVersion"));

                    if (versionKey) {
                        pGetVersionDword (versionKey, MEMDB_ITEM_MAJOR_VERSION, &ourVersion.dwMajorVersion);
                        pGetVersionDword (versionKey, MEMDB_ITEM_MINOR_VERSION, &ourVersion.dwMinorVersion);
                        pGetVersionDword (versionKey, MEMDB_ITEM_BUILD_NUMBER, &ourVersion.dwBuildNumber);
                        pGetVersionDword (versionKey, MEMDB_ITEM_PLATFORM_ID, &ourVersion.dwPlatformId);
                    } else {
                        DEBUGMSG ((DBG_VERBOSE, "Did not find PrevOsVersion; defaulting to Win98 gold"));
                    }

                } else {
                    DEBUGMSG ((DBG_VERBOSE, "Not a Win9x upgrade"));
                    status = Uninstall_DidNotFindRegistryEntries;
                }
                MemFree (g_hHeap, 0, value);
            }
        }
    }
    __finally {
        if (versionKey)
            CloseRegKey (versionKey);
        if (key)
            CloseRegKey (key);
    }

    //
    // ComponentType is provided to allow special-case behavior to be
    // performed. For example, maybe we want to warn on FAT-to-NTFS
    // conversion when coming from Win9x, but we don't care when coming
    // from Win2k.
    //

    if (status == Uninstall_Valid) {
        status = SanityCheck (QUICK_CHECK, NULL, NULL);

        if (ComponentType == Uninstall_FatToNtfsConversion) {
            if (status == Uninstall_OldImage) {
                //
                // Do not suppress convert.exe warning even if uninstall is old
                //

                status = Uninstall_Valid;
            }
        }
    }

    if (status == Uninstall_Valid) {
        if (BackedUpOsVersion) {
            __try {
                orgVersionSize = BackedUpOsVersion->dwOSVersionInfoSize;
                orgVersionSize = min (orgVersionSize, sizeof (ourVersion));
                CopyMemory (BackedUpOsVersion, &ourVersion, orgVersionSize);
                BackedUpOsVersion->dwOSVersionInfoSize = orgVersionSize;
            }
            __except (1) {
                status = Uninstall_Exception;
            }
        }
    }

    pUninstallStatusToWin32Error (status);
    return status;
}



ULONGLONG
GetUninstallImageSize (
    VOID
    )
{
    ULONGLONG diskSpace;

    DeferredInit();

    //
    // SanityCheck returns the disk space used by the uninstall image,
    // regardless if it is valid or not.
    //

    SanityCheck (QUICK_CHECK, NULL, &diskSpace);

    return diskSpace;
}


BOOL
RemoveUninstallImage (
    VOID
    )
{
    DeferredInit();
    return DoCleanup();
}


BOOL
ExecuteUninstall (
    VOID
    )
{
    UNINSTALLSTATUS status;

    DeferredInit();

    status = SanityCheck (VERIFY_CAB, NULL, NULL);

    if (status != Uninstall_Valid && status != Uninstall_OldImage) {
        pUninstallStatusToWin32Error (status);
        return FALSE;
    }

    return DoUninstall();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\compguid.h ===
// {67cf8cbd-e5c0-44f7-9de5-e1d599d626d8}
DEFINE_GUID(CLSID_UninstallCleaner, 0x67cf8cbd, 0xe5c0, 0x44f7, 0x9d, 0xe5, 0xe1, 0xd5, 0x99, 0xd6, 0x26, 0xd8);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\com.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    com.c

Abstract:

    Implements the required code for a COM server. This module is specific to
    the COM interfaces exposed by osuninst.dll

Author:

    Jim Schmidt (jimschm) 21-Feb-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "compguid.h"
#include "com.h"
#include "undop.h"


//
// Globals
//

INT g_DllObjects;
INT g_DllLocks;

//
// Implementation
//

STDAPI
DllGetClassObject (
    IN      REFCLSID ClassId,
    IN      REFIID InterfaceIdRef,
    OUT     PVOID *InterfacePtr
    )

/*++

Routine Description:

  DllGetClassObject is the DLL-to-COM connection. It is exported from the DLL,
  so that COM can call it with CoGetClassObject. COM is the only one who calls
  this entry point, and finds the dll through registration of the CLSID in
  HKCR.

Arguments:

  ClassId - Specifies the class factory desired. This arg allows a single DLL
      to implement multiple interfaces.

  InterfaceIdRef - Specifies the interface the caller wants on the class
      object, usually IID_ClassFactory.

  InterfacePtr - Receives the interface pointer, or NULL if an error occurs.

Return Value:

  E_INVALIDARG - The caller specified an invalid argument
  E_OUTOFMEMORY - Failed to alloc memory for interface
  E_UNEXPECTED - Some random problem
  S_OK - Success
  CLASS_E_CLASSNOTAVAILABLE - Requested class is not supported

--*/

{
    BOOL result = FALSE;
    HRESULT hr = S_OK;
    PUNINSTALLCLASSFACTORY uninstallClassFactory = NULL;

    __try {
        DeferredInit();

        //
        // Initialize out arg
        //

        __try {
            *InterfacePtr = NULL;
        }
        __except(1) {
            hr = E_INVALIDARG;
        }

        if (hr != S_OK) {
            DEBUGMSG ((DBG_ERROR, __FUNCTION__ ": Invalid InterfacePtr arg"));
            __leave;
        }

        //
        // Is this a request for a disk cleanup class? If not, fail with
        // CLASS_E_CLASSNOTAVAILABLE.
        //

        if (!IsEqualCLSID (ClassId, CLSID_UninstallCleaner)) {
            DEBUGMSG ((DBG_ERROR, "Uninstall: Requested class not supported"));
            hr = CLASS_E_CLASSNOTAVAILABLE;
            __leave;
        }

        //
        // Return our IClassFactory for making CCompShellExt objects
        //

        uninstallClassFactory = new CUninstallClassFactory ();

        if (!uninstallClassFactory) {
            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        // Test if our class factory support the requested interface
        //

        hr = uninstallClassFactory->QueryInterface (InterfaceIdRef, InterfacePtr);

    }
    __finally {
        if (FAILED (hr) && uninstallClassFactory) {
            //
            // failure -- clean up object
            //
            delete uninstallClassFactory;
        }
    }

    return hr;
}


STDAPI
DllCanUnloadNow (
    VOID
    )

/*++

Routine Description:

  Indicatates if this DLL is in use or not. If it is not in use, COM will
  unload it.

Arguments:

  None.

Return Value:

  S_OK - The DLL is not in use
  S_FALSE - The DLL is used at least once

--*/

{
    if (g_DllObjects || g_DllLocks) {
        return S_FALSE;
    }

    return S_OK;
}


/*++

Routine Descriptions:

  This constructor is a generic class factory that supports multiple object
  types. Upon creation, the object interface pointer ref count is set to zero,
  and the global number of objects for the dll is incremented.

  The destructor simply decrements the DLL object count.

Arguments:

  None.

Return Value:

  None.

--*/

CUninstallClassFactory::CUninstallClassFactory (
    VOID
    )

{
    //
    // -Initialize the interface pointer count
    // -Increment the DLL's global count of objects
    //
    _References = 0;
    g_DllObjects++;
}

CUninstallClassFactory::~CUninstallClassFactory (
    VOID
    )
{
    g_DllObjects--;
}


STDMETHODIMP
CUninstallClassFactory::QueryInterface (
    IN      REFIID InterfaceIdRef,
    OUT     PVOID *InterfacePtr
    )
{
    HRESULT hr = S_OK;

    DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Entering"));

    __try {
        //
        // Initialize out arg
        //

        __try {
            *InterfacePtr = NULL;
        }
        __except(1) {
            hr = E_INVALIDARG;
        }

        if (hr != S_OK) {
            DEBUGMSG ((DBG_ERROR, __FUNCTION__ ": Invalid InterfacePtr arg"));
            __leave;
        }

        //
        // Test for the supported interface
        //
        if (IsEqualIID (InterfaceIdRef, IID_IUnknown)) {
            DEBUGMSG ((DBG_VERBOSE, "Caller requested IUnknown"));
            *InterfacePtr = (LPUNKNOWN)(LPCLASSFACTORY) this;
            AddRef();
            __leave;
        }


        if (IsEqualIID (InterfaceIdRef, IID_IClassFactory)) {
            DEBUGMSG ((DBG_VERBOSE, "Caller requested IClassFactory"));
            *InterfacePtr = (LPCLASSFACTORY)this;
            AddRef();
            __leave;
        }

        DEBUGMSG ((DBG_WARNING, "Caller requested unknown interface"));
        hr = E_NOINTERFACE;
    }
    __finally {
    }

    DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Leaving"));

    return hr;
}


/*++

Routine Description:

  AddRef is the standard IUnknown member function that increments the object
  reference count.

  Release is the standard IUnknown member function that decrements the object
  reference count.

Arguments:

  None.

Return Value:

  The number of interface references.

--*/

STDMETHODIMP_(ULONG)
CUninstallClassFactory::AddRef (
    VOID
    )
{
    return ++_References;
}


STDMETHODIMP_(ULONG)
CUninstallClassFactory::Release (
    VOID
    )
{
    if (!_References) {
        DEBUGMSG ((DBG_ERROR, "Can't release because there are no references"));
    } else {
        _References--;

        if (!_References) {
            delete this;
            return 0;
        }
    }

    return _References;
}


STDMETHODIMP
CUninstallClassFactory::CreateInstance (
    IN      LPUNKNOWN  IUnknownOuterInterfacePtr,
    IN      REFIID InterfaceIdRef,
    OUT     PVOID * InterfacePtr
    )

/*++

Routine Description:

  CreateInstance establishes an object.

Arguments:

  IUnknownOuterInterfacePtr - Specifies the IUnknown interface that
      is the outer layer in objects derrived from us. This happens only when
      additional objects inherit out interfaces.

  InterfaceIdRef - Specifies the interface that the caller wants to
      instantiate

  InterfacePtr - Receives the pointer to the interface, or NULL on an error

Return Value:

  S_OK - The object was created and its reference is returned in InterfacePtr
  E_OUTOFMEMORY - Not enough memory available to instantiate the object
  E_INVALIDARG - The caller specified an invalid InterfacePtr arg
  E_UNEXPECTED - Some random error condition was encountered
  E_NOINTERFACE - InterfaceIdRef is not supported

--*/

{
    HRESULT hr = S_OK;
    PUNINSTALLDISKCLEANER uninstallDiskCleaner = NULL;

    __try {
        //
        // Initialize out arg
        //

        __try {
            *InterfacePtr = NULL;
        }
        __except(1) {
            hr = E_INVALIDARG;
        }

        if (hr != S_OK) {
            DEBUGMSG ((DBG_ERROR, __FUNCTION__ ": Invalid InterfacePtr arg"));
            __leave;
        }

        //
        // Shell extensions typically don't support aggregation (inheritance)
        //

        if (IUnknownOuterInterfacePtr) {
            hr = CLASS_E_NOAGGREGATION;
            __leave;
        }

        //
        // Create the disk cleaner object
        //

        if (IsEqualIID (InterfaceIdRef, IID_IEmptyVolumeCache)) {
            DEBUGMSG ((DBG_VERBOSE, __FUNCTION__ ": Creating CUninstallDiskCleaner"));

            uninstallDiskCleaner = new CUninstallDiskCleaner();
            if (!uninstallDiskCleaner) {
                hr = E_OUTOFMEMORY;
                __leave;
            }

            hr = uninstallDiskCleaner->QueryInterface (InterfaceIdRef, InterfacePtr);
            __leave;
        }

        DEBUGMSG ((DBG_ERROR, __FUNCTION__ ": Unknown InterfaceIdRef"));
        hr = E_NOINTERFACE;
    }
    __finally {

        if (FAILED(hr)) {
            if (uninstallDiskCleaner) {
                delete uninstallDiskCleaner;
            }
        }
    }

    return hr;
}

STDMETHODIMP
CUninstallClassFactory::LockServer (
    IN      BOOL Lock
    )

/*++

Routine Description:

  LockServer is the standard IUnknown interface that is used to keep a server
  in memory. Its implementation tracks the lock count in a global.

Arguments:

  Lock - Specifies TRUE to increment the loc count, or FALSE to decrement it.

Return Value:

  S_OK - Server was locked (or unlocked)
  E_FAIL - No locks exist/can't unlock

--*/

{
    HRESULT hr = S_OK;

    if (Lock) {
        g_DllLocks++;
    } else {
        if (g_DllLocks) {
            g_DllLocks--;
        } else {
            DEBUGMSG ((DBG_ERROR, __FUNCTION__ ": Attempt to unlock when no locks exist"));
            hr = E_FAIL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\register.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    diskcleaner.c

Abstract:

    Implements the code specific to the disk cleaner COM server.

Author:

    Jim Schmidt (jimschm) 21-Jan-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "undop.h"
#include "com.h"

#include <advpub.h>

HRESULT
pCallRegInstall (
    PCSTR szSection
    )
{
    HRESULT hr = E_FAIL;
    HINSTANCE advPackLib;
    REGINSTALL regInstall;
    STRENTRY dirIdEntries[] = {
        { "TEMP_PATH", "%TEMP%" },
        { "25", "%SystemRoot%" },
        { "11", "%SystemRoot%\\system32" },
    };
    STRTABLE dirIdTable = { ARRAYSIZE(dirIdEntries), dirIdEntries };

    advPackLib = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (advPackLib) {
        regInstall = (REGINSTALL) GetProcAddress (advPackLib, "RegInstall");
        if (regInstall) {
            hr = regInstall (g_hInst, szSection, &dirIdTable);
        }

        FreeLibrary(advPackLib);
    }

    return hr;
}


STDAPI
DllRegisterServer (
    VOID
    )
{
    DeferredInit();


    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    // (The inf engine doesn't guarantee DelReg/AddReg order, that's
    // why we explicitly unreg and reg here.)
    //
    return pCallRegInstall("RegDll");
}

STDAPI
DllUnregisterServer (
    VOID
    )
{
    DeferredInit();

    // We only need one unreg call since all our sections share
    // the same backup information
    return pCallRegInstall("UnregDll");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\pch\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\undop.h ===
#ifdef __cplusplus
extern "C" {
#endif

VOID
DeferredInit (
    VOID
    );


PCTSTR
GetUndoDirPath (
    VOID
    );

typedef enum {
    QUICK_CHECK         = 0x0000,
    VERIFY_CAB          = 0x0001,
    FAIL_IF_NOT_OLD     = 0x0002
} SANITYFLAGS;

UNINSTALLSTATUS
SanityCheck (
    IN      SANITYFLAGS Flags,
    IN      PCWSTR VolumeRestriction,           OPTIONAL
    OUT     PULONGLONG DiskSpace                OPTIONAL
    );


BOOL
DoUninstall (
    VOID
    );

BOOL
DoCleanup (
    VOID
    );

BOOL
GetBootDrive(
    IN  PCTSTR BackUpPath,
    IN  PCTSTR Path
    );

extern TCHAR g_BootDrv;

BOOL
CheckCabForAllFilesAvailability(
    IN PCTSTR CabPath
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\uninst.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    uninst.c

Abstract:

    Implements the code to launch the uninstall.

Author:

    Jim Schmidt (jimschm)   28-Nov-2000

Revision History:

--*/

#include "pch.h"
#include "undop.h"
#include "resource.h"

//
// Types
//

typedef enum {
    BACKUP_DOESNT_EXIST,
    BACKUP_IN_PROGRESS,
    BACKUP_SKIPPED_BY_USER,
    BACKUP_COMPLETE
} JOURNALSTATUS;


//
// Global Variables
//

DRIVELETTERS g_DriveLetters;
TCHAR g_BootDrv = UNKNOWN_DRIVE;

#define WMX_STOP        (WM_APP+96)

//
// Code
//

VOID
pAddSifEntry (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCTSTR Key,
    IN      PCTSTR Data
    )
{
    PTSTR quotedData;

    quotedData = AllocText (CharCount (Data) + 2);
    wsprintf (quotedData, TEXT("\"%s\""), Data);
    AddInfLineToTable (Inf, Section, Key, quotedData, 0);
    FreeText (quotedData);
}


BOOL
pEnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    )
{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}


VOID
pWriteDrvLtrFiles (
    VOID
    )
{
    BOOL        rf = TRUE;
    DWORD       index;
    HANDLE      signatureFile;
    TCHAR       signatureFilePath[MAX_PATH * 2];
    DWORD       signatureFilePathLength;
    DWORD       bytesWritten;

    InitializeDriveLetterStructure (&g_DriveLetters);

    //
    // Hard drive information is actually written to a special signature file
    // on the root directory of each fixed hard drive. The information is
    // nothing special -- just the drive number (0 = A, etc.)
    //

    lstrcpy (signatureFilePath,TEXT("*:\\$DRVLTR$.~_~"));
    signatureFilePathLength = lstrlen(signatureFilePath);

    for (index = 0; index < NUMDRIVELETTERS; index++) {

        if (g_DriveLetters.ExistsOnSystem[index] &&
            g_DriveLetters.Type[index] == DRIVE_FIXED) {

            *signatureFilePath = (TCHAR) index + TEXT('A');

            signatureFile = CreateFile(
                                signatureFilePath,
                                GENERIC_WRITE | GENERIC_READ,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_HIDDEN,
                                NULL
                                );

            if (signatureFile != INVALID_HANDLE_VALUE) {

                WriteFile (signatureFile, &index, sizeof(DWORD), &bytesWritten, NULL);
                CloseHandle (signatureFile);
            }
        }
    }
}


VOID
pAppendSystemRestore (
    IN      HANDLE FileHandle,
    IN      PCWSTR SystemGuid
    )
{
    INT index;
    WCHAR outputStr[MAX_PATH];
    DWORD dontCare;

    DEBUGMSG ((DBG_VERBOSE, "Enumerating sr drives"));

    for (index = 0; index < NUMDRIVELETTERS; index++) {

        if (g_DriveLetters.ExistsOnSystem[index] &&
            g_DriveLetters.Type[index] == DRIVE_FIXED
            ) {
            wsprintfW (
                outputStr,
                L"%c:\\System Volume Information\\_restore%s\r\n",
                (WCHAR) index + L'A',
                SystemGuid
                );

            DEBUGMSGW ((DBG_VERBOSE, "Adding %s to deldirs.txt file", outputStr));
            SetFilePointer (FileHandle, 0, NULL, FILE_END);
            WriteFile (FileHandle, outputStr, ByteCountW (outputStr), &dontCare, NULL);
        }
    }
}


VOID
pAppendSystemRestoreToDelDirs (
    IN      PCTSTR DelDirsTxtPath
    )
{
    HANDLE delDirsFile = INVALID_HANDLE_VALUE;
    HKEY key = NULL;
    PCWSTR data = NULL;

    __try {
        key = OpenRegKeyStr (TEXT("HKLM\\System\\CurrentControlSet\\Services\\sr\\Parameters"));
        if (!key) {
            DEBUGMSG ((DBG_ERROR, "Can't open SR Parameters key"));
            __leave;
        }

        data = GetRegValueStringW (key, L"MachineGuid");
        if (!data) {
            DEBUGMSG ((DBG_ERROR, "Can't get SR MachineGuid"));
            __leave;
        }

        delDirsFile = CreateFile (
                            DelDirsTxtPath,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if (delDirsFile == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_ERROR, "Can't open %s for writing", DelDirsTxtPath));
            __leave;
        }

        pAppendSystemRestore (delDirsFile, data);
    }
    __finally {
        if (delDirsFile != INVALID_HANDLE_VALUE) {
            CloseHandle (delDirsFile);
        }

        if (data) {
            FreeMem (data);
        }

        if (key) {
            CloseRegKey (key);
        }
    }
}


BOOL
WINAPI
pCabNotificationSeekForDrive(
    IN      PCTSTR FileName
    )
{
    if(!FileName){
        MYASSERT(FALSE);
        return FALSE;
    }

    MYASSERT(UNKNOWN_DRIVE == g_BootDrv);

    g_BootDrv = (TCHAR)FileName[0];

    return -1;
}

BOOL
GetBootDrive(
    IN  PCTSTR BackUpPath,
    IN  PCTSTR Path
    )
{
    OCABHANDLE cabHandle;

    if(UNKNOWN_DRIVE != g_BootDrv){
        return TRUE;
    }

    cabHandle = CabOpenCabinet (Path);
    if (cabHandle) {
        SetCurrentDirectory (BackUpPath);

        CabExtractAllFilesEx (
            cabHandle,
            NULL,
            (PCABNOTIFICATIONW)pCabNotificationSeekForDrive);

        CabCloseCabinet (cabHandle);

        MYASSERT(UNKNOWN_DRIVE != g_BootDrv);
    } else {
        return FALSE;
    }

    return TRUE;
}


DWORD
WINAPI
pLongOperationUi (
    PVOID DontCare
    )
{
    HWND h;
    RECT parentRect;
    MSG msg;
    TCHAR textBuf[256];
    HKEY key;
    LONG rc;
    DWORD size;
    HFONT font;
    HDC hdc;
    LOGFONT lf;
    SIZE textSize;
    RECT rect;
    HWND parent;
    TCHAR title[128];

    //
    // Get dialog title
    //

    if (!LoadString (g_hInst, IDS_TITLE, title, ARRAYSIZE(title))) {
        return 0;
    }

    //
    // Get display text
    //

    key = OpenRegKeyStr (S_WIN9XUPG_KEY);
    if (!key) {
        return 0;
    }

    size = sizeof (textBuf);
    rc = RegQueryValueEx (key, S_UNINSTALL_DISP_STR, NULL, NULL, (PBYTE) textBuf, &size);

    CloseRegKey (key);

    if (rc != ERROR_SUCCESS) {
        return 0;
    }

    //
    // Create font object and compute width/height
    //

    hdc = CreateDC (TEXT("DISPLAY"), NULL, NULL, NULL);

    ZeroMemory (&lf, sizeof (lf));
    lf.lfHeight = -MulDiv (9, GetDeviceCaps (hdc, LOGPIXELSY), 72);
    StringCopy (lf.lfFaceName, TEXT("MS Shell Dlg"));

    font = CreateFontIndirect (&lf);
    SelectObject (hdc, font);
    GetTextExtentPoint32 (hdc, textBuf, TcharCount (textBuf), &textSize);

    DeleteDC (hdc);

    //
    // Compute window position
    //

    GetWindowRect (GetDesktopWindow(), &parentRect);

    rect.left = (parentRect.right - parentRect.left) / 2;
    rect.right = rect.left;

    rect.left -= textSize.cx * 2;
    rect.right += textSize.cx * 2;

    rect.top = (parentRect.bottom - parentRect.top) / 2;
    rect.bottom = rect.top;

    rect.top -= textSize.cy * 4;
    rect.bottom += textSize.cy * 4;

    parent = CreateWindow (
                TEXT("STATIC"),
                title,
                WS_OVERLAPPED|WS_BORDER|WS_CAPTION|SS_WHITERECT,
                rect.left,
                rect.top,
                rect.right - rect.left,
                rect.bottom - rect.top,
                NULL,
                NULL,
                g_hInst,
                NULL
                );

    //
    // Create static control
    //

    GetClientRect (parent, &rect);

    //
    // Create window & let it run until verify is done
    //

    h = CreateWindow (
            TEXT("STATIC"),
            textBuf,
            WS_CHILD|SS_CENTER|SS_CENTERIMAGE,
            rect.left,
            rect.top,
            rect.right - rect.left,
            rect.bottom - rect.top,
            parent,
            NULL,
            g_hInst,
            NULL
            );

    SendMessage (h, WM_SETFONT, (WPARAM) font, 0);

    ShowWindow (parent, SW_SHOW);
    ShowWindow (h, SW_SHOW);
    UpdateWindow (parent);

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (msg.message == WMX_STOP) {
            DestroyWindow (parent);
            break;
        }

        TranslateMessage (&msg);
        DispatchMessage (&msg);
    }

    DeleteObject (font);

    return 0;
}


DWORD
pStartLongOperationUi (
    VOID
    )
{
    HANDLE h;
    DWORD threadId;

    h = CreateThread (
            NULL,
            0,
            pLongOperationUi,
            NULL,
            0,
            &threadId
            );

    if (!h) {
        return 0;
    }

    CloseHandle (h);

    return threadId;
}


VOID
pKillLongOperationUi (
    IN      DWORD ThreadId
    )
{
    if (ThreadId) {
        PostThreadMessage (ThreadId, WMX_STOP, 0, 0);
    }
}


BOOL
CheckCabForAllFilesAvailability(
    IN PCTSTR CabPath
    )
{
    OCABHANDLE cabHandle;
    BOOL result = FALSE;
    DWORD threadId;

    threadId = pStartLongOperationUi();

    cabHandle = CabOpenCabinet (CabPath);
    if (cabHandle) {
        result = CabVerifyCabinet (cabHandle);
        CabCloseCabinet (cabHandle);
    }

    pKillLongOperationUi (threadId);

    return result;
}

BOOL
DoUninstall (
    VOID
    )
{
    HINF inf = INVALID_HANDLE_VALUE;
    PINFSECTION section;
    PCTSTR path = NULL;
    PCTSTR path2 = NULL;
    PCTSTR sifPath = NULL;
    TCHAR bootPath[4] = TEXT("?:\\");
    BOOL error = TRUE;
    OCABHANDLE cabHandle;
    PINFLINE infLine;
    DWORD attribs;
    PCTSTR backUpPath;
    PTSTR updatedData;
    BOOL cantSave;
    TCHAR textModeBootIniEntry[] = TEXT("?:\\$win_nt$.~bt\\bootsect.dat");
    TCHAR bootDirPath[MAX_PATH] = TEXT("");
    HANDLE fileHandle;
    DWORD bytesWritten;
    JOURNALSTATUS journalStatus;
    BOOL result;


    __try {
        backUpPath = GetUndoDirPath();

        SetCursor (LoadCursor (NULL, IDC_WAIT));

        //
        // Retrieve directory path of backup directory
        //
        if(!backUpPath) {
            LOG ((LOG_WARNING, "Uninstall Cleanup: Failed to retrieve directory path"));
            __leave;
        }

        //
        // Recreate "backup.$$$" with correct content, if file was not in place.
        //
        path = JoinPaths (backUpPath, TEXT("backup.$$$"));
        if(0xffffffff == GetFileAttributes(path)){
            MYASSERT(ERROR_FILE_NOT_FOUND == GetLastError());

            fileHandle = CreateFile(path,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
            if(INVALID_HANDLE_VALUE != fileHandle){
                journalStatus = BACKUP_COMPLETE;
                result = WriteFile(fileHandle,
                                   &journalStatus,
                                   sizeof(journalStatus),
                                   &bytesWritten,
                                   NULL);

                CloseHandle(fileHandle);

                if(!result){
                    LOG ((LOG_WARNING, "Uninstall Cleanup: Failed to write to backup.$$$"));
                    __leave;
                }
            }
            else {
                LOG ((LOG_WARNING, "Uninstall Cleanup: Failed to create file backup.$$$"));
                __leave;
            }
        }
        FreePathString (path);

        //
        // Write a drive signature file to each drive
        //

        pWriteDrvLtrFiles();

        //
        // Prepare boot path, clean out existing $win_nt$.~bt
        // directory
        //

        path = JoinPaths (backUpPath, TEXT("boot.cab"));


        if(GetBootDrive(backUpPath, path)){
            bootPath[0] = g_BootDrv;
            textModeBootIniEntry[0] = g_BootDrv;
        }
        else{
            LOG ((LOG_WARNING, "Uninstall Cleanup: Unable to open %s", path));
            __leave;
        }
        FreePathString (path);

        path = JoinPaths (bootPath, TEXT("$win_nt$.~bt"));
        RemoveCompleteDirectory (path);
        StringCopy(bootDirPath, path);
        FreePathString (path);
        path = NULL;

        //
        // Extract the boot files from the boot.cab
        //

        path = JoinPaths (backUpPath, TEXT("boot.cab"));
        cabHandle = CabOpenCabinet (path);

        if (cabHandle) {
            SetCurrentDirectory (backUpPath);
            CabExtractAllFiles (cabHandle, NULL);
            CabCloseCabinet (cabHandle);
        } else {
            LOG ((LOG_WARNING, "Uninstall Cleanup: Unable to open %s", path));
            __leave;
        }

        //
        // Verify the CAB expanded properly
        //

        FreePathString (path);
        path = NULL;

        path = JoinPaths (bootPath, TEXT("$win_nt$.~bt"));
        if (!DoesFileExist (path)) {
            LOG ((LOG_ERROR, "Files did not expand properly or boot.cab is damaged"));
            __leave;
        }
        FreePathString (path);
        path = NULL;

        path = JoinPaths (backUpPath, S_ROLLBACK_DELFILES_TXT);
        if (!DoesFileExist (path)) {
            LOG ((LOG_ERROR, "delfiles.txt not found"));
            __leave;
        }
        FreePathString (path);
        path = NULL;

        path = JoinPaths (backUpPath, S_ROLLBACK_DELDIRS_TXT);
        if (!DoesFileExist (path)) {
            LOG ((LOG_ERROR, "deldirs.txt not found"));
            __leave;
        }
        FreePathString (path);
        path = NULL;

        path = JoinPaths (backUpPath, S_ROLLBACK_MKDIRS_TXT);
        if (!DoesFileExist (path)) {
            LOG ((LOG_ERROR, "mkdirs.txt not found"));
            __leave;
        }
        FreePathString (path);
        path = NULL;

        path = JoinPaths (backUpPath, S_ROLLBACK_MOVED_TXT);
        if (!DoesFileExist (path)) {
            LOG ((LOG_ERROR, "moved.txt not found"));
            __leave;
        }
        FreePathString (path);
        path = NULL;

        //
        // Modify winnt.sif so that text mode knows what to do
        //

        sifPath = JoinPaths (bootPath, TEXT("$win_nt$.~bt\\winnt.sif"));

        inf = OpenInfFile (sifPath);
        if (inf == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "Can't open %s", sifPath));
            __leave;
        }

        section = FindInfSectionInTable (inf, TEXT("data"));

        if (section) {

            //
            // Write keys to winnt.sif...
            //

            if (!FindLineInInfSection (inf, section, TEXT("Rollback"))) {
                pAddSifEntry (inf, section, TEXT("Rollback"), TEXT("1"));
            }

            //
            // ...change %windir%\setup\uninstall\*.txt to %backuppath%\*.txt
            //

            // moved.txt
            infLine = FindLineInInfSection (inf, section, WINNT_D_ROLLBACK_MOVE);
            if (infLine) {
                DeleteLineInInfSection (inf, infLine);
            }

            path = JoinPaths (backUpPath, S_ROLLBACK_MOVED_TXT);
            pAddSifEntry (inf, section, WINNT_D_ROLLBACK_MOVE, path);
            FreePathString (path);
            path = NULL;

            // delfiles.txt
            infLine = FindLineInInfSection (inf, section, WINNT_D_ROLLBACK_DELETE);
            if (infLine) {
                DeleteLineInInfSection (inf, infLine);
            }

            path = JoinPaths (backUpPath, S_ROLLBACK_DELFILES_TXT);
            pAddSifEntry (inf, section, WINNT_D_ROLLBACK_DELETE, path);
            FreePathString (path);
            path = NULL;

            // deldirs.txt
            infLine = FindLineInInfSection (inf, section, WINNT_D_ROLLBACK_DELETE_DIR);
            if (infLine) {
                DeleteLineInInfSection (inf, infLine);
            }

            path = JoinPaths (backUpPath, S_ROLLBACK_DELDIRS_TXT);
            pAddSifEntry (inf, section, WINNT_D_ROLLBACK_DELETE_DIR, path);

            //
            // append System Restore directories to deldirs.txt
            //
            DEBUGMSG ((DBG_VERBOSE, "Appending SR dirs to %s", path));
            pAppendSystemRestoreToDelDirs (path);

            FreePathString (path);
            path = NULL;

            // mkdirs.txt
            infLine = FindLineInInfSection (inf, section, S_ROLLBACK_MK_DIRS);
            if (infLine) {
                DeleteLineInInfSection (inf, infLine);
            }

            path = JoinPaths (backUpPath, S_ROLLBACK_MKDIRS_TXT);
            pAddSifEntry (inf, section, S_ROLLBACK_MK_DIRS, path);
            FreePathString (path);
            path = NULL;

            //
            // ...write changed winnt.sif file
            //

            if (!SaveInfFile (inf, sifPath)) {
                LOG ((LOG_ERROR, "Unable to update winnt.sif"));
                __leave;
            }

            //
            // clone txtsetup.sif
            //

            path = JoinPaths (bootPath, TEXT("$win_nt$.~bt\\txtsetup.sif"));
            path2 = JoinPaths (bootPath, TEXT("txtsetup.sif"));

            SetFileAttributes (path2, FILE_ATTRIBUTE_NORMAL);
            if (!CopyFile (path, path2, FALSE)) {
                LOG ((LOG_ERROR, "Can't copy %s to %s", path, path2));
                __leave;
            }

            FreePathString (path);
            path = NULL;
            FreePathString (path2);
            path2 = NULL;

        } else {
            LOG ((LOG_ERROR, "[data] not found in winnt.sif"));
        }

        CloseInfFile (inf);
        FreePathString (sifPath);
        sifPath = NULL;

        //
        // Edit the current boot.ini
        //

        sifPath = JoinPaths (bootPath, TEXT("boot.ini"));

        inf = OpenInfFile (sifPath);
        if (inf == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "Can't open %s", sifPath));
            __leave;
        }

        section = FindInfSectionInTable (inf, TEXT("Operating Systems"));

        if (!section) {
            LOG ((LOG_ERROR, "[Operating Systems] not found in boot.ini"));
            __leave;
        }

        //
        // Add /rollback to textmode entry
        //

        infLine = FindLineInInfSection (inf, section, textModeBootIniEntry);
        if (infLine) {
            if(!_tcsistr (infLine->Data, TEXT("/rollback"))){
                updatedData = AllocText (TcharCount (infLine->Data) + 10);

                StringCopy (updatedData, infLine->Data);
                StringCat (updatedData, TEXT(" /rollback"));

                AddInfLineToTable (inf, section, infLine->Key, updatedData, infLine->LineFlags);
                DeleteLineInInfSection (inf, infLine);

                FreeText (updatedData);
            }
        } else {
            updatedData = AllocText (256 + sizeof (TEXT("\" /rollback\"")) / sizeof (TCHAR));
            StringCopy (updatedData, TEXT("\""));

            if (!LoadString (g_hInst, IDS_TITLE, GetEndOfString (updatedData), 256)) {
                DEBUGMSG ((DBG_ERROR, "Can't load boot.ini text"));
                __leave;
            }

            StringCat (updatedData, TEXT("\" /rollback"));

            AddInfLineToTable (inf, section, textModeBootIniEntry, updatedData, 0);
            FreeText (updatedData);
        }

        //
        // Set timeout to zero and set default
        //

        section = FindInfSectionInTable (inf, TEXT("boot loader"));
        if (!section) {
            LOG ((LOG_ERROR, "[Boot Loader] not found in boot.ini"));
            __leave;
        }

        infLine = FindLineInInfSection (inf, section, TEXT("timeout"));
        if (infLine) {
            DeleteLineInInfSection (inf, infLine);
        }

        AddInfLineToTable (inf, section, TEXT("timeout"), TEXT("0"), 0);

        infLine = FindLineInInfSection (inf, section, TEXT("default"));
        if (infLine) {
            DeleteLineInInfSection (inf, infLine);
        }

        AddInfLineToTable (inf, section, TEXT("default"), textModeBootIniEntry, 0);

        //
        // Save changes
        //

        attribs = GetFileAttributes (sifPath);
        SetFileAttributes (sifPath, FILE_ATTRIBUTE_NORMAL);

        cantSave = (SaveInfFile (inf, sifPath) == FALSE);

        if (attribs != INVALID_ATTRIBUTES) {
            SetFileAttributes (sifPath, attribs);
        }

        if (cantSave) {
            LOG ((LOG_ERROR, "Unable to update boot.ini"));
            __leave;
        }

        //
        // Rollback environment is ready to go
        //

        error = FALSE;
    }
    __finally {
        FreePathString (path);
        FreePathString (path2);
        FreePathString (sifPath);

        if (backUpPath) {
            MemFree (g_hHeap, 0, backUpPath);
        }

        if (inf != INVALID_HANDLE_VALUE) {
            CloseInfFile (inf);
        }
    }

    //
    // Shutdown on success
    //

    if (!error) {
        pEnablePrivilege(SE_SHUTDOWN_NAME,TRUE);
        ExitWindowsEx (EWX_REBOOT, 0);
    } else {
        RemoveCompleteDirectory (bootDirPath);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDS_TITLE                       1
#define IDS_DO_UNINSTALL                2
#define IDS_DO_CLEANUP                  3
#define IDS_NO_BACKUP                   4
#define IDS_NO_REGISTRY                 5
#define IDS_NO_INVALID_OS               6
#define IDS_NO_ENOUGH_PRIVILEGE         7
#define IDS_FILES_MODIFIED              8
#define IDS_CANT_RETRIEVE_SYSTEMINFO    9
#define IDS_WRONG_DRIVE                 10
#define IDS_NOT_ENOUGH_SPACE            11
#define IDS_UNINSTALL_PREPARATION_FAILED 12
#define IDS_NEW_IMAGE                   13
#define IDS_OLD_IMAGE                   14
#define IDS_DIFFERENT_DISK_NUMBER       15
#define IDS_NOT_ENOUGH_MEMORY           16
#define IDS_FLOPPYDISK_IN_DRIVE         17
#define IDS_DIFFERENT_DRIVE_LETTER      18
#define IDS_DIFFERENT_DRIVE_FILE_SYSTEM 19
#define IDS_DIFFERENT_DRIVE_GEOMETRY    20
#define IDS_DIFFERENT_DRIVE_PARTITION   21
#define IDD_UNDO                        122
#define IDI_SETUP                       135
#define IDC_LOGO                        1135
#define IDC_RADIO1                      1140
#define IDC_RADIO2                      1141
#define IDC_TEXT1                       3032

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1141
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\common9x\cmn9xp.h ===
//
// sysmigp.h - private prototypes
//
#define DBG_SYSMIG "SysMig"

extern PCTSTR g_UserProfileRoot;

//
// shares.c
//

DWORD
SaveShares (
    IN      DWORD Request
    );



//
// olereg.c
//

DWORD
SuppressOleGuids (
    IN      DWORD Request
    );

//
// condmsg.c
//


DWORD
ConditionalIncompatibilities(
    IN      DWORD Request
    );

DWORD
HardwareProfileWarning (
    IN      DWORD Request
    );

DWORD
UnsupportedProtocolsWarning (
    IN      DWORD Request
    );

DWORD
SaveMMSettings_User (
    DWORD Request,
    PUSERENUM EnumPtr
    );

DWORD
SaveMMSettings_System (
    IN      DWORD Request
    );

DWORD
BadNamesWarning (
    IN      DWORD Request
    );


VOID
MsgSettingsIncomplete (
    IN      PCTSTR UserDatPath,
    IN      PCTSTR UserName,
    IN      BOOL CompletelyBusted
    );


VOID
InitGlobalPaths (
    VOID
    );

BOOL
AddShellFolder (
    PCTSTR ValueName,
    PCTSTR FolderName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\dll\validate.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    validate.c

Abstract:

    Code to validate an uninstall image

Author:

    Jim Schmidt (jimschm) 19-Jan-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "undop.h"
#include "file.h"
#include "persist.h"
#include "uninstall.h"

//
// Contants
//

#define MAX_BACKUP_FILES    3

#define _SECOND             ((__int64) 10000000)
#define _MINUTE             (60 * _SECOND)
#define _HOUR               (60 * _MINUTE)
#define _DAY                (24 * _HOUR)

PERSISTENCE_IMPLEMENTATION(DRIVE_LAYOUT_INFORMATION_EX_PERSISTENCE);
PERSISTENCE_IMPLEMENTATION(DISKINFO_PERSISTENCE);
PERSISTENCE_IMPLEMENTATION(DRIVEINFO_PERSISTENCE);
PERSISTENCE_IMPLEMENTATION(FILEINTEGRITYINFO_PERSISTENCE);
PERSISTENCE_IMPLEMENTATION(BACKUPIMAGEINFO_PERSISTENCE);

//
// Code
//

PCTSTR
GetUndoDirPath (
    VOID
    )

/*++

Routine Description:

  GetUndoDirPath queries the registry and obtains the stored backup path.

Arguments:

  None.

Return Value:

  The backup path, which must be freed with MemFree, or NULL if the backup
  path is not stored in the registry.

--*/

{
    PCTSTR backUpPath = NULL;
    HKEY key;

    key = OpenRegKeyStr (S_REGKEY_WIN_SETUP);
    if (key) {
        backUpPath = GetRegValueString (key, S_REG_KEY_UNDO_PATH);
        CloseRegKey (key);
    }

    return backUpPath;
}


BOOL
pIsUserAdmin (
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE Token;
    UINT BytesRequired;
    PTOKEN_GROUPS Groups;
    BOOL b;
    UINT i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    //
    // On non-NT platforms the user is administrator.
    //
    if(!ISNT()) {
        return(TRUE);
    }

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Groups = NULL;

    //
    // Get group information.
    //
    if(!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Groups = (PTOKEN_GROUPS)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired)) {

        b = AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );

        if(b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid(AdministratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if(Groups) {
        LocalFree((HLOCAL)Groups);
    }

    CloseHandle(Token);

    return(b);
}


PBACKUPIMAGEINFO
pReadUndoFileIntegrityInfo(
    VOID
    )

/*++
Routine Description:

  pReadUndoFileIntegrityInfo reads the uninstall registry info that was
  written by setup. This info tells undo what files are in the backup image
  and details about those files.

Arguments:

    None.

Return Value:

  A pointer to a BACKUPIMAGEINFO which must be freed with MemFree structure
  if successful, NULL otherwise.

--*/

{
    static BACKUPIMAGEINFO backupInfo;
    BYTE * filesIntegrityPtr = NULL;
    UINT sizeOfBuffer = 0;
    UINT typeOfRegKey;
    HKEY key;
    LONG rc;
    BOOL bResult = FALSE;

    key = OpenRegKeyStr (S_REGKEY_WIN_SETUP);

    if (key) {
        rc = RegQueryValueEx (
            key,
            S_REG_KEY_UNDO_INTEGRITY,
            NULL,
            &typeOfRegKey,
            NULL,
            &sizeOfBuffer
            );

        if(rc == ERROR_SUCCESS && sizeOfBuffer){
            filesIntegrityPtr = MemAlloc(g_hHeap, 0, sizeOfBuffer);

            if(filesIntegrityPtr){
                rc = RegQueryValueEx (
                        key,
                        S_REG_KEY_UNDO_INTEGRITY,
                        NULL,
                        &typeOfRegKey,
                        (PBYTE)filesIntegrityPtr,
                        &sizeOfBuffer
                        );

                if (rc != ERROR_SUCCESS) {
                    MemFree(g_hHeap, 0, filesIntegrityPtr);
                    filesIntegrityPtr = NULL;

                    DEBUGMSG ((DBG_ERROR, "File integrity info struct is not the expected size"));
                }
            }
        }

        CloseRegKey (key);
    }

    if(filesIntegrityPtr){
        if(Persist_Success == PERSIST_LOAD(filesIntegrityPtr,
                                           sizeOfBuffer,
                                           BACKUPIMAGEINFO,
                                           BACKUPIMAGEINFO_VERSION,
                                           &backupInfo)){
            bResult = TRUE;
        }
        MemFree(g_hHeap, 0, filesIntegrityPtr);
    }

    return bResult? &backupInfo: NULL;
}

VOID
pReleaseMemOfUndoFileIntegrityInfo(
    BACKUPIMAGEINFO * pBackupImageInfo
    )

/*++
Routine Description:

  pReleaseMemOfUndoFileIntegrityInfo releases memory of BACKUPIMAGEINFO structure,
  that was allocated previously by pReadUndoFileIntegrityInfo function

Arguments:

    None.

Return Value:

    None.

--*/

{
    if(!pBackupImageInfo){
        return;
    }

    PERSIST_RELEASE_STRUCT_MEMORY(BACKUPIMAGEINFO, BACKUPIMAGEINFO_VERSION, pBackupImageInfo);
}

BOOL
pIsEnoughDiskSpace(
    IN  TCHAR Drive,
    IN  PULARGE_INTEGER NeedDiskSpacePtr
    )
{
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    TCHAR drive[] = TEXT("?:\\");

    if(!NeedDiskSpacePtr){
        MYASSERT(FALSE);
        return FALSE;
    }

    drive[0] = Drive;

    if(!GetDiskFreeSpaceEx(drive, NULL, NULL, &TotalNumberOfFreeBytes)){
        LOG ((LOG_ERROR, "Unable to get %c drive free space information", Drive));
        return FALSE;
    }

    if(TotalNumberOfFreeBytes.QuadPart < NeedDiskSpacePtr->QuadPart){
        LOG ((
            LOG_ERROR,
            "No enough space on windir drive %c:\\. Free: %d MB Need: %d MB",
            Drive,
            (UINT)TotalNumberOfFreeBytes.QuadPart>>20,
            (UINT)NeedDiskSpacePtr->QuadPart>>20)
            );
        return FALSE;
    }

    return TRUE;
}

UNINSTALLSTATUS pDiskInfoComparationStatusToUninstallStatus(
    IN  DISKINFO_COMPARATION_STATUS diskInfoCmpStatus
    )
{
    switch(diskInfoCmpStatus)
    {
    case DiskInfoCmp_DifferentLetter:
    case DiskInfoCmp_DriveMountPointHasChanged:
        return Uninstall_DifferentDriveLetter;
    case DiskInfoCmp_FileSystemHasChanged:
        return Uninstall_DifferentDriveFileSystem;
    case DiskInfoCmp_GeometryHasChanged:
        return Uninstall_DifferentDriveGeometry;
    case DiskInfoCmp_PartitionPlaceHasChanged:
    case DiskInfoCmp_PartitionLengthHasChanged:
    case DiskInfoCmp_PartitionTypeHasChanged:
    case DiskInfoCmp_PartitionStyleHasChanged:
    case DiskInfoCmp_PartitionCountHasChanged:
    case DiskInfoCmp_PartitionNumberHasChanged:
    case DiskInfoCmp_RewritePartitionHasChanged:
    case DiskInfoCmp_PartitionAttributesHasChanged:
        return Uninstall_DifferentDrivePartitionInfo;
        ;
    };
    return Uninstall_WrongDrive;
}

UNINSTALLSTATUS
SanityCheck (
    IN      SANITYFLAGS Flags,
    IN      PCWSTR VolumeRestriction,           OPTIONAL
    OUT     PULONGLONG DiskSpace                OPTIONAL
    )
{
    PCTSTR path = NULL;
    UINT attribs;
    UINT version;
    UINT i;
    UINT j;
    WIN32_FILE_ATTRIBUTE_DATA fileDetails;
    PCTSTR backUpPath = NULL;
    PBACKUPIMAGEINFO imageInfo = NULL;
    UNINSTALLSTATUS result;
    OSVERSIONINFOEX osVersion;
    ULONGLONG condition;
    SYSTEMTIME st;
    FILETIME ft;
    ULARGE_INTEGER backupFileTime;
    ULARGE_INTEGER timeDifference;
    PCWSTR unicodePath;
    BOOL restricted;
    WCHAR winDir[MAX_PATH];
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    ULARGE_INTEGER FileSize;
    UINT drivesNumber;
    DRIVEINFO drivesInfo[MAX_DRIVE_NUMBER];
    UINT disksNumber;
    DISKINFO * disksInfo = NULL;
    WCHAR * FileSystemName = NULL;
    WCHAR * VolumeNTPath = NULL;
    BOOL oldImage = FALSE;
    DISKINFO_COMPARATION_STATUS DiskCmpStatus;


    __try {

        if (DiskSpace) {
            *DiskSpace = 0;
        }

        //
        // Check OS version. Use the Windows 2000 VerifyVersionInfo API so we
        // always get good results, even in the future. We support NT 5.1 and
        // above.
        //

        condition = VerSetConditionMask (0,         VER_MAJORVERSION, VER_GREATER_EQUAL);
        condition = VerSetConditionMask (condition, VER_MINORVERSION, VER_GREATER_EQUAL);
        condition = VerSetConditionMask (condition, VER_PLATFORMID, VER_EQUAL);

        ZeroMemory (&osVersion, sizeof (osVersion));
        osVersion.dwOSVersionInfoSize = sizeof (osVersion);
        osVersion.dwMajorVersion = 5;
        osVersion.dwMinorVersion = 1;
        osVersion.dwPlatformId = VER_PLATFORM_WIN32_NT;

        if (!VerifyVersionInfo (
                &osVersion,
                VER_MAJORVERSION|VER_MINORVERSION|VER_PLATFORMID,
                condition
                )) {
            DEBUGMSG ((DBG_ERROR, "VerifyVersionInfo says this is not the OS we support"));
            result = Uninstall_InvalidOsVersion;
            __leave;
        }

        //
        // Validate security
        //

        if (!pIsUserAdmin()) {
            result = Uninstall_NotEnoughPrivileges;
            DEBUGMSG ((DBG_WARNING, "User is not an administrator"));
            __leave;
        }

        //
        // Get info setup wrote to the registry
        //

        DEBUGMSG ((DBG_NAUSEA, "Getting registry info"));

        backUpPath = GetUndoDirPath();
        imageInfo = pReadUndoFileIntegrityInfo();

        if(!backUpPath || !imageInfo) {
            result = Uninstall_DidNotFindRegistryEntries;
            LOG ((LOG_WARNING, "Uninstall: Failed to retrieve registry entries"));
            __leave;
        }

        //
        // Verify backup subdirectory exists
        //

        DEBUGMSG ((DBG_NAUSEA, "Validating undo subdirectory"));

        attribs = GetFileAttributes (backUpPath);
        if (attribs == INVALID_ATTRIBUTES || !(attribs & FILE_ATTRIBUTE_DIRECTORY)) {
            DEBUGMSG ((DBG_VERBOSE, "%s not found", backUpPath));
            result = Uninstall_DidNotFindDirOrFiles;
            __leave;
        }

        //
        // Compute disk space used by image
        //

        if (DiskSpace) {
            for (i = 0; i < imageInfo->NumberOfFiles; i++) {

                path = JoinPaths (backUpPath, imageInfo->FilesInfo[i].FileName);

                DEBUGMSG ((DBG_NAUSEA, "Getting disk space for %s", path));

                if (VolumeRestriction) {
                    DEBUGMSG ((DBG_NAUSEA, "Validating volume restriction for %s", path));

                    unicodePath = CreateUnicode (path);
                    restricted = !StringIPrefixW (unicodePath, VolumeRestriction);
                    if (restricted) {
                        DEBUGMSGW ((
                            DBG_VERBOSE,
                            "%s is being skipped because it is not on volume %s",
                            unicodePath,
                            VolumeRestriction
                            ));
                    }
                    DestroyUnicode (unicodePath);

                    if (restricted) {
                        FreePathString (path);
                        path = NULL;
                        continue;
                    }
                }

                if (GetFileAttributesEx (path, GetFileExInfoStandard, &fileDetails) &&
                    fileDetails.dwFileAttributes != INVALID_ATTRIBUTES &&
                    !(fileDetails.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    ) {

                    DEBUGMSG ((
                        DBG_NAUSEA,
                        "Adding %I64u bytes for %s",
                        (ULONGLONG) fileDetails.nFileSizeLow +
                            ((ULONGLONG) fileDetails.nFileSizeHigh << (ULONGLONG) 32),
                        path
                        ));
                    *DiskSpace += (ULONGLONG) fileDetails.nFileSizeLow +
                                  ((ULONGLONG) fileDetails.nFileSizeHigh << (ULONGLONG) 32);
                }

                FreePathString (path);
                path = NULL;
            }
        }

        //
        // Validate each file in the backup subdirectory
        //

        for (i = 0; i < imageInfo->NumberOfFiles; i++) {

            path = JoinPaths (backUpPath, imageInfo->FilesInfo[i].FileName);

            DEBUGMSG ((DBG_NAUSEA, "Validating %s", path));

            if (VolumeRestriction) {
                DEBUGMSG ((DBG_NAUSEA, "Validating volume restriction for %s", path));

                unicodePath = CreateUnicode (path);
                restricted = !StringIPrefixW (unicodePath, VolumeRestriction);
                if (restricted) {
                    DEBUGMSGW ((
                        DBG_VERBOSE,
                        "%s is being skipped because it is not on volume %s",
                        unicodePath,
                        VolumeRestriction
                        ));
                }
                DestroyUnicode (unicodePath);

                if (restricted) {
                    FreePathString (path);
                    path = NULL;
                    continue;
                }
            }

            if (!GetFileAttributesEx (path, GetFileExInfoStandard, &fileDetails) ||
                fileDetails.dwFileAttributes == INVALID_ATTRIBUTES ||
                (fileDetails.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                ) {
                DEBUGMSG ((DBG_VERBOSE, "%s not found", path));
                result = Uninstall_DidNotFindDirOrFiles;
                __leave;
            }

            DEBUGMSG ((DBG_NAUSEA, "Validating time for %s", path));

            //
            // Get the current FILETIME and transfer file time into a ULONGLONG
            //

            backupFileTime.LowPart = fileDetails.ftLastWriteTime.dwLowDateTime;
            backupFileTime.HighPart = fileDetails.ftLastWriteTime.dwHighDateTime;

            GetSystemTime (&st);
            SystemTimeToFileTime (&st, &ft);
            timeDifference.LowPart = ft.dwLowDateTime;
            timeDifference.HighPart = ft.dwHighDateTime;

            //
            // If time is messed up, then fail
            //

            if (timeDifference.QuadPart < backupFileTime.QuadPart) {
                DEBUGMSG ((DBG_VERBOSE, "File time of %s is in the future according to current clock", path));
                result = Uninstall_NewImage;
                __leave;
            }

            //
            // Subtract the original write time from the current time. If
            // the result is less than 7 days, then stop.
            //

            timeDifference.QuadPart -= backupFileTime.QuadPart;

            if (Flags & FAIL_IF_NOT_OLD) {

                if (timeDifference.QuadPart < 7 * _DAY) {
                    DEBUGMSG ((DBG_VERBOSE, "Image is less than 7 days old", path));
                    result = Uninstall_NewImage;
                    __leave;
                }
            }

            //
            // Check if the image is more than 30 days old. If so, stop.
            //

            if (timeDifference.QuadPart >= (31 * _DAY)) {
                DEBUGMSG ((DBG_VERBOSE, "Image is more than 30 days old", path));
                oldImage = TRUE;
            }

            //
            // Check file size
            //

            FileSize.LowPart = fileDetails.nFileSizeLow;
            FileSize.HighPart = fileDetails.nFileSizeHigh;

            if(FileSize.QuadPart != imageInfo->FilesInfo[i].FileSize.QuadPart){
                DEBUGMSG ((DBG_VERBOSE, "%s was changed", path));
                result = Uninstall_FileWasModified;
                __leave;
            }

            if (Flags & VERIFY_CAB) {
                if (imageInfo->FilesInfo[i].IsCab) {
                    if (!CheckCabForAllFilesAvailability (path)){
                        result = Uninstall_FileWasModified;
                        __leave;
                    }
                }
            }

            FreePathString (path);
            path = NULL;
        }
        DEBUGMSG ((DBG_VERBOSE, "Undo image is valid"));

        //
        // Validate disk geometry and partition info
        //

        path = JoinPaths (backUpPath, TEXT("boot.cab"));
        if(!GetBootDrive(backUpPath, path)){
            LOG ((LOG_WARNING, "Uninstall Validate: Unable to open %s", path));
            result = Uninstall_FileWasModified;
            __leave;
        }

        if(!GetWindowsDirectoryW(winDir, ARRAYSIZE(winDir))){
            LOG ((LOG_WARNING, "Uninstall Validate: Unable to get Windows dir"));
            result = Uninstall_CantRetrieveSystemInfo;
            __leave;
        }

        //
        // compare disk information
        //

        FileSystemName = MemAlloc(g_hHeap, 0, MAX_DRIVE_NUMBER * MAX_PATH);
        if(!FileSystemName){
            LOG ((LOG_WARNING, "Uninstall Validate: Unable to allocate memory for FileSystemName"));
            result = Uninstall_NotEnoughMemory;
            __leave;
        }

        VolumeNTPath = MemAlloc(g_hHeap, 0, MAX_DRIVE_NUMBER * MAX_PATH);
        if(!VolumeNTPath){
            LOG ((LOG_WARNING, "Uninstall Validate: Unable to allocate memory for VolumeNTPath"));
            result = Uninstall_NotEnoughMemory;
            __leave;
        }

        memset(drivesInfo, 0, sizeof(drivesInfo));
        for(j = 0; j < ARRAYSIZE(drivesInfo); j++){
            drivesInfo[j].FileSystemName = &FileSystemName[j * MAX_PATH];
            drivesInfo[j].VolumeNTPath = &VolumeNTPath[j * MAX_PATH];
        }

        if(!GetUndoDrivesInfo(drivesInfo, &drivesNumber, g_BootDrv, winDir[0], backUpPath[0])){
            LOG ((LOG_WARNING, "Uninstall Validate: Unable to get disk drives information"));
            result = Uninstall_CantRetrieveSystemInfo;
            __leave;
        }

        if(drivesNumber != imageInfo->NumberOfDrives){
            LOG ((LOG_WARNING, "Uninstall Validate: Different number of drive %d, was %d", drivesNumber, imageInfo->NumberOfDrives));
            result = Uninstall_DifferentNumberOfDrives;
            __leave;
        }

        if(!CompareDrivesInfo(drivesInfo,
                              imageInfo->DrivesInfo,
                              drivesNumber,
                              &DiskCmpStatus,
                              NULL)){
            LOG ((LOG_WARNING, "Uninstall Validate: Different drives layout"));
            result = pDiskInfoComparationStatusToUninstallStatus(DiskCmpStatus);
            __leave;
        }

        if(!GetDisksInfo(&disksInfo, &disksNumber)){
            LOG ((LOG_WARNING, "Uninstall Validate: Unable to get physical disk information"));
            result = Uninstall_CantRetrieveSystemInfo;
            __leave;
        }

        if(disksNumber != imageInfo->NumberOfDisks){
            LOG ((LOG_WARNING, "Uninstall Validate: Different number of disks %d, was %d", disksNumber, imageInfo->NumberOfDisks));
            result = Uninstall_DifferentNumberOfDrives;
            __leave;
        }

        if(!CompareDisksInfo(disksInfo,
                             imageInfo->DisksInfo,
                             disksNumber,
                             &DiskCmpStatus,
                             NULL)){
            LOG ((LOG_WARNING, "Uninstall Validate: Different disks layout"));
            result = pDiskInfoComparationStatusToUninstallStatus(DiskCmpStatus);
            __leave;
        }
        //
        // validate free disk space
        //

        if(towlower(backUpPath[0]) == towlower(winDir[0]) ||
           towlower(backUpPath[0]) == towlower(g_BootDrv)){
            if(towlower(backUpPath[0]) == towlower(winDir[0])){
                imageInfo->BackupFilesDiskSpace.QuadPart += imageInfo->UndoFilesDiskSpace.QuadPart;
            }
            else{
                imageInfo->BootFilesDiskSpace.QuadPart += imageInfo->UndoFilesDiskSpace.QuadPart;
            }
        }
        else{
            if(!pIsEnoughDiskSpace(backUpPath[0], &imageInfo->UndoFilesDiskSpace)){
                result = Uninstall_NotEnoughSpace;
                __leave;
            }
        }

        if(towlower(g_BootDrv) == towlower(winDir[0])){
            imageInfo->BackupFilesDiskSpace.QuadPart += imageInfo->BootFilesDiskSpace.QuadPart;
        }
        else
        {
            if(!pIsEnoughDiskSpace(g_BootDrv, &imageInfo->BootFilesDiskSpace)){
                result = Uninstall_NotEnoughSpace;
                __leave;
            }
        }

        if(!pIsEnoughDiskSpace(winDir[0], &imageInfo->BackupFilesDiskSpace)){
            result = Uninstall_NotEnoughSpace;
            __leave;
        }

        //
        // Uninstall backup is valid & uninstall is possible. Now process warnings.
        //

        if (oldImage) {
            result = Uninstall_OldImage;
        } else {
            result = Uninstall_Valid;
        }
    }
    __finally {
        if (path) {
            FreePathString (path);
        }
        if(backUpPath){
            MemFree(g_hHeap, 0, backUpPath);
        }

        if(imageInfo){
            pReleaseMemOfUndoFileIntegrityInfo(imageInfo);
        }

        if(disksInfo){
            FreeDisksInfo(disksInfo, disksNumber);
        }

        if(VolumeNTPath){
            MemFree(g_hHeap, 0, VolumeNTPath);
        }

        if(FileSystemName){
            MemFree(g_hHeap, 0, FileSystemName);
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\exe\undo.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    osuninst.c

Abstract:

    Implements a GUI executable that gets added as part of Add/Remove
    Programs, to allow the user to roll back to Win9x.

Author:

    Jim Schmidt (jimschm)   20-Nov-2000

Revision History:

--*/

#include "pch.h"
#include "resource.h"
#include "memmsg.h"

BOOL g_DisableUninstall;
BOOL g_OldImage;
HINSTANCE g_hInst;

#define DO_UNINSTALL    1
#define DO_CLEANUP      2

VOID
pGetMsgFromRc (
    OUT     PWSTR Buffer,
    IN      UINT BufferSize,
    IN      UINT Id
    )
{
    *Buffer = 0;
    LoadString (GetModuleHandle(NULL), Id, Buffer, BufferSize);
}

BOOL
pYesNoMsgFromRcDlg (
    IN      HWND Parent,
    IN      UINT Id
    )
{
    WCHAR title[256];
    WCHAR msg[1024];

    pGetMsgFromRc (title, ARRAYSIZE(title), IDS_TITLE);
    pGetMsgFromRc (msg, ARRAYSIZE(msg), Id);

    return MessageBox (Parent, msg, title, MB_YESNO|MB_ICONEXCLAMATION|MB_DEFBUTTON2) == IDYES;
}


BOOL
pYesNoMsgFromMcDlg (
    IN      HWND Parent,
    IN      UINT Id
    )
{
    WCHAR title[256];
    PCWSTR msg;
    BOOL result = FALSE;

    pGetMsgFromRc (title, ARRAYSIZE(title), IDS_TITLE);

    msg = NULL;
    FormatMessageW (
        FORMAT_MESSAGE_ALLOCATE_BUFFER|
            FORMAT_MESSAGE_ARGUMENT_ARRAY|
            FORMAT_MESSAGE_FROM_HMODULE,
        (PVOID) g_hInst,
        Id,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (PVOID) &msg,
        0,
        (va_list *) NULL                // array of PCWSTR pointers
        );

    if (msg) {
        result = MessageBox (Parent, msg, title, MB_YESNO|MB_ICONEXCLAMATION|MB_DEFBUTTON2) == IDYES;
        LocalFree ((HLOCAL) msg);
    }

    return result;
}


VOID
pOkBoxFromRc (
    IN      HWND Parent,
    IN      UINT Id
    )
{
    WCHAR title[256];
    WCHAR msg[1024];

    pGetMsgFromRc (title, ARRAYSIZE(title), IDS_TITLE);
    pGetMsgFromRc (msg, ARRAYSIZE(msg), Id);

    MessageBox (Parent, msg, title, MB_OK|MB_ICONEXCLAMATION);
}


INT_PTR
CALLBACK
pUndoDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WCHAR msg[1024];

    switch (uMsg) {

    case WM_INITDIALOG:
        EnableWindow (GetDlgItem (hdlg, IDOK), FALSE);

        if (g_DisableUninstall) {
            EnableWindow (GetDlgItem (hdlg, IDC_RADIO1), FALSE);
            SetFocus (GetDlgItem (hdlg, IDC_RADIO2));
        }
        break;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDC_RADIO1:
        case IDC_RADIO2:
            if (HIWORD (wParam) == BN_CLICKED) {
                EnableWindow (
                    GetDlgItem (hdlg, IDOK),
                    IsDlgButtonChecked (hdlg, IDC_RADIO1) ||
                        IsDlgButtonChecked (hdlg, IDC_RADIO2)
                    );
            }
            break;

        case IDOK:
            if (IsDlgButtonChecked (hdlg, IDC_RADIO1)) {
                EndDialog (hdlg, DO_UNINSTALL);

            } else if (IsDlgButtonChecked (hdlg, IDC_RADIO2)) {
                EndDialog (hdlg, DO_CLEANUP);
            }

            break;

        case IDCANCEL:
            EndDialog (hdlg, 0);
            return TRUE;
        }

        break;

    }

    return FALSE;
}


UINT
pTranslateUninstallStatusToRc (
    UNINSTALLSTATUS Status
    )
{
    switch (Status) {

    case Uninstall_DidNotFindRegistryEntries:
        return IDS_NO_REGISTRY;

    case Uninstall_DidNotFindDirOrFiles:
        return IDS_NO_BACKUP;

    case Uninstall_InvalidOsVersion:
        return IDS_NO_INVALID_OS;

    case Uninstall_NotEnoughPrivileges:
        return IDS_NO_ENOUGH_PRIVILEGE;

    case Uninstall_FileWasModified:
        return IDS_FILES_MODIFIED;

    case Uninstall_CantRetrieveSystemInfo:
        return IDS_CANT_RETRIEVE_SYSTEMINFO;

    case Uninstall_WrongDrive:
        return IDS_WRONG_DRIVE;

    case Uninstall_NotEnoughSpace:
        return IDS_NOT_ENOUGH_SPACE;

    case Uninstall_NewImage:
        return IDS_NEW_IMAGE;

    case Uninstall_OldImage:
        return IDS_OLD_IMAGE;

    case Uninstall_DifferentNumberOfDrives:
        return IDS_DIFFERENT_DISK_NUMBER;

    case Uninstall_NotEnoughMemory:
        return IDS_NOT_ENOUGH_MEMORY;

    case Uninstall_DifferentDriveLetter:
        return IDS_DIFFERENT_DRIVE_LETTER;

    case Uninstall_DifferentDriveFileSystem:
        return IDS_DIFFERENT_DRIVE_FILE_SYSTEM;

    case Uninstall_DifferentDriveGeometry:
        return IDS_DIFFERENT_DRIVE_GEOMETRY;

    case Uninstall_DifferentDrivePartitionInfo:
        return IDS_DIFFERENT_DRIVE_PARTITION;
    }

    return IDS_NO_BACKUP;
}

UINT
pTranslateLastErrorToRc (
    VOID
    )
{
    UINT result;

    switch (GetLastError()) {
    case ERROR_SUCCESS:
        result = 0;
        break;

    case ERROR_RESOURCE_NOT_PRESENT:
        result = IDS_NO_REGISTRY;
        break;

    case ERROR_FILE_NOT_FOUND:
        result = IDS_NO_BACKUP;
        break;

    case ERROR_OLD_WIN_VERSION:
        result = IDS_NO_INVALID_OS;
        break;

    case ERROR_ACCESS_DENIED:
        result = IDS_NO_ENOUGH_PRIVILEGE;
        break;

    case ERROR_FILE_INVALID:
        result = IDS_FILES_MODIFIED;
        break;

    case ERROR_CALL_NOT_IMPLEMENTED:
        result = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    case ERROR_INVALID_TIME:
        result = IDS_NEW_IMAGE;
        break;

    case ERROR_NOACCESS:
        result = ERROR_NOACCESS;
        break;

    case ERROR_TIMEOUT:
        result = IDS_OLD_IMAGE;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        result = IDS_NOT_ENOUGH_MEMORY;
        break;

    default:
        result = IDS_UNINSTALL_PREPARATION_FAILED;
        break;
    }

    return result;
}


BOOL
pCanRemoveImage (
    UNINSTALLSTATUS Status
    )
{
    switch (Status) {

    case Uninstall_Valid:
    case Uninstall_DidNotFindDirOrFiles:
    case Uninstall_FileWasModified:
    case Uninstall_CantRetrieveSystemInfo:
    case Uninstall_WrongDrive:
    case Uninstall_DifferentNumberOfDrives:
    case Uninstall_NotEnoughSpace:
    case Uninstall_OldImage:
    case Uninstall_NewImage:
    case Uninstall_DifferentDriveLetter:
    case Uninstall_DifferentDriveFileSystem:
    case Uninstall_DifferentDriveGeometry:
    case Uninstall_DifferentDrivePartitionInfo:
        return TRUE;
    }

    return FALSE;
}


BOOL
pIsFloppyDiskInDrive(
    VOID
    )
{
    WCHAR Drive[] = L"?:\\";
    WCHAR DriveNT[] = L"\\\\.\\?:";
    UINT i;
    HANDLE hDiskDrive;
    BOOL bDiskInDrive = FALSE;
    BOOL bResult;
    DISK_GEOMETRY diskGeometry;
    DWORD bytesReturned;
    DWORD Drives;

    for(i = 0, Drives = 0x7/*GetLogicalDrives()*/; Drives; Drives >>= 1, i++){
        if(!(Drives&1)){
            continue;
        }

        Drive[0] = 'A' + i;
        if(DRIVE_REMOVABLE != GetDriveTypeW(Drive)){
            continue;
        }

        DriveNT[4] = Drive[0];

        while(1){
            hDiskDrive = CreateFileW(DriveNT,
                                     GENERIC_READ,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL);

            if(INVALID_HANDLE_VALUE == hDiskDrive){
                break;
            }

            bResult = DeviceIoControl(hDiskDrive,
                                      IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                      NULL,
                                      0,
                                      &diskGeometry,
                                      sizeof(diskGeometry),
                                      &bytesReturned,
                                      NULL);

            CloseHandle(hDiskDrive);


            if(bResult){
                bDiskInDrive = diskGeometry.MediaType != Unknown &&
                               diskGeometry.MediaType != RemovableMedia &&
                               diskGeometry.MediaType != FixedMedia;
                break;
            }

            if(ERROR_MEDIA_CHANGED != GetLastError()){
                break;
            }
        }
        if(bDiskInDrive){
            break;
        }
    }

    return bDiskInDrive;
}

INT
WINAPI
WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    PSTR AnsiCmdLine,
    INT CmdShow
    )

/*++

Routine Description:

  The entry point to osuninst.exe.

Arguments:

  hInstance     - The instance handle of this EXE
  hPrevInstance - The previous instance handle of this EXE if it is
                  running, or NULL if no other instances exist.
  AnsiCmdLine   - The command line (ANSI version)
  CmdShow       - The ShowWindow command passed by the shell

Return Value:

  Returns -1 if an error occurred, or 0 if the exe completed.

--*/

{
    INT rc = 0;
    UNINSTALLSTATUS status;
    UINT uninstallWarningMsg;
    PCSTR p;
    INITCOMMONCONTROLSEX init = {sizeof (INITCOMMONCONTROLSEX), 0};
    BOOL unattended = FALSE;

    InitCommonControlsEx (&init);
    g_hInst = hInstance;

#ifdef PRERELEASE
    //
    // Parse cmd line
    //

    p = _mbschr (AnsiCmdLine, '/');
    if (!p) {
        p = _mbschr (AnsiCmdLine, '-');
    }

    if (p) {
        if (tolower(p[1]) == 'u') {
            rc = DO_UNINSTALL;
            unattended = TRUE;
        } else if (tolower(p[1]) == 'c') {
            rc = DO_CLEANUP;
            unattended = TRUE;
        }
    }
#endif

    //
    // Validate image
    //

    status = IsUninstallImageValid (Uninstall_DontCare, NULL);

    if (status != Uninstall_Valid && status != Uninstall_OldImage) {
        pOkBoxFromRc (NULL, pTranslateUninstallStatusToRc (status));

        if (!pCanRemoveImage (status)) {
            //
            // Abnormal failure -- do not continue
            //

            return 0;
        }

        //
        // Allow user to run osuninst.exe, but restrict functionality to
        // cleanup only
        //

        g_DisableUninstall = TRUE;
    }

    if (status == Uninstall_OldImage) {
        uninstallWarningMsg = MSG_DO_OLD_UNINSTALL;
    } else {
        uninstallWarningMsg = MSG_DO_UNINSTALL;
    }

    //
    // Ask user what to do (if not unattended)
    //

    if (!rc) {
        rc = DialogBox (hInstance, MAKEINTRESOURCE(IDD_UNDO), NULL, pUndoDlgProc);
    }

    //
    // Perform action
    //

    if (rc == DO_CLEANUP) {
        if (unattended || pYesNoMsgFromMcDlg (NULL, MSG_DO_CLEANUP)) {
            RemoveUninstallImage();
        }
    } else if (rc == DO_UNINSTALL) {
        if (unattended || ProvideUiAlerts (GetDesktopWindow())) {
            if (unattended || pYesNoMsgFromMcDlg (NULL, uninstallWarningMsg)) {
                if(!unattended && pIsFloppyDiskInDrive()){
                    pOkBoxFromRc (NULL, IDS_FLOPPYDISK_IN_DRIVE);
                }
                if(!ExecuteUninstall()) {
                    pOkBoxFromRc (NULL, pTranslateLastErrorToRc());
                }
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\undo\pch\pch.h ===
#ifdef __cplusplus
extern "C" {
#endif

#define MIGISOL_INCLUDES
#include "master.h"
#include <undo.h>

#ifdef __cplusplus
}
#endif

#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))

#include <objbase.h>
#include <initguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\common9x\common9x.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    common9x.c

Abstract:

    Common functionality between various parts of Win9x-side processing.
    The routines in this library are shared only by other LIBs in the
    w95upg tree.

Author:

    Jim Schmidt (jimschm) 18-Aug-1998

Revision History:

    Name (alias)            Date            Description

--*/

#include "pch.h"

static PMAPSTRUCT g_EnvVars9x;

typedef struct {
    UINT MapSize;
    UINT Icons;
    BYTE Map[];
} ICONMAP, *PICONMAP;

static HASHTABLE g_IconMaps;
static POOLHANDLE g_IconMapPool;
static BYTE g_Bits[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};




BOOL
WINAPI
Common9x_Entry (
    IN HINSTANCE Instance,
    IN DWORD Reason,
    IN PVOID lpv
    )

/*++

Routine Description:

  Common9x_Entry is a DllMain-like init funciton, called by w95upg\dll.
  This function is called at process attach and detach.

Arguments:

  Instance - (OS-supplied) instance handle for the DLL
  Reason   - (OS-supplied) indicates attach or detatch from process or
             thread
  lpv      - unused

Return Value:

  Return value is always TRUE (indicating successful init).

--*/

{
    switch (Reason) {

    case DLL_PROCESS_ATTACH:
        //
        // used by userenum.c
        //
        if(!pSetupInitializeUtils()) {
            return FALSE;
        }
        break;


    case DLL_PROCESS_DETACH:
        pSetupUninitializeUtils();
        break;
    }

    return TRUE;
}


BOOL
EnumFirstJoystick (
    OUT     PJOYSTICK_ENUM EnumPtr
    )
{
    ZeroMemory (EnumPtr, sizeof (JOYSTICK_ENUM));

    EnumPtr->Root = OpenRegKeyStr (TEXT("HKLM\\System\\CurrentControlSet\\Control\\MediaResources\\joystick\\<FixedKey>\\CurrentJoystickSettings"));

    if (!EnumPtr->Root) {
        return FALSE;
    }

    return EnumNextJoystick (EnumPtr);
}


BOOL
EnumNextJoystick (
    IN OUT  PJOYSTICK_ENUM EnumPtr
    )
{
    TCHAR ValueName[MAX_REGISTRY_VALUE_NAME];
    PCTSTR Data;

    //
    // Ping the root key for Joystick<n>OEMName and Joystick<n>OEMCallout
    //

    EnumPtr->JoyId++;

    wsprintf (ValueName, TEXT("Joystick%uOEMName"), EnumPtr->JoyId);
    Data = GetRegValueString (EnumPtr->Root, ValueName);

    if (!Data) {
        AbortJoystickEnum (EnumPtr);
        return FALSE;
    }

    StringCopy (EnumPtr->JoystickName, Data);
    MemFree (g_hHeap, 0, Data);

    wsprintf (ValueName, TEXT("Joystick%uOEMCallout"), EnumPtr->JoyId);
    Data = GetRegValueString (EnumPtr->Root, ValueName);

    if (!Data) {
        AbortJoystickEnum (EnumPtr);
        return FALSE;
    }

    StringCopy (EnumPtr->JoystickDriver, Data);
    MemFree (g_hHeap, 0, Data);

    return TRUE;
}


VOID
AbortJoystickEnum (
    IN      PJOYSTICK_ENUM EnumPtr
    )
{
    if (EnumPtr->Root) {
        CloseRegKey (EnumPtr->Root);
    }

    ZeroMemory (EnumPtr, sizeof (JOYSTICK_ENUM));
}



typedef struct {

    PCTSTR Text;
    PCTSTR Button1;
    PCTSTR Button2;

} TWOBUTTONBOXPARAMS, *PTWOBUTTONBOXPARAMS;


BOOL
CALLBACK
TwoButtonProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PTWOBUTTONBOXPARAMS params;

    switch (uMsg) {
    case WM_INITDIALOG:

        params = (PTWOBUTTONBOXPARAMS) lParam;
        SetWindowText (GetDlgItem (hdlg, IDC_TWOBUTTON_TEXT), params->Text);
        SetWindowText (GetDlgItem (hdlg, IDBUTTON1), params->Button1);
        SetWindowText (GetDlgItem (hdlg, IDBUTTON2), params->Button2);

        CenterWindow (hdlg, GetDesktopWindow());

        return FALSE;

    case WM_COMMAND:

        EndDialog (hdlg, LOWORD (wParam));
        break;
    }

    return FALSE;

}


LRESULT
TwoButtonBox (
    IN HWND Window,
    IN PCTSTR Text,
    IN PCTSTR Button1,
    IN PCTSTR Button2
    )
{
    TWOBUTTONBOXPARAMS params;

    params.Text = Text;
    params.Button1 = Button1;
    params.Button2 = Button2;

    return DialogBoxParam (
                g_hInst,
                MAKEINTRESOURCE(IDD_TWOBUTTON_DLG),
                Window,
                TwoButtonProc,
                (LPARAM) &params
                );
}


BOOL
DontTouchThisFile (
    IN      PCTSTR FileName
    )
{
    TCHAR key[MEMDB_MAX];

    RemoveOperationsFromPath (FileName, ALL_CHANGE_OPERATIONS);

    MemDbBuildKey (key, MEMDB_CATEGORY_DEFERREDANNOUNCE, FileName, NULL, NULL);
    MemDbDeleteTree (key);

    return TRUE;
}


VOID
ReplaceOneEnvVar (
    IN OUT  PCTSTR *NewString,
    IN      PCTSTR Base,
    IN      PCTSTR Variable,
    IN      PCTSTR Value
    )
{
    PCTSTR FreeMe;

    //
    // The Base string cannot be freed, but a previous NewString
    // value must be freed.
    //

    FreeMe = *NewString;        // FreeMe will be NULL if no replacement string
                                // has been generated yet

    if (FreeMe) {
        Base = FreeMe;          // Previously generated replacement string is now the source
    }

    *NewString = StringSearchAndReplace (Base, Variable, Value);

    if (*NewString == NULL) {
        // Keep previously generated replacement string
        *NewString = FreeMe;
    } else if (FreeMe) {
        // Free previously generated replacmenet string
        FreePathString (FreeMe);
    }

    //
    // *NewString is either:
    //
    //   1. It's original value (which may be NULL)
    //   2. A new string that will need to be freed with FreePathString
    //

}


VOID
Init9xEnvironmentVariables (
    VOID
    )
{

    DestroyStringMapping (g_EnvVars9x);
    g_EnvVars9x = CreateStringMapping();

    AddStringMappingPair (g_EnvVars9x, S_WINDIR_ENV, g_WinDir);
    AddStringMappingPair (g_EnvVars9x, S_SYSTEMDIR_ENV, g_SystemDir);
    AddStringMappingPair (g_EnvVars9x, S_SYSTEM32DIR_ENV, g_System32Dir);
    AddStringMappingPair (g_EnvVars9x, S_SYSTEMDRIVE_ENV, g_WinDrive);
    AddStringMappingPair (g_EnvVars9x, S_BOOTDRIVE_ENV, g_BootDrivePath);
    AddStringMappingPair (g_EnvVars9x, S_PROGRAMFILES_ENV, g_ProgramFilesDir);
    AddStringMappingPair (g_EnvVars9x, S_COMMONPROGRAMFILES_ENV, g_ProgramFilesCommonDir);
}


BOOL
Expand9xEnvironmentVariables (
    IN      PCSTR SourceString,
    OUT     PSTR DestinationString,     // can be the same as SourceString
    IN      INT DestSizeInBytes
    )
{
    BOOL Changed;

    Changed = MappingSearchAndReplaceEx (
                    g_EnvVars9x,
                    SourceString,
                    DestinationString,
                    0,
                    NULL,
                    DestSizeInBytes,
                    STRMAP_ANY_MATCH,
                    NULL,
                    NULL
                    );

    return Changed;
}


VOID
CleanUp9xEnvironmentVariables (
    VOID
    )
{
    DestroyStringMapping (g_EnvVars9x);
}


BOOL
pIsGuid (
    PCTSTR Key
    )

/*++

Routine Description:

  pIsGuid examines the string specified by Key and determines if it
  is the correct length and has dashes at the correct locations.

Arguments:

  Key - The string that may or may not be a GUID

Return Value:

  TRUE if Key is a GUID (and only a GUID), or FALSE if not.

--*/

{
    PCTSTR p;
    int i;
    DWORD DashesFound = 0;

    if (CharCount (Key) != 38) {
        return FALSE;
    }

    for (i = 0, p = Key ; *p ; p = _tcsinc (p), i++) {
        if (_tcsnextc (p) == TEXT('-')) {
            if (i != 9 && i != 14 && i != 19 && i != 24) {
                DEBUGMSG ((DBG_NAUSEA, "%s is not a GUID", Key));
                return FALSE;
            }
        } else if (i == 9 || i == 14 || i == 19 || i == 24) {
            DEBUGMSG ((DBG_NAUSEA, "%s is not a GUID", Key));
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
FixGuid (
    IN      PCTSTR Guid,
    OUT     PTSTR NewGuid           // can be the same as Guid
    )
{
    TCHAR NewData[MAX_GUID];

    if (pIsGuid (Guid)) {
        if (NewGuid != Guid) {
            StringCopy (NewGuid, Guid);
        }

        return TRUE;
    }

    //
    // Try fixing GUID -- sometimes the braces are missing
    //

    wsprintf (NewData, TEXT("{%s}"), Guid);
    if (pIsGuid (NewData)) {
        StringCopy (NewGuid, NewData);
        return TRUE;
    }

    return FALSE;
}


BOOL
IsGuid (
    IN      PCTSTR Guid,
    IN      BOOL MustHaveBraces
    )
{
    TCHAR NewData[MAX_GUID];

    if (pIsGuid (Guid)) {
        return TRUE;
    }

    if (MustHaveBraces) {
        return FALSE;
    }

    //
    // Try fixing GUID -- sometimes the braces are missing
    //

    wsprintf (NewData, TEXT("{%s}"), Guid);
    if (pIsGuid (NewData)) {
        return TRUE;
    }

    return FALSE;
}


VOID
pParseMapRanges (
    IN      PCTSTR List,
    OUT     PGROWBUFFER Ranges,     OPTIONAL
    OUT     PINT HighestNumber      OPTIONAL
    )
{
    MULTISZ_ENUM e;
    PTSTR ParsePos;
    INT From;
    INT To;
    INT Max = 0;
    PINT Ptr;

    if (EnumFirstMultiSz (&e, List)) {
        do {
            //
            // The INF has either a single resource ID, or
            // a range, separated by a dash.
            //

            if (_tcschr (e.CurrentString, TEXT('-'))) {

                From = (INT) _tcstoul (e.CurrentString, &ParsePos, 10);

                ParsePos = (PTSTR) SkipSpace (ParsePos);
                if (_tcsnextc (ParsePos) != TEXT('-')) {
                    DEBUGMSG ((DBG_WHOOPS, "Ignoring invalid resource ID %s", e.CurrentString));
                    continue;
                }

                ParsePos = (PTSTR) SkipSpace (_tcsinc (ParsePos));

                To = (INT) _tcstoul (ParsePos, &ParsePos, 10);

                if (*ParsePos) {
                    DEBUGMSG ((DBG_WHOOPS, "Ignoring garbage resource ID %s", e.CurrentString));
                    continue;
                }

                if (From > To) {
                    DEBUGMSG ((DBG_WHOOPS, "Ignoring invalid resource ID range %s", e.CurrentString));
                    continue;
                }

                Max = max (Max, To);

            } else {
                From = To = (INT) _tcstoul (e.CurrentString, &ParsePos, 10);

                if (*ParsePos) {
                    DEBUGMSG ((DBG_WHOOPS, "Ignoring garbage resource %s", e.CurrentString));
                    continue;
                }

                Max = max (Max, From);
            }

            if (Ranges) {

                Ptr = (PINT) GrowBuffer (Ranges, sizeof (INT));
                *Ptr = From;

                Ptr = (PINT) GrowBuffer (Ranges, sizeof (INT));
                *Ptr = To;

            }
        } while (EnumNextMultiSz (&e));
    }

    if (HighestNumber) {
        *HighestNumber = Max;
    }
}


VOID
InitializeKnownGoodIconMap (
    VOID
    )
{
    PICONMAP Map;
    INT Highest;
    INT From;
    INT To;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR Module;
    PCTSTR List;
    PCTSTR IconsInModule;
    GROWBUFFER Ranges = GROWBUF_INIT;
    PINT Ptr;
    PINT End;
    UINT MapDataSize;
    PBYTE Byte;
    BYTE Bit;

    if (g_IconMaps) {
        return;
    }

    if (g_Win95UpgInf == INVALID_HANDLE_VALUE) {
        MYASSERT (g_ToolMode);
        return;
    }

    g_IconMaps = HtAllocWithData (sizeof (PICONMAP));
    g_IconMapPool = PoolMemInitNamedPool ("IconMap");

    //
    // Enumerate the lines in win95upg.inf and build a map table for each
    //

    if (InfFindFirstLine (g_Win95UpgInf, S_KNOWN_GOOD_ICON_MODULES, NULL, &is)) {
        do {

            //
            // Parse the INF format into a binary struct
            //

            List = InfGetMultiSzField (&is, 2);

            pParseMapRanges (List, &Ranges, &Highest);

            if (!Ranges.End) {
                continue;
            }

            //
            // Allocate a map struct
            //

            MapDataSize = (Highest / 8) + 1;
            Map = PoolMemGetMemory (g_IconMapPool, sizeof (ICONMAP) + MapDataSize);

            //
            // Fill in the map
            //

            Map->MapSize = Highest;
            ZeroMemory (Map->Map, MapDataSize);

            Ptr = (PINT) Ranges.Buf;
            End = (PINT) (Ranges.Buf + Ranges.End);

            while (Ptr < End) {
                From = *Ptr++;
                To = *Ptr++;

                while (From <= To) {
                    Byte = Map->Map + (From / 8);
                    Bit = g_Bits[From & 7];

                    *Byte |= Bit;
                    From++;
                }
            }

            FreeGrowBuffer (&Ranges);

            IconsInModule = InfGetStringField (&is, 1);
            if (IconsInModule) {
                Map->Icons = _tcstoul (IconsInModule, NULL, 10);
            }
            else {
                continue;
            }


            //
            // Cross-reference the map with the module name via a hash table
            //

            Module = InfGetStringField (&is, 0);
            if (!Module || !*Module) {
                continue;
            }

            HtAddStringAndData (g_IconMaps, Module, &Map);

        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);
}


VOID
CleanUpKnownGoodIconMap (
    VOID
    )
{
    if (g_IconMaps) {
        HtFree (g_IconMaps);
        g_IconMaps = NULL;
    }

    if (g_IconMapPool) {
        PoolMemDestroyPool (g_IconMapPool);
        g_IconMapPool = NULL;
    }
}


BOOL
IsIconKnownGood (
    IN      PCTSTR FileSpec,
    IN      INT Index
    )
{
    PCTSTR Module;
    PICONMAP Map;
    PBYTE Byte;
    BYTE Bit;
    TCHAR node[MEMDB_MAX];

    Module = GetFileNameFromPath (FileSpec);
    MYASSERT (Module);

    //
    // Check icon against moved icons
    //

    wsprintf (node, MEMDB_CATEGORY_ICONS_MOVED TEXT("\\%s\\%i"), FileSpec, Index);
    if (MemDbGetValue (node, NULL)) {
        return TRUE;
    }

    //
    // If a path is specified, make sure it is in either %windir% or %windir%\system.
    //

    if (Module > (FileSpec + 2)) {

        if (!StringIMatchCharCount (FileSpec, g_WinDirWack, g_WinDirWackChars) &&
            !StringIMatchCharCount (FileSpec, g_SystemDirWack, g_SystemDirWackChars)
            ) {
            return FALSE;
        }
    }

    //
    // Test if there is an icon map for this module, then check the map
    //

    if (!HtFindStringAndData (g_IconMaps, Module, &Map)) {
        return FALSE;
    }

    //
    // If the icon index is a positive number, then it is a sequential
    // ID.  If it is a negative number, then it is a resource ID.
    //

    if (Index >= 0) {
        return (UINT) Index <= Map->Icons;
    }

    Index = -Index;

    if ((UINT) Index > Map->MapSize) {
        return FALSE;
    }

    Byte = Map->Map + (Index / 8);
    Bit = g_Bits[Index & 7];

    return *Byte & Bit;
}


BOOL
TreatAsGood (
    IN      PCTSTR FullPath
    )

/*++

Routine Description:

  TreatAsGood checks the registry to see if a file is listed as good.  If
  this is the case, then setup processing is skipped.  This is currently
  used for TWAIN data sources, run keys and CPLs.

Arguments:

  FullPath - Specifies the full path of the file.

Return Value:

  TRUE if the file should be treated as known good, FALSE otherwise.

--*/

{
    HKEY Key;
    REGVALUE_ENUM e;
    BOOL b = FALSE;
    PCTSTR str;

    Key = OpenRegKeyStr (TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\KnownGood"));

    if (Key) {

        if (EnumFirstRegValue (&e, Key)) {
            do {

                str = GetRegValueString (Key, e.ValueName);

                if (str) {
                    b = StringIMatch (FullPath, str);
                    MemFree (g_hHeap, 0, str);

                    DEBUGMSG_IF ((b, DBG_VERBOSE, "File %s is known-good", FullPath));
                }

            } while (!b && EnumNextRegValue (&e));
        }

        CloseRegKey (Key);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\common9x\namefix.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  namefix.c

Abstract:

  This module generates memdb entries for names that are to be used on Windows
  NT.  All names are validated, and incompatible names are placed in the
  NewNames memdb category.

  Names are organized into groups; within a group, each name must be unique,
  but across groups, duplicate names are allowed.  For example, the name
  group "UserNames" holds all user names, and each user name must be unique.
  The user name can be the same as the computer name, because the computer
  name is stored in the "ComputerName" group.

  The code here is extendable for other types of name collisions.  To add
  support for other types of names, simply add the group name to the
  NAME_GROUP_LIST macro expansion below, then implement three functions:

    pEnumGroupName
    pValidateGroupName
    pRecommendGroupName

  You'll replace GroupName in the function names above with the name of your
  actual group.

  The code in this module should be the only place where names are validated
  on the Win9x side.

Author:

  Jim Schmidt (jimschm) 24-Dec-1997

Revision History:

   jimschm      21-Jan-1998         Commented macro expansion list, added
                                    g_DisableDomainChecks capability


--*/

#include "pch.h"
#include "cmn9xp.h"

#include <validc.h>     // nt\private\inc
#define S_ILLEGAL_CHARS      ILLEGAL_NAME_CHARS_STR TEXT("*")


#define DBG_NAMEFIX     "NameFix"

#define MIN_UNLEN       20


//
// TEST_ALL_INCOMPATIBLE will force all names to be considered incompatible
// TEST_MANGLE_NAMES will force names to be invalid
//

//#define TEST_ALL_INCOMPATIBLE
//#define TEST_MANGLE_NAMES


/*++

Macro Expansion List Description:

  NAME_GROUP_LIST lists each name category, such as computer name, domain name,
  user name and so on.  The macro expansion list automatically generates
  three function prototypes for each name category.  Also, the message ID is
  used as the category identifier by external callers.

Line Syntax:

   DEFMAC(GroupName, Id)

Arguments:

   GroupName - Specifies the type of name.  Must be a valid C function name.
               The macro expansion list will generate prototypes for:

                    pEnum<GroupName>
                    pValidate<GroupName>
                    pRecommend<GroupName>

                where, of course, <GroupName> is replaced by the text in the
                macro declaration line.

                All three functions must be implemented in this source file.

  Id - Specifies the message ID giving the display name of the name group.
       The name group is displayed in the list box that the user sees when
       they are alerted there are some incompatible names on their machine.
       Id is also used to uniquely identify a name group in some of the
       routines below.

Variables Generated From List:

    g_NameGroupRoutines

--*/

#define NAME_GROUP_LIST                                      \
        DEFMAC(ComputerDomain, MSG_COMPUTERDOMAIN_CATEGORY)  \
        DEFMAC(Workgroup, MSG_WORKGROUP_CATEGORY)            \
        DEFMAC(UserName, MSG_USERNAME_CATEGORY)              \
        DEFMAC(ComputerName, MSG_COMPUTERNAME_CATEGORY)      \




//
// Macro expansion declarations
//

#define MAX_NAME        2048

typedef struct {
    //
    // The NAME_ENUM structure is passed uninitialized to pEnumGroupName
    // function.  The same structure is passed unchanged to subsequent
    // calls to pEnumGroupName.  Each enum function declares its
    // params in this struct.
    //

    union {
        struct {
            //
            // pEnumUser
            //
            USERENUM UserEnum;
        };
    };

    //
    // All enumeration routines must fill in the following if they
    // return TRUE:
    //

    TCHAR Name[MAX_NAME];

} NAME_ENUM, *PNAME_ENUM;

typedef struct {
    PCTSTR GroupName;
    TCHAR AuthenticatingAgent[MAX_COMPUTER_NAME];
    BOOL FromUserInterface;
    UINT FailureMsg;
    BOOL DomainLogonEnabled;
} NAME_GROUP_CONTEXT, *PNAME_GROUP_CONTEXT;

typedef BOOL (ENUM_NAME_PROTOTYPE)(PNAME_GROUP_CONTEXT Context, PNAME_ENUM EnumPtr, BOOL First);
typedef ENUM_NAME_PROTOTYPE * ENUM_NAME_FN;

typedef BOOL (VALIDATE_NAME_PROTOTYPE)(PNAME_GROUP_CONTEXT Context, PCTSTR NameCandidate);
typedef VALIDATE_NAME_PROTOTYPE * VALIDATE_NAME_FN;

typedef VOID (RECOMMEND_NAME_PROTOTYPE)(PNAME_GROUP_CONTEXT Context, PCTSTR InvalidName, PTSTR RecommendedNameBuf);
typedef RECOMMEND_NAME_PROTOTYPE * RECOMMEND_NAME_FN;

typedef struct {
    UINT NameId;
    PCTSTR GroupName;
    ENUM_NAME_FN Enum;
    VALIDATE_NAME_FN Validate;
    RECOMMEND_NAME_FN Recommend;
    NAME_GROUP_CONTEXT Context;
} NAME_GROUP_ROUTINES, *PNAME_GROUP_ROUTINES;

//
// Automatic arrays and prototypes
//

// The prototoypes
#define DEFMAC(x,id)    ENUM_NAME_PROTOTYPE pEnum##x;

NAME_GROUP_LIST

#undef DEFMAC

#define DEFMAC(x,id)    VALIDATE_NAME_PROTOTYPE pValidate##x;

NAME_GROUP_LIST

#undef DEFMAC

#define DEFMAC(x,id)    RECOMMEND_NAME_PROTOTYPE pRecommend##x;

NAME_GROUP_LIST

#undef DEFMAC

// The array of functions
#define DEFMAC(x,id)    {id, TEXT(#x), pEnum##x, pValidate##x, pRecommend##x},

NAME_GROUP_ROUTINES g_NameGroupRoutines[] = {

    NAME_GROUP_LIST /* , */

    {0, NULL, NULL, NULL, NULL, NULL}
};


//
// Local prototypes
//

BOOL
pDoesNameExistInMemDb (
    IN      PNAME_GROUP_CONTEXT Context,
    IN      PCTSTR UserName
    );


//
// Implementation
//

PNAME_GROUP_ROUTINES
pGetNameGroupById (
    IN      UINT MessageId
    )

/*++

Routine Description:

  pGetNameGroupById finds a group by searching the list for a message ID.  The
  message ID is the unique identifier for the group.

Arguments:

  MessageId - Specifies the unique ID of the group to find

Return Value:

  A pointer to the group struct, or NULL if one was not found.

--*/

{
    INT i;

    for (i = 0 ; g_NameGroupRoutines[i].GroupName ; i++) {
        if (g_NameGroupRoutines[i].NameId == MessageId) {
            return &g_NameGroupRoutines[i];
        }
    }

    return NULL;
}


PNAME_GROUP_CONTEXT
pGetNameGroupContextById (
    IN      UINT MessageId
    )

/*++

Routine Description:

  pGetNameGroupById finds a group by searching the list for a message ID.  The
  message ID is the unique identifier for the group.  The return value is
  the context structure used by the group.

Arguments:

  MessageId - Specifies the unique ID of the group to find

Return Value:

  A pointer to the group's context struct, or NULL if one was not found.

--*/

{
    INT i;

    for (i = 0 ; g_NameGroupRoutines[i].GroupName ; i++) {
        if (g_NameGroupRoutines[i].NameId == MessageId) {
            return &g_NameGroupRoutines[i].Context;
        }
    }

    return NULL;
}


BOOL
pEnumComputerName (
    IN      PNAME_GROUP_CONTEXT Context,
    IN OUT  PNAME_ENUM EnumPtr,
    IN      BOOL First
    )

/*++

Routine Description:

  pEnumComputerName obtains the computer name and returns it
  in the EnumPtr struct.  If no name is assigned to the computer,
  an empty string is returned.

Arguments:

  Context - Unused (holds context about name group)

  EnumPtr - Receives the computer name

  First - Specifies TRUE on the first call to pEnumComputerName,
          or FALSE on subseqeuent calls to pEnumComputerName.

Return Value:

  If First is TRUE, returns TRUE if a name is enumerated, or FALSE
  if the name is not valid.

  If First is FALSE, always returns FALSE.


--*/

{
    DWORD Size;

    if (!First) {
        return FALSE;
    }

    //
    // Get the computer name
    //

    Size = sizeof (EnumPtr->Name) / sizeof (EnumPtr->Name[0]);
    if (!GetComputerName (EnumPtr->Name, &Size)) {
        EnumPtr->Name[0] = 0;
    }

    return TRUE;
}


BOOL
pEnumUserName (
    IN      PNAME_GROUP_CONTEXT Context,
    IN OUT  PNAME_ENUM EnumPtr,
    IN      BOOL First
    )

/*++

Routine Description:

  pEnumUserName enumerates all users on the machine via the EnumFirstUser/
  EnumNextUser APIs.  It does not enumerate the fixed names.

  Like the other enumeration routines, this routine is called until it
  returns FALSE, so that all resources are cleaned up correctly.

Arguments:

  Context - Unused (holds context about name group)

  EnumPtr - Specifies the current enumeration state.  Receives the enumerated
            user name.

  First - Specifies TRUE on the first call to pEnumUserName,
          or FALSE on subseqeuent calls to pEnumUserName.

Return Value:

  TRUE if a user was enumerated, or FALSE if all users were enumerated.

--*/

{
    //
    // Enumerate the next user
    //

    if (First) {
        if (!EnumFirstUser (&EnumPtr->UserEnum, ENUMUSER_DO_NOT_MAP_HIVE)) {
            LOG ((LOG_ERROR, "No users to enumerate"));
            return FALSE;
        }
    } else {
        if (!EnumNextUser (&EnumPtr->UserEnum)) {
            return FALSE;
        }
    }

    //
    // Special case -- ignore default user
    //

    while (*EnumPtr->UserEnum.UserName == 0) {
        if (!EnumNextUser (&EnumPtr->UserEnum)) {
            return FALSE;
        }
    }

    //
    // Copy user name to name buffer
    //

    StringCopy (EnumPtr->Name, EnumPtr->UserEnum.UserName);

    return TRUE;
}


BOOL
pEnumWorkgroup (
    IN      PNAME_GROUP_CONTEXT Context,
    IN OUT  PNAME_ENUM EnumPtr,
    IN      BOOL First
    )

/*++

Routine Description:

  pEnumWorkgroup obtains the workgroup name and returns it
  in the EnumPtr struct.  If the VNETSUP support is not
  installed, or the workgroup name is empty, this routine
  returns FALSE.

Arguments:

  Context - Receives AuthenticatingAgent value

  EnumPtr - Receives the computer domain name

  First - Specifies TRUE on the first call to pEnumWorkgroup,
          or FALSE on subseqeuent calls to pEnumWorkgroup.

Return Value:

  If First is TRUE, returns TRUE if a name is enumerated, or FALSE
  if the name is not valid.

  If First is FALSE, always returns FALSE.

--*/

{
    HKEY VnetsupKey;
    PCTSTR StrData;

    if (!First) {
        return FALSE;
    }

    EnumPtr->Name[0] = 0;

    //
    // Obtain the workgroup name into EnumPtr->Name
    //

    VnetsupKey = OpenRegKeyStr (S_VNETSUP);

    if (VnetsupKey) {

        StrData = GetRegValueString (VnetsupKey, S_WORKGROUP);

        if (StrData) {
            _tcssafecpy (EnumPtr->Name, StrData, MAX_COMPUTER_NAME);
            MemFree (g_hHeap, 0, StrData);
        }
        ELSE_DEBUGMSG ((DBG_WARNING, "pEnumWorkgroup: Workgroup value does not exist"));

        CloseRegKey (VnetsupKey);
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "pEnumWorkgroup: VNETSUP key does not exist"));

    return EnumPtr->Name[0] != 0;
}


BOOL
pEnumComputerDomain (
    IN      PNAME_GROUP_CONTEXT Context,
    IN OUT  PNAME_ENUM EnumPtr,
    IN      BOOL First
    )

/*++

Routine Description:

  pEnumComputerDomain obtains the workgroup name and returns it in the EnumPtr
  struct.  If the MS Networking client is not installed, this routine returns
  FALSE.

  This routine also obtains the AuthenticatingAgent value, and stores it in
  the Context structure for use by pRecommendComputerDomain.

Arguments:

  Context - Receives AuthenticatingAgent value

  EnumPtr - Receives the computer domain name

  First - Specifies TRUE on the first call to pEnumComputerDomain,
          or FALSE on subseqeuent calls to pEnumComputerDomain.

Return Value:

  If First is TRUE, returns TRUE if a name is enumerated, or FALSE
  if the name is not valid.

  If First is FALSE, always returns FALSE.

--*/

{
    HKEY Key;
    HKEY NetLogonKey;
    HKEY VnetsupKey;
    PBYTE Data;
    PCTSTR StrData;
    BOOL b = TRUE;

    if (!First) {
        return FALSE;
    }

    EnumPtr->Name[0] = 0;
    Context->DomainLogonEnabled = FALSE;

    //
    // Is the MS Networking client installed?
    //

    Key = OpenRegKeyStr (S_MSNP32);
    if (!Key) {
        //
        // MS Networking client is not installed.  Return FALSE
        // because any Win9x workgroup name will work with NT.
        //

        DEBUGMSG ((DBG_NAMEFIX, "pEnumComputerDomain: MS Networking client is not installed."));
        return FALSE;
    }

    __try {
        //
        // Determine if the domain logon is enabled
        //

        NetLogonKey = OpenRegKeyStr (S_LOGON_KEY);

        if (NetLogonKey) {
            Data = (PBYTE) GetRegValueBinary (NetLogonKey, S_LM_LOGON);
            if (Data) {
                if (*Data) {
                    Context->DomainLogonEnabled = TRUE;
                }

                MemFree (g_hHeap, 0, Data);
            }

            CloseRegKey (NetLogonKey);
        }

        //
        // If no domain logon is enabled, return FALSE, because
        // any Win9x workgroup name will work with NT.
        //

        if (!Context->DomainLogonEnabled) {
            DEBUGMSG ((DBG_NAMEFIX, "pEnumComputerDomain: Domain logon is not enabled."));
            b = FALSE;
            __leave;
        }

        //
        // Obtain the workgroup name into EnumPtr->Name; we will try
        // to use this as the NT computer domain.
        //

        VnetsupKey = OpenRegKeyStr (S_VNETSUP);

        if (VnetsupKey) {

            StrData = GetRegValueString (VnetsupKey, S_WORKGROUP);

            if (StrData) {
                _tcssafecpy (EnumPtr->Name, StrData, MAX_COMPUTER_NAME);
                MemFree (g_hHeap, 0, StrData);
            }
            ELSE_DEBUGMSG ((DBG_WARNING, "pEnumComputerDomain: Workgroup value does not exist"));

            CloseRegKey (VnetsupKey);
        }
        ELSE_DEBUGMSG ((DBG_WARNING, "pEnumComputerDomain: VNETSUP key does not exist"));

        //
        // Obtain the AuthenticatingAgent value from Key and stick it in
        // Context->AuthenticatingAgent
        //

        StrData = GetRegValueString (Key, S_AUTHENTICATING_AGENT);
        if (StrData) {

            //
            // Copy AuthenticatingAgent to enum struct
            //

            _tcssafecpy (Context->AuthenticatingAgent, StrData, MAX_COMPUTER_NAME);

            MemFree (g_hHeap, 0, StrData);

        } else {
            Context->AuthenticatingAgent[0] = 0;

            LOG ((LOG_ERROR,"Domain Logon enabled, but AuthenticatingAgent value is missing"));
        }
    }

    __finally {
        CloseRegKey (Key);
    }

    return b;
}


BOOL
pValidateNetName (
    OUT     PNAME_GROUP_CONTEXT Context,    OPTIONAL
    IN      PCTSTR NameCandidate,
    IN      BOOL SpacesAllowed,
    IN      BOOL DotSpaceCheck,
    IN      UINT MaxLength,
    OUT     PCSTR *OffendingChar            OPTIONAL
    )

/*++

Routine Description:

  pValidateNetName performs a check to see if the specified name is valid on
  NT 5.

Arguments:

  Context       - Receives the error message ID, if any error occurred.

  NameCandidate - Specifies the name to validate.

  SpacesAllowed - Specifies TRUE if spaces are allowed in the name, or FALSE
                  if not.

  MaxLength     - Specifies the max characters that can be in the name.

  DotSpaceCheck - Specifies TRUE if the name cannot consist only of a dot and
                  a space, or FALSE if it can.

  OffendingChar - Receives the pointer to the character that caused the
                  problem, or NULL if no error or the error was caused by
                  something other than a character set mismatch or length test.

Return Value:

  TRUE if the name is valid, or FALSE if it is not.

--*/

{
    PCTSTR p;
    PCTSTR LastNonSpaceChar;
    CHARTYPE ch;
    BOOL allDigits;

    if (OffendingChar) {
        *OffendingChar = NULL;
    }

    //
    // Minimum length test
    //

    if (!NameCandidate[0]) {
        if (Context) {
            Context->FailureMsg = MSG_INVALID_EMPTY_NAME_POPUP;
        }

        return FALSE;
    }

    //
    // Maximum length test
    //

    if (CharCount (NameCandidate) > MaxLength) {
        if (Context) {
            Context->FailureMsg = MSG_INVALID_COMPUTERNAME_LENGTH_POPUP;
        }

        if (OffendingChar) {
            *OffendingChar = TcharCountToPointer (NameCandidate, MaxLength);
        }

        return FALSE;
    }

    //
    // No leading spaces allowed
    //

    if (_tcsnextc (NameCandidate) == TEXT(' ')) {
        if (Context) {
            Context->FailureMsg = MSG_INVALID_COMPUTERNAME_CHAR_POPUP;
        }

        if (OffendingChar) {
            *OffendingChar = NameCandidate;
        }

        return FALSE;
    }

    //
    // No invalid characters
    //

    ch = ' ';
    LastNonSpaceChar = NULL;
    allDigits = TRUE;

    for (p = NameCandidate ; *p ; p = _tcsinc (p)) {

        ch = _tcsnextc (p);

        if (_tcschr (S_ILLEGAL_CHARS, ch) != NULL ||
            (ch == TEXT(' ') && !SpacesAllowed)
            ) {
            if (OffendingChar) {
                *OffendingChar = p;
            }

            if (Context) {
                Context->FailureMsg = MSG_INVALID_COMPUTERNAME_CHAR_POPUP;
            }

            return FALSE;
        }

        if (ch != TEXT('.') && ch != TEXT(' ')) {
            DotSpaceCheck = FALSE;
        }

        if (ch != TEXT(' ')) {
            LastNonSpaceChar = p;
        }

        if (allDigits) {
            if (ch < TEXT('0') || ch > TEXT('9')) {
                allDigits = FALSE;
            }
        }
    }

    if (allDigits) {

        if (OffendingChar) {
            *OffendingChar = NameCandidate;
        }

        if (Context) {
            Context->FailureMsg = MSG_INVALID_COMPUTERNAME_CHAR_POPUP;
        }

        return FALSE;
    }

    //
    // No trailing dot
    //

    if (ch == TEXT('.')) {
        MYASSERT (LastNonSpaceChar);

        if (OffendingChar) {
            *OffendingChar = LastNonSpaceChar;
        }

        if (Context) {
            Context->FailureMsg = MSG_INVALID_COMPUTERNAME_CHAR_POPUP;
        }

        return FALSE;
    }

    //
    // No trailing space
    //

    if (ch == TEXT(' ')) {
        MYASSERT (LastNonSpaceChar);

        if (OffendingChar) {
            *OffendingChar = _tcsinc (LastNonSpaceChar);
        }

        if (Context) {
            Context->FailureMsg = MSG_INVALID_COMPUTERNAME_CHAR_POPUP;
        }

        return FALSE;
    }

    //
    // Dot-space only check
    //

    if (DotSpaceCheck) {
        if (OffendingChar) {
            *OffendingChar = NameCandidate;
        }

        if (Context) {
            Context->FailureMsg = MSG_INVALID_USERNAME_SPACEDOT_POPUP;
        }

        return FALSE;
    }

    return TRUE;
}


BOOL
ValidateDomainNameChars (
    IN      PCTSTR NameCandidate
    )
{
    return pValidateNetName (
                NULL,
                NameCandidate,
                FALSE,
                FALSE,
                min (MAX_SERVER_NAME, DNLEN),
                NULL
                );
}


BOOL
ValidateUserNameChars (
    IN      PCTSTR NameCandidate
    )
{
    return pValidateNetName (
                NULL,
                NameCandidate,
                TRUE,
                TRUE,
                min (MAX_USER_NAME, MIN_UNLEN),
                NULL
                );
}


BOOL
pValidateComputerName (
    IN      PNAME_GROUP_CONTEXT Context,
    IN      PCTSTR NameCandidate
    )

/*++

Routine Description:

  pValidateComputerName makes sure the specified name is not
  empty, is not longer than 15 characters, and consists only
  of characters legal for a computer name.  Also, if the name
  collides with a user name, then the computer name is invalid.

Arguments:

  Context - Unused (holds context about name group)

  NameCandidate - Specifies name to validate

Return Value:

  TRUE if the name is valid, FALSE otherwise.

--*/

{
    BOOL b;
    //PNAME_GROUP_CONTEXT UserContext;

    //UserContext = pGetNameGroupContextById (MSG_USERNAME_CATEGORY);

    //if (pDoesNameExistInMemDb (UserContext, NameCandidate)) {
    //    return FALSE;
    //}

    b = pValidateNetName (
            Context,
            NameCandidate,
            FALSE,
            FALSE,
            MAX_COMPUTER_NAME,
            NULL
            );

    return b;
}


BOOL
pValidateWorkgroup (
    IN      PNAME_GROUP_CONTEXT Context,
    IN      PCTSTR NameCandidate
    )

/*++

Routine Description:

  pValidateWorkgroup makes sure the specified name is not
  empty, is not longer than 15 characters, and consists only
  of characters legal for a computer name.

  If domain logon is enabled, this routine always returns
  TRUE.

Arguments:

  Context - Unused (holds context about name group)

  NameCandidate - Specifies name to validate

Return Value:

  TRUE if the name is valid, FALSE otherwise.

--*/

{
    PNAME_GROUP_CONTEXT DomainContext;

    //
    // Return TRUE if domain is enabled
    //

    DomainContext = pGetNameGroupContextById (MSG_COMPUTERDOMAIN_CATEGORY);

    if (DomainContext && DomainContext->DomainLogonEnabled) {
        return TRUE;
    }

    //
    // A workgroup name is a domain name, but spaces are allowed.
    //

    return pValidateNetName (Context, NameCandidate, TRUE, FALSE, DNLEN, NULL);
}


BOOL
pValidateUserName (
    IN      PNAME_GROUP_CONTEXT Context,
    IN      PCTSTR NameCandidate
    )

/*++

Routine Description:

  pValidateUserName makes sure the specified name is not empty,
  is not longer than 20 characters, consists  only of characters
  legal for a user name, and does not exist in memdb's NewName
  or InUseName categories.

Arguments:

  Context - Specifies context info for the UserName name group,
            used for memdb operations.

  NameCandidate - Specifies name to validate

Return Value:

  TRUE if the name is valid, FALSE otherwise.

--*/

{
    BOOL b;

    //
    // Validate name
    //

    b = pValidateNetName (Context, NameCandidate, TRUE, TRUE, min (MAX_USER_NAME, MIN_UNLEN), NULL);

    if (!b && Context->FailureMsg == MSG_INVALID_COMPUTERNAME_LENGTH_POPUP) {
        Context->FailureMsg = MSG_INVALID_USERNAME_LENGTH_POPUP;
    }

    if (!b) {
        return FALSE;
    }

    //
    // Check for existence in memdb
    //

    if (pDoesNameExistInMemDb (Context, NameCandidate)) {
        Context->FailureMsg = MSG_INVALID_USERNAME_DUPLICATE_POPUP;
        return FALSE;
    }

    return TRUE;
}


BOOL
pValidateComputerDomain (
    IN      PNAME_GROUP_CONTEXT Context,
    IN      PCTSTR NameCandidate
    )

/*++

Routine Description:

  pValidateComputerDomain performs the same validatation that
  pValidateComputerName performs.  Therefore, it simply calls
  pValidateComputerName.

  If the name comes from the registry, and not the user interface, then we
  check to see if the workgroup name actually refers to a domain controller.
  If it does, the name is returned as valid; otherwise, the name is returned
  as invalid, even though it may consist of valid characters.

  If the name comes from the user interface, we assume the UI code will do
  the validation to see if the name is an actual server.  This allows the UI
  to override the API, because the API may not work properly on all networks.

Arguments:

  Context - Specifies context of the ComputerDomain name group. In particular,
            the FromUserInterface member tells us to ignore validation of the
            domain name via the NetServerGetInfo API.

  NameCandidate - Specifies domain name to validate

Return Value:

  TRUE if the domain name is legal, or FALSE if it is not.

--*/

{
    TCHAR NewComputerName[MAX_COMPUTER_NAME];

    if (!pValidateNetName (Context, NameCandidate, FALSE, FALSE, DNLEN, NULL)) {
        return FALSE;
    }

    if (!Context->FromUserInterface) {
        if (GetUpgradeComputerName (NewComputerName)) {
            // 1 == account was found, 0 == account does not exist, -1 == no response
            if (1 != DoesComputerAccountExistOnDomain (
                        NameCandidate,
                        NewComputerName,
                        TRUE
                        )) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
pCleanUpNetName (
    IN      PNAME_GROUP_CONTEXT Context,
    IN OUT  PTSTR Name,
    IN      UINT NameType
    )

/*++

Routine Description:

  pCleanUpNetName eliminates all characters that are invalid from the
  specified name.

  NOTE: We could add some smarts here, such as translation of
        spaces to dashes, and so on.

Arguments:

  Context - Unused; passed along to pValidateComputerName.

  Name - Specifies the name containing potentially invalid characters.
         Receives the name with all invalid characters removed.

  NameType - Specifies the type of name to clean up

Return Value:

  TRUE if the resulting name is valid, or FALSE if the resulting
  name is still not valid.

--*/

{
    TCHAR TempBuf[MAX_COMPUTER_NAME];
    PTSTR p;
    PTSTR q;
    UINT Len;
    BOOL b;

    //
    // Delete all the invalid characters
    //

    _tcssafecpy (TempBuf, Name, MAX_COMPUTER_NAME);

    for (;;) {
        p = NULL;
        b = FALSE;

        switch (NameType) {
        case MSG_COMPUTERNAME_CATEGORY:
            b = pValidateNetName (Context, TempBuf, TRUE, FALSE, MAX_COMPUTER_NAME, &p);
            break;

        case MSG_WORKGROUP_CATEGORY:
            b = pValidateNetName (Context, TempBuf, TRUE, FALSE, DNLEN, &p);
            break;

        case MSG_COMPUTERDOMAIN_CATEGORY:
            b = pValidateNetName (Context, TempBuf, FALSE, FALSE, DNLEN, &p);
            break;

        case MSG_USERNAME_CATEGORY:
            b = pValidateNetName (Context, TempBuf, TRUE, TRUE, MIN_UNLEN, &p);
            break;
        }

        if (b || !p) {
            break;
        }

        q = _tcsinc (p);
        Len = ByteCount (q) + sizeof (TCHAR);
        MoveMemory (p, q, Len);
    }

    if (b) {
        //
        // Do not allow names that contain a lot of invalid characters
        //

        if (CharCount (Name) - 3 > CharCount (TempBuf)) {
            b = FALSE;
        }
    }

    if (!b) {
        // Empty out recommended name
        *Name = 0;
    }

    if (b) {

        StringCopy (Name, TempBuf);

        switch (NameType) {
        case MSG_COMPUTERNAME_CATEGORY:
            b = pValidateComputerName (Context, Name);
            break;

        case MSG_WORKGROUP_CATEGORY:
            b = pValidateWorkgroup (Context, Name);
            break;

        case MSG_COMPUTERDOMAIN_CATEGORY:
            b = pValidateComputerDomain (Context, Name);
            break;

        case MSG_USERNAME_CATEGORY:
            b = pValidateUserName (Context, Name);
            break;

        }
    }

    return b;
}


VOID
pRecommendComputerName (
    IN      PNAME_GROUP_CONTEXT Context,
    IN      PCTSTR InvalidName,
    OUT     PTSTR RecommendedName
    )

/*++

Routine Description:

  pRecommendComputerName obtains the current user's name and
  returns it for use as a computer name.  If the user's name
  has characters that cannot be used in a computer name,
  the invalid characters are removed.  If the name is still
  invalid, then a static string is returned.

Arguments:

  Context - Unused (holds context about name group)

  InvalidName - Specifies the current invalid name, or an empty
                string if no name exists.

  RecommendedName - Receives the recommended name.

Return Value:

  none

--*/

{
    DWORD Size;
    PCTSTR p;
    PCTSTR ArgArray[1];

    //
    // Try to clean up the invalid name
    //

    if (*InvalidName) {
        _tcssafecpy (RecommendedName, InvalidName, MAX_COMPUTER_NAME);
        if (pCleanUpNetName (Context, RecommendedName, MSG_COMPUTERNAME_CATEGORY)) {
            return;
        }
    }

    //
    // Generate a suggestion from the user name
    //

    Size = MAX_COMPUTER_NAME;
    if (!GetUserName (RecommendedName, &Size)) {
        *RecommendedName = 0;
    } else {
        CharUpper (RecommendedName);

        ArgArray[0] = RecommendedName;
        p = ParseMessageID (MSG_COMPUTER_REPLACEMENT_NAME, ArgArray);
        MYASSERT (p);

        if (p) {

            _tcssafecpy (RecommendedName, p, MAX_COMPUTER_NAME);
            FreeStringResource (p);
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "Failed to parse message resource for MSG_COMPUTER_REPLACEMENT_NAME. Check localization."));
    }

    //
    // Try to clean up invalid computer name chars in user name
    //

    if (pCleanUpNetName (Context, RecommendedName, MSG_COMPUTERNAME_CATEGORY)) {
        return;
    }

    //
    // All else has failed; obtain static computer name string
    //

    p = GetStringResource (MSG_RECOMMENDED_COMPUTER_NAME);
    MYASSERT (p);
    if (p) {
        StringCopy (RecommendedName, p);
        FreeStringResource (p);
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "Failed to parse message resource for MSG_RECOMMENDED_COMPUTER_NAME. Check localization."));
}


VOID
pRecommendWorkgroup (
    IN      PNAME_GROUP_CONTEXT Context,
    IN      PCTSTR InvalidName,
    OUT     PTSTR RecommendedName
    )

/*++

Routine Description:

  pRecommendWorkgroupName tries to clean up the invalid workgroup name, and
  only if necessary recommends the name Workgroup.

Arguments:

  Context - Unused (holds context about name group)

  InvalidName - Specifies the current invalid name, or an empty
                string if no name exists.

  RecommendedName - Receives the recommended name.

Return Value:

  none

--*/

{
    PCTSTR p;

    //
    // Try to clean up the invalid name
    //

    if (*InvalidName) {
        _tcssafecpy (RecommendedName, InvalidName, MAX_COMPUTER_NAME);
        if (pCleanUpNetName (Context, RecommendedName, MSG_WORKGROUP_CATEGORY)) {
            return;
        }
    }

    //
    // All else has failed; obtain static workgroup string
    //

    p = GetStringResource (MSG_RECOMMENDED_WORKGROUP_NAME);
    MYASSERT (p);
    StringCopy (RecommendedName, p);
    FreeStringResource (p);
}


VOID
pRecommendUserName (
    IN      PNAME_GROUP_CONTEXT Context,
    IN      PCTSTR InvalidName,
    OUT     PTSTR RecommendedName
    )

/*++

Routine Description:

  pRecommendUserName tries to clean up the specified invalid
  user name.  If that fails, this routine generates a
  generic user name (such as Windows User).  If the generic
  name is not valid, numbers are appended until a unique,
  valid name is found.

Arguments:

  Context - Specifies settings for the UserName name group context,
            including the group name itself.  This context is used
            in memdb operations to validate the name.

  InvalidName - Specifies the current invalid name, or an empty
                string if no name exists.

  RecommendedName - Receives the recommended name.

Return Value:

  none

--*/

{
    PCTSTR p;
    UINT Sequencer;

    //
    // Attempt to clean out invalid characters from the user
    // name.
    //

    _tcssafecpy (RecommendedName, InvalidName, MAX_USER_NAME);

    if (pCleanUpNetName (Context, RecommendedName, MSG_USERNAME_CATEGORY)) {
        return;
    }

    //
    // If there are some characters left, and there is room for
    // a sequencer, just add the sequencer.
    //

    if (*RecommendedName) {
        p = DuplicateText (RecommendedName);
        MYASSERT (p);

        for (Sequencer = 1 ; Sequencer < 10 ; Sequencer++) {
            wsprintf (RecommendedName, TEXT("%s-%u"), p, Sequencer);
            if (pValidateUserName (Context, RecommendedName)) {
                break;
            }
        }

        FreeText (p);
        if (Sequencer < 10) {
            return;
        }
    }

    //
    // Obtain a generic name
    //

    p = GetStringResource (MSG_RECOMMENDED_USER_NAME);
    MYASSERT (p);

    if (p) {

        __try {
            if (pValidateUserName (Context, p)) {
                StringCopy (RecommendedName, p);
            } else {

                for (Sequencer = 2 ; Sequencer < 100000 ; Sequencer++) {
                    wsprintf (RecommendedName, TEXT("%s %u"), p, Sequencer);
                    if (pValidateUserName (Context, RecommendedName)) {
                        break;
                    }
                }

                if (Sequencer == 100000) {
                    LOG ((LOG_ERROR, "Sequencer hit %u", Sequencer));
                }
            }
        }
        __finally {
            FreeStringResource (p);
        }
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "Could not retrieve string resource MSG_RECOMMENDED_USER_NAME. Check localization."));
}


VOID
pRecommendComputerDomain (
    IN      PNAME_GROUP_CONTEXT Context,
    IN      PCTSTR InvalidName,
    OUT     PTSTR RecommendedName
    )

/*++

Routine Description:

  pRecommendComputerDomain returns the value of AuthenticatingAgent
  stored in the Context structure by pEnumComputerDomain.

Arguments:

  Context - Specifies the name group context structure, which holds
            the computer domain found by pEnumComputerDomain.

  InvalidName - Specifies the current invalid name, or an empty
                string if no name exists.

  RecommendedName - Receives the recommended name.

Return Value:

  none

--*/

{
    StringCopy (RecommendedName, Context->AuthenticatingAgent);
}


BOOL
ValidateName (
    IN      HWND ParentWnd,             OPTIONAL
    IN      PCTSTR NameGroup,
    IN      PCTSTR NameCandidate
    )

/*++

Routine Description:

  ValidateName is called by the UI to perform validation on the
  specified name.

Arguments:

  ParentWnd - Specifies the handle used for popups that tell the user
              what is wrong with the name they entered.  If NULL, no
              UI is generated.

  NameGroup - Specifies the name group, a static string that defines
              what characters are legal for the name.

  NameCandidate - Specifies the name to validate

Return Value:

  TRUE if the name is valid, or FALSE if it is not valid.

--*/

{
    INT i;
    BOOL b;

    //
    // Scan the g_NameGroupRoutines array for the name grup
    //

    for (i = 0 ; g_NameGroupRoutines[i].GroupName ; i++) {
        if (StringIMatch (g_NameGroupRoutines[i].GroupName, NameGroup)) {
            break;
        }
    }

    if (!g_NameGroupRoutines[i].GroupName) {
        DEBUGMSG ((DBG_WHOOPS, "ValidateName: Don't know how to validate %s names", NameGroup));
        LOG ((LOG_ERROR, "Don't know how to validate %s names", NameGroup));
        return TRUE;
    }

    g_NameGroupRoutines[i].Context.FromUserInterface = TRUE;

    b = g_NameGroupRoutines[i].Validate (&g_NameGroupRoutines[i].Context, NameCandidate);

    if (!b && ParentWnd) {
        OkBox (ParentWnd, g_NameGroupRoutines[i].Context.FailureMsg);
    }

    g_NameGroupRoutines[i].Context.FromUserInterface = FALSE;

    return b;
}


BOOL
pDoesNameExistInMemDb (
    IN      PNAME_GROUP_CONTEXT Context,
    IN      PCTSTR Name
    )

/*++

Routine Description:

  pDoesUserExistInMemDb looks in memdb to see if the specified name
  is listed in either the NewNames category (incompatible names that
  are going to be changed), or the InUseNames category (compatible
  names that cannot be used more than once).

  This routine compares only names in the same name group.

Arguments:

  Context - Specifies the group context

  Name - Specifies the name to query

Return Value:

  TRUE if the name is in use, or FALSE if the name is not in use.

--*/

{
    TCHAR Node[MEMDB_MAX];

    DEBUGMSG ((DBG_NAMEFIX, "%s: [%s] is compatible", Context->GroupName, Name));

    MemDbBuildKey (
        Node,
        MEMDB_CATEGORY_NEWNAMES,
        Context->GroupName,
        MEMDB_FIELD_NEW,
        Name
        );

    if (MemDbGetValue (Node, NULL)) {
        return TRUE;
    }

    MemDbBuildKey (
        Node,
        MEMDB_CATEGORY_INUSENAMES,
        Context->GroupName,
        NULL,
        Name
        );

    return MemDbGetValue (Node, NULL);
}


VOID
pMemDbSetIncompatibleName (
    IN      PCTSTR NameGroup,
    IN      PCTSTR OrgName,
    IN      PCTSTR NewName
    )

/*++

Routine Description:

  pMemDbSetIncompatibleName adds the correct entries to memdb to
  have a name appear in the name collision wizard page.

Arguments:

  NameGroup - Specifies the name group such as ComputerName, UserName, etc...

  OrgName - Specifies the original name that is invalid

  NewName - Specifies the recommended new name

Return Value:

  none

--*/

{
    DWORD NewNameOffset;

    DEBUGMSG ((DBG_NAMEFIX, "%s: [%s]->[%s]", NameGroup, OrgName, NewName));

    MemDbSetValueEx (
        MEMDB_CATEGORY_NEWNAMES,
        NameGroup,
        NULL,
        NULL,
        0,
        NULL
        );

    MemDbSetValueEx (
        MEMDB_CATEGORY_NEWNAMES,
        NameGroup,
        MEMDB_FIELD_NEW,
        NewName,
        0,
        &NewNameOffset
        );

    MemDbSetValueEx (
        MEMDB_CATEGORY_NEWNAMES,
        NameGroup,
        MEMDB_FIELD_OLD,
        OrgName,
        NewNameOffset,
        NULL
        );
}


VOID
pMemDbSetCompatibleName (
    IN      PCTSTR NameGroup,
    IN      PCTSTR Name
    )

/*++

Routine Description:

  pMemDbSetCompatibleName creates the memdb entries necessary
  to store names that are in use and are compatible.

Arguments:

  NameGroup - Specifies the name group such as ComputerName, UserName, etc...

  Name - Specifies the compatible name

Return Value:

  none

--*/

{
    MemDbSetValueEx (
        MEMDB_CATEGORY_INUSENAMES,
        NameGroup,
        NULL,
        Name,
        0,
        NULL
        );
}


VOID
CreateNameTables (
    VOID
    )

/*++

Routine Description:

  CreateNameTables finds all names on the computer and puts valid names
  into the InUseNames memdb category, and invalid names into the NewNames
  memdb category (including both the invalid name and recommended name).
  A wizard page appears if invalid names are found on the system.

Arguments:

  none

Return Value:

  none

--*/

{
    INT i;
    NAME_ENUM e;
    PNAME_GROUP_ROUTINES Group;
    TCHAR RecommendedName[MAX_NAME];
    PTSTR p;
    PTSTR DupList;
    static BOOL AlreadyDone = FALSE;

    if (AlreadyDone) {
        return;
    }

    AlreadyDone = TRUE;
    TurnOnWaitCursor();

    //
    // Special case: Add NT group names to InUse list
    //

    p = (PTSTR) GetStringResource (
                    *g_ProductFlavor == PERSONAL_PRODUCTTYPE ?
                        MSG_NAME_COLLISION_LIST_PER :
                        MSG_NAME_COLLISION_LIST
                    );
    MYASSERT (p);

    if (p) {
        DupList = DuplicateText (p);
        MYASSERT (DupList);
        FreeStringResource (p);

        p = _tcschr (DupList, TEXT('|'));
        while (p) {
            *p = 0;
            p = _tcschr (_tcsinc (p), TEXT('|'));
        }

        Group = pGetNameGroupById (MSG_USERNAME_CATEGORY);
        MYASSERT (Group);

        if (Group) {

            p = DupList;
            while (*p) {
                pMemDbSetCompatibleName (
                    Group->GroupName,
                    p
                    );

                p = GetEndOfString (p) + 1;
            }
        }

        FreeText (DupList);
    }

    //
    // General case: Enumerate all names, call Validate and add them to memdb
    //

    for (i = 0 ; g_NameGroupRoutines[i].GroupName ; i++) {

        Group = &g_NameGroupRoutines[i];

        //
        // Initialize the context structure
        //

        ZeroMemory (&Group->Context, sizeof (NAME_GROUP_CONTEXT));
        Group->Context.GroupName = Group->GroupName;

        //
        // Call the enum entry point
        //

        ZeroMemory (&e, sizeof (e));
        if (Group->Enum (&Group->Context, &e, TRUE)) {
            do {
                //
                // Determine if this name is valid.  If it is valid, add it to the
                // InUseNames memdb category.  If it is not valid, get a recommended
                // replacement name, and store the incompatible and recommended
                // names in the NewNames memdb category.
                //

#ifdef TEST_MANGLE_NAMES
                StringCat (e.Name, TEXT("\"%foo"));
#endif

#ifdef TEST_ALL_INCOMPATIBLE

                if (0) {

#else

                if (Group->Validate (&Group->Context, e.Name)) {

#endif

                    pMemDbSetCompatibleName (
                        Group->GroupName,
                        e.Name
                        );

                } else {
                    Group->Recommend (&Group->Context, e.Name, RecommendedName);

                    pMemDbSetIncompatibleName (
                        Group->GroupName,
                        e.Name,
                        RecommendedName
                        );
                }

            } while (Group->Enum (&Group->Context, &e, FALSE));
        }
    }

    TurnOffWaitCursor();
}


BOOL
IsIncompatibleNamesTableEmpty (
    VOID
    )

/*++

Routine Description:

  IsIncompatibleNamesTableEmpty looks at memdb to see if there are any
  names in the NewNames category.  This function is used to determine
  if the name collision wizard page should appear.

Arguments:

  none

Return Value:

  TRUE if at least one name is invalid, or FALSE if all names are valid.

--*/

{
    INVALID_NAME_ENUM e;

    return !EnumFirstInvalidName (&e);
}


BOOL
pEnumInvalidNameWorker (
    IN OUT  PINVALID_NAME_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumInvalidNameWorker implements a state machine for invalid
  name enumeration.  It returns the group name, original name
  and new name to the caller.

Arguments:

  EnumPtr - Specifies the enumeration in progress; receives the
            updated fields

Return Value:

  TRUE if an item was enumerated, or FALSE if no more items exist.

--*/

{
    PCTSTR p;
    INT i;

    while (EnumPtr->State != ENUM_STATE_DONE) {

        switch (EnumPtr->State) {

        case ENUM_STATE_INIT:
            if (!MemDbEnumItems (&EnumPtr->NameGroup, MEMDB_CATEGORY_NEWNAMES)) {
                EnumPtr->State = ENUM_STATE_DONE;
            } else {
                EnumPtr->State = ENUM_STATE_ENUM_FIRST_GROUP_ITEM;
            }
            break;

        case ENUM_STATE_ENUM_FIRST_GROUP_ITEM:
            if (!MemDbGetValueEx (
                    &EnumPtr->Name,
                    MEMDB_CATEGORY_NEWNAMES,
                    EnumPtr->NameGroup.szName,
                    MEMDB_FIELD_OLD
                    )) {
                EnumPtr->State = ENUM_STATE_ENUM_NEXT_GROUP;
            } else {
                EnumPtr->State = ENUM_STATE_RETURN_GROUP_ITEM;
            }
            break;

        case ENUM_STATE_RETURN_GROUP_ITEM:
            //
            // Get the group name
            //

            EnumPtr->GroupName = EnumPtr->NameGroup.szName;

            //
            // Get the display group name from the message resources
            //

            for (i = 0 ; g_NameGroupRoutines[i].GroupName ; i++) {
                if (StringMatch (g_NameGroupRoutines[i].GroupName, EnumPtr->GroupName)) {
                    break;
                }
            }

            MYASSERT (g_NameGroupRoutines[i].GroupName);

            if (g_NameGroupRoutines[i].NameId == MSG_COMPUTERDOMAIN_CATEGORY) {
                EnumPtr->State = ENUM_STATE_ENUM_NEXT_GROUP_ITEM;
                break;
            }

            p = GetStringResource (g_NameGroupRoutines[i].NameId);
            MYASSERT (p);
            if (p) {
                _tcssafecpy (EnumPtr->DisplayGroupName, p, (sizeof (EnumPtr->DisplayGroupName) / 2) / sizeof (TCHAR));
                FreeStringResource (p);
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Unable to get string resource. Check localization."));

            //
            // Get EnumPtr->NewName and  EnumPtr->Identifier
            //

            EnumPtr->OriginalName = EnumPtr->Name.szName;

            MemDbBuildKeyFromOffset (
                EnumPtr->Name.dwValue,
                EnumPtr->NewName,
                3,
                NULL
                );

            MemDbGetOffsetEx (
                MEMDB_CATEGORY_NEWNAMES,
                EnumPtr->GroupName,
                MEMDB_FIELD_OLD,
                EnumPtr->OriginalName,
                &EnumPtr->Identifier
                );

            EnumPtr->State = ENUM_STATE_ENUM_NEXT_GROUP_ITEM;
            return TRUE;

        case ENUM_STATE_ENUM_NEXT_GROUP_ITEM:
            if (!MemDbEnumNextValue (&EnumPtr->Name)) {
                EnumPtr->State = ENUM_STATE_ENUM_NEXT_GROUP;
            } else {
                EnumPtr->State = ENUM_STATE_RETURN_GROUP_ITEM;
            }
            break;

        case ENUM_STATE_ENUM_NEXT_GROUP:
            if (!MemDbEnumNextValue (&EnumPtr->NameGroup)) {
                EnumPtr->State = ENUM_STATE_DONE;
            } else {
                EnumPtr->State = ENUM_STATE_ENUM_FIRST_GROUP_ITEM;
            }
            break;
        }
    }

    return FALSE;
}


BOOL
EnumFirstInvalidName (
    OUT     PINVALID_NAME_ENUM EnumPtr
    )

/*++

Routine Description:

  EnumFirstInvalidName enumerates the first entry in the memdb NewNames
  category.  The caller receives the name group, the old name and
  the new name.

Arguments:

  none

Return Value:

  TRUE if at least one name is invalid, or FALSE if all names are valid.

--*/

{
    EnumPtr->State = ENUM_STATE_INIT;
    return pEnumInvalidNameWorker (EnumPtr);
}


BOOL
EnumNextInvalidName (
    IN OUT  PINVALID_NAME_ENUM EnumPtr
    )

/*++

Routine Description:

  EnumNextInvalidName enumerates the first entry in the memdb NewNames
  category.  The caller receives the name group, the old name and
  the new name.

Arguments:

  none

Return Value:

  TRUE if another invalid name is available, or FALSE if no more names
  can be enumerated.

--*/

{
    return pEnumInvalidNameWorker (EnumPtr);
}


VOID
GetNamesFromIdentifier (
    IN      DWORD Identifier,
    IN      PTSTR NameGroup,        OPTIONAL
    IN      PTSTR OriginalName,     OPTIONAL
    IN      PTSTR NewName           OPTIONAL
    )

/*++

Routine Description:

  GetNamesFromIdentifier copies names to caller-specified buffers, given a
  unique identifier (a memdb offset).  The unique identifer is provided
  by enumeration functions.

Arguments:

  Identifier   - Specifies the identifier of the name.
  NameGroup    - Receives the text for the name group.
  OriginalName - Receivies the original name.
  NewName      - Receives the fixed name that is compatible with NT.

Return Value:

  none

--*/

{
    BOOL b;
    PTSTR p;
    TCHAR NameGroupTemp[MEMDB_MAX];
    TCHAR OrgNameTemp[MEMDB_MAX];
    DWORD NewNameOffset;

    if (NameGroup) {
        *NameGroup = 0;
    }

    if (OriginalName) {
        *OriginalName = 0;
    }

    if (NewName) {
        *NewName = 0;
    }

    //
    // Get NameGroup
    //

    if (!MemDbBuildKeyFromOffset (Identifier, NameGroupTemp, 1, NULL)) {
        return;
    }

    p = _tcschr (NameGroupTemp, TEXT('\\'));
    MYASSERT (p);
    *p = 0;

    if (NameGroup) {
        StringCopy (NameGroup, NameGroupTemp);
    }

    //
    // Get OrgName and NewNameOffset.
    //
    b = MemDbBuildKeyFromOffset (Identifier, OrgNameTemp, 3, &NewNameOffset);

    if (OriginalName) {
        StringCopy (OriginalName, OrgNameTemp);
    }

    //
    // Get NewName
    //

    if (NewName) {
        b &= MemDbBuildKeyFromOffset (NewNameOffset, NewName, 3, NULL);
    }

    MYASSERT (b);

}


VOID
ChangeName (
    IN      DWORD Identifier,
    IN      PCTSTR NewName
    )

/*++

Routine Description:

  ChangeName puts a new name value in memdb for the name indicated by
  Identifier.  The Identifier comes from enum functions.

Arguments:

  Identifier - Specifies the name identifier (a memdb offset), and cannot be
               zero.
  NewName    - Specifies the NT-compatible replacement name.

Return Value:

  none

--*/

{
    TCHAR Node[MEMDB_MAX];
    TCHAR NameGroup[MEMDB_MAX];
    TCHAR OrgName[MEMDB_MAX];
    DWORD NewNameOffset;
    PTSTR p, q;
    BOOL b;

    MYASSERT (Identifier);

    if (!Identifier) {
        return;
    }

    //
    // - Obtain the original name
    // - Get the offset to the current new name
    // - Build the full key to the current new name
    // - Delete the current new name
    //

    if (!MemDbBuildKeyFromOffset (Identifier, OrgName, 3, &NewNameOffset)) {
        DEBUGMSG ((DBG_WHOOPS, "Can't obtain original name using offset %u", Identifier));
        LOG ((LOG_ERROR, "Can't obtain original name using offset %u", Identifier));
        return;
    }

    if (!MemDbBuildKeyFromOffset (NewNameOffset, Node, 0, NULL)) {
        DEBUGMSG ((DBG_WHOOPS, "Can't obtain new name key using offset %u", NewNameOffset));
        LOG ((LOG_ERROR, "Can't obtain new name key using offset %u", NewNameOffset));
        return;
    }

    MemDbDeleteValue (Node);

    //
    // Obtain the name group from the key string.  It's the second
    // field (separated by backslashes).
    //

    p = _tcschr (Node, TEXT('\\'));
    MYASSERT (p);
    p = _tcsinc (p);

    q = _tcschr (p, TEXT('\\'));
    MYASSERT (q);

    StringCopyAB (NameGroup, p, q);

    //
    // Now set the updated new name, and link the original name
    // to the new name.
    //

    b = MemDbSetValueEx (
             MEMDB_CATEGORY_NEWNAMES,
             NameGroup,
             MEMDB_FIELD_NEW,
             NewName,
             0,
             &NewNameOffset
             );

    b &= MemDbSetValueEx (
             MEMDB_CATEGORY_NEWNAMES,
             NameGroup,
             MEMDB_FIELD_OLD,
             OrgName,
             NewNameOffset,
             NULL
             );

    if (!b) {
        LOG ((LOG_ERROR, "Failure while attempting to change %s name to %s.",OrgName,NewName));
    }
}


BOOL
GetUpgradeComputerName (
    OUT     PTSTR NewName
    )

/*++

Routine Description:

  GetUpgradeComputerName obtains the computer name that will be used for
  upgrade.

Arguments:

  NewName - Receives the name of the computer, as it will be set
            when NT is installed.  Must hold at least
            MAX_COMPUTER_NAME characters.

Return Value:

  TRUE if the name exists, or FALSE if it does not yet exit.

--*/

{
    PNAME_GROUP_ROUTINES Group;
    NAME_ENUM e;

    Group = pGetNameGroupById (MSG_COMPUTERNAME_CATEGORY);
    MYASSERT (Group);
    if (!Group)
        return FALSE;

    //
    // Look in MemDb for a replacement name
    //

    if (MemDbGetEndpointValueEx (
            MEMDB_CATEGORY_NEWNAMES,
            Group->GroupName,
            MEMDB_FIELD_NEW,
            NewName
            )) {
        return TRUE;
    }

    //
    // No replacement name; obtain the current name
    //

    ZeroMemory (&e, sizeof (e));
    if (Group->Enum (&Group->Context, &e, TRUE)) {
        StringCopy (NewName, e.Name);

        while (Group->Enum (&Group->Context, &e, FALSE)) {
            // empty
        }

        return TRUE;
    }

    return FALSE;
}


DWORD
GetDomainIdentifier (
    VOID
    )

/*++

Routine Description:

  GetDomainIdentifier returns the identifier for the domain name.  The
  identifier is a memdb offset.

Arguments:

  None.

Return Value:

  A non-zero identifier which can be used with other routines in this file.

--*/

{
    PNAME_GROUP_ROUTINES Group;
    MEMDB_ENUM e;
    DWORD Identifier = 0;

    Group = pGetNameGroupById (MSG_COMPUTERDOMAIN_CATEGORY);
    MYASSERT (Group);

    if (Group && MemDbGetValueEx (
            &e,
            MEMDB_CATEGORY_NEWNAMES,
            Group->GroupName,
            MEMDB_FIELD_OLD
            )) {

        MemDbGetOffsetEx (
            MEMDB_CATEGORY_NEWNAMES,
            Group->GroupName,
            MEMDB_FIELD_OLD,
            e.szName,
            &Identifier
            );
    }

    return Identifier;
}


BOOL
pGetUpgradeName (
    IN      UINT CategoryId,
    OUT     PTSTR NewName
    )

/*++

Routine Description:

  pGetUpgradeName returns the NT-compatible name for a given name group.  If
  a name group has multiple names, this routine should not be used.

Arguments:

  CategoryId - Specifies the MSG_* constant for the group (see macro
               expansion list at top of file).
  NewName    - Receives the text for the NT-compatible replacement name for
               the group.

Return Value:

  TRUE if a name is being returned, or FALSE if no replacement name exists.

--*/

{
    PNAME_GROUP_ROUTINES Group;
    NAME_ENUM e;

    Group = pGetNameGroupById (CategoryId);
    MYASSERT (Group);
    if (!Group)
        return FALSE;

    //
    // Look in MemDb for a replacement name
    //

    if (MemDbGetEndpointValueEx (
            MEMDB_CATEGORY_NEWNAMES,
            Group->GroupName,
            MEMDB_FIELD_NEW,
            NewName
            )) {
        return TRUE;
    }

    //
    // No replacement name; obtain the current name
    //

    ZeroMemory (&e, sizeof (e));
    if (Group->Enum (&Group->Context, &e, TRUE)) {
        StringCopy (NewName, e.Name);

        while (Group->Enum (&Group->Context, &e, FALSE)) {
            // empty
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
GetUpgradeDomainName (
    OUT     PTSTR NewName
    )

/*++

Routine Description:

  GetUpgradeDomainName returns the new domain name, if one exists.

Arguments:

  NewName - Receiveis the new domain name.

Return Value:

  TRUE if a new name is being returned, or FALSE if no replacement name
  exists.

--*/

{
    return pGetUpgradeName (
                MSG_COMPUTERDOMAIN_CATEGORY,
                NewName
                );
}


BOOL
GetUpgradeWorkgroupName (
    OUT     PTSTR NewName
    )

/*++

Routine Description:

  GetUpgradeWorkgroupName returns the new workgroup name, if one exists.

Arguments:

  None.

Return Value:

  TRUE if a new name is being returned, or FALSE if no replacement name
  exists.

--*/

{
    return pGetUpgradeName (
                MSG_WORKGROUP_CATEGORY,
                NewName
                );
}


BOOL
GetUpgradeUserName (
    IN      PCTSTR User,
    OUT     PTSTR NewUserName
    )

/*++

Routine Description:

  GetUpgradeUserName returns the fixed user name for the user specified.  If
  no fixed name exists, this routine returns the original name.

Arguments:

  User        - Specifies the user to look up.  The user name must exist on
                the Win9x configuration.
  NewUserName - Receives the NT-compatible user name, which may or may not be
                the same as User.

Return Value:

  Always TRUE.

--*/

{
    PNAME_GROUP_ROUTINES Group;
    TCHAR Node[MEMDB_MAX];
    DWORD NewOffset;

    Group = pGetNameGroupById (MSG_USERNAME_CATEGORY);
    MYASSERT (Group);

    //
    // Look in MemDb for a replacement name
    //
    if (Group) {
        MemDbBuildKey (
            Node,
            MEMDB_CATEGORY_NEWNAMES,
            Group->GroupName,
            MEMDB_FIELD_OLD,
            User
            );

        if (MemDbGetValue (Node, &NewOffset)) {
            if (MemDbBuildKeyFromOffset (NewOffset, NewUserName, 3, NULL)) {
                return TRUE;
            }
        }
    }

    //
    // No replacement name; use the current name
    //

    StringCopy (NewUserName, User);

    return TRUE;
}


BOOL
WarnAboutBadNames (
    IN      HWND PopupParent
    )

/*++

Routine Description:

  WarnAboutBadNames adds an incompatibility message whenever domain
  logon is enabled but there is no account set up for the machine.  A popup
  is generated if PopupParent is non-NULL.

  Other incompatibility messages are added for each name that will change.

Arguments:

  Popup - Specifies TRUE if the message should appear in a message box, or
          FALSE if it should be added to the incompatibility report.

Return Value:

  TRUE if the user wants to continue, or FALSE if the user wants to change
  the domain name.

--*/

{
    PCTSTR RootGroup;
    PCTSTR NameSubGroup;
    PCTSTR FullGroupName;
    PCTSTR BaseGroup;
    PNAME_GROUP_CONTEXT Context;
    PCTSTR ArgArray[3];
    INVALID_NAME_ENUM e;
    BOOL b = TRUE;
    TCHAR EncodedName[MEMDB_MAX];
    PCTSTR Blank;

    if (PopupParent) {
        //
        // PopupParent is non-NULL only when the incompatible names wizard page
        // is being deactivated.  Here we have a chance to make sure the names
        // specified all work together before proceeding.
        //
        // This functionality has been disabled because domain validation has
        // been moved to a new page.  We might re-enable this when another
        // invalid name group comes along.
        //
        return TRUE;
    }

    //
    // Enumerate all bad names
    //

    if (EnumFirstInvalidName (&e)) {
        Blank = GetStringResource (MSG_BLANK_NAME);
        MYASSERT (Blank);

        do {
            //
            // Prepare message
            //

            ArgArray[0] = e.DisplayGroupName;
            ArgArray[1] = e.OriginalName;
            ArgArray[2] = e.NewName;

            if (ArgArray[1][0] == 0) {
                ArgArray[1] = Blank;
            }

            if (ArgArray[2][0] == 0) {
                ArgArray[2] = Blank;
            }

            RootGroup = GetStringResource (MSG_INSTALL_NOTES_ROOT);
            MYASSERT (RootGroup);

            NameSubGroup = ParseMessageID (MSG_NAMECHANGE_WARNING_GROUP, ArgArray);
            MYASSERT (NameSubGroup);

            BaseGroup = JoinPaths (RootGroup, NameSubGroup);
            MYASSERT (BaseGroup);

            FreeStringResource (RootGroup);
            FreeStringResource (NameSubGroup);

            NameSubGroup = ParseMessageID (MSG_NAMECHANGE_WARNING_SUBCOMPONENT, ArgArray);
            MYASSERT (NameSubGroup);

            FullGroupName = JoinPaths (BaseGroup, NameSubGroup);
            MYASSERT (FullGroupName);

            FreePathString (BaseGroup);
            FreeStringResource (NameSubGroup);

            EncodedName[0] = TEXT('|');
            StringCopy (EncodedName + 1, e.OriginalName);

            MsgMgr_ObjectMsg_Add(
                EncodedName,        // Object name, prefixed with a pipe symbol
                FullGroupName,      // Message title
                S_EMPTY             // Message text
                );

            FreePathString (FullGroupName);

        } while (EnumNextInvalidName (&e));

        FreeStringResource (Blank);

        //
        // Save changed user names to FixedUserNames
        //

        Context = pGetNameGroupContextById (MSG_USERNAME_CATEGORY);
        MYASSERT (Context);

        if (EnumFirstInvalidName (&e)) {

            do {
                if (StringMatch (Context->GroupName, e.GroupName)) {

                    _tcssafecpy (EncodedName, e.OriginalName, MAX_USER_NAME);
                    MemDbMakeNonPrintableKey (
                        EncodedName,
                        MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1|
                            MEMDB_CONVERT_WILD_STAR_TO_ASCII_2|
                            MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3
                        );

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_FIXEDUSERNAMES,
                        EncodedName,
                        NULL,
                        e.NewName,
                        0,
                        NULL
                        );
                }
            } while (EnumNextInvalidName (&e));
        }
    }

    return b;
}


DWORD
BadNamesWarning (
    DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_BAD_NAMES_WARNING;
    case REQUEST_RUN:
        if (!WarnAboutBadNames (NULL)) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in BadNamesWarning"));
    }
    return 0;
}


//
// The following flag is no longer in use.  It used to be used
// to disable domain checking (to bypass the block requiring
// a valid domain).  Currently there is no way to get beyond
// the wizard page that resolved the domain name, except by
// providing a valid domain or credentials to create a computer
// account on a domain.
//

BOOL g_DisableDomainChecks = FALSE;

VOID
DisableDomainChecks (
    VOID
    )
{
    g_DisableDomainChecks = TRUE;
}


VOID
EnableDomainChecks (
    VOID
    )
{
    g_DisableDomainChecks = FALSE;
}


BOOL
IsOriginalDomainNameValid (
    VOID
    )

/*++

Routine Description:

  IsOriginalDomainNameValid checks to see if there is a replacement domain
  name.  If there is, the current domain name must be invalid.

Arguments:

  None.

Return Value:

  TRUE - the Win9x domain name is valid, no replacement name exists
  FALSE - the Win9x domain name is invalid

--*/

{
    PNAME_GROUP_ROUTINES Group;
    TCHAR NewName[MEMDB_MAX];

    Group = pGetNameGroupById (MSG_COMPUTERDOMAIN_CATEGORY);
    MYASSERT (Group);

    //
    // Look in MemDb for a replacement name
    //

    if (Group && MemDbGetEndpointValueEx (
            MEMDB_CATEGORY_NEWNAMES,
            Group->GroupName,
            MEMDB_FIELD_NEW,
            NewName
            )) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\common9x\ntenv.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ntenv.c

Abstract:

    Environment routines to emulate NT environment

Author:

    Jim Schmidt (jimschm) 24-Aug-1998

Revision History:

    Name (alias)            Date            Description

--*/

#include "pch.h"

static PMAPSTRUCT g_NtSysEnvMap;
static PMAPSTRUCT g_NtUserEnvMap;

VOID
InitNtEnvironment (
    VOID
    )
{
    TCHAR Buf[4096];

    g_NtSysEnvMap = CreateStringMapping();
    g_NtUserEnvMap = CreateStringMapping();

    //
    // Add the basics
    //

    // %COMPUTERNAME%
    if (GetUpgradeComputerName (Buf)) {
        MapNtSystemEnvironmentVariable (TEXT("%COMPUTERNAME%"), Buf);
    }

    // %HOMEDRIVE%  (%HOMEPATH% is unknown)
    MapNtSystemEnvironmentVariable (TEXT("%HOMEDRIVE%"), g_BootDrive);

    // %OS%
    MapNtSystemEnvironmentVariable (TEXT("%OS%"), TEXT("Windows_NT"));

    // %ProgramFiles%
    MapNtSystemEnvironmentVariable (TEXT("%ProgramFiles%"), g_ProgramFilesDir);

    // %SystemDrive%
    MapNtSystemEnvironmentVariable (TEXT("%SystemDrive%"), g_WinDrive);

    // %SystemRoot%, %windir%
    MapNtSystemEnvironmentVariable (TEXT("%SystemRoot%"), g_WinDir);
    MapNtSystemEnvironmentVariable (TEXT("%windir%"), g_WinDir);

    // %AllUsersProfile% is unknown, but we use a symbolic representation until GUI mode
    MapNtSystemEnvironmentVariable (TEXT("%AllUsersProfile%"), TEXT(">") S_DOT_ALLUSERS);
}


VOID
TerminateNtEnvironment (
    VOID
    )
{
    DestroyStringMapping (g_NtSysEnvMap);
    DestroyStringMapping (g_NtUserEnvMap);
}


VOID
InitNtUserEnvironment (
    IN      PUSERENUM UserEnumPtr
    )
{
    DestroyStringMapping (g_NtUserEnvMap);
    g_NtUserEnvMap = CreateStringMapping();

    //
    // Add per-user settings
    //

    // %USERNAME%
    MapNtUserEnvironmentVariable (TEXT("%USERNAME%"), UserEnumPtr->FixedUserName);

    // %USERDNSDOMAIN%, %USERDOMAIN% and %USERPROFILE% are not known.  However, we use
    // a symbolic path for %USERPROFILE% (>username).

    MapNtUserEnvironmentVariable (TEXT("%USERPROFILE%"), UserEnumPtr->NewProfilePath);

}


VOID
TerminateNtUserEnvironment (
    VOID
    )
{
    //
    // Simply blow away old mapping and make an empty one
    //

    DestroyStringMapping (g_NtUserEnvMap);
    g_NtUserEnvMap = CreateStringMapping();
}


VOID
MapNtUserEnvironmentVariable (
    IN      PCSTR Variable,
    IN      PCSTR Value
    )
{
    AddStringMappingPair (g_NtUserEnvMap, Variable, Value);
}


VOID
MapNtSystemEnvironmentVariable (
    IN      PCSTR Variable,
    IN      PCSTR Value
    )
{
    AddStringMappingPair (g_NtSysEnvMap, Variable, Value);
}


BOOL
ExpandNtEnvironmentVariables (
    IN      PCSTR SourceString,
    OUT     PSTR DestinationString,     // can be the same as SourceString
    IN      INT DestSizeInBytes
    )
{
    BOOL Changed;

    Changed = MappingSearchAndReplaceEx (
                    g_NtUserEnvMap,
                    SourceString,
                    DestinationString,
                    0,
                    NULL,
                    DestSizeInBytes,
                    STRMAP_ANY_MATCH,
                    NULL,
                    NULL
                    );

    Changed |= MappingSearchAndReplaceEx (
                    g_NtSysEnvMap,
                    DestinationString,
                    DestinationString,
                    0,
                    NULL,
                    DestSizeInBytes,
                    STRMAP_ANY_MATCH,
                    NULL,
                    NULL
                    );

    return Changed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\dll\makefile.inc ===
obj\$(TARGET_DIRECTORY)\w95upg.res: w95upg.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\dll\dllentry.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

  dllentry.c

Abstract:

  Code that implements the external DLL routines that interface with WINNT32.

Author:

  Jim Schmidt (jimschm) 01-Oct-1996

Revision History:

  marcw     23-Sep-1998 Added Winnt32VirusScannerCheck
  jimschm   30-Dec-1997 Moved initializion to init.lib
  jimschm   21-Nov-1997 Updated for NEC98, cleaned up and commented code

--*/

#include "pch.h"


extern BOOL g_Terminated;


BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )

/*++

Routine Description:

  DllMain cannot be counted on for anything.  Do not put any code here!!

Arguments:

  hInstance - Specifies the instance handle of the DLL (and not the parent EXE or DLL)

  dwReason - Specifies DLL_PROCESS_ATTACH or DLL_PROCESS_DETACH.  We specifically
             disable DLL_THREAD_ATTACH and DLL_THREAD_DETACH.

  lpReserved - Unused.

Return Value:

  DLL_PROCESS_ATTACH:
      TRUE if initialization completed successfully, or FALSE if an error
      occurred.  The DLL remains loaded only if TRUE is returned.

  DLL_PROCESS_DETACH:
      Always TRUE.

  other:
      unexpected, but always returns TRUE.

--*/

{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;

    }

    return TRUE;
}




DWORD
CALLBACK
Winnt32PluginInit (
    IN PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK Info
    )


/*++

Routine Description:

  Winnt32PluginInit is called when WINNT32 first loads w95upg.dll, before
  any wizard pages are displayed.  The structure supplies pointers to
  WINNT32's variables that will be filled with valid values as WINNT32
  runs.

  Control is passed to the code in init9x.lib.

Arguments:

  Info - Specifies the WINNT32 variables the upgrade module needs access
         to. Note that this is actually a PWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK
         (which itself holds the normal initialization block..)

Return Value:

  A Win32 status code indicating outcome.

--*/


{
    LONG Result = ERROR_SUCCESS;
    PWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK win9xInfo = (PWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK) Info;

    __try {


        //
        // Get dll path information from the Info block. We need to set this first because
        // some initialization routines depend on it being set correctly. Because we may have
        // been loaded using dll replacement, we can't assume that the rest of our files are
        // in the same directory as us.. Winnt32 provides us with the correct information in
        // the UpgradeSourcePath variable of the win9xInfo.
        //
        MYASSERT (win9xInfo->UpgradeSourcePath && *win9xInfo->UpgradeSourcePath);
        StringCopy (g_UpgradeSources, win9xInfo->UpgradeSourcePath);



        //
        // Initialize DLL globals
        //

        if (!FirstInitRoutine (g_hInst)) {
            Result = ERROR_DLL_INIT_FAILED;
            __leave;
        }

        //
        // Initialize all libraries
        //

        if (!InitLibs (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
            Result = ERROR_DLL_INIT_FAILED;
            __leave;
        }

        //
        // Final initialization
        //

        if (!FinalInitRoutine ()) {
            Result = ERROR_DLL_INIT_FAILED;
            __leave;
        }

        Result = Winnt32Init (win9xInfo);
    }
    __finally {
        if (Result != ERROR_SUCCESS && Result != ERROR_REQUEST_ABORTED) {
            Winnt32Cleanup();
        }
    }

    return Result;
}


#define S_VSCANDBINF TEXT("vscandb.inf")
BOOL
CALLBACK
Winnt32VirusScannerCheck (
    VOID
    )
{
    HANDLE snapShot;
    PROCESSENTRY32 process;
    HANDLE processHandle;
    WIN32_FIND_DATA findData;
    FILE_HELPER_PARAMS fileParams;
    HANDLE findHandle;
    PTSTR infFile;
    PTSTR p;
    UINT i;
    UINT size;

    g_BadVirusScannerFound = FALSE;
    infFile = JoinPaths (g_UpgradeSources, S_VSCANDBINF);

    //
    // Initialize migdb from vscandb.inf.
    //
    if (!InitMigDbEx (infFile)) {

        DEBUGMSG ((DBG_ERROR, "Could not initialize migdb with virus scanner information. infFile: %s", infFile));
        FreePathString (infFile);
        return TRUE;
    }

    FreePathString (infFile);

    //
    // Take snapshot of the system (will contain a list of all
    // the 32 bit processes running)
    //
    snapShot = CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);

    if (snapShot != INVALID_HANDLE_VALUE) {

         //
         // Enumerate all the processes and check the executables they ran from against the vscandb.
         //
         process.dwSize = sizeof (PROCESSENTRY32);
         if (Process32First (snapShot, &process)) {

            do {

                //
                // We need to fill in the file helper params structure and pass it to migdb to test against
                // known bad virus scanners.
                //
                ZeroMemory (&fileParams, sizeof(FILE_HELPER_PARAMS));
                fileParams.FullFileSpec = process.szExeFile;

                p = _tcsrchr (process.szExeFile, TEXT('\\'));
                if (p) {
                    *p = 0;
                    StringCopy (fileParams.DirSpec, process.szExeFile);
                    *p = TEXT('\\');
                }

                fileParams.Extension = GetFileExtensionFromPath (process.szExeFile);

                findHandle = FindFirstFile (process.szExeFile, &findData);
                if (findHandle != INVALID_HANDLE_VALUE) {

                    fileParams.FindData = &findData;
                    FindClose (findHandle);
                }
                fileParams.VirtualFile = FALSE;

                //
                // Now that we have filled in the necessary information, test the file against
                // our database of bad virus scanners. If the process *is* a bad virus scanner,
                // then the necessary globals will have been filled in by the migdb action
                // associated with these types of incompatibilities.
                //
                MigDbTestFile (&fileParams);

            } while (Process32Next (snapShot, &process));

        }
        ELSE_DEBUGMSG ((DBG_WARNING, "No processes to enumerate found on the system. No virus scanner checking done."));

        //
        // Now, terminate any files that were added to the badvirusscanner growlist.
        //
        size = GrowListGetSize (&g_BadVirusScannerGrowList);
        if (!g_BadVirusScannerFound && size && Process32First (snapShot, &process)) {

            do {

                for (i = 0; i < size; i++) {

                    p = (PTSTR) GrowListGetString (&g_BadVirusScannerGrowList, i);
                    if (StringIMatch (p, process.szExeFile)) {

                        processHandle = OpenProcess (PROCESS_TERMINATE, FALSE, process.th32ProcessID);

                        if (processHandle == INVALID_HANDLE_VALUE || !TerminateProcess (processHandle, 0)) {
                            g_BadVirusScannerFound = TRUE;
                            DEBUGMSG ((DBG_ERROR, "Unable to kill process %s.", process.szExeFile));
                        }
                    }
                }
            } while (Process32Next (snapShot, &process));
        }

        CloseHandle (snapShot);
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "Could not enumerate processes on the system. No Virus scanner checking done."));

    FreeGrowList (&g_BadVirusScannerGrowList);
    CleanupMigDb ();

    if (g_BadVirusScannerFound) {
        DEBUGMSG ((DBG_WARNING, "Virus scanner found. Setup will not continue until the user deletes this process."));
        return FALSE;
    }

    return TRUE;
}


PTSTR
CALLBACK
Winnt32GetOptionalDirectories (
    VOID
    )
{

    if (!CANCELLED()) {
        return GetNeededLangDirs ();
    }
    else {
        return NULL;
    }

}


DWORD
CALLBACK
Winnt32PluginGetPages (
    OUT    UINT *FirstCountPtr,
    OUT    PROPSHEETPAGE **FirstArray,
    OUT    UINT *SecondCountPtr,
    OUT    PROPSHEETPAGE **SecondArray,
    OUT    UINT *ThirdCountPtr,
    OUT    PROPSHEETPAGE **ThirdArray
    )


/*++

Routine Description:

  Winnt32PluginGetPages is called right after Winnt32PluginInit.  We return
  three arrays of wizard pages, and WINNT32 inserts them into its master
  wizard page array.  Because no wizard pages have been displayed, the user
  has not yet chosen the upgrade or fresh install option.  Therefore, all
  our wizard pages get called in all cases, so we must remember NOT to do
  any processong in fresh install.

Arguments:

  FirstCountPtr - Receives the number of pages in FirstArray and can be zero.

  FirstArray - Receives a pointer to an array of FirstCountPtr property
               sheet page structs.

  SecondCountPtr - Receives the number of pages in SecondArray and can be zero.

  SecondArray - Receives a pointer to an array of SecondCountPtr property
               sheet page structs.

  ThirdCountPtr - Receives the number of pages in ThirdArray and can be zero.

  ThirdArray - Receives a pointer to an array of ThirdCountPtr property
               sheet page structs.

  See WINNT32 for more information on where these wizard pages are inserted
  into the master wizard page list.

Return Value:

  A Win32 status code indicating outcome.

--*/

{
    return UI_GetWizardPages (FirstCountPtr,
                              FirstArray,
                              SecondCountPtr,
                              SecondArray,
                              ThirdCountPtr,
                              ThirdArray);
}


DWORD
CALLBACK
Winnt32WriteParams (
    IN      PCTSTR WinntSifFile
    )

/*++

Routine Description:

  Winnt32WriteParams is called just before WINNT32 begins to modify the
  boot sector and copy files.  Our job here is to take the specified
  WINNT.SIF file, read it in, merge in our changes, and write it back
  out.

  The actual work is done in the init9x.lib code.

Arguments:

  WinntSifFile - Specifies path to WINNT.SIF.  By this time, the WINNT.SIF
                 file has some values already set.

Return Value:

  A Win32 status code indicating outcome.

--*/

{
    if (UPGRADE()) {
        return Winnt32WriteParamsWorker (WinntSifFile);
    }

    return ERROR_SUCCESS;
}


VOID
CALLBACK
Winnt32Cleanup (
    VOID
    )

/*++

Routine Description:

  If the user cancels Setup, Winnt32Cleanup is called while WINNT32 is
  displaying the wizard page "Setup is undoing changes it made to your
  computer."  We must stop all processing and clean up.

  If WINNT32 completes all of its work, Winnt32Cleanup is called as
  the process exists.

  We get called even on fresh install, so we must verify we are upgrading.

Arguments:

  none

Return Value:

  none

--*/

{
    if (g_Terminated) {
        return;
    }

    if (UPGRADE()) {
        Winnt32CleanupWorker();
    }

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (g_hInst, DLL_PROCESS_DETACH, NULL);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();

}


BOOL
CALLBACK
Winnt32SetAutoBoot (
    IN    INT DriveLetter
    )

/*++

Routine Description:

  Winnt32SetAutoBoot is called by WINNT32 on both upgrade and fresh install
  to modify the boot partition of a NEC PC-9800 Partition Control Table.

  Control is passed to the init9x.lib code.

Arguments:

  DriveLetter - Specifies the boot drive letter

Return Value:

  TRUE if the partition control table was updated, or FALSE if it wasn't,
  or an error occurred.

--*/

{
    return Winnt32SetAutoBootWorker (DriveLetter);
}


BOOL
CALLBACK
Win9xGetIncompDrvs (
    OUT     PSTR** IncompatibleDrivers
    )
{
    HARDWARE_ENUM e;
    GROWBUFFER listDevicePnpids;
    GROWBUFFER listUnsupDrv = GROWBUF_INIT;
    PCTSTR multisz;

    if (!IncompatibleDrivers) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *IncompatibleDrivers = NULL;

    MYASSERT (g_SourceDirectoriesFromWinnt32 && g_SourceDirectoryCountFromWinnt32);
    if (!(g_SourceDirectoriesFromWinnt32 && g_SourceDirectoryCountFromWinnt32)) {
        DEBUGMSG ((
            DBG_ERROR,
            "Win9xAnyNetDevicePresent: upgrade module was not initialized"
            ));
        return TRUE;
    }

    if (!CreateNtHardwareList (
            g_SourceDirectoriesFromWinnt32,
            *g_SourceDirectoryCountFromWinnt32,
            NULL,
            REGULAR_OUTPUT
            )) {
        DEBUGMSG ((
            DBG_ERROR,
            "Win9xupgGetIncompatibleDrivers: CreateNtHardwareList failed!"
            ));
        return FALSE;
    }

    //
    // ISSUE - is this enumerating unsupported drivers as well?
    //
    if (EnumFirstHardware (&e, ENUM_INCOMPATIBLE_DEVICES, 0)) {
        do {
            if (!(e.HardwareID && *e.HardwareID) &&
                !(e.CompatibleIDs && *e.CompatibleIDs)) {
                continue;
            }
            LOG ((
                LOG_INFORMATION,
                "Win9xupgGetIncompatibleDrivers: Found Incompatible Device:\r\n"
                "Name: %s\r\nMfg: %s\r\nHardwareID: %s\r\nCompatibleIDs: %s\r\nHWRevision: %s",
                e.DeviceDesc,
                e.Mfg,
                e.HardwareID,
                e.CompatibleIDs,
                e.HWRevision
                ));

            ZeroMemory (&listDevicePnpids, sizeof (listDevicePnpids));
            if (e.HardwareID && *e.HardwareID) {
                AddPnpIdsToGrowBuf (&listDevicePnpids, e.HardwareID);
            }
            if (e.CompatibleIDs && *e.CompatibleIDs) {
                AddPnpIdsToGrowBuf (&listDevicePnpids, e.CompatibleIDs);
            }

            GrowBufAppendDword (&listUnsupDrv, (DWORD)listDevicePnpids.Buf);

        } while (EnumNextHardware (&e));
    }
    //
    // terminate the list with a NULL
    //
    GrowBufAppendDword (&listUnsupDrv, (DWORD)NULL);

    if (listUnsupDrv.Buf) {
        *IncompatibleDrivers = (PSTR*)listUnsupDrv.Buf;
    }
    return TRUE;
}


VOID
CALLBACK
Win9xReleaseIncompDrvs (
    IN      PSTR* IncompatibleDrivers
    )
{
    GROWBUFFER listDevicePnpids = GROWBUF_INIT;
    GROWBUFFER listUnsupDrv = GROWBUF_INIT;

    if (IncompatibleDrivers) {
        listUnsupDrv.Buf = (PBYTE)IncompatibleDrivers;
        while (*IncompatibleDrivers) {
            listDevicePnpids.Buf = (PBYTE)(*IncompatibleDrivers);
            FreeGrowBuffer (&listDevicePnpids);
            IncompatibleDrivers++;
        }
        FreeGrowBuffer (&listUnsupDrv);
    }
}


BOOL
CALLBACK
Win9xAnyNetDevicePresent (
    VOID
    )
{
    HARDWARE_ENUM e;

#if 0

    MYASSERT (g_SourceDirectoriesFromWinnt32 && g_SourceDirectoryCountFromWinnt32);
    if (!(g_SourceDirectoriesFromWinnt32 && g_SourceDirectoryCountFromWinnt32)) {
        DEBUGMSG ((
            DBG_ERROR,
            "Win9xAnyNetDevicePresent: upgrade module was not initialized"
            ));
        return TRUE;
    }
    if (!CreateNtHardwareList (
            g_SourceDirectoriesFromWinnt32,
            *g_SourceDirectoryCountFromWinnt32,
            NULL,
            REGULAR_OUTPUT
            )) {
        DEBUGMSG ((
            DBG_ERROR,
            "Win9xAnyNetDevicePresent: failed to create the NT hardware list"
            ));
        //
        // assume there is one
        //
        return TRUE;
    }

#endif

    if (EnumFirstHardware (&e, ENUM_ALL_DEVICES, ENUM_DONT_REQUIRE_HARDWAREID)) {
        do {
            //
            // Enumerate all PNP devices of class Net
            //
            if (e.Class) {
                if (StringIMatch (e.Class, TEXT("net")) ||
                    StringIMatch (e.Class, TEXT("modem"))
                    ) {
                    AbortHardwareEnum (&e);
                    return TRUE;
                }
            }

        } while (EnumNextHardware (&e));
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\common9x\twain.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    twain.c

Abstract:

    Enumeration routines for TWAIN data sources.

Author:

    Jim Schmidt (jimschm) 13-Aug-1998

Revision History:

--*/

#include "pch.h"


VOID
pSplitDataIntoWords (
    IN      PCTSTR Data,
    OUT     PWORD LeftWord,
    OUT     PWORD RightWord
    )
{
    INT a, b;
    PCTSTR p;

    a = _ttoi (Data);
    p = _tcschr (Data, TEXT('.'));
    if (!p) {
        b = 0;
    } else {
        b = _ttoi (p + 1);
    }

    *LeftWord = (WORD) a;
    *RightWord = (WORD) b;
}


BOOL
pGetDsInfo16 (
    IN      PCTSTR DsPath,
    OUT     TW_IDENTITY *Id
    )
{
    CHAR CmdLine[MAX_CMDLINE];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL ProcessResult;
    DWORD rc;
    PSTR Data;

    Data = CmdLine;

    //
    // Launch TWID.EXE
    //

    wsprintf (CmdLine, TEXT("\"%s\\TWID.EXE\" %s"), g_UpgradeSources, DsPath);

    ZeroMemory (&si, sizeof (si));
    si.cb = sizeof (si);
    si.dwFlags = STARTF_FORCEOFFFEEDBACK;

    ProcessResult = CreateProcessA (
                        NULL,
                        CmdLine,
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_DEFAULT_ERROR_MODE,
                        NULL,
                        g_WinDir,
                        &si,
                        &pi
                        );

    if (ProcessResult) {
        CloseHandle (pi.hThread);
    } else {
        LOG ((LOG_ERROR, "Cannot start %s", CmdLine));
        return FALSE;
    }

    rc = WaitForSingleObject (pi.hProcess, 10000);

    if (rc != WAIT_OBJECT_0) {
        TerminateProcess (pi.hProcess, 0);
    }

    CloseHandle (pi.hProcess);

    //
    // If process terminated, look for win.ini section
    //

    if (rc == WAIT_OBJECT_0) {
        ZeroMemory (Id, sizeof (TW_IDENTITY));

        GetProfileString (
            TEXT("$TWAINDSINFO$"),
            TEXT("Version"),
            TEXT("1.0"),
            Data,
            32
            );

        pSplitDataIntoWords (Data, &Id->Version.MajorNum, &Id->Version.MinorNum);

        GetProfileString (
            TEXT("$TWAINDSINFO$"),
            TEXT("Locale"),
            TEXT(""),
            Data,
            32
            );

        pSplitDataIntoWords (Data, &Id->Version.Language, &Id->Version.Country);

        GetProfileString (
            TEXT("$TWAINDSINFO$"),
            TEXT("VersionInfo"),
            TEXT(""),
            Id->Version.Info,
            sizeof (Id->Version.Info)
            );

        GetProfileString (
            TEXT("$TWAINDSINFO$"),
            TEXT("Mfg"),
            TEXT(""),
            Id->Manufacturer,
            sizeof (Id->Manufacturer)
            );

        GetProfileString (
            TEXT("$TWAINDSINFO$"),
            TEXT("Family"),
            TEXT(""),
            Id->ProductFamily,
            sizeof (Id->ProductFamily)
            );

        GetProfileString (
            TEXT("$TWAINDSINFO$"),
            TEXT("Name"),
            TEXT(""),
            Id->ProductName,
            sizeof (Id->ProductName)
            );

        //
        // Delete the INI data
        //

        WriteProfileString (
            TEXT("$TWAINDSINFO$"),
            NULL,
            NULL
            );

        return *(Id->ProductName) != 0;
    }

    return FALSE;
}

DWORD g_OrgEsp;
DWORD g_OrgEbp;

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(push)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

BOOL
pGetDsInfo32 (
    IN      PCTSTR DsPath,
    OUT     TW_IDENTITY *Id
    )
{
    HINSTANCE DsLib = NULL;
    DSENTRYPROC DsEntry;
    TW_UINT16 TwainRc;

    __try {
        //
        // Open the DS as a 32-bit library
        //

        DsLib = LoadLibrary (DsPath);

        if (!DsLib) {
            return FALSE;
        }

        //
        // Get the DS entry point
        //

        DsEntry = (DSENTRYPROC) GetProcAddress (DsLib, "DS_Entry");

        if (!DsEntry) {
            FreeLibrary (DsLib);
            return FALSE;
        }

        //
        // Get the TW_IDENTITY struct, and preserve the stack for poorly
        // written DSes.
        //

        __asm {
            mov eax, esp
            mov [g_OrgEsp], eax
            mov [g_OrgEbp], ebp
        }

        TwainRc = DsEntry (NULL, DG_CONTROL, DAT_IDENTITY, MSG_GET, Id);

        __asm {
            mov eax, [g_OrgEsp]
            mov esp, eax
            mov ebp, [g_OrgEbp]
        }

    }
    __except (TRUE) {
        TwainRc = ERROR_NOACCESS;
    }

    if (DsLib) {
        FreeLibrary (DsLib);
    }

    return TwainRc == ERROR_SUCCESS;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

BOOL
EnumFirstTwainDataSource (
    OUT     PTWAINDATASOURCE_ENUM EnumPtr
    )
{
    ZeroMemory (EnumPtr, sizeof (EnumPtr));
    EnumPtr->State = TE_INIT;

    return EnumNextTwainDataSource (EnumPtr);
}


BOOL
EnumNextTwainDataSource (
    IN OUT  PTWAINDATASOURCE_ENUM EnumPtr
    )
{
    TCHAR Path[MAX_TCHAR_PATH];
    TW_IDENTITY Id;

    while (EnumPtr->State != TE_DONE) {
        switch (EnumPtr->State) {

        case TE_INIT:
            EnumPtr->State = TE_BEGIN_ENUM;
            EnumPtr->Dir = TEXT("TWAIN\0TWAIN_32\0TWAIN32\0");
            break;

        case TE_BEGIN_ENUM:
            wsprintf (Path, TEXT("%s\\%s"), g_WinDir, EnumPtr->Dir);

            if (!EnumFirstFileInTree (&EnumPtr->Enum, Path, TEXT("*.DS"), TRUE)) {
                EnumPtr->State = TE_END_ENUM;
            } else {
                EnumPtr->State = TE_EVALUATE;
            }
            break;

        case TE_EVALUATE:
            if (EnumPtr->Enum.Directory) {
                EnumPtr->State = TE_NEXT;
            } else if (pGetDsInfo16 (EnumPtr->Enum.FullPath, &Id)) {
                EnumPtr->State = TE_RETURN;
            } else if (pGetDsInfo32 (EnumPtr->Enum.FullPath, &Id)) {
                EnumPtr->State = TE_RETURN;
            } else {
                EnumPtr->State = TE_NEXT;
            }
            break;

        case TE_RETURN:
            EnumPtr->State = TE_NEXT;

            __try {
                StackStringCopy (EnumPtr->Manufacturer, Id.Manufacturer);
                StackStringCopy (EnumPtr->ProductFamily, Id.ProductFamily);
                StackStringCopy (EnumPtr->DisplayName, Id.ProductName);
                StackStringCopy (EnumPtr->DataSourceModule, EnumPtr->Enum.FullPath);
            }
            __except (TRUE) {
                break;
            }

            return TRUE;

        case TE_NEXT:
            if (!EnumNextFileInTree (&EnumPtr->Enum)) {
                EnumPtr->State = TE_END_ENUM;
            } else {
                EnumPtr->State = TE_EVALUATE;
            }
            break;

        case TE_END_ENUM:
            EnumPtr->Dir = GetEndOfString (EnumPtr->Dir) + 1;
            if (*EnumPtr->Dir) {
                EnumPtr->State = TE_BEGIN_ENUM;
            } else {
                EnumPtr->State = TE_DONE;
            }
            break;
        }
    }

    return FALSE;
}


VOID
AbortTwainDataSourceEnum (
    IN OUT  PTWAINDATASOURCE_ENUM EnumPtr
    )
{
    if (EnumPtr->State != TE_DONE) {
        AbortEnumFileInTree (&EnumPtr->Enum);
        EnumPtr->State = TE_DONE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\hwcomp\hwcompp.h ===
//
// hwcompp.h
//

//
// Include the interface exported in miglib.lib:
//

#include "miglib.h"
#undef HASHTABLE

//
// Enumeration tracking macros
//

#ifdef DEBUG

INT g_EnumsActive;
INT g_NetEnumsActive;

#define START_ENUM  g_EnumsActive++
#define END_ENUM    g_EnumsActive--
#define START_NET_ENUM  g_NetEnumsActive++
#define END_NET_ENUM    g_NetEnumsActive--

#else

#define START_ENUM
#define END_ENUM
#define START_NET_ENUM
#define END_NET_ENUM

#endif

//
// Hardware ID tables
//

extern HASHTABLE g_NeededHardwareIds;
extern HASHTABLE g_UiSuppliedIds;

//
// GrowBuffer access
//

#define GETPNPIDTEXT(offset) ((PCTSTR) (g_PnpIdText.Buf + offset))
#define GETINFFILENAME(offset) ((PCTSTR) (g_InfFileName.Buf + offset))

//
// Typedefs
//

typedef struct {
    HANDLE File;
    HASHITEM InfFileOffset;
    BOOL UnsupportedDevice;
} SAVE_ENUM_PARAMS, *PSAVE_ENUM_PARAMS;


//
// Constants
//

#define STATE_ENUM_FIRST_KEY    0
#define STATE_ENUM_NEXT_KEY     1
#define STATE_ENUM_FIRST_VALUE  2
#define STATE_ENUM_NEXT_VALUE   3
#define STATE_EVALUATE_VALUE    4
#define STATE_VALUE_CLEANUP     5
#define STATE_ENUM_CHECK_KEY    6

#define STATE_ENUM_FIRST_HARDWARE   0
#define STATE_ENUM_NEXT_HARDWARE    1
#define STATE_EVALUATE_HARDWARE     2

#define ENUM_USER_SUPPLIED_FLAG_NEEDED (ENUM_WANT_USER_SUPPLIED_FLAG|ENUM_WANT_USER_SUPPLIED_ONLY|ENUM_DONT_WANT_USER_SUPPLIED)

#define MAX_PNP_ID      1024
#define HWCOMPDAT_SIGNATURE "HwCompDat-v2"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\common9x\userenum.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  userenum.c

Abstract:

  This module implements a pair of user enumeration functions to consolidate
  general-case and special-case processing of users.  The caller does not
  need to know how a machine's user profiles are configured because the
  code here abstracts the details.

  The caller gets:

  - Each user name, .default for the logon prompt, and Default User for the
    NT default user account
  - The Win9x user.dat location for each user, including the default user
  - The Win9x profile directory, or All Users for the default user
  - The symbolic NT profile directory
  - The account type (normal, administrator and/or default)
  - Indication that the account registry is valid
  - Indication that the account is the current logged-on user or last logged-on
    user

Routines:

  EnumFirstUser - Begins the user enumeration

  EnumNextUser - Continues the user enumeration

  EnumUserAbort - Cleans up an enumeration that did not complete

Author:

  Jim Schmidt (jimschm) 23-Jul-1997

Revision History:

  Jim Schmidt (jimschm)  08-Sep-1998   Changed to a better state machine to
                                       clean up the evolved complexity
  Jim Schmidt (jimschm)  09-Jun-1998   Revisions for dynamic user profile dir

--*/

#include "pch.h"
#include "cmn9xp.h"


#define DBG_USERENUM "UserEnum"

#define UE_INITIALIZED      0x0001
#define UE_SF_COLLISIONS    0x0002

static DWORD g_UserEnumFlags = 0;


VOID
pMoveAndRenameProfiles (
    IN      PCTSTR ProfileList
    )

/*++

Routine Description:

  pReportNonMigrateableUserAccounts adds a message to the incompatibility
  report when a condition that makes user migration impossible (except current user)
  is detected

Arguments:

  ProfileList - Specifies the list of non-migrated user profile paths (multisz)

Return Value:

  none

--*/

{
    MULTISZ_ENUM msze;
    PTSTR p, append;
    TCHAR sourceDir[MAX_TCHAR_PATH];
    TREE_ENUM e;
    TCHAR newDest[MAX_TCHAR_PATH];
    PTSTR profiles;
    TCHAR tempFile[MAX_TCHAR_PATH];

    profiles = JoinPaths (g_WinDir, TEXT("Profiles"));

    if (EnumFirstMultiSz (&msze, ProfileList)) {
        do {
            //
            // remove user.dat from the path
            //
            StackStringCopy (sourceDir, msze.CurrentString);
            p = _tcsrchr (sourceDir, TEXT('\\'));
            if (!p) {
                MYASSERT (FALSE);
                continue;
            }
            *p = 0;
            MYASSERT (StringIMatch (p + 1, TEXT("user.dat")));
            p = _tcsrchr (sourceDir, TEXT('\\'));
            if (!p) {
                MYASSERT (FALSE);
                continue;
            }
            //
            // append Win9x OS name to the target directory name
            //
            append = newDest + wsprintf (newDest, TEXT("%s%s.%s"), g_ProfileDirNt, p, g_Win95Name);
            if (CanSetOperation (sourceDir, OPERATION_FILE_MOVE_EXTERNAL)) {
                MarkFileForMoveExternal (sourceDir, newDest);
            }
            *append = TEXT('\\');
            append++;
            //
            // now enumerate and move all the files
            //
            if (StringIPrefix (sourceDir, profiles) && EnumFirstFileInTree (&e, sourceDir, NULL, TRUE)) {
                do {
                    StringCopy (append, e.SubPath);
                    if (!e.Directory) {
                        //
                        // remove old operation and set a new one
                        // with the updated final dest
                        //
                        if (CanSetOperation (e.FullPath, OPERATION_TEMP_PATH)) {
                            ComputeTemporaryPath (e.FullPath, NULL, NULL, g_TempDir, tempFile);
                            MarkFileForTemporaryMoveEx (e.FullPath, newDest, tempFile, TRUE);
                        }
                    } else {
                        if (CanSetOperation (e.FullPath, OPERATION_FILE_MOVE_EXTERNAL)) {
                            MarkFileForMoveExternal (e.FullPath, newDest);
                        }
                    }

                } while (EnumNextFileInTree (&e));
            }
        } while (EnumNextMultiSz (&msze));
    }

    FreePathString (profiles);
}


VOID
pReportNonMigrateableUserAccounts (
    IN      PCTSTR UserList
    )

/*++

Routine Description:

  pReportNonMigrateableUserAccounts adds a message to the incompatibility
  report when a condition that makes user migration impossible (except current user)
  is detected

Arguments:

  UserList - Specifies the list of non-migrated users (multisz)

Return Value:

  none

--*/

{
    PCTSTR MsgGroup = NULL;
    PCTSTR RootGroup = NULL;
    PCTSTR SubGroup = NULL;
    PCTSTR Message = NULL;
    PCTSTR ArgArray[2];
    MULTISZ_ENUM msze;

    __try {
        RootGroup = GetStringResource (MSG_LOSTSETTINGS_ROOT);
        SubGroup  = GetStringResource (MSG_SHARED_USER_ACCOUNTS);
        if (!RootGroup || !SubGroup) {
            MYASSERT (FALSE);
            __leave;
        }

        //
        // Build "Settings That Will Not Be Upgraded\Shared User Accounts"
        //
        MsgGroup = JoinPaths (RootGroup, SubGroup);
        //
        // Send message to report
        //
        ArgArray[0] = g_Win95Name;
        ArgArray[1] = g_ProfileDirNt;
        Message = ParseMessageID (MSG_SHARED_USER_ACCOUNTS_MESSAGE, ArgArray);
        if (Message) {
            MsgMgr_ObjectMsg_Add (TEXT("*SharedUserAccounts"), MsgGroup, Message);
        }

        if (EnumFirstMultiSz (&msze, UserList)) {
            do {
                //
                // remove all associated messages from the report
                //
                HandleObject (msze.CurrentString, TEXT("UserName"));
            } while (EnumNextMultiSz (&msze));
        }
    }
    __finally {
        //
        // Clean up
        //
        FreeStringResource (Message);
        FreeStringResource (RootGroup);
        FreeStringResource (SubGroup);
        FreePathString (MsgGroup);
    }
}


VOID
pCheckShellFoldersCollision (
    VOID
    )
{
    USERENUM e;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR idShellFolder;
    PCTSTR path;
    GROWBUFFER gb = GROWBUF_INIT;
    GROWBUFFER users = GROWBUF_INIT;
    GROWBUFFER profilesWin9x = GROWBUF_INIT;
    MULTISZ_ENUM msze;
    TCHAR key[MEMDB_MAX];
    BOOL collisions = FALSE;

    if (EnumFirstUser (&e, 0)) {

        if (!e.CommonProfilesEnabled) {

            if (InfFindFirstLine (g_Win95UpgInf, S_PROFILES_SF_COLLISIONS, NULL, &is)) {
                do {
                    idShellFolder = InfGetStringField (&is, 1);
                    if (idShellFolder && *idShellFolder) {
                        MultiSzAppend (&gb, idShellFolder);
                    }
                } while (InfFindNextLine (&is));
                InfCleanUpInfStruct (&is);
            }

            do {
                if (!EnumFirstMultiSz (&msze, (PCTSTR)gb.Buf)) {
                    break;
                }
                if (!(e.AccountType & (LOGON_PROMPT | DEFAULT_USER | INVALID_ACCOUNT))) {
                    if (!(e.AccountType & CURRENT_USER)) {
                        MultiSzAppend (&users, e.UserName);
                        MultiSzAppend (&profilesWin9x, e.UserDatPath);
                    }
                    if (!collisions) {
                        do {
                            path = ShellFolderGetPath (&e, msze.CurrentString);
                            if (path) {
                                MemDbBuildKey (key, MEMDB_CATEGORY_PROFILES_SF_COLLISIONS, msze.CurrentString, path, NULL);
                                if (MemDbGetValue (key, NULL)) {
                                    //
                                    // this shell folder path is shared between multiple users
                                    //

                                    LOG ((
                                        LOG_INFORMATION,
                                        "User %s shares path %s with another user for %s",
                                        e.UserName,
                                        path,
                                        msze.CurrentString
                                        ));

                                    collisions = TRUE;
                                    break;
                                }

                                LOG ((
                                    LOG_INFORMATION,
                                    "User %s uses path %s for %s",
                                    e.UserName,
                                    path,
                                    msze.CurrentString
                                    ));

                                MemDbSetValue (key, 0);
                                FreePathString (path);
                            }
                        } while (EnumNextMultiSz (&msze));
                    }
                }
            } while (EnumNextUser (&e));
        }

        EnumUserAbort (&e);
    }

    if (collisions) {
        //
        // show this in the upgrade report
        //
        LOG ((
            LOG_WARNING,
            "Some user profiles share special shell folders; only the current account will be migrated"
            ));
        MYASSERT (users.Buf && profilesWin9x.Buf);
        pReportNonMigrateableUserAccounts (users.Buf);
        //
        // rename their profile from <Profiles9x>\<username> to <ProfilesNT>\<username>.<Win9xOSName>
        //
        pMoveAndRenameProfiles (profilesWin9x.Buf);
        //
        // set the global flag
        //
        g_UserEnumFlags |= UE_SF_COLLISIONS;
    }

    FreeGrowBuffer (&gb);
    FreeGrowBuffer (&users);
    MemDbDeleteTree (MEMDB_CATEGORY_PROFILES_SF_COLLISIONS);
}


BOOL
pUserMigrationDisabled (
    IN      PUSERENUM EnumPtr
    )
{
    return (g_UserEnumFlags & UE_SF_COLLISIONS) != 0 &&
           !(EnumPtr->AccountType & (CURRENT_USER | DEFAULT_USER));
}


BOOL
pIsProfileDirInUse (
    IN      PVOID ProfileDirTable,
    IN      PCTSTR ProfileDirName,
    IN      PCTSTR ActualUserName
    )
{
    LONG rc;

    if (StringIMatch (ProfileDirName, ActualUserName)) {
        return FALSE;
    }

    rc = pSetupStringTableLookUpString (
             ProfileDirTable,
             (PTSTR) ProfileDirName,
             STRTAB_CASE_INSENSITIVE
             );

    if (rc != -1) {
        return TRUE;
    }

    if (StringIMatch (ProfileDirName, g_AdministratorStr)) {
        return TRUE;
    }

    if (StringIMatch (ProfileDirName, S_DEFAULT_USER)) {
        return TRUE;
    }

    if (StringIMatch (ProfileDirName, S_ALL_USERS)) {
        return TRUE;
    }

    if (StringIMatch (ProfileDirName, S_LOCALSERVICE_USER)) {
        return TRUE;
    }

    if (StringIMatch (ProfileDirName, S_NETWORKSERVICE_USER)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pIsAdministratorUserName (
    IN      PCTSTR UserName
    )

/*++

Routine Description:

  Determines if the specified name is the administrator account or not.

Arguments:

  UserName - Specifies the user name (without a domain name)

Return Value:

  TRUE if the specified string is the same as "Administrator"
  FALSE if the specified string is not "Administrator"

--*/

{
    return StringIMatch (UserName, g_AdministratorStr);
}


VOID
pPrepareStructForNextUser (
    IN OUT  PUSERENUM EnumPtr
    )

/*++

Routine Description:

  pPrepareStructForNextUser initializes the user-specific members of the enum
  struct.

Arguments:

  EnumPtr - Specifies the previous enum state, receives the initialized enum
            state.

Return Value:

  None.

--*/

{
    //
    // Init flags
    //

    EnumPtr->DefaultUserHive = FALSE;
    EnumPtr->CreateAccountOnly = FALSE;

    //
    // Init names
    //

    EnumPtr->UserName[0] = 0;
    EnumPtr->FixedUserName[0] = 0;

    // AdminUserName is the true Win9x user name of the future Administrator
    EnumPtr->AdminUserName[0] = 0;
    EnumPtr->FixedAdminUserName[0] = 0;

    //
    // Init paths
    //

    EnumPtr->UserDatPath[0] = 0;
    EnumPtr->ProfileDirName[0] = 0;
    EnumPtr->OrgProfilePath[0] = 0;
    EnumPtr->NewProfilePath[0] = 0;

    //
    // Init values
    //

    EnumPtr->AccountType = 0;

    //
    // Init reg value
    //

    if (EnumPtr->UserRegKey) {
        CloseRegKey (EnumPtr->UserRegKey);
        EnumPtr->UserRegKey = NULL;
    }
}


VOID
pPrepareStructForReturn (
    IN OUT  PUSERENUM EnumPtr,
    IN      ACCOUNTTYPE AccountType,
    IN      USERENUM_STATE NextState
    )

/*++

Routine Description:

  pPrepareStructForReturn performs processing common to any type of
  enumeration.  This includes:

  - Identifying an actual Win9x user named Administrator (a special case)
  - Finding the fixed name (i.e., NT-compatible name) for the user account
  - Mapping in the hive into the registry
  - Computing the full path to the profile directory, as well as the profile
    dir name (i.e., joeuser.001).  The profile dir is encoded as >username
    because we don't know the true location until GUI mode.
  - Setting flags for current user or last logged on user

  The caller must set UserName and DefaultUserHive prior to calling
  this function (as well as all enumeration-wide members such as current
  user name).

Arguments:

  EnumPtr     - Specifies the partially completed enum state.  Receives the
                complete enum state.
  AccountType - Specifies the account type being returned.
  NextState   - Specifies the next state for the state machine, used when the
                caller calls EnumNextUser.

Return Value:

  None.

--*/

{
    DWORD rc;
    PTSTR p;
    TCHAR TempDir[MAX_TCHAR_PATH];
    UINT TempDirSeq;
    HKEY key;
    HKEY userKey;
    PCTSTR data;

    //
    // Fill in state machine members
    //

    EnumPtr->AccountType = AccountType;
    EnumPtr->State = UE_STATE_RETURN;
    EnumPtr->NextState = NextState;

    //
    // Check if named user is also Administrator
    //

    if (AccountType & NAMED_USER) {
        if (pIsAdministratorUserName (EnumPtr->UserName)) {
            EnumPtr->AccountType |= ADMINISTRATOR;
            StringCopy (EnumPtr->AdminUserName, EnumPtr->UserName);
        }

        //
        // If this is a named user but there is no hive, use the default hive
        //

        key = OpenRegKeyStr (S_HKLM_PROFILELIST_KEY);

        if (key) {
            userKey = OpenRegKey (key, EnumPtr->UserName);

            if (userKey) {
                data = GetRegValueString (userKey, S_PROFILEIMAGEPATH);
                if (data) {
                    FreeMem (data);
                } else {
                    EnumPtr->DefaultUserHive = TRUE;
                }

                CloseRegKey (userKey);
            }

            CloseRegKey (key);
        }
    }

    //
    // Generate fixed user names
    //

    if (EnumPtr->EnableNameFix) {
        GetUpgradeUserName (EnumPtr->UserName, EnumPtr->FixedUserName);

        //
        // If this is Administrator, and it is coming from DefaultUser, then
        // UserName is empty and we must use the name Administrator for the
        // account (or Owner on PER skus).
        //

        if ((EnumPtr->AccountType & ADMINISTRATOR) &&
            EnumPtr->FixedUserName[0] == 0
            ) {
            StringCopy (EnumPtr->FixedUserName, g_AdministratorStr);
            MemDbSetValueEx (
                MEMDB_CATEGORY_FIXEDUSERNAMES,
                EnumPtr->UserName,              // empty string
                EnumPtr->FixedUserName,         // Administrator or Owner
                NULL,
                0,
                NULL
                );
        }

        if (EnumPtr->AdminUserName[0]) {
            GetUpgradeUserName (EnumPtr->AdminUserName, EnumPtr->FixedAdminUserName);
        }

    } else {
        StringCopy (EnumPtr->FixedUserName, EnumPtr->UserName);
        StringCopy (EnumPtr->FixedAdminUserName, EnumPtr->AdminUserName);
    }

    //
    // Map in the hive
    //

    if (!EnumPtr->DoNotMapHive) {
        if (EnumPtr->DefaultUserHive) {
            // The default hive
            rc = Win95RegSetCurrentUser (
                    NULL,                       // User Pos -- NULL for default
                    NULL,                       // (IN OPTIONAL) Substitute %WinDir%
                    EnumPtr->UserDatPath        // OUT
                    );
        } else {
            // A non-default hive
            rc = Win95RegSetCurrentUser (
                    &EnumPtr->pos,
                    NULL,                       // (IN OPTIONAL) Substitute %WinDir%
                    EnumPtr->UserDatPath
                    );
        }
    } else {
        if (!EnumPtr->pos.UseProfile || EnumPtr->DefaultUserHive) {

            StringCopy (EnumPtr->UserDatPath, g_WinDir);
            StringCat (EnumPtr->UserDatPath, TEXT("\\user.dat"));
            rc = ERROR_SUCCESS;

        } else {
            //
            // Call FindAndLoadHive to get the user.dat path,
            // but don't actually load the hive.
            //
            rc = FindAndLoadHive (
                    &EnumPtr->pos,
                    NULL,                       // CallerSuppliedWinDir
                    NULL,                       // UserDatFromCaller
                    EnumPtr->UserDatPath,
                    FALSE                       // MapTheHive flag
                    );
        }
    }

    //
    // Resolve profile directory
    //

    if (rc != ERROR_SUCCESS) {
        EnumPtr->AccountType |= INVALID_ACCOUNT;

        DEBUGMSG ((
            DBG_WARNING,
            "pUpdateEnumStruct: Win95RegSetCurrentUser could not set user %s (rc=%u)",
            EnumPtr->UserName,
            rc
            ));

    } else {

        if (!EnumPtr->DoNotMapHive) {
            //
            // User's hive is valid, open the registry
            //

            MYASSERT (g_UserKey && *g_UserKey);
            if (!g_UserKey) {
                g_UserKey = S_EMPTY;
            }

            EnumPtr->UserRegKey = OpenRegKeyStr (g_UserKey);

            if (!EnumPtr->UserRegKey) {
                LOG ((LOG_ERROR, "Cannot open %s", g_UserKey));
                EnumPtr->State = EnumPtr->NextState;
            }
        }

        //
        // Save original profile directory
        //

        StringCopy (EnumPtr->OrgProfilePath, EnumPtr->UserDatPath);
        p = _tcsrchr (EnumPtr->OrgProfilePath, TEXT('\\'));
        if (p) {
            *p = 0;
        }

        //
        // now build profile directory and path
        //

        if (EnumPtr->AccountType & ADMINISTRATOR) {
            //
            // Special case: We know the NT Profile directory name for Administrator.
            //               It can't come from Win9x.
            //
            StringCopy (EnumPtr->ProfileDirName, g_AdministratorStr);

        } else {
            //
            // General case: The profile directory is in the user.dat path
            //

            if (!StringMatch (EnumPtr->UserName, EnumPtr->FixedUserName)) {
                //
                // Use fixed user name if one exists
                //

                StringCopy (EnumPtr->ProfileDirName, EnumPtr->FixedUserName);

            } else if (StringIMatchCharCount (EnumPtr->UserDatPath, g_ProfileDirWack, g_ProfileDirWackChars)) {
                //
                // If per-user profile directory exists, extract the user name from it
                //

                _tcssafecpy (
                    EnumPtr->ProfileDirName,
                    CharCountToPointer (EnumPtr->UserDatPath, g_ProfileDirWackChars),
                    MAX_TCHAR_PATH
                    );

                p = _tcsrchr (EnumPtr->ProfileDirName, TEXT('\\'));
                if (p) {
                    *p = 0;

                    //
                    // Unusual case: The directory name we extracted collides with
                    // another user, Default User, All Users or Administrator.
                    //

                    StringCopy (TempDir, EnumPtr->ProfileDirName);
                    TempDirSeq = 1;

                    p = _tcschr (TempDir, TEXT('.'));
                    if (p) {
                        *p = 0;
                    }

                    while (pIsProfileDirInUse (
                                EnumPtr->ProfileDirTable,
                                EnumPtr->ProfileDirName,
                                EnumPtr->UserName
                                )) {
                        wsprintf (EnumPtr->ProfileDirName, TEXT("%s.%03u"), TempDir, TempDirSeq);
                        TempDirSeq++;

                        if (TempDirSeq == 1000) {
                            break;
                        }
                    }

                } else {
                    //
                    // Unusual case: No sub dir after profile directory -- copy user name
                    //

                    _tcssafecpy (EnumPtr->ProfileDirName, EnumPtr->UserName, MAX_TCHAR_PATH);
                }

                //
                // Add to table for collision detection
                //

                pSetupStringTableAddString (
                    EnumPtr->ProfileDirTable,
                    EnumPtr->ProfileDirName,
                    STRTAB_CASE_INSENSITIVE
                    );

            } else {
                //
                // No per-user profile directory -- copy user name
                //

                _tcssafecpy (EnumPtr->ProfileDirName, EnumPtr->UserName, MAX_TCHAR_PATH);
            }

            //
            // If profile directory is empty, change to All Users
            //

            if (!EnumPtr->ProfileDirName[0]) {
                StringCopy (EnumPtr->ProfileDirName, S_ALL_USERS);
            }
        }

        //
        // Generate full path to new profile dir
        //

        if (*EnumPtr->FixedUserName) {
            wsprintf (
                EnumPtr->NewProfilePath,
                TEXT(">%s"),
                EnumPtr->FixedUserName
                );
        } else {
            wsprintf (
                EnumPtr->NewProfilePath,
                TEXT(">%s"),
                EnumPtr->ProfileDirName
                );
        }
    }

    //
    // Set flag for last logged on user and current user
    //

    if (StringIMatch (EnumPtr->UserName, EnumPtr->LastLoggedOnUserName)) {

        EnumPtr->AccountType |= LAST_LOGGED_ON_USER;

    }

    if (StringIMatch (EnumPtr->UserName, EnumPtr->CurrentUserName)) {

        EnumPtr->AccountType |= CURRENT_USER;

    }

}


BOOL
pUserEnumWorker (
    IN OUT  PUSERENUM EnumPtr
    )

/*++

Routine Description:

  pUserEnumWorker implements a state machine that enumerates:

  1. All named users
  2. If no named users, the last logged on user (if one exists)
  3. The Administrator account (if not already enumerated in step 1 or 2)
  4. The logon prompt account
  5. The default user (if enabled)

  The caller can filter out the create-only Administrator account
  and the logon prompt account.

Arguments:

  EnumPtr - Specifies the previous enumeration state (or an initialized
            enumeration struct).  Recieves the next enumerated user.

Return Value:

  TRUE if another user was enumerated, or FALSE if no additional users are
  left.

--*/

{
    DWORD rc;
    HKEY Key;
    PCTSTR Data;
    DWORD Size;

    while (EnumPtr->State != UE_STATE_END) {

        switch (EnumPtr->State) {

        case UE_STATE_INIT:
            //
            // Init table for collisions...
            //

            EnumPtr->ProfileDirTable = pSetupStringTableInitialize();
            if (!EnumPtr->ProfileDirTable) {
                return FALSE;
            }

            //
            // Get data static to the enumeration:
            //  - Last logged on user
            //  - Current user
            //

            Key = OpenRegKeyStr (TEXT("HKLM\\Network\\Logon"));
            if (Key) {
                Data = GetRegValueString (Key, TEXT("username"));

                if (Data) {
                    _tcssafecpy (EnumPtr->LastLoggedOnUserName, Data, MAX_USER_NAME);
                    MemFree (g_hHeap, 0, Data);
                }

                CloseRegKey (Key);
            }

            Size = MAX_USER_NAME;
            if (!GetUserName (EnumPtr->CurrentUserName, &Size)) {
                EnumPtr->CurrentUserName[0] = 0;
            }

            //
            // Check for an account named Administrator
            //

            rc = Win95RegGetFirstUser (&EnumPtr->pos, EnumPtr->UserName);
            if (rc != ERROR_SUCCESS) {
                EnumPtr->State = UE_STATE_CLEANUP;
                LOG ((LOG_ERROR, "Could not enumerate first user. Error: %u.", rc));
                break;
            }

            while (Win95RegHaveUser (&EnumPtr->pos)) {
                //
                // Add user name to profile dir table
                //

                pSetupStringTableAddString (
                    EnumPtr->ProfileDirTable,
                    EnumPtr->UserName,
                    STRTAB_CASE_INSENSITIVE
                    );

                //
                // If this is Administrator, set flag
                //

                if (pIsAdministratorUserName (EnumPtr->UserName)) {
                    EnumPtr->RealAdminAccountExists = TRUE;
                }

                Win95RegGetNextUser (&EnumPtr->pos, EnumPtr->UserName);
            }

            EnumPtr->State = UE_STATE_BEGIN_WIN95REG;
            break;

        case UE_STATE_BEGIN_WIN95REG:

            pPrepareStructForNextUser (EnumPtr);

            Win95RegGetFirstUser (&EnumPtr->pos, EnumPtr->UserName);

            EnumPtr->CommonProfilesEnabled = !EnumPtr->pos.UseProfile;

            DEBUGMSG_IF ((EnumPtr->CommonProfilesEnabled, DBG_USERENUM, "Common profiles enabled"));
            DEBUGMSG_IF ((!EnumPtr->CommonProfilesEnabled, DBG_USERENUM, "Common profiles disabled"));

            EnumPtr->DefaultUserHive = EnumPtr->CommonProfilesEnabled;

            if (Win95RegHaveUser (&EnumPtr->pos)) {
                //
                // We have a user.
                //

                pPrepareStructForReturn (EnumPtr, NAMED_USER, UE_STATE_NEXT_WIN95REG);

            } else {
                //
                // We have NO users.
                //

                EnumPtr->State = UE_STATE_NO_USERS;

            }

            break;

        case UE_STATE_NO_USERS:
            //
            // There are two cases, either there is no logon prompt, or the
            // user hit escape and decided to upgrade.
            //

            pPrepareStructForNextUser (EnumPtr);

            //
            // No users means no hives.
            //

            EnumPtr->DefaultUserHive = TRUE;

            if (EnumPtr->LastLoggedOnUserName[0]) {

                DEBUGMSG ((DBG_USERENUM, "User is not logged on now, but was logged on before."));
                StringCopy (EnumPtr->UserName, EnumPtr->LastLoggedOnUserName);

                if (pIsAdministratorUserName (EnumPtr->UserName)) {
                    pPrepareStructForReturn (EnumPtr, NAMED_USER, UE_STATE_LOGON_PROMPT);
                } else {
                    pPrepareStructForReturn (EnumPtr, NAMED_USER, UE_STATE_ADMINISTRATOR);
                }

            } else {
                DEBUGMSG ((DBG_USERENUM, "Machine only has a default user."));

                EnumPtr->UserName[0] = 0;
                pPrepareStructForReturn (EnumPtr, DEFAULT_USER|ADMINISTRATOR|LOGON_PROMPT|CURRENT_USER, UE_STATE_LOGON_PROMPT);
            }

            break;

        case UE_STATE_NEXT_WIN95REG:

            pPrepareStructForNextUser (EnumPtr);

            rc = Win95RegGetNextUser (&EnumPtr->pos, EnumPtr->UserName);
            if (rc != ERROR_SUCCESS) {
                EnumPtr->State = UE_STATE_CLEANUP;
                LOG ((LOG_ERROR, "Could not enumerate next user. Error: %u.", rc));
                break;
            }

            if (Win95RegHaveUser (&EnumPtr->pos)) {
                //
                // We have another user
                //

                pPrepareStructForReturn (EnumPtr, NAMED_USER, UE_STATE_NEXT_WIN95REG);

            } else {

                EnumPtr->State = UE_STATE_ADMINISTRATOR;

            }

            break;

        case UE_STATE_ADMINISTRATOR:
            //
            // Until now, there has been no user named Administrator.
            // Enumerate this account only if the caller wants it.
            //

            if (EnumPtr->WantCreateOnly) {

                pPrepareStructForNextUser (EnumPtr);

                //
                // Enumerate Win95Reg until Administrator is found
                //

                Win95RegGetFirstUser (&EnumPtr->pos, EnumPtr->UserName);

                while (Win95RegHaveUser (&EnumPtr->pos)) {
                    if (pIsAdministratorUserName (EnumPtr->UserName)) {
                        break;
                    }

                    Win95RegGetNextUser (&EnumPtr->pos, EnumPtr->UserName);
                }

                if (Win95RegHaveUser (&EnumPtr->pos)) {
                    //
                    // If an account named Administrator exists, then
                    // don't enumerate it again.
                    //

                    EnumPtr->State = UE_STATE_LOGON_PROMPT;
                    break;

                }

                //
                // We used to set all data from the current user. We don't do that any more.
                // Administrator data is pretty much similar with default user.
                //
                EnumPtr->DefaultUserHive = TRUE;
                StringCopy (EnumPtr->UserName, g_AdministratorStr);
                StringCopy (EnumPtr->AdminUserName, g_AdministratorStr);
                EnumPtr->CreateAccountOnly = TRUE;

                //
                // Now return the user, or default user if the current user is not
                // named.
                //

                pPrepareStructForReturn (EnumPtr, ADMINISTRATOR, UE_STATE_LOGON_PROMPT);

            } else {
                EnumPtr->State = UE_STATE_LOGON_PROMPT;
            }

            break;

        case UE_STATE_LOGON_PROMPT:
            if (EnumPtr->WantLogonPrompt) {
                pPrepareStructForNextUser (EnumPtr);

                EnumPtr->DefaultUserHive = TRUE;
                StringCopy (EnumPtr->UserName, S_DOT_DEFAULT);

                pPrepareStructForReturn (EnumPtr, LOGON_PROMPT, UE_STATE_DEFAULT_USER);

            } else {
                EnumPtr->State = UE_STATE_DEFAULT_USER;
            }

            break;

        case UE_STATE_DEFAULT_USER:
            if (g_ConfigOptions.MigrateDefaultUser) {
                pPrepareStructForNextUser (EnumPtr);

                EnumPtr->DefaultUserHive = TRUE;
                StringCopy (EnumPtr->UserName, S_DEFAULT_USER);

                pPrepareStructForReturn (EnumPtr, DEFAULT_USER, UE_STATE_CLEANUP);

            } else {
                EnumPtr->State = UE_STATE_CLEANUP;
            }

            break;

        case UE_STATE_RETURN:
            EnumPtr->State = EnumPtr->NextState;
            //
            // check if certain conditions are met that would prevent
            // migration of certain user accounts (like ones that share some shell folders)
            //
            if (pUserMigrationDisabled (EnumPtr)) {
                EnumPtr->AccountType |= INVALID_ACCOUNT;
            }
            return TRUE;

        case UE_STATE_CLEANUP:
            if (EnumPtr->UserRegKey) {
                CloseRegKey (EnumPtr->UserRegKey);
            }

            if (EnumPtr->ProfileDirTable) {
                pSetupStringTableDestroy (EnumPtr->ProfileDirTable);
            }

            ZeroMemory (EnumPtr, sizeof (USERENUM));
            EnumPtr->State = UE_STATE_END;
            break;
        }
    }

    return FALSE;
}


VOID
pFixBrokenNetLogonRegistry (
    VOID
    )
{
    HKEY key;
    PCTSTR data;
    TCHAR userName[256];
    DWORD size;

    key = OpenRegKeyStr (TEXT("HKLM\\Network\\Logon"));
    if (key) {
        data = GetRegValueString (key, TEXT("UserName"));
        if (!data) {
            size = ARRAYSIZE(userName);
            if (GetUserName (userName, &size) && (size > 0)) {

                LOG ((
                    LOG_WARNING,
                    "HKLM\\Network\\Logon [UserName] is missing; filling it in with %s",
                    userName
                    ));

                RegSetValueEx (
                    key,
                    TEXT("UserName"),
                    0,
                    REG_SZ,
                    (PBYTE) (userName),
                    SizeOfString (userName)
                    );
            }

        } else {
            FreeMem (data);
        }

        CloseRegKey (key);
    }
}


VOID
pRecordUserDoingTheUpgrade (
    VOID
    )
{
    TCHAR userName[256];
    DWORD size;

    userName[0] = 0;
    size = ARRAYSIZE(userName);
    GetUserName (userName, &size);

    if (userName[0] == 0) {
        StringCopy (userName, g_AdministratorStr);
    }

    MemDbSetValueEx (
        MEMDB_CATEGORY_ADMINISTRATOR_INFO,
        MEMDB_ITEM_AI_USER_DOING_MIG,
        NULL,       // no field
        userName,
        0,
        NULL
        );
}


BOOL
EnumFirstUser (
    OUT     PUSERENUM EnumPtr,
    IN      DWORD Flags
    )

/*++

Routine Description:

  EnumFirstUser begins the enumeration of all users to be migrated.  This
  includes all named users (even ones with broken registries), the
  Administrator account, the logon prompt account, and the Default User
  account.

Arguments:

  EnumPtr - Receives the enumerated user attributes
  Flags   - Specifies any of the following flags:

            ENUMUSER_ENABLE_NAME_FIX - Caller wants the fixed versions of
                                       the user names
            ENUMUSER_DO_NOT_MAP_HIVE - Caller wants fast enumeration (no
                                       registry hive map)
            ENUMUSER_ADMINISTRATOR_ALWAYS - Caller wants the Administrator
                                            account, even if a user is
                                            not named Administrator
            ENUMUSER_INCLUDE_LOGON_PROMPT - Caller wants the logon prompt
                                            account


Return Value:

  TRUE if a user was enumerated, or FALSE if not.

--*/

{
    //
    // first initialize the enumeration engine
    //
    if (!(g_UserEnumFlags & UE_INITIALIZED)) {
        g_UserEnumFlags |= UE_INITIALIZED;
        pFixBrokenNetLogonRegistry ();
        pRecordUserDoingTheUpgrade ();
        pCheckShellFoldersCollision ();
    }
    //
    // Init enum struct
    //

    ZeroMemory (EnumPtr, sizeof (USERENUM));

    //
    // Separate the flags
    //

    EnumPtr->EnableNameFix   = (Flags & ENUMUSER_ENABLE_NAME_FIX) != 0;
    EnumPtr->DoNotMapHive    = (Flags & ENUMUSER_DO_NOT_MAP_HIVE) != 0;
    EnumPtr->WantCreateOnly  = (Flags & ENUMUSER_ADMINISTRATOR_ALWAYS) != 0;
    EnumPtr->WantLogonPrompt = (Flags & ENUMUSER_NO_LOGON_PROMPT) == 0;

    //
    // Init the state machine
    //

    EnumPtr->State = UE_STATE_INIT;

    //
    // Enum the next item
    //

    return pUserEnumWorker (EnumPtr);
}


BOOL
EnumNextUser (
    IN OUT  PUSERENUM EnumPtr
    )
{
    return pUserEnumWorker (EnumPtr);
}


VOID
EnumUserAbort (
    IN OUT  PUSERENUM EnumPtr
    )
{
    if (EnumPtr->State != UE_STATE_END &&
        EnumPtr->State != UE_STATE_INIT
        ) {
        EnumPtr->State = UE_STATE_CLEANUP;
        pUserEnumWorker (EnumPtr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\hwcomp\hwcomp.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    hwcomp.c

Abstract:

    Win95 to NT hardware device comparison routines.

Author:

    Jim Schmidt (jimschm) 8-Jul-1996

Revision History:

    marcw    28-Jun-1999    Added HwComp_MakeLocalSourceDeviceExists
    jimschm  04-Dec-1998    Fixed checksum problem caused by date rounding
    jimschm  29-Sep-1998    Fixed incompatible hardware message to use proper roots
    jimschm  28-Apr-1998    Support for description-less hardware
    jimschm  01-Apr-1998    Added %1 to (not currently present) message
    jimschm  27-Feb-1998    Added suppression of (not currently present) devices
    marcw    11-Nov-1997    Minor change to ensure that we can find the dial-up adapter.
    jimschm  03-Nov-1997    Revised to use GROWBUFs and project's reg api
    jimschm  08-Oct-1997    Added legacy keyboard support
    marcw    18-Sep-1997    Added some fields to netcard enumerator
    jimschm  24-Jun-1997    Added net card enumerator
    marcw    05-May-1997    Fixed problem with looking for usable hdd. Need to
                            look for "diskdrive" class instead of "hdc" class.
    marcw    18-Apr-1997    Added ability to determine if a CdRom and Hdd
                            compatible with Windows Nt is online.
    marcw    14-Apr-1997    Retrofitted new progress bar handling code in.
    jimschm   2-Jan-1997    Added INF verification to hwcomp.dat
                            to automatically detect when an OEM
                            changes one or more INFs

--*/

#include "pch.h"
#include "hwcompp.h"
#include <cfgmgr32.h>


#define DBG_HWCOMP  "HwComp"

#ifdef UNICODE
#error "hwcomp.c cannot be compiled as UNICODE"
#endif

#define S_HWCOMP_DAT        TEXT("hwcomp.dat")
#define S_HKLM_ENUM         TEXT("HKLM\\Enum")
#define S_HARDWAREID        TEXT("HardwareID")
#define S_COMPATIBLEIDS     TEXT("CompatibleIDs")
#define S_CLASS             TEXT("Class")
#define S_MANUFACTURER      TEXT("Manufacturer")
#define S_IGNORE_THIS_FILE  TEXT("*")

#define PNPID_FIELD     2


#define DECLARE(varname,text)   text,

PCTSTR g_DeviceFields[] = {
    DEVICE_FIELDS /* , */
    NULL
};

#undef DECLARE


GROWBUFFER g_FileNames = GROWBUF_INIT;
GROWBUFFER g_DecompFileNames = GROWBUF_INIT;
HASHTABLE g_PnpIdTable;
HASHTABLE g_UnsupPnpIdTable;
HASHTABLE g_ForceBadIdTable;
HASHTABLE g_InfFileTable;
HASHTABLE g_NeededHardwareIds;
HASHTABLE g_UiSuppliedIds;
BOOL g_ValidWinDir;
BOOL g_ValidSysDrive;
BOOL g_IncompatibleScsiDevice = FALSE;
BOOL g_ValidCdRom;
BOOL g_FoundPnp8387;
PPARSEDPATTERN g_PatternCompatibleIDsTable;

typedef enum {
    HW_INCOMPATIBLE,
    HW_REINSTALL,
    HW_UNSUPPORTED
} HWTYPES;

static PCTSTR g_ExcludeTable[] = {
    TEXT("wkstamig.inf"),
    TEXT("desktop.inf"),
    TEXT("usermig.inf"),
    TEXT("dosnet.inf"),
    TEXT("pad.inf"),
    TEXT("msmail.inf"),
    TEXT("wordpad.inf"),
    TEXT("syssetup.inf"),
    TEXT("pinball.inf"),
    TEXT("perms.inf"),
    TEXT("optional.inf"),
    TEXT("multimed.inf"),
    TEXT("mmopt.inf"),
    TEXT("layout.inf"),
    TEXT("kbd.inf"),
    TEXT("iexplore.inf"),
    TEXT("intl.inf"),
    TEXT("imagevue.inf"),
    TEXT("games.inf"),
    TEXT("font.inf"),
    TEXT("communic.inf"),
    TEXT("apps.inf"),
    TEXT("accessor.inf"),
    TEXT("mailnews.inf"),
    TEXT("cchat.inf"),
    TEXT("iermv2.inf"),
    TEXT("default.inf"),
    TEXT("setup16.inf"),
    TEXT("")
};

BOOL
GetFileNames (
    IN      PCTSTR *InfDirs,
    IN      UINT InfDirCount,
    IN      BOOL QueryFlag,
    IN OUT  PGROWBUFFER FileNames,
    IN OUT  PGROWBUFFER DecompFileNames
    );


VOID
FreeFileNames (
    IN      PGROWBUFFER FileNames,
    IN      PGROWBUFFER DecompFileNames,
    IN      BOOL QueryFlag
    );

VOID
pFreeHwCompDatName (
    PCTSTR Name
    );

BOOL
pIsInfFileExcluded (
    PCTSTR FileNamePtr
    );

BOOL
pGetFileNamesWorker (
    IN OUT  PGROWBUFFER FileNames,
    IN OUT  PGROWBUFFER DecompFileNames,
    IN      PCTSTR InfDir,
    IN      BOOL QueryFlag
    );

BOOL
pIsDeviceConsideredCompatible (
    PCTSTR DevIds
    );

BOOL
pFindForcedBadHardwareId (
    IN      PCTSTR PnpIdList,
    OUT     PTSTR InfFileName       OPTIONAL
    );

//
// Implementation
//

BOOL
WINAPI
HwComp_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD dwReason,
    IN LPVOID lpv
    )

/*++

Routine Description:

  HwComp_Entry initializes the hwcomp library. It does what would normally
  happen if this were a standalone dll, as opposed to a library.


  At process detach, the device buffer is freed if necessary.

Arguments:

  hinstDLL - (OS-supplied) instance handle for the DLL
  dwReason - (OS-supplied) indicates attach or detatch from process or
             thread
  lpv      - unused

Return Value:

  Return value is always TRUE (indicating successful init).

--*/

{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_UiSuppliedIds = HtAlloc();

        if (!g_UiSuppliedIds) {
            DEBUGMSG ((DBG_ERROR, "HwComp_Entry: Can't create g_UiSuppliedIds"));
            return FALSE;
        }

        break;


    case DLL_PROCESS_DETACH:
        DEBUGMSG_IF ((
            g_EnumsActive,
            DBG_ERROR,
            "%u hardware enumerations still active",
            g_EnumsActive
            ));

        DEBUGMSG_IF ((
            g_NetEnumsActive,
            DBG_ERROR,
            "%u network hardware enumerations still active",
            g_NetEnumsActive
            ));

        FreeNtHardwareList();

        if (g_NeededHardwareIds) {
            HtFree (g_NeededHardwareIds);
            g_NeededHardwareIds = NULL;
        }

        if (g_UiSuppliedIds) {
            HtFree (g_UiSuppliedIds);
            g_UiSuppliedIds = NULL;
        }

        if (g_PatternCompatibleIDsTable) {
            DestroyParsedPattern (g_PatternCompatibleIDsTable);
            g_PatternCompatibleIDsTable = NULL;
        }

        break;
    }

    return TRUE;
}



PCTSTR
pGetHwCompDat (
    IN      PCTSTR SourceDir,
    IN      BOOL MustExist
    )

/*++

Routine Description:

  GetHwCompDat builds e:\i386\hwcomp.dat, where e:\i386 is specified in
  SourceDir.  The caller must call pFreeHwCompDatName to clean up the
  memory allocation.

Arguments:

  SourceDir - The directory holding hwcomp.dat

  MustExist - Specifies TRUE if hwcomp.dat must exist as specified,
              or FALSE if hwcomp.dat does not necessarily exist.

Return Value:

  MustExist = TRUE:
        A pointer to a string, or NULL hwcomp.dat does not exist as
        specified, or if allocation failed.

  MustExist = FALSE:
        A pointer to a string, or NULL if a memory allocation failed.

  Caller must free the string via pFreeHwCompDatName.

--*/

{
    PTSTR FileName;

    if (SourceDir) {
        FileName = JoinPaths (SourceDir, S_HWCOMP_DAT);
    } else {
        FileName = DuplicatePathString (S_HWCOMP_DAT, 0);
    }

    if (MustExist && GetFileAttributes (FileName) == 0xffffffff) {
        pFreeHwCompDatName (FileName);
        return NULL;
    }

    return FileName;
}


VOID
pFreeHwCompDatName (
    PCTSTR Name
    )
{
    if (Name) {
        FreePathString (Name);
    }
}


//
// Routines for accessing the registry
//

PVOID
pPrivateRegValAllocator (
    DWORD Size
    )
{
    return AllocText (Size);
}

VOID
pPrivateRegValDeallocator (
    PCVOID Mem
    )
{
    FreeText (Mem);
}


PCTSTR
pGetAltDeviceDesc (
    PCTSTR DriverSubKey
    )
{
    TCHAR DriverKey[MAX_REGISTRY_KEY];
    HKEY Key;
    PCTSTR Data;
    PTSTR ReturnText = NULL;

    if (!DriverSubKey) {
        return NULL;
    }

    //
    // Get driver key
    //

    wsprintf (DriverKey, TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class\\%s"), DriverSubKey);

    Key = OpenRegKeyStr (DriverKey);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueString (Key, TEXT("DriverDesc"));

    CloseRegKey (Key);

    if (Data) {
        ReturnText = pPrivateRegValAllocator (SizeOfString (Data));
        if (ReturnText) {
            StringCopy (ReturnText, Data);
        }
        MemFree (g_hHeap, 0, Data);
    }

    return ReturnText;
}


VOID
pGetRegValText (
    HKEY Key,
    PCTSTR VarText,
    PCTSTR *RetPtr
    )
{
    MYASSERT (!(*RetPtr));
    *RetPtr = (PCTSTR) GetRegValueDataOfType2 (
                            Key,
                            VarText,
                            REG_SZ,
                            pPrivateRegValAllocator,
                            pPrivateRegValDeallocator
                            );
}


VOID
pFreeRegValText (
    PHARDWARE_ENUM EnumPtr
    )
{
    //
    // Free all device field text
    //

#define DECLARE(varname,text)  pPrivateRegValDeallocator((PVOID) EnumPtr->varname); EnumPtr->varname = NULL;
    DEVICE_FIELDS
#undef DECLARE

}


VOID
pGetAllRegVals (
    PHARDWARE_ENUM EnumPtr
    )
{
    PCTSTR AltDesc;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PTSTR BetterDesc = NULL;
    TCHAR PnpId[MAX_PNP_ID];
    PCTSTR PnpIdList;
    PCTSTR OldDesc;
    PCTSTR p;
    PCTSTR end;
    PCTSTR start;
    PTSTR newBuf;
    PTSTR ptr;
    CHARTYPE ch;

#define DECLARE(varname,text)  if(!EnumPtr->varname) {                                  \
                                    pGetRegValText (                                    \
                                        EnumPtr->ek.CurrentKey->KeyHandle,              \
                                        text,                                           \
                                        &EnumPtr->varname                               \
                                        );                                              \
                               }                                                        \

    DEVICE_FIELDS

#undef DECLARE

    //
    // If there is a better name for this device, use it
    //

    PnpIdList = EnumPtr->HardwareID;

    while (PnpIdList && *PnpIdList) {
        PnpIdList = ExtractPnpId (PnpIdList, PnpId);

        if (*PnpId) {

            if (InfFindFirstLine (g_Win95UpgInf, S_PNP_DESCRIPTIONS, PnpId, &is)) {
                AltDesc = InfGetStringField (&is, 1);

                if (AltDesc) {
                    OldDesc = EnumPtr->DeviceDesc;

                    BetterDesc = (PTSTR) pPrivateRegValAllocator (SizeOfString (AltDesc));
                    StringCopy (BetterDesc, AltDesc);
                    EnumPtr->DeviceDesc = BetterDesc;

                    DEBUGMSG ((
                        DBG_HWCOMP,
                        "Using %s for description (instead of %s)",
                        BetterDesc,
                        OldDesc
                        ));

                    pPrivateRegValDeallocator ((PVOID) OldDesc);
                    break;
                }
                ELSE_DEBUGMSG ((DBG_WHOOPS, "Better description could not be retrieved"));
            }
        }
    }

    //
    // Workaround: if the device description is bad, use the driver
    //             description if it is available
    //

    if (!BetterDesc) {

        if (!EnumPtr->DeviceDesc || CharCount (EnumPtr->DeviceDesc) < 5) {

            AltDesc = pGetAltDeviceDesc (EnumPtr->Driver);
            if (AltDesc) {
                pPrivateRegValDeallocator ((PVOID) EnumPtr->DeviceDesc);
                EnumPtr->DeviceDesc = AltDesc;
            }
        }

        //
        // Fix leading/trail space problems
        //

        if (EnumPtr->DeviceDesc) {

            start = SkipSpace (EnumPtr->DeviceDesc);

            end = GetEndOfString (start);
            p = SkipSpaceR (start, end);

            if (p && (p != end || start != EnumPtr->DeviceDesc)) {

                p = _tcsinc (p);

                newBuf = pPrivateRegValAllocator (
                                (PBYTE) (p + 1) - (PBYTE) start
                                );
                StringCopyAB (newBuf, start, p);

                pPrivateRegValDeallocator ((PVOID) EnumPtr->DeviceDesc);
                EnumPtr->DeviceDesc = newBuf;
            }
        }

        //
        // Eliminate newline chars inside description; replace \r or \n with a space
        // the replacement occurs inplace, so chars will be replaced inplace
        //

        if (EnumPtr->DeviceDesc) {

            for (ptr = (PTSTR)EnumPtr->DeviceDesc; *ptr; ptr = _tcsinc (ptr)) {
                ch = _tcsnextc (ptr);
                if (!_istprint (ch)) {
                    //
                    // in this case it's a single TCHAR, just replace it inplace
                    //
                    MYASSERT (*ptr == (TCHAR)ch);
                    *ptr = TEXT(' ');
                }
            }
        }
    }

    InfCleanUpInfStruct (&is);
}


BOOL
pGetPnpIdList (
    IN      PINFSTRUCT is,
    OUT     PTSTR Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  pGetPnpIdList is similar to SetupGetMultiSzField, except it supports
  skipping of blank fields.

Arguments:

  is     - Specifies the INFSTRUCT that indicates the line being processed.
  Buffer - Receives the multi-sz ID list.
  Size   - Specifies the size of Buffer.

Return Value:

  TRUE if one or more PNP ID fields exist, or FALSE if none exist.

--*/

{
    UINT FieldCount;
    UINT Field;
    PTSTR p;
    PTSTR End;
    PCTSTR FieldStr;

    p = Buffer;
    End = (PTSTR) ((PBYTE) Buffer + Size);
    End--;

    FieldCount = InfGetFieldCount (is);

    if (FieldCount < PNPID_FIELD) {
        return FALSE;
    }

    for (Field = PNPID_FIELD ; Field <= FieldCount ; Field++) {
        FieldStr = InfGetStringField (is, Field);
        if (FieldStr && *FieldStr) {
            if (SizeOfString (FieldStr) > (UINT) (End - p)) {
                DEBUGMSG ((DBG_WHOOPS, "PNP ID list is bigger than %u bytes", Size));
                break;
            }

            StringCopy (p, FieldStr);
            p = GetEndOfString (p) + 1;
        }
    }

    *p = 0;
    return TRUE;
}



/*++

Routine Description:

  BeginHardwareEnum initializes a structure for enumeration of all hardware
  configuration registry values.  Call BeginHardwareEnum, followed by
  either NextHardwareEnum or AbortHardwareEnum.

Arguments:

  EnumPtr - Receives the next enumerated item

Return Value:

  TRUE if the supplied enumeration structure was filled, or FALSE if
  there are no hardware items (unlikely) or an error occurred.
  GetLastError() will provide the failure reason or ERROR_SUCCESS.

--*/

BOOL
RealEnumFirstHardware (
    OUT     PHARDWARE_ENUM EnumPtr,
    IN      TYPE_OF_ENUM TypeOfEnum,
    IN      DWORD EnumFlags
    )
{
    //
    // If string tables have not been created, create them
    // before enumerating.
    //

    if (TypeOfEnum != ENUM_ALL_DEVICES) {
        if (!g_PnpIdTable || !g_UnsupPnpIdTable || !g_InfFileTable || !g_ForceBadIdTable) {
            if (!CreateNtHardwareList (
                    SOURCEDIRECTORYARRAY(),
                    SOURCEDIRECTORYCOUNT(),
                    NULL,
                    REGULAR_OUTPUT
                    )) {

                LOG ((
                    LOG_ERROR,
                    "Unable to create NT hardware list "
                        "(required for hardware enumeration)"
                    ));

                return FALSE;
            }
        }
    }

    START_ENUM;

    //
    // Init enum struct
    //
    ZeroMemory (EnumPtr, sizeof (HARDWARE_ENUM));
    EnumPtr->State = STATE_ENUM_FIRST_KEY;
    EnumPtr->TypeOfEnum = TypeOfEnum;
    EnumPtr->EnumFlags = EnumFlags;

    //
    // Call NextHardwareEnum to fill in rest of struct
    //

    return RealEnumNextHardware (EnumPtr);
}


VOID
pGenerateTapeIds (
    IN OUT  PGROWBUFFER HackBuf,
    IN      PCTSTR PnpIdList
    )

/*++

Routine Description:

  pGenerateTapeIds creates two IDs based on the IDs given by the caller.  The
  first created ID is the caller's ID prefixed with Sequential.  The second
  created ID is the caller's ID prefixed with Sequential and without the
  revision character.  These new IDs match the tape IDs that NT supports.

Arguments:

  HackBuf   - Specifies a buffer that holds the new IDs, in a multi-sz.  It
              may have some initial IDs in it.  Receives additional IDs.
  PnpIdList - Specifies the ID list (either a hardware ID list or compatible
              ID list).

Return Value:

  None.

--*/

{
    TCHAR PnpId[MAX_PNP_ID];
    TCHAR HackedPnpIdBuf[MAX_PNP_ID + 32];
    PTSTR HackedPnpId;
    PTSTR p;

    if (PnpIdList) {

        while (*PnpIdList) {
            PnpIdList = ExtractPnpId (PnpIdList, PnpId);

            //
            // Ignore PNP IDs that specify the root enumerator, or that
            // begin with Gen and don't have an underscore (such as GenDisk)
            //

            *HackedPnpIdBuf = 0;

            if (StringIMatchCharCount (TEXT("SCSI\\"), PnpId, 5)) {
                MoveMemory (PnpId, PnpId + 5, SizeOfString (PnpId + 5));
                HackedPnpId = _tcsappend (HackedPnpIdBuf, TEXT("SCSI\\"));
            } else {
                HackedPnpId = HackedPnpIdBuf;
            }

            if (_tcschr (PnpId, TEXT('\\'))) {
                continue;
            }

            if (StringIMatchCharCount (PnpId, TEXT("Gen"), 3) &&
                !_tcschr (PnpId, TEXT('_'))
                ) {
                continue;
            }

            //
            // Add another ID with Sequential
            //

            wsprintf (HackedPnpId, TEXT("Sequential%s"), PnpId);
            MultiSzAppend (HackBuf, HackedPnpIdBuf);

            //
            // Add another ID with Sequential and without the single
            // character revision
            //

            p = GetEndOfString (HackedPnpId);
            p = _tcsdec (HackedPnpId, p);
            *p = 0;
            MultiSzAppend (HackBuf, HackedPnpIdBuf);
        }
    }
}


BOOL
pIsMultiFunctionDevice (
    IN      PCTSTR PnpIdList        OPTIONAL
    )

/*++

Routine Description:

  pIsMultiFunctionDevice scans the caller-supplied list of PNP IDs for one
  that starts with MF\.  This prefix indicates the multi-function enumerator
  root.

Arguments:

  PnpIdList - Specifies the comma-separated list of PNP IDs

Return Value:

  TRUE if a multi-function ID is in the list, FALSE otherwise.

--*/

{
    TCHAR PnpId[MAX_PNP_ID];
    BOOL b = FALSE;

    if (PnpIdList) {
        while (*PnpIdList) {
            PnpIdList = ExtractPnpId (PnpIdList, PnpId);
            if (StringIMatchCharCount (TEXT("MF\\"), PnpId, 3)) {
                b = TRUE;
                break;
            }
        }
    }

    return b;
}


BOOL
pGenerateMultiFunctionIDs (
    IN OUT  PGROWBUFFER IdList,
    IN      PCTSTR EncodedDevicePath
    )

/*++

Routine Description:

  pGenerateMultiFunctionIDs locates the device node for the device related to
  the multi-function node.  If a device node is found, all of its IDs (both
  hardware IDs and compatible IDs) are added to the multi-function device as
  compatible IDs.

Arguments:

  IdList            - Specifies an initialized grow buffer that has zero or
                      more multi-sz strings. Receives additional multi-sz
                      entries.
  EncodedDevicePath - Specifies a device path in the form of
                      Root&Device&Instance, as obtained from the
                      multi-function dev node key name.

Return Value:

  TRUE if the multi-function device has a master device, FALSE otherwise.

--*/

{
    HKEY Parent;
    HKEY Key;
    BOOL b = FALSE;
    TCHAR DevicePathCopy[MAX_REGISTRY_KEY];
    PCTSTR Start;
    PTSTR End;
    TCHAR c;
    PCTSTR Data;
    PTSTR q;

    //
    // Multifunction devices have IDs in the form of:
    //
    //  MF\CHILDxxxx\Root&Device&Instance
    //
    // Find the original device by parsing this string.
    //

    Parent = OpenRegKeyStr (S_HKLM_ENUM);
    if (!Parent) {
        return FALSE;
    }

    StringCopy (DevicePathCopy, EncodedDevicePath);
    Start = DevicePathCopy;

    End = _tcschr (Start, TEXT('&'));

    for (;;) {

        if (!End) {
            c = 0;
        } else {
             c = *End;
            *End = 0;
        }

        Key = OpenRegKey (Parent, Start);

        if (Key) {

            //
            // Key exists.  Close the parent, and begin
            // using the current key as the parent. Then
            // continue parsing if necessary.
            //

            CloseRegKey (Parent);
            Parent = Key;

            if (!c) {
                b = TRUE;
                break;
            }

            *End = TEXT('\\');          // turns DevicePathCopy into a subkey path

            Start = End + 1;
            End = _tcschr (Start, TEXT('&'));

        } else if (c) {

            //
            // Key does not exist, try breaking at the
            // next ampersand.
            //

            *End = c;
            End = _tcschr (End + 1, TEXT('&'));

        } else {

            //
            // Nothing left, key was not found
            //

            MYASSERT (!End);
            break;

        }
    }

    if (b) {

        DEBUGMSG ((DBG_HWCOMP, "Parsed MF device node is %s", DevicePathCopy));

        //
        // Now get all the IDs for this device
        //

        q = (PTSTR) IdList->Buf;

        Data = GetRegValueString (Parent, S_HARDWAREID);
        if (Data) {
            MultiSzAppend (IdList, Data);
            MemFree (g_hHeap, 0, Data);
        }

        Data = GetRegValueString (Parent, S_COMPATIBLEIDS);
        if (Data) {
            MultiSzAppend (IdList, Data);
            MemFree (g_hHeap, 0, Data);
        }

        //
        // Convert commas into nuls, because we are passing
        // back a multi-sz.
        //

        if (!q) {
            q = (PTSTR) IdList->Buf;
        }

        End = (PTSTR) (IdList->Buf + IdList->End);

        while (q < End) {
            if (_tcsnextc (q) == TEXT(',')) {
                *q = 0;
            }
            q = _tcsinc (q);
        }

        //
        // Do not double-terminate the multi-sz yet.  The caller
        // may want to append more IDs to the list.
        //
    }

    CloseRegKey (Parent);

    return b;
}



/*++

Routine Description:

  NextHardwareEnum returns the next registry value related to hardware
  configuration.

Arguments:

  EnumPtr - Specifies the current enumeration structure

Return Value:

  TRUE if the supplied enumeration structure was filled, or FALSE if
  there are no hardware items (unlikely) or an error occurred.
  GetLastError() will provide the failure reason or ERROR_SUCCESS.

--*/

BOOL
RealEnumNextHardware (
    IN OUT  PHARDWARE_ENUM EnumPtr
    )
{
    TCHAR InstanceBuf[MAX_REGISTRY_KEY];
    PTSTR p;
    GROWBUFFER HackBuf = GROWBUF_INIT;
    MULTISZ_ENUM e;
    PTSTR NewBuf;
    BOOL TapeDevice;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR pattern;

    for (;;) {
        switch (EnumPtr->State) {

        case STATE_ENUM_FIRST_KEY:
            EnumPtr->State = STATE_ENUM_CHECK_KEY;

            if (!EnumFirstRegKeyInTree (&EnumPtr->ek, S_HKLM_ENUM)) {
                END_ENUM;
                return FALSE;
            }

            break;


        case STATE_ENUM_NEXT_KEY:
            EnumPtr->State = STATE_ENUM_CHECK_KEY;

            if (!EnumNextRegKeyInTree (&EnumPtr->ek)) {
                END_ENUM;
                return FALSE;
            }

            break;

        case STATE_ENUM_CHECK_KEY:
            EnumPtr->State = STATE_ENUM_FIRST_VALUE;

            if (InfFindFirstLine (g_Win95UpgInf, S_IGNORE_REG_KEY, NULL, &is)) {
                do {
                    pattern = InfGetStringField (&is, 1);

                    if (pattern && IsPatternMatch (pattern, EnumPtr->ek.FullKeyName)) {
                        DEBUGMSG ((DBG_WARNING, "Hardware key %s is excluded", EnumPtr->ek.FullKeyName));

                        EnumPtr->State = STATE_ENUM_NEXT_KEY;
                        break;
                    }
                } while (InfFindNextLine (&is));

                InfCleanUpInfStruct (&is);
            }
            break;

        case STATE_ENUM_FIRST_VALUE:
            if (!EnumFirstRegValue (
                    &EnumPtr->ev,
                    EnumPtr->ek.CurrentKey->KeyHandle
                    )) {
                EnumPtr->State = STATE_ENUM_NEXT_KEY;
            } else {
                EnumPtr->State = STATE_EVALUATE_VALUE;
            }

            break;

        case STATE_ENUM_NEXT_VALUE:
            if (!EnumNextRegValue (&EnumPtr->ev)) {
                EnumPtr->State = STATE_ENUM_NEXT_KEY;
            } else {
                EnumPtr->State = STATE_EVALUATE_VALUE;
            }

            break;

        case STATE_EVALUATE_VALUE:
            if (StringIMatch (EnumPtr->ev.ValueName, S_CLASS)) {
                //
                // Match found: fill struct with data
                //

                EnumPtr->State = STATE_VALUE_CLEANUP;

                //
                // Get HardwareID and CompatibleIDs
                //

                pGetRegValText (
                    EnumPtr->ek.CurrentKey->KeyHandle,
                    S_HARDWAREID,
                    &EnumPtr->HardwareID
                    );

                pGetRegValText (
                    EnumPtr->ek.CurrentKey->KeyHandle,
                    S_COMPATIBLEIDS,
                    &EnumPtr->CompatibleIDs
                    );

                //
                // Special case: flip hardware ID and compatible IDs
                // if we don't have a hardware ID but we do have a
                // compatible ID
                //

                if (!EnumPtr->HardwareID && EnumPtr->CompatibleIDs) {
                    DEBUGMSG ((
                        DBG_WARNING,
                        "Reversing hardware and compatible IDs for %s",
                        EnumPtr->CompatibleIDs
                        ));

                    EnumPtr->HardwareID = EnumPtr->CompatibleIDs;
                    EnumPtr->CompatibleIDs = NULL;
                }

                //
                // Multifunction device special case
                //

                if (pIsMultiFunctionDevice (EnumPtr->HardwareID)) {
                    //
                    // Multifunction devices have IDs in the form of:
                    //
                    //  MF\CHILDxxxx\Root&Device&Instance
                    //
                    // Find the original device by parsing this string.
                    //

                    pGenerateMultiFunctionIDs (
                        &HackBuf,
                        EnumPtr->ek.CurrentKey->KeyName
                        );

                }

                //
                // Tape device special case
                //

                else if (_tcsistr (EnumPtr->ek.FullKeyName, TEXT("SCSI"))) {

                    pGetRegValText (
                        EnumPtr->ek.CurrentKey->KeyHandle,
                        S_CLASS,
                        &EnumPtr->Class
                        );

                    TapeDevice = FALSE;

                    if (!EnumPtr->Class) {
                        TapeDevice = TRUE;
                    } else if (_tcsistr (EnumPtr->Class, TEXT("tape"))) {
                        TapeDevice = TRUE;
                    }
                    ELSE_DEBUGMSG ((
                        DBG_VERBOSE,
                        "SCSI device class %s is not a tape device",
                        EnumPtr->Class
                        ));

                    if (TapeDevice) {

                        //
                        // For tape devices in the SCSI enumerator, we must create
                        // extra compatible IDs.  For each ID, we add two more,
                        // both prefixed with Sequential, and one with its revision
                        // number stripped off.
                        //

                        pGenerateTapeIds (&HackBuf, EnumPtr->HardwareID);
                        pGenerateTapeIds (&HackBuf, EnumPtr->CompatibleIDs);

                        DEBUGMSG_IF ((
                            HackBuf.End,
                            DBG_HWCOMP,
                            "Tape Device detected, fixing PNP IDs."
                            ));

                        DEBUGMSG_IF ((
                            !HackBuf.End,
                            DBG_VERBOSE,
                            "Tape Device detected, but no IDs to fix.\n"
                                "Hardware ID: %s\n"
                                "Compatible IDs: %s",
                            EnumPtr->HardwareID,
                            EnumPtr->CompatibleIDs
                            ));
                    }
                }

                //
                // Add all IDs in HackBuf (a multi-sz) to the compatible
                // ID list.
                //

                if (HackBuf.End) {
                    MultiSzAppend (&HackBuf, S_EMPTY);

                    if (EnumPtr->CompatibleIDs) {

                        NewBuf = pPrivateRegValAllocator (
                                    ByteCount (EnumPtr->CompatibleIDs) +
                                        HackBuf.End
                                    );

                        StringCopy (NewBuf, EnumPtr->CompatibleIDs);

                    } else {
                        NewBuf = pPrivateRegValAllocator (HackBuf.End);
                        *NewBuf = 0;
                    }

                    p = GetEndOfString (NewBuf);

                    if (EnumFirstMultiSz (&e, (PCTSTR) HackBuf.Buf)) {
                        do {

                            if (p != NewBuf) {
                                p = _tcsappend (p, TEXT(","));
                            }

                            p = _tcsappend (p, e.CurrentString);

                        } while (EnumNextMultiSz (&e));
                    }

                    DEBUGMSG ((
                        DBG_HWCOMP,
                        "Hardware ID: %s\n"
                            "Old compatible ID list: %s\n"
                            "New compatible ID list: %s",
                        EnumPtr->HardwareID,
                        EnumPtr->CompatibleIDs,
                        NewBuf
                        ));

                    if (EnumPtr->CompatibleIDs) {
                        pPrivateRegValDeallocator ((PVOID) EnumPtr->CompatibleIDs);
                    }

                    EnumPtr->CompatibleIDs = NewBuf;

                    FreeGrowBuffer (&HackBuf);
                }

                //
                // Unless the user specified that the hardware ID was not required, break if it does not
                // exist.
                //
                if (!EnumPtr->HardwareID && !(EnumPtr->EnumFlags & ENUM_DONT_REQUIRE_HARDWAREID)) {
                    break;
                }


                //
                // Process enumeration filter
                //

                if ((EnumPtr->EnumFlags & ENUM_WANT_COMPATIBLE_FLAG) ||
                    (EnumPtr->TypeOfEnum != ENUM_ALL_DEVICES)
                    ) {

                    EnumPtr->HardwareIdCompatible = FindHardwareId (EnumPtr->HardwareID, NULL);
                    EnumPtr->CompatibleIdCompatible = FindHardwareId (EnumPtr->CompatibleIDs, NULL);
                    EnumPtr->HardwareIdUnsupported = FindUnsupportedHardwareId (EnumPtr->HardwareID, NULL);
                    EnumPtr->CompatibleIdUnsupported = FindUnsupportedHardwareId (EnumPtr->CompatibleIDs, NULL);

                    //
                    // Process UI-based IDs and unsupported IDs
                    //

                    if (EnumPtr->EnumFlags & ENUM_USER_SUPPLIED_FLAG_NEEDED) {
                        EnumPtr->SuppliedByUi = FindUserSuppliedDriver (EnumPtr->HardwareID, EnumPtr->CompatibleIDs);
                    }

                    if (EnumPtr->EnumFlags & ENUM_DONT_WANT_USER_SUPPLIED) {
                        if (EnumPtr->SuppliedByUi) {
                            break;
                        }
                    }

                    if (EnumPtr->EnumFlags & ENUM_WANT_USER_SUPPLIED_ONLY) {
                        if (!EnumPtr->SuppliedByUi) {
                            break;
                        }
                    }

                    EnumPtr->Compatible = EnumPtr->HardwareIdCompatible ||
                                          EnumPtr->CompatibleIdCompatible;

                    EnumPtr->Unsupported = EnumPtr->HardwareIdUnsupported ||
                                           EnumPtr->CompatibleIdUnsupported;

                    //
                    // This logic is broken for a USB device that has both
                    // unsupported and compatible IDs in its hardware ID list.
                    //
                    // Removing this if statement causes that device to be
                    // reported as unsupported.
                    //
                    //if (EnumPtr->HardwareIdCompatible) {
                    //    EnumPtr->Unsupported = FALSE;
                    //}

                    if (EnumPtr->Unsupported) {
                        EnumPtr->Compatible = FALSE;
                    }

                    //
                    // Special case: force incompatible?  If so, we indicate
                    // this only by modifying the abstract Compatible flag.
                    //

                    if (pFindForcedBadHardwareId (EnumPtr->HardwareID, NULL) ||
                        pFindForcedBadHardwareId (EnumPtr->CompatibleIDs, NULL)
                        ) {

                        EnumPtr->Compatible = FALSE;
                    }

                    //
                    // Continue enumerating if this device does not fit the
                    // caller's request.
                    //

                    if (EnumPtr->TypeOfEnum == ENUM_COMPATIBLE_DEVICES) {
                        if (!EnumPtr->Compatible) {
                            break;
                        }
                    } else if (EnumPtr->TypeOfEnum == ENUM_INCOMPATIBLE_DEVICES) {
                        if (EnumPtr->Compatible || EnumPtr->Unsupported) {
                            break;
                        }
                    } else if (EnumPtr->TypeOfEnum == ENUM_UNSUPPORTED_DEVICES) {
                        if (!EnumPtr->Unsupported) {
                            break;
                        }
                    } else if (EnumPtr->TypeOfEnum == ENUM_NON_FUNCTIONAL_DEVICES) {
                        if (EnumPtr->Compatible) {
                            break;
                        }
                    }
                }

                //
                // Copy reg key to struct
                //

                StringCopy (InstanceBuf, EnumPtr->ek.FullKeyName);
                p = _tcschr (InstanceBuf, TEXT('\\'));
                MYASSERT(p);
                if (p) {
                    p = _tcschr (_tcsinc (p), TEXT('\\'));
                    MYASSERT(p);
                }
                if (p) {
                    p = _tcschr (_tcsinc (p), TEXT('\\'));
                    MYASSERT(p);
                }
                if (p) {
                    p = _tcsinc (p);
                }

                EnumPtr->InstanceId = DuplicateText (p);
                EnumPtr->FullKey    = EnumPtr->ek.FullKeyName;
                EnumPtr->KeyHandle  = EnumPtr->ek.CurrentKey->KeyHandle;

                //
                // Get all fields; require Class field
                //

                if (!(EnumPtr->EnumFlags & ENUM_DONT_WANT_DEV_FIELDS)) {
                    pGetAllRegVals (EnumPtr);
                    if (!EnumPtr->Class) {

                        DEBUGMSG ((
                            DBG_HWCOMP,
                            "Device %s does not have a Class field",
                            EnumPtr->InstanceId
                            ));

                        break;
                    }
                }

                //
                // Determine if device is online
                //

                if (EnumPtr->EnumFlags & ENUM_WANT_ONLINE_FLAG) {
                    EnumPtr->Online = IsPnpIdOnline (EnumPtr->InstanceId, EnumPtr->Class);
                }

                return TRUE;
            } else {
                EnumPtr->State = STATE_ENUM_NEXT_VALUE;
            }

            break;

        case STATE_VALUE_CLEANUP:

            //
            // Free all device field text
            //

            pFreeRegValText (EnumPtr);

            FreeText (EnumPtr->InstanceId);
            EnumPtr->InstanceId = NULL;

            EnumPtr->State = STATE_ENUM_NEXT_VALUE;
            break;

        default:
            MYASSERT(FALSE);
            END_ENUM;
            return FALSE;
        }
    }
}


/*++

Routine Description:

  AbortHardwareEnum cleans up all resources in use by an enumeration.  Call
  this function with the EnumPtr value of BeginHardwareEnum or NextHardwareEnum.

Arguments:

  EnumPtr - Specifies the enumeration to abort.

Return Value:

  none

--*/

VOID
AbortHardwareEnum (
    IN OUT  PHARDWARE_ENUM EnumPtr
    )
{
    PushError();

    END_ENUM;

    if (EnumPtr->State == STATE_VALUE_CLEANUP) {
        pFreeRegValText (EnumPtr);
        FreeText (EnumPtr->InstanceId);
    }

    AbortRegKeyTreeEnum (&EnumPtr->ek);

    ZeroMemory (EnumPtr, sizeof (HARDWARE_ENUM));

    PopError();
}





//
// NT5 INF database
//



BOOL
FindHardwareId (
    IN      PCTSTR PnpIdList,
    OUT     PTSTR InfFileName       OPTIONAL
    )

/*++

Routine Description:

  FindHardwareId parses an ID string that may contain zero or more
  plug and play device IDs, separated by commas.  The function then
  searches for each ID in the device ID table, copying the INF file
  name to a supplied buffer when a match is found.


Arguments:

  PnpIdList     - An ID string that contains zero or more plug and play
                  device IDs, separated by commas.
  InfFileName   - A buffer (big enough to hold MAX_PATH characters)
                  that receives the INF file name upon successful
                  match.  If a match is not found, InfFileName is
                  set to an empty string.

Return Value:

  TRUE if a match was found, or FALSE if a match was not found.

--*/


{
    return FindHardwareIdInHashTable (PnpIdList, InfFileName, g_PnpIdTable, TRUE);
}


BOOL
FindUnsupportedHardwareId (
    IN      PCTSTR PnpIdList,
    OUT     PTSTR InfFileName       OPTIONAL
    )

/*++

Routine Description:

  FindUnsupportedHardwareId parses an ID string that may contain zero
  or more plug and play device IDs, separated by commas.  The function
  then searches for each ID in the device ID table, copying the INF file
  name to a supplied buffer when a match is found.

Arguments:

  PnpIdList     - An ID string that contains zero or more plug and play
                  device IDs, separated by commas.
  InfFileName   - A buffer (big enough to hold MAX_PATH characters)
                  that receives the INF file name upon successful
                  match.  If a match is not found, InfFileName is
                  set to an empty string.

Return Value:

  TRUE if a match was found, or FALSE if a match was not found.

--*/


{
    return FindHardwareIdInHashTable (PnpIdList, InfFileName, g_UnsupPnpIdTable, FALSE);
}


BOOL
pFindForcedBadHardwareId (
    IN      PCTSTR PnpIdList,
    OUT     PTSTR InfFileName       OPTIONAL
    )

/*++

Routine Description:

  pFindForcedBadHardwareId parses an ID string that may contain zero or more
  plug and play device IDs, separated by commas.  The function then searches
  for each ID in the force bad device ID table, copying the INF file name to a
  supplied buffer when a match is found.

Arguments:

  PnpIdList     - An ID string that contains zero or more plug and play
                  device IDs, separated by commas.
  InfFileName   - A buffer (big enough to hold MAX_PATH characters)
                  that receives the INF file name upon successful
                  match.  If a match is not found, InfFileName is
                  set to an empty string.

Return Value:

  TRUE if a match was found, or FALSE if a match was not found.

--*/


{
    return FindHardwareIdInHashTable (PnpIdList, InfFileName, g_ForceBadIdTable, FALSE);
}


BOOL
FindUserSuppliedDriver (
    IN      PCTSTR HardwareIdList,      OPTIONAL
    IN      PCTSTR CompatibleIdList     OPTIONAL
    )

/*++

Routine Description:

  FindUserSuppliedDriver parses hardware and compatible hardware ID
  strings that may contain zero or more plug and play device IDs,
  separated by commas.  The function then searches for each ID in
  g_UiSuppliedIds table.

Arguments:

  HardwareIdList - An ID string that contains zero or more plug and play
                   device IDs, separated by commas.

  CompatibleIdList - An ID string that contains zero or more plug and play
                     device IDs, separated by commas.

Return Value:

  TRUE if a match was found, or FALSE if a match was not found.

--*/


{
    BOOL b = FALSE;

    if (HardwareIdList) {
        b = FindHardwareIdInHashTable (HardwareIdList, NULL, g_UiSuppliedIds, FALSE);
    }

    if (!b && CompatibleIdList) {
        b = FindHardwareIdInHashTable (CompatibleIdList, NULL, g_UiSuppliedIds, FALSE);
    }

    return b;
}


BOOL
FindHardwareIdInHashTable (
    IN      PCTSTR PnpIdList,
    OUT     PTSTR InfFileName,      OPTIONAL
    IN      HASHTABLE StrTable,
    IN      BOOL UseOverrideList
    )

/*++

Routine Description:

  FindHardwareIdInHashTable queries a string table for each PNP ID in
  the specified list.  If one is found, the routine optionally copies the
  INF file it was found in.  The caller can also choose to scan the win95upg.inf
  override list.

Arguments:

  PnpIdList - Specifies zero or more PNP IDs, separated by commas.

  InfFileName - Receives the file name of the INF containing the PNP IDs.

  StrTable - Specifies the string table to query.  If InfFileName is not NULL,
             the string table must have an extra data value of the offset in
             g_InfFileTable.

  UseOverrideList - Specifies TRUE if the win95upg.inf file is to be queried for
                    the PNP ID.  This query is performed after it has been
                    determined that all IDs in PnpIdList are not in StrTable.

Return Value:

  TRUE if at least one PNP ID in PnpIdList was found, or FALSE if none of the
  IDs were found.

--*/

{
    HASHITEM InfName;
    TCHAR PnpId[MAX_PNP_ID];
    PCSTR p;
    TCHAR FixedEisaId[MAX_PNP_ID];

    //
    // Extract a PNP ID from PnpIdList, then look for it in string table
    //

    if (!PnpIdList) {
        return FALSE;
    }

    MYASSERT (StrTable);
    if (!StrTable) {
        return FALSE;
    }

    p = PnpIdList;

    while (*p) {
        p = ExtractPnpId (p, PnpId);
        if (*PnpId == 0) {
            continue;
        }

        //
        // Locate ID in PNP ID table
        //

        if (HtFindStringAndData (StrTable, PnpId, (PVOID) &InfName)) {

            //
            // Found PNP ID.  Get INF file and return.
            //

            if (InfFileName) {
                if (StrTable != g_PnpIdTable && StrTable != g_UnsupPnpIdTable && StrTable != g_ForceBadIdTable) {
                    DEBUGMSG ((DBG_WHOOPS, "Caller wants InfFileName from private string table"));
                } else {
                    _tcssafecpy (
                        InfFileName,
                        HtGetStringFromItem (InfName),
                        MAX_TCHAR_PATH
                        );
                }
            }

            return TRUE;
        }

        //
        // This is a fix for the EISA roots.  On Win9x, we have an EISA
        // enumerator, but on NT, the ISA enumerator handles EISA too.
        //

        if (StringIMatchCharCount (TEXT("EISA\\"), PnpId, 5)) {
            StringCopy (FixedEisaId, TEXT("EISA&"));
            StringCat (FixedEisaId, PnpId + 5);

            if (HtFindStringAndData (StrTable, FixedEisaId, (PVOID) &InfName)) {

                //
                // Found PNP ID.  Get INF file and return.
                //

                if (InfFileName) {
                    if (StrTable != g_PnpIdTable && StrTable != g_UnsupPnpIdTable && StrTable != g_ForceBadIdTable) {
                        DEBUGMSG ((DBG_WHOOPS, "Caller wants InfFileName from private string table (2)"));
                    } else {
                        _tcssafecpy (
                            InfFileName,
                            HtGetStringFromItem (InfName),
                            MAX_TCHAR_PATH
                            );
                    }
                }

                return TRUE;
            }
        }
    }

    //
    // Locate ID in override table
    //

    if (UseOverrideList) {
        if (pIsDeviceConsideredCompatible (PnpIdList)) {

            DEBUGMSG ((
                DBG_WARNING,
                "%s is considered compatible but actually does not have PNP support in NT.",
                PnpIdList
                ));

            return TRUE;
        }
    }

    return FALSE;
}



BOOL
pProcessNtInfFile (
    IN      PCTSTR InfFile,
    IN      INT UiMode,
    IN OUT  HASHTABLE InfFileTable,
    IN OUT  HASHTABLE PnpIdTable,
    IN OUT  HASHTABLE UnsupPnpIdTable
    )

/*++

Routine Description:

  pProcessNtInfFile scans an NT INF and places all hardware device
  IDs in the PNP string table.  All entries of the string table
  have extra data that points to the INF file (added to the INF
  file name string table).

Arguments:

  InfFile - The path to an INF file to be examined

  UiMode - Specifies VERBOSE_OUTPUT or PNPREPT_OUTPUT when the PNP
           IDs are to be dumped tvia the progress bar output
           routines.  If REGULAR_OUTPUT, no output is generated.

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    HINF hInf;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    INFSTRUCT isMfg = INITINFSTRUCT_GROWBUFFER;
    INFSTRUCT isDev = INITINFSTRUCT_GROWBUFFER;
    BOOL UnsupportedDevice;
    PCTSTR DevSection;
    PCTSTR Manufacturer;
    TCHAR PnpId[MAX_PNPID_LENGTH * 4];
    PTSTR CurrentDev;
    TCHAR TrimmedId[MAX_PNP_ID];
    PCTSTR FileName;
    PCTSTR p;
    CHARTYPE ch;
    HASHITEM InfOffset = NULL;
    LONG rc;
    LONG DontCare = 0;
    BOOL Result = FALSE;
    PCTSTR RealDevSection = NULL;
    BOOL b;
    PCTSTR TempStr;
    HASHITEM hashItem;

    //
    // Get a pointer to the inf file excluding the path
    //

    FileName = NULL;
    for (p = InfFile ; *p ; p = _tcsinc (p)) {
        ch = _tcsnextc (p);
        if (ch == TEXT('\\')) {
            FileName = _tcsinc (p);
        } else if (!FileName && ch == TEXT(':')) {
            FileName = _tcsinc (p);
        }
    }

    MYASSERT (*FileName);

    //
    // Open INF file with Setup APIs
    //

    hInf = InfOpenInfFile (InfFile);

    if (hInf == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Failed to open %s while processing hardware INFs.", InfFile));
        return FALSE;
    }

    __try {
        //
        // Enumerate [Manufacturer] section
        //

        if (!InfFindFirstLine (hInf, S_MANUFACTURER, NULL, &is)) {
            rc = GetLastError();

            // If section not found, return success
            if (rc == ERROR_SECTION_NOT_FOUND || rc == ERROR_LINE_NOT_FOUND) {
                SetLastError (ERROR_SUCCESS);
                Result = TRUE;
                __leave;
            }

            SetLastError (rc);
            LOG ((LOG_ERROR, "Error trying to find %s in %s", S_MANUFACTURER, InfFile));
            __leave;
        }

        do  {
            //
            // Get the manufacturer name
            //
            Manufacturer = InfGetLineText (&is);
            if (!Manufacturer) {
                LOG ((LOG_ERROR, "Error getting line text of enumerated line"));
                __leave;
            }

            //
            // Enumerate the devices listed in the manufacturer's section,
            // looking for PnpId
            //

            if (!InfFindFirstLine (hInf, Manufacturer, NULL, &isMfg)) {
                rc = GetLastError();

                // if section not found, move on to next manufacturer
                if (rc == ERROR_SECTION_NOT_FOUND || rc == ERROR_LINE_NOT_FOUND) {
                    DEBUGMSG ((
                        DBG_HWCOMP,
                        "Manufacturer %s section does not exist in %s",
                        Manufacturer,
                        InfFile
                        ));

                    continue;
                }

                LOG((LOG_ERROR, "Error while searching for %s in %s.", Manufacturer, InfFile));
                __leave;
            }

            do  {
                //
                // Is this an unsupported device?
                //

                DevSection = InfGetStringField (&isMfg, 1);
                if (!DevSection) {
                    // There is no field 1
                    continue;
                }

                UnsupportedDevice = FALSE;

                //
                // Try section.NTx86 first, then section.NT, then section
                //

                RealDevSection = JoinText (DevSection, TEXT(".NTx86"));
                b = InfFindFirstLine (hInf, RealDevSection, NULL, &isDev);

                if (!b) {
                    FreeText (RealDevSection);
                    RealDevSection = JoinText (DevSection, TEXT(".NT"));
                    b = InfFindFirstLine (hInf, RealDevSection, NULL, &isDev);
                }

                if (!b) {
                    FreeText (RealDevSection);
                    RealDevSection = DuplicateText (DevSection);
                    b = InfFindFirstLine (hInf, RealDevSection, NULL, &isDev);
                }

                if (!b) {
                    DEBUGMSG ((
                        DBG_HWCOMP,
                        "Device section for %s does not exist in %s of %s",
                        RealDevSection,
                        Manufacturer,
                        InfFile
                        ));
                } else {

                    if (InfFindFirstLine (hInf, RealDevSection, TEXT("DeviceUpgradeUnsupported"), &isDev)) {
                        TempStr = InfGetStringField (&isDev, 1);

                        if (TempStr && _ttoi (TempStr)) {
                            UnsupportedDevice = TRUE;
                        }
                    }
                }

                FreeText (RealDevSection);

                //
                // Get the device id
                //

                if (!pGetPnpIdList (&isMfg, PnpId, sizeof (PnpId))) {
                    // There is no field 2
                    continue;
                }

                //
                // Add each device id to the id tree
                //

                CurrentDev = PnpId;
                while (*CurrentDev) {
                    //
                    // First time through add the INF file name to string table
                    //

                    if (!InfOffset) {
                        if (InfFileTable) {
                            InfOffset = HtAddString (InfFileTable, FileName);

                            if (!InfOffset) {
                                LOG ((LOG_ERROR, "Cannot add %s to table of INFs.", FileName));
                                __leave;
                            }
                        }
                    }

                    //
                    // Add PNP ID to string table
                    //

                    StringCopy (TrimmedId, SkipSpace (CurrentDev));
                    TruncateTrailingSpace (TrimmedId);

                    if (UnsupportedDevice) {
                        hashItem = HtAddStringAndData (UnsupPnpIdTable, TrimmedId, &InfOffset);
                    } else {
                        hashItem = HtAddStringAndData (PnpIdTable, TrimmedId, &InfOffset);
                    }

                    if (!hashItem) {
                        LOG ((LOG_ERROR, "Cannot add %s to table of PNP IDs.", CurrentDev));
                        __leave;
                    }

                    MYASSERT (
                        UnsupportedDevice ?
                            hashItem == HtFindString (UnsupPnpIdTable, TrimmedId) :
                            hashItem == HtFindString (PnpIdTable, TrimmedId)
                        );

                    //
                    // UI options
                    //

                    if (UiMode == VERBOSE_OUTPUT || UiMode == PNPREPT_OUTPUT) {
                        TCHAR Msg[MAX_ENCODED_PNPID_LENGTH + MAX_INF_DESCRIPTION + 16];
                        TCHAR Desc[MAX_INF_DESCRIPTION];
                        TCHAR EncPnpId[MAX_ENCODED_PNPID_LENGTH * 4];
                        TCHAR EncDesc[MAX_INF_DESCRIPTION * 2];

                        if (SetupGetStringField (
                                &isMfg.Context,
                                0,
                                Desc,
                                MAX_INF_DESCRIPTION,
                                NULL
                                )) {
                            if (UiMode == VERBOSE_OUTPUT) {
                                wsprintf (Msg, TEXT("  PNP ID: %s, Desc: %s"), PnpId, Desc);
                            } else {
                                StringCopy (EncPnpId, PnpId);
                                StringCopy (EncDesc, Desc);

                                EncodePnpId (EncPnpId);
                                EncodePnpId (EncDesc);

                                wsprintf (Msg, TEXT("%s\\%s\\%s"), EncPnpId, EncDesc, FileName);
                            }
                            ProgressBar_SetSubComponent (Msg);
                        }
                    }

                    CurrentDev = GetEndOfString (CurrentDev) + 1;
                }

            } while (InfFindNextLine (&isMfg));

        } while (InfFindNextLine (&is));

        InfCloseInfFile (hInf);
        SetLastError (ERROR_SUCCESS);

        Result = TRUE;
    }
    __finally {
        PushError();
        InfCleanUpInfStruct (&is);
        InfCleanUpInfStruct (&isMfg);
        InfCleanUpInfStruct (&isDev);
        InfCloseInfFile (hInf);
        PopError();
    }

    return Result;
}


PCTSTR
ExtractPnpId (
    IN      PCTSTR PnpIdList,
    OUT     PTSTR PnpIdBuf
    )

/*++

Routine Description:

  ExtractPnpId removes the next PNP ID from a list of zero or more
  PNP IDs (separated by commas).  Upon return, PnpIdBuf contains the
  PNP ID (or empty string if none found), and the return value points
  to the next PNP ID in the list.

  This routine is designed to be called in a loop until the return
  value points to the nul terminated of PnpIdList.

Arguments:

  PnpIdList - Specifies a pointer to the next string in the PNP ID list.

  PnpIdBuf - Receives the PNP ID with spaces trimmed on both sides of the
             ID.


Return Value:

  A pointer to the next item in the list, or a pointer to the nul at the
  end of the list.  If the pointer points to a non-nul character, call
  ExtractPnpId again, using the return value for the PnpIdList param.

--*/

{
    PCTSTR p, q;

    PnpIdList = SkipSpace (PnpIdList);

    q = _tcschr (PnpIdList, TEXT(','));
    if (!q) {
        q = GetEndOfString (PnpIdList);
    }

    p = q;
    if (p > (PnpIdList + MAX_PNP_ID - 1)) {
        p = PnpIdList + MAX_PNP_ID - 1;
    }

    StringCopyAB (PnpIdBuf, PnpIdList, p);
    TruncateTrailingSpace (PnpIdBuf);

    if (*q) {
        q = _tcsinc (q);
    }

    return q;
}


BOOL
AddPnpIdsToHashTable (
    IN OUT  HASHTABLE Table,
    IN      PCTSTR PnpIdList
    )

/*++

Routine Description:

  AddPnpIdsToHashTable extracts all PNP IDs from a comma-separated
  list of PNP IDs and places each one in the specified string table.

  PNP IDs are added to the string table as case-insensitive.

Arguments:

  Table - Specifies the table to add each PNP ID to

  PnpIdList - Specifies a comma-separated list of zero or more PNP
              IDs to add to Table.


Return Value:

  TRUE if all IDs were processed successfully, or FALSE if an error
  occurred adding to the string table.

--*/

{
    TCHAR PnpId[MAX_PNP_ID];
    PCTSTR p;

    p = PnpIdList;
    if (!p) {
        return TRUE;
    }

    while (*p) {
        p = ExtractPnpId (p, PnpId);

        if (*PnpId) {

            if (!HtAddString (Table, PnpId)) {
                LOG ((LOG_ERROR, "Can't add %s to table of PNP ids.", PnpId));
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
AddPnpIdsToGrowList (
    IN OUT  PGROWLIST GrowList,
    IN      PCTSTR PnpIdList
    )

/*++

Routine Description:

  AddPnpIdsToHashTable extracts all PNP IDs from a comma-separated
  list of PNP IDs and places each one in the specified grow list.

Arguments:

  GrowList - Specifies the list to add each PNP ID to

  PnpIdList - Specifies a comma-separated list of zero or more PNP
              IDs to add to GrowList.

Return Value:

  TRUE if all IDs were processed successfully, or FALSE if an error
  occurred adding to the grow list.

--*/

{
    TCHAR PnpId[MAX_PNP_ID];
    PCTSTR p;

    p = PnpIdList;

    while (*p) {
        p = ExtractPnpId (p, PnpId);

        if (*PnpId) {

            if (!GrowListAppendString (GrowList, PnpId)) {
                DEBUGMSG ((DBG_ERROR, "AddPnpIdsToGrowList: Can't add %s", PnpId));
                return FALSE;
            }
        }
    }

    return TRUE;
}


PCTSTR
AddPnpIdsToGrowBuf (
    IN OUT  PGROWBUFFER GrowBuffer,
    IN      PCTSTR PnpIdList
    )

/*++

Routine Description:

  AddPnpIdsToGrowBuf extracts all PNP IDs from a comma-separated
  list of PNP IDs and places each one in the specified grow buffer.

Arguments:

  GrowBuffer - Specifies the buffer to add each PNP ID to

  PnpIdList - Specifies a comma-separated list of zero or more PNP
              IDs to add to GrowBuffer.

Return Value:

  A pointer to the beginning of the multisz buffer

--*/

{
    TCHAR PnpId[MAX_PNP_ID];
    PCTSTR p;

    p = PnpIdList;

    while (*p) {
        p = ExtractPnpId (p, PnpId);

        if (*PnpId) {

            if (!MultiSzAppend (GrowBuffer, PnpId)) {
                DEBUGMSG ((DBG_ERROR, "AddPnpIdsToGrowBuf: Can't add %s", PnpId));
                return FALSE;
            }
        }
    }

    return GrowBuffer->Buf;
}


BOOL
pIsFileOnCD (
    PCTSTR File
    )

/*++

Routine Description:

  pIsFileOnCd checks the drive letter at the head of File to see if
  it is a CD-ROM.

  This function also emulates the CD-ROM behavior for the report tool.

Arguments:

  File - Specifies the full path of the file to compare

Return Value:

  TRUE if the file is on a CD-ROM, or FALSE if it is not.

--*/

{
    TCHAR RootDir[4];

    //
    // If report tool, or private stress option, always return TRUE.
    //

    if (REPORTONLY()) {
        return TRUE;
    }

#ifdef PRERELEASE
    if (g_Stress) {
        return TRUE;
    }
#endif

    //
    // A CD drive cannot be a UNC path
    //

    if (File[0] && File[1] != TEXT(':')) {
        return FALSE;
    }

    RootDir[0] = File[0];
    RootDir[1] = File[1];
    RootDir[2] = TEXT('\\');
    RootDir[3] = 0;

    return DRIVE_CDROM == GetDriveType (RootDir);
}


DWORD
pComputeInfChecksum (
    IN      PCTSTR HwCompDat,       OPTIONAL
    OUT     PBOOL Rebuild           OPTIONAL
    )
/*++

Routine Description:

  pComputeInfChecksum calculates a checksum for all INFs in the
  source directories.  This routine scans all directories in the
  SOURCEDIRECTORYARRAY() global string array.

Arguments:

  HwCompDat - Specifies path to hwcomp.dat, required if Rebuild is
              specified.

  Rebuild - Receives TRUE if an INF file was found with a greater
            date than hwcomp.dat.

Return Value:

  The checksum.

--*/

{
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    DWORD Checksum = 0;
    PTSTR p;
    TCHAR InfPattern[MAX_TCHAR_PATH];
    UINT u, v;
    FILETIME HwCompDatTime;

    MYASSERT ((!HwCompDat && !Rebuild) || (HwCompDat && Rebuild));

    if (Rebuild) {
        if (DoesFileExistEx (HwCompDat, &fd)) {
            *Rebuild = FALSE;
            HwCompDatTime = fd.ftLastWriteTime;
        } else {
            *Rebuild = TRUE;
        }
    }

    //
    // NTRAID#NTBUG9-379084-2001/04/27-jimschm disable this until a better solution is found
    //

#if 0

    for (u = 0 ; u < SOURCEDIRECTORYCOUNT() ; u++) {

        //
        // Have we already processed this source dir?
        //

        for (v = 0 ; v < u ; v++) {
            if (StringIMatch (SOURCEDIRECTORY(u),SOURCEDIRECTORY(v))) {
                break;
            }
        }

        if (v != u) {
            continue;
        }

        //
        // Process this directory
        //

        StringCopy (InfPattern, SOURCEDIRECTORY(u));
        AppendWack (InfPattern);
        StringCat (InfPattern, TEXT("*.in?"));

        hFind = FindFirstFile (InfPattern, &fd);
        if (hFind != INVALID_HANDLE_VALUE) {
            do {
                //
                // Make sure file name ends in underscore or f
                //
                // We cheat... because we know that if the file was DBCS,
                // it couldn't end in .INF
                //
                p = GetEndOfString (fd.cFileName);
                MYASSERT (p != fd.cFileName);
                p = _tcsdec2 (fd.cFileName, p);

                if (*p == TEXT('_')) {
                    if (_istlower (*(p -1)))
                        *p = TEXT('f');
                    else
                        *p = TEXT('F');
                } else if (tolower (*p) != TEXT('f')) {
                    continue;
                }

                // Make sure the file is not excluded
                if (pIsInfFileExcluded (fd.cFileName)) {
                    continue;
                }

                if (Rebuild) {
                    // Check file times
                    if (CompareFileTime (&fd.ftLastWriteTime, &HwCompDatTime) > 0) {
                        *Rebuild = TRUE;
                        // abandon computation
                        break;
                    }
                }

                // Add the file size to the checksum
                Checksum = _rotl (Checksum, 1) ^ fd.nFileSizeLow;

                // Add file name
                for (p = fd.cFileName ; *p ; p++) {
                    // preserve character and order
                    Checksum += (DWORD) (*p) * (DWORD) (1 + fd.cFileName - p);
                }

            } while (FindNextFile (hFind, &fd));

            FindClose (hFind);
        }
    }

#endif

    return Checksum;
}


BOOL
LoadDeviceList (
    IN      LOADOP Operation,
    IN      PCTSTR HwCompDatPath
    )

/*++

Routine Description:

  LoadDeviceList attempts to load hwcomp.dat from the path specified
  in the HwCompDat parameter.  If it is able to load this file, all
  PNP IDs for all INFs are valid.  If it is not able to load this file,
  the file does not exist, or the file does not match the INFs.

Arguments:

  Operation  - QUERY: the validity of hwcomp.dat is to be checked
               LOAD: load the data into memory.
               DUMP: dump the file to stdout

  HwCompDatPath  - The path of hwcomp.dat, the data file holding a
                   pre-compiled compatible PNP ID list.

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD StoredChecksum;
    BOOL b = FALSE;
    HASHTABLE InfFileTable = NULL;
    HASHTABLE PnpIdTable = NULL;
    BOOL Rebuild;
    DWORD CurrentChecksum;
    DWORD HwCompDatId = 0;

    //
    // !!! IMPORTANT !!!
    //
    // hwcomp.dat is used by other parts of NT.  *DO NOT* change it without first e-mailing
    // the NT group.  Also, be sure to keep code in lib.c in sync with changes.
    //

    if (Operation == DUMP) {
        DumpHwCompDat (HwCompDatPath, TRUE);
        return TRUE;
    }

    __try {
        //
        // Open the hardware compatibility database
        //

        HwCompDatId = OpenHwCompDat (HwCompDatPath);

        if (!HwCompDatId) {
            __leave;
        }

#if 0
        //
        // Get the checksum
        //

        StoredChecksum = GetHwCompDatChecksum (HwCompDatId);

        //
        // Verify the checksum
        //

        CurrentChecksum = pComputeInfChecksum (HwCompDatPath, &Rebuild);

        if (CurrentChecksum != StoredChecksum || Rebuild) {

            if (!pIsFileOnCD (HwCompDatPath)) {
                DEBUGMSG ((DBG_WARNING, "PNP dat file's internal checksum does not match"));
                __leave;
            }

            DEBUGMSG ((
                DBG_WARNING,
                "PNP dat file's internal checksum does not match.  Error "
                      "ignored because %s is on a CD.",
                HwCompDatPath
                ));
        }

#endif

        //
        // Load the rest of hwcomp.dat
        //

        if (!LoadHwCompDat (HwCompDatId)) {
            DEBUGMSG ((DBG_ERROR, "Can't load hwcomp.dat"));
            __leave;
        }

        //
        // If a load operation, put the hash tables into globals for use by
        // the rest of hwcomp.c.
        //

        if (Operation == LOAD) {

            //
            // Take ownership of the hash tables
            //

            if (g_InfFileTable) {
                HtFree (g_InfFileTable);
            }

            if (g_PnpIdTable) {
                HtFree (g_PnpIdTable);
            }

            if (g_UnsupPnpIdTable) {
                HtFree (g_UnsupPnpIdTable);
            }

            TakeHwCompHashTables (
                HwCompDatId,
                (PVOID *) (&g_PnpIdTable),
                (PVOID *) (&g_UnsupPnpIdTable),
                (PVOID *) (&g_InfFileTable)
                );

        }

        b = TRUE;

    }
    __finally {

        CloseHwCompDat (HwCompDatId);

    }

    return b;
}


BOOL
pWriteDword (
    IN      HANDLE File,
    IN      DWORD Val
    )

/*++

Routine Description:

  pWriteDword writes the specified DWORD value to File.

Arguments:

  File - Specifies file to write to

  Val - Specifies value to write

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD BytesWritten;

    return WriteFile (File, &Val, sizeof (Val), &BytesWritten, NULL);
}


BOOL
pWriteWord (
    IN      HANDLE File,
    IN      WORD Val
    )

/*++

Routine Description:

  pWriteWord writes the specified WORD vlue to File.

Arguments:

  File - Specifies file to write to

  Val - Specifies value to write

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD BytesWritten;

    return WriteFile (File, &Val, sizeof (Val), &BytesWritten, NULL);
}


BOOL
pWriteStringWithLength (
    IN      HANDLE File,
    IN      PCTSTR String
    )

/*++

Routine Description:

  pWriteStringWithLength writes the length of String as a WORD,
  and then writes String (excluding the nul terminator).

Arguments:

  File - Specifies file to write to

  String - Specifies string to write

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD BytesWritten;
    WORD Length;

    Length = (WORD) ByteCount (String);
    if (!pWriteWord (File, Length)) {
        DEBUGMSG ((DBG_ERROR, "pWriteStringWithLength: Can't write word"));
        return FALSE;
    }

    if (Length) {
        if (!WriteFile (File, String, Length, &BytesWritten, NULL)) {
            DEBUGMSG ((DBG_ERROR, "pWriteStringWithLength: Can't write %s", String));
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
pPnpIdEnum (
    IN      HASHTABLE Table,
    IN      HASHITEM StringId,
    IN      PCTSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  pPnpIdEnum is a string table callback function that writes a PNP
  ID to the file indicated in the Params struct (the lParam member).

  This function only writes PNP IDs for a specific INF file (indicated
  by the ExtraData arg).

Arguments:

  Table - Specifies table being enumerated

  StringId - Specifies offset of string in Table

  String - Specifies string being enumerated

  ExtraData - Specifies a pointer to a LONG that holds the INF ID
              to enumerate.  The PNP ID's INF ID must match this
              parameter.

  lParam - Specifies a pointer to a SAVE_ENUM_PARAMS struct

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.

--*/

{
    PSAVE_ENUM_PARAMS Params;
    PCSTR BangString;
    BOOL b = TRUE;

    Params = (PSAVE_ENUM_PARAMS) lParam;

    if (*((HASHITEM *) ExtraData) == Params->InfFileOffset) {
        //
        // Write this PNP ID to the file
        //

        if (Params->UnsupportedDevice) {

            BangString = JoinTextExA (NULL, "!", String, NULL, 0, NULL);
            b = pWriteStringWithLength (Params->File, BangString);
            FreeTextA (BangString);

        } else {

            b = pWriteStringWithLength (Params->File, String);

        }
    }

    return b;
}


BOOL
pInfFileEnum (
    IN      HASHTABLE Table,
    IN      HASHITEM StringId,
    IN      PCTSTR String,
    IN      HASHTABLE ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  pInfFileEnum is a string table callback function and is called for
  each INF in g_InfFileTable.

  This routine writes the name of the INF to disk, and then enumerates
  the PNP IDs for the INF, writing them to disk.

  The PNP ID list is terminated with an empty string.

Arguments:

  Table - Specifies g_InfFileTable

  StringId - Specifies offset of String in g_InfFileTable

  String - Specifies current INF file being enumerated

  ExtraData - unused

  ExtraDataSize - unused

  lParam - Specifies a pointer to SAVE_ENUM_PARAMS struct.

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.

--*/

{
    PSAVE_ENUM_PARAMS Params;

    Params = (PSAVE_ENUM_PARAMS) lParam;
    Params->InfFileOffset = StringId;

    //
    // Save the file name
    //

    if (!pWriteStringWithLength (Params->File, String)) {
        return FALSE;
    }

    //
    // Enumerate all PNP IDs
    //

    Params->UnsupportedDevice = FALSE;

    if (!EnumHashTableWithCallback (g_PnpIdTable, pPnpIdEnum, lParam)) {
        LOG ((LOG_ERROR, "Error while saving device list."));
        return FALSE;
    }

    Params->UnsupportedDevice = TRUE;

    if (!EnumHashTableWithCallback (g_UnsupPnpIdTable, pPnpIdEnum, lParam)) {
        LOG ((LOG_ERROR, "Error while saving device list. (2)"));
        return FALSE;
    }

    //
    // Terminate the PNP ID list
    //

    if (!pWriteStringWithLength (Params->File, S_EMPTY)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
SaveDeviceList (
    PCTSTR HwCompDatPath
    )

/*++

Routine Description:

  SaveDeviceList writes all data stored in g_InfFileTable and g_PnpIdTable
  to the file specified by HwCompDat.  This file will therefore contain
  all PNP IDs in all INFs of Windows NT.

Arguments:

  HwCompDatPath - Specifies path of file to write

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    HANDLE File;
    DWORD BytesWritten;
    BOOL b = FALSE;
    SAVE_ENUM_PARAMS Params;
    DWORD ChecksumToStore;

    //
    // !!! IMPORTANT !!!
    //
    // hwcomp.dat is used by other parts of NT.  *DO NOT* change it without first e-mailing
    // the NT group.  Also, be sure to keep code in lib.c in sync with changes.
    //
    ChecksumToStore = pComputeInfChecksum (NULL, NULL);

    File = CreateFile (
                HwCompDatPath,
                GENERIC_WRITE,
                0,                          // open for exclusive access
                NULL,                       // no security attribs
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL                        // no template
                );

    if (File == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Cannot open %s for writing", HwCompDatPath));
        return FALSE;
    }

    __try {
        //
        // Write version stamp
        //

        if (!WriteFile (File, HWCOMPDAT_SIGNATURE, ByteCount (HWCOMPDAT_SIGNATURE), &BytesWritten, NULL)) {
            LOG ((LOG_ERROR, "Can't write signature file."));
            __leave;
        }

        //
        // Write checksum
        //

        if (!pWriteDword (File, ChecksumToStore)) {
            LOG ((LOG_ERROR, "Can't write checksum"));
            __leave;
        }

        //
        // Enumerate the INF table, writing the INF file name and all PNP IDs
        //

        Params.File = File;

        if (!EnumHashTableWithCallback (
                g_InfFileTable,
                pInfFileEnum,
                (LPARAM) (&Params)
                )) {
            DEBUGMSG ((DBG_WARNING, "SaveDeviceList: EnumHashTableWithCallback returned FALSE"));
            __leave;
        }

        //
        // Terminate the INF file list
        //

        if (!pWriteStringWithLength (File, S_EMPTY)) {
            DEBUGMSG ((DBG_WARNING, "SaveDeviceList: Can't write INF terminator"));
            __leave;
        }

        b = TRUE;
    }
    __finally {
        CloseHandle (File);

        if (!b) {
            DeleteFile (HwCompDatPath);
        }
    }

    return b;
}


BOOL
pIsInfFileExcluded (
    PCTSTR FileNamePtr
    )

/*++

Routine Description:

  IsInfFileExcluded returns TRUE when the specified file name does
  not contain PNP IDs.

Arguments:

  FileNamePtr - The name of the uncompressed INF file, without any path info.

Return Value:

  TRUE if the file should be ignored by the PNP parser, or FALSE if
  the file may contain PNP IDs.

--*/

{
    PCTSTR *p;

    // Check for OEMN (old network INFs)
    if (StringIMatchCharCount (FileNamePtr, TEXT("OEMN"), 4)) {
        return TRUE;
    }

    // Make sure extension has INF

    if (!StringIMatch (FileNamePtr + TcharCount (FileNamePtr) - 3 * sizeof (TCHAR), TEXT("INF"))) {
        return TRUE;
    }

    // Check list of excluded files

    for (p = g_ExcludeTable ; **p ; p++) {
        if (StringIMatch (FileNamePtr, *p)) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
pGetNonExistingFile (
    IN      PCTSTR Path,
    OUT     PTSTR EndOfPath,
    IN      PCTSTR DefaultName
    )

/*++

Routine Description:

  pGetNonExistingFile generates a file name of a file that does
  not exist. It creates an empty file with that name, to reserve it.

Arguments:

  Path - Specifies the path where the file will exist.  Path must
         end in a backslash.

  EndOfPath - Points to the nul at the end of Path and is used to
              write the new file name.

  DefaultName - Specifies the default file name to try to use.  If such
                a file already exists, numbers are appended to
                DefaultName until a unique name is found.

Return Value:

  none

--*/

{
    UINT Count = 0;

    StringCopy (EndOfPath, DefaultName);

    while (GetFileAttributes (Path) != 0xffffffff) {
        Count++;
        wsprintf (EndOfPath, TEXT("%s.%03u"), DefaultName, Count);
    }
}


BOOL
GetFileNames (
    IN      PCTSTR *InfDirs,
    IN      UINT InfDirCount,
    IN      BOOL QueryFlag,
    IN OUT  PGROWBUFFER FileNames,
    IN OUT  PGROWBUFFER DecompFileNames
    )

/*++

Routine Description:

  GetFileNames searches InfDirs for any file that ends with .INF or .IN_.
  It builds a MULTI_SZ list of file names that may contain PNP IDs.  All
  compressed INFs are decompressed into a temporary directory.

  If the QueryFlag is set, the file name list is prepared but no files
  are decompressed.

Arguments:

  InfDirs - A list of paths to the directory containing INFs, either
            compressed or non-compressed.

  InfDirCount - Specifies the number of dirs in the InfDirs array.

  QueryFlag - TRUE if the function should build the file list but
              should not decompress; FALSE if the function
              should build the file list and decompress as needed.

  FileNames - Specifies an empty GROWBUFFER struct that is used to build
              a multi-sz list of full paths to the INF files.

Return Value:

  A pointer to the MUTLI_SZ list.  The caller is responsible for freeing
  this buffer via FreeFileNames.

  The return value is NULL if an error occurred.  Call GetLastError for
  an error code.

--*/

{
    UINT u;

    //
    // Add list of files for each directory
    //

    for (u = 0 ; u < InfDirCount ; u++) {
        if (!pGetFileNamesWorker (FileNames, DecompFileNames, InfDirs[u], QueryFlag)) {
            FreeFileNames (FileNames, DecompFileNames, QueryFlag);
            return FALSE;
        }
    }

    MultiSzAppend (FileNames, S_EMPTY);
    MultiSzAppend (DecompFileNames, S_EMPTY);

    return TRUE;
}

BOOL
pGetFileNamesWorker (
    IN OUT  PGROWBUFFER FileNames,
    IN OUT  PGROWBUFFER DecompFileNames,
    IN      PCTSTR InfDir,
    IN      BOOL QueryFlag
    )

/*++

Routine Description:

  pGetFileNamesWorker gets the file names for a single directory.
  See GetFileNames for more details.

Arguments:

  FileNames - Specifies GROWBUFFER of file names.  This routine
              appends file names using MultiSzAppend but does not
              append the final empty string.

  InfDir - Specifies directory holding zero or more INFs (either
           compressed or non-compressed).

  QueryFlag - Specifies TRUE if INF list is to be queried, or
              FALSE if the list is to be fully processed.  When
              QueryFlag is TRUE, files are not decompressed or
              opened.

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    PTSTR p;
    TCHAR ActualFile[MAX_TCHAR_PATH];
    CHAR AnsiFileName[MAX_MBCHAR_PATH];
    PTSTR FileNameOnDisk;
    HANDLE hFile;
    DWORD BytesRead;
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    TCHAR Pattern[MAX_TCHAR_PATH];
    TCHAR UncompressedFile[MAX_TCHAR_PATH];
    TCHAR CompressedFile[MAX_TCHAR_PATH];
    PTSTR FileNamePtr;
    BOOL DecompressFlag;
    DWORD rc;
    BYTE BufForSp[2048];
    PSP_INF_INFORMATION psp;

    psp = (PSP_INF_INFORMATION) BufForSp;

    //
    // Get file names
    //

    StringCopy (Pattern, InfDir);
    StringCopy (AppendWack (Pattern), TEXT("*.in?"));

    hFind = FindFirstFile (Pattern, &fd);
    if (hFind == INVALID_HANDLE_VALUE) {
        if (GetLastError() == ERROR_NO_MORE_FILES) {
            return TRUE;
        }

        LOG ((LOG_ERROR, "FindFirstFile failed for %s", Pattern));
        return FALSE;
    }

    //
    // Determine if each matching file is actually an INF, and if so
    // add it to the FileNames growbuf.
    //

    rc = ERROR_SUCCESS;

    do {
        if (*g_CancelFlagPtr) {
            rc = ERROR_CANCELLED;
            break;
        }

        //
        // Make sure file has _ or f at the end.
        //

        p = GetEndOfString (fd.cFileName);
        MYASSERT (p != fd.cFileName);
        p = _tcsdec2 (fd.cFileName, p);
        MYASSERT (p);

        if (!p) {
            continue;
        }

        if (*p != TEXT('_') && _totlower (*p) != TEXT('f')) {
            continue;
        }

        //
        // Default actual file to uncompressed name
        //

        StringCopy (ActualFile, fd.cFileName);

        //
        // Build source file (CompressedFile)
        //

        StringCopy (CompressedFile, InfDir);
        StringCopy (AppendWack (CompressedFile), ActualFile);

        //
        // Build destination file (UncompressedFile) and detect collisions
        //
/*
        StringCopy (UncompressedFile, g_TempDir);
        FileNamePtr = AppendWack (UncompressedFile);
        pGetNonExistingFile (UncompressedFile, FileNamePtr, ActualFile);
*/
        DecompressFlag = FALSE;
        if (!GetTempFileName (g_TempDir, TEXT("inf"), 0, UncompressedFile)) {
            rc = GetLastError ();
            break;
        }

        //
        // Create uncompressed file path
        //

        if (*p == TEXT('_')) {

            //
            // Extract real name from INF file at offset 0x3c
            //

            ActualFile[0] = 0;
            hFile = CreateFile (
                        CompressedFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

            if (hFile != INVALID_HANDLE_VALUE) {

                if (0xffffffff != SetFilePointer (hFile, 0x3c, NULL, FILE_BEGIN)) {

                    if (ReadFile (
                            hFile,
                            AnsiFileName,
                            sizeof (AnsiFileName),
                            &BytesRead,
                            NULL
                            )) {

                        if (BytesRead >= SizeOfString (fd.cFileName)) {
                            FileNameOnDisk = ConvertAtoT (AnsiFileName);

                            if (StringIMatchCharCount (
                                    fd.cFileName,
                                    FileNameOnDisk,
                                    CharCount (fd.cFileName) - 1
                                    )) {

                                //
                                // Real name found -- use it as ActualFile
                                //

                                StringCopy (ActualFile, FileNameOnDisk);

                                //
                                // Also use real file name for decompression, but
                                // append numbers if collision.
                                //
/*
                                pGetNonExistingFile (
                                    UncompressedFile,
                                    FileNamePtr,
                                    FileNameOnDisk
                                    );
*/
                            }

                            FreeAtoT (FileNameOnDisk);
                        }
                    }
                }

                CloseHandle (hFile);
            }

            //
            // If file name could not be found, discard this file
            //

            if (!ActualFile[0]) {
                DEBUGMSG ((DBG_HWCOMP, "%s is not an INF file", fd.cFileName));
                continue;
            }

            DecompressFlag = TRUE;

        } else {
            StringCopy (UncompressedFile, CompressedFile);
        }

        //
        // Skip excluded files
        //

        if (pIsInfFileExcluded (ActualFile)) {
            continue;
        }

        if (!QueryFlag) {

            //
            // Uncompress file if necessary
            //

            if (DecompressFlag) {
/*
                SetFileAttributes (UncompressedFile, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (UncompressedFile);
*/
                rc = SetupDecompressOrCopyFile (CompressedFile, UncompressedFile, 0);

                if (rc != ERROR_SUCCESS) {
                    LOG ((LOG_ERROR, "Could not decompress %s to %s", CompressedFile, UncompressedFile));
                    break;
                }
            }

            //
            // Determine if this is an NT 4 INF
            //

            if (!SetupGetInfInformation (
                    UncompressedFile,
                    INFINFO_INF_NAME_IS_ABSOLUTE,
                    psp,
                    sizeof (BufForSp),
                    NULL) ||
                    psp->InfStyle != INF_STYLE_WIN4
                ) {

                DEBUGMSG ((DBG_HWCOMP, "%s is not a WIN4 INF file", UncompressedFile));
/*
                if (DecompressFlag && !QueryFlag) {
                    DeleteFile (UncompressedFile);
                }
*/
                StringCopy (UncompressedFile, S_IGNORE_THIS_FILE);
            }

            TickProgressBar();
        }

        //
        // Add file to grow buffer
        //

        MultiSzAppend (DecompressFlag ? DecompFileNames : FileNames, UncompressedFile);

    } while (rc == ERROR_SUCCESS && FindNextFile (hFind, &fd));

    FindClose (hFind);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        DEBUGMSG ((DBG_ERROR, "pGetFileNamesWorker: Error encountered in loop"));
        return FALSE;
    }

    return TRUE;
}


VOID
FreeFileNames (
    IN      PGROWBUFFER FileNames,
    IN OUT  PGROWBUFFER DecompFileNames,
    IN      BOOL QueryFlag
    )

/*++

Routine Description:

  FreeFileNames cleans up the list generated by GetFileNames.  If
  QueryFlag is set to FALSE, all temporary decompressed
  files are deleted.

Arguments:

  FileNames - The same grow buffer passed to GetFileNames
  QueryFlag - The same flag passed to GetFileNames

Return Value:

  none

--*/

{
    PTSTR p;

    p = (PTSTR) DecompFileNames->Buf;
    if (!p) {
        return;
    }

    //
    // Remove all files in temp dir (we created them when performing decompression)
    //

    if (!QueryFlag) {
        while (*p) {
            if (StringIMatchCharCount (p, g_TempDirWack, g_TempDirWackChars)) {
                SetFileAttributes (p, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (p);
            }

            p = GetEndOfString (p) + 1;
        }
    }

    //
    // Deallocate FileNames
    //

    FreeGrowBuffer (DecompFileNames);
    FreeGrowBuffer (FileNames);
}


VOID
pBuildPatternCompatibleIDsTable (
    VOID
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR p;
    GROWBUFFER joinedPattern = GROWBUF_INIT;
    PPARSEDPATTERN test;

    MYASSERT (g_Win95UpgInf != INVALID_HANDLE_VALUE);
    if (InfFindFirstLine (g_Win95UpgInf, S_COMPATIBLE_PNP_IDS, NULL, &is)) {
        do {
            p = InfGetStringField (&is, 0);
            if (*p) {
                //
                // first check if the pattern is correct
                // if it isn't, we skip it
                //
                test = CreateParsedPattern (p);
                if (test) {
                    DestroyParsedPattern (test);
                    GrowBufAppendString (&joinedPattern, TEXT("<"));
                    GrowBufAppendString (&joinedPattern, p);
                    GrowBufAppendString (&joinedPattern, TEXT(">"));
                }
                ELSE_DEBUGMSG ((DBG_WHOOPS, "Unable to parse pattern %s in [%s]", p, S_COMPATIBLE_PNP_IDS));
            }
        } while (InfFindNextLine (&is));
    }
    InfCleanUpInfStruct (&is);

    if (joinedPattern.Buf) {
        g_PatternCompatibleIDsTable = CreateParsedPattern (joinedPattern.Buf);
        FreeGrowBuffer (&joinedPattern);
    }
}


BOOL
CreateNtHardwareList (
    IN      PCTSTR * NtInfPaths,
    IN      UINT NtInfPathCount,
    IN      PCTSTR HwCompDatPath,       OPTIONAL
    IN      INT UiMode
    )

/*++

Routine Description:

  CreateNtHardwareList gets a list of all INF files and calls pProcessNtInfFile
  to build the NT device list.  This routine is called at initialization.
  The resulting list is saved to disk as hwcomp.dat.  If hwcomp.dat already
  exists, the device list is read from disk.

Arguments:

  NtInfPaths - Specifies an array of full paths to the NT INF files.

  NtInfPathCount - Specifies the number of elements in NtInfPaths.  Cannot
                   be zero.

  HwCompDatPath - Specifies a full path spec where the new HWCOMP.DAT file
                  should be loaded from.  This is used by the hwdatgen tool.

  UiMode - Specifies the type of output (if any) to produce while building
           the device lists.  Values are zero, PNPREPT_OUTPUT, or
           VERBOSE_OUTPUT.

Return Value:

  Returns TRUE if successful, or FALSE if not.  Call GetLastError for
  failure code.

--*/

{
    PCTSTR SourceFile;
    PCTSTR DestFile;
    BOOL FreeSourceAndDest;
    UINT u;
    PTSTR File;
    DWORD rc;
    BOOL bSaved = FALSE;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR p;

    MYASSERT (NtInfPathCount > 0);

    //
    // If string tables already exist, then we do not have to build this list
    // a second time.
    //

    if (!g_PatternCompatibleIDsTable) {
        //
        // table not set up; build it now
        //
        pBuildPatternCompatibleIDsTable ();
    }

    if (g_PnpIdTable && g_UnsupPnpIdTable && g_InfFileTable && g_ForceBadIdTable) {
        return TRUE;
    }

    DEBUGMSG ((DBG_VERBOSE, "CreateNtHardwareList: building hardware list"));

    MYASSERT (!g_PnpIdTable);
    MYASSERT (!g_UnsupPnpIdTable);
    MYASSERT (!g_InfFileTable);
    MYASSERT (!g_ForceBadIdTable);

    //
    // Prepare file names.  If HwCompDatPath is provided, use it only.
    //

    if (HwCompDatPath) {
        //
        // Use caller-supplied path; the caller is not necessarily NT Setup.
        //

        SourceFile = HwCompDatPath;
        DestFile   = HwCompDatPath;
        FreeSourceAndDest = FALSE;
    } else {
        //
        // Locate the source hwcomp.dat.  If one does not exist,
        // use the first source directory as Source.
        //

        SourceFile = NULL;

        for (u = 0 ; !SourceFile && u < NtInfPathCount ; u++) {
            SourceFile = pGetHwCompDat (NtInfPaths[u], TRUE);
        }

        if (!SourceFile) {
            SourceFile = pGetHwCompDat (NtInfPaths[0], FALSE);
        }

        DestFile = pGetHwCompDat (g_TempDir, FALSE);
        FreeSourceAndDest = TRUE;
    }

    //
    // Build force table
    //

    if (g_ForceBadIdTable) {
        HtFree (g_ForceBadIdTable);
    }

    g_ForceBadIdTable = HtAlloc();

    if (InfFindFirstLine (g_Win95UpgInf, TEXT("Forced Incompatible IDs"), NULL, &is)) {

        do {

            p = InfGetStringField (&is, 0);

            if (*p) {
                HtAddString (g_ForceBadIdTable, p);
            }

        } while (InfFindNextLine (&is));

    }

    InfCleanUpInfStruct (&is);

    __try {
        //
        // Try loading state from CD
        //

        if (UiMode != PNPREPT_OUTPUT) {

            if (!LoadDeviceList (LOAD, SourceFile)) {
                //
                // Could not load from CD -- try loading from temporary storage
                // location
                //

                if (!HwCompDatPath && LoadDeviceList (LOAD, DestFile)) {
                    return TRUE;
                }

                DEBUGMSG ((DBG_HWCOMP, "%s does not exist or needs to be rebuilt", SourceFile));

            } else {
                return TRUE;
            }
        }

        //
        // Load the INF file names
        //

        ProgressBar_SetComponentById (MSG_DECOMPRESSING);

        // Get file names
        if (!g_FileNames.Buf && !g_DecompFileNames.Buf) {
            if (!GetFileNames (NtInfPaths, NtInfPathCount, FALSE, &g_FileNames, &g_DecompFileNames)) {
                DEBUGMSG ((DBG_WARNING, "HWCOMP: Can't get INF file names"));
                return FALSE;
            }
        }

        __try {

            ProgressBar_SetComponentById (MSG_HWCOMP);

            //
            // Initialize string tables
            //

            g_PnpIdTable = HtAllocWithData (sizeof (HASHITEM));
            g_UnsupPnpIdTable = HtAllocWithData (sizeof (HASHITEM));
            g_InfFileTable = HtAlloc();

            if (!g_PnpIdTable || !g_UnsupPnpIdTable || !g_InfFileTable) {
                LOG ((LOG_ERROR, "HWCOMP: Can't allocate string tables"));
                return FALSE;
            }

            //
            // Walk through list of INF files, and locate device names inside
            // manufacturer sections.  Add each name to the string table.
            //

            File = (PTSTR) g_FileNames.Buf;
            while (*File) {
                //
                // Skip non-WIN4 INF files
                //

                if (StringMatch (File, S_IGNORE_THIS_FILE)) {
                    File = GetEndOfString (File) + 1;
                    if (!TickProgressBar()) {
                        break;
                    }

                    continue;
                }

                //
                // Process all WIN4 INF files
                //

                if (UiMode != PNPREPT_OUTPUT) {
                    ProgressBar_SetSubComponent (File);
                }

                if (!pProcessNtInfFile (File, UiMode, g_InfFileTable, g_PnpIdTable, g_UnsupPnpIdTable)) {
                    if ((GetLastError() & 0xe0000000) == 0xe0000000) {
                        DEBUGMSG ((DBG_WARNING, "pProcessNtInfFile failed to parse %s.", File));
                    } else {
                        break;
                    }
                }

                if (!TickProgressBar()) {
                    break;
                }

                File = GetEndOfString (File) + 1;
            }

            rc = GetLastError();
            if (rc == ERROR_SUCCESS) {
                File = (PTSTR) g_DecompFileNames.Buf;
                while (*File) {
                    //
                    // Skip non-WIN4 INF files
                    //

                    if (StringMatch (File, S_IGNORE_THIS_FILE)) {
                        File = GetEndOfString (File) + 1;
                        if (!TickProgressBar()) {
                            break;
                        }

                        continue;
                    }

                    //
                    // Process all WIN4 INF files
                    //

                    if (UiMode != PNPREPT_OUTPUT) {
                        ProgressBar_SetSubComponent (File);
                    }

                    if (!pProcessNtInfFile (File, UiMode, g_InfFileTable, g_PnpIdTable, g_UnsupPnpIdTable)) {
                        if ((GetLastError() & 0xe0000000) == 0xe0000000) {
                            DEBUGMSG ((DBG_WARNING, "pProcessNtInfFile failed to parse %s.", File));
                        } else {
                            break;
                        }
                    }

                    if (!TickProgressBar()) {
                        break;
                    }

                    File = GetEndOfString (File) + 1;
                }
                rc = GetLastError();
            }

            //
            // Clean up UI
            //

            ProgressBar_SetComponent (NULL);
            ProgressBar_SetSubComponent (NULL);

            //
            // Save string tables to hwcomp.dat
            //

            if (UiMode == PNPREPT_OUTPUT) {
                bSaved = TRUE;
            } else if (rc == ERROR_SUCCESS) {
                bSaved = SaveDeviceList (DestFile);

                //
                // Try copying this file to the right place for future installs
                //

                if (bSaved && !HwCompDatPath) {
                    if (!StringIMatch (DestFile, SourceFile)) {
                        CopyFile (DestFile, SourceFile, FALSE);
                    }
                }

                if (!bSaved) {
                    rc = GetLastError();
                }
            }
        }

        __finally {
            FreeFileNames (&g_FileNames, &g_DecompFileNames, FALSE);
        }
    }

    __finally {
        if (FreeSourceAndDest) {
            pFreeHwCompDatName (SourceFile);
            pFreeHwCompDatName (DestFile);
        }
    }

    return bSaved;
}


VOID
FreeNtHardwareList (
    VOID
    )

/*++

Routine Description:

  FreeNtHardwareList cleans up the string tables.  This function is called by
  DllMain when a process detaches.

Arguments:

  none

Return Value:

  none

--*/

{
    if (g_InfFileTable) {
        HtFree (g_InfFileTable);
        g_InfFileTable = NULL;
    }

    if (g_PnpIdTable) {
        HtFree (g_PnpIdTable);
        g_PnpIdTable = NULL;
    }

    if (g_UnsupPnpIdTable) {
        HtFree (g_UnsupPnpIdTable);
        g_UnsupPnpIdTable = NULL;
    }

    if (g_ForceBadIdTable) {
        HtFree (g_ForceBadIdTable);
        g_ForceBadIdTable = NULL;
    }
}


//
// Routines that use the enumerators
//

BOOL
HwComp_ScanForCriticalDevices (
    VOID
    )

/*++

Routine Description:

  HwComp_ScanForCriticalDevices is one of the first functions called in
  the upgrade module.  It enumerates the hardware and determines if
  certain required devices are compatible.

Arguments:

  none

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.
  Call GetLastError() for failure code.

--*/

{
    HARDWARE_ENUM e;

    //
    // Reset flags for reentrancy
    //

    g_ValidWinDir = FALSE;
    g_ValidSysDrive = FALSE;
    g_ValidCdRom = FALSE;
    g_FoundPnp8387 = FALSE;

    if (g_NeededHardwareIds) {
        HtFree (g_NeededHardwareIds);
        g_NeededHardwareIds = NULL;
    }

    g_NeededHardwareIds = HtAlloc();
    MYASSERT (g_NeededHardwareIds);

    //
    // Make sure hardware list is valid
    //

    if (!CreateNtHardwareList (
            SOURCEDIRECTORYARRAY(),
            SOURCEDIRECTORYCOUNT(),
            NULL,
            REGULAR_OUTPUT
            )) {

        DEBUGMSG_IF ((
            GetLastError() != ERROR_CANCELLED,
            DBG_ERROR,
            "HwComp_ScanForCriticalDevices: CreateNtHardwareList failed!"
            ));

        return FALSE;
    }

    //
    // Scan all hardware
    //

    if (EnumFirstHardware (&e, ENUM_ALL_DEVICES, ENUM_WANT_COMPATIBLE_FLAG | ENUM_DONT_REQUIRE_HARDWAREID)) {
        do {
            //
            // Fill g_NeededHardwareIDs with all PNP IDs of incompatible devices.
            // Skip the devices that are deliberately unsupported.
            //

            if (!e.Compatible && !e.Unsupported) {
                if (e.HardwareID) {
                    AddPnpIdsToHashTable (g_NeededHardwareIds, e.HardwareID);
                }

                if (e.CompatibleIDs) {
                    AddPnpIdsToHashTable (g_NeededHardwareIds, e.CompatibleIDs);
                }
            }

            //
            // Test 1: Check to see if (A) g_WinDir is on supported device, and
            //         (B) g_BootDriveLetter is on a supported device.
            //

            if (e.Compatible && e.CurrentDriveLetter) {
                if (_tcschr (e.CurrentDriveLetter, _tcsnextc (g_WinDir))) {
                    g_ValidWinDir = TRUE;
                }

                if (_tcschr (e.CurrentDriveLetter, g_BootDriveLetter)) {
                    g_ValidSysDrive = TRUE;
                }
            }

            //
            // Test 2: Check to see if the class is CDROM
            //

            if (e.Compatible && e.Class) {
                if (StringIMatch (e.Class, TEXT("CDROM"))) {
                    g_ValidCdRom = TRUE;
                }
            }

            //
            // Test 3: Check to see if HardwareID or CompatibleIDs contains
            //         *PNP8387 (Dial-Up Adapter)
            //

            if (e.CompatibleIDs && _tcsistr (e.CompatibleIDs, TEXT("*PNP8387"))) {
                g_FoundPnp8387 = TRUE;
            }

            if (e.HardwareID && _tcsistr (e.HardwareID, TEXT("*PNP8387"))) {
                g_FoundPnp8387 = TRUE;
            }

            //
            // Test 4: Test for an incompatible SCSI adapter
            //

            if (e.HardwareID && !e.Compatible && _tcsistr (e.Class, TEXT("SCSI"))) {
                g_IncompatibleScsiDevice = TRUE;
            }

        } while (EnumNextHardware (&e));
    }

    return TRUE;
}


BOOL
HwComp_DialUpAdapterFound (
    VOID
    )

/*++

Routine Description:

  HwComp_DialUpAdapterFound returns TRUE if *PNP8387 was found
  during the HwComp_ScanForCriticalDevices routine.

Arguments:

  none

Return Value:

  TRUE if the Microsoft Dial-Up Adapter exists, or FALSE if it
  does not.

--*/

{
    return g_FoundPnp8387;
}


BOOL
HwComp_NtUsableHardDriveExists (
    VOID
    )

/*++

Routine Description:

  HwComp_NtUsableHardDriveExists returns TRUE if a compatible
  hard disk exists for the Windows directory and the boot
  drive.

Arguments:

  none

Return Value:

  TRUE if a compatible hard disk exists, or FALSE if one does
  not exist.

--*/

{
    return g_ValidSysDrive && g_ValidWinDir;
}


BOOL
HwComp_ReportIncompatibleController (
    VOID
    )

/*++

Routine Description:

  HwComp_ReportIncompatibleController adds a message when an incompatible
  hard disk controller is found.  If the boot drive or windir drive is
  incompatible, then a strong warning is given.  Otherwise, the message
  is informational.

Arguments:

  none

Return Value:

  TRUE if an incompatible controller message was added, FALSE otherwise.

--*/

{

    HARDWARE_ENUM e;
    BOOL MsgAdded = FALSE;
    PCTSTR Group;
    PCTSTR Message;
    BOOL BadMainDev;

    //
    // Do this only if a bad controller exists
    //

    BadMainDev = HwComp_NtUsableHardDriveExists();
    if (!BadMainDev && !g_IncompatibleScsiDevice) {
        return FALSE;
    }

    //
    // Scan incompatible hardware
    //

    if (EnumFirstHardware (
            &e,
            ENUM_NON_FUNCTIONAL_DEVICES,
            ENUM_WANT_COMPATIBLE_FLAG | ENUM_DONT_REQUIRE_HARDWAREID
            )) {

        do {

            //
            // this test is not reliable
            // there are CDROMs that will falll into this category but they are not HD controllers
            // and there are also real SCSI controllers that have an "Unknown" class because
            // Win9x doesn't have (or need) a driver for them
            //
#if 0
            if (_tcsistr (e.Class, TEXT("SCSI"))) {

                if (!MsgAdded) {
                    MsgAdded = TRUE;

                    Group = BuildMessageGroup (MSG_INCOMPATIBLE_HARDWARE_ROOT, MSG_INCOMPATIBLE_HARD_DISK_SUBGROUP, NULL);

                    Message = GetStringResource (
                                    BadMainDev ? MSG_INCOMPATIBLE_HARD_DISK_WARNING :
                                                 MSG_INCOMPATIBLE_HARD_DISK_NOTIFICATION
                                    );

                    MsgMgr_ContextMsg_Add (TEXT("*BadController"), Group, Message);

                    FreeText (Group);
                    FreeStringResource (Message);
                }

                MsgMgr_LinkObjectWithContext (TEXT("*BadController"), e.FullKey);
                DEBUGMSG ((DBG_HWCOMP, "Bad controller key: %s", e.FullKey));
            }
#endif

        } while (EnumNextHardware (&e));
    }

    return MsgAdded;
}


BOOL
HwComp_NtUsableCdRomDriveExists (
    VOID
    )

/*++

Routine Description:

  HwComp_NtUsableCdRomDriveExists returns TRUE if a compatible
  CD-ROM drive exists.

Arguments:

  none

Return Value:

  TRUE if a compatible CD-ROM drive exists, or FALSE if it does not.

--*/

{
    return g_ValidCdRom;
}


BOOL
HwComp_MakeLocalSourceDeviceExists (
    VOID
    )


/*++

Routine Description:

  MakeLocalSourceDevice scans the IDs found on the system for a match in a
  special section in win95upg.inf. If one of these devices is found, the
  function returns TRUE. This is used to catch cases where the user's CDrom
  drive may be attached to a device that will not be available during
  textmode.

Arguments:

  None.

Return Value:

  TRUE if such a device exists, FALSE otherwise.

--*/


{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    HASHTABLE table;
    HARDWARE_ENUM e;
    BOOL rDeviceExists = FALSE;
    PTSTR p = NULL;


    __try {
        if (InfFindFirstLine (g_Win95UpgInf, S_MAKELOCALSOURCEDEVICES, NULL, &is)) {

            table = HtAlloc ();

            //
            // Add all of the "bad" pnpids listed in win95upg.inf.
            //
            do {

                p = InfGetStringField (&is, 0);
                HtAddString (table, p);

            } while (InfFindNextLine (&is));

            //
            // Now, enumerate the devices on the system and see if we have any matches.
            //
            if (EnumFirstHardware (&e, ENUM_ALL_DEVICES, ENUM_WANT_ONLINE_FLAG)) {
                do {

                    if (HtFindString (table, e.HardwareID)) {

                        rDeviceExists = TRUE;
                        AbortHardwareEnum (&e);
                        DEBUGMSG ((DBG_WARNING, "Device %s requires us to turn on the local source flag.", e.HardwareID));
                        break;
                    }


                } while (EnumNextHardware (&e));
            }


            HtFree (table);
        }
    }
    __except (1) {
        return FALSE;
    }

    return rDeviceExists;

}


BOOL
HwComp_DoesDatFileNeedRebuilding (
    VOID
    )

/*++

Routine Description:

  HwComp_DoesDatFileNeedRebuilding locates hwcomp.dat in the source
  directories and determines if it needs to be rebuilt by obtaining
  the checksum in the file and comparing it against the one from
  the current INF files.

Arguments:

  none

Return Value:

  TRUE if the hwcomp.dat file needs to be rebuilt, or FALSE if it
  does not.

--*/

{
    PCTSTR SourceFile = NULL;
    UINT u;
    BOOL b = FALSE;

    for (u = 0 ; u < SOURCEDIRECTORYCOUNT() ; u++) {
        SourceFile = pGetHwCompDat(SOURCEDIRECTORY(u), TRUE);
        if (SourceFile) {
            break;
        }
    }

    if (SourceFile) {
        TurnOnWaitCursor();
        b = LoadDeviceList (QUERY, SourceFile);
        TurnOffWaitCursor();

        pFreeHwCompDatName (SourceFile);
    }

    // b is TRUE when hwcomp.dat is valid, so return opposite
    return !b;
}


INT
HwComp_GetProgressMax (
    VOID
    )

/*++

Routine Description:

  HwComp_GetProgressMax calculates the number of INF files that would
  need to be scanned if hwcomp.dat needs to be rebuilt.  If it is
  determined that hwcomp.dat does not need to be rebuilt, the function
  returns zero.

Arguments:

  none

Return Value:

  The number of INF files that need to be processed, times two.  (One
  pass for decompression, another pass for parsing the INFs.)

--*/

{
    INT FileCount = 0;
    PCTSTR File;
    PCTSTR SourceFile = NULL;
    BOOL b = FALSE;

    //
    // Query validity of hwcomp.dat
    //

    if (!HwComp_DoesDatFileNeedRebuilding()) {
        return 0;
    }

    //
    // hwcomp.dat needs to be rebuilt, so return the number of files
    // that need to be scanned times two.
    //

    // Count files
    if (!g_FileNames.Buf && !g_DecompFileNames.Buf) {
        if (!GetFileNames (
                SOURCEDIRECTORYARRAY(),
                SOURCEDIRECTORYCOUNT(),
                TRUE,
                &g_FileNames,
                &g_DecompFileNames
                )) {
            LOG ((LOG_ERROR, "HWCOMP: Can't estimate number of INF files"));
            return 850;             // estimation, so there is some progress bar activity
        }
    }

    for (File = (PCTSTR) g_FileNames.Buf ; *File ; File = GetEndOfString (File) + 1) {
        FileCount++;
    }
    for (File = (PCTSTR) g_DecompFileNames.Buf ; *File ; File = GetEndOfString (File) + 1) {
        FileCount++;
    }

    FreeFileNames (&g_FileNames, &g_DecompFileNames, TRUE);
    MYASSERT (!g_FileNames.Buf);
    MYASSERT (!g_DecompFileNames.Buf);

    return FileCount*2;
}


BOOL
pIsDeviceConsideredCompatible (
    PCTSTR DevIds
    )

/*++

Routine Description:

  pIsDeviceConsideredCompatible scans a list of comma-separated
  PNP IDs against the list in win95upg.inf.  If at least one
  ID matches, TRUE is returned.

  This function also implements a hack for the VIRTUAL root.

Arguments:

  DevIds - Specifies a list of zero or more PNP IDs, separated
           by commas.

Return Value:

  TRUE if a PNP ID was found to be overridden as compatible, or
  FALSE if none of the IDs are in win95upg.inf.

--*/

{
    TCHAR Id[MAX_PNP_ID];
    INFCONTEXT ic;

    while (*DevIds) {

        //
        // Create Id string from comma-separated PNP ID list
        //

        DevIds = ExtractPnpId (DevIds, Id);
        if (*Id == 0) {
            continue;
        }

        //
        // Search win95upg.inf for the PNP ID
        //

        if (SetupFindFirstLine (g_Win95UpgInf, S_STANDARD_PNP_IDS, Id, &ic)) {
            DEBUGMSG ((DBG_HWCOMP, "%s is incompatible, but suppressed in win95upg.inf", Id));
            return TRUE;
        }

        //
        // This is a hack for the VIRTUAL enumerator, used by Turtle Beach.
        //

        if (StringIMatchCharCount (TEXT("VIRTUAL\\"), Id, 8)) {
            return TRUE;
        }

        //
        // Test for pattern PNPIDs
        //
        if (g_PatternCompatibleIDsTable && TestParsedPattern (g_PatternCompatibleIDsTable, Id)) {
            DEBUGMSG ((DBG_HWCOMP, "%s is incompatible, but suppressed in win95upg.inf", Id));
            return TRUE;
        }
    }

    return FALSE;
}



BOOL
pIsDeviceInstalled (
    IN     PCTSTR DeviceDesc
    )

/*++

Routine Description:

  pIsDeviceInstalled scans the registry looking for a device that has the
  specified description and is online.

Arguments:

  DeviceDesc - Specifies the description of the duplicate device to find
               (i.e., Dial-Up Adapter)

Return Value:

  TRUE if an identical device was found and is online, or FALSE if not.

--*/

{
    HARDWARE_ENUM e;

    if (EnumFirstHardware (
            &e,
            ENUM_NON_FUNCTIONAL_DEVICES,
            ENUM_WANT_ONLINE_FLAG|ENUM_DONT_WANT_USER_SUPPLIED
            )) {
        do {
            if (e.Online) {
                if (e.DeviceDesc) {
                    if (StringIMatch (e.DeviceDesc, DeviceDesc)) {
                        AbortHardwareEnum (&e);
                        return TRUE;
                    }
                }
            }
        } while (EnumNextHardware (&e));
    }

    return FALSE;
}


VOID
pGetFriendlyClassName (
    IN      HKEY ClassKey,
    IN      PCTSTR Class,
    OUT     PTSTR Buffer
    )
{
    PCTSTR Data = NULL;
    HKEY SubKey;

    SubKey = OpenRegKey (ClassKey, Class);

    if (SubKey) {
        Data = GetRegValueString (SubKey, S_EMPTY);
        CloseRegKey (SubKey);

        if (!Data || !*Data) {
            SubKey = NULL;
        }
    }

    if (!SubKey) {
        Data = GetStringResource (MSG_UNKNOWN_DEVICE_CLASS);
        if (Data) {
            _tcssafecpy (Buffer, Data, MAX_TCHAR_PATH);
            FreeStringResource (Data);
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "Unable to load string resource MSG_UNKNOWN_DEVICE_CLASS. Check localization."));
        return;
    }

    _tcssafecpy (Buffer, Data, MAX_TCHAR_PATH);
    MemFree (g_hHeap, 0, Data);

    return;
}


BOOL
pStuffDeviceInReport (
    PHARDWARE_ENUM e,
    HKEY Key,
    HWTYPES SupportedType
    )

/*++

Routine Description:

  pStuffDeviceInReport adds a device to the upgrade report.  The device is
  either incompatible or unsupported.

Arguments:

  e            - Specifies the current hardware enumerator struct.
  Key          - Specifies a handle to the Class key in HKLM\System\Services
  SupportedType - Specifies one of the HWTYPES constants -- HW_INCOMPATIBLE,
                  HW_REINSTALL or HW_UNINSTALL, to indicate which category
                  to stuff the message into.

Return Value:

  None.

--*/

{
    PCTSTR ModifiedDescription = NULL;
    PCTSTR Group = NULL;
    PCTSTR Message = NULL;
    PCTSTR DeviceDesc = NULL;
    PCTSTR Array[6];
    BOOL UnknownClass = FALSE;
    PCTSTR Mfg;
    PCTSTR Class;
    PCTSTR HardwareID;
    PCTSTR CompatibleID;
    PCTSTR ClassAndName;
    TCHAR FriendlyClass[MAX_TCHAR_PATH];
    UINT SubGroup;
    PCTSTR SubGroupText;            // for log output only, hard-coded text
    BOOL b = FALSE;

    //
    // Determine which group this message belongs in. The order is determined
    // by the alphanumeric order of SubGroup.
    //

    if (SupportedType == HW_INCOMPATIBLE) {
        SubGroup =  MSG_INCOMPATIBLE_HARDWARE_PNP_SUBGROUP;
        SubGroupText = TEXT("Incompatible");
    } else if (SupportedType == HW_REINSTALL) {
        SubGroup =  MSG_REINSTALL_HARDWARE_PNP_SUBGROUP;
        SubGroupText = TEXT("Reinstall");
    } else {
        SubGroup =  MSG_UNSUPPORTED_HARDWARE_PNP_SUBGROUP;
        SubGroupText = TEXT("Unsupported");
    }

    //
    // Is device suppressed?
    //

    if (IsReportObjectHandled (e->FullKey)) {
        return FALSE;
    }

    //
    // Sometimes blank entries are found!!
    //

    __try {
        DeviceDesc = e->DeviceDesc;

        if (!DeviceDesc || (DeviceDesc && *DeviceDesc == 0)) {

            LOG ((
                LOG_ERROR,
                "Skipping device because it lacks DriverDesc (%s,%s,%s)",
                e->Mfg,
                e->Class,
                e->HardwareID
                ));

            __leave;
        }

        Mfg = e->Mfg;
        if (!Mfg) {

            DEBUGMSG ((
                DBG_WARNING,
                "Device lacking manufacturer (%s,%s,%s)",
                e->DeviceDesc,
                e->Class,
                e->HardwareID
                ));

            Mfg = S_EMPTY;
        }

        Class = e->Class;
        if (!Class) {

            DEBUGMSG ((
                DBG_WARNING,
                "Device lacking class (%s,%s,%s)",
                e->DeviceDesc,
                e->Mfg,
                e->HardwareID
                ));

            Class = GetStringResource (MSG_UNKNOWN_DEVICE_CLASS);
            MYASSERT (Class);
            UnknownClass = TRUE;
        }

        HardwareID = e->HardwareID;
        if (!HardwareID) {

            DEBUGMSG ((
                DBG_WARNING,
                "Device lacking hardware ID (%s,%s,%s)",
                e->DeviceDesc,
                e->Mfg,
                e->Class
                ));

            HardwareID = S_EMPTY;
        }

        CompatibleID = e->CompatibleIDs;
        if (!CompatibleID) {
            CompatibleID = S_EMPTY;
        }

        //
        // Add "(not currently present)" to offline devices
        //

        if (!e->Online) {
            //
            // Verify identical online device doesn't exist
            //

            if (pIsDeviceInstalled (DeviceDesc)) {
                __leave;
            }

            Array[0] = DeviceDesc;
            ModifiedDescription = ParseMessageID (MSG_OFFLINE_DEVICE, Array);
        }

        //
        // Add hardware message to the incompatibility table
        //

        if (UnknownClass) {
            StringCopy (FriendlyClass, Class);
        } else {
            pGetFriendlyClassName (Key, Class, FriendlyClass);
        }

        DEBUGMSG ((
            DBG_HWCOMP,
            "%s Device:\n"
                "  %s (%s)\n"
                "  %s\n"
                "  %s (%s)\n"
                "  %s\n",
            SubGroupText,
            HardwareID,
            CompatibleID,
            ModifiedDescription ? ModifiedDescription : DeviceDesc,
            Class,
            FriendlyClass,
            Mfg
            ));

        //
        // Add the message via message manager
        //

        Array[0] = ModifiedDescription ? ModifiedDescription : DeviceDesc;
        Array[1] = S_EMPTY;         // formerly Enumerator Text
        Array[2] = Class;
        Array[3] = Mfg;
        Array[4] = HardwareID;
        Array[5] = FriendlyClass;

        ClassAndName = JoinPaths (Array[5], Array[0]);

        Group = BuildMessageGroup (
                    MSG_INCOMPATIBLE_HARDWARE_ROOT,
                    SubGroup,
                    ClassAndName
                    );
        MYASSERT (Group);

        FreePathString (ClassAndName);

        Message = ParseMessageID (MSG_HARDWARE_MESSAGE, Array);
        MYASSERT (Message);

        MsgMgr_ObjectMsg_Add (e->FullKey, Group, Message);

        LOG ((
            LOG_INFORMATION,
            "%s Device:\n"
                "  %s (%s)\n"
                "  %s\n"
                "  %s\n"
                "  %s\n",
            SubGroupText,
            HardwareID,
            CompatibleID,
            ModifiedDescription ? ModifiedDescription : DeviceDesc,
            Class,
            Mfg
            ));

        b = TRUE;

    }
    __finally {

        //
        // Cleanup
        //

        FreeStringResource (ModifiedDescription);
        FreeText (Group);
        FreeStringResource (Message);

        if (UnknownClass) {
            FreeStringResource (Class);
        }
    }

    return b;
}


LONG
HwComp_PrepareReport (
    VOID
    )

/*++

Routine Description:

  HwComp_PrepareReport is called after the progress bar on the
  Win9x side of the upgrade.  It enumerates the hardware and adds
  incompatibility messages for all incompatible hardware.

Arguments:

  None.

Return Value:

  A Win32 status code.

--*/

{
    LONG rc;
    HARDWARE_ENUM e;
    HKEY Key;
    HWTYPES msgType;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PTSTR pnpIdList;
    PTSTR p, q;
    TCHAR ch;

    Key = OpenRegKeyStr (TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class"));

    __try {

        if (!CreateNtHardwareList (
                SOURCEDIRECTORYARRAY(),
                SOURCEDIRECTORYCOUNT(),
                NULL,
                REGULAR_OUTPUT
                )) {

            rc = GetLastError();
            if (rc != ERROR_CANCELLED) {
                LOG ((LOG_ERROR, "Could not create list of NT hardware."));
            }

            __leave;
        }

        if (EnumFirstHardware (
                &e,
                ENUM_INCOMPATIBLE_DEVICES,
                ENUM_WANT_ONLINE_FLAG|ENUM_DONT_WANT_USER_SUPPLIED
                )) {

            do {

                msgType = HW_INCOMPATIBLE;

                if (e.HardwareID) {
                    pnpIdList = DuplicateText (e.HardwareID);

                    p = pnpIdList;
                    do {
                        q = _tcschr (p, TEXT(','));
                        if (!q) {
                            q = GetEndOfString (p);
                        }

                        ch = *q;
                        *q = 0;

                        if (InfFindFirstLine (g_Win95UpgInf, S_REINSTALL_PNP_IDS, p, &is)) {
                            msgType = HW_REINSTALL;
                            DEBUGMSG ((DBG_HWCOMP, "Found reinstall hardware ID %s", p));
                            break;
                        }

                        *q = ch;
                        p = q + 1;
                    } while (ch);

                    FreeText (pnpIdList);
                }

                if (msgType == HW_INCOMPATIBLE && e.CompatibleIDs) {
                    pnpIdList = DuplicateText (e.CompatibleIDs);

                    p = pnpIdList;
                    do {
                        q = _tcschr (p, TEXT(','));
                        if (!q) {
                            q = GetEndOfString (p);
                        }

                        ch = *q;
                        *q = 0;

                        if (InfFindFirstLine (g_Win95UpgInf, S_REINSTALL_PNP_IDS, p, &is)) {
                            msgType = HW_REINSTALL;
                            DEBUGMSG ((DBG_HWCOMP, "Found reinstall compatible ID %s", p));
                            break;
                        }

                        *q = ch;
                        p = q + 1;
                    } while (ch);

                    FreeText (pnpIdList);
                }

                if (pStuffDeviceInReport (&e, Key, msgType)) {
                    DEBUGMSG ((DBG_HWCOMP, "Found incompatible hardware %s", e.DeviceDesc));
                }

            } while (EnumNextHardware (&e));
        }

        if (EnumFirstHardware (
                &e,
                ENUM_UNSUPPORTED_DEVICES,
                ENUM_WANT_ONLINE_FLAG|ENUM_DONT_WANT_USER_SUPPLIED
                )) {

            do {

                if (pStuffDeviceInReport (&e, Key, HW_UNSUPPORTED)) {
                    DEBUGMSG ((DBG_HWCOMP, "Found incompatible hardware %s", e.DeviceDesc));
                }

            } while (EnumNextHardware (&e));
        }

        rc = ERROR_SUCCESS;
    }
    __finally {
        if (Key) {
            CloseRegKey (Key);
        }
        InfCleanUpInfStruct (&is);
    }

    return rc;
}


BUSTYPE
pGetBusType (
    IN      PHARDWARE_ENUM EnumPtr
    )

/*++

Routine Description:

  pGetBusType returns the type of bus that the current hardware
  devices belongs to.

Arguments:

  EnumPtr - Specifies hardware device to process as returned from
            the hardware enum functions.

Return Value:

  The enumerated bus type.

--*/

{
    PCTSTR p, q;
    TCHAR Bus[MAX_HARDWARE_STRING];

    if (EnumPtr->BusType) {
        StringCopy (Bus, EnumPtr->BusType);
    } else {

        p = EnumPtr->FullKey;
        p = _tcschr (p, TEXT('\\'));
        if (p) {
            p = _tcschr (_tcsinc (p), TEXT('\\'));
        }
        if (!p) {
            return BUSTYPE_UNKNOWN;
        }

        p++;
        q = _tcschr (p, TEXT('\\'));
        if (!q) {
            q = GetEndOfString (p);
        }

        StringCopyAB (Bus, p, q);
    }

    if (StringIMatch (Bus, S_ISA)) {
        return BUSTYPE_ISA;
    }
    if (StringIMatch (Bus, S_EISA)) {
        return BUSTYPE_EISA;
    }
    if (StringIMatch (Bus, S_MCA)) {
        return BUSTYPE_MCA;
    }
    if (StringIMatch (Bus, S_PCI)) {
        return BUSTYPE_PCI;
    }
    if (StringIMatch (Bus, S_PNPISA)) {
        return BUSTYPE_PNPISA;
    }
    if (StringIMatch (Bus, S_PCMCIA)) {
        return BUSTYPE_PCMCIA;
    }
    if (StringIMatch (Bus, S_ROOT)) {
        return BUSTYPE_ROOT;
    }
    if (ISPC98()) {
        if (StringIMatch (Bus, S_C98PNP)) {
            return BUSTYPE_PNPISA;
        }
    }

    return BUSTYPE_UNKNOWN;
}


VOID
pGetIoAddrs (
    IN      PHARDWARE_ENUM EnumPtr,
    OUT     PTSTR Buf
    )

/*++

Routine Description:

  pGetIoAddrs returns a list of comma-separated IO address ranges.
  For example:

    0x310-0x31F,0x388-0x38F

Arguments:

  EnumPtr - Specifies device to process

  Buf - Receives zero or more comma-separated address ranges.

Return Value:

  none

--*/

{
    DEVNODERESOURCE_ENUM e;
    PIO_RESOURCE_9X IoRes;
    PTSTR p;

    *Buf = 0;
    p = Buf;

    if (EnumFirstDevNodeResource (&e, EnumPtr->FullKey)) {
        do {

            if (e.Type == ResType_IO) {
                if (p > Buf) {
                    p = _tcsappend (p, TEXT(","));
                }

                IoRes = (PIO_RESOURCE_9X) e.ResourceData;
                wsprintf (
                    p,
                    TEXT("0x%X-0x%X"),
                    IoRes->IO_Header.IOD_Alloc_Base,
                    IoRes->IO_Header.IOD_Alloc_End
                    );

                p = GetEndOfString (p);
            }
        } while (EnumNextDevNodeResource (&e));
    }
}


VOID
pGetIrqs (
    IN      PHARDWARE_ENUM EnumPtr,
    OUT     PTSTR Buf
    )

/*++

Routine Description:

  pGetIrqs returns a list of comma-separated IRQs used by the device.
  For example:

    0x07,0x0F

Arguments:

  EnumPtr - Specifies the device to process

  Buf - Receives zero or more comma-separated IRQs

Return Value:

  none

--*/

{
    DEVNODERESOURCE_ENUM e;
    PIRQ_RESOURCE_9X IrqRes;
    PTSTR p;

    *Buf = 0;
    p = Buf;

    if (EnumFirstDevNodeResource (&e, EnumPtr->FullKey)) {
        do {

            if (e.Type == ResType_IRQ) {
                if (p > Buf) {
                    p = _tcsappend (p, TEXT(","));
                }

                IrqRes = (PIRQ_RESOURCE_9X) e.ResourceData;
                wsprintf (
                    p,
                    TEXT("0x%02X"),
                    IrqRes->AllocNum
                    );

                p = GetEndOfString (p);
            }
        } while (EnumNextDevNodeResource (&e));
    }
}


VOID
pGetDma (
    IN      PHARDWARE_ENUM EnumPtr,
    OUT     PTSTR Buf
    )

/*++

Routine Description:

  pGetDma returns a list of comma-separated DMA channels used
  by the device.  For example:

  1,4

  An empty string means "auto"

Arguments:

  EnumPtr - Specifies hardware device to process

  Buf - Receives zero or more comma-separated DMA channel numbers

Return Value:

  none

--*/

{
    DEVNODERESOURCE_ENUM e;
    PDMA_RESOURCE_9X DmaRes;
    DWORD Bit, Channel;
    PTSTR p;

    *Buf = 0;
    p = Buf;

    if (EnumFirstDevNodeResource (&e, EnumPtr->FullKey)) {
        do {

            if (e.Type == ResType_DMA) {
                if (p > Buf) {
                    p = _tcsappend (p, TEXT(","));
                }

                DmaRes = (PDMA_RESOURCE_9X) e.ResourceData;
                Channel = 0;

                for (Bit = 1 ; Bit ; Bit <<= 1) {

                    if (DmaRes->DMA_Bits & Bit) {
                        wsprintf (p, TEXT("%u"), Channel);
                        p = GetEndOfString (p);
                    }

                    Channel++;
                }

                p = GetEndOfString (p);
            }
        } while (EnumNextDevNodeResource (&e));
    }
}


VOID
pGetMemRanges (
    IN      PHARDWARE_ENUM EnumPtr,
    OUT     PTSTR Buf
    )

/*++

Routine Description:

  pGetMemRanges returns a list of comma-separated memory addresses
  used by the device.  For example:

  0x0000D800-0x0000D9FF,0x0000F000-0x0000FFFF

Arguments:

  EnumPtr - Specifies hardware to process

  Buf - Receives zero or more comma-separated address ranges

Return Value:

  none

--*/

{
    DEVNODERESOURCE_ENUM e;
    PMEM_RESOURCE_9X MemRes;
    PTSTR p;

    *Buf = 0;
    p = Buf;

    if (EnumFirstDevNodeResource (&e, EnumPtr->FullKey)) {
        do {

            if (e.Type == ResType_Mem) {
                if (p > Buf) {
                    p = _tcsappend (p, TEXT(","));
                }

                MemRes = (PMEM_RESOURCE_9X) e.ResourceData;

                wsprintf (
                    p,
                    TEXT("0x%08X-0x%08X"),
                    MemRes->MEM_Header.MD_Alloc_Base,
                    MemRes->MEM_Header.MD_Alloc_End
                    );

                p = GetEndOfString (p);
            }
        } while (EnumNextDevNodeResource (&e));
    }
}


TRANSCIEVERTYPE
pGetTranscieverType (
    IN      PHARDWARE_ENUM EnumPtr
    )


/*++

Routine Description:

  pGetTranscieverType returns the transciever type for the specified
  device (i.e. net card).

Arguments:

  EnumPtr - Specifies hardware device to process

Return Value:

  The devices's transciever type

--*/


{
    return TRANSCIEVERTYPE_AUTO;
}


IOCHANNELREADY
pGetIoChannelReady (
    IN      PHARDWARE_ENUM EnumPtr
    )


/*++

Routine Description:

  pGetIoChannelReady returns the setting of the IoChannelReady
  mode for a device.

Arguments:

  EnumPtr - Specifies hardware device to process

Return Value:

  The device's IO Channel Ready mode

--*/


{
    return IOCHANNELREADY_AUTODETECT;
}


/*++

Routine Description:

  EnumFirstNetCard/EnumNextNetCard enumerate all installed network adapters
  on a machine.

Arguments:

  EnumPtr - An uninitiailzed structure that receives the state of enumeration.

Return Value:

  TRUE if a net card was enumerated, or FALSE if no more net cards exist.

--*/

BOOL
EnumFirstNetCard (
    OUT     PNETCARD_ENUM EnumPtr
    )
{
    START_NET_ENUM;

    ZeroMemory (EnumPtr, sizeof (NETCARD_ENUM));
    EnumPtr->State = STATE_ENUM_FIRST_HARDWARE;

    return EnumNextNetCard (EnumPtr);
}

BOOL
EnumNextNetCard (
    IN OUT  PNETCARD_ENUM EnumPtr
    )
{
    PHARDWARE_ENUM ep;

    for (;;) {

        switch (EnumPtr->State) {

        case STATE_ENUM_FIRST_HARDWARE:
            if (!EnumFirstHardware (&EnumPtr->HardwareEnum, ENUM_ALL_DEVICES,ENUM_DONT_REQUIRE_HARDWAREID)) {
                END_NET_ENUM;
                return FALSE;
            }

            EnumPtr->State = STATE_EVALUATE_HARDWARE;
            break;

        case STATE_ENUM_NEXT_HARDWARE:
            if (!EnumNextHardware (&EnumPtr->HardwareEnum)) {
                END_NET_ENUM;
                return FALSE;
            }

            EnumPtr->State = STATE_EVALUATE_HARDWARE;
            break;

        case STATE_EVALUATE_HARDWARE:
            ep = &EnumPtr->HardwareEnum;

            EnumPtr->State = STATE_ENUM_NEXT_HARDWARE;

            if (!StringIMatch (ep->Class, TEXT("Net"))) {
                break;
            }

            if (ep -> HardwareID) {
                _tcssafecpy (EnumPtr->HardwareId, ep->HardwareID, MAX_HARDWARE_STRING);
            }

            if (ep -> CompatibleIDs) {
                _tcssafecpy (EnumPtr -> CompatibleIDs, ep -> CompatibleIDs, MAX_HARDWARE_STRING);
            }

            if (ep->DeviceDesc) {
                _tcssafecpy (EnumPtr->Description, ep->DeviceDesc, MAX_HARDWARE_STRING);
            } else {
                EnumPtr->Description[0] = 0;
            }
            _tcssafecpy (EnumPtr->CurrentKey, ep->ek.FullKeyName, MAX_HARDWARE_STRING);

            EnumPtr->BusType = pGetBusType (ep);
            EnumPtr->TranscieverType = pGetTranscieverType (ep);
            EnumPtr->IoChannelReady = pGetIoChannelReady (ep);

            pGetIoAddrs (ep, EnumPtr->IoAddrs);
            pGetIrqs (ep, EnumPtr->Irqs);
            pGetDma (ep, EnumPtr->Dma);
            pGetMemRanges (ep, EnumPtr->MemRanges);

            return TRUE;
        }
    }
}

VOID
EnumNetCardAbort (
    IN      PNETCARD_ENUM EnumPtr
    )
{
    PushError();
    END_NET_ENUM;
    AbortHardwareEnum (&EnumPtr->HardwareEnum);
    PopError();
}



VOID
EncodePnpId (
    IN OUT  LPSTR Id
    )

/*++

Routine Description:

  This routine is used for the pnprept tool to encode a PNP ID so it does not
  have any backslashes.

Arguments:

  Id - Specifies ID that may have backslashes.  The buffer must be big enough
       to hold strlen(Id) * 2 characters.

Return Value:

  none

--*/

{
    CHAR TempBuf[MAX_MBCHAR_PATH];
    LPSTR s, d;

    s = Id;
    d = TempBuf;
    while (*s) {
        if (*s == '\\') {
            *d = '~';
            d++;
            *d = '1';
        } else if (*s == '*') {
            *d = '~';
            d++;
            *d = '2';
        } else if (*s == '~') {
            *d = '~';
            d++;
            *d = '~';
        }
        else {
            *d = *s;
        }

        d++;
        s++;
    }

    *d = 0;
    lstrcpy (Id, TempBuf);
}

VOID
DecodePnpId (
    IN OUT  LPSTR Id
    )

/*++

Routine Description:

  This routine is used by pnprept to decode a PNP ID that was encoded by
  EncodePnpId.

Arguments:

  Id - Specifies the encoded string to process.  The string is truncated if
       any encoded characters are found.

Return Value:

  none

--*/

{
    LPSTR s, d;

    s = Id;
    d = Id;
    while (*s) {
        if (*s == '~') {
            s++;
            if (*s == '1') {
                *d = '\\';
            } else if (*s == '2') {
                *d = '*';
            } else {
                *d = *s;
            }
        } else if (d < s) {
            *d = *s;
        }

        d++;
        s++;
    }

    *d = 0;
}



BOOL
pFindFileInAnySourceDir (
    IN      PCTSTR File,
    OUT     PTSTR MatchPath
    )
{
    UINT Count;
    UINT i;
    PCTSTR Path;

    Count = SOURCEDIRECTORYCOUNT();

    for (i = 0 ; i < Count ; i++) {
        Path = JoinPaths (SOURCEDIRECTORY(i), File);

        __try {
            if (DoesFileExist (Path)) {
                _tcssafecpy (MatchPath, Path, MAX_TCHAR_PATH);
                return TRUE;
            }
        }
        __finally {
            FreePathString (Path);
        }
    }

    return FALSE;
}


BOOL
GetLegacyKeyboardId (
    OUT     PTSTR Buffer,
    IN      UINT BufferSize
    )

/*++

Routine Description:

  GetLegacyKeyboardId looks in NT's keyboard.inf for a legacy mapping.
  If one is found, the legacy ID is returned to the caller so they
  can write it to the answer file.

Arguments:

  Buffer - Receives the legacy text corresponding to the installed
           keyboard device.

  BufferSize - Specifies the size of Buffer in bytes

Return Value:

  TRUE if the legacy ID was found and copied, or FALSE if an error
  occurred.  If FALSE is returned, the caller should add an incompatibility
  message and let NT decide which keyboard to use.

--*/

{
    HINF Inf;
    TCHAR KeyboardInfPath[MAX_TCHAR_PATH];
    TCHAR TempDir[MAX_TCHAR_PATH];
    PCTSTR TempKeyboardInfPath;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR PnpId, LegacyId;
    LONG rc;
    UINT keyboardType;
    UINT keyboardSubtype;
    PTSTR id = NULL;
    HARDWARE_ENUM e;
    TCHAR curId[MAX_PNP_ID];
    PCTSTR devIds = NULL;


    keyboardType = GetKeyboardType (0);
    keyboardSubtype = GetKeyboardType (1);

    //
    // keyboard type : 7 - Japanese keyboard
    //
    if (keyboardType == 7) {

        //
        // sub type : 2 - 106 keyboard
        //
        if (keyboardSubtype == 2) {

            id = TEXT("PCAT_106KEY");

            //
            // Ok, we have a japanese keyboard. Still, it may be USB which
            // requires a different entry. Lets check.
            //
            if (EnumFirstHardware (&e, ENUM_COMPATIBLE_DEVICES, ENUM_WANT_DEV_FIELDS)) {



                do {
                    devIds = e.HardwareID;

                    while (*devIds) {

                        devIds = ExtractPnpId (devIds, curId);
                        if (*curId == 0) {
                            continue;
                        }


                        if (InfFindFirstLine (g_Win95UpgInf, S_JPN_USB_KEYBOARDS, curId, &is)) {

                            id = TEXT("kbdhid");
                            AbortHardwareEnum (&e);
                            break;
                        }
                    }



                } while (EnumNextHardware (&e) && !StringIMatch (id, TEXT("kbdhid")));
            }



            _tcssafecpy (Buffer, id, BufferSize / sizeof (TCHAR));
            return TRUE;
        }
    }

    //
    // keyboard type : 8 - Korean keyboard
    //
    if (keyboardType == 8) {

        switch (keyboardSubtype) {

        case 3:

            //
            // 101a keyboard
            //
            id = TEXT("STANDARD");
            break;
        case 4:

            //
            // 101b keyboard
            //
            id = TEXT("101B TYPE");
            break;
        case 5:

            //
            // 101c keyboard
            //
            id = TEXT("101C TYPE");
            break;
        case 6:

            //
            // 103 keyboard
            //
            id = TEXT("103 TYPE");
            break;
        }

        if (id) {

            _tcssafecpy (Buffer, id, BufferSize);
            return TRUE;
        }
   }

    //
    // Move keyboard.in_ (or keyboard.inf) from NT sources into
    // temp dir.
    //

    if (!pFindFileInAnySourceDir (S_KEYBOARD_IN_, KeyboardInfPath)) {
        if (!pFindFileInAnySourceDir (S_KEYBOARD_INF, KeyboardInfPath)) {
            LOG ((LOG_ERROR,"GetLegacyKeyboardId: keyboard.inf not found in sources"));
            return FALSE;
        }
    }

    GetTempPath (sizeof (TempDir), TempDir);
    TempKeyboardInfPath = JoinPaths (TempDir, S_KEYBOARD_INF);

    __try {
        rc = SetupDecompressOrCopyFile (
                KeyboardInfPath,
                TempKeyboardInfPath,
                0
                );

        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR,"GetLegacyKeyboardId: keyboard.inf could not be copied to temp dir"));
            return FALSE;
        }

        __try {
            Inf = InfOpenInfFile (TempKeyboardInfPath);

            if (Inf == INVALID_HANDLE_VALUE) {
                LOG ((LOG_ERROR,"GetLegacyKeyboardId: %s could not be opened",TempKeyboardInfPath));
                return FALSE;
            }

            __try {
                //
                // We now have keyboard.inf open.  Let's enumerate each PNP
                // ID in the [LegacyXlate.DevId] section and check if the
                // hardware is available.
                //

                if (InfFindFirstLine (Inf, S_WIN9XUPGRADE, NULL, &is)) {
                    do {
                        PnpId = InfGetStringField (&is, 0);
                        if (PnpId) {
                            //
                            // Is PnpId online?
                            //

                            DEBUGMSG ((DBG_HWCOMP, "Searching for keyboard ID %s", PnpId));

                            if (IsPnpIdOnline (PnpId, S_KEYBOARD_CLASS)) {
                                //
                                // Yes - obtain PNP, copy to caller's buffer
                                // and get out
                                //

                                LegacyId = InfGetStringField (&is, 1);
                                if (LegacyId) {
                                    DEBUGMSG ((DBG_HWCOMP, "Found match: %s = %s", LegacyId, PnpId));
                                    _tcssafecpy (Buffer, LegacyId, BufferSize / sizeof (TCHAR));
                                    return TRUE;
                                }
                            }
                        }

                        InfResetInfStruct (&is);

                    } while (InfFindNextLine (&is));
                }

            }
            __finally {
                InfCleanUpInfStruct (&is);
                InfCloseInfFile (Inf);
            }

        }
        __finally {
            DeleteFile (TempKeyboardInfPath);
        }

    }
    __finally {
        FreePathString (TempKeyboardInfPath);
    }

    return FALSE;
}


BOOL
IsComputerOffline (
    VOID
    )

/*++

Routine Description:

  IsComputerOffline checks if a network card exists on the machine and is
  currently present.

Arguments:

  None.

Return Value:

  TRUE if the machine is known to be offline, or FALSE if the online state is
  not known.

--*/


{
    HARDWARE_ENUM e;
    BOOL possiblyOnline = FALSE;

    if (EnumFirstHardware (&e, ENUM_ALL_DEVICES, ENUM_WANT_ONLINE_FLAG|ENUM_WANT_COMPATIBLE_FLAG)) {
        do {
            //
            // Enumerate all PNP devices of class Net
            // or Modem
            //

            if (e.Class) {
                if (StringIMatch (e.Class, TEXT("net")) ||
                    StringIMatch (e.Class, TEXT("modem"))
                    ) {
                    //
                    // Determine if this is not a RAS adapter
                    //

                    if (e.CompatibleIDs && !_tcsistr (e.CompatibleIDs, TEXT("*PNP8387"))) {
                        possiblyOnline = TRUE;
                    }

                    if (e.HardwareID && !_tcsistr (e.HardwareID, TEXT("*PNP8387"))) {
                        possiblyOnline = TRUE;
                    }

                    //
                    // If this is not a RAS adapter, we assume it may be a LAN
                    // adapter.  If the LAN adapter is present, then we assume
                    // that it might be online.
                    //

                    if (possiblyOnline) {
                        possiblyOnline = e.Online;
                    }
                }
            }

            //
            // Other tests for online go here
            //

            if (possiblyOnline) {
                AbortHardwareEnum (&e);
                return FALSE;
            }

        } while (EnumNextHardware (&e));
    }

    //
    // We have one of the following cases:
    //
    //  - No device with the class of "Net"
    //  - Only the RAS adapter is installed
    //  - All "Net" class devices are not present
    //
    // That makes us say "this computer is offline"
    //

    return TRUE;
}


BOOL
HwComp_AnyNeededDrivers (
    VOID
    )
{
    return !HtIsEmpty (g_NeededHardwareIds);
}


BOOL
AppendDynamicSuppliedDrivers (
    IN      PCTSTR DriversPath
    )

/*++

Routine Description:

  AppendDynamicSuppliedDrivers scans a path and its subdirs for new drivers and places
  all hardware device IDs in the global PNP string tables.

Arguments:

  DriversPath - The root path to new drivers

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails for at least one driver.

--*/

{
    TREE_ENUM te;
    DWORD HwCompDatId;
    BOOL b = TRUE;

    if (EnumFirstFileInTree (&te, DriversPath, TEXT("hwcomp.dat"), TRUE)) {
        do {
            if (te.Directory) {
                continue;
            }
            //
            // Open the hardware compatibility database
            //

            HwCompDatId = OpenAndLoadHwCompDatEx (
                                te.FullPath,
                                (PVOID)g_PnpIdTable,
                                (PVOID)g_UnsupPnpIdTable,
                                (PVOID)g_InfFileTable
                                );
            if (HwCompDatId) {
                SetWorkingTables (HwCompDatId, NULL, NULL, NULL);
                CloseHwCompDat (HwCompDatId);
            } else {
                LOG ((
                    LOG_WARNING,
                    "AppendDynamicSuppliedDrivers: OpenAndLoadHwCompDat failed for %s (rc=0x%x)",
                    te.FullPath,
                    GetLastError ()
                    ));
                //
                // report failure, but keep going
                //
                b = FALSE;
            }
        } while (EnumNextFileInTree (&te));
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\hwcomp\hwdisk.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hwdisk.c

Abstract:

    Implements detection of a third-party NT driver supplied before the
    installation of NT and copies all files for the specified devices
    to a temporary directory.

Author:

    Jim Schmidt (jimschm) 06-Nov-1997

Revision History:

    jimschm     15-Jun-1998     Added support for catalog files

--*/

#include "pch.h"
#include "hwcompp.h"
#include "memdb.h"

#define DBG_HWDISK  "HwDisk"


//
// VWIN32 interface
//

#define VWIN32_DIOC_DOS_IOCTL 1

typedef struct _DIOC_REGISTERS {
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DIOC_REGISTERS, *PDIOC_REGISTERS;


//
// Private types and local functions
//

typedef struct {
    HINF Inf;
    HINF LayoutInf;
    PCTSTR BaseDir;
    PCTSTR DestDir;
    DWORD ResultCode;
    HWND WorkingDlg;                OPTIONAL
    HANDLE CancelEvent;             OPTIONAL
} COPYPARAMS, *PCOPYPARAMS;

BOOL
pAddHashTable (
    IN      HASHTABLE Table,
    IN      HASHITEM StringId,
    IN      PCTSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    );

BOOL
pInstallSectionCallback (
    IN      HASHTABLE Table,
    IN      HASHITEM StringId,
    IN      PCTSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    );

PCTSTR g_EjectMedia = NULL;
TCHAR g_EjectMediaFileSpec[MAX_TCHAR_PATH];

//
// Implementation
//

BOOL
CopyDriverFilesToTempDir (
    IN      HWND WorkingDlg,                OPTIONAL
    IN      HANDLE CancelEvent,             OPTIONAL
    IN      PCTSTR SourceInfDir,
    IN      PCTSTR SourceInfSpec,
    IN      HASHTABLE PnpIdTable,
    IN      PCTSTR TempDir,
    IN      HASHTABLE PrevSuppliedIdTable,
    IN OUT  HASHTABLE SuppliedIdTable,
    OUT     PTSTR DestDirCreated,
    IN      PCTSTR OriginalInstallPath
    )

/*++

Routine Description:

  CopyDriverFilesToTempDir copies all files required by the driver to
  the specified temporary directory.  This routine scans the indicated
  INF file for one or more PNP IDs, and if at least one is found, the
  installer sections are traversed to locate files that need to be
  copied.

  This routine is divided into the following operations:

  (1) Detect the support of one or more PNP IDs in the source INF

  (2) For each supported PNP ID:

        (A) Scan the installer sections for include lines

        (B) Copy all necessary files to a unique subdirectory.
            Maintain a mapping of PNP IDs to installer INF
            locations using memdb.

Arguments:

  WorkingDlg - Specifies the window handle of the parent for the
               file copy dialog.

  CancelEvent - Specifies the event that when signaled causes the copy
                to be canceled

  SourceInfDir - Specifies directory of SourceInfSpec

  SourceInfSpec - Specifies full path to INF file to process

  PnpIdTable - Specifies a hash table of PNP IDs that are installed
               on the Win9x computer.  If one or more IDs in this list
               are found in SourceInfSpec, driver files are copied.

  TempDir - Specifies root path for device driver files.  Subdirs
            will be created under TempDir for each device driver.

  PrevSuppliedIdTable - Specifies string table holding a list of PNP IDs
                        considered to be compatible with NT 5.  This routine
                        filters out all drivers that have previously been
                        supplied.

  SuppliedIdTable - Specifies string table receiving a list of PNP IDs
                    found in SourceInfSpec.

  DestDirCreated - Receives the destination directory upon successful copy
                   of driver files, or is returned empty.

Return Value:

  TRUE if one or more PNP IDs in PnpIdTable (and not in PrevSuppliedIdTable
  or SuppliedIdTable) were found in SourceInfSpec, or FALSE if either
  (A) no IDs were found or (B) an error occurred.  Call GetLastError() for
  error details.

--*/

{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    INFSTRUCT isFile = INITINFSTRUCT_GROWBUFFER;
    INFSTRUCT isMfg = INITINFSTRUCT_GROWBUFFER;
    COPYPARAMS CopyParams;
    GROWLIST MatchingPnpIds = GROWLIST_INIT;
    HINF Inf;
    HASHTABLE InstallSectionsTable;
    PCTSTR Manufacturer;
    PCTSTR PnpId;
    PCTSTR MatchingPnpId;
    PCTSTR Section;
    PCTSTR DestDir = NULL;
    PCTSTR DestInfSpec = NULL;
    TCHAR TmpFileName[32];
    BOOL HaveOneId = FALSE;
    UINT u;
    UINT Count;
    static UINT DirCount = 0;
    BOOL NeedThisDriver;
    PTSTR ListPnpId;
    PCTSTR FileName;
    PCTSTR SourcePath;
    PCTSTR DestPath;
    PCTSTR LayoutFiles;
    BOOL Result = FALSE;
    BOOL SubResult;
    DWORD InfLine;
    HINF LayoutInf;

#if 0
    PCTSTR Signature;
#endif


    *DestDirCreated = 0;

    Inf = InfOpenInfFile (SourceInfSpec);
    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InstallSectionsTable = HtAlloc();

    __try {

        //
        // We do not check version... because Signature is meaningless.
        //

#if 0
        //
        // Verify INF is a $WINDOWS NT$ version
        //

        if (InfFindFirstLine (Inf, S_VERSION, S_SIGNATURE, &is)) {
            Signature = InfGetStringField (&is, 1);
            if (!StringIMatch (Signature, S_DOLLAR_WINDOWS_NT_DOLLAR)) {
                SetLastError (ERROR_WRONG_INF_STYLE);
                __leave;
            }
        } else {
            SetLastError (ERROR_WRONG_INF_STYLE);
            __leave;
        }
#endif

        //
        // Check if this INF has a layout line.
        //

        LayoutInf = NULL;

        if (InfFindFirstLine (Inf, S_VERSION, S_LAYOUTFILES, &is)) {

            LayoutFiles = InfGetMultiSzField (&is, 1);

            if (LayoutFiles) {
                while (*LayoutFiles) {
                    if (StringIMatch (LayoutFiles, S_LAYOUT_INF)) {

                        LayoutInf = InfOpenInfInAllSources (S_LAYOUT_INF);

                        if (LayoutInf == INVALID_HANDLE_VALUE) {
                            DEBUGMSG ((DBG_ERROR, "Can't open %s", S_LAYOUT_INF));
                            LayoutInf = NULL;
                        }

                        break;
                    }

                    LayoutFiles = GetEndOfString (LayoutFiles) + 1;
                }
            }
        }

        //
        // Create DestDir path
        //

        do {
            FreePathString (DestDir);

            DirCount++;
            wsprintf (TmpFileName, TEXT("driver.%03u"), DirCount);
            DestDir = JoinPaths (TempDir, TmpFileName);

        } while (DoesFileExist (DestDir));

        //
        // Scan [Manufacturer] section, then for each manufacturer, scan the
        // device list looking for PNP IDs that are in PnpIdTable.
        //

        if (InfFindFirstLine (Inf, S_MANUFACTURER, NULL, &is)) {
            do {
                //
                // Get manufacturer section name
                //

                Manufacturer = InfGetStringField (&is, 1);
                if (!Manufacturer) {
                    DEBUGMSG ((DBG_HWDISK, "Can't get manufacturer string in %s", SourceInfSpec));
                    __leave;
                }

                //
                // Enumerate all devices supported by the manufacturer
                //

                if (InfFindFirstLine (Inf, Manufacturer, NULL, &isMfg)) {
                    do {
                        //
                        // Extract PNP ID
                        //

                        PnpId = InfGetMultiSzField (&isMfg, 2);
                        MatchingPnpId = PnpId;

                        if (PnpId) {
                            while (*PnpId) {
                                //
                                // Check string table for ID
                                //

                                if (HtFindString (PnpIdTable, PnpId)) {
                                    //
                                    // ID was found!  Add all PNP IDs to our list of
                                    // matching IDs, and add install section to
                                    // string table.
                                    //

                                    HaveOneId = TRUE;

                                    while (*MatchingPnpId) {
                                        if (!AddPnpIdsToGrowList (
                                                &MatchingPnpIds,
                                                MatchingPnpId
                                                )) {

                                            LOG ((
                                                LOG_ERROR,
                                                "Error adding %s to grow list",
                                                PnpId
                                                ));

                                            __leave;
                                        }

                                        MatchingPnpId = GetEndOfString (MatchingPnpId) + 1;
                                    }

                                    Section = InfGetStringField (&isMfg, 1);
                                    if (!Section) {

                                        LOG ((
                                            LOG_ERROR,
                                            "Can't get install section for line in [%s] of %s",
                                            Manufacturer,
                                            SourceInfSpec
                                            ));

                                        __leave;
                                    }

                                    if (!HtAddString (InstallSectionsTable, Section)) {

                                        LOG ((
                                            LOG_ERROR,
                                            "Error adding %s to string table",
                                            Section
                                            ));

                                        __leave;

                                    }

                                    break;
                                }

                                PnpId = GetEndOfString (PnpId) + 1;
                            }
                        } else {
                            DEBUGMSG ((
                                DBG_HWDISK,
                                "Can't get PNP ID for line in [%s] of %s",
                                Manufacturer,
                                SourceInfSpec
                                ));
                        }

                    } while (InfFindNextLine (&isMfg));
                } else {
                    DEBUGMSG ((DBG_HWDISK, "INF %s does not have [%s]", Manufacturer));
                }

            } while (InfFindNextLine (&is));
        } else {
            DEBUGMSG ((DBG_HWDISK, "INF %s does not have [%s]", SourceInfSpec, S_MANUFACTURER));
            __leave;
        }

        //
        // If we have at least one PNP ID, process the install section
        //

        if (HaveOneId) {

            //
            // Create the working directory
            //

            CreateDirectory (DestDir, NULL);
            _tcssafecpy (DestDirCreated, DestDir, MAX_TCHAR_PATH);

            DestInfSpec = JoinPaths (DestDir, GetFileNameFromPath (SourceInfSpec));

            if (!CopyFile (SourceInfSpec, DestInfSpec, TRUE)) {

                LOG ((LOG_ERROR, "Could not copy %s to %s", SourceInfSpec, DestInfSpec));

                __leave;
            }

            //
            // Ignore the driver if all matching IDs are in either PrevSuppliedIdTable
            // or SuppliedIdTable.  This causes only the first instance of the driver
            // to be used.
            //

            Count = GrowListGetSize (&MatchingPnpIds);
            NeedThisDriver = FALSE;

            for (u = 0 ; u < Count ; u++) {

                ListPnpId = (PTSTR) GrowListGetString (&MatchingPnpIds, u);

                if (!HtFindString (PrevSuppliedIdTable, ListPnpId)) {

                    //
                    // Not in PrevSuppliedIdTable; check SuppliedIdTable
                    //

                    if (!HtFindString (SuppliedIdTable, ListPnpId)) {

                        //
                        // Not in either table, so we need this driver.  Add PNP ID to
                        // answer file and set flag to copy driver files.
                        //

                        NeedThisDriver = TRUE;
                    }
                }
            }

            if (!NeedThisDriver) {
                DEBUGMSG ((
                    DBG_HWDISK,
                    "Driver skipped (%s) because all devices are compatible already",
                    SourceInfSpec
                    ));
                __leave;
            }

            //
            // Enumerate the string table of installed sections,
            // copying all the files they reference.
            //

            CopyParams.Inf          = Inf;
            CopyParams.LayoutInf    = LayoutInf;
            CopyParams.WorkingDlg   = WorkingDlg;
            CopyParams.CancelEvent  = CancelEvent;
            CopyParams.BaseDir      = SourceInfDir;
            CopyParams.DestDir      = DestDir;
            CopyParams.ResultCode   = ERROR_SUCCESS;

            EnumHashTableWithCallback (
                InstallSectionsTable,
                pInstallSectionCallback,
                (LPARAM) &CopyParams
                );

            //
            // If enumeration fails, we return the error code to the
            // caller.
            //

            if (CopyParams.ResultCode != ERROR_SUCCESS) {

                SetLastError (CopyParams.ResultCode);
                DEBUGMSG ((DBG_HWDISK, "Error processing an install section"));
                __leave;
            }

            //
            // Copy CatalogFile setting, if it exists
            //

            if (InfFindFirstLine (Inf, S_VERSION, S_CATALOGFILE, &isFile)) {
                do {
                    FileName = InfGetStringField (&isFile, 1);
                    if (FileName) {
                        SourcePath = JoinPaths (SourceInfDir, FileName);
                        DestPath = JoinPaths (DestDir, FileName);

                        SubResult = FALSE;

                        if (SourcePath && DestPath) {
                            SubResult = CopyFile (SourcePath, DestPath, TRUE);
                        }

                        PushError();
                        FreePathString (SourcePath);
                        FreePathString (DestPath);
                        PopError();

                        if (!SubResult) {
                            LOG ((
                                LOG_ERROR,
                                "Could not copy %s to %s (catalog file)",
                                SourcePath,
                                DestPath
                                ));

                            __leave;
                        }
                    }

                } while (InfFindNextLine (&isFile));
            }

            //
            // Everything was copied fine; stick all matching IDs in
            // SuppliedIdTable
            //

            for (u = 0 ; u < Count ; u++) {

                ListPnpId = (PTSTR) GrowListGetString (&MatchingPnpIds, u);

                if (!HtAddString (SuppliedIdTable, ListPnpId)) {

                    DEBUGMSG ((
                        DBG_WARNING,
                        "CopyDriverFilesToTempDir: Error adding %s to "
                            "supported ID string table",
                        ListPnpId
                        ));
                }

                InfLine = WriteInfKeyEx (
                                S_DEVICE_DRIVERS,
                                ListPnpId,
                                DestInfSpec,
                                0,
                                FALSE
                                );

                if (InfLine) {

                    InfLine = WriteInfKeyEx (
                                    S_DEVICE_DRIVERS,
                                    ListPnpId,
                                    OriginalInstallPath,
                                    InfLine,
                                    FALSE
                                    );

                }

                if (!InfLine) {
                    LOG ((LOG_ERROR, "Can't write answer file key"));
                    __leave;
                }
            }
        }

        Result = TRUE;
    }
    __finally {
        PushError();

        InfCloseInfFile (Inf);
        InfCleanUpInfStruct (&is);
        InfCleanUpInfStruct (&isMfg);
        InfCleanUpInfStruct (&isFile);

        if (LayoutInf) {
            InfCloseInfFile (LayoutInf);
            LayoutInf = NULL;
        }

        if (InstallSectionsTable) {
            HtFree (InstallSectionsTable);
        }

        FreePathString (DestDir);
        FreePathString (DestInfSpec);

        PopError();
    }

    return Result && HaveOneId;
}


BOOL
pCopyDriverFileWorker (
    IN      HINF LayoutInf,         OPTIONAL
    IN      PCTSTR BaseDir,
    IN      PCTSTR DestDir,
    IN      PCTSTR FileName,
    IN      HANDLE CancelEvent      OPTIONAL
    )

/*++

Routine Description:

  pCopyDriverFileWorker copies driver files to a temporary directory.  It
  copies a single file, and copies the compressed version if it exists.

Arguments:

  LayoutInf   - Specifies the handle to NT's layout.inf, used to tell if
                the source file comes from NT or not
  BaseDir     - Specifies the base directory of the driver media (i.e.,
                a:\i386)
  DestDir     - Specifies the destination directory (i.e.,
                c:\windows\setup\driver.001)
  FileName    - Specifies the file to copy.
  CancelEvent - Specifies the handle to the UI cancel event (set when the
                user clicks cancel)

Return Value:

  TRUE if the copy was successful, FALSE if not.

--*/

{
    PCTSTR SourceName = NULL;
    PCTSTR DestName = NULL;
    PTSTR p;
    BOOL b = FALSE;
    TCHAR FileNameCopy[MAX_TCHAR_PATH];
    LONG rc;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;

    StringCopy (FileNameCopy, FileName);

    if (CancelEvent &&
        WAIT_OBJECT_0 == WaitForSingleObject (CancelEvent, 0)
        ) {
        SetLastError (ERROR_CANCELLED);
        return FALSE;
    }

    __try {
        SourceName = JoinPaths (BaseDir, FileNameCopy);

        //
        // If file does not exist, then try with trailing underscore
        //

        if (!DoesFileExist (SourceName)) {
            p = GetEndOfString (SourceName);
            p = _tcsdec2 (SourceName, p);
            if (p) {
                *p = TEXT('_');
                p = _tcsinc (p);
                *p = 0;
            }

#ifdef PRESERVE_COMPRESSED_FILES
            p = GetEndOfString (FileNameCopy);
            p = _tcsdec2 (FileNameCopy, p);
            if (p) {
                *p = TEXT('_');
                p = _tcsinc (p);
                *p = 0;
            }
#endif


        }

        DestName = JoinPaths (DestDir, FileNameCopy);

#ifdef PRESERVE_COMPRESSED_FILES
        b = CopyFile (SourceName, DestName, TRUE);
#else
        rc = SetupDecompressOrCopyFile (SourceName, DestName, 0);
        b = (rc == ERROR_SUCCESS);
        if (!b) {
            SetLastError (rc);
        }
#endif

        if (!b) {
            //
            // Check layout.inf for this file
            //

            if (LayoutInf) {
                if (InfFindFirstLine (
                        LayoutInf,
                        S_SOURCEDISKSFILES,
                        FileName,
                        &is
                        )) {

                    b = TRUE;
                    DEBUGMSG ((DBG_VERBOSE, "File %s is expected to be supplied by NT 5"));

                } else {
                    LOG ((LOG_ERROR, "%s is not supplied by Windows XP", FileName));
                }

                InfCleanUpInfStruct (&is);

            } else {
                LOG ((LOG_ERROR, "Could not copy %s to %s", SourceName, DestName));
            }
        }
    }
    __finally {
        PushError();

        FreePathString (SourceName);
        FreePathString (DestName);

        PopError();
    }

    return b;
}


BOOL
pCopyDriverFilesToTempDir (
    IN      HINF Inf,
    IN      HINF LayoutInf,             OPTIONAL
    IN      PCTSTR FileOrSection,
    IN      PCTSTR BaseDir,
    IN      PCTSTR DestDir,
    IN      HANDLE CancelEvent          OPTIONAL
    )

/*++

Routine Description:

  pCopyDriverFilesToTempDir parses the specified driver INF and copies all
  needed files to the specified destination.  The cancel event allows UI to
  cancel the copy.

Arguments:

  Inf           - Specifies the handle to the driver INF
  LayoutInf     - Specifies the handle to the NT layout INF, used to ignore copy
                  errors for files that ship with the product
  FileOrSection - Specifies the file name or section name.  File names begin
                  with an @ symbol.  This is the same way setupapi handles a
                  FileCopy section.
  BaseDir       - Specifies the media directory (i.e., a:\i386)
  DestDir       - Specifies the setup temporary directory (i.e.,
                  c:\windows\setup\driver.001)
  CancelEvent   - Specifies the handle the an event that is set when the user
                  cancels via UI.

Return Value:

  TRUE if the copy was successful, or FALSE if a file could not be copied.

--*/

{
    PCTSTR FileName;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    BOOL b = FALSE;

    if (_tcsnextc (FileOrSection) == TEXT('@')) {

        //
        // FileOrSection is a file
        //

        b = pCopyDriverFileWorker (
                LayoutInf,
                BaseDir,
                DestDir,
                _tcsinc (FileOrSection),
                CancelEvent
                );
    } else {

        //
        // FileOrSection is a section
        //

        if (InfFindFirstLine (Inf, FileOrSection, NULL, &is)) {
            do {
                //
                // Each line in the section represents a file to be copied
                // to the DestDir
                //

                FileName = InfGetStringField (&is, 1);
                if (!FileName) {
                    DEBUGMSG ((
                        DBG_WARNING,
                        "pCopyDriverFilesToTempDir: Error accessing %s",
                        FileOrSection
                        ));
                    b = FALSE;
                } else {
                    b = pCopyDriverFileWorker (
                            LayoutInf,
                            BaseDir,
                            DestDir,
                            FileName,
                            CancelEvent
                            );
                }

            } while (b && InfFindNextLine (&is));

        } else {
            DEBUGMSG ((
                DBG_WARNING,
                "pCopyDriverFilesToTempDir: %s is empty or does not exist",
                FileOrSection
                ));

            b = TRUE;
        }
    }

    InfCleanUpInfStruct (&is);

    return b;
}


BOOL
pInstallSectionCallback (
    IN      HASHTABLE Table,
    IN      HASHITEM StringId,
    IN      PCTSTR InstallSection,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  pInstallSectionCallback is called for each installation section specified
  in a driver INF.  It does the same processing as the device installer
  routines in Setup API.  It supports include= and needs= lines, and then
  enumerates the install section for ClassInstall and CopyFiles.  When the
  routine completes, the entire install section, and an optional class
  installer, will be present in a temp dir on the system drive.

  Special attention is paid to the extensions on the section names.  One
  section is processed, using the following precedence table:

        <section>.NTx86
        <section>.NT
        <section>

Arguments:

  Table          - Specifies the string table (unused)
  StringId       - Specifies the ID of the string being enumerated (unused)
  InstallSection - Specifies the text of the install section as maintained by
                   the string table
  ExtraData      - Specifies extra data (unused)
  ExtraDataSize  - Specifies the size of ExtraData (unused)
  lParam         - Specifies copy parameters, receives

Return Value:

  TRUE if the install section was processed properly, or FALSE if an error
  occurred.

--*/

{
    PCOPYPARAMS Params;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    GROWLIST SectionList = GROWLIST_INIT;
    PCTSTR Key;
    PCTSTR IncludedFile;
    PCTSTR NeededSection;
    PCTSTR CopyFiles;
    PCTSTR p;
    PCTSTR RealSection;
    PCTSTR Section;
    PCTSTR ClassInstall32;
    UINT Count;
    UINT u;
    BOOL b = FALSE;

    Params = (PCOPYPARAMS) lParam;

    //
    // Look for InstallSection.NTx86
    //

    RealSection = JoinText (InstallSection, TEXT(".NTx86"));
    if (!RealSection) {
        return FALSE;
    }

    if (!InfFindFirstLine (Params->Inf, RealSection, NULL, &is)) {
        FreeText (RealSection);
        RealSection = JoinText (InstallSection, TEXT(".NT"));
        if (!RealSection) {
            return FALSE;
        }

        if (!InfFindFirstLine (Params->Inf, RealSection, NULL, &is)) {
            RealSection = DuplicateText (InstallSection);
            if (!RealSection) {
                return FALSE;
            }
        }
    }

    __try {
        //
        // Put RealSection in grow list
        //

        if (!GrowListAppendString (&SectionList, RealSection)) {
            __leave;
        }

        //
        // Append-load layout.inf if necessary
        //

        InfOpenAppendInfFile (NULL, Params->Inf, NULL);

        //
        // Scan RealSection for include
        //

        if (InfFindFirstLine (Params->Inf, RealSection, TEXT("include"), &is)) {
            do {
                //
                // Verify key is "include"
                //
                MYASSERT (StringIMatch (InfGetStringField (&is, 0), TEXT("include")));

                //
                // Get include file name(s)
                //

                IncludedFile = InfGetMultiSzField (&is, 1);
                if (!IncludedFile) {

                    LOG ((
                        LOG_ERROR,
                        "Include= syntax error in %s",
                        RealSection
                        ));

                    __leave;
                }

                p = IncludedFile;

                while (*p) {
                    //
                    // Append-load the INF
                    //

                    if (!InfOpenAppendInfFile (IncludedFile, Params->Inf, NULL)) {

                        LOG ((
                            LOG_ERROR,
                            "Cannot append-load %s",
                            IncludedFile
                            ));

                        __leave;
                    }

                    p = GetEndOfString  (p) + 1;
                }

                InfResetInfStruct (&is);

            } while (InfFindNextLine (&is));
        }

        //
        // Scan RealSection for needs=
        //

        if (InfFindFirstLine (Params->Inf, RealSection, TEXT("needs"), &is)) {
            do {
                //
                // Verify key is "needs"
                //

                MYASSERT (StringIMatch (InfGetStringField (&is, 0), TEXT("needs")));

                //
                // Get needed section name(s)
                //

                NeededSection = InfGetMultiSzField (&is, 1);
                if (!NeededSection) {

                    LOG ((
                        LOG_ERROR,
                        "Needs= syntax error in %s",
                        RealSection
                        ));

                    __leave;
                }

                p = NeededSection;

                while (*p) {
                    //
                    // Add sections to grow list
                    //

                    if (!GrowListAppendString (&SectionList, p)) {
                        __leave;
                    }

                    p = GetEndOfString (p) + 1;
                }
            } while (InfFindNextLine (&is));
        }

        //
        // Scan for ClassInstall32.NTx86, ClassInstall32.NT or ClassInstall32,
        // and if found, add to section list.
        //

        ClassInstall32 = TEXT("ClassInstall32.NTx86");
        if (!InfFindFirstLine (Params->Inf, ClassInstall32, NULL, &is)) {

            ClassInstall32 = TEXT("ClassInstall32.NT");
            if (!InfFindFirstLine (Params->Inf, ClassInstall32, NULL, &is)) {

                ClassInstall32 = TEXT("ClassInstall32");
                if (!InfFindFirstLine (Params->Inf, ClassInstall32, NULL, &is)) {
                    ClassInstall32 = NULL;
                }
            }
        }

        if (ClassInstall32) {
            GrowListAppendString (&SectionList, ClassInstall32);
        }

        //
        // Scan all sections in SectionList for CopyFiles
        //

        Count = GrowListGetSize (&SectionList);

        for (u = 0; u < Count ; u++) {

            Section = GrowListGetString (&SectionList, u);

            if (InfFindFirstLine (Params->Inf, Section, S_COPYFILES, &is)) {
                do {
                    //
                    // Verify key is "CopyFiles"
                    //

                    MYASSERT (StringIMatch (InfGetStringField (&is, 0), S_COPYFILES));

                    //
                    // Obtain list of copy files
                    //

                    CopyFiles = InfGetMultiSzField (&is, 1);
                    if (!CopyFiles) {

                        LOG ((
                            LOG_ERROR,
                            "CopyFile syntax error in %s",
                            Section
                            ));

                        __leave;
                    }

                    p = CopyFiles;

                    while (*p) {
                        //
                        // Copy these files to temporary dir
                        //

                        if (!pCopyDriverFilesToTempDir (
                                Params->Inf,
                                Params->LayoutInf,
                                p,
                                Params->BaseDir,
                                Params->DestDir,
                                Params->CancelEvent
                                )) {
                            Params->ResultCode = GetLastError();
                            __leave;
                        }

                        p = GetEndOfString (p) + 1;
                    }

                } while (InfFindNextLine (&is));
            }
        }

        b = TRUE;
    }
    __finally {
        PushError();
        FreeText (RealSection);
        InfCleanUpInfStruct (&is);
        FreeGrowList (&SectionList);
        PopError();
    }

    return b;
}


BOOL
ScanPathForDrivers (
    IN      HWND WorkingDlg,            OPTIONAL
    IN      PCTSTR SourceInfDir,
    IN      PCTSTR TempDir,
    IN      HANDLE CancelEvent          OPTIONAL
    )

/*++

Routine Description:

  ScanPathForDrivers searches SourceInfDir for any file that ends in
  INF, and then examines the file to see if it supports any of the
  devices in g_NeededHardwareIds.  If a driver is found for a device not
  already in g_UiSuppliedIds, the driver is copied to the local
  drive for setup in GUI mode.

Arguments:

  WorkingDlg -  Specifies the parent window for the driver copy
                animation dialog.  If not specified, no copy
                dialog is displayed.

  SourceInfDir - Specifies full path to dir to scan

  TempDir - Specifies root path for device driver files.  Subdirs
            will be created under TempDir for each device driver.

  CancelEvent - Specifies the event set by the UI when the user clicks
                Cancel

Return Value:

  TRUE if one or more drivers were found and were copied to the local
  disk, or FALSE if either (A) no IDs were found or (B) an error occurred.
  Call GetLastError() for error details.

--*/

{
    GROWLIST DriverDirList = GROWLIST_INIT;
    GROWLIST InfFileList = GROWLIST_INIT;
    TREE_ENUM Tree;
    BOOL ContinueEnum = FALSE;
    HASHTABLE SuppliedIdTable = NULL;
    PCTSTR TempFile = NULL;
    PCTSTR FullInfPath;
    PCTSTR ActualInfDir;
    PCTSTR DriverDir;
    PTSTR p;
    TCHAR TmpFileName[32];
    TCHAR DestDir[MAX_TCHAR_PATH];
    DWORD rc;
    UINT Count;
    UINT u;
    BOOL b;
    BOOL OneFound = FALSE;
    PCTSTR FileName;
    BOOL Result = FALSE;

    __try {
        //
        // Create string table to hold PNP IDs until all drivers have been
        // copied correctly.  Once everything is OK, we merge SuppliedIdTable
        // into g_UiSuppliedIds.
        //

        SuppliedIdTable = HtAlloc();
        if (!SuppliedIdTable) {
            __leave;
        }

        ContinueEnum = EnumFirstFileInTree (&Tree, SourceInfDir, TEXT("*.in?"), FALSE);

        while (ContinueEnum) {
            if (!Tree.Directory) {

                FullInfPath = Tree.FullPath;

                p = GetEndOfString (Tree.Name);
                MYASSERT(p);
                p = _tcsdec2 (Tree.Name, p);
                MYASSERT(p);

                ActualInfDir = SourceInfDir;

                if (_tcsnextc (p) == TEXT('_')) {
                    Count = 0;
                    b = TRUE;

                    //
                    // Prepare a temporary file name
                    //

                    do {
                        Count++;

                        if (Count > 1) {
                            wsprintf (TmpFileName, TEXT("oem%05u.inf"), Count);
                        } else {
                            StringCopy (TmpFileName, TEXT("oemsetup.inf"));
                        }

                        TempFile = JoinPaths (g_TempDir, TmpFileName);

                        if (DoesFileExist (TempFile)) {
                            FreePathString (TempFile);
                            TempFile = NULL;
                        }
                    } while (!TempFile);

                    //
                    // Abort on memory allocation error
                    //

                    if (!b) {
                        OneFound = FALSE;
                        break;
                    }

                    //
                    // Decompress the file to temporary location
                    //

                    rc = SetupDecompressOrCopyFile (FullInfPath, TempFile, 0);

                    //
                    // Handle errors
                    //

                    if (rc != ERROR_SUCCESS) {
                        LOG ((LOG_ERROR, "Could not decompress %s", FullInfPath));
                        FreePathString (TempFile);
                        TempFile = NULL;

                        SetLastError(rc);
                        OneFound = FALSE;
                        break;
                    }

                    //
                    // Now use TempFile instead of FullInfPath
                    //

                    FullInfPath = TempFile;
                }

                //
                // Now that we have the uncompressed INF, let's check to see if it
                // has needed driver files, and if the files can be copied to the
                // local disk.
                //

                b = CopyDriverFilesToTempDir (
                        WorkingDlg,
                        CancelEvent,
                        ActualInfDir,
                        FullInfPath,
                        g_NeededHardwareIds,
                        TempDir,
                        g_UiSuppliedIds,
                        SuppliedIdTable,
                        DestDir,
                        ActualInfDir
                        );

                OneFound |= b;

                //
                // Clean up temporary INF file and add DestDir to grow list
                //

                PushError();

                if (TempFile == FullInfPath) {
                    DeleteFile (FullInfPath);
                    FreePathString (TempFile);
                    TempFile = NULL;
                }

                if (*DestDir) {
                    GrowListAppendString (&DriverDirList, DestDir);
                    FileName = GetFileNameFromPath (FullInfPath);
                    GrowListAppendString (&InfFileList, FileName);
                }

                PopError();

                //
                // Check for failure (such as disk full)
                //

                if (!b) {
                    rc = GetLastError();

                    if (rc != ERROR_SUCCESS &&
                        (rc & 0xe0000000) != 0xe0000000
                        ) {
                        OneFound = FALSE;
                        break;
                    }
                }

                if (CancelEvent &&
                    WAIT_OBJECT_0 == WaitForSingleObject (CancelEvent, 0)
                    ) {
                    SetLastError (ERROR_CANCELLED);
                    OneFound = FALSE;
                    break;
                }

            } else {

                //
                // Check for scary directories such as windir and get out!
                //

                if (StringIMatchCharCount (Tree.FullPath, g_WinDirWack, g_WinDirWackChars)) {
                    AbortEnumCurrentDir(&Tree);
                }
            }

            ContinueEnum = EnumNextFileInTree (&Tree);
        }

        if (OneFound) {
            //
            // Copy SuppliedIdTable to g_UiSuppliedIds
            //

            if (!EnumHashTableWithCallback (
                    SuppliedIdTable,
                    pAddHashTable,
                    (LPARAM) g_UiSuppliedIds
                    )) {

                DEBUGMSG ((DBG_HWDISK, "Error copying SuppliedIdTable to g_UiSuppliedIds"));
            }

            if (GetDriveType (SourceInfDir) == DRIVE_REMOVABLE) {

                //
                // If there is already a different removable drive
                // used, eject the media.
                //

                EjectDriverMedia (FullInfPath);

                g_EjectMedia = g_EjectMediaFileSpec;
                StringCopy (g_EjectMediaFileSpec, FullInfPath);
            }

        } else {
            PushError();

            //
            // Delete all dirs in DeviceDirList
            //

            Count = GrowListGetSize (&DriverDirList);

            for (u = 0 ; u < Count ; u++) {
                //
                // Blow away the temporary driver dir
                //

                DriverDir = GrowListGetString (&DriverDirList, u);
                DeleteDirectoryContents (DriverDir);
                SetFileAttributes (DriverDir, FILE_ATTRIBUTE_NORMAL);
                b = RemoveDirectory (DriverDir);

                DEBUGMSG_IF ((
                    !b && DoesFileExist (DriverDir),
                    DBG_WARNING,
                    "Could not clean up %s",
                    DriverDir
                    ));
            }

            PopError();
        }

        Result = OneFound;
    }
    __finally {
        PushError();

        MYASSERT (!TempFile);

        if (SuppliedIdTable) {
            HtFree (SuppliedIdTable);
        }

        FreeGrowList (&DriverDirList);
        FreeGrowList (&InfFileList);

        if (ContinueEnum) {
            AbortEnumFileInTree (&Tree);
        }

        PopError();
    }

    return Result;
}


BOOL
pAddHashTable (
    IN      HASHTABLE Table,
    IN      HASHITEM StringId,
    IN      PCTSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  pAddHashTable adds one string table to another.  It is an enumeration
  callback.

Arguments:

  Table         - Specifies the table being enumerated (unused)
  StringId      - Specifies the ID of the current string (unused)
  String        - Specifies the current string to be copied to the table
                  indicated by lParam.
  ExtraData     - Specifies extra data for the item being enumerated (unused)
  ExtraDataSize - Specifies the size of ExtraData (unused)
  lParam        - Specifies the destination table

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    HASHTABLE DestTable;

    DestTable = (HASHTABLE) lParam;
    if (!HtAddString (DestTable, String)) {
        DEBUGMSG ((DBG_ERROR, "pAddHashTable: Can't add to table 0x%X", DestTable));
        return FALSE;
    }

    return TRUE;
}


BOOL
pEjectMedia (
    IN      UINT DriveNum           // A == 0, B == 1, etc...
    )
{
    HANDLE VWin32Handle;
    DIOC_REGISTERS reg;
    BOOL Result;
    DWORD DontCare;
    BOOL b;

    VWin32Handle = CreateFile(
                        TEXT("\\\\.\\vwin32"),
                        0,
                        0,
                        NULL,
                        0,
                        FILE_FLAG_DELETE_ON_CLOSE,
                        NULL
                        );

    if (VWin32Handle == INVALID_HANDLE_VALUE) {
        MYASSERT (VWin32Handle != INVALID_HANDLE_VALUE);
        return FALSE;
    }

    reg.reg_EAX   = 0x440D;       // IOCTL for block devices
    reg.reg_EBX   = DriveNum;     // zero-based drive identifier
    reg.reg_ECX   = 0x0849;       // Get Media ID command
    reg.reg_Flags = 0x0001;       // assume error (carry flag is set)

    Result = DeviceIoControl (
                VWin32Handle,
                VWIN32_DIOC_DOS_IOCTL,
                &reg,
                sizeof(reg),
                &reg,
                sizeof(reg),
                &DontCare,
                0
                );

    if (!Result || (reg.reg_Flags & 0x0001)) {
        DEBUGMSG ((DBG_WARNING, "Eject Media: error code is 0x%02X", reg.reg_EAX));
        b = FALSE;
    } else {
        b = TRUE;
    }

    CloseHandle (VWin32Handle);

    return b;
}


BOOL
EjectDriverMedia (
    IN      PCSTR IgnoreMediaOnDrive        OPTIONAL
    )
{
    PCTSTR ArgArray[1];
    TCHAR DriveLetter[2];

    if (g_EjectMedia) {

        //
        // If IgnoreMediaOnDrive is specified, then assume no media
        // exists when it is on the drive specified.
        //

        if (IgnoreMediaOnDrive) {
            if (IgnoreMediaOnDrive[0] == g_EjectMedia[0]) {
                return TRUE;
            }
        }

        //
        // Attempt to eject the media automatically
        //

        if (!pEjectMedia (g_EjectMedia[0])) {

            //
            // Force user to eject the media
            //

            DriveLetter[0] = g_EjectMedia[0];
            DriveLetter[1] = 0;
            ArgArray[0] = DriveLetter;

            while (DoesFileExist (g_EjectMedia)) {

                ResourceMessageBox (
                    g_ParentWndAlwaysValid,
                    MSG_REMOVE_DRIVER_DISK,
                    MB_OK|MB_ICONINFORMATION|MB_SETFOREGROUND,
                    ArgArray
                    );

            }

        }

        g_EjectMedia = NULL;

    }

    return g_EjectMedia != NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\hwcomp\hwdlg.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    hwdlg.c

Abstract:

    Details dialog for HWCOMP

Author:

    Jim Schmidt (jimschm) 26-Nov-1996

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

// column sort function
int
CALLBACK
HwComp_ListViewCompareFunc (
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\hwcomp\lib.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    lib.c

Abstract:

    Implements a lib interface for reading hwcomp.dat.

Author:

    Jim Schmidt (jimschm) 08-Feb-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "hwcompp.h"


typedef struct {
    HASHTABLE PnpIdTable;
    HASHTABLE UnSupPnpIdTable;
    HASHTABLE InfFileTable;
    DWORD Checksum;
    BOOL Loaded;
    HANDLE File;
    DWORD InfListOffset;
    CHAR HwCompDatPath[MAX_MBCHAR_PATH];
} HWCOMPSTRUCT, *PHWCOMPSTRUCT;


BOOL
pReadDword (
    IN      HANDLE File,
    OUT     PDWORD Data
    )

/*++

Routine Description:

  pReadDword reads the next DWORD at the current file position of File.

Arguments:

  File - Specifies file to read

  Data - Receives the DWORD

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD BytesRead;

    if (!ReadFile (File, Data, sizeof (DWORD), &BytesRead, NULL) ||
        BytesRead != sizeof (DWORD)
        ) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pReadWord (
    IN      HANDLE File,
    OUT     PWORD Data
    )

/*++

Routine Description:

  pReadWord reads the next WORD at the current file position of File.

Arguments:

  File - Specifies file to read

  Data - Receive s the WORD

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/
{
    DWORD BytesRead;

    if (!ReadFile (File, Data, sizeof (WORD), &BytesRead, NULL) ||
        BytesRead != sizeof (WORD)
        ) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pReadString (
    IN      HANDLE File,
    OUT     PTSTR Buf,
    IN      UINT BufSizeInBytes
    )

/*++

Routine Description:

  pReadString reads a WORD length from File, and then reads in the
  string from File.

Arguments:

  File - Specifies file to read

  Buf - Receives the zero-terminated string

  BufSizeInBytes - Specifies the size of Buf in bytes

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  This function will fail if the string is larger than Buf.
  Call GetLastError for additional failure information.

--*/
{
    DWORD BytesRead;
    WORD Length;

    if (!pReadWord (File, &Length)) {
        DEBUGMSG ((DBG_ERROR, "pReadString: Can't get string length"));
        return FALSE;
    }

    if (Length > BufSizeInBytes - 2) {
        DEBUGMSG ((DBG_ERROR, "pReadString: Can't read string of %u bytes", Length));
        return FALSE;
    }

    if (Length) {
        if (!ReadFile (File, Buf, Length, &BytesRead, NULL) ||
            Length != BytesRead
            ) {
            LOG ((LOG_ERROR, "Can't read string from file."));
            return FALSE;
        }
    }

    *((PBYTE) Buf + Length ) = 0;
    *((PBYTE) Buf + Length + 1) = 0;

    return TRUE;
}


DWORD
pOpenAndLoadHwCompDatA (
    IN      PCSTR HwCompDatPath,            // NULL if PrevStruct is not NULL
    IN      BOOL Load,
    IN      BOOL Dump,
    IN      BOOL DumpInf,
    IN      PHWCOMPSTRUCT PrevStruct,       OPTIONAL
    IN      HASHTABLE PnpIdTable,           OPTIONAL
    IN      HASHTABLE UnSupPnpIdTable,      OPTIONAL
    IN      HASHTABLE InfFileTable          OPTIONAL
    )
{
    PHWCOMPSTRUCT Struct;
    DWORD Result = 0;
    CHAR Buf[sizeof (HWCOMPDAT_SIGNATURE) + 2];
    CHAR PnpId[MAX_PNP_ID+2];
    BOOL AllocatedStruct = FALSE;
    DWORD BytesRead;
    CHAR InfFile[MAX_MBCHAR_PATH];
    HASHITEM InfOffset;
    HASHITEM hashResult;

    //
    // !!! IMPORTANT !!!
    //
    // hwcomp.dat is used by other parts of NT.  *DO NOT* change it without first e-mailing
    // the NT group.  Also, be sure to keep code in hwcomp.c in sync with changes.
    //

    __try {

        if (!PrevStruct) {
            Struct = (PHWCOMPSTRUCT) MemAlloc (g_hHeap, 0, sizeof (HWCOMPSTRUCT));
            if (!Struct) {
                __leave;
            }

            ZeroMemory (Struct, sizeof (HWCOMPSTRUCT));
            Struct->File = INVALID_HANDLE_VALUE;
            StringCopy (Struct->HwCompDatPath, HwCompDatPath);

            AllocatedStruct = TRUE;

        } else {
            Struct = PrevStruct;
            if (HwCompDatPath) {
                SetLastError (ERROR_INVALID_PARAMETER);
                __leave;
            }

            HwCompDatPath = Struct->HwCompDatPath;
        }

        if (Struct->File == INVALID_HANDLE_VALUE) {
            //
            // Try to open the file
            //

            Struct->File = CreateFile (
                                HwCompDatPath,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,                       // no security attribs
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL                        // no template
                                );
        }

        if (Struct->File == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (AllocatedStruct) {
            //
            // Create hash tables
            //

            Struct->PnpIdTable = PnpIdTable ? PnpIdTable : HtAllocWithData (sizeof (UINT));
            Struct->UnSupPnpIdTable = UnSupPnpIdTable ? UnSupPnpIdTable : HtAllocWithData (sizeof (UINT));
            Struct->InfFileTable = InfFileTable ? InfFileTable : HtAlloc();

            if (!Struct->PnpIdTable || !Struct->InfFileTable) {
                __leave;
            }

            //
            // Look at the signature
            //

            ZeroMemory (Buf, sizeof(Buf));

            SetFilePointer (Struct->File, 0, NULL, FILE_BEGIN);

            if (!ReadFile (Struct->File, Buf, ByteCount (HWCOMPDAT_SIGNATURE), &BytesRead, NULL) ||
                !StringMatch (HWCOMPDAT_SIGNATURE, Buf)
                ) {

                SetLastError (ERROR_BAD_FORMAT);
                __leave;
            }

            //
            // Get INF checksum
            //

            if (!pReadDword (Struct->File, &Struct->Checksum)) {
                SetLastError (ERROR_BAD_FORMAT);
                __leave;
            }

            Struct->InfListOffset = SetFilePointer (Struct->File, 0, NULL, FILE_CURRENT);
        }

        if (Load || Dump) {

            SetFilePointer (Struct->File, Struct->InfListOffset, NULL, FILE_BEGIN);

            //
            // Read in all INFs
            //

            for (;;) {

                //
                // Get INF file name.  If empty, we are done.
                //

                if (!pReadString (Struct->File, InfFile, sizeof (InfFile))) {
                    SetLastError (ERROR_BAD_FORMAT);
                    __leave;
                }

                if (*InfFile == 0) {
                    break;
                }

                if (Load) {
                    //
                    // Add to hash table
                    //

                    InfOffset = HtAddString (Struct->InfFileTable, InfFile);

                    if (!InfOffset) {
                        __leave;
                    }
                }

                //
                // Read in all PNP IDs for the INF
                //

                for (;;) {
                    //
                    // Get the PNP ID.  If empty, we are done.
                    //

                    if (!pReadString (Struct->File, PnpId, sizeof (PnpId))) {
                        __leave;
                    }

                    if (*PnpId == 0) {
                        break;
                    }

                    if (Load) {
                        //
                        // Add to hash table
                        //

                        if (*PnpId == '!') {
                            hashResult = HtAddStringAndData (
                                             Struct->UnSupPnpIdTable,
                                             PnpId + 1,
                                             &InfOffset
                                             );
                        } else {
                            hashResult = HtAddStringAndData (
                                             Struct->PnpIdTable,
                                             PnpId,
                                             &InfOffset
                                             );
                        }

                        if (!hashResult) {
                            __leave;
                        }
                    }

                    if (Dump) {
                        if (*PnpId == '!') {
                            if (DumpInf) {
                                printf ("%s\t%s (unsupported)\n", InfFile, PnpId + 1);
                            } else {
                                printf ("%s (unsupported)\n", PnpId + 1);
                            }
                        } else {
                            if (DumpInf) {
                                printf ("%s\t%s\n", InfFile, PnpId);
                            } else {
                                printf ("%s\n", PnpId);
                            }
                        }
                    }
                }

                if (Dump) {
                    printf ("\n");
                }
            }
        }

        Result = (DWORD) Struct;

        if (Load) {
            Struct->Loaded = TRUE;
            CloseHandle (Struct->File);
            Struct->File = INVALID_HANDLE_VALUE;
        }

    }
    __finally {
        if (!Result) {
            if (AllocatedStruct) {
                CloseHwCompDat ((DWORD) Struct);
            }

            if (Dump) {
                printf ("Can't open %s\n", HwCompDatPath);
            }
        }
    }

    return Result;

}


DWORD
OpenHwCompDatA (
    IN      PCSTR HwCompDatPath
    )
{
    return pOpenAndLoadHwCompDatA (HwCompDatPath, FALSE, FALSE, FALSE, NULL, NULL, NULL, NULL);
}


DWORD
LoadHwCompDat (
    IN      DWORD HwCompDatId
    )
{
    return pOpenAndLoadHwCompDatA (NULL, TRUE, FALSE, FALSE, (PHWCOMPSTRUCT) HwCompDatId, NULL, NULL, NULL);
}


DWORD
GetHwCompDatChecksum (
    IN      DWORD HwCompDatId
    )
{
    PHWCOMPSTRUCT Struct = (PHWCOMPSTRUCT) HwCompDatId;

    if (Struct) {
        return Struct->Checksum;
    }

    return 0;
}


VOID
DumpHwCompDatA (
    IN      PCSTR HwCompDatPath,
    IN      BOOL IncludeInf
    )
{
    CloseHwCompDat (pOpenAndLoadHwCompDatA (HwCompDatPath, FALSE, TRUE, IncludeInf, NULL, NULL, NULL, NULL));
}


DWORD
OpenAndLoadHwCompDatA (
    IN      PCSTR HwCompDatPath
    )
{
    return pOpenAndLoadHwCompDatA (HwCompDatPath, TRUE, FALSE, FALSE, NULL, NULL, NULL, NULL);
}

DWORD
OpenAndLoadHwCompDatExA (
    IN      PCSTR HwCompDatPath,
    IN      HASHTABLE PnpIdTable,           OPTIONAL
    IN      HASHTABLE UnSupPnpIdTable,      OPTIONAL
    IN      HASHTABLE InfFileTable          OPTIONAL
    )
{
    return pOpenAndLoadHwCompDatA (HwCompDatPath, TRUE, FALSE, FALSE, NULL, PnpIdTable, UnSupPnpIdTable, InfFileTable);
}


VOID
TakeHwCompHashTables (
    IN      DWORD HwCompDatId,
    OUT     HASHTABLE *PnpIdTable,
    OUT     HASHTABLE *UnSupPnpIdTable,
    OUT     HASHTABLE *InfFileTable
    )
{
    PHWCOMPSTRUCT Struct = (PHWCOMPSTRUCT) HwCompDatId;

    if (Struct) {
        *PnpIdTable = Struct->PnpIdTable;
        Struct->PnpIdTable = NULL;

        *UnSupPnpIdTable = Struct->UnSupPnpIdTable;
        Struct->UnSupPnpIdTable = NULL;

        *InfFileTable = Struct->InfFileTable;
        Struct->InfFileTable = NULL;
    }
}


VOID
CloseHwCompDat (
    IN      DWORD HwCompDatId
    )
{
    PHWCOMPSTRUCT Struct = (PHWCOMPSTRUCT) HwCompDatId;

    if (Struct) {
        HtFree (Struct->PnpIdTable);
        HtFree (Struct->UnSupPnpIdTable);
        HtFree (Struct->InfFileTable);

        if (Struct->File != INVALID_HANDLE_VALUE) {
            CloseHandle (Struct->File);
        }

        MemFree (g_hHeap, 0, Struct);
    }
}


VOID
SetWorkingTables (
    IN      DWORD HwCompDatId,
    IN      HASHTABLE PnpIdTable,
    IN      HASHTABLE UnSupPnpIdTable,
    IN      HASHTABLE InfFileTable
    )
{
    PHWCOMPSTRUCT Struct = (PHWCOMPSTRUCT) HwCompDatId;

    if (Struct) {
        Struct->PnpIdTable = PnpIdTable;
        Struct->UnSupPnpIdTable = UnSupPnpIdTable;
        Struct->InfFileTable = InfFileTable;
    }
}


BOOL
IsPnpIdSupportedByNtA (
    IN      DWORD HwCompDatId,
    IN      PCSTR PnpId
    )
{
    PHWCOMPSTRUCT Struct = (PHWCOMPSTRUCT) HwCompDatId;
    BOOL b = FALSE;

    if (Struct) {
        b = HtFindString (Struct->PnpIdTable, PnpId) != 0;
    }

    return b;
}


BOOL
IsPnpIdUnsupportedByNtA (
    IN      DWORD HwCompDatId,
    IN      PCSTR PnpId
    )
{
    PHWCOMPSTRUCT Struct = (PHWCOMPSTRUCT) HwCompDatId;
    BOOL b = FALSE;

    if (Struct) {
        b = HtFindString (Struct->UnSupPnpIdTable, PnpId) != 0;
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\hwcomp\online.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    online.c

Abstract:

    Functions to enumerate all currently online devices.  This module
    walks the registry's HKEY_DYN_DATA\Config Manager\Enum branch and
    returns an open HKEY to the HKEY_LOCAL_MACHINE\Enum item.

Author:

    Jim Schmidt (jimschm) 9-Apr-1997

Revision History:

--*/

#include "pch.h"

#define S_COMPATIBLE_IDS        TEXT("CompatibleIDs")

BOOL
EnumFirstActiveHardware (
    OUT     PACTIVE_HARDWARE_ENUM EnumPtr,
    IN      PCTSTR ClassFilter              OPTIONAL
    )

/*++

Routine Description:

  EnumFirstActiveHardware identifies the first online device as identified
  in HKDD\Config Manager.  Information about the device is stored in the
  enumeration structure, and the caller is expected to access its members
  directly.

  The caller can specify a class filter pattern to screen devices by type.

Arguments:

  EnumPtr - Receives the enumeration state of the first device listed in
            HKDD\Config Manager.

  ClassFilter - Specifies a pattern to limit the search to.  comparison is
                performed against the Class value of the dev node.

Return Value:

  TRUE if an active device was found, or FALSE if enumeration is
  complete.

--*/

{
    ZeroMemory (EnumPtr, sizeof (ACTIVE_HARDWARE_ENUM));

    if (ClassFilter) {
        EnumPtr->ClassFilter = (PTSTR) MemAlloc (g_hHeap, 0, SizeOfString (ClassFilter));
        if (!EnumPtr->ClassFilter) {
            return FALSE;
        }

        StringCopy (EnumPtr->ClassFilter, ClassFilter);
    }

    EnumPtr->ConfigMgrKey = OpenRegKey (HKEY_DYN_DATA, S_CONFIG_MANAGER);
    if (!EnumPtr->ConfigMgrKey) {
        LOG ((LOG_ERROR, "Cannot open HKDD\\%s for hardware enumeration", S_CONFIG_MANAGER));
        AbortActiveHardwareEnum (EnumPtr);
        return FALSE;
    }

    EnumPtr->EnumKey = OpenRegKey (HKEY_LOCAL_MACHINE, S_ENUM_BRANCH);
    if (!EnumPtr->EnumKey) {
        LOG ((LOG_ERROR, "Cannot open HKLM\\%s for hardware enumeration", S_ENUM_BRANCH));
        AbortActiveHardwareEnum (EnumPtr);
        return FALSE;
    }

    return EnumNextActiveHardware (EnumPtr);
}


BOOL
EnumNextActiveHardware (
    IN OUT  PACTIVE_HARDWARE_ENUM EnumPtr
    )

/*++

Routine Description:

  EnumNextActiveHardware enumerates the next active hardware device by
  using the dynamic data stored in HKDD\Config Manager and finding the
  static HKLM\Enum entry for the device.  If necessary, devices are
  screened based on the class pattern supplied to EnumFirstActiveHardware.

Arguments:

  EnumPtr - Specifies the enumeration structure initialized by
            EnumFirstActiveHardware.

Return Value:

  TRUE if another active device was found, or FALSE if enumeration is
  complete.

--*/

{
    HKEY OnlineDeviceKey;
    PCTSTR Data;
    PCTSTR Class;
    HKEY ActualDeviceKey;

    if (EnumPtr->ActualDeviceKey) {
        CloseRegKey (EnumPtr->ActualDeviceKey);
        EnumPtr->ActualDeviceKey = NULL;
    }

    do {
        //
        // Get the next registry key
        //

        if (EnumPtr->NotFirst) {
            if (!EnumNextRegKey (&EnumPtr->CurrentDevice)) {
                AbortActiveHardwareEnum (EnumPtr);
                return FALSE;
            }
        } else {
            if (!EnumFirstRegKey (&EnumPtr->CurrentDevice, EnumPtr->ConfigMgrKey)) {
                AbortActiveHardwareEnum (EnumPtr);
                return FALSE;
            }
            EnumPtr->NotFirst = TRUE;
        }

        //
        // Get the HardWareKey value from the current online device
        //

        OnlineDeviceKey = OpenRegKey (
                                EnumPtr->CurrentDevice.KeyHandle,
                                EnumPtr->CurrentDevice.SubKeyName
                                );

        if (OnlineDeviceKey) {
            //
            // Get the HardWareKey value data
            //

            Data = GetRegValueString (OnlineDeviceKey, S_HARDWAREKEY_VALUENAME);

            if (Data) {
                //
                // Open hardware key in enum branch
                //

                _tcssafecpy (EnumPtr->RegLocation, Data, MAX_TCHAR_PATH);

                ActualDeviceKey = OpenRegKey (EnumPtr->EnumKey, Data);
                if (ActualDeviceKey) {
                    //
                    // Check if this is actually a device (it has a
                    // class value)
                    //

                    Class = GetRegValueString (ActualDeviceKey, S_CLASS_VALUENAME);
                    if (Class) {
                        //
                        // It is a valid device, now compare against pattern
                        //

                        if (EnumPtr->ClassFilter) {
                            if (IsPatternMatch (EnumPtr->ClassFilter, Class)) {
                                // Match!!
                                EnumPtr->ActualDeviceKey = ActualDeviceKey;
                            }
                        } else {
                            // Match!!
                            EnumPtr->ActualDeviceKey = ActualDeviceKey;
                        }

                        MemFree (g_hHeap, 0, Class);
                    }

                    // Close if this device is not a match
                    if (!EnumPtr->ActualDeviceKey) {
                        CloseRegKey (ActualDeviceKey);
                    }
                }

                MemFree (g_hHeap, 0, Data);
            }

            CloseRegKey (OnlineDeviceKey);
        }

    } while (!EnumPtr->ActualDeviceKey);

    return TRUE;
}


VOID
AbortActiveHardwareEnum (
    IN      PACTIVE_HARDWARE_ENUM EnumPtr
    )

/*++

Routine Description:

  AbortActiveHardwareEnum is required by callers who need to stop
  active device enumeration before it completes itself.

Arguments:

  EnumPtr - Specifies the enumeration structure modified by
            EnumFirstActiveHardware or EnumNextActiveHardware

Return Value:

  none

--*/

{
    if (EnumPtr->ClassFilter) {
        MemFree (g_hHeap, 0, EnumPtr->ClassFilter);
    }

    if (EnumPtr->ActualDeviceKey) {
        CloseRegKey (EnumPtr->ActualDeviceKey);
        EnumPtr->ActualDeviceKey = NULL;
    }

    if (EnumPtr->ConfigMgrKey) {
        CloseRegKey (EnumPtr->ConfigMgrKey);
        EnumPtr->ConfigMgrKey = NULL;
    }

    if (EnumPtr->EnumKey) {
        CloseRegKey (EnumPtr->EnumKey);
        EnumPtr->EnumKey = NULL;
    }

    AbortRegKeyEnum (&EnumPtr->CurrentDevice);
}



BOOL
IsPnpIdOnline (
    IN      PCTSTR PnpId,
    IN      PCTSTR Class            OPTIONAL
    )

/*++

Routine Description:

  IsPnpIdOnline enumerats all active devices and scans each registry
  location for the specified PNP ID.

Arguments:

  PnpId - Specifies the PNP ID of the device that may be online.
          This string can be as complete as needed; it is compared
          against the registry key location of the device's dev node.
          Comparison is also performed against the CompatibleIDs
          value, if one exists.

          PnpID Example: *PNP0303

  Class - Specifies a device class pattern to limit the search to

Return Value:

  TRUE if the device with the specified ID is online, or
  FALSE if the device was not found.

--*/

{
    ACTIVE_HARDWARE_ENUM e;
    PCTSTR Data;
    BOOL b = FALSE;

    if (EnumFirstActiveHardware (&e, Class)) {
        do {
            if (_tcsistr (e.RegLocation, PnpId)) {
                b = TRUE;
                break;
            }

            Data = GetRegValueString (e.ActualDeviceKey, S_COMPATIBLE_IDS);
            if (Data) {
                b = _tcsistr (Data, PnpId) != NULL;
                MemFree (g_hHeap, 0, Data);

                if (b) {
                    break;
                }
            }

        } while (EnumNextActiveHardware (&e));
    }

    if (b) {
        AbortActiveHardwareEnum (&e);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\init9x\defer.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    defer.c

Abstract:

    This module implements deferred initialization, code that must run only
    after WINNT32 has obtained source directories.

Author:

    Jim Schmidt (jimschm) 08-Jan-1998

Revision History:

    jimschm     23-Sep-1998 InitNtEnvironment move

--*/

#include "pch.h"
#include "init9xp.h"
#include "ntverp.h"

//
// Local prototypes
//

HWND
pFindProcessWindow (
    VOID
    );

BOOL
pGetProfilesDirectory (
    OUT     PTSTR Path,         OPTIONAL
    IN OUT  PDWORD Size
    );

INT
pGetProcessorSpeed (
    OUT     PTSTR *Family
    );

BOOL
pReloadWin95upgInf (
    VOID
    )
{
    if (g_Win95UpgInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_Win95UpgInf);
        g_Win95UpgInf = INVALID_HANDLE_VALUE;
    }

    MYASSERT (g_Win95UpgInfFile);
    g_Win95UpgInf = InfOpenInfFile (g_Win95UpgInfFile);

    return g_Win95UpgInf != INVALID_HANDLE_VALUE;
}

//
// Implementation
//

BOOL
pPutBootFileInUninstallTempDir (
    IN      PCTSTR SrcFileName,
    IN      PCTSTR DestFileName         OPTIONAL
    )
{
    PCTSTR src;
    PCTSTR dest;
    UINT rc = ERROR_SUCCESS;
    DWORD attribs;

    src = JoinPaths (g_BootDrivePath, SrcFileName);
    dest = JoinPaths (g_TempDir, DestFileName ? DestFileName : SrcFileName);

    if (DoesFileExist (src)) {

        SetFileAttributes (dest, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (dest);

        if (!CopyFile (src, dest, FALSE)) {
            DEBUGMSG ((DBG_ERROR, "Can't copy %s to %s", src, dest));
            rc = GetLastError();
        }
    }

    SetLastError (rc);
    return rc == ERROR_SUCCESS;
}


BOOL
DeferredInit (
    IN      HWND WizardPageHandle
    )

/*++

Routine Description:

  DeferredInit performs all initialization that requires the source directories
  to be provied by Windows NT.  It runs after the user has selected the
  correct source directory, and WINNT32 has validated the choice.

Arguments:

  WizardPageHandle - Specifies handle to wizard page and is used to display
                     abnormal end popups.

Return Value:

  TRUE if init succeeds, or FALSE if it fails.  If FALSE is returned,
  Setup terminates without any popups.

--*/

{
    INT speed;
    PSTR family;
    MEMORYSTATUS memoryStatus;
    UINT index;
    TCHAR ProfileTemp[MAX_TCHAR_PATH];
    DWORD Size;
    BYTE bootSector[FAT_BOOT_SECTOR_SIZE];
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    DWORD dontCare;
    DWORD attribs;
    BOOL result = FALSE;
    TCHAR dest[MAX_TCHAR_PATH];
    HKEY key;

    LOG ((LOG_INFORMATION, "UpgradeModuleBuild: %u", VER_PRODUCTBUILD));


    __try {
        //
        // Update the list of INF modifications in %windir%\upginfs.
        //
        InitInfReplaceTable ();

        //
        // reload win95upg.inf if an update is available
        //
        if (g_UpginfsUpdated && *g_UpginfsUpdated) {
            if (!pReloadWin95upgInf ()) {
                LOG ((LOG_FATAL_ERROR, (PCSTR)MSG_WIN95UPG_RELOAD_FAILED, g_Win95UpgInfFile));
                __leave;
            }
        }

        //
        // Update the configuration settings (i.e. WINNT32 command line options)
        //
        if (!Cfg_InitializeUserOptions()) {

            if (!g_ConfigOptions.Help) {
                LOG ((LOG_FATAL_ERROR, (PCSTR)MSG_DEFERRED_INIT_FAILED_POPUP));
            }

            __leave;
        }

        //
        // Initialize safe/recovery mechanism
        //
        SafeModeInitialize (g_ConfigOptions.SafeMode);

        //
        // Initialize our fake NT environment block
        //

        InitNtEnvironment();

        //
        // Save parent window
        //

        g_ParentWndAlwaysValid = pFindProcessWindow();
        if (!g_ParentWndAlwaysValid) {
            DEBUGMSG ((DBG_WHOOPS, "Cannot find parent window handle!"));
            g_ParentWndAlwaysValid = GetParent(WizardPageHandle);
        }

        //
        // Make a symbol that is NULL in unattend mode, and a valid parent window
        // handle otherwise. This is used by migration DLLs and LOG functions.
        //

        g_ParentWnd = UNATTENDED() ? NULL : g_ParentWndAlwaysValid;
        LogReInit (&g_ParentWnd, NULL);

        //
        // Get information about the system we are running on...This can be very useful.
        //

        speed = pGetProcessorSpeed(&family);

        memoryStatus.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus(&memoryStatus);

        LOG((
            LOG_INFORMATION,
            "System Statistics:\n  Family: %s\n  Processor Speed: %u mhz\n  Memory: %u bytes",
            family ? family : "Unknown",
            speed,
            memoryStatus.dwTotalPhys
            ));


        if (!Cfg_CreateWorkDirectories()) {
            LOG ((LOG_FATAL_ERROR, (PCSTR)MSG_COULD_NOT_CREATE_DIRECTORY));
            __leave;
        }

        //
        // Start background copy thread
        //

        StartCopyThread();

        //
        // Get NT Profile dir.
        //

        Size = sizeof (ProfileTemp) / sizeof (ProfileTemp[0]);
        if (!pGetProfilesDirectory (ProfileTemp, &Size)) {
            LOG ((LOG_FATAL_ERROR, (PCSTR)MSG_DEFERRED_INIT_FAILED_POPUP));
            __leave;
        }


        //
        // replace any NT string env vars with actual values
        //

        ExpandNtEnvironmentVariables (ProfileTemp, ProfileTemp, sizeof (ProfileTemp));

        g_ProfileDirNt = PoolMemDuplicateString (g_GlobalPool, ProfileTemp);

        DEBUGMSG ((DBG_NAUSEA, "NT profile dir: %s", g_ProfileDirNt));

        //
        // Put current user name in the setup key
        //

        Size = ARRAYSIZE (ProfileTemp);
        if (GetUserName (ProfileTemp, &Size)) {
            key = CreateRegKeyStr (S_WIN9XUPG_KEY);
            if (key) {
                RegSetValueEx (
                    key,
                    S_CURRENT_USER_VALUENAME,
                    0,
                    REG_SZ,
                    (PBYTE) ProfileTemp,
                    SizeOfString (ProfileTemp)
                    );

                CloseRegKey (key);
            }
        }

        //
        // Open txtsetup.sif
        //

        if (g_TxtSetupSif == INVALID_HANDLE_VALUE) {
            g_TxtSetupSif = InfOpenInfInAllSources (S_TXTSETUP_SIF);

            if (g_TxtSetupSif == INVALID_HANDLE_VALUE) {
                LOG ((LOG_FATAL_ERROR, (PCSTR)MSG_TXTSETUP_SIF_ERROR));
                __leave;
            }
        }

        if (!BeginMigrationDllProcessing()) {
            DEBUGMSG ((DBG_WARNING, "BeginMigrationDllProcessing returned FALSE"));
            __leave;
        }

        if (!InitAccessibleDrives()) {
            __leave;
        }


        //
        // exclude all of the directories in source directories and optional directories from processing.
        //
        for (index = 0; index < SOURCEDIRECTORYCOUNT(); index++) {

            ExcludePath (g_ExclusionValue, SOURCEDIRECTORY(index));
        }

        for (index = 0; index < OPTIONALDIRECTORYCOUNT(); index++) {

            ExcludePath (g_ExclusionValue, OPTIONALDIRECTORY(index));
        }

        //
        // also exclude the directory used by Dynamic Setup
        //
        if (g_DynamicUpdateLocalDir) {
            ExcludePath (g_ExclusionValue, g_DynamicUpdateLocalDir);
        }

        //
        // Put original boot.ini, bootfont.bin, ntdetect.com, ntldr and boot
        // sector in setup temp dir
        //

        if (g_BootDrivePath && g_TempDir) {
            if (!pPutBootFileInUninstallTempDir (S_BOOTINI, S_BOOTINI_BACKUP)) {
                __leave;
            }

            if (!pPutBootFileInUninstallTempDir (S_BOOTFONT_BIN, S_BOOTFONT_BACKUP)) {
                __leave;
            }

            if (!pPutBootFileInUninstallTempDir (S_NTDETECT, S_NTDETECT_BACKUP)) {
                __leave;
            }

            if (!pPutBootFileInUninstallTempDir (S_NTLDR, S_NTLDR_BACKUP)) {
                __leave;
            }

            if (ReadDiskSectors (
                    *g_BootDrive,
                    FAT_STARTING_SECTOR,
                    FAT_BOOT_SECTOR_COUNT,
                    FAT_BOOT_SECTOR_SIZE,
                    bootSector
                    )) {

                StringCopy (dest, g_TempDir);
                StringCopy (AppendWack (dest), S_BOOTSECT_BACKUP);

                fileHandle = CreateFile (
                                dest,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

                if (fileHandle == INVALID_HANDLE_VALUE) {
                    DEBUGMSG ((DBG_ERROR, "Can't create %s", dest));
                    __leave;
                }

                if (!WriteFile (fileHandle, bootSector, sizeof (bootSector), &dontCare, NULL)) {
                    DEBUGMSG ((DBG_ERROR, "Can't write boot sector to %s", dest));
                    __leave;
                }
            }
        } else {
            MYASSERT (FALSE);
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
    }

    return result;
}


BOOL
pGetProfilesDirectory (
    OUT     PTSTR Path,         OPTIONAL
    IN OUT  PDWORD Size
    )

/*++

Routine Description:

  pGetProfileDirectory emulates the NT 5 API GetProfileDirectory.  It looks in
  hivesft.inf for Winlogon's ProfilesDirectory key.  If an override to the NT
  profile directory is given in the winnt.sif file, then the override is used
  instead.

Arguments:

  Path - Receives the user profile path

  Size - Specifies the size of Path, in TCHAR characters.  Receives the number
         of characters needed to hold the profile path.

Return Value:

  TRUE if the API succeeds, or FALSE if an unexpected error occurs.

--*/

{
    TCHAR Buffer[MAX_TCHAR_PATH];
    PCTSTR p;
    BOOL b;
    DWORD SizeNeeded;
    PCTSTR EndOfString;
    PCTSTR UserProfiles;

    if (!Size) {
        return FALSE;
    }

    MYASSERT (g_WinDir);
    MYASSERT (g_SourceDirectoryCountFromWinnt32);

    //
    // Look in answer file for setting, use it if it exists
    //

    Buffer[0] = 0;

    if (g_UnattendScriptFile && *g_UnattendScriptFile) {
        GetPrivateProfileString (
            S_GUIUNATTENDED,
            S_PROFILEDIR,
            S_EMPTY,
            Buffer,
            MAX_TCHAR_PATH,
            *g_UnattendScriptFile
            );
    }

    if (!(*Buffer)) {

        //
        // Default to %systemroot%\Documents and Settings
        //

        UserProfiles = GetStringResource (MSG_USER_PROFILE_ROOT);
        MYASSERT (UserProfiles);

        StringCopy (Buffer, UserProfiles);

        FreeStringResource (UserProfiles);
    }

    Buffer[MAX_TCHAR_PATH - 1] = 0;     // user can pass in anything via answer file!

    SizeNeeded = ByteCount (Buffer) / sizeof (TCHAR);

    if (Path) {
        b = *Size >= SizeNeeded;

        if (*Size) {
            EndOfString = GetEndOfString (Buffer);
            p = min (EndOfString, Buffer + *Size);
            StringCopyAB (Path, Buffer, p);
        }
    } else {
        b = TRUE;
    }

    *Size = SizeNeeded;

    return b;
}


typedef struct {
    DWORD ProcessId;
    HWND hwnd;
} FINDPROCESSWINDOW, *PFINDPROCESSWINDOW;


BOOL
CALLBACK
pFindProcessWindowCallback (
    HWND hwnd,
    LPARAM lParam
    )

/*++

Routine Description:

  pFindProcessWindowCallback is called by the window enumeration started by
  pFindProcessWindow.  If the process ID of the window matches our process
  ID, then the enumeration is stopped so the proper window handle can
  be returned by pFindProcessWindow.

Arguments:

  hwnd - Specifies the current enumerated window handle

  lParam - Specifies the FINDPROCESSWINDOW structure allocated by
           pFindProcessWindow

Return Value:

  TRUE if enuemration should continue, or FALSE if it should stop.

--*/

{
    PFINDPROCESSWINDOW p;
    DWORD ProcessId = 0;

    p = (PFINDPROCESSWINDOW) lParam;

    GetWindowThreadProcessId (hwnd, &ProcessId);
    if (ProcessId == p->ProcessId) {
        p->hwnd = hwnd;
        return FALSE;
    }

    return TRUE;
}


HWND
pFindProcessWindow (
    VOID
    )

/*++

Routine Description:

  pFindProcessWindow enumerates all windows and returns the first one that
  the current process owns.  There should only be one, so the end result
  is a handle to the main window of the process.

Arguments:

  none

Return Value:

  A handle to the process main window, or NULL if no windows exist for
  the process.

--*/

{
    FINDPROCESSWINDOW Enum;

    ZeroMemory (&Enum, sizeof (Enum));
    Enum.ProcessId = GetCurrentProcessId();

    EnumWindows (pFindProcessWindowCallback, (LPARAM) &Enum);

    return Enum.hwnd;
}


INT
pGetProcessorSpeed (
    OUT     PTSTR *Family
    )

/*++

Routine Description:

  pGetProcessorSpeed returns the speed in MHz of the computer, and identifies
  the processor if it is a Pentium or better.  Code from Todd Laney (toddla).

Arguments:

  Family - Receives a pointer to the name of the processor family

Return Value:

  The speed of the processor, in MHz.

--*/

{
    SYSTEM_INFO si;
    __int64 start, end, freq;
    INT     flags,family;
    INT     time;
    INT     clocks;
    DWORD   oldclass;
    HANDLE      hprocess;
    INT     familyIndex = 0;

    static PTSTR familyStrings[] = {
        "Unknown (0)",
        "Unknown (1)",
        "Unknown (2)",
        "x386",
        "x486",
        "Pentium",
        "Pentium Pro",
        "Pentium II (?)",
        "Unknown..."
    };

    *Family = NULL;

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel) {

        family = si.wProcessorLevel;

    } else {

        family = 0;

    //Ok, we're on Win95
        switch (si.dwProcessorType) {
            case PROCESSOR_INTEL_386:
                familyIndex=3;
                break;

            case PROCESSOR_INTEL_486:
                familyIndex=4;
                break;
            default:
                familyIndex=0;
                break;
        }
    }

    //
    // make sure this is a INTEL Pentium (or clone) or higher.
    //
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return 0;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return 0;

    //
    // see if this chip supports rdtsc before using it.
    //
    __try
    {
        _asm
        {
            mov     eax,1
            _emit   00Fh     ;; CPUID
            _emit   0A2h
            mov     flags,edx
            mov     family,eax
        }
    }
    __except(1)
    {
        flags = 0;
    }

    //check for support of CPUID and fail
    if (!(flags & 0x10))
        return 0;

    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!familyIndex) {
       familyIndex=(family & 0x0F00) >> 8;
    }

    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass(hprocess);
    SetPriorityClass(hprocess, REALTIME_PRIORITY_CLASS);
    Sleep(10);

    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    _asm
    {
        _emit   0Fh     ;; RDTSC
        _emit   31h
        mov     ecx,100000
x:      dec     ecx
        jnz     x
        mov     ebx,eax
        _emit   0Fh     ;; RDTSC
        _emit   31h
        sub     eax,ebx
        mov     dword ptr clocks[0],eax
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);
    SetPriorityClass(hprocess, oldclass);

    time = MulDiv((int)(end-start),1000000,(int)freq);

    if (familyIndex > 7) {
        familyIndex = 7;
    }

    *Family = familyStrings[familyIndex];

    return (clocks + time/2) / time;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\init9x\config.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.c

Abstract:

    This file implements the windows 9x side configuration functionality of the upgrade project.
    This includes unattend behavior and command line options in addition to the normal set of
    configuration duties.

Author:

    Marc R. Whitten (marcw)

Revision History:

    ovidiut     14-Mar-2000 Added encrypted passwords support
    marcw       15-Oct-1998 Cleaned up unattend options.
    jimschm     23-Sep-1998 Removed operation code
    jimschm     01-May-1998 Removed MikeCo plugtemp.inf crap
    marcw       10-Dec-1997 Added UserPassword unattend setting.
    calinn      19-Nov-1997 Added g_Boot16, enables 16 bit environment boot option
    marcw       13-Nov-1997 Unattend settings changed to get closer to a final state.
    marcw       12-Aug-1997 We now respect setup's unattend flag.
    marcw       21-Jul-1997 Added FAIR flag.
    marcw       26-May-1997 Added lots and lots of comments.

--*/

#include "pch.h"

USEROPTIONS g_ConfigOptions;
PVOID g_OptionsTable;


#undef BOOLOPTION
#undef MULTISZOPTION
#undef STRINGOPTION
#undef INTOPTION
#undef TRISTATEOPTION


typedef BOOL (OPTIONHANDLERFUN)(PTSTR, PVOID * Option, PTSTR Value);
typedef OPTIONHANDLERFUN * POPTIONHANDLERFUN;

BOOL pHandleBoolOption (PTSTR, PVOID *, PTSTR);
BOOL pHandleIntOption (PTSTR, PVOID *, PTSTR);
BOOL pHandleTriStateOption (PTSTR, PVOID *, PTSTR);
BOOL pHandleMultiSzOption (PTSTR, PVOID *, PTSTR);
BOOL pHandleStringOption (PTSTR, PVOID *, PTSTR);
BOOL pHandleSaveReportTo (PTSTR, PVOID *, PTSTR);
BOOL pHandleBoot16 (PTSTR, PVOID *, PTSTR);
BOOL pGetDefaultPassword (PTSTR, PVOID *, PTSTR);


typedef struct {

    PTSTR OptionName;
    PVOID Option;
    POPTIONHANDLERFUN DefaultHandler;
    POPTIONHANDLERFUN SpecialHandler;
    PVOID Default;

} OPTIONSTRUCT, *POPTIONSTRUCT;

typedef struct {
    PTSTR Alias;
    PTSTR Option;
} ALIASSTRUCT, *PALIASSTRUCT;

#define BOOLOPTION(o,h,d) {TEXT(#o), &(g_ConfigOptions.##o), pHandleBoolOption, (h), (PVOID) (BOOL) (d) ? S_YES  : S_NO},
#define INTOPTION(o,h,d) {TEXT(#o), &(g_ConfigOptions.##o), pHandleIntOption, (h), (PVOID)(d)},
#define TRISTATEOPTION(o,h,d) {TEXT(#o), &(g_ConfigOptions.##o), pHandleTriStateOption, (h), (PVOID)  (INT) (d == TRISTATE_AUTO)? S_AUTO: (d == TRISTATE_YES)? S_YES  : S_NO},
#define MULTISZOPTION(o,h,d) {TEXT(#o), &(g_ConfigOptions.##o), pHandleMultiSzOption, (h), (PVOID) (d)},
#define STRINGOPTION(o,h,d) {TEXT(#o), &(g_ConfigOptions.##o), pHandleStringOption, (h), (PVOID) (d)},

OPTIONSTRUCT g_OptionsList[] = {OPTION_LIST /*,*/ {NULL,NULL,NULL,NULL}};

#define ALIAS(a,o) {TEXT(#a),TEXT(#o)},

ALIASSTRUCT g_AliasList[] = {ALIAS_LIST /*,*/ {NULL,NULL}};



#define HANDLEOPTION(Os,Value) {Os->SpecialHandler  ?   \
        Os->SpecialHandler (Os->OptionName,Os->Option,Value)       :   \
        Os->DefaultHandler (Os->OptionName,Os->Option,Value);          \
        }




BOOL
Cfg_CreateWorkDirectories (
    VOID
    )

{
/*++

Routine Description:

    This routine is responsible for creating the main win9xupg working directories. It should not
    be called until after the user has chosen to upgrade his system. In practice, this means that
    we must not create our directories when winnt32 calls us to init as this is done before the
    user chooses wether to upgrade or do a clean install.



Arguments:

    None.

Return Value:

    None.

--*/

    DWORD   rc;
    FILE_ENUM e;

    if (EnumFirstFile (&e, g_TempDir, FALSE)) {
        do {

            if (e.Directory) {
                CreateEmptyDirectory (e.FullPath);
            }

       } while (EnumNextFile (&e));
    }

    rc = CreateEmptyDirectory (g_PlugInTempDir);
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pInitUserOptions (
    VOID
    )
{
   POPTIONSTRUCT os;
   BOOL rSuccess = TRUE;

   os = g_OptionsList;

   while (os->OptionName) {

        //
        // Set the default value.
        //
        HANDLEOPTION(os, os->Default);


        //
        // Add the option struct to a string table for quick retrieval.
        //
        if (-1 == pSetupStringTableAddStringEx (
                        g_OptionsTable,
                        os->OptionName,
                        STRTAB_CASE_INSENSITIVE,
                        (PBYTE) &os,
                        sizeof (POPTIONSTRUCT)
                        )) {

            LOG ((LOG_ERROR, "User Options: Can't add to string table"));
            rSuccess = FALSE;
            break;
        }

        os++;
   }

   return rSuccess;
}


POPTIONSTRUCT
pFindOption (
    PTSTR OptionName
    )
{

/*++

Routine Description:

  Given an option name, pFindOption returns the associated option struct.

Arguments:

  OptionName - The name of the option to find.

Return Value:

  a valid option struct if successful, NULL otherwise.

--*/



    POPTIONSTRUCT rOption = NULL;
    UINT rc;

    //
    // find the matching option struct for this, and
    // call the handler.
    //
    rc = pSetupStringTableLookUpStringEx (
        g_OptionsTable,
        OptionName,
        STRTAB_CASE_INSENSITIVE,
        (PBYTE) &rOption,
        sizeof (POPTIONSTRUCT)
        );

    DEBUGMSG_IF ((rc == -1, DBG_WARNING, "Unknown option found: %s", OptionName));

    return rOption;
}

VOID
pReadUserOptionsFromUnattendFile (
    VOID
    )

/*++

Routine Description:

  This function reads all available win9xupg options from an unattend.txt
  file passed to winnt32.

Arguments:

  None.

Return Value:

  None.

--*/


{
    POPTIONSTRUCT os;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PTSTR option;
    PTSTR value;
    HINF unattendInf;



    if (*g_UnattendScriptFile) {

        unattendInf = InfOpenInfFile (*g_UnattendScriptFile);

        if (unattendInf != INVALID_HANDLE_VALUE) {

            if (InfFindFirstLine (unattendInf, S_WIN9XUPGRADE, NULL, &is)) {

                //
                // Enumerate through each of the options, call the
                //
                do {

                    option = InfGetStringField (&is, 0);
                    value = InfGetLineText (&is);

                    //
                    // find the matching option struct for this, and
                    // call the handler.
                    //
                    os = pFindOption (option);

                    if (os) {

                        HANDLEOPTION(os, value);
                    }


                } while (InfFindNextLine (&is));

            }

            if (InfFindFirstLine (unattendInf, S_UNINSTALL, NULL, &is)) {

                //
                // Enumerate through each of the options, call the
                //
                do {

                    option = InfGetStringField (&is, 0);
                    value = InfGetLineText (&is);

                    //
                    // find the matching option struct for this, and
                    // call the handler.
                    //
                    os = pFindOption (option);

                    if (os) {

                        HANDLEOPTION(os, value);
                    }


                } while (InfFindNextLine (&is));

            }

            InfCloseInfFile (unattendInf);
        }
    }

    InfCleanUpInfStruct (&is);
}

VOID
pReadUserOptionsFromCommandLine (
    VOID
    )

/*++

Routine Description:

  This function processes all of the win9xupg command line options that were
  passed into winnt32 (those starting with /#U:) winnt32 has already packaged
  this list (minus the /#U:) into a nice multisz for us.

Arguments:

  None.

Return Value:

  None.

--*/


{
    MULTISZ_ENUM e;
    PTSTR option;
    PTSTR value;
    PTSTR equals;
    POPTIONSTRUCT os;

    if (*g_CmdLineOptions) {

        //
        // We have data to parse, run through the multisz.
        //
        if (EnumFirstMultiSz (&e, *g_CmdLineOptions)) {

            do {

                option = (PTSTR) e.CurrentString;
                value = NULL;

                equals = _tcschr (option, TEXT('='));
                if (equals) {
                    value = _tcsinc (equals);
                    *equals = 0;
                }

                os = pFindOption (option);
                if (os) {
                    HANDLEOPTION (os, value);
                }

                if (equals) {
                    *equals = TEXT('=');
                }

            } while (EnumNextMultiSz (&e));
        }
    }
}




VOID
pCreateNetCfgIni (
    VOID
    )
{
/*++

Routine Description:

  pCreateNetCfgIni creates a very basic netcfg.ini file. This will cause many
  networking messages to be dumped to the debugger during Network
  Installation in GUI mode. The file is deleted at the end of setup, if we
  created it.

Arguments:

  None.

Return Value:

  None.

--*/


    HANDLE h;
    PTSTR  path;
    PTSTR  content =
            TEXT("[Default]\r\n")
            TEXT("OutputToDebug=1\r\n\r\n")
            TEXT("[OptErrors]\r\n")
            TEXT("OutputToDebug=0\r\n\r\n")
            TEXT("[EsLocks]\r\n")
            TEXT("OutputToDebug=0\r\n");
    UINT   unused;

    path = JoinPaths(g_WinDir,TEXT("netcfg.ini"));

    //
    // Create the netcfg.ini file, and fill in its content. Note that we do
    // not want to overwrite a netcfg.ini file that may previously exist.
    //

    h = CreateFile (
        path,
        GENERIC_READ | GENERIC_WRITE,
        0,                              // No sharing.
        NULL,                           // No inheritance.
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL                            // No template file.
        );




    if (h != INVALID_HANDLE_VALUE) {

        if (!WriteFile (h,(PVOID) content, ByteCount(content), &unused, NULL)) {
            LOG((LOG_ERROR,"Error writing netcfg.ini."));
        }

        CloseHandle(h);
    }
    ELSE_DEBUGMSG((DBG_WARNING,"pCreateNetCfgIni: Could not create file. Probably already exists.."));

    FreePathString(path);


}

VOID
pInitAliases (
    VOID
    )
{

/*++

Routine Description:

  This functions initializes any aliases specified within unattend.h. These
  aliases may be used instead of the option they refer to.

Arguments:

  None.

Return Value:

  None.

--*/


    PALIASSTRUCT alias;
    POPTIONSTRUCT option;

    alias = g_AliasList;


    while (alias->Alias) {


        option = pFindOption (alias->Option);

        if (option) {

            if (-1 == pSetupStringTableAddStringEx (
                        g_OptionsTable,
                        alias->Alias,
                        STRTAB_CASE_INSENSITIVE,
                        (PBYTE) &option,
                        sizeof (POPTIONSTRUCT)
                        )) {

                LOG ((LOG_ERROR, "User Options: Can't add alias %s to string table.", alias->Alias));
                break;
            }

        }
        ELSE_DEBUGMSG ((DBG_WARNING, "Could not find matching option for alias %s=%s.",alias->Alias,alias->Option));


        alias++;
    }
}


BOOL
Cfg_InitializeUserOptions (
    VOID
    )

/*++

Routine Description:

    This routine is responsible for Initializing user configurable options for the win9xupg project.
    These options can come from either the command line or an unattend file.  This routine also saves
    the user options into the Win9xUpg.UserOptions section of the answer file.

    The heirarchy of user options is:
        (1) Command line parameters.
        (2) Unattend file parameters.
        (3) Default parameters.

    In other words, command line parameters have precedence above unattend file parameters which in
    turn have precedence over the default parameters.

    Since this function relies on the winnt32 supplied Unattend File and Command Line parameters,
    it must not be called until after winnt32 has filled in the necessary variables. In practice,
    this means that this function cannot be called until after the first time one of win9xupg's
    wizard pages is activated.

Arguments:

    None.

Return Value:

    TRUE if user options were successfully configured, FALSE otherwise.

--*/

{

    BOOL rSuccess = TRUE;
    PTSTR user = NULL;
    PTSTR domain = NULL;
    PTSTR curPos = NULL;
    PTSTR password = NULL;
    TCHAR FileSystem[MAX_PATH] = TEXT("");



    g_OptionsTable = pSetupStringTableInitializeEx (sizeof (POPTIONSTRUCT), 0);


    if (!g_OptionsTable) {
        LOG ((LOG_ERROR, "User Options: Unable to initialize string table."));
        return FALSE;
    }

    //
    // Set default values for everything, fill in the options table.
    //
    if (!pInitUserOptions ()) {
        pSetupStringTableDestroy (g_OptionsTable);
        return FALSE;
    }

    //
    // Add any aliases to the table.
    //
    pInitAliases();

    //
    // Read values from the unattend file.
    //
    pReadUserOptionsFromUnattendFile ();

    //
    // Read values from the command line.
    //
    pReadUserOptionsFromCommandLine ();

    //
    // Do any post processing necessary.
    //

    //
    //If user wish to change filesystem type we have disable uninstall feature.
    //

    if(*g_UnattendScriptFile){
        GetPrivateProfileString(S_UNATTENDED,
                                S_FILESYSTEM,
                                FileSystem,
                                FileSystem,
                                sizeof(FileSystem),
                                *g_UnattendScriptFile);

        if(FileSystem[0] && !StringIMatch(FileSystem, TEXT("LeaveAlone"))){
            LOG ((LOG_WARNING, "User Options: User require to change filesystem.Uninstall option will be disabled"));
            g_ConfigOptions.EnableBackup = TRISTATE_NO;
        }
    }


    //
    // Use migisol.exe only if testdlls is FALSE.
    //
    g_UseMigIsol = !g_ConfigOptions.TestDlls;

#ifdef DEBUG

    //
    // if DoLog was specified, turn on the variable in debug.c.
    //
    if (g_ConfigOptions.DoLog) {
        SET_DOLOG();
        LogReInit (NULL, NULL);
        pCreateNetCfgIni();
    }

#endif

#ifdef PRERELEASE

    //
    // if stress was specified, turn on global.
    //
    if (g_ConfigOptions.Stress) {
        g_Stress = TRUE;
        g_ConfigOptions.AllLog = TRUE;
    }

    //
    // if fast was specified, turn on global.
    //
    if (g_ConfigOptions.Fast) {
        g_Stress = TRUE;
    }

    //
    // if autostress was specified, turn on stress.
    //
    if (g_ConfigOptions.AutoStress) {
        g_Stress = TRUE;
        g_ConfigOptions.AllLog = TRUE;
        g_ConfigOptions.Stress = TRUE;
    }

    //
    // If AllLog was specified, force all log output into files
    //

    if (g_ConfigOptions.AllLog) {
        SET_DOLOG();
        LogReInit (NULL, NULL);
        pCreateNetCfgIni();
        SuppressAllLogPopups (TRUE);
    }

    //
    // If help was specified, then dump the option list
    //

    if (g_ConfigOptions.Help) {
        POPTIONSTRUCT Option;
        PALIASSTRUCT Alias;
        GROWBUFFER GrowBuf = GROWBUF_INIT;
        TCHAR Buf[128];

        Option = g_OptionsList;
        while (Option->OptionName) {
            wsprintf (Buf, TEXT("/#U:%-20s"), Option->OptionName);
            GrowBufAppendString (&GrowBuf, Buf);

            Alias = g_AliasList;
            while (Alias->Alias) {
                if (StringIMatch (Option->OptionName, Alias->Option)) {
                    wsprintf (Buf, TEXT("/#U:%-20s"), Alias->Alias);
                    GrowBufAppendString (&GrowBuf, Buf);
                }

                Alias++;
            }

            wsprintf (Buf, TEXT("\n"));
            GrowBufAppendString (&GrowBuf, Buf);

            Option++;
        }

        MessageBox (NULL, (PCSTR) GrowBuf.Buf, TEXT("Help"), MB_OK);
        FreeGrowBuffer (&GrowBuf);

        return FALSE;
    }


#endif


    //
    // Save user domain information into memdb.
    //
    if (g_ConfigOptions.UserDomain && *g_ConfigOptions.UserDomain) {

        curPos = g_ConfigOptions.UserDomain;

        while (curPos) {


            user = _tcschr(curPos,TEXT(','));

            if (user) {

                *user = 0;
                user = _tcsinc(user);
                domain = curPos;
                curPos = _tcschr(user,TEXT(','));

                if (curPos) {
                    *curPos = 0;
                    curPos = _tcsinc(curPos);
                }

                if (!MemDbSetValueEx(
                    MEMDB_CATEGORY_KNOWNDOMAIN,
                    domain,
                    user,
                    NULL,
                    0,
                    NULL
                    )) {

                    ERROR_NONCRITICAL;
                    LOG((LOG_ERROR,"Error saving domain information into memdb. Domain: %s User: %s",domain,user));
                }
            } else {
                ERROR_NONCRITICAL;
                LOG((LOG_ERROR,"Error in Unattend file for UserDomains. Domain specified but no User. Domain: %s",curPos));
                curPos = NULL;
            }
        }
    }

    //
    // If UserPassword was specified, then add the information into memdb.
    //
    if (g_ConfigOptions.UserPassword && *g_ConfigOptions.UserPassword) {

        curPos = g_ConfigOptions.UserPassword;

        while (curPos) {


            password = _tcschr(curPos,TEXT(','));

            if (password) {
                *password = 0;
                password = _tcsinc(password);
                user = curPos;
                curPos = _tcschr(password,TEXT(','));
                if (curPos) {
                    *curPos = 0;
                    curPos = _tcsinc(curPos);
                }
                if (!MemDbSetValueEx(
                    MEMDB_CATEGORY_USERPASSWORD,
                    user,
                    password,
                    NULL,
                    g_ConfigOptions.EncryptedUserPasswords ? PASSWORD_ATTR_ENCRYPTED : 0,
                    NULL
                    )) {

                    ERROR_NONCRITICAL;
                    LOG((LOG_ERROR,"Error saving password information into memdb. Password: %s User: %s",password,user));

                }
            } else {
                ERROR_NONCRITICAL;
                LOG((LOG_ERROR,"Error in Unattend file for UserDomains. Password specified but no User. Password: %s",curPos));
                curPos = NULL;
            }
        }
    }


    //
    // If a default password was set, save that away now.
    //
    if (g_ConfigOptions.DefaultPassword && *g_ConfigOptions.DefaultPassword) {

        if (!MemDbSetValueEx (
            MEMDB_CATEGORY_USERPASSWORD,
            S_DEFAULTUSER,
            g_ConfigOptions.DefaultPassword,
            NULL,
            g_ConfigOptions.EncryptedUserPasswords ? PASSWORD_ATTR_ENCRYPTED : 0,
            NULL
            )) {

            ERROR_NONCRITICAL;
            LOG((LOG_ERROR, "Error saving password information into memdb. Password: %s (Default)", password));
        }
    }



    //
    // We're done with our string table.
    //
    pSetupStringTableDestroy (g_OptionsTable);

    return rSuccess;
}




//
// Option Handling Functions.
//
BOOL
pHandleBoolOption (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{
    BOOL rSuccess = TRUE;
    PBOOL option = (PBOOL) OptionVar;

    MYASSERT(Name && OptionVar);

    //
    // We treat a NULL value as equivelant to TRUE.
    // /#U:DOLOG on the command line is equivelant to
    // /#U:DOLOG=YES
    //

    if (!Value) {
        Value = S_YES;
    }

    if (StringIMatch (Value, S_YES) ||
        StringIMatch (Value, S_ONE) ||
        StringIMatch (Value, TEXT("TRUE"))) {

        *option = TRUE;
    }
    else {

        *option = FALSE;
    }


    //
    // Save the data away to buildinf.
    //
    WriteInfKey (S_WIN9XUPGUSEROPTIONS, Name, *option ? S_YES : S_NO);


    return rSuccess;
}

BOOL
pHandleIntOption (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{
    BOOL rSuccess = TRUE;
    PINT option = (PINT) OptionVar;

    MYASSERT(Name && OptionVar);

    //
    // We treat a NULL value as equivelant to 0.
    // /#U:DOLOG on the command line is equivelant to
    // /#U:DOLOG=0
    //

    if (!Value) {
        Value = TEXT("0");
    }

    *option = _ttoi((PCTSTR)Value);

    //
    // Save the data away to buildinf.
    //
    WriteInfKey (S_WIN9XUPGUSEROPTIONS, Name, Value);


    return rSuccess;
}

BOOL
pHandleTriStateOption (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{
    BOOL rSuccess = TRUE;
    PINT option = (PINT) OptionVar;

    MYASSERT(Name && OptionVar);

    //
    // We treat a NULL value as equivelant to AUTO.
    // /#U:DOLOG on the command line is equivelant to
    // /#U:DOLOG=AUTO
    //

    if (!Value) {
        Value = S_AUTO;
    }

    if (StringIMatch (Value, S_YES)  ||
        StringIMatch (Value, S_ONE)  ||
        StringIMatch (Value, S_TRUE) ||
        StringIMatch (Value, S_REQUIRED)) {
        *option = TRISTATE_YES;
    }
    else {
        if(StringIMatch (Value, S_NO) ||
           StringIMatch (Value, S_STR_FALSE) ||
           StringIMatch (Value, S_ZERO)) {
            *option = TRISTATE_NO;
        }
        else {
            *option = TRISTATE_AUTO;
        }
    }


    //
    // Save the data away to buildinf.
    //
    WriteInfKey (
        S_WIN9XUPGUSEROPTIONS,
        Name,
        (*option == TRISTATE_AUTO)? S_AUTO:
                                    (*option == TRISTATE_YES)? S_YES  : S_NO);

    return rSuccess;
}

BOOL
pHandleStringOption (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value          OPTIONAL
    )
{
    PTSTR * option = (PTSTR *) OptionVar;

    MYASSERT(Name && OptionVar);

    if (!Value) {

        if (!*option) {
            *option = S_EMPTY;
        }

        WriteInfKey (S_WIN9XUPGUSEROPTIONS, Name, NULL);
        return TRUE;
    }

    *option = PoolMemDuplicateString (g_UserOptionPool, Value);

    //
    // save the data into winnt.sif.
    //
    WriteInfKey (S_WIN9XUPGUSEROPTIONS, Name, *option);

    return TRUE;
}

BOOL
pHandleMultiSzOption (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{

    BOOL rSuccess = TRUE;
    PTSTR * option = (PTSTR *) OptionVar;
    PTSTR end;
    PTSTR start;
    PTSTR temp;
    CHARTYPE ch;
    PTSTR p;
    GROWBUFFER growBuf = GROWBUF_INIT;
    UINT offset;
    MULTISZ_ENUM e;

    MYASSERT(Name && OptionVar);

    end = *option;

    if (end) {

        start = end;
        while (*end) {
            end = GetEndOfString (end) + 1;
        }
        end = _tcsinc (end);

        temp = (PTSTR) GrowBuffer (&growBuf, end - start);
        MYASSERT (temp);

        CopyMemory (temp, start, end - start);
        growBuf.End -= sizeof (TCHAR);

    }


    if (Value) {
        //
        // Parse Value into one or more strings, separated at the commas.
        //
        // NOTE: We do not support any escaping to get a real comma in one
        //       of these strings
        //

        temp = AllocText (CharCount (Value) + 1);

        end = NULL;
        start = NULL;
        p = Value;

        do {

            ch = _tcsnextc (p);

            if (ch && _istspace (ch)) {
                if (!end) {
                    end = p;
                }
            } else if (ch && ch != TEXT(',')) {
                if (!start) {
                    start = p;
                }
                end = NULL;
            } else {
                if (!end) {
                    end = p;
                }

                if (start) {
                    StringCopyAB (temp, start, end);
                } else {
                    *temp = 0;
                }

                MultiSzAppend (&growBuf, temp);
                FreeText (temp);

                end = NULL;
                start = NULL;
            }

            p = _tcsinc (p);

        } while (ch);
    }

    MultiSzAppend (&growBuf, S_EMPTY);

    *option = PoolMemDuplicateMultiSz (g_UserOptionPool, (PCTSTR) growBuf.Buf);
    FreeGrowBuffer (&growBuf);


    offset = 0;
    if (EnumFirstMultiSz (&e, *option)) {

        do {
            offset = WriteInfKeyEx (S_WIN9XUPGUSEROPTIONS, Name, e.CurrentString, offset, FALSE);

        } while (EnumNextMultiSz (&e));
    }

    return rSuccess;
}


BOOL
pHandleSaveReportTo (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{
    BOOL rSuccess = TRUE;
    PTSTR * option = (PTSTR *) OptionVar;
    TCHAR computerName[MAX_COMPUTER_NAME];
    PTSTR newPath;
    PTSTR envVars[4]={NULL,NULL,NULL,NULL};
    UINT computerNameLength;

    MYASSERT (Name && OptionVar);

    rSuccess = pHandleStringOption (Name, OptionVar, Value);

    computerNameLength = MAX_COMPUTER_NAME;

    if (!GetComputerName (computerName, &computerNameLength)) {
        DEBUGMSG ((DBG_WARNING, "InitUserOptions: Could not retrieve computer name."));
        *computerName = 0;
    }

    if (*computerName) {
        envVars[0] = S_COMPUTERNAME;
        envVars[1] = computerName;
    }

    newPath = ExpandEnvironmentTextEx (*option, envVars);
    *option = PoolMemDuplicateString (g_UserOptionPool, newPath);
    FreeText (newPath);

    if (*option) {
        if (ERROR_SUCCESS != MakeSurePathExists (*option, FALSE)) {
            LOG ((LOG_ERROR, (PCSTR)MSG_ERROR_CREATING_SAVETO_DIRECTORY, g_ConfigOptions.SaveReportTo));
            *option = FALSE;
        }
    }

    return rSuccess;
}

BOOL
pHandleBoot16 (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{

    BOOL rSuccess = TRUE;
    PTSTR * option = (PTSTR *) OptionVar;

    if (!Value ||
        StringIMatch (Value, S_NO) ||
        StringIMatch (Value, S_ZERO)) {

        *option = S_NO;

        *g_Boot16 = BOOT16_NO;
    }
    else if (Value &&
            (StringIMatch (Value, S_BOOT16_UNSPECIFIED) ||
             StringIMatch (Value, S_BOOT16_AUTOMATIC))) {


        *option = S_BOOT16_AUTOMATIC;

        *g_Boot16 = BOOT16_AUTOMATIC;
    }
    else {

        *g_Boot16 = BOOT16_YES;

        *option = S_YES;


    }

    WriteInfKey (S_WIN9XUPGUSEROPTIONS, Name, *option);

    return rSuccess;
}

BOOL
pGetDefaultPassword (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{
    PTSTR * option = (PTSTR *) OptionVar;

    MYASSERT (Name && OptionVar);

    //
    // for Personal set an empty user password by default
    //
    if (g_PersonalSKU && !Value) {
        Value = TEXT("*");
    }

    return pHandleStringOption (Name, OptionVar, Value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\hwcomp\resenum.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    resenum.c

Abstract:

    Win95 hardware resource enumeration routines.

Author:

    Jim Schmidt (jimschm) 28-Jul-1998

Revision History:

    jimschm     28-Sep-1998 Auto DMA added to resource enum
--*/

#include "pch.h"
#include <cfgmgr32.h>


BOOL
pFindDynamicValue (
    IN      PCTSTR DevNode,
    OUT     PTSTR DynamicKey
    );



PBYTE
GetDevNodeResources (
    IN      PCTSTR DevNodeKey
    )
{
    PBYTE Data = NULL;
    TCHAR DynDataKey[MAX_REGISTRY_KEY];
    HKEY Key;

    //
    // Given a dev node, locate the dynamic entry
    //

    if (!pFindDynamicValue (DevNodeKey, DynDataKey)) {
        return NULL;
    }

    //
    // Get resource binary blob from HKEY_DYN_DATA\Config Manager\Enum\*\Allocation.
    //

    Key = OpenRegKeyStr (DynDataKey);

    if (!Key) {
        DEBUGMSG ((DBG_WHOOPS, "Can't open key: %s", DynDataKey));
        return NULL;
    }

    Data = GetRegValueBinary (Key, S_ALLOCATION);

    CloseRegKey (Key);

    return Data;
}


VOID
FreeDevNodeResources (
    IN      PBYTE ResourceData
    )
{
    if (ResourceData) {
        MemFree (g_hHeap, 0, ResourceData);
    }
}


BOOL
pFindDynamicValue (
    IN      PCTSTR DevNode,
    OUT     PTSTR DynamicKey
    )
{
    REGKEY_ENUM e;
    PCTSTR HardwareKey;
    HKEY SubKey;
    BOOL Found = FALSE;
    TCHAR BaseCfgMgrKey[MAX_REGISTRY_KEY];

    StringCopy (BaseCfgMgrKey, TEXT("HKDD\\"));
    StringCat (BaseCfgMgrKey, S_CONFIG_MANAGER);

    if (StringIMatchCharCount (TEXT("HKLM\\Enum\\"), DevNode, 10)) {
        DevNode = CharCountToPointer (DevNode, 10);
    } else if (StringIMatchCharCount (TEXT("HKEY_LOCAL_MACHINE\\Enum\\"), DevNode, 24)) {
        DevNode = CharCountToPointer (DevNode, 24);
    }

    if (EnumFirstRegKeyStr (&e, BaseCfgMgrKey)) {
        do {
            SubKey = OpenRegKey (e.KeyHandle, e.SubKeyName);
            if (!SubKey) {
                DEBUGMSG ((DBG_ERROR, "Can't open subkey %s in HKDD\\Config Manager\\Enum", e.SubKeyName));
                continue;
            }

            HardwareKey = GetRegValueString (SubKey, S_HARDWAREKEY_VALUENAME);
            if (HardwareKey) {
                if (StringIMatch (DevNode, HardwareKey)) {
                    Found = TRUE;
                    AbortRegKeyEnum (&e);

                    StringCopy (DynamicKey, BaseCfgMgrKey);
                    StringCopy (AppendWack (DynamicKey), e.SubKeyName);
                }

                MemFree (g_hHeap, 0, HardwareKey);
            }

            CloseRegKey (SubKey);

        } while (!Found && EnumNextRegKey (&e));
    }

    return Found;
}


BOOL
EnumFirstDevNodeResourceEx (
    OUT     PDEVNODERESOURCE_ENUM EnumPtr,
    IN      PBYTE DevNodeResources
    )
{
    ZeroMemory (EnumPtr, sizeof (DEVNODERESOURCE_ENUM));
    EnumPtr->Resources = DevNodeResources;

    if (!DevNodeResources) {
        return FALSE;
    }

    if (*((PDWORD) EnumPtr->Resources) != 0x0400) {
        DEBUGMSG ((DBG_ERROR, "Enumeration of dev node resources, cfg mgr != v4"));
        return FALSE;
    }

    EnumPtr->NextResource = DevNodeResources + sizeof (DWORD) * 2;
    return EnumNextDevNodeResourceEx (EnumPtr);
}


BOOL
EnumNextDevNodeResourceEx (
    IN OUT  PDEVNODERESOURCE_ENUM EnumPtr
    )
{
    DWORD Len;

    Len =  *((PDWORD) EnumPtr->NextResource);

    if (!Len) {
        return FALSE;
    }

    EnumPtr->Resource = EnumPtr->NextResource;
    EnumPtr->ResourceData = EnumPtr->Resource + sizeof (DWORD) * 2;
    EnumPtr->Type = *((PDWORD) (EnumPtr->Resource + sizeof (DWORD)));

    EnumPtr->NextResource += Len;
    return TRUE;
}


BOOL
EnumFirstDevNodeResource (
    OUT     PDEVNODERESOURCE_ENUM EnumPtr,
    IN      PCTSTR DevNode
    )
{
    if (!EnumFirstDevNodeResourceEx (
            EnumPtr,
            GetDevNodeResources (DevNode)
            )) {
        FreeDevNodeResources (EnumPtr->Resources);
        return FALSE;
    }

    return TRUE;
}


BOOL
EnumNextDevNodeResource (
    IN OUT  PDEVNODERESOURCE_ENUM EnumPtr
    )
{
    if (!EnumNextDevNodeResourceEx (EnumPtr)) {
        FreeDevNodeResources (EnumPtr->Resources);
        return FALSE;
    }

    return TRUE;
}


BOOL
pIsDisplayableType (
    IN      PDEVNODESTRING_ENUM EnumPtr
    )
{
    BOOL b = TRUE;

    switch (EnumPtr->Enum.Type) {
    case ResType_Mem:
        break;

    case ResType_IO:
        break;

    case ResType_DMA:
        break;

    case ResType_IRQ:
        break;

    default:
        b = FALSE;
        break;
    }

    return b;
}


VOID
pFormatMemoryResource (
    IN OUT  PDEVNODESTRING_ENUM EnumPtr
    )
{
    PMEM_RESOURCE_9X MemRes;

    MemRes = (PMEM_RESOURCE_9X) EnumPtr->Enum.ResourceData;

    wsprintf (
        EnumPtr->Value,
        TEXT("%08X - %08X"),
        MemRes->MEM_Header.MD_Alloc_Base,
        MemRes->MEM_Header.MD_Alloc_End
        );
}


VOID
pFormatIoResource (
    IN OUT  PDEVNODESTRING_ENUM EnumPtr
    )
{
    PIO_RESOURCE_9X IoRes;

    IoRes = (PIO_RESOURCE_9X) EnumPtr->Enum.ResourceData;

    wsprintf (
        EnumPtr->Value,
        TEXT("%04X - %04X"),
        IoRes->IO_Header.IOD_Alloc_Base,
        IoRes->IO_Header.IOD_Alloc_End
        );
}


VOID
pAddChannel (
    IN OUT  PTSTR String,
    IN      UINT Channel
    )
{
    if (String[0]) {
        StringCat (String, TEXT(" "));
    }
    wsprintf (
        GetEndOfString (String),
        TEXT("%02X"),
        Channel
        );
}


VOID
pFormatDmaResource (
    IN OUT  PDEVNODESTRING_ENUM EnumPtr
    )
{
    PDMA_RESOURCE_9X DmaRes;
    DWORD Bit, Channel;
    PCTSTR ResText;

    DmaRes = (PDMA_RESOURCE_9X) EnumPtr->Enum.ResourceData;

    EnumPtr->Value[0] = 0;
    Channel = 0;

    for (Bit = 1 ; Bit ; Bit <<= 1) {
        if (DmaRes->DMA_Bits & Bit) {
            pAddChannel (EnumPtr->Value, Channel);
        }

        Channel++;
    }

    if (EnumPtr->Value[0] == 0) {
        ResText = GetStringResource (MSG_AUTO_DMA);
        if (ResText) { // otherwise... do nothing, I guess, since this function
	               // doesn't return a status value right now.
            StringCopy (EnumPtr->Value, ResText);
            FreeStringResource (ResText);
        }
    }
}


VOID
pFormatIrqResource (
    IN OUT  PDEVNODESTRING_ENUM EnumPtr
    )
{
    PIRQ_RESOURCE_9X IrqRes;

    IrqRes = (PIRQ_RESOURCE_9X) EnumPtr->Enum.ResourceData;

    wsprintf (
        EnumPtr->Value,
        TEXT("%02X"),
        IrqRes->AllocNum
        );
}


BOOL
pEnumDevNodeStringWorker (
    IN OUT PDEVNODESTRING_ENUM EnumPtr
    )
{
    UINT Id = 0;
    PCTSTR Name;

    //
    // Format each type of resource for display
    //

    switch (EnumPtr->Enum.Type) {

    case ResType_Mem:
        Id = MSG_RESTYPE_MEMORY;
        pFormatMemoryResource (EnumPtr);
        break;

    case ResType_IO:
        Id = MSG_RESTYPE_IO;
        pFormatIoResource (EnumPtr);
        break;

    case ResType_DMA:
        Id = MSG_RESTYPE_DMA;
        pFormatDmaResource (EnumPtr);
        break;

    case ResType_IRQ:
        Id = MSG_RESTYPE_IRQ;
        pFormatIrqResource (EnumPtr);
        break;

    }

    if (Id) {
        Name = GetStringResource (Id);

        if (Name) {
            StringCopy (
                EnumPtr->ResourceName,
                Name
                );

            FreeStringResource (Name);
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
EnumFirstDevNodeString (
    OUT     PDEVNODESTRING_ENUM EnumPtr,
    IN      PCTSTR DevNodeKeyStr
    )
{
    if (!EnumFirstDevNodeResource (&EnumPtr->Enum, DevNodeKeyStr)) {
        return FALSE;
    }

    if (pIsDisplayableType (EnumPtr)) {
        return pEnumDevNodeStringWorker (EnumPtr);
    }

    return EnumNextDevNodeString (EnumPtr);
}


BOOL
EnumNextDevNodeString (
    IN OUT  PDEVNODESTRING_ENUM EnumPtr
    )
{
    do {
        if (!EnumNextDevNodeResource (&EnumPtr->Enum)) {
            return FALSE;
        }
    } while (!pIsDisplayableType (EnumPtr));

    return pEnumDevNodeStringWorker (EnumPtr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\init9x\init9xp.h ===
extern READ_DISK_SECTORS_PROC ReadDiskSectors;


#define FAT_BOOT_SECTOR_SIZE 512
#define FAT_BOOT_SECTOR_COUNT 1
#define FAT_STARTING_SECTOR 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\init9x\init9x.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

  init9x.c

Abstract:

  Code that initializes all libraries used on the Win9x side of the upgrade.

Author:

  Jim Schmidt (jimschm) 30-Dec-1997

Revision History:

  marcw                 21-Jul-1999  Examine the boot sector.
  marcw                 15-Jul-1999  Added pSafeToUpgrade.
  ovidiut               08-Mar-1999  Add call to UndoChangedFileProps
  Jim Schmidt (jimschm) 30-Mar-1998  IsServerInstall

--*/

#include "pch.h"
#include "n98boot.h"
#include "init9xp.h"



//
// Process globals
//

BOOL g_Terminated = FALSE;

HANDLE g_hHeap = NULL;
HINSTANCE g_hInst = NULL;
HWND g_ParentWnd = NULL;

PRODUCTTYPE *g_ProductType;
extern DWORD g_MasterSequencer;

READ_DISK_SECTORS_PROC ReadDiskSectors;
//
// Paths
//

// Filled in DllMain
TCHAR g_DllDir[MAX_TCHAR_PATH];
TCHAR g_UpgradeSources[MAX_TCHAR_PATH];

// Filled in Winnt32PlugInInit
PTSTR g_TempDir;
PTSTR g_Win9xSifDir;
PTSTR g_TempDirWack;
PTSTR g_WinDir;
PTSTR g_WinDirWack;
PTSTR g_WinDrive;
PTSTR g_PlugInDir;
PTSTR g_PlugInDirWack;
PTSTR g_PlugInTempDir;
PTSTR g_SystemDir;
PTSTR g_SystemDirWack;
PTSTR g_System32Dir;
PTSTR g_System32DirWack;
PTSTR g_ProgramFilesDir;
PTSTR g_ProgramFilesDirWack;
PTSTR g_ProgramFilesCommonDir;
PTSTR g_Win95UpgInfFile;
PTSTR g_RecycledDirWack;
PTSTR g_ProfileDirNt;
PTSTR g_ProfileDir;
PTSTR g_ProfileDirWack;
PTSTR g_CommonProfileDir;
PTSTR g_DriversDir;
PTSTR g_InfDir;
PTSTR g_HelpDir;
PTSTR g_HelpDirWack;
PTSTR g_CatRootDir;
PTSTR g_CatRootDirWack;
PTSTR g_FontsDir;
PTSTR g_ViewersDir;
PTSTR g_ColorDir;
PTSTR g_SharedDir;
PTSTR g_SpoolDir;
PTSTR g_SpoolDriversDir;
PTSTR g_PrintProcDir;

HINF  g_Win95UpgInf = INVALID_HANDLE_VALUE;
HINF  g_TxtSetupSif = INVALID_HANDLE_VALUE;
PCTSTR g_ProfileName = NULL;
TCHAR g_Win95Name[MAX_TCHAR_PATH];

INT g_TempDirWackChars;
INT g_WinDirWackChars;
INT g_HelpDirWackChars;
INT g_CatRootDirWackChars;
INT g_SystemDirWackChars;
INT g_System32DirWackChars;
INT g_ProgramFilesDirWackChars;
INT g_PlugInDirWackChars;
INT g_RecycledDirWackChars;
INT g_ProfileDirWackChars;

BOOL g_ToolMode = FALSE;

//
// HWND for use by migrate.dlls.
//

HWND g_pluginHwnd;

//
// Info from WINNT32
//

PCTSTR      g_SourceDirectories[MAX_SOURCE_COUNT];
DWORD       g_SourceDirectoryCount;
PCTSTR *    g_SourceDirectoriesFromWinnt32;
PDWORD      g_SourceDirectoryCountFromWinnt32;
PCTSTR      g_OptionalDirectories[MAX_SOURCE_COUNT];
DWORD       g_OptionalDirectoryCount;
PCTSTR *    g_OptionalDirectoriesFromWinnt32;
PDWORD      g_OptionalDirectoryCountFromWinnt32;
PCTSTR *    g_UnattendScriptFile;
PCTSTR *    g_CmdLineOptions;
BOOL *      g_UnattendedFlagPtr;
BOOL *      g_CancelFlagPtr;
BOOL *      g_AbortFlagPtr;
BOOL *      g_UpgradeFlagPtr;
BOOL *      g_MakeLocalSourcePtr;
BOOL *      g_CdRomInstallPtr;
BOOL *      g_BlockOnNotEnoughSpace;
PDWORD      g_LocalSourceDrive;
PLONGLONG   g_LocalSourceSpace;
PLONGLONG   g_WinDirSpace;
PCTSTR      g_AdministratorStr;
BOOL *      g_ForceNTFSConversion;
PUINT       g_RamNeeded;
PUINT       g_RamAvailable;
UINT *      g_ProductFlavor;
BOOL        g_PersonalSKU;
PDWORD      g_SetupFlags;
PTSTR       g_DynamicUpdateLocalDir;
PTSTR       g_DynamicUpdateDrivers;
BOOL *      g_UnattendSwitchSpecified;


//
// Info for config.c
//

BOOL        g_GoodDrive = FALSE;     // cmdLine option: Skip Valid HDD check.
BOOL        g_NoFear    = FALSE;     // cmdLine option: Skip Beta 1 Warnings...

POOLHANDLE  g_UserOptionPool = NULL;

BOOL        g_UseSystemFont = FALSE; // force use of sys font for variable text

BOOL        g_Stress;                // used for private stress options

POOLHANDLE g_GlobalPool;            // for globals that are allocated for the lifetime of the DLL

//
// PC-98 additions
//

//
// Define and Globals for NEC98. These items are used to call 98ptn32.dll.
//
typedef int (CALLBACK WIN95_PLUGIN_98PTN32_GETBOOTDRIVE_PROTOTYPE)(void);
typedef WIN95_PLUGIN_98PTN32_GETBOOTDRIVE_PROTOTYPE * PWIN95_PLUGIN_98PTN32_GETBOOTDRIVE;
typedef BOOL (CALLBACK WIN95_PLUGIN_98PTN32_SETBOOTFLAG_PROTOTYPE)(int, WORD);
typedef WIN95_PLUGIN_98PTN32_SETBOOTFLAG_PROTOTYPE * PWIN95_PLUGIN_98PTN32_SETBOOTFLAG;
typedef BOOL (CALLBACK WIN95_PLUGIN_98PTN32_SETPTNNAME_PROTOTYPE)(int, WORD);
typedef WIN95_PLUGIN_98PTN32_SETPTNNAME_PROTOTYPE * PWIN95_PLUGIN_98PTN32_SETPTNNAME;

PWIN95_PLUGIN_98PTN32_SETBOOTFLAG   SetBootFlag;
PWIN95_PLUGIN_98PTN32_GETBOOTDRIVE  GetBootDrive;
PWIN95_PLUGIN_98PTN32_SETPTNNAME    SetPtnName;

#define WIN95_98PTN32_GETBOOTDRIVE  TEXT("GetBootDriveLetter32")
#define WIN95_98PTN32_SETBOOTFLAG   TEXT("SetBootable95ptn32")
#define WIN95_98PTN32_SETPTNNAME    TEXT("SetPartitionName32")
#define PC98_DLL_NAME               TEXT("98PTN32.DLL")

HINSTANCE g_Pc98ModuleHandle = NULL;

#define SB_BOOTABLE   0x0001
#define SB_UNBOOTABLE 0x0002
#define MSK_BOOTABLE  0x000f
#define SB_AUTO       0x0010
#define MSK_AUTO      0x00f0
#define WIN9X_DOS_NAME 0
#define WINNT5_NAME    1

BOOL IsServerInstall (VOID);


VOID pCleanUpShellFolderTemp (VOID);

//
// The following macro expansion was designed to simplify library
// maintenence.  The library name in LIBLIST is used in two ways:
// (1) the routine is automatically prototyped, and (2) an array
// of function pointers is automatically created.  Each function
// listed in LIBLIST is called whenever the dll entry point is called.
//
// To add a new library to this DLL, follow these steps:
//
//  1. Make a directory and have the target built in win95upg\lib\i386.
//     Your new library must have an entry point declared like DllEntryPoint.
//  2. Add the target library to the sources in win95upg\w95upg\dll\i386.
//  3. Add your library's entry point name to the list below.  It will
//     get called at load of w95upg.dll and at termination of w95upg.dll.
//


//
// IMPORTANT: MigUtil_Entry *must* be first; other libs are dependent on its
//            initialization.
//

#define LIBLIST                       \
    LIBRARY_NAME(MigUtil_Entry)       \
    LIBRARY_NAME(Win95Reg_Entry)      \
    LIBRARY_NAME(MemDb_Entry)         \
    LIBRARY_NAME(FileEnum_Entry)      \
    LIBRARY_NAME(Common9x_Entry)      \
    LIBRARY_NAME(MigApp_Entry)        \
    LIBRARY_NAME(HwComp_Entry)        \
    LIBRARY_NAME(BuildInf_Entry)      \
    LIBRARY_NAME(SysMig_Entry)        \
    LIBRARY_NAME(DosMig_Entry)        \
    LIBRARY_NAME(UI_Entry)            \
    LIBRARY_NAME(Ras_Entry)           \
    LIBRARY_NAME(MigDll9x_Entry)      \


//
// Declare prototype types
//

typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);
typedef INITROUTINE_PROTOTYPE * INITROUTINE;

//
// Declare the actual prototypes of the entry points
//

#define LIBRARY_NAME(x) INITROUTINE_PROTOTYPE x;

LIBLIST

#undef LIBRARY_NAME

//
// Declare an array of function pointers to the entry pointes
//

#define LIBRARY_NAME(x) x,

static INITROUTINE g_InitRoutine[] = {LIBLIST /*,*/ NULL};

#undef LIBRARY_NAME



//
// Declare variable to track number of libraries successfully loaded
//

static int g_LibCount = 0;

//
// Persistent strings buffer holds strings that we use for the
// life of the DLL.
//

static PGROWBUFFER g_PersistentStrings;


//
// Implementation
//

BOOL
FirstInitRoutine (
    HINSTANCE hInstance
    )

/*++

Routine Description:

  pFirstInitRoutine is the very first function called during the
  initialization of the DLL.  It sets up globals such as the heap
  pointer and instance handle.  This routine must be called before
  any library entry point is called.

Arguments:

  hInstance  - (OS-supplied) instance handle for the DLL

Return Value:

  Returns TRUE if the global variables could be initialized, or FALSE
  if an error occurred.

--*/

{
    PTSTR p;

    //
    // Get the process heap & instance handle
    //
    if (g_ToolMode) {
        g_hHeap = GetProcessHeap ();
    }
    else {

        g_hHeap = HeapCreate(0, 0x20000, 0);
        if (!g_hHeap) {
            LOG ((LOG_ERROR, "Cannot create a private heap."));
            g_hHeap = GetProcessHeap();
        }
    }

    g_hInst = hInstance;

    //
    // No DLL_THREAD_ATTACH or DLL_THREAD_DETECH needed
    //

    DisableThreadLibraryCalls (hInstance);

    //
    // Init common controls
    //

    InitCommonControls();

    //
    // Get DLL path and strip directory
    //
    GetModuleFileName (hInstance, g_DllDir, MAX_TCHAR_PATH);
    p = _tcsrchr (g_DllDir, TEXT('\\'));
    MYASSERT (p);
    *p = 0;


    if (g_ToolMode) {
        StringCopy (g_UpgradeSources, g_DllDir);
    }



    return TRUE;
}


BOOL
InitLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved
    )

/*++

Routine Description:

  pInitLibs calls all library entry points in the g_InitRoutine array.
  If an entry point fails, all libraries are unloaded in reverse order
  and pInitLibs returns FALSE.

Arguments:

  hInstance  - (OS-supplied) instance handle for the DLL
  dwReason   - (OS-supplied) indicates attach or detatch from process or
               thread -- in this case always DLL_PROCESS_ATTACH
  lpReserved - (OS-supplied) unused

Return Value:

  Returns TRUE if all libraries successfully initialized, or FALSE if
  a library could not initialize.  If TRUE is returned, pTerminateLibs
  must be called for the DLL_PROCESS_DETACH message.

--*/

{
    InitCommonControls();
    if(!pSetupInitializeUtils()) {
        return FALSE;
    }

    SET_RESETLOG();

    // Init each LIB
    for (g_LibCount = 0 ; g_InitRoutine[g_LibCount] != NULL ; g_LibCount++) {
        if (!g_InitRoutine[g_LibCount] (hInstance, dwReason, lpReserved)) {
            TerminateLibs (hInstance, DLL_PROCESS_DETACH, lpReserved);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
FinalInitRoutine (
    VOID
    )

/*++

Routine Description:

  pFinalInitRoutine completes all initialization that requires completely
  initialized libraries.

Arguments:

  none

Return Value:

  TRUE if initialization completed successfully, or FALSE if an error occurred.

--*/

{
    TCHAR Buffer[MAX_TCHAR_PATH];
    PTSTR p;

    //
    // Load common message strings
    //

    g_PersistentStrings = CreateAllocTable();
    if (!g_PersistentStrings) {
        return FALSE;
    }

    // Get Administrator account name
    g_AdministratorStr = GetStringResourceEx (g_PersistentStrings, MSG_ADMINISTRATOR_ACCOUNT);
    if (!g_AdministratorStr) {
        g_AdministratorStr = S_EMPTY;
    }

    //
    // Obtain PC-98 helper routine addresses
    //

    if(ISPC98()){
        //
        // Generate directory of WINNT32
        //
        StringCopy (Buffer, g_UpgradeSources);
        p = _tcsrchr (Buffer, TEXT('\\'));
        MYASSERT (p);
        StringCopy (_tcsinc(p), PC98_DLL_NAME);

        //
        // Load library
        //

        g_Pc98ModuleHandle = LoadLibraryEx(
                                Buffer,
                                NULL,
                                LOAD_WITH_ALTERED_SEARCH_PATH
                                );

        if(!g_Pc98ModuleHandle){
            LOG ((LOG_ERROR, "Cannot load %s", Buffer));
            return FALSE;
        }

        //
        // Get entry points
        //

        (FARPROC)SetBootFlag = GetProcAddress (g_Pc98ModuleHandle, WIN95_98PTN32_SETBOOTFLAG);
        if(!SetBootFlag){
            LOG ((LOG_ERROR, "Cannot get %s address from %s", WIN95_98PTN32_SETBOOTFLAG, Buffer));
            return FALSE;
        }

        (FARPROC)GetBootDrive = GetProcAddress (g_Pc98ModuleHandle, WIN95_98PTN32_GETBOOTDRIVE);
        if(!GetBootDrive){
            LOG ((LOG_ERROR, "Cannot get %s address from %s", WIN95_98PTN32_GETBOOTDRIVE, Buffer));
            return FALSE;
        }

        (FARPROC)SetPtnName = GetProcAddress (g_Pc98ModuleHandle, WIN95_98PTN32_SETPTNNAME);
        if(!SetPtnName){
            LOG ((LOG_ERROR, "Cannot get %s address from %s", WIN95_98PTN32_SETPTNNAME, Buffer));
            return FALSE;
        }

        //
        // Update boot drive
        //

        DEBUGMSG_IF ((
            GetBootDrive() != g_BootDriveLetterA,
            DBG_VERBOSE,
            "Boot drive letter is %c:, different from A:",
            GetBootDrive()
            ));

        g_BootDriveLetterW = g_BootDriveLetterA = (char)GetBootDrive();
        *((PSTR) g_BootDrivePathA) = g_BootDriveLetterA;
        *((PWSTR) g_BootDrivePathW) = g_BootDriveLetterW;
    }

    //
    // Allocate a global pool
    //

    g_GlobalPool = PoolMemInitNamedPool ("Global Pool");

    //
    // Declare temporary memdb keys
    //

#ifndef PRERELEASE
    if (!MemDbCreateTemporaryKey (MEMDB_TMP_HIVE)) {
        LOG((LOG_ERROR, TEXT("Cannot create temporary key!")));
    }
#endif

    pCleanUpShellFolderTemp();

    return TRUE;
}


VOID
pCleanUpShellFolderTemp (
    VOID
    )
{
    DRIVELETTERS driveLetters;
    UINT u;
    TCHAR dir1[] = S_SHELL_TEMP_NORMAL_PATH;
    TCHAR dir2[] = S_SHELL_TEMP_LONG_PATH;

    InitializeDriveLetterStructure (&driveLetters);

    for (u = 0 ; u < NUMDRIVELETTERS ; u++) {
        if (driveLetters.Type[u] == DRIVE_FIXED) {
            dir1[0] = driveLetters.Letter[u];
            dir2[0] = driveLetters.Letter[u];

            RemoveCompleteDirectory (dir1);
            RemoveCompleteDirectory (dir2);
        }
    }
}


VOID
FirstCleanupRoutine (
    VOID
    )

/*++

Routine Description:

  pFirstCleanupRoutine is called to perform any cleanup that requires
  libraries to still be loaded.

Arguments:

  none

Return Value:

  none

--*/

{

    g_Terminated = TRUE;

    //
    // Clean up drive structures
    //

    CleanUpAccessibleDrives();

    //
    // Clean up our fake NT environment block
    //

    TerminateNtEnvironment();
    CleanUp9xEnvironmentVariables();

    //
    // Free standard pools
    //

    if (g_GlobalPool) {
        PoolMemDestroyPool (g_GlobalPool);
        g_GlobalPool = NULL;
    }

    if (g_PersistentStrings) {
        DestroyAllocTable (g_PersistentStrings);
        g_PersistentStrings = NULL;
    }

    if (g_UserOptionPool) {
        PoolMemDestroyPool(g_UserOptionPool);
        g_UserOptionPool = NULL;
    }

    //
    // Close all files
    //

    CleanUpKnownGoodIconMap();

    if (g_Win95UpgInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_Win95UpgInf);
        g_Win95UpgInf = INVALID_HANDLE_VALUE;
    }

    if (g_TxtSetupSif != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_TxtSetupSif);
        g_TxtSetupSif = INVALID_HANDLE_VALUE;
    }

    CleanupMigDb();
}


VOID
TerminateLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )

/*++

Routine Description:

  TerminateLibs is called to unload all libraries in the reverse order
  that they were initialized.  Each entry point of successfully
  initialized library is called.

Arguments:

  hInstance  - (OS-supplied) instance handle for the DLL
  dwReason   - (OS-supplied) indicates attach or detatch from process or
               thread -- in this case always DLL_PROCESS_DETACH
  lpReserved - (OS-supplied) unused

Return Value:

  none

--*/

{
    INT i;

    for (i = g_LibCount - 1 ; i >= 0 ; i--) {
        g_InitRoutine[i] (hInstance, dwReason, lpReserved);
    }

    g_LibCount = 0;

    pSetupUninitializeUtils();
}


VOID
FinalCleanupRoutine (
    VOID
    )

/*++

Routine Description:

  FinalCleanupRoutine is after all library entry points have been
  called for cleanup.  This routine cleans up all resources that a
  library will not clean up.

Arguments:

  none

Return Value:

  none

--*/

{
}




BOOL
pSafeToUpgrade (
    VOID
    )

/*++

Routine Description:

  pSafeToUpgrade ensures that we are willing to upgrade the machine. If
  certain conditions exist (particularily other OSes on other partitions) we
  may inadvertantly destroy data used by the other Operating System.

Arguments:

  None.

Return Value:

  TRUE if we believe it is safe to upgrade the machine, FALSE otherwise.

--*/


{
    BOOL rUpgradeSafe = TRUE;

    //
    // ignore this check for now, allow machines that have multiple OSes installed to be upgraded
    // if they have another OS on the SAME drive, setup will stop at the report,
    // after disk analyze phase
    //

#if 0

    PTSTR p;
    GROWBUFFER buf = GROWBUF_INIT;
    UINT size;
    MULTISZ_ENUM e;
    TCHAR winDriveMatch[20];
    PCTSTR group;
    PCTSTR message;
    BOOL ntBootSector = FALSE;
    BYTE bootSector[FAT_BOOT_SECTOR_SIZE];
    TCHAR cmpBuffer[6];
    UINT i;

    //
    // Look to see if there is an NT boot sector on the machine.
    //
    __try {

        if (ReadDiskSectors (
                *g_BootDrive,
                FAT_STARTING_SECTOR,
                FAT_BOOT_SECTOR_COUNT,
                FAT_BOOT_SECTOR_SIZE,
                bootSector
                )) {


            cmpBuffer[5] = 0;
            for (i = 0;i < FAT_BOOT_SECTOR_SIZE - 4; i++) {

                if (bootSector[i] == 'n' || bootSector[i] == 'N') {

                    StringCopyByteCount (cmpBuffer, (PTSTR) (bootSector + i), 6);
                    if (StringIMatch (cmpBuffer, TEXT("ntldr"))) {

                        ntBootSector = TRUE;
                        break;
                    }
                }
            }
        }
    }
    __except (1) {

        ntBootSector = FALSE;
    }

    if (ntBootSector) {

        //
        // See if there is another OS listed in BOOT.ini.
        //
        p = JoinPaths (g_BootDrive, S_BOOTINI);

        size = 4096;
        GrowBuffer (&buf, size);
        *buf.Buf = 0;

        while (GetPrivateProfileSection (S_OPERATING_SYSTEMS, buf.Buf, 4096, p) == size -2) {
            size += 4096;
            GrowBuffer (&buf, size);
        }

        FreePathString (p);

        if (EnumFirstMultiSz (&e, buf.Buf)) {

            wsprintf (winDriveMatch, TEXT("%s\\"), g_WinDrive);

            do {

                p = (PTSTR) _tcschr (e.CurrentString, TEXT('='));
                if (p) {
                    *p = 0;
                }

                if (!StringIMatchCharCount(winDriveMatch, e.CurrentString, 3)) {

                    if (!g_ConfigOptions.IgnoreOtherOS) {

                        g_OtherOsExists = TRUE;
                        group = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_OTHER_OS_WARNING_SUBGROUP, NULL);
                        message = GetStringResource (MSG_OTHER_OS_WARNING);

                        if (message && group) {
                            MsgMgr_ObjectMsg_Add (TEXT("*BootIniFound"), group, message);
                        }
                        FreeText (group);
                        FreeStringResource (message);


                        rUpgradeSafe = FALSE;

                        //
                        // Let the user know why they won't be upgrading today.
                        //
                        break;
                    }

                }

                if (p) {

                    *p = TEXT('=');
                }

            } while (EnumNextMultiSz (&e));
        }

        FreeGrowBuffer (&buf);

    }

#endif

    return rUpgradeSafe;


}

BOOL
pGetInfEntry (
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    OUT     PTSTR  Buffer
    )

/*++

Routine Description:

  Given a section and key, pGetInfEntry gets a value from win95upg.inf.

Arguments:

  Section - Specifies the section contianing Key

  Key - Specifies the key containing a value

  Buffer - Receives the value specified in win95upg.inf for Section and Key

Return Value:

  TRUE if a value was obtained, or FALSE if the value does not exist.

--*/

{
    GetPrivateProfileString (
        Section,
        Key,
        S_EMPTY,
        Buffer,
        MAX_TCHAR_PATH,
        g_Win95UpgInfFile
        );

    Buffer[MAX_TCHAR_PATH-1] = 0;

    if (!(*Buffer)) {
        LOG ((
            LOG_ERROR,
            "Cannot obtain %s in [%s] in %s.",
            Key,
            Section,
            g_Win95UpgInfFile
            ));

        return FALSE;
    }

    return TRUE;
}


PTSTR
pCreateDirectoryFromInf (
    IN      PCTSTR Key,
    IN      PCTSTR BaseDir,
    IN      BOOL Empty
    )

/*++

Routine Description:

  pCreateDirectoryFromInf obtains a directory for the sequencer specified
  by Key.  If Key is valid, the BaseDir is combined with the value stored
  in win95upg.inf to form a complete path.  The path is created and the
  path string is returned to the caller.

  If g_ToolMode is TRUE, then we don't have an INF to read, and we make
  all the directories point to the name "Setup."

Arguments:

  Key - Specifies the key (normally a number) that exists in the [Win95.Directories]
        section of win95upg.inf.

  BaseDir - Specifies the base directory to build the path from.

  Empty - TRUE if directory should be emptied, FALSE if it should be created
          if it does not already exist

Return Value:

  A pointer to the path, or NULL if the specified key doesn't exist or the
  path could not be created.

  The caller must free a non-NULL return value with FreePathString.

--*/

{
    TCHAR FileName[MAX_TCHAR_PATH];
    PTSTR Buffer;
    BOOL b;
    LONG rc;

    if (g_ToolMode) {
        StringCopy (FileName, TEXT("Setup"));
    } else if (!pGetInfEntry (
                SECTION_MIGRATION_DIRECTORIES,
                Key,
                FileName
                )) {
        LOG ((LOG_ERROR, "%s does not exist in [%s] of %s",Key, SECTION_MIGRATION_DIRECTORIES, FileName));
        return FALSE;
    }

    Buffer = JoinPathsEx (g_GlobalPool, BaseDir, FileName);

    if (Empty) {
        b = CreateEmptyDirectory (Buffer);
    } else {
        b = MakeSurePathExists (Buffer, TRUE) == ERROR_SUCCESS;
    }

    if (!b) {
        rc = GetLastError();

        if (rc != ERROR_SUCCESS && rc != ERROR_ALREADY_EXISTS) {
            LOG ((LOG_ERROR, "Cannot create %s", Buffer));
            FreePathStringEx (g_GlobalPool, Buffer);
            return NULL;
        }
    }

    return Buffer;
}


BOOL
pGetProductFlavor (
    VOID
    )
{
    DWORD i;
    TCHAR buf[12];
    PTSTR path;
    DWORD count;
    DWORD rc = ERROR_INVALID_PARAMETER; // when *g_SourceDirectoryCountFromWinnt32 == 0
    BOOL b = FALSE;

    for (i = 0; i < *g_SourceDirectoryCountFromWinnt32; i++) {
        path = JoinPaths (g_SourceDirectoriesFromWinnt32[i], TEXT("dosnet.inf"));
        count = GetPrivateProfileString (
                    TEXT("Miscellaneous"),
                    S_PRODUCTTYPE,
                    TEXT(""),
                    buf,
                    12,
                    path
                    );
        rc = GetLastError ();
        FreePathString (path);

        if (count == 1 && buf[0] >= TEXT('0') && buf[0] <= TEXT('9')) {
            *g_ProductFlavor = buf[0] - TEXT('0');
            b = TRUE;
            break;
        }
    }

    if (!b && g_ToolMode) {
        b = TRUE;
    }

    SetLastError (rc);
    return b;
}


//
// Exported functions called from WINNT32
//

DWORD
Winnt32Init (
    IN PWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK Info
    )


/*++

Routine Description:

  Winnt32Init is called when WINNT32 first loads w95upg.dll, before
  any wizard pages are displayed.  The structure supplies pointers to
  WINNT32's variables that will be filled with valid values as WINNT32
  runs.

  This routine copies the inbound values to our own private structures.
  We do not count on WINNT32 to maintain the Info structure after we
  return.

  In addition to obtaining the WINNT32 variable pointers, this routine
  generates all paths needed by the w95upg.dll to do its work.

Arguments:

  Win9xInfo - Specifies the WINNT32 variables the upgrade module needs access
            to.

Return Value:

  A Win32 status code indicating outcome.

--*/


{
    DWORD rc = ERROR_SUCCESS;
    PCTSTR TempStr = NULL;
    PCTSTR RegStr = NULL;
    PTSTR TempStr2;
    TCHAR TempPath[MAX_TCHAR_PATH];
    HKEY Key;
    PCTSTR RegData;
    HKEY h;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    UINT index;
    UINT index2;
#if 0
    PDWORD data;
#endif


    DEBUGMSG ((
        DBG_VERBOSE,
        "ProductType: %u\n"
        "BuildNumber: %u\n"
        "ProductVersion: %u\n"
        "Debug: %u\n"
        "PreRelease: %u\n"
        "UpdatesLocalDir: %s\n",
        *Info->BaseInfo->ProductType,
        Info->BaseInfo->BuildNumber,
        Info->BaseInfo->ProductVersion,
        Info->BaseInfo->Debug,
        Info->BaseInfo->PreRelease,
        Info->DynamicUpdateLocalDir ? Info->DynamicUpdateLocalDir : TEXT("<none>")
        ));

    __try {
        //
        // Open win95upg.inf in i386\winnt32\win9x
        //
        g_Win95UpgInfFile = JoinPathsEx (g_GlobalPool, g_UpgradeSources, STR_WIN95UPG_INF);

        g_Win95UpgInf = InfOpenInfFile (g_Win95UpgInfFile);

        if (g_Win95UpgInf == INVALID_HANDLE_VALUE) {

            if (!g_ToolMode) {
                LOG ((LOG_ERROR, "Cannot open %s", g_Win95UpgInfFile));
                rc = ERROR_FILE_NOT_FOUND;
                __leave;
            }
        }

        InitializeKnownGoodIconMap();
        MsgMgr_InitStringMap ();

        //
        // Get name of platform
        //

        if (ISWIN95_GOLDEN()) {
            TempStr = GetStringResource (MSG_CHICAGO);
        } else if (ISWIN95_OSR2()) {
            TempStr = GetStringResource (MSG_NASHVILLE);
        } else if (ISMEMPHIS()) {
            TempStr = GetStringResource (MSG_MEMPHIS);
        } else if (ISMILLENNIUM()) {
            TempStr = GetStringResource (MSG_MILLENNIUM);
        } else {
            //
            // We don't know what this is. We'll check the registry. If there isn't a name there, we'll
            // use an 'unknown' case name.
            //
            h = OpenRegKeyStr (TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion"));
            if (h && h != INVALID_HANDLE_VALUE) {
                RegStr = GetRegValueString (h, TEXT("ProductName"));
                CloseRegKey (h);

            }

            if (!RegStr) {
                TempStr = GetStringResource (MSG_UNKOWN_WINDOWS);
            }
        }

        if (!TempStr && !RegStr) {
            rc = GetLastError();
            __leave;
        }

        StringCopy (g_Win95Name, TempStr ? TempStr : RegStr);
        if (TempStr) {
            FreeStringResource (TempStr);
        }
        if (RegStr) {
            MemFree (g_hHeap, 0, RegStr);
        }


        MemDbSetValueEx (
            MEMDB_CATEGORY_STATE,
            MEMDB_ITEM_PLATFORM_NAME,
            g_Win95Name,
            NULL,
            0,
            NULL
            );

        //
        // Get %WinDir%, with and without wack
        //
        if (!GetWindowsDirectory (TempPath, MAX_TCHAR_PATH)) {
            return GetLastError ();
        }
        g_WinDir = PoolMemDuplicateString (g_GlobalPool, TempPath);

        g_WinDirWack      = JoinPathsEx (g_GlobalPool, g_WinDir, S_EMPTY);
        g_WinDirWackChars = CharCount (g_WinDirWack);

        g_InfDir           = JoinPaths (g_WinDir,        S_INFDIR);
        g_HelpDir          = JoinPaths (g_WinDir,        S_HELPDIR);
        g_HelpDirWack      = JoinPaths (g_HelpDir,       S_EMPTY);
        g_HelpDirWackChars = CharCount (g_HelpDirWack);
        g_CatRootDir       = JoinPaths (g_WinDir,        S_CATROOTDIR);
        g_CatRootDirWack   = JoinPaths (g_CatRootDir,    S_EMPTY);
        g_CatRootDirWackChars = CharCount (g_CatRootDirWack);
        g_FontsDir         = JoinPaths (g_WinDir,        S_FONTSDIR);
        g_SharedDir        = g_WinDir;

        //
        // Get Windows drive
        //

        SplitPath (g_WinDir, &TempStr2, NULL, NULL, NULL);
        g_WinDrive = PoolMemDuplicateString (g_GlobalPool, TempStr2);
        FreePathString (TempStr2);

        //
        // Get user profile dir
        //

        g_ProfileDir          = JoinPathsEx (g_GlobalPool, g_WinDir, S_PROFILES);
        g_ProfileDirWack      = JoinPathsEx (g_GlobalPool, g_ProfileDir, S_EMPTY);
        g_ProfileDirWackChars = CharCount (g_ProfileDirWack);

        g_CommonProfileDir    = JoinPathsEx (g_GlobalPool, g_WinDir, TEXT("All Users"));

        //
        // Get System dir, with and without wack
        //

        GetSystemDirectory(TempPath, MAX_TCHAR_PATH);
        g_SystemDir = PoolMemDuplicateString (g_GlobalPool, TempPath);
        g_SystemDirWack = JoinPathsEx (g_GlobalPool, g_SystemDir, S_EMPTY);
        g_SystemDirWackChars = CharCount (g_SystemDirWack);

        //
        // Get System32 dir
        //

        g_System32Dir = JoinPathsEx (g_GlobalPool, g_WinDir, STR_SYSTEM32);
        g_System32DirWack = JoinPathsEx (g_GlobalPool, g_System32Dir, S_EMPTY);
        g_System32DirWackChars = CharCount (g_System32DirWack);

        g_DriversDir       = JoinPaths (g_System32Dir,    S_DRIVERSDIR);
        g_ViewersDir       = JoinPaths (g_System32Dir,    S_VIEWERSDIR);
        g_SpoolDir         = JoinPaths (g_System32Dir,    S_SPOOLDIR);
        g_SpoolDriversDir  = JoinPaths (g_SpoolDir,       S_SPOOLDRIVERSDIR);
        g_ColorDir         = JoinPaths (g_SpoolDriversDir,S_COLORDIR);
        g_PrintProcDir     = JoinPaths (g_SpoolDir,       S_PRINTPROCDIR);

        //
        // Get Program Files dir
        //

        g_ProgramFilesDir = NULL;
        g_ProgramFilesCommonDir = NULL;

        Key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion"));

        if (Key) {
            RegData = GetRegValueString (Key, TEXT("ProgramFilesDir"));
            if (RegData) {
                g_ProgramFilesDir = PoolMemDuplicateString (g_GlobalPool, RegData);
                MemFree (g_hHeap, 0, RegData);
            }
        }

        if (!g_ProgramFilesDir) {

            TempStr = (PTSTR) GetStringResource (MSG_PROGRAM_FILES_DIR);
            MYASSERT (TempStr);

            g_ProgramFilesDir = PoolMemDuplicateString (g_GlobalPool, TempStr);
            MYASSERT (g_ProgramFilesDir);
            g_ProgramFilesDir[0] = g_SystemDir[0];

            FreeStringResource (TempStr);
        }

        DEBUGMSG ((DBG_VERBOSE, "Program Files Dir is %s", g_ProgramFilesDir));

        //
        // Get Program Files\Common Files dir
        //

        g_ProgramFilesDirWack = JoinPathsEx (g_GlobalPool, g_ProgramFilesDir, S_EMPTY);
        MYASSERT (g_ProgramFilesDirWack);
        g_ProgramFilesDirWackChars = CharCount (g_ProgramFilesDirWack);

        if (Key) {
            RegData = GetRegValueString (Key, TEXT("CommonFilesDir"));
            if (RegData) {
                g_ProgramFilesCommonDir = PoolMemDuplicateString (g_GlobalPool, RegData);
                MemFree (g_hHeap, 0, RegData);
            }
        }

        if (!g_ProgramFilesCommonDir) {

            TempStr = JoinPaths (g_ProgramFilesDir, S_COMMONDIR);
            g_ProgramFilesCommonDir = PoolMemDuplicateString (g_GlobalPool, TempStr);
            FreePathString (TempStr);
        }

        if (Key) {
            CloseRegKey (Key);
        }

        DEBUGMSG ((DBG_VERBOSE, "Common Program Files Dir is %s", g_ProgramFilesCommonDir));

        //
        // Create temporary directory path, with and without wack
        //

        g_TempDir = pCreateDirectoryFromInf (KEY_TEMP_BASE, g_WinDir, FALSE);
        if (!g_TempDir) {
            rc = GetLastError();
            __leave;
        }

        g_Win9xSifDir = JoinPathsEx (g_GlobalPool, g_TempDir,S_WIN9XSIF);

        g_TempDirWack      = JoinPathsEx (g_GlobalPool, g_TempDir, S_EMPTY);
        g_TempDirWackChars = CharCount (g_TempDirWack);

        //
        // Build plugin dir, with and without wack
        //

        g_PlugInDir     = PoolMemDuplicateString (g_GlobalPool, g_TempDir);
        g_PlugInDirWack = JoinPathsEx (g_GlobalPool, g_PlugInDir, S_EMPTY);
        g_PlugInDirWackChars = CharCount (g_PlugInDirWack);

        //
        // Create plugin temp dir, with and without wack.
        //

        g_PlugInTempDir = JoinPathsEx (g_GlobalPool, g_PlugInDir, TEXT("temp"));

        //
        // Create recycled dir, with wack
        //

        g_RecycledDirWack = JoinPathsEx (g_GlobalPool, g_WinDrive, TEXT("recycled\\"));
        g_RecycledDirWackChars = CharCount (g_RecycledDirWack);

        //
        // Copy WINNT32 settings to globals
        //
        // NOTE: If more args are added to WINNT32's Info struct, you should
        //       adjust the InitToolMode code below to match.
        //
        //

        g_UnattendedFlagPtr     = Info->BaseInfo->UnattendedFlag;
        g_CancelFlagPtr         = Info->BaseInfo->CancelledFlag;
        g_AbortFlagPtr          = Info->BaseInfo->AbortedFlag;
        g_UpgradeFlagPtr        = Info->BaseInfo->UpgradeFlag;
        g_MakeLocalSourcePtr    = Info->BaseInfo->LocalSourceModeFlag;
        g_CdRomInstallPtr       = Info->BaseInfo->CdRomInstallFlag;
        g_UnattendScriptFile    = Info->BaseInfo->UnattendedScriptFile;
        g_CmdLineOptions        = Info->BaseInfo->UpgradeOptions;
        g_BlockOnNotEnoughSpace = Info->BaseInfo->NotEnoughSpaceBlockFlag;
        g_LocalSourceDrive      = Info->BaseInfo->LocalSourceDrive;
        g_LocalSourceSpace      = Info->BaseInfo->LocalSourceSpaceRequired;
        g_ProductType           = Info->BaseInfo->ProductType;
        g_SourceDirectoryCountFromWinnt32 = Info->BaseInfo->SourceDirectoryCount;
        g_SourceDirectoriesFromWinnt32    = Info->BaseInfo->SourceDirectories;
        g_ForceNTFSConversion   = Info->BaseInfo->ForceNTFSConversion;
        g_Boot16                = Info->BaseInfo->Boot16;
        g_UnattendSwitchSpecified = Info->BaseInfo->UnattendSwitchSpecified;
        //
        // ProductFlavor is not initialized at this point yet, but it will be below
        //
        g_ProductFlavor         = Info->BaseInfo->ProductFlavor;
        g_SetupFlags            = Info->BaseInfo->SetupFlags;
        g_WinDirSpace           = Info->WinDirSpace;
        g_RamNeeded             = Info->RequiredMb;
        g_RamAvailable          = Info->AvailableMb;
        g_OptionalDirectoryCountFromWinnt32 = Info->OptionalDirectoryCount;
        g_OptionalDirectoriesFromWinnt32    = Info->OptionalDirectories;
        g_UpginfsUpdated        = Info->UpginfsUpdated;

        ReadDiskSectors = Info->ReadDiskSectors;

        if (!pGetProductFlavor ()) {
            LOG ((LOG_ERROR, "Cannot get ProductType key from dosnet.inf"));
            rc = GetLastError ();
            __leave;
        }

        if (*g_ProductFlavor != PROFESSIONAL_PRODUCTTYPE && *g_ProductFlavor != PERSONAL_PRODUCTTYPE) {
            *g_ProductType = NT_SERVER;
        } else {
            *g_ProductType = NT_WORKSTATION;
            g_PersonalSKU = (*g_ProductFlavor == PERSONAL_PRODUCTTYPE);
        }

        if (IsServerInstall()) {
            rc = ERROR_REQUEST_ABORTED;
            __leave;
        }

        //
        // NOTE: If more args are added to WINNT32's Info struct, you should
        //       adjust the InitToolMode code below to match.
        //

        if (Info->DynamicUpdateLocalDir && *Info->DynamicUpdateLocalDir) {
            g_DynamicUpdateLocalDir = DuplicateTextEx (g_GlobalPool, Info->DynamicUpdateLocalDir, 0, NULL);
        }
        if (Info->DynamicUpdateDrivers && *Info->DynamicUpdateDrivers) {
            g_DynamicUpdateDrivers = DuplicateTextEx (g_GlobalPool, Info->DynamicUpdateDrivers, 0, NULL);
        }

        g_UserOptionPool = PoolMemInitNamedPool ("User Options");

        //
        // Initialize Win9x environment table
        //

        Init9xEnvironmentVariables();

        //
        // Make sure that we really want to upgrade this machine.
        //
        if (!g_ToolMode && !pSafeToUpgrade ()) {

            *Info->UpgradeFailureReason = REASON_UPGRADE_OTHER_OS_FOUND;
            rc = ERROR_REQUEST_ABORTED;
            __leave;
        }

        //
        // winnt32 doesn't scrub the source directories for duplicates..We, however, do.
        //

        g_SourceDirectoryCount = 0;

        for (index = 0 ; index < *g_SourceDirectoryCountFromWinnt32; index++) {

            for (index2 = 0; index2 < g_SourceDirectoryCount; index2++) {

                if (StringIMatch(
                    g_SourceDirectories[index2],
                    g_SourceDirectoriesFromWinnt32[index]
                    )) {
                    DEBUGMSG ((
                        DBG_WARNING,
                        "Duplicate Source Directory %s removed from list!!",
                        g_SourceDirectories[index2]
                        ));

                    break;
                }
            }

            if (index2 == g_SourceDirectoryCount) {
                //
                // No matching directory found, add to list..
                //
                g_SourceDirectories[g_SourceDirectoryCount++] = g_SourceDirectoriesFromWinnt32[index];
            }
        }

        //
        // Do the samescrubbing with optional directories.
        //
        g_OptionalDirectoryCount = 0;

        for (index = 0 ; index < *g_OptionalDirectoryCountFromWinnt32; index++) {

            for (index2 = 0; index2 < g_OptionalDirectoryCount; index2++) {

                if (StringIMatch(
                    g_OptionalDirectories[index2],
                    g_OptionalDirectoriesFromWinnt32[index]
                    )) {
                    DEBUGMSG ((
                        DBG_WARNING,
                        "Duplicate Optional Directory %s removed from list!!",
                        g_OptionalDirectories[index2]
                        ));

                    break;
                }
            }

            if (index2 == g_OptionalDirectoryCount) {
                //
                // No matching directory found, add to list..
                //
                g_OptionalDirectories[g_OptionalDirectoryCount++] = g_OptionalDirectoriesFromWinnt32[index];
            }
        }

        //
        // block upgrades from Win95
        //
        if (!g_ToolMode && !ISATLEASTWIN98()) {
            rc = ERROR_REQUEST_ABORTED;
            ResourceMessageBox (NULL, MSG_PLATFORM_UPGRADE_UNSUPPORTED, MB_OK, NULL);
            __leave;
        }

        rc = ERROR_SUCCESS;
    }
    __finally {

        if (rc != ERROR_SUCCESS && rc != ERROR_REQUEST_ABORTED) {
            if (g_Win95UpgInf != INVALID_HANDLE_VALUE) {
                InfCloseInfFile (g_Win95UpgInf);

                g_Win95UpgInf = INVALID_HANDLE_VALUE;
            }
        }
    }

    return rc;
}


BOOL
InitToolMode (
    HINSTANCE Instance
    )

/*++

Routine Description:

  InitToolMode is called by Win9x-side tools (not by shipping setup code).
  It initializes the libraries and simulates WINNT32 init.

Arguments:

  None.

Return Value:

  TRUE if init was successful, FALSE otherwise.

--*/

{
    DWORD dwReason;
    PVOID lpReserved;
    WINNT32_PLUGIN_INIT_INFORMATION_BLOCK BaseInfo;
    WINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK InfoBlock;
    static BOOL AlwaysFalseFlag = FALSE;
    static BOOL AlwaysTrueFlag = TRUE;
    static PRODUCTTYPE ProductType = NT_WORKSTATION;
    static UINT SourceDirs = 1;
    static PCTSTR SourceDirMultiSz = TEXT(".\0");
    static UINT ProductFlavor = PERSONAL_PRODUCTTYPE;
    static UINT AlwaysZero = 0;


    g_ToolMode = TRUE;

    //
    // Simulate DllMain
    //

    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    //
    // Initialize DLL globals
    //

    if (!FirstInitRoutine (Instance)) {
        return FALSE;
    }

    //
    // Initialize all libraries
    //

    if (!InitLibs (Instance, dwReason, lpReserved)) {
        return FALSE;
    }

    //
    // Final initialization
    //

    if (!FinalInitRoutine ()) {
        return FALSE;
    }

    //
    // Simulate WINNT32 init
    //

    ZeroMemory (&BaseInfo, sizeof (BaseInfo));
    ZeroMemory (&InfoBlock, sizeof (InfoBlock));

    BaseInfo.UnattendedFlag = &AlwaysFalseFlag;
    BaseInfo.CancelledFlag = &AlwaysFalseFlag;
    BaseInfo.AbortedFlag = &AlwaysFalseFlag;
    BaseInfo.UpgradeFlag = &AlwaysTrueFlag;
    BaseInfo.LocalSourceModeFlag = &AlwaysFalseFlag;
    BaseInfo.CdRomInstallFlag = &AlwaysFalseFlag;
    BaseInfo.UnattendedScriptFile = NULL;
    BaseInfo.UpgradeOptions = NULL;
    BaseInfo.NotEnoughSpaceBlockFlag = &AlwaysFalseFlag;
    BaseInfo.LocalSourceDrive = NULL;
    BaseInfo.LocalSourceSpaceRequired = 0;
    BaseInfo.ProductType = &ProductType;
    BaseInfo.SourceDirectoryCount = &SourceDirs;
    BaseInfo.SourceDirectories = &SourceDirMultiSz;
    BaseInfo.ForceNTFSConversion = &AlwaysFalseFlag;
    BaseInfo.Boot16 = &AlwaysFalseFlag;
    BaseInfo.ProductFlavor = &ProductFlavor;

    InfoBlock.BaseInfo = &BaseInfo;
    InfoBlock.WinDirSpace = 0;
    InfoBlock.RequiredMb = 0;
    InfoBlock.AvailableMb = 0;
    InfoBlock.OptionalDirectories = NULL;
    InfoBlock.OptionalDirectoryCount = &AlwaysZero;

    return ERROR_SUCCESS == Winnt32Init (&InfoBlock);
}


VOID
TerminateToolMode (
    HINSTANCE Instance
    )
{
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    //
    // Call the cleanup routine that requires library APIs
    //

    FirstCleanupRoutine();

    //
    // Clean up all libraries
    //

    TerminateLibs (Instance, dwReason, lpReserved);

    //
    // Do any remaining clean up
    //

    FinalCleanupRoutine();

}



DWORD
Winnt32WriteParamsWorker (
    IN      PCTSTR WinntSifFile
    )

/*++

Routine Description:

  Winnt32WriteParamsWorker is called just before WINNT32 begins to modify the
  boot sector and copy files.  Our job here is to take the specified
  WINNT.SIF file, read it in, merge in our changes, and write it back
  out.

Arguments:

  WinntSifFile - Specifies path to WINNT.SIF.  By this time, the WINNT.SIF
                 file has some values already set.

Return Value:

  A Win32 status code indicating outcome.

--*/

{
    static TCHAR SifBuf[MAX_TCHAR_PATH];

    //
    // This can take a while (especially writing the INF to disk.)
    // Display a wait cursor.
    //
    TurnOnWaitCursor();

    __try {


        //
        // We finally got the WINNT.SIF file location.  Merge any
        // settings that are already there, then save it to disk.
        // If it saves OK, start using profile APIs.
        //

        if (!MergeInf (WinntSifFile))
            return GetLastError();

        if (!WriteInfToDisk (WinntSifFile))
            return GetLastError();

        StringCopy (SifBuf, WinntSifFile);
        g_ProfileName = SifBuf;


        if (!REPORTONLY()) {

            //
            // Go ahead and save ntsetup.dat at this time as well.. to ensure that we
            // get rid of the BuildInf stuff.
            //

            MemDbSetValue (
                MEMDB_CATEGORY_STATE TEXT("\\") MEMDB_ITEM_MASTER_SEQUENCER,
                g_MasterSequencer
                );

            if (!MemDbSave (UI_GetMemDbDat())) {
                return GetLastError();
            }
        }
#ifdef PRERELEASE
        if (g_ConfigOptions.DevPause) {
            OkBox (g_ParentWnd, (DWORD) TEXT("Developer Pause"));
        }
#endif
    }

    __finally {
        TurnOffWaitCursor();
    }

    return ERROR_SUCCESS;
}


VOID
Winnt32CleanupWorker (
    VOID
    )

/*++

Routine Description:

  If the user cancels Setup, Winnt32Cleanup is called while WINNT32 is
  displaying the wizard page "Setup is undoing changes it made to your
  computer."  We must stop all processing and clean up.

  If WINNT32 completes all of its work, Winnt32Cleanup is called as
  the process exists.

  We get called even on fresh install, so we must verify we are upgrading.

Arguments:

  none

Return Value:

  none

--*/

{
    HKEY Key;
    TCHAR Path[MAX_TCHAR_PATH];
    TCHAR src[MAX_PATH];
    TCHAR dest[MAX_PATH];
    DWORD attribs;
    TCHAR drive[] = TEXT(":?");
    UINT u;

    DEBUGMSG ((DBG_VERBOSE, "Winnt32Cleanup initiated"));

    TerminateWinntSifBuilder();
    UI_Cleanup();

    //
    // If the cancel flag pointer is set, we must undo everything!!
    //

    if (CANCELLED()) {
        DeleteDirectoryContents(g_PlugInTempDir);
        RemoveDirectory(g_PlugInTempDir);

        DeleteDirectoryContents(g_TempDir);
        RemoveDirectory(g_TempDir);

        //
        // Enumerate all drives and try to delete user~tmp.@0?
        //

        pCleanUpShellFolderTemp();

        //
        // if some files were already affected, undo those modifications
        //
        UndoChangedFileProps ();

    } else {
        //
        // Put boot.ini in uninstall image
        //

        if (g_BootDrivePath && g_TempDir) {
            StringCopy (src, g_BootDrivePath);
            StringCopy (AppendWack (src), S_BOOTINI);
            StringCopy (dest, g_TempDir);
            StringCopy (AppendWack (dest), TEXT("uninstall\\boot.ini"));

            attribs = GetFileAttributes (src);
            SetFileAttributes (src, FILE_ATTRIBUTE_NORMAL);
            CopyFile (src, dest, FALSE);
            SetFileAttributes (src, attribs);

            StringCopy (src, g_BootDrivePath);
            StringCopy (AppendWack (src), TEXT("$ldr$"));
            StringCopy (dest, g_TempDir);
            StringCopy (AppendWack (dest), TEXT("uninstall\\$ldr$"));

            attribs = GetFileAttributes (src);
            SetFileAttributes (src, FILE_ATTRIBUTE_NORMAL);
            CopyFile (src, dest, FALSE);
            SetFileAttributes (src, attribs);

            if (g_ConfigOptions.EnableBackup) {
                //
                // Put autochk.exe in c:\$win_nt$.~bt\i386
                //

                StringCopy (dest, g_BootDrivePath);
                StringCat (dest, TEXT("$win_nt$.~bt\\i386\\autochk.exe"));
                MakeSurePathExists (dest, FALSE);

                for (u = 0 ; u < g_SourceDirectoryCount ; u++) {
                    StringCopy (src, g_SourceDirectories[u]);
                    StringCopy (AppendWack (src), "autochk.exe");

                    if (DoesFileExist (src)) {
                        break;
                    }
                }

                if (u == g_SourceDirectoryCount) {
                    LOG ((LOG_WARNING, "autochk.exe not found in sources"));
                } else {
                    if (!CopyFile (src, dest, FALSE)) {
                        LOG ((LOG_WARNING, "autochk.exe could not be copied from %s to %s; not fatal", src, dest));
                    }
                }
            }

        } else {
            MYASSERT (FALSE);
        }

        //
        // Put cleanup code in Run key
        //

        Key = CreateRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce"));
        MYASSERT (Key);

        if (Key) {
            wsprintf(
                Path,
                TEXT("\"%s\\migisol.exe\" -%c"),
                g_TempDir,
                g_ConfigOptions.EnableBackup? 'b': 'c'
                );

            if(g_ConfigOptions.EnableBackup){
                drive[1] = g_BootDrivePath[0];
                StringCat(Path, drive);
            }

            DEBUGMSG ((DBG_VERBOSE, Path));

            if(ERROR_SUCCESS != RegSetValueEx (Key, TEXT("WINNT32"), 0, REG_SZ, (PBYTE) Path, SizeOfString (Path))){
                DEBUGMSG ((DBG_ERROR, "RegSetValueEx is failed to setup RunServicesOnce with migisol.exe"));
            }

            CloseRegKey (Key);
        }
    }

    SafeModeShutDown ();

    DEBUGMSG ((DBG_VERBOSE, "Winnt32Cleanup completed"));
}



BOOL
Winnt32SetAutoBootWorker (
    IN    INT DrvLetter
    )

/*++

Routine Description:

  Winnt32SetAutoBootWorker is called by WINNT32 on both upgrade and fresh install
  to modify the boot partition of a NEC PC-9800 Partition Control Table.

Arguments:

  none

Return Value:

  TRUE if the partition control table was updated, or FALSE if it wasn't,
  or an error occurred.

--*/

{
    INT Win95BootDrive;
    INT rc = TRUE;

    if(ISPC98()) {
        if (!g_Pc98ModuleHandle) {
            LOG ((LOG_ERROR, "PC98: External module not loaded!  Can't update auto boot."));
            return FALSE;
        }

        //
        // Set the NT 5 drive as "Bootable" and "Auto boot"
        //

        if (!SetBootFlag (DrvLetter, SB_BOOTABLE | SB_AUTO)) {
            LOG ((LOG_ERROR, "PC98: Unable to set target partition as BOOTABLE and AUTO."));
            return FALSE;
        }

        DrvLetter = _totupper (DrvLetter);
        Win95BootDrive = _totupper ((UINT) g_BootDriveLetter);

        if ( Win95BootDrive != DrvLetter) {
            if ( *g_Boot16 == BOOT16_YES ) {
                //
                // In this case, we do not create "MS-DOS" entry into BOOT.INI.
                // Set partition name to Win95 boot drive and NT5 system drive, instead of NT5 Boot menu (boot.ini).
                //
                rc = SetPtnName (Win95BootDrive, WIN9X_DOS_NAME);
                if (!rc) {
                    LOG ((LOG_ERROR, "PC98: Unable to set partition name into NEC98 boot menu. (WIN9X_DOS_NAME)"));
                }
                rc = SetPtnName (DrvLetter, WINNT5_NAME);
                if (!rc) {
                    LOG ((LOG_ERROR, "PC98: Unable to set partition name into NEC98 boot menu. (WINNT5_NAME)"));
                }
            } else {
                //
                // Set to Win95 drive as "Unbootable"
                //
                rc = SetBootFlag (Win95BootDrive, SB_UNBOOTABLE);
                if (!rc) {
                    LOG ((LOG_ERROR, "PC98: Unable to set target partition as UNBOOTABLE."));
                }
            }
        }
        return rc;
    }

    return FALSE;
}


BOOL
IsServerInstall (
    VOID
    )

/*++

Routine Description:

  IsServerInstall checks win95upg.inf to see if ProductType is set to zero,
  indicating workstation.  If this test passes incorrectly, a test in
  wizproc.c will catch the upgrade to server.

Arguments:

  None.

Return Value:

  TRUE if this win95upg.inf is for server.

--*/

{
    PCTSTR ArgArray[1];
    BOOL b;

    if (g_ToolMode) {
        return FALSE;
    }

    //
    // Block upgrades of Server
    //

    b = FALSE;

    if (*g_ProductFlavor != PROFESSIONAL_PRODUCTTYPE && *g_ProductFlavor != PERSONAL_PRODUCTTYPE) {
        ArgArray[0] = g_Win95Name;

        ResourceMessageBox (
            g_ParentWnd,
            MSG_SERVER_UPGRADE_UNSUPPORTED_INIT,
            MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
            ArgArray
            );

        b = TRUE;
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\apcompat.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    apcompat.c

Abstract:

    This source implements checking AppCompatibility key that will come with NT

Author:

    Calin Negreanu (calinn) 18-May-1999

Revision History:

--*/

#include "pch.h"
#include "badapps.h"

// #define _OLDAPPDB
#define DBG_APPCOMPAT           "AppCompat"

//
// Globals
//

POOLHANDLE g_AppCompatPool   = NULL;
HASHTABLE g_AppCompatTable  = NULL;
HINF g_AppCompatInf = INVALID_HANDLE_VALUE;

//
// ISSUE - this will change to appmig.inf - leave it the old way until
// AppCompat team checks in the new file
//
#define S_APP_COMPAT_FILE1          TEXT("APPMIG.INF")
#define S_APP_COMPAT_FILE2          TEXT("APPMIG.IN_")

#define S_BASE_WIN_OPTIONS          TEXT("BaseWinOptions")
#define S_ADD_REG                   TEXT("AddReg")

typedef struct _APPCOMPAT_FILE {
    PBYTE Info;
    DWORD InfoSize;
    struct _APPCOMPAT_FILE *Next;
} APPCOMPAT_FILE, *PAPPCOMPAT_FILE;

BOOL
pInitAppCompat (
    VOID
    )
{
    PCSTR AppCompatFile = NULL;
    PCSTR AppCompatCompFile = NULL;
    DWORD decompResult;
    BOOL result = TRUE;
    INFCONTEXT baseContext, addContext, regContext;
    TCHAR baseSection [MEMDB_MAX];
    TCHAR addSection [MEMDB_MAX];
    TCHAR regValue [MEMDB_MAX];
    TCHAR fieldStr [MEMDB_MAX];
    INT   fieldVal;
    PCTSTR regFile;
    PAPPCOMPAT_FILE appCompatFile;
    DWORD index;
    HASHITEM stringId;

    if (CANCELLED()) {
        SetLastError (ERROR_CANCELLED);
        return FALSE;
    }
    __try {
        AppCompatFile = JoinPaths (SOURCEDIRECTORY(0), S_APP_COMPAT_FILE1);
        g_AppCompatInf = InfOpenInfFile (AppCompatFile);
        if (g_AppCompatInf == INVALID_HANDLE_VALUE) {
            FreePathString (AppCompatFile);
            AppCompatFile = JoinPaths (g_TempDir, S_APP_COMPAT_FILE1);
            AppCompatCompFile = JoinPaths (SOURCEDIRECTORY(0), S_APP_COMPAT_FILE2);
            decompResult = SetupDecompressOrCopyFile (AppCompatCompFile, AppCompatFile, 0);
            if ((decompResult != ERROR_SUCCESS) && (decompResult != ERROR_ALREADY_EXISTS)) {
                LOG((LOG_ERROR, "Cannot open Application compatibility database : %s", AppCompatCompFile));
                result = FALSE;
                __leave;
            }
            g_AppCompatInf = InfOpenInfFile (AppCompatFile);
            if (g_AppCompatInf == INVALID_HANDLE_VALUE) {
                LOG((LOG_ERROR, "Cannot open Application compatibility database : %s", AppCompatCompFile));
                result = FALSE;
                __leave;
            }
        }
        g_AppCompatPool = PoolMemInitNamedPool ("AppCompat Pool");
        g_AppCompatTable = HtAllocWithData (sizeof (PAPPCOMPAT_FILE));
        if (g_AppCompatTable == NULL) {
            LOG((LOG_ERROR, "Cannot initialize memory for Application compatibility operations"));
            result = FALSE;
            __leave;
        }
        //
        // finally load the data from ApCompat.inf
        //
        if (SetupFindFirstLine (g_AppCompatInf, S_BASE_WIN_OPTIONS, NULL, &baseContext)) {
            do {
                if (SetupGetStringField (&baseContext, 1, baseSection, MEMDB_MAX, NULL)) {
                    if (SetupFindFirstLine (g_AppCompatInf, baseSection, S_ADD_REG, &addContext)) {
                        do {
                            if (SetupGetStringField (&addContext, 1, addSection, MEMDB_MAX, NULL)) {
                                if (SetupFindFirstLine (g_AppCompatInf, addSection, NULL, &regContext)) {
                                    do {
                                        if (SetupGetStringField (&regContext, 2, regValue, MEMDB_MAX, NULL)) {
                                            regFile = GetFileNameFromPath (regValue);
                                            appCompatFile = (PAPPCOMPAT_FILE) PoolMemGetMemory (g_AppCompatPool, sizeof (APPCOMPAT_FILE));
                                            ZeroMemory (appCompatFile, sizeof (APPCOMPAT_FILE));
                                            index = SetupGetFieldCount (&regContext);
                                            if (index > 4) {
                                                appCompatFile->Info = (PBYTE) PoolMemGetMemory (g_AppCompatPool, index - 4);
                                                appCompatFile->InfoSize = index - 4;
                                                index = 0;
                                                while (SetupGetStringField (&regContext, index+5, fieldStr, MEMDB_MAX, NULL)) {
                                                    sscanf (fieldStr, TEXT("%x"), &fieldVal);
                                                    appCompatFile->Info [index] = (BYTE) fieldVal;
                                                    index ++;
                                                }
                                                if (index) {
                                                    stringId = HtFindString (g_AppCompatTable, regFile);
                                                    if (stringId) {
                                                        HtCopyStringData (g_AppCompatTable, stringId, &(appCompatFile->Next));
                                                        HtSetStringData (g_AppCompatTable, stringId, &appCompatFile);
                                                    } else {
                                                        HtAddStringAndData (g_AppCompatTable, regFile, &appCompatFile);
                                                    }
                                                }
                                            }
                                        }
                                    } while (SetupFindNextLine (&regContext, &regContext));
                                }
                            }
                        } while (SetupFindNextLine (&addContext, &addContext));
                    }
                }
            } while (SetupFindNextLine (&baseContext, &baseContext));
        }
    }
    __finally {
        if (AppCompatFile) {
            FreePathString (AppCompatFile);
            AppCompatFile = NULL;
        }
        if (AppCompatCompFile) {
            FreePathString (AppCompatCompFile);
            AppCompatCompFile = NULL;
        }
    }
    return result;
}

DWORD
InitAppCompat (
    IN     DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_INIT_APP_COMPAT;
    case REQUEST_RUN:
        if (!pInitAppCompat ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in InitAppCompat"));
    }
    return 0;
}

BOOL
pDoneAppCompat (
    VOID
    )
{
    if (g_AppCompatTable) {
        HtFree (g_AppCompatTable);
        g_AppCompatTable = NULL;
    }
    if (g_AppCompatPool) {
        PoolMemDestroyPool (g_AppCompatPool);
        g_AppCompatPool = NULL;
    }
    if (g_AppCompatInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_AppCompatInf);
        g_AppCompatInf = INVALID_HANDLE_VALUE;
    }
    return TRUE;
}

DWORD
DoneAppCompat (
    IN     DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_DONE_APP_COMPAT;
    case REQUEST_RUN:
        if (!pDoneAppCompat ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in DoneAppCompat"));
    }
    return 0;
}

BOOL
AppCompatTestFile (
    IN OUT  PFILE_HELPER_PARAMS Params
    )
{
    PCTSTR filePtr;
    HASHITEM stringId;
    PAPPCOMPAT_FILE appCompatFile;
    BOOL found = FALSE;
    BADAPP_DATA badAppData;
    BADAPP_PROP badAppProp;

    if (Params->Handled == 0) {

        filePtr = GetFileNameFromPath (Params->FullFileSpec);
        if (filePtr) {
            stringId = HtFindString (g_AppCompatTable, filePtr);
            if (stringId) {
                HtCopyStringData (g_AppCompatTable, stringId, &appCompatFile);
                while (!found && appCompatFile) {
                    if (appCompatFile->Info) {

                        badAppProp.Size = sizeof(BADAPP_PROP);
                        badAppData.Size = sizeof(BADAPP_DATA);
                        badAppData.FilePath = Params->FullFileSpec;
                        badAppData.Blob = appCompatFile->Info;
                        badAppData.BlobSize = appCompatFile->InfoSize;

                        if (SHIsBadApp(&badAppData, &badAppProp)) {
                            switch (badAppProp.AppType & APPTYPE_TYPE_MASK)
                            {
                                case APPTYPE_INC_HARDBLOCK:
                                case APPTYPE_INC_NOBLOCK:
                                    found = TRUE;
                                    MarkFileForExternalDelete (Params->FullFileSpec);
                                    if (!IsFileMarkedForAnnounce (Params->FullFileSpec)) {
                                        AnnounceFileInReport (Params->FullFileSpec, 0, ACT_INCOMPATIBLE);
                                    }
                                    Params->Handled = TRUE;
                            }
                        }
                    }
                    appCompatFile = appCompatFile->Next;
                }
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\dbaction.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dbaction.c

Abstract:

    This source implements action functions used by MigDb. There are two types
    of action functions here as the third parameter of the macro list is TRUE
    or FALSE.
    First type of action function is called whenever an action is triggered
    during file scanning. The second type of action function is called at the
    end of file scanning if the associated action was not triggered during
    file scanning phase.

Author:

    Calin Negreanu (calinn) 07-Jan-1998

Revision History:

  jimschm   20-Nov-2000 Added MarkForBackup
  marcw     31-Aug-1999 Added BlockingHardware
  ovidiut   20-Jul-1999 Added Ignore
  ovidiut   28-May-1999 Added IniFileMappings
  marcw     23-Sep-1998 Added BlockingVirusScanner
  jimschm   13-Aug-1998 Added CompatibleFiles
  jimschm   19-May-1998 Added MinorProblems_NoLinkRequired
  jimschm   27-Feb-1998 Added UninstallSections
  calinn    18-Jan-1998 Added CompatibleModules action

--*/

#include "pch.h"
#include "migdbp.h"
#include "migappp.h"

/*++

Macro Expansion List Description:

  GATHER_DATA_FUNCTIONS and ACTION_FUNCTIONS lists all valid actions to be performed
  by migdb when a context is met. Meeting a context means that all the sections
  associated with the context are satisfied (usually there is only one section).
  The difference is that GATHER_DATA_FUNCTIONS are called even if some function already
  handles a file.

Line Syntax:

   DEFMAC(ActionFn, ActionName, CallWhenTriggered, CanHandleVirtualFiles)

Arguments:

   ActionFn   - This is a boolean function that returnes TRUE if the specified action
                could be performed. It should return FALSE only if a serious error
                occures. You must implement a function with this name and required
                parameters.

   ActionName - This is the string that identifies the action function. It should
                have the same value as listed in migdb.inf.  This arg is declared
                as both a macro and the migdb.inf section name string.

   CallWhenTriggered - If the MigDbContext this action is associated with is triggered
                the action will be called if this field is TRUE, otherwise we will call
                the action at the end of file scan if the context was not triggered.

   CanHandleVirtualFiles - This is for treating files that are supposed to be in a fixed place
                but are not there (not installed or deleted). We need this in order to fix
                registry or links that point to this kind of files. A good example is backup.exe
                which is located in %ProgramFiles%\Accessories. The rules say that we should
                use ntbackup.exe instead but since this file is not existent we don't normally fix
                registry settings pointing to this file. We do now, with this new variable.

Variables Generated From List:

   g_ActionFunctions - do not touch!

For accessing the array there are the following functions:

   MigDb_GetActionAddr
   MigDb_GetActionIdx
   MigDb_GetActionName

--*/


/*
   Declare the macro list of action functions. If you need to add a new action just
   add a line in this list and implement the function.
*/
#define GATHER_DATA_FUNCTIONS   \
        DEFMAC1(CompatibleFiles,                    COMPATIBLEFILES,                    TRUE, FALSE)  \
        DEFMAC1(CompatibleShellModules,             COMPATIBLESHELLMODULES,             TRUE, FALSE)  \
        DEFMAC1(CompatibleRunKeyModules,            COMPATIBLERUNKEYMODULES,            TRUE, FALSE)  \
        DEFMAC1(CompatibleDosModules,               COMPATIBLEDOSMODULES,               TRUE, FALSE)  \
        DEFMAC1(CompatibleHlpFiles,                 COMPATIBLEHLPFILES,                 TRUE, FALSE)  \
        DEFMAC1(StoreMapi32Locations,               MAPI32,                             TRUE, FALSE)  \
        DEFMAC1(IniFileMappings,                    INIFILEMAPPINGS,                    TRUE, FALSE)  \
        DEFMAC1(SilentUninstall,                    SILENTUNINSTALL,                    TRUE, FALSE)  \
        DEFMAC1(FileEdit,                           FILEEDIT,                           TRUE, FALSE)  \
        DEFMAC1(IgnoreInReport,                     IGNORE,                             TRUE, FALSE)  \
        DEFMAC1(MarkForBackup,                      MARKFORBACKUP,                      TRUE, FALSE)  \
        DEFMAC1(ShowInSimplifiedView,               SHOWINSIMPLIFIEDVIEW,               TRUE, FALSE)  \

#define ACTION_FUNCTIONS        \
        DEFMAC2(UseNtFiles,                         USENTFILES,                         TRUE, TRUE )  \
        DEFMAC2(ProductCollisions,                  PRODUCTCOLLISIONS,                  TRUE, FALSE)  \
        DEFMAC2(MinorProblems,                      MINORPROBLEMS,                      TRUE, FALSE)  \
        DEFMAC2(MinorProblems_NoLinkRequired,       MINORPROBLEMS_NOLINKREQUIRED,       TRUE, FALSE)  \
        DEFMAC2(Reinstall_AutoUninstall,            REINSTALL_AUTOUNINSTALL,            TRUE, FALSE)  \
        DEFMAC2(Reinstall,                          REINSTALL,                          TRUE, FALSE)  \
        DEFMAC2(Reinstall_NoLinkRequired,           REINSTALL_NOLINKREQUIRED,           TRUE, FALSE)  \
        DEFMAC2(Reinstall_SoftBlock,                REINSTALL_SOFTBLOCK,                TRUE, FALSE)  \
        DEFMAC2(Incompatible_AutoUninstall,         INCOMPATIBLE_AUTOUNINSTALL,         TRUE, FALSE)  \
        DEFMAC2(Incompatible,                       INCOMPATIBLE,                       TRUE, FALSE)  \
        DEFMAC2(Incompatible_NoLinkRequired,        INCOMPATIBLE_NOLINKREQUIRED,        TRUE, FALSE)  \
        DEFMAC2(Incompatible_PreinstalledUtilities, INCOMPATIBLE_PREINSTALLEDUTILITIES, TRUE, FALSE)  \
        DEFMAC2(Incompatible_SimilarOsFunctionality,INCOMPATIBLE_SIMILAROSFUNCTIONALITY,TRUE, FALSE)  \
        DEFMAC2(Incompatible_HardwareUtility,       INCOMPATIBLE_HARDWAREUTILITY,       TRUE, FALSE)  \
        DEFMAC1(BadFusion,                          BADFUSION,                          TRUE, FALSE)  \
        DEFMAC2(OsFiles,                            OSFILES,                            TRUE, FALSE)  \
        DEFMAC2(DosApps,                            DOSAPPS,                            TRUE, FALSE)  \
        DEFMAC2(NonPnpDrivers,                      NONPNPDRIVERS,                      TRUE, FALSE)  \
        DEFMAC2(NonPnpDrivers_NoMessage,            NONPNPDRIVERS_NOMESSAGE,            TRUE, FALSE)  \
        DEFMAC2(MigrationProcessing,                MIGRATIONPROCESSING,                TRUE, FALSE)  \
        DEFMAC2(BlockingVirusScanner,               BLOCKINGVIRUSSCANNERS,              TRUE, FALSE)  \
        DEFMAC2(BlockingFile,                       BLOCKINGFILES,                      TRUE, FALSE)  \
        DEFMAC2(BlockingHardware,                   BLOCKINGHARDWARE,                   TRUE, FALSE)  \
        DEFMAC2(RequiredOSFiles,                    REQUIREDOSFILES,                    FALSE,FALSE)  \

/*
   Declare the action functions
*/
#define DEFMAC1(fn,id,call,can) ACTION_PROTOTYPE fn;
#define DEFMAC2(fn,id,call,can) ACTION_PROTOTYPE fn;
GATHER_DATA_FUNCTIONS
ACTION_FUNCTIONS
#undef DEFMAC1
#undef DEFMAC2


/*
   This is the structure used for handling action functions
*/
typedef struct {
    PCSTR ActionName;
    PACTION_PROTOTYPE ActionFunction;
    BOOL CallWhenTriggered;
    BOOL CanHandleVirtualFiles;
    BOOL CallAlways;
} ACTION_STRUCT, *PACTION_STRUCT;


/*
   Declare a global array of functions and name identifiers for action functions
*/
#define DEFMAC1(fn,id,call,can) {#id,fn,call,can,TRUE},
#define DEFMAC2(fn,id,call,can) {#id,fn,call,can,FALSE},
static ACTION_STRUCT g_ActionFunctions[] = {
                              GATHER_DATA_FUNCTIONS
                              ACTION_FUNCTIONS
                              {NULL, NULL, FALSE}
                              };
#undef DEFMAC1
#undef DEFMAC2


BOOL g_BadVirusScannerFound = FALSE;
BOOL g_BlockingFileFound = FALSE;
BOOL g_BlockingHardwareFound = FALSE;
BOOL g_UnknownOs = FALSE;
GROWLIST g_BadVirusScannerGrowList = GROWLIST_INIT;
DWORD g_BackupDirCount = 0;
extern BOOL g_IsFusionDir;

BOOL
pNoLinkRequiredWorker (
    IN      UINT GroupId,
    IN      UINT SubGroupId,            OPTIONAL
    IN      DWORD ActionType,
    IN      PMIGDB_CONTEXT Context
    );


PACTION_PROTOTYPE
MigDb_GetActionAddr (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_GetActionAddr returns the address of the action function based on the action index

Arguments:

  ActionIdx - Action index.

Return value:

  Action function address. Note that no checking is made so the address returned could be invalid.
  This is not a problem since the parsing code did the right job.

--*/

{
    return g_ActionFunctions[ActionIdx].ActionFunction;
}


INT
MigDb_GetActionIdx (
    IN      PCSTR ActionName
    )

/*++

Routine Description:

  MigDb_GetActionIdx returns the action index based on the action name

Arguments:

  ActionName - Action name.

Return value:

  Action index. If the name is not found, the index returned is -1.

--*/

{
    PACTION_STRUCT p = g_ActionFunctions;
    INT i = 0;
    while (p->ActionName != NULL) {
        if (StringIMatch (p->ActionName, ActionName)) {
            return i;
        }
        p++;
        i++;
    }
    return -1;
}


PCSTR
MigDb_GetActionName (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_GetActionName returns the name of an action based on the action index

Arguments:

  ActionIdx - Action index.

Return value:

  Action name. Note that no checking is made so the returned pointer could be invalid.
  This is not a problem since the parsing code did the right job.

--*/

{
    return g_ActionFunctions[ActionIdx].ActionName;
}


BOOL
MigDb_CallWhenTriggered (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_CallWhenTriggered is called every time when an action is triggered. Will return
  TRUE is the associated action function needs to be called, FALSE otherwise.

Arguments:

  ActionIdx - Action index.

Return value:

  TRUE if the associated action function needs to be called, FALSE otherwise.

--*/

{
    return g_ActionFunctions[ActionIdx].CallWhenTriggered;
}


BOOL
MigDb_CanHandleVirtualFiles (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_CanHandleVirtualFiles is called if a virtual file is passed to migdb

Arguments:

  ActionIdx - Action index.

Return value:

  TRUE if the associated action can handle virtual files, false if not.

--*/

{
    return g_ActionFunctions[ActionIdx].CanHandleVirtualFiles;
}


BOOL
MigDb_CallAlways (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_CallAlways returnes if an action should be called regardless of handled state.

Arguments:

  ActionIdx - Action index.

Return value:

  TRUE if the associated action should be called every time.

--*/

{
    return g_ActionFunctions[ActionIdx].CallAlways;
}


BOOL
IsMigrationPathEx (
    IN      PCTSTR Path,
    OUT     PBOOL IsWin9xOsPath         OPTIONAL
    )

/*++

Routine Description:

  IsMigrationPath checks to see if the given path is a "MigrationPath" (meaning
  that the path belongs to the OS that we are currently upgrading). The MigrationPaths
  category was previously created in filescan.c by pBuildMigrationPaths

Arguments:

  Path - Specifies the path to be checked.
  IsWin9xOsPath - Receives a BOOL indicating if this path is a Win9x OS migration path

Return value:

  TRUE if the path is part of "Migration Paths", FALSE otherwise.

--*/

{
    TCHAR key [MEMDB_MAX];
    PTSTR pathPtr;
    DWORD depth = 0;
    DWORD pathValue;
    TCHAR path[MAX_TCHAR_PATH];
    DWORD bIsWin9xOsPath;

    StringCopyTcharCount (path, Path, MAX_TCHAR_PATH);
    RemoveWackAtEnd (path);

    MemDbBuildKey (key, MEMDB_CATEGORY_MIGRATION_PATHS, path, NULL, NULL);

    pathPtr = GetEndOfString (key);

    if (IsWin9xOsPath) {
        *IsWin9xOsPath = FALSE;
    }

    while (pathPtr) {
        *pathPtr = 0;

        if ((MemDbGetValueAndFlags (key, &pathValue, &bIsWin9xOsPath)) &&
            (pathValue >= depth)
            ) {
            if (IsWin9xOsPath) {
                *IsWin9xOsPath = bIsWin9xOsPath;
            }
            return TRUE;
        }
        depth ++;
        pathPtr =  GetPrevChar (key, pathPtr, TEXT('\\'));
    }

    return FALSE;
}


BOOL
DeleteFileWithWarning (
    IN      PCTSTR FileName
    )

/*++

Routine Description:

  DeleteFileWithWarning marks a file for deletion but checks to see if a warning
  should be added in user report. We will generate a "backup files found" warning
  if the file that's going to be deleted is outside "Migration Paths",
  but not under %ProgramFiles%.

Arguments:

  FileName   - file to be deleted.

Return value:

  TRUE if the file was deleted successfully, FALSE otherwise.

--*/

{
    PCTSTR filePtr;
    TCHAR  filePath [MEMDB_MAX];
    TCHAR key [MEMDB_MAX];
    INFCONTEXT ic;

    RemoveOperationsFromPath (FileName, ALL_DEST_CHANGE_OPERATIONS);

    filePtr = (PTSTR)GetFileNameFromPath (FileName);
    if (!filePtr) {
        return FALSE;
    }
    filePtr = _tcsdec (FileName, filePtr);
    if (!filePtr) {
        return FALSE;
    }
    StringCopyABA (filePath, FileName, filePtr);

    if (!StringIMatchCharCount (filePath, g_ProgramFilesDirWack, g_ProgramFilesDirWackChars) &&
        !IsMigrationPath (filePath)
        ) {
        //
        // exclude certain files from user's report,
        // even if they are not in migration directories
        //
        if (!SetupFindFirstLine (g_Win95UpgInf, S_BACKUPFILESIGNORE, filePtr + 1, &ic)) {

            //
            // this file is not excluded; show it's dir in the report
            //
            MemDbBuildKey (key, MEMDB_CATEGORY_BACKUPDIRS, filePath, NULL, NULL);
            if (!MemDbGetValue (key, NULL)) {
                //
                // write it in the log
                //
                DEBUGMSG ((DBG_WARNING, "BACKUPDIR: %s is considered a backup directory.", filePath));

                MemDbSetValueEx (MEMDB_CATEGORY_BACKUPDIRS, filePath, NULL, NULL, 0 , NULL);
                g_BackupDirCount++;
            }
        }
    }

    if (CanSetOperation (FileName, OPERATION_FILE_DELETE)) {
        MarkFileForDelete (FileName);
    }

    return TRUE;
}


BOOL
OsFiles (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when an OS file is found. Basically the file gets deleted to
  make room for NT version.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    PCSTR newFileName;
    DWORD fileStatus;
    MULTISZ_ENUM fileEnum;
    BOOL b = FALSE;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
        do {
            if (!g_IsFusionDir || !IsNtCompatibleModule (fileEnum.CurrentString)) {
                //
                // If this file is marked with any MOVE operations, remove those operations.
                // we want this deletion to take precedence.
                //
                RemoveOperationsFromPath (
                    fileEnum.CurrentString,
                    ALL_MOVE_OPERATIONS
                    );

                DeleteFileWithWarning (fileEnum.CurrentString);
                MarkFileAsOsFile (fileEnum.CurrentString);
                fileStatus = GetFileStatusOnNt (fileEnum.CurrentString);

                if ((fileStatus & FILESTATUS_REPLACED) != 0) {

                    newFileName = GetPathStringOnNt (fileEnum.CurrentString);

                    if (StringIMatch (newFileName, fileEnum.CurrentString)) {
                        MarkFileForCreation (newFileName);
                    } else {
                        MarkFileForMoveByNt (fileEnum.CurrentString, newFileName);
                    }

                    FreePathString (newFileName);
                }
                b = TRUE;
            }
        }
        while (EnumNextMultiSz (&fileEnum));
    }

    return b;
}


BOOL
UseNtFiles (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when NT uses another file for same functionality. We will
  mark the file as deleted, moved and we will add it in RenameFile category

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    CHAR ntFilePath [MAX_MBCHAR_PATH];
    MULTISZ_ENUM fileEnum;
    TCHAR key [MEMDB_MAX];
    DWORD set;
    PCTSTR name;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {

        if (!GetNtFilePath (Context->Arguments, ntFilePath)) {
            LOG((LOG_ERROR, "Cannot UseNTFile for %s", Context->Arguments));
            return FALSE;
        }
        else {
            do {
                if (Context->VirtualFile) {
                    MarkFileForExternalDelete (fileEnum.CurrentString);
                } else {
                    DeleteFileWithWarning (fileEnum.CurrentString);
                }
                MarkFileForMoveByNt (fileEnum.CurrentString, ntFilePath);
                MarkFileAsOsFile (fileEnum.CurrentString);
                if (Context->VirtualFile) {
                    continue;
                }
                //
                // add this info to memdb to update commands that use these files
                //
                name = GetFileNameFromPath (fileEnum.CurrentString);
                if (!g_UseNtFileHashTable) {
                    continue;
                }
                if (!HtFindStringAndData (g_UseNtFileHashTable, name, &set)) {
                    MYASSERT (FALSE);
                    continue;
                }
                //
                // check if a file with this name, but not handled, was previously found
                //
                if (!set) {
                    MemDbBuildKey (
                        key,
                        MEMDB_CATEGORY_USE_NT_FILES,
                        name,
                        GetFileNameFromPath (ntFilePath),
                        NULL
                        );
                    if (!MemDbGetValue (key, NULL)) {
                        MemDbSetValue (key, 0);
                    }
                } else {
                    DEBUGMSG ((
                        DBG_VERBOSE,
                        "Found [UseNtFiles] file %s, but there's already one that was not handled",
                        name
                        ));
                }
            }
            while (EnumNextMultiSz (&fileEnum));
        }
    }
    return TRUE;
}


BOOL
Incompatible (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when a known incompatible file is found. The file gets marked
  for external deletion (it will not be deleted but in all subsequent operation will be
  considered as deleted) and if there is a link pointing to it an announcement is made
  in LinkProcessing phase.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;
    PCTSTR extPtr;
    BOOL result = FALSE;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
        do {
            if (!IsFileMarkedAsKnownGood (fileEnum.CurrentString)) {
                result = TRUE;
                extPtr = GetFileExtensionFromPath (fileEnum.CurrentString);
                if (extPtr) {
                    if (StringIMatch (extPtr, TEXT("SCR"))) {
                        DisableFile (fileEnum.CurrentString);
                    }
                }
                MarkFileForExternalDelete (fileEnum.CurrentString);
                if (!IsFileMarkedForAnnounce (fileEnum.CurrentString)) {
                    AnnounceFileInReport (fileEnum.CurrentString, (DWORD)Context, ACT_INC_NOBADAPPS);
                }
            }
        }
        while (EnumNextMultiSz (&fileEnum));
    }
    return result;
}


BOOL
Incompatible_PreinstalledUtilities (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when a known incompatible preinstalled utility is found.
  The file gets marked for external deletion (it will not be deleted but in all
  subsequent operation will be considered as deleted) and if there is a link
  pointing to it an announcement is made in LinkProcessing phase.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;
    BOOL result = FALSE;

    if (!Context->Arguments) {
        if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
            do {
                if (!IsFileMarkedAsKnownGood (fileEnum.CurrentString)) {
                    result = TRUE;
                    MarkFileForExternalDelete (fileEnum.CurrentString);
                    if (!IsFileMarkedForAnnounce (fileEnum.CurrentString)) {
                        AnnounceFileInReport (fileEnum.CurrentString, (DWORD)Context, ACT_INC_PREINSTUTIL);
                    }
                }
            } while (EnumNextMultiSz (&fileEnum));
        }
    } else {
        return pNoLinkRequiredWorker (
                    MSG_INCOMPATIBLE_ROOT,
                    MSG_INCOMPATIBLE_PREINSTALLED_UTIL_SUBGROUP,
                    ACT_INC_PREINSTUTIL,
                    Context
                    );
    }

    return result;
}


BOOL
Incompatible_SimilarOsFunctionality (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when a known incompatible preinstalled utility is found.
  The file gets marked for external deletion (it will not be deleted but in all
  subsequent operation will be considered as deleted) and if there is a link
  pointing to it an announcement is made in LinkProcessing phase.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;
    BOOL result = FALSE;

    if (!Context->Arguments) {
        if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
            do {
                if (!IsFileMarkedAsKnownGood (fileEnum.CurrentString)) {
                    result = TRUE;
                    MarkFileForExternalDelete (fileEnum.CurrentString);
                    if (!IsFileMarkedForAnnounce (fileEnum.CurrentString)) {
                        AnnounceFileInReport (fileEnum.CurrentString, (DWORD)Context, ACT_INC_SIMILAROSFUNC);
                    }
                }
            } while (EnumNextMultiSz (&fileEnum));
        }
    } else {
        return pNoLinkRequiredWorker (
                    MSG_INCOMPATIBLE_ROOT,
                    MSG_INCOMPATIBLE_UTIL_SIMILAR_FEATURE_SUBGROUP,
                    ACT_INC_SIMILAROSFUNC,
                    Context
                    );
    }

    return result;
}


BOOL
Incompatible_HardwareUtility (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when a known incompatible hardware
  utility is found.  The file gets marked for external deletion
  (it will not be deleted but in all subsequent operation will
  be considered as deleted) and if there is a link pointing to
  it an announcement is made in LinkProcessing phase.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;
    BOOL result = FALSE;

    if (!Context->Arguments) {

        if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
            do {
                if (!IsFileMarkedAsKnownGood (fileEnum.CurrentString)) {
                    result = TRUE;
                    MarkFileForExternalDelete (fileEnum.CurrentString);
                    if (!IsFileMarkedForAnnounce (fileEnum.CurrentString)) {
                        AnnounceFileInReport (fileEnum.CurrentString, (DWORD)Context, ACT_INC_IHVUTIL);
                    }
                }
            } while (EnumNextMultiSz (&fileEnum));
        }

    } else {
        return pNoLinkRequiredWorker (
                    MSG_INCOMPATIBLE_ROOT,
                    MSG_INCOMPATIBLE_HW_UTIL_SUBGROUP,
                    ACT_INC_IHVUTIL,
                    Context
                    );
    }

    return result;
}




BOOL
MinorProblems (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an app with known minor problems. If there is a link
  pointing to one of these files an announcement is made in LinkProcessing phase.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;
    BOOL result = FALSE;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
        do {
            if (!IsFileMarkedAsKnownGood (fileEnum.CurrentString)) {
                result = TRUE;
                if (!IsFileMarkedForAnnounce (fileEnum.CurrentString)) {
                    AnnounceFileInReport (fileEnum.CurrentString, (DWORD)Context, ACT_MINORPROBLEMS);
                }
            }
        }
        while (EnumNextMultiSz (&fileEnum));
    }
    return result;
}


BOOL
Reinstall (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an app that should be reinstalled on NT. If there
  is a link pointing to one of these files an announcement is made in LinkProcessing phase.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;
    BOOL result = FALSE;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
        do {
            if (!IsFileMarkedAsKnownGood (fileEnum.CurrentString)) {
                result = TRUE;
                MarkFileForExternalDelete (fileEnum.CurrentString);
                if (!IsFileMarkedForAnnounce (fileEnum.CurrentString)) {
                    AnnounceFileInReport (fileEnum.CurrentString, (DWORD)Context, ACT_REINSTALL);
                }
            }
        }
        while (EnumNextMultiSz (&fileEnum));
    }
    return result;
}


BOOL
DosApps (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an DOS app that's either incompatible or has
  minor problems (it's incompatible if Context has Message field NULL). We are forced
  to add this now in the user report since DOS apps usually don't have PIF files
  associated.

Arguments:

  Context - See definition.

Return value:

  TRUE  - at least one file was announced
  FALSE - no files were announced

--*/

{
    MULTISZ_ENUM fileEnum;
    BOOL AtLeastOneFile;

    AtLeastOneFile = FALSE;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
        do {
            if (!IsFileMarkedAsKnownGood (fileEnum.CurrentString)) {
                if (Context->Message != NULL) {
                    if (!IsFileMarkedForAnnounce (fileEnum.CurrentString)) {
                        AnnounceFileInReport (fileEnum.CurrentString, (DWORD)Context, ACT_MINORPROBLEMS);
                    }
                } else {
                    MarkFileForExternalDelete (fileEnum.CurrentString);
                    if (!IsFileMarkedForAnnounce (fileEnum.CurrentString)) {
                        AnnounceFileInReport (fileEnum.CurrentString, (DWORD)Context, ACT_INCOMPATIBLE);
                    }
                }

                HandleDeferredAnnounce (NULL, fileEnum.CurrentString, TRUE);

                AtLeastOneFile = TRUE;

                if (*g_Boot16 == BOOT16_AUTOMATIC) {
                    *g_Boot16 = BOOT16_YES;
                }
            }
        } while (EnumNextMultiSz (&fileEnum));
    }

    return AtLeastOneFile;
}


BOOL
pNoLinkRequiredWorker (
    IN      UINT GroupId,
    IN      UINT SubGroupId,            OPTIONAL
    IN      DWORD ActionType,
    IN      PMIGDB_CONTEXT Context
    )
{
    MULTISZ_ENUM e;
    PCTSTR Group;
    PCTSTR RootGroup;
    PCTSTR SubGroup;
    PCTSTR GroupTemp;
    BOOL result = FALSE;

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {
        do {
            if (!IsFileMarkedAsKnownGood (e.CurrentString)) {
                result = TRUE;
            }
        } while (EnumNextMultiSz (&e));
    }
    if (!result) {
        return FALSE;
    }

    //
    // Add the message using section name as the context
    //

    if (!Context->SectNameForDisplay) {
        DEBUGMSG ((DBG_WHOOPS, "Rule for %s needs a localized app title", Context->SectName));
        return TRUE;
    }

    RootGroup = GetStringResource (GroupId);

    if (!RootGroup) {
        LOG((LOG_ERROR, "Cannot get resources while processing section %s", Context->SectNameForDisplay));
        return TRUE;
    }

    //
    // Now fetch the group string, and optional subgroup string,
    // and join them together
    //

    if (SubGroupId) {

        SubGroup = GetStringResource (SubGroupId);
        MYASSERT (SubGroup);

        GroupTemp = JoinPaths (RootGroup, SubGroup);
        Group = JoinPaths (GroupTemp, Context->SectNameForDisplay);
        FreePathString (GroupTemp);

    } else {

        Group = JoinPaths (RootGroup, Context->SectNameForDisplay);
    }

    FreeStringResource (RootGroup);

    //
    // Put the message in msgmgr
    //

    MsgMgr_ContextMsg_Add (
        Context->SectName,
        Group,
        Context->Message
        );

    FreePathString (Group);

    //
    // Associate all files with the context
    //

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {
        do {
            if (ActionType != ACT_MINORPROBLEMS) {
                MarkFileForExternalDelete (e.CurrentString);
            }
            if (!IsFileMarkedForAnnounce (e.CurrentString)) {
                AnnounceFileInReport (e.CurrentString, (DWORD)Context, ActionType);
            }
            MsgMgr_LinkObjectWithContext (
                Context->SectName,
                e.CurrentString
                );
        } while (EnumNextMultiSz (&e));
    }

    return TRUE;
}


BOOL
Reinstall_NoLinkRequired (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an app that should be reinstalled on NT. The
  message is added to the report whenever the action is triggered; no link is required.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    return pNoLinkRequiredWorker (
                MSG_REINSTALL_ROOT,
                Context->Message ? MSG_REINSTALL_DETAIL_SUBGROUP : MSG_REINSTALL_LIST_SUBGROUP,
                ACT_REINSTALL,
                Context
                );
}


BOOL
Reinstall_SoftBlock (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an app that should be reinstalled on NT. The
  message is added to the report whenever the action is triggered; no link is required.
  In addition, the user must uninstall the app before proceeding.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM e;

    //
    // Add all files to blocking hash table in msgmgr
    //

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {
        do {
            if (!IsFileMarkedAsKnownGood (e.CurrentString)) {
                AddBlockingObject (e.CurrentString);
            }
        } while (EnumNextMultiSz (&e));
    }
    return pNoLinkRequiredWorker (MSG_BLOCKING_ITEMS_ROOT, MSG_REINSTALL_BLOCK_ROOT, ACT_REINSTALL_BLOCK, Context);
}


BOOL
Incompatible_NoLinkRequired (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an app that is incompatible with NT. The
  message is added to the report whenever the action is triggered; no link is required.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    return pNoLinkRequiredWorker (
                MSG_INCOMPATIBLE_ROOT,
                Context->Message ? MSG_INCOMPATIBLE_DETAIL_SUBGROUP : MSG_TOTALLY_INCOMPATIBLE_SUBGROUP,
                ACT_INC_NOBADAPPS,
                Context
                );
}

BOOL
MinorProblems_NoLinkRequired (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an app that is incompatible with NT. The
  message is added to the report whenever the action is triggered; no link is required.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    return pNoLinkRequiredWorker (
                MSG_MINOR_PROBLEM_ROOT,
                0,
                ACT_MINORPROBLEMS,
                Context
                );
}


BOOL
CompatibleShellModules (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an "known good" shell module. Those modules are
  therefore approved to be listed in SHELL= line in SYSTEM.INI.

Arguments:

  Context - See definition.

Return value:

  FALSE - this will allow other actions to handle this file

--*/

{
    MULTISZ_ENUM fileEnum;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
        do {
            AddCompatibleShell (fileEnum.CurrentString, (DWORD)Context);
        }
        while (EnumNextMultiSz (&fileEnum));
    }
    return FALSE;
}


BOOL
CompatibleRunKeyModules (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an "known good" RunKey module. Those modules are
  therefore approved to be listed in Run key.

Arguments:

  Context - Specifies a pointer to the migdb context

Return value:

  FALSE - this will allow other actions to handle this file

--*/

{
    MULTISZ_ENUM fileEnum;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
        do {
            AddCompatibleRunKey (fileEnum.CurrentString, (DWORD)Context);
        } while (EnumNextMultiSz (&fileEnum));
    }

    return FALSE;
}


BOOL
CompatibleDosModules (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an "known good" Dos module. Those modules are
  therefore approved to be loaded in autoexec and config files.

Arguments:

  Context - Specifies a pointer to the migdb context

Return value:

  FALSE - this will allow other actions to handle this file

--*/

{
    MULTISZ_ENUM fileEnum;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
        do {
            AddCompatibleDos (fileEnum.CurrentString, (DWORD)Context);
        } while (EnumNextMultiSz (&fileEnum));
    }

    return FALSE;
}

VOID
pCommonSectionProcess (
    IN      PMIGDB_CONTEXT Context,
    IN      BOOL MsgLink
    )
{
    MULTISZ_ENUM e;
    TCHAR Path[MAX_TCHAR_PATH];
    PTSTR p;

    //
    // Defer processing: add the section to memdb so the section is processed only once.
    //

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {

        do {

            //
            // Construct just the path
            //

            StringCopy (Path, e.CurrentString);
            p = (PTSTR) GetFileNameFromPath (Path);

            // Path is a full path so GetFileNameFromPath will always return something
            if (p) {

                p = _tcsdec2 (Path, p);

                // p will always be not NULL and will point to the last wack
                if (p && (*p == '\\')) {

                    *p = 0;

                    MemDbSetValueExA (
                        MEMDB_CATEGORY_MIGRATION_SECTION,
                        Context->Arguments,
                        Path,
                        NULL,
                        0,
                        NULL
                        );

                    if (MsgLink) {
                        MsgMgr_LinkObjectWithContext (
                            Context->Arguments,
                            e.CurrentString
                            );
                    }
                }
            }

      } while (EnumNextMultiSz (&e));
   }
}

BOOL
Incompatible_AutoUninstall (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  Incompatible_AutoUninstall implements the action taken when we find a particular app and
  need to process an uninstall section.  The uninstall section removes files or
  registry entries. This application will also be announced in the report as incompatible.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    PCTSTR Group;

    if (!Context->Arguments) {
        DEBUGMSG ((DBG_WHOOPS, "Incompatible_AutoUninstall: ARG is required"));
        return TRUE;
    }

    Group = BuildMessageGroup (
                MSG_INCOMPATIBLE_ROOT,
                MSG_AUTO_UNINSTALL_SUBGROUP,
                Context->SectNameForDisplay
                );
    if (Group) {

        MsgMgr_ContextMsg_Add (
            Context->Arguments,
            Group,
            S_EMPTY
            );

        FreeText (Group);
    }

    pCommonSectionProcess (Context, TRUE);

    return TRUE;
}


BOOL
Reinstall_AutoUninstall (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  Reinstall_AutoUninstall implements the action taken when we find a particular app and
  need to process an uninstall section.  The uninstall section removes files or
  registry entries. This application will also be announced in the report as reinstall.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    PCTSTR Group;

    if (!Context->Arguments) {
        DEBUGMSG ((DBG_WHOOPS, "Reinstall_AutoUninstall: ARG is required"));
        return TRUE;
    }

    Group = BuildMessageGroup (
                MSG_REINSTALL_ROOT,
                Context->Message ? MSG_REINSTALL_DETAIL_SUBGROUP : MSG_REINSTALL_LIST_SUBGROUP,
                Context->SectNameForDisplay
                );
    if (Group) {

        MsgMgr_ContextMsg_Add (
            Context->Arguments,
            Group,
            S_EMPTY
            );

        FreeText (Group);
    }

    pCommonSectionProcess (Context, TRUE);

    return TRUE;
}


BOOL
SilentUninstall (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  SilentUninstall implements the action taken when we find a particular app and
  need to process an uninstall section.  The uninstall section removes files or
  registry entries. No message goes in the report.

Arguments:

  Context - See definition.

Return value:

  Always FALSE - other actions should be processed

--*/

{
    if (!Context->Arguments) {
        DEBUGMSG ((DBG_WHOOPS, "SilentUninstall: ARG is required"));
        return FALSE;
    }

    //
    // Defer processing: add the section to memdb so the section is processed only once.
    //

    pCommonSectionProcess (Context, FALSE);

    return FALSE;
}


BOOL
FileEdit (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  FileEdit triggers a file edit operation, allowing search/replace and path
  updates.

Arguments:

  Context - Specifies the context of the migdb.inf entry that triggered this
            action

Return Value:

  Always FALSE - allow other actions to be called

--*/

{
    MULTISZ_ENUM e;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCSTR Data;
    GROWBUFFER SearchList = GROWBUF_INIT;
    GROWBUFFER ReplaceList = GROWBUF_INIT;
    GROWBUFFER TokenArgBuf = GROWBUF_INIT;
    GROWBUFFER TokenSetBuf = GROWBUF_INIT;
    GROWBUFFER DataBuf = GROWBUF_INIT;
    UINT u;
    PTOKENARG TokenArg;
    PBYTE Dest;
    PTOKENSET TokenSet;
    PCSTR editSection = NULL;
    PCSTR CharsToIgnore = NULL;
    BOOL urlMode = FALSE;
    BOOL result = FALSE;

    __try {
        //
        // If no args, then this file is just supposed to get its paths updated
        //

        if (!Context->Arguments) {
            if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {

                do {
                    MemDbSetValueEx (
                        MEMDB_CATEGORY_FILEEDIT,
                        e.CurrentString,
                        NULL,
                        NULL,
                        0,
                        NULL
                        );

                } while (EnumNextMultiSz (&e));
            }

            return FALSE;
        }

        //
        // Scan the args for EnableUrlMode
        //

        if (EnumFirstMultiSz (&e, Context->Arguments)) {
            do {
                if (StringIMatch (e.CurrentString, TEXT("EnableUrlMode"))) {
                    urlMode = TRUE;
                } else if (!editSection) {
                    editSection = e.CurrentString;
                    DEBUGMSG ((DBG_NAUSEA, "FileEdit: EditSection is %s", editSection));
                } else if (!CharsToIgnore) {
                    CharsToIgnore = e.CurrentString;
                    DEBUGMSG ((DBG_NAUSEA, "FileEdit: CharsToIgnore is %s", CharsToIgnore));
                } else {
                    DEBUGMSG ((DBG_WHOOPS, "Ignoring extra file edit arg %s", e.CurrentString));
                }
            } while (EnumNextMultiSz (&e));
        }

        //
        // Parse the edit section
        //

        if (editSection) {
            if (InfFindFirstLine (g_MigDbInf, editSection, NULL, &is)) {

                do {

                    ReplaceList.End = 0;
                    SearchList.End = 0;

                    //
                    // Get the search/replace strings
                    //

                    for (u = 3 ; ; u += 2) {

                        Data = InfGetStringField (&is, u + 1);
                        if (!Data) {
                            break;
                        }

                        MYASSERT (*Data);
                        if (*Data == 0) {
                            continue;
                        }

                        MultiSzAppend (&ReplaceList, Data);

                        Data = InfGetStringField (&is, u);
                        MYASSERT (Data && *Data);
                        if (!Data || *Data == 0) {
                            __leave;
                        }

                        MultiSzAppend (&SearchList, Data);

                    }

                    //
                    // Get the detection string
                    //

                    Data = InfGetStringField (&is, 1);

                    if (Data && *Data) {
                        //
                        // Save the token arg into an array
                        //

                        TokenArg = (PTOKENARG) GrowBuffer (&TokenArgBuf, sizeof (TOKENARG));
                        TokenArg->DetectPattern = (PCSTR) (DataBuf.End + TOKEN_BASE_OFFSET);
                        GrowBufCopyString (&DataBuf, Data);

                        if (SearchList.End) {
                            MultiSzAppend (&SearchList, TEXT(""));

                            TokenArg->SearchList = (PCSTR) (DataBuf.End + TOKEN_BASE_OFFSET);
                            Dest = GrowBuffer (&DataBuf, SearchList.End);
                            CopyMemory (Dest, SearchList.Buf, SearchList.End);

                            MultiSzAppend (&ReplaceList, TEXT(""));

                            TokenArg->ReplaceWith = (PCSTR) (DataBuf.End + TOKEN_BASE_OFFSET);
                            Dest = GrowBuffer (&DataBuf, ReplaceList.End);
                            CopyMemory (Dest, ReplaceList.Buf, ReplaceList.End);

                        } else {

                            TokenArg->SearchList = 0;
                            TokenArg->ReplaceWith = 0;

                        }

                        Data = InfGetStringField (&is, 2);
                        if (_tcstoul (Data, NULL, 10)) {
                            TokenArg->UpdatePath = TRUE;
                        } else {
                            TokenArg->UpdatePath = FALSE;
                        }
                    }

                } while (InfFindNextLine (&is));
            }
            ELSE_DEBUGMSG ((DBG_WHOOPS, "FileEdit action's section %s does not exist", editSection));

        } else if (urlMode) {
            //
            // Create an argument that has a detect pattern of *
            //

            TokenArg = (PTOKENARG) GrowBuffer (&TokenArgBuf, sizeof (TOKENARG));
            TokenArg->DetectPattern = (PCSTR) (DataBuf.End + TOKEN_BASE_OFFSET);
            GrowBufCopyString (&DataBuf, TEXT("*"));

            TokenArg->SearchList = NULL;
            TokenArg->ReplaceWith = NULL;
            TokenArg->UpdatePath = TRUE;
        }

        //
        // Build a token set out of the token args
        //

        if (TokenArgBuf.End) {
            TokenSet = (PTOKENSET) GrowBuffer (
                                        &TokenSetBuf,
                                        sizeof (TOKENSET) +
                                            TokenArgBuf.End +
                                            DataBuf.End
                                        );

            TokenSet->ArgCount = TokenArgBuf.End / sizeof (TOKENARG);
            TokenSet->SelfRelative = TRUE;
            TokenSet->UrlMode = urlMode;

            if (CharsToIgnore) {
                TokenSet->CharsToIgnore = (PCSTR) (DataBuf.End + TOKEN_BASE_OFFSET);
                GrowBufCopyString (&TokenSetBuf, CharsToIgnore);
            } else {
                TokenSet->CharsToIgnore = NULL;
            }

            CopyMemory (TokenSet->Args, TokenArgBuf.Buf, TokenArgBuf.End);
            CopyMemory (
                (PBYTE) (TokenSet->Args) + TokenArgBuf.End,
                DataBuf.Buf,
                DataBuf.End
                );

            //
            // Save TokenSet to memdb
            //

            if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {

                do {
                    MemDbSetBinaryValueEx (
                        MEMDB_CATEGORY_FILEEDIT,
                        e.CurrentString,
                        NULL,
                        TokenSetBuf.Buf,
                        TokenSetBuf.End,
                        NULL
                        );

                    if (g_ConfigOptions.EnableBackup) {
                        MarkFileForBackup (e.CurrentString);
                    }

                } while (EnumNextMultiSz (&e));
            }
        }

        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (&is);
        FreeGrowBuffer (&SearchList);
        FreeGrowBuffer (&ReplaceList);
        FreeGrowBuffer (&TokenArgBuf);
        FreeGrowBuffer (&TokenSetBuf);
        FreeGrowBuffer (&DataBuf);
    }

    return result;
}



BOOL
MigrationProcessing (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  MigrationProcessing implements the action taken when we find a particular app and
  we need some migration DLL like processing to go on.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    if (!Context->Arguments) {
        DEBUGMSG ((DBG_WHOOPS, "MigrationProcessing: ARG is required"));
        return TRUE;
    }

    //
    // Defer processing: add the section to memdb so the section is processed only once.
    //

    pCommonSectionProcess (Context, FALSE);

    return TRUE;
}


BOOL
NonPnpDrivers (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  NonPnpDrivers adds hardware incompatibility messages for incompatible
  devices found by identifying drivers.

Arguments:

  Context - Specifies the context of the file found.

Return Value:

  Always TRUE.

--*/

{
    PCTSTR Group;
    PCTSTR GroupRoot;
    MULTISZ_ENUM e;
    TCHAR MsgMgrContext[256];
    PCTSTR OtherDevices;

    MYASSERT (Context->SectNameForDisplay);

    //
    // Add MemDb entry, so .386 check code knows about this file
    //

    NonPnpDrivers_NoMessage (Context);

    //
    // Add incompatibility message to Hardware.  This involves decorating
    // the device driver name and using a context prefix of NonPnpDrv.
    //

    OtherDevices = GetStringResource (MSG_UNKNOWN_DEVICE_CLASS);
    if (!OtherDevices) {
        MYASSERT (FALSE);
        return FALSE;
    }

    GroupRoot = BuildMessageGroup (
                    MSG_INCOMPATIBLE_HARDWARE_ROOT,
                    MSG_INCOMPATIBLE_HARDWARE_PNP_SUBGROUP,
                    OtherDevices
                    );

    FreeStringResource (OtherDevices);

    if (!GroupRoot) {
        MYASSERT (FALSE);
        return FALSE;
    }

    Group = JoinPaths (GroupRoot, Context->SectNameForDisplay);
    FreeText (GroupRoot);

    MYASSERT (TcharCount (Context->SectName) < 240);
    StringCopy (MsgMgrContext, TEXT("*NonPnpDrv"));
    StringCat (MsgMgrContext, Context->SectName);

    MsgMgr_ContextMsg_Add (MsgMgrContext, Group, NULL);

    FreePathString (Group);

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {
        do {
            MsgMgr_LinkObjectWithContext (
                MsgMgrContext,
                e.CurrentString
                );

        } while (EnumNextMultiSz (&e));
    }

    return TRUE;
}


BOOL
NonPnpDrivers_NoMessage (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  NonPnpDrivers_NoMessage marks a device driver file as known, so the .386
  warning does not appear because of it.

Arguments:

  Context - Specifies the context of the file found.

Return Value:

  Always TRUE.

--*/

{
    MULTISZ_ENUM e;

    MYASSERT (Context->SectNameForDisplay);

    //
    // Add MemDb entry, so .386 check code knows about this file
    //

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {
        do {
            DeleteFileWithWarning (e.CurrentString);
        } while (EnumNextMultiSz (&e));
    }

    return TRUE;
}


extern HWND g_Winnt32Wnd;


BOOL
RequiredOSFiles (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is for now the only action function that's called when the associated action was
  not triggered during the file scan.
  We need to know that we are upgrading a known OS so this function is called when none
  of the required files were found. The action taken is warning the user and terminating
  the upgrade.

Arguments:

  Context - See definition.

Return value:

  TRUE  - Always

--*/

{
    PCTSTR group = NULL;
    PCTSTR message = NULL;


    if ((!g_ConfigOptions.AnyVersion) && (!CANCELLED ())) {

        //
        // Add a message to the Incompatibility Report.
        //

        g_UnknownOs = TRUE;
        group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_UNKNOWN_OS_WARNING_SUBGROUP, NULL);
        message = GetStringResource (MSG_UNKNOWN_OS);

        if (message && group) {
            MsgMgr_ObjectMsg_Add (TEXT("*UnknownOs"), group, message);
        }
        FreeText (group);
        FreeStringResource (message);


    }
    return TRUE;
}



BOOL
CompatibleHlpFiles (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when we found an "known good" HLP file. We do this to prevent
  help file checking routines from announcing it as incompatible.

Arguments:

  Context - See definition.

Return value:

  FALSE - this will allow other actions to handle this file

--*/

{
    MULTISZ_ENUM fileEnum;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
        do {
            AddCompatibleHlp (fileEnum.CurrentString, (DWORD)Context);
        } while (EnumNextMultiSz (&fileEnum));
    }

    return FALSE;
}



BOOL
BlockingVirusScanner (
    IN      PMIGDB_CONTEXT Context
    )
{
    MULTISZ_ENUM fileEnum;
    PCTSTR message = NULL;
    PCTSTR button1 = NULL;
    PCTSTR button2 = NULL;
    PCSTR args[1];
    BOOL bStop;

    if (EnumFirstMultiSz (&fileEnum, Context->FileList.Buf)) {
        do {

            //
            // Inform the user of the problem.
            //
            args[0] = Context -> Message;
            bStop = (Context->Arguments && StringIMatch (Context->Arguments, TEXT("1")));

            if (bStop) {

                ResourceMessageBox (
                        g_ParentWnd,
                        MSG_BAD_VIRUS_SCANNER_STOP,
                        MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                        args
                        );
                g_BadVirusScannerFound = TRUE;

            } else {
                message = ParseMessageID (MSG_BAD_VIRUS_SCANNER, args);
                button1 = GetStringResource (MSG_KILL_APPLICATION);
                button2 = GetStringResource (MSG_QUIT_SETUP);
                if (!UNATTENDED() && IDBUTTON1 != TwoButtonBox (g_ParentWnd, message, button1, button2)) {

                    g_BadVirusScannerFound = TRUE;
                }
                else {

                    //
                    // Add the string to the list of files to be
                    // to be terminated.
                    //
                    GrowListAppendString (
                        &g_BadVirusScannerGrowList,
                        Context->FileList.Buf
                        );

                }
                FreeStringResource (message);
                FreeStringResource (button1);
                FreeStringResource (button2);
            }
        }
        while (EnumNextMultiSz (&fileEnum));
    }

    return TRUE;
}


BOOL
BlockingFile (
    IN      PMIGDB_CONTEXT Context
    )
{

    MULTISZ_ENUM  e;
    PCTSTR group;
    BOOL result = FALSE;

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {
        do {
            if (!IsFileMarkedAsKnownGood (e.CurrentString)) {

                result = TRUE;
                DEBUGMSG ((DBG_WARNING, "BLOCKINGFILE: Found file %s which blocks upgrade.", e.CurrentString));
                group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_MUST_UNINSTALL_ROOT, Context->SectNameForDisplay);
                MsgMgr_ObjectMsg_Add (e.CurrentString, group, Context->Message);
                FreeText (group);

                g_BlockingFileFound = TRUE;
            }

        } while (EnumNextMultiSz (&e));
    }

    return result;
}

BOOL
BlockingHardware (
    IN      PMIGDB_CONTEXT Context
    )
{

    MULTISZ_ENUM  e;
    PCTSTR group;

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {
        do {

            DEBUGMSG ((DBG_WARNING, "BLOCKINGHARDWARE: Found file %s which blocks upgrade.", e.CurrentString));

            group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_BLOCKING_HARDWARE_SUBGROUP, Context->SectNameForDisplay);
            MsgMgr_ObjectMsg_Add (e.CurrentString, group, Context->Message);
            FreeText (group);

            g_BlockingHardwareFound = TRUE;

        } while (EnumNextMultiSz (&e));
    }

    return TRUE;
}



BOOL
CompatibleFiles (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when an application file is considered good. Later, if we find
  a link that points to a file that's not in this section, we will announce the link as
  "unknown".

Arguments:

  Context - See definition.

Return value:

  FALSE - this will allow other actions to handle this file

--*/

{
    MULTISZ_ENUM e;

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {
        do {
            MarkFileAsKnownGood (e.CurrentString);
        } while (EnumNextMultiSz (&e));
    }

    return FALSE;
}


BOOL
StoreMapi32Locations (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken for files related to MAPI32. We keep the locations
  in a list, so we can later detect whether MAPI is handled or not.  If it
  is not handled, then we must tell the user they will lose e-mail functionality.

Arguments:

  Context - See definition.

Return value:

  FALSE - this will allow other actions to handle this file

--*/

{
    MULTISZ_ENUM e;

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {

        do {
            MemDbSetValueEx (
                MEMDB_CATEGORY_MAPI32_LOCATIONS,
                e.CurrentString,
                NULL,
                NULL,
                0,
                NULL
                );

        } while (EnumNextMultiSz (&e));
    }
    return FALSE;
}



BOOL
ProductCollisions (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  ProductCollisions identifies files that are known good but match an NT
  system file name.  In this case, we want one file to be treated as an OS
  file (the one in %windir% for example), while another file needs to be
  treated as an application file (the one in the app dir for example).  Here
  we get called only when the application files are found.

Arguments:

  Context - Specifies the current file context

Return Value:

  Always TRUE.

--*/

{
    return TRUE;
}


BOOL
MarkForBackup (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  MarkForBackup puts a backup operation on the file, unless backup is turned
  off.

Arguments:

  Context - Specifies the current file context

Return Value:

  Always TRUE.

--*/

{
    MULTISZ_ENUM e;

    if (g_ConfigOptions.EnableBackup) {
        if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {

            do {
                MarkFileForBackup (e.CurrentString);
            } while (EnumNextMultiSz (&e));
        }
    }

    return TRUE;
}


BOOL
ShowInSimplifiedView (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  ShowInSimplifiedView records the file with message manager, so that
  the list view will show the incompatibility.

Arguments:

  Context - Specifies the current file context

Return Value:

  Always FALSE, so other actions can process the file.

--*/

{
    MULTISZ_ENUM e;

    if (g_ConfigOptions.ShowReport == TRISTATE_PARTIAL) {
        if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {

            do {
                ElevateObject (e.CurrentString);
                DEBUGMSG ((DBG_VERBOSE, "Elevated %s to the short view", e.CurrentString));
            } while (EnumNextMultiSz (&e));
        }
    }

    return FALSE;
}


BOOL
IniFileMappings (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  IniFileMappings records the locations of all INI files, so they
  can be processed during GUI mode.

Arguments:

  Context - See definition.

Return value:

  FALSE - this will allow other actions to handle this file

--*/

{
    MULTISZ_ENUM e;

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {

        do {
            MemDbSetValueEx (
                MEMDB_CATEGORY_INIFILES_CONVERT,
                e.CurrentString,
                NULL,
                NULL,
                0,
                NULL
                );

        } while (EnumNextMultiSz (&e));
    }
    return FALSE;
}


BOOL
IgnoreInReport (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  IgnoreInReport handles a file so that it will not appear in the
  upgrade report. Currently this action is only for Office FindFast
  version 9 and higher.  Random results are likely with any other
  type of file.

Arguments:

  Context - See definition.

Return value:

  FALSE - this will allow other actions to handle this file

--*/

{
    MULTISZ_ENUM e;

    if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {

        do {

            HandleObject (e.CurrentString, TEXT("Report"));

        } while (EnumNextMultiSz (&e));
    }

    return FALSE;
}


BOOL
BadFusion (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  BadFusion removes known bad library files found in fusion dirs.

Arguments:

  Context - See definition.

Return value:

  FALSE - this will allow other actions to handle this file

--*/

{
    MULTISZ_ENUM e;
    TCHAR exeName[MAX_TCHAR_PATH * 2];
    TCHAR localFile[MAX_TCHAR_PATH * 2];
    PTSTR filePtr;
    HANDLE h;
    WIN32_FIND_DATA fd;
    DWORD type;
    BOOL b = FALSE;

    if (g_IsFusionDir) {

        if (EnumFirstMultiSz (&e, Context->FileList.Buf)) {

            do {
                if (IsFileMarkedForDelete (e.CurrentString)) {
                    continue;
                }

                if (SizeOfString (e.CurrentString) > sizeof (exeName)) {
                    MYASSERT (FALSE);
                    continue;
                }
                StringCopy (exeName, e.CurrentString);

                filePtr = (PTSTR)GetFileNameFromPath (exeName);
                if (!filePtr) {
                    MYASSERT (FALSE);
                    continue;
                }

                //
                // make full path to app
                //
                StringCopy (filePtr, Context->Arguments);

                //
                // and to .local
                //
                StringCopyAB (localFile, exeName, filePtr);
                filePtr = GetEndOfString (localFile);

                //
                // check if this is really a fusion case;
                // both a file "exeName" and a file or dir (bug?) "exeName.local"
                // must be present
                //
                h = FindFirstFile (exeName, &fd);
                if (h == INVALID_HANDLE_VALUE) {
                    continue;
                }
                do {
                    if (fd.cFileName[0] == TEXT('.') &&
                        (fd.cFileName[1] == 0 || fd.cFileName[1] == TEXT('.') && fd.cFileName[2] == 0)
                        ) {
                        continue;
                    }
                    *filePtr = 0;
                    StringCopy (StringCat (filePtr, fd.cFileName), TEXT(".local"));

                    if (DoesFileExist (localFile)) {
                        type = GetExeType (localFile);
                        if ((type == EXE_WIN32_APP) || (type == EXE_WIN16_APP)) {
                            b = TRUE;
                            break;
                        }
                    }

                } while (FindNextFile (h, &fd));
                FindClose (h);

                if (b) {
                    RemoveOperationsFromPath (e.CurrentString, ALL_OPERATIONS);
                    MarkFileForDelete (e.CurrentString);
                    LOG ((
                        LOG_WARNING,
                        "BadFusion: removed known bad component %s in fusion dir",
                        e.CurrentString
                        ));
                }

            } while (EnumNextMultiSz (&e));
        }
    }
    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\helpers.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    helpers.c

Abstract:

    Implements a set of functions that are called for every
    file or directory (before and after the AppDb processing).

Author:

    Calin Negreanu (calinn) 21-Nov-1997

Revision History:

    ovidiut     14-Feb-2000 Added support for fusion
    ovidiut     10-May-1999 Added GatherIniFiles (support for INI actions)
    jimschm     07-Jan-1999 CPLs are now known-good migration
    jimschm     23-Sep-1998 Cleanup for new fileops

--*/

#include "pch.h"
#include "migdbp.h"
#include "migappp.h"

/*++

Macro Expansion List Description:

  HELPER_FUNCTIONS contains a list of functions called for each file and directory
  during file scanning.

Line Syntax:

   DEFMAC(HelperName, HelperId)

Arguments:

   HelperName - this is the helper function. You must implement a function with this
                name and required parameters.

   HelperId   - this is the helper id. If your function handles the file it should
                update that in Params structure.

   CanHandleVirtualFiles - this is for enumerating some files that might not be on the
                system but we want them to be processed as if they were. A good example
                is backup.exe which must be replaced by ntbackup.exe. If the file is not
                on the system, all registry settings pointing to it will not be changed.

Variables Generated From List:

   g_HelperFunctionList - defined in helpers.c

--*/

#define HELPER_FUNCTIONS        \
        DEFMAC(IsFusionDir,             IS_FUSION_DIR,      FALSE)   \
        DEFMAC(MigDbTestFile,           MIGDB_TEST_FILE,    TRUE )   \
        DEFMAC(CheckOsFiles,            CHECK_OS_FILES,     FALSE)   \
        DEFMAC(pStoreCPLs,              STORE_CPL,          FALSE)   \
        DEFMAC(pCheckCpl,               CHECK_CPL,          FALSE)   \
        DEFMAC(pSetupTableFileHelper,   SETUP_TABLE_FILE,   FALSE)   \
        DEFMAC(ProcessHelpFile,         TEST_HELP_FILES,    FALSE)   \
        DEFMAC(SaveExeFiles,            SAVE_EXE_FILES,     FALSE)   \
        DEFMAC(SaveLinkFiles,           SAVE_LNK_FILES,     FALSE)   \
        DEFMAC(pGatherDunFiles,         GATHER_DUN_FILES,   FALSE)   \
        DEFMAC(pMigrationDllNotify,     MIGRATION_DLL,      FALSE)   \
        DEFMAC(GatherBriefcases,        GATHER_BRIEFCASES,  FALSE)   \
        DEFMAC(GatherIniFiles,          GATHER_INI_FILES,   FALSE)   \
        DEFMAC(TestNtFileName,          TEST_NT_FILE_NAME,  FALSE)   \
        DEFMAC(BackUpIsuFiles,          BACKUP_ISU_FILES,   FALSE)   \
        DEFMAC(EditHtmlFiles,           EDIT_HTML_FILES,    FALSE)   \

#if 0

        //
        // the appcompat team doesn't support "APPMIG.INF" any longer
        // and they requested us to no longer depend on it
        //
        DEFMAC(AppCompatTestFile,       APPCOMPAT_TEST_FILE,FALSE)   \

#endif

#define DEFMAC(fn,id,can)   id,
typedef enum {
    START_OF_LIST,
    HELPER_FUNCTIONS
    END_OF_LIST
} HELPER_FUNCTIONS_ID;
#undef DEFMAC

//
// Declare a global array of function pointers
//
typedef BOOL (HELPER_PROTOTYPE) (PFILE_HELPER_PARAMS p);

typedef HELPER_PROTOTYPE *PHELPER_PROTOTYPE;

/*
   Declare the helper functions
*/
#define DEFMAC(fn,id,can) HELPER_PROTOTYPE fn;
HELPER_FUNCTIONS
#undef DEFMAC

/*
   This is the structure used for handling helper functions
*/
typedef struct {
    PCSTR HelperName;
    PHELPER_PROTOTYPE HelperFunction;
    BOOL CanHandleVirtualFiles;
} HELPER_STRUCT, *PHELPER_STRUCT;

/*
   Declare a global array of functions and name identifiers for helper functions
*/
#define DEFMAC(fn,id,can) {#id, fn, can},
static HELPER_STRUCT g_HelperFunctions[] = {
                              HELPER_FUNCTIONS
                              {NULL, NULL, FALSE}
                              };
#undef DEFMAC

extern BOOL g_IsFusionDir;

BOOL
ProcessFileHelpers (
    IN OUT  PFILE_HELPER_PARAMS Params
    )
/*++

Routine Description:

  Calls every helper function listed in the macro expansion list.
  If a helper function returns FALSE, this function returns FALSE.

Arguments:

  Params - Specifies the parameters for the current object

Return Value:

  TRUE if success, FALSE if failure.

--*/
{
    PHELPER_STRUCT currentHelper = g_HelperFunctions;
#ifdef DEBUG
    BOOL InterestingFile;
    TCHAR DbgBuf[32];

    //
    // Check if this file is in [FilesToTrack] inside debug.inf
    //

    GetPrivateProfileString ("FilesToTrack", Params->FullFileSpec, "", DbgBuf, ARRAYSIZE(DbgBuf), g_DebugInfPath);
    if (!(*DbgBuf) && Params->FindData) {
        GetPrivateProfileString ("FilesToTrack", Params->FindData->cFileName, "", DbgBuf, ARRAYSIZE(DbgBuf), g_DebugInfPath);
    }

    InterestingFile = (*DbgBuf != 0);

#endif

    while (currentHelper->HelperFunction) {

        if ((!Params->VirtualFile) ||
            (currentHelper->CanHandleVirtualFiles)
            ) {

#ifdef DEBUG

            if (InterestingFile) {
                DEBUGMSG ((
                    DBG_TRACK,
                    "Calling %s for %s",
                    currentHelper->HelperName,
                    Params->FullFileSpec
                    ));
            }
#endif

            if (!currentHelper->HelperFunction (Params)) {

#ifdef DEBUG

                if (InterestingFile) {
                    DEBUGMSG ((
                        DBG_TRACK,
                        "%s failed for %s",
                        currentHelper->HelperName,
                        Params->FullFileSpec
                        ));
                }
#endif

                return FALSE;
            }

#ifdef DEBUG

            if (InterestingFile) {
                DEBUGMSG ((
                    DBG_TRACK,
                    "%s returned, Handled = %u (0x%08X)",
                    currentHelper->HelperName,
                    Params->Handled
                    ));
            }
#endif

        }
        currentHelper++;
    }

    return TRUE;
}



BOOL
pGatherDunFiles (
    IN OUT PFILE_HELPER_PARAMS Params
    )
/*++

Routine Description:

  pGatherDunFiles adds a memdb entry for any file that has an extension
  of .DUN, and then sets the HandledBy type to GATHER_DUN_FILES.

Arguments:

  Params - Specifies the file enumeration parameters

Return Value:

  TRUE if success, FALSE if failure.

--*/

{

    if (StringIMatch (Params->Extension, TEXT(".DUN"))) {
        MemDbSetValueEx (MEMDB_CATEGORY_DUN_FILES, Params->FullFileSpec, NULL, NULL, 0, NULL);
        Params->Handled = GATHER_DUN_FILES;
    }

    return TRUE;

}


BOOL
pSetupTableFileHelper (
    IN OUT  PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  pSetupTableFileHelper adds a memdb entry for any file that has an extension
  of .STF, and then sets the HandledBy type to SETUP_TABLE_FILE.

Arguments:

  Params - Specifies the file enumeration parameters

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    if (StringIMatch (Params->Extension, TEXT(".STF"))) {
        MemDbSetValueEx (MEMDB_CATEGORY_STF, Params->FullFileSpec, NULL, NULL, 0, NULL);
        Params->Handled = SETUP_TABLE_FILE;
        MarkFileForBackup (Params->FullFileSpec);
    }

    return TRUE;
}


BOOL
pMigrationDllNotify (
    IN OUT  PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  pMigrationDllNotify calls the migration DLL code to update any DLL that
  wants to know where a particular file is on the system.

Arguments:

  Params - Specifies the file enumeration parameters

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    if (!Params->VirtualFile) {
        MYASSERT (Params->FindData);

        if (!(Params->IsDirectory)) {
            if (!UpdateFileSearch (Params->FullFileSpec, Params->FindData->cFileName)) {
                DEBUGMSG ((DBG_WARNING, "UpdateFileSearch returned FALSE"));
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
pStoreCPLs (
    IN OUT  PFILE_HELPER_PARAMS Params
    )
{
    PCTSTR ModuleExt;

    ModuleExt = GetFileExtensionFromPath (Params->FullFileSpec);

    if ((ModuleExt) && (StringIMatch (ModuleExt, TEXT("CPL")))) {

        MemDbSetValueEx (
            MEMDB_CATEGORY_CPLS,
            Params->FullFileSpec,
            NULL,
            NULL,
            0,
            NULL
            );
    }

    return TRUE;
}

BOOL
pCheckCpl (
    IN OUT  PFILE_HELPER_PARAMS Params
    )
{
    DWORD Status;
    PCTSTR ModuleExt;

    if (Params->Handled == 0) {

        ModuleExt = GetFileExtensionFromPath (Params->FullFileSpec);

        if ((ModuleExt) && (StringIMatch (ModuleExt, TEXT("CPL")))) {

            if (!IsFileMarkedAsKnownGood (Params->FullFileSpec)) {

                //
                // Delete the file if it is displayable
                //

                if (IsDisplayableCPL (Params->FullFileSpec) &&
                    !TreatAsGood (Params->FullFileSpec)
                    ) {

                    DisableFile (Params->FullFileSpec);

                    Status = GetFileStatusOnNt (Params->FullFileSpec);

                    if (!(Status & FILESTATUS_REPLACED)) {
                        //
                        // Announce this CPL as bad because:
                        //
                        // - It is not known good
                        // - NT does not replace it
                        //

                        ReportControlPanelApplet (
                            Params->FullFileSpec,
                            NULL,
                            ACT_INCOMPATIBLE
                            );
                    }
                }
            }
        }
    }

    return TRUE;
}


BOOL
CheckOsFiles (
    IN OUT  PFILE_HELPER_PARAMS Params
    )
{
    TCHAR key[MEMDB_MAX];
    PCTSTR filePtr;
    DWORD fileStatus;
    PCTSTR newFileName;
    BOOL bIsWin9xOsPath;

    if (Params->Handled == 0) {
        filePtr = GetFileNameFromPath (Params->FullFileSpec);
        if (filePtr) {

            MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES, filePtr, NULL, NULL);
            if (MemDbGetValue (key, NULL)) {
                MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES_EXCEPT, filePtr, NULL, NULL);
                if (!MemDbGetValue (key, NULL)) {
                    //
                    // only do this for files in a MigrationDir
                    //
                    if (IsMigrationPathEx (Params->DirSpec, &bIsWin9xOsPath) && bIsWin9xOsPath) {
                        if (GlobalVersionCheck (Params->FullFileSpec, "COMPANYNAME", "*MICROSOFT*")) {
                            MYASSERT (Params->CurrentDirData);
                            if (!g_IsFusionDir || !IsNtCompatibleModule (Params->FullFileSpec)) {
                                //
                                // If this file is marked with any MOVE operations, remove those operations.
                                // we want this deletion to take precedence.
                                //
                                RemoveOperationsFromPath (
                                    Params->FullFileSpec,
                                    ALL_MOVE_OPERATIONS
                                    );
                                DeleteFileWithWarning (Params->FullFileSpec);
                                MarkFileAsOsFile (Params->FullFileSpec);
                                fileStatus = GetFileStatusOnNt (Params->FullFileSpec);
                                if ((fileStatus & FILESTATUS_REPLACED) != 0) {
                                    newFileName = GetPathStringOnNt (Params->FullFileSpec);
                                    if (StringIMatch (newFileName, Params->FullFileSpec)) {
                                        MarkFileForCreation (newFileName);
                                    } else {
                                        MarkFileForMoveByNt (Params->FullFileSpec, newFileName);
                                    }
                                    FreePathString (newFileName);
                                }
                                Params->Handled = CHECK_OS_FILES;
                            }
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}


BOOL
GatherIniFiles (
    IN      PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  GatherIniFiles marks in memdb all INI files that have associated actions on NT.

Arguments:

  Params - Specifies the file enumeration parameters

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    MEMDB_ENUM e;
    PTSTR NtPath;
    BOOL TempMove;
    BOOL DoIniAct;
    BOOL Success;
    DWORD Operations;

    if (Params->IsDirectory) {
        return TRUE;
    }
    if (Params->Handled) {
        return TRUE;
    }
    if (!StringIMatch(Params->Extension, TEXT(".INI"))) {
        return TRUE;
    }

    DoIniAct = FALSE;

    Params->Handled = GATHER_INI_FILES;

    TempMove = FALSE;
    //
    // Save selected INI filenames to memdb to perform actions on NT
    //
    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_INIFILES_ACT_FIRST, NULL, NULL)) {
        do {
            //
            // if this dir name is matched, add this file to memdb and return
            //
            if (IsPatternMatch (e.szName, Params->FullFileSpec)) {
                //
                // move file in temp location
                //
                NtPath = GetPathStringOnNt (Params->FullFileSpec);
                if (!NtPath) {
                    //
                    // can't get path on NT!
                    //
                    DEBUGMSG ((
                        DBG_ERROR,
                        "GetPathStringOnNt (%s) returned NULL",
                        Params->FullFileSpec
                        ));
                    return FALSE;
                }

                Operations = GetOperationsOnPath (Params->FullFileSpec);
                if (Operations & OPERATION_FILE_MOVE_SHELL_FOLDER) {
                    DEBUGMSG ((
                        DBG_WARNING,
                        "Replacing operation OPERATION_FILE_MOVE_SHELL_FOLDER with OPERATION_TEMP_PATH for file %s",
                        Params->FullFileSpec
                        ));
                    RemoveOperationsFromPath (
                        Params->FullFileSpec,
                        OPERATION_FILE_MOVE_SHELL_FOLDER
                        );
                }

                Success = MarkFileForTemporaryMove (Params->FullFileSpec, NtPath, g_TempDir);
                FreePathString (NtPath);

                if (!Success) {
                    DEBUGMSG ((
                        DBG_ERROR,
                        "MarkFileForTemporaryMove (source=%s) returned FALSE",
                        Params->FullFileSpec
                        ));
                    return FALSE;
                }

                NtPath = GetPathStringOnNt (Params->DirSpec);
                Success = MarkDirectoryAsPreserved (NtPath);
                if (!Success) {
                    DEBUGMSG ((
                        DBG_ERROR,
                        "MarkDirectoryAsPreserved (%s) returned FALSE",
                        Params->DirSpec
                        ));
                }

                FreePathString (NtPath);

                TempMove = TRUE;

                MemDbSetValueEx (
                    MEMDB_CATEGORY_INIACT_FIRST,
                    Params->FullFileSpec,
                    NULL,
                    NULL,
                    0,
                    NULL
                    );
                DoIniAct = TRUE;
                break;
            }
        } while (MemDbEnumNextValue (&e));
    }

    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_INIFILES_ACT_LAST, NULL, NULL)) {
        do {
            //
            // if this dir name is matched, add this file to memdb and return
            //
            if (IsPatternMatch (e.szName, Params->FullFileSpec)) {
                if (!TempMove) {
                    //
                    // move file in temp location
                    //
                    NtPath = GetPathStringOnNt (Params->FullFileSpec);
                    if (!NtPath) {
                        //
                        // can't get path on NT!
                        //
                        DEBUGMSG ((
                            DBG_ERROR,
                            "GetPathStringOnNt (%s) returned NULL",
                            Params->FullFileSpec
                            ));
                        return FALSE;
                    }

                    Operations = GetOperationsOnPath (Params->FullFileSpec);
                    if (Operations & OPERATION_FILE_MOVE_SHELL_FOLDER) {
                        DEBUGMSG ((
                            DBG_WARNING,
                            "Replacing operation OPERATION_FILE_MOVE_SHELL_FOLDER with OPERATION_TEMP_PATH for file %s",
                            Params->FullFileSpec
                            ));
                        RemoveOperationsFromPath (
                            Params->FullFileSpec,
                            OPERATION_FILE_MOVE_SHELL_FOLDER
                            );
                    }
                    Success = MarkFileForTemporaryMove (Params->FullFileSpec, NtPath, g_TempDir);

                    FreePathString (NtPath);

                    if (!Success) {
                        DEBUGMSG ((
                            DBG_ERROR,
                            "MarkFileForTemporaryMove (source=%s) returned FALSE",
                            Params->FullFileSpec
                            ));
                        return FALSE;
                    }

                    NtPath = GetPathStringOnNt (Params->DirSpec);
                    Success = MarkDirectoryAsPreserved (NtPath);
                    if (!Success) {
                        DEBUGMSG ((
                            DBG_ERROR,
                            "MarkDirectoryAsPreserved (%s) returned FALSE",
                            Params->DirSpec
                            ));
                    }

                    FreePathString (NtPath);

                    TempMove = TRUE;
                }

                MemDbSetValueEx (
                    MEMDB_CATEGORY_INIACT_LAST,
                    Params->FullFileSpec,
                    NULL,
                    NULL,
                    0,
                    NULL
                    );
                DoIniAct = TRUE;
                break;
            }
        } while (MemDbEnumNextValue (&e));
    }

    if (!DoIniAct) {
        //
        // ini files in %windir% are treated separately
        //
        if (!StringIMatch (Params->DirSpec, g_WinDirWack)) {
            //
            // Save all other INI filenames to memdb to convert them later on NT
            //
            MemDbSetValueEx (
                MEMDB_CATEGORY_INIFILES_CONVERT,
                Params->FullFileSpec,
                NULL,
                NULL,
                0,
                NULL
                );
            MarkFileForBackup (Params->FullFileSpec);
        }
    }

    return TRUE;
}


BOOL
GatherBriefcases (
    IN      PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  GatherBriefcases stores in memdb all Windows Briefcase Databases

Arguments:

  Params - Specifies the file enumeration parameters

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    if (!*Params->Extension && !Params->IsDirectory) {

        MYASSERT (Params->FindData);

        if (StringIMatch (
                GetFileNameFromPath (Params->FindData->cFileName),
                TEXT("Briefcase Database")
                )) {
            MemDbSetValueEx (
                MEMDB_CATEGORY_BRIEFCASES,
                Params->FullFileSpec,
                NULL,
                NULL,
                0,
                NULL
                );
            MarkFileForBackup (Params->FullFileSpec);
        }
    }

    return TRUE;
}


BOOL
pIsDirInPath (
    IN      PCTSTR FullDirSpec
    )
{
    PATH_ENUMA e;

    if (EnumFirstPathExA (&e, NULL, NULL, NULL, TRUE)) {
        do {
            if (StringIMatch (FullDirSpec, e.PtrCurrPath)) {
                return TRUE;
            }
        } while (EnumNextPath (&e));
    }

    return FALSE;
}


BOOL
pIsFusionDir (
    IN      PCTSTR FullDirSpec
    )
{
    HANDLE h;
    WIN32_FIND_DATA fd, fd2;
    TCHAR FileSpec[2 * MAX_TCHAR_PATH];
    TCHAR ExeName[2 * MAX_TCHAR_PATH];
    INT length;
    DWORD type;
    BOOL b = FALSE;

    MYASSERT (FullDirSpec);

    //
    // a fusion dir is never the root of a local drive or in windir or in path
    //
    if (SizeOfString (FullDirSpec) <= 4 ||
        StringIMatch (FullDirSpec, g_WinDir) ||
        StringIMatchCharCount (FullDirSpec, g_WinDirWack, g_WinDirWackChars) ||
        pIsDirInPath (FullDirSpec)
        ) {
        return FALSE;
    }
    length = wsprintf (FileSpec, TEXT("%s\\%s"), FullDirSpec, TEXT("*.local"));
    if (length <= MAX_PATH) {

        h = FindFirstFile (FileSpec, &fd);
        if (h != INVALID_HANDLE_VALUE) {

            do {
                length = wsprintf (ExeName, TEXT("%s%s"), FullDirSpec, fd.cFileName);
                //
                // cut the .local and check if this file exists
                //
                MYASSERT (ExeName[length - 6] == TEXT('.'));
                ExeName[length - 6] = 0;
                if (DoesFileExistEx (ExeName, &fd2) &&
                    !(fd2.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    ) {
                    type = GetExeType (ExeName);
                    b = (type == EXE_WIN32_APP) || (type == EXE_WIN16_APP);
                }

            } while (!b && FindNextFile (h, &fd));

            FindClose (h);
        }
    }

    return b;
}


BOOL
IsFusionDir (
    IN      PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  IsFusionDir tests if the current dir is a fusion directory;
  it will set the MIGAPP_DIRDATA_FUSION_DIR bit in *Params->CurrentDirData

Arguments:

  Params - Specifies the file enumeration parameters

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    //
    // this helper should be called before action functions (first ID is MIGDB_TEST_FILE)
    //
    MYASSERT (IS_FUSION_DIR < MIGDB_TEST_FILE);

    //
    // the caller must provide the storage space
    //
    MYASSERT (Params->CurrentDirData);
    if (!Params->CurrentDirData) {
        return FALSE;
    }

    if (!Params->IsDirectory) {

        if ((*Params->CurrentDirData & MIGAPP_DIRDATA_FUSION_DIR_DETERMINED) == 0) {
            if (pIsFusionDir (Params->DirSpec)) {
                *Params->CurrentDirData |= MIGAPP_DIRDATA_IS_FUSION_DIR;
            }
            *Params->CurrentDirData |= MIGAPP_DIRDATA_FUSION_DIR_DETERMINED;
        }

        g_IsFusionDir = (*Params->CurrentDirData & MIGAPP_DIRDATA_IS_FUSION_DIR) != 0;

    } else {
        g_IsFusionDir = FALSE;
    }

    return TRUE;
}


BOOL
TestNtFileName (
    IN      PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  TestNtFileName tests if the current file has the same name as one in [UseNtFiles];
  if it does, then renaming of this file on NT side is infibited, to ensure we don't
  change files that are not ours.

Arguments:

  Params - Specifies the file enumeration parameters

Return Value:

  Always TRUE.

--*/

{
    HASHITEM result;
    DWORD set;
    TCHAR key [MEMDB_MAX];
    MEMDB_ENUM e;
    PCTSTR name;

    if (!Params->IsDirectory && !Params->Handled) {
        name = GetFileNameFromPath (Params->FullFileSpec);
        if (g_UseNtFileHashTable) {
            result = HtFindStringAndData (g_UseNtFileHashTable, name, NULL);
            if (result) {
                DEBUGMSG ((
                    DBG_VERBOSE,
                    "Found unhandled [UseNtFiles] file %s; it's name will not be replaced",
                    name
                    ));
                //
                // remove this mapping from memdb
                //
                MemDbBuildKey (
                    key,
                    MEMDB_CATEGORY_USE_NT_FILES,
                    name,
                    NULL,
                    NULL
                    );
                MemDbDeleteTree (key);
                MYASSERT (!MemDbGetValueEx (&e, key, NULL, NULL));
                //
                // mark this file with data so that we know a file with this name
                // not handled by MigDb was found
                //
                set = 1;
                if (!HtSetStringData (g_UseNtFileHashTable, result, &set)) {
                    MYASSERT (FALSE);
                }
            }
        }
    }

    return TRUE;
}


BOOL
BackUpIsuFiles (
    IN      PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  BackUpIsuFiles collect all of the InstallShield files, so that they
  can be edited during GUI mode using code provided by InstallShield.

Arguments:

  Params - Specifies the file enumeration parameters

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    MEMDB_ENUM e;
    PTSTR NtPath;
    BOOL TempMove;
    BOOL DoIniAct;
    BOOL Success;
    DWORD Operations;

    if (Params->IsDirectory) {
        return TRUE;
    }
    if (Params->Handled) {
        return TRUE;
    }
    if (!StringIMatch(Params->Extension, TEXT(".ISU"))) {
        return TRUE;
    }

    Params->Handled = BACKUP_ISU_FILES;

    MarkFileForBackup (Params->FullFileSpec);

    return TRUE;
}


BOOL
EditHtmlFiles (
    IN      PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  EditHtmlFiles examines all *.HTM? files and looks for the text FILE:. If it
  is found, then the file is added to the FileEdit group, so that references to
  local paths can be updated. The file is also marked for backup.

Arguments:

  Params - Specifies the file enumeration parameters

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    HANDLE file;
    HANDLE map;
    PBYTE image;
    PCSTR pos;
    PCSTR end;
    BOOL found = FALSE;
    TCHAR pathCopy[MAX_TCHAR_PATH];
    GROWBUFFER tokenArgBuf = GROWBUF_INIT;
    GROWBUFFER tokenSetBuf = GROWBUF_INIT;
    GROWBUFFER dataBuf = GROWBUF_INIT;
    PTOKENARG tokenArg;
    PTOKENSET tokenSet;
    TCHAR node[MEMDB_MAX];

    if (Params->IsDirectory) {
        return TRUE;
    }
    if (Params->Handled) {
        return TRUE;
    }

    if (!StringIMatch (Params->Extension, TEXT(".HTM")) &&
        !IsPatternMatch (Params->Extension, TEXT(".HTM?"))
        ) {
        return TRUE;
    }

    //
    // Exclude OS files
    //

    if (IsFileMarkedAsOsFile (Params->FullFileSpec)) {
        DEBUGMSG ((DBG_WARNING, "%s is an OS file; skipping file: ref update", Params->FullFileSpec));
        return TRUE;
    }

    //
    // Exclude Temporary Internet Files
    //

    StringCopy (pathCopy, Params->FullFileSpec);
    if (MappingSearchAndReplace (g_CacheShellFolders, pathCopy, sizeof (pathCopy))) {
        DEBUGMSG ((DBG_WARNING, "%s is in a Cache shell folder; skipping file: ref update", Params->FullFileSpec));
        return TRUE;
    }

    DEBUGMSG ((DBG_NAUSEA, "Checking %s for local references", Params->FullFileSpec));

    //
    // Already processed?
    //

    MemDbBuildKey (node, MEMDB_CATEGORY_FILEEDIT, Params->FullFileSpec, NULL, NULL);
    if (MemDbGetValue (node, NULL)) {
        DEBUGMSG ((DBG_NAUSEA, "%s is already processed; skipping", Params->FullFileSpec));
        return TRUE;
    }

    //
    // Scan file for text "FILE:"
    //

    image = (PBYTE) MapFileIntoMemory (Params->FullFileSpec, &file, &map);
    if (!image) {
        DEBUGMSG ((DBG_WARNING, "Can't map %s into memory; skipping", Params->FullFileSpec));
        return TRUE;
    }

    pos = (PCSTR) image;
    end = (PCSTR) ((PBYTE) pos + GetFileSize (file, NULL));

    if (end > pos + 1 && !(pos[0] == 0xFF && pos[1] == 0xFE)) {
        while (pos < end) {
            if (!isspace (*pos) && *pos != '\r' && *pos != '\n') {
                if (*pos < 32) {
                    DEBUGMSG ((DBG_VERBOSE, "File %s looks like it is binary; skipping", Params->FullFileSpec));
                    break;
                }

                if (*pos == 'F' || *pos == 'f') {
                    if (StringIPrefix (pos, TEXT("FILE:"))) {
                        found = TRUE;
                        DEBUGMSG ((DBG_VERBOSE, "File %s has FILE: in it; processing it as HTML", Params->FullFileSpec));
                        break;
                    }
                }
            }

            pos++;
        }
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "File %s is not an ANSI file; skipping", Params->FullFileSpec));

    UnmapFile (image, map, file);

    //
    // Text found -- mark for edit & backup
    //

    if (found) {
        Params->Handled = EDIT_HTML_FILES;
        MarkFileForBackup (Params->FullFileSpec);

        //
        // Create an argument that has a detect pattern of * and UpdatePath
        // set to TRUE. We fill every member of TOKENARG here.
        //

        tokenArg = (PTOKENARG) GrowBuffer (&tokenArgBuf, sizeof (TOKENARG));
        tokenArg->DetectPattern = (PCSTR) (dataBuf.End + TOKEN_BASE_OFFSET);
        GrowBufCopyString (&dataBuf, TEXT("*"));

        tokenArg->SearchList = NULL;
        tokenArg->ReplaceWith = NULL;
        tokenArg->UpdatePath = TRUE;

        //
        // Create a token set of just one token argument. We fill every member
        // of TOKENSET here.
        //

        tokenSet = (PTOKENSET) GrowBuffer (
                                    &tokenSetBuf,
                                    sizeof (TOKENSET) +
                                        tokenArgBuf.End +
                                        dataBuf.End
                                    );

        tokenSet->ArgCount = 1;
        tokenSet->SelfRelative = TRUE;
        tokenSet->UrlMode = TRUE;
        tokenSet->CharsToIgnore = NULL;

        CopyMemory (tokenSet->Args, tokenArgBuf.Buf, tokenArgBuf.End);
        CopyMemory (
            (PBYTE) (tokenSet->Args) + tokenArgBuf.End,
            dataBuf.Buf,
            dataBuf.End
            );

        //
        // Save completed tokenSet to FileEdit category of memdb
        //

        MemDbSetBinaryValueEx (
            MEMDB_CATEGORY_FILEEDIT,
            Params->FullFileSpec,
            NULL,
            tokenSetBuf.Buf,
            tokenSetBuf.End,
            NULL
            );
    }
    ELSE_DEBUGMSG ((DBG_NAUSEA, "File %s does not have FILE: in it; skipping", Params->FullFileSpec));

    FreeGrowBuffer (&tokenArgBuf);
    FreeGrowBuffer (&tokenSetBuf);
    FreeGrowBuffer (&dataBuf);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\dbattrib.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dbattrib.c

Abstract:

    This source implements attribute functions used by MigDb

Author:

    Calin Negreanu (calinn) 07-Jan-1998

Revision History:

  28-May-1999   ovidiut     Added SECTIONKEY attribute
  22-Apr-1999   jimschm     Added UPTOBIN*VER attributes
  07-Jan-1999   jimschm     Added HASVERSION attribute
  18-May-1998   jimschm     Added INPARENTDIR attribute
  08-Apr-1998   calinn      Added two more attributes (ExeType and Description)
  29-Jan-1998   calinn      Modified CheckSum and FileSize to work with hex numbers
  19-Jan-1998   calinn      added CheckSum attribute

--*/

#include "pch.h"
#include "migdbp.h"

/*++

Macro Expansion List Description:

  ATTRIBUTE_FUNCTIONS lists all valid attributes to query for a specific file.
  They are used by migdb in it's attempt to locate files.

Line Syntax:

   DEFMAC(AttribFn, AttribName, ReqArgs)

Arguments:

   AttribFn   - This is a boolean function that returnes TRUE if a specified file has
                the specified attribute. You must implement a function with this name
                and required parameters.

   AttribName - This is the string that identifies the attribute function. It should
                have the same value as listed in migdb.inf

   ReqArgs    - Specifies the number of args that are required for the action.  Used
                by the parser.

Variables Generated From List:

   g_AttributeFunctions - do not touch!

For accessing the array there are the following functions:

   MigDb_GetAttributeAddr
   MigDb_GetAttributeIdx
   MigDb_GetAttributeName
   MigDb_GetReqArgCount

--*/

#define ATTRIBUTE_FUNCTIONS        \
        DEFMAC(CompanyName,         COMPANYNAME,        1)  \
        DEFMAC(FileDescription,     FILEDESCRIPTION,    1)  \
        DEFMAC(FileVersion,         FILEVERSION,        1)  \
        DEFMAC(InternalName,        INTERNALNAME,       1)  \
        DEFMAC(LegalCopyright,      LEGALCOPYRIGHT,     1)  \
        DEFMAC(OriginalFilename,    ORIGINALFILENAME,   1)  \
        DEFMAC(ProductName,         PRODUCTNAME,        1)  \
        DEFMAC(ProductVersion,      PRODUCTVERSION,     1)  \
        DEFMAC(FileSize,            FILESIZE,           1)  \
        DEFMAC(IsMsBinary,          ISMSBINARY,         0)  \
        DEFMAC(IsWin9xBinary,       ISWIN9XBINARY,      0)  \
        DEFMAC(InWinDir,            INWINDIR,           0)  \
        DEFMAC(InCatDir,            INCATDIR,           0)  \
        DEFMAC(InHlpDir,            INHLPDIR,           0)  \
        DEFMAC(InSysDir,            INSYSDIR,           0)  \
        DEFMAC(InProgramFiles,      INPROGRAMFILES,     0)  \
        DEFMAC(IsNotSysRoot,        ISNOTSYSROOT,       0)  \
        DEFMAC(CheckSum,            CHECKSUM,           1)  \
        DEFMAC(ExeType,             EXETYPE,            1)  \
        DEFMAC(Description,         DESCRIPTION,        1)  \
        DEFMAC(InParentDir,         INPARENTDIR,        1)  \
        DEFMAC(InRootDir,           INROOTDIR,          0)  \
        DEFMAC(PnpIdAttrib,         PNPID,              1)  \
        DEFMAC(HlpTitle,            HLPTITLE,           1)  \
        DEFMAC(IsWin98,             ISWIN98,            0)  \
        DEFMAC(HasVersion,          HASVERSION,         0)  \
        DEFMAC(ReqFile,             REQFILE,            1)  \
        DEFMAC(BinFileVer,          BINFILEVER,         1)  \
        DEFMAC(BinProductVer,       BINPRODUCTVER,      1)  \
        DEFMAC(FileDateHi,          FILEDATEHI,         1)  \
        DEFMAC(FileDateLo,          FILEDATELO,         1)  \
        DEFMAC(FileVerOs,           FILEVEROS,          1)  \
        DEFMAC(FileVerType,         FILEVERTYPE,        1)  \
        DEFMAC(SizeCheckSum,        FC,                 2)  \
        DEFMAC(UpToBinProductVer,   UPTOBINPRODUCTVER,  1)  \
        DEFMAC(UpToBinFileVer,      UPTOBINFILEVER,     1)  \
        DEFMAC(SectionKey,          SECTIONKEY,         1)  \
        DEFMAC(RegKeyPresent,       REGKEYPRESENT,      1)  \
        DEFMAC(AtLeastWin98,        ATLEASTWIN98,       0)  \
        DEFMAC(HasUninstall,        HASUNINSTALL,       1)  \
        DEFMAC(IsItInstalled,       ISITINSTALLED,      1)  \


typedef struct {
    PCSTR AttributeName;
    PATTRIBUTE_PROTOTYPE AttributeFunction;
    UINT RequiredArgs;
} ATTRIBUTE_STRUCT, *PATTRIBUTE_STRUCT;

//
// Declare the attribute functions
//
#define DEFMAC(fn,id,reqargs) ATTRIBUTE_PROTOTYPE fn;
ATTRIBUTE_FUNCTIONS
#undef DEFMAC

//
// Declare a global array of functions and name identifiers for attribute functions
//
#define DEFMAC(fn,id,regargs) {#id, fn, regargs},
static ATTRIBUTE_STRUCT g_AttributeFunctions[] = {
                              ATTRIBUTE_FUNCTIONS
                              {NULL, NULL}
                              };
#undef DEFMAC

//
// if this is TRUE, all attributes that check directories (InWinDir, InHlpDir, InCatDir, InSysDir)
// will return TRUE, otherwise will actually do the appropriate tests.
//
BOOL g_InAnyDir = FALSE;


BOOL
pAlwaysFalseAttribute (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return FALSE;
}


PATTRIBUTE_PROTOTYPE
MigDb_GetAttributeAddr (
    IN      INT AttributeIdx
    )
/*++

Routine Description:

  MigDb_GetAttributeAddr returns the address of the attribute function based on the attribute index

Arguments:

  AttributeIdx - Attribute index.

Return value:

  Attribute function address. Note that no checking is made so the address returned could be invalid.
  This is not a problem since the parsing code did the right job.

--*/
{
    if (AttributeIdx == -1) {
        return &pAlwaysFalseAttribute;
    }

    return g_AttributeFunctions[AttributeIdx].AttributeFunction;
}


INT
MigDb_GetAttributeIdx (
    IN      PCSTR AttributeName
    )
/*++

Routine Description:

  MigDb_GetAttributeIdx returns the attribute index based on the attribute name

Arguments:

  AttributeName - Attribute name.

Return value:

  Attribute index. If the name is not found, the index returned is -1.

--*/
{
    PATTRIBUTE_STRUCT p = g_AttributeFunctions;
    INT i = 0;
    while (p->AttributeName != NULL) {
        if (StringIMatch (p->AttributeName, AttributeName)) {
            return i;
        }
        p++;
        i++;
    }
    return -1;
}

PCSTR
MigDb_GetAttributeName (
    IN      INT AttributeIdx
    )
/*++

Routine Description:

  MigDb_GetAttributeName returns the name of an attribute based on the attribute index

Arguments:

  AttributeIdx - Attribute index.

Return value:

  Attribute name. Note that no checking is made so the returned pointer could be invalid.
  This is not a problem since the parsing code did the right job.

--*/
{
    if (AttributeIdx == -1) {
        return "nul";
    }

    return g_AttributeFunctions[AttributeIdx].AttributeName;
}


UINT
MigDb_GetReqArgCount (
    IN      INT AttributeIndex
    )

/*++

Routine Description:

  MigDb_GetReqArgCount is called by the migdb parser to get the required
  argument count.  When the parser sees arguments that lack the required
  arguments, it skips them.

Arguments:

  Index - Specifies the argument index

Return Value:

  The required argument count, which can be zero or more.

--*/

{
    if (AttributeIndex == -1) {
        return 0;
    }

    return g_AttributeFunctions[AttributeIndex].RequiredArgs;
}


ULONGLONG
GetBinFileVer (
    IN      PCSTR FileName
    )
{
    VERSION_STRUCT Version;
    ULONGLONG result = 0;

    if (CreateVersionStruct (&Version, FileName)) {
        result = VerGetFileVer (&Version);
        DestroyVersionStruct (&Version);
    }
    return result;
}

ULONGLONG
GetBinProductVer (
    IN      PCSTR FileName
    )
{
    VERSION_STRUCT Version;
    ULONGLONG result = 0;

    if (CreateVersionStruct (&Version, FileName)) {
        result = VerGetProductVer (&Version);
        DestroyVersionStruct (&Version);
    }
    return result;
}

DWORD
GetFileDateHi (
    IN      PCSTR FileName
    )
{
    VERSION_STRUCT Version;
    DWORD result = 0;

    if (CreateVersionStruct (&Version, FileName)) {
        result = VerGetFileDateHi (&Version);
        DestroyVersionStruct (&Version);
    }
    return result;
}

DWORD
GetFileDateLo (
    IN      PCSTR FileName
    )
{
    VERSION_STRUCT Version;
    DWORD result = 0;

    if (CreateVersionStruct (&Version, FileName)) {
        result = VerGetFileDateLo (&Version);
        DestroyVersionStruct (&Version);
    }
    return result;
}

DWORD
GetFileVerOs (
    IN      PCSTR FileName
    )
{
    VERSION_STRUCT Version;
    DWORD result = 0;

    if (CreateVersionStruct (&Version, FileName)) {
        result = VerGetFileVerOs (&Version);
        DestroyVersionStruct (&Version);
    }
    return result;
}

DWORD
GetFileVerType (
    IN      PCSTR FileName
    )
{
    VERSION_STRUCT Version;
    DWORD result = 0;

    if (CreateVersionStruct (&Version, FileName)) {
        result = VerGetFileVerType (&Version);
        DestroyVersionStruct (&Version);
    }
    return result;
}

PSTR
QueryVersionEntry (
    IN      PCSTR FileName,
    IN      PCSTR VersionEntry
    )
/*++

Routine Description:

  QueryVersionEntry queries the file's version structure returning the
  value for a specific entry

Arguments:

  FileName     - File to query for version struct.

  VersionEntry - Name to query in version structure.

Return value:

  Value of specified entry or NULL if unsuccessful

--*/
{
    VERSION_STRUCT Version;
    PCSTR CurrentStr;
    PSTR result = NULL;

    MYASSERT (VersionEntry);

    if (CreateVersionStruct (&Version, FileName)) {
        __try {
            CurrentStr = EnumFirstVersionValue (&Version, VersionEntry);
            if (CurrentStr) {
                CurrentStr = SkipSpace (CurrentStr);
                result = DuplicatePathString (CurrentStr, 0);
            }
            else {
                __leave;
            }
        }
        __finally {
            DestroyVersionStruct (&Version);
        }
    }
    return result;
}

BOOL
GlobalVersionCheck (
    IN      PCSTR FileName,
    IN      PCSTR NameToCheck,
    IN      PCSTR ValueToCheck
    )
/*++

Routine Description:

  GlobalVersionCheck queries the file's version structure trying to
  see if a specific name has a specific value.

Arguments:

  FileName     - File to query for version struct.

  NameToCheck  - Name to query in version structure.

  ValueToCheck - Value to query in version structure.

Return value:

  TRUE  - the query was successful
  FALSE - the query failed

--*/
{
    VERSION_STRUCT Version;
    PCSTR CurrentStr;
    BOOL result = FALSE;

    MYASSERT (NameToCheck);
    MYASSERT (ValueToCheck);

    if (CreateVersionStruct (&Version, FileName)) {
        __try {
            CurrentStr = EnumFirstVersionValue (&Version, NameToCheck);
            while (CurrentStr) {
                CurrentStr = SkipSpace (CurrentStr);
                TruncateTrailingSpace ((PSTR) CurrentStr);
                if (IsPatternMatchA (ValueToCheck, CurrentStr)) {
                    result = TRUE;
                    __leave;
                }

                CurrentStr = EnumNextVersionValue (&Version);
            }
        }
        __finally {
            DestroyVersionStruct (&Version);
        }
    }
    return result;
}


/*++
  CompanyName, FileDescription, FileVersion, InternalName, LegalCopyright, OriginalFilename,
  ProductName, ProductVersion are attribute functions that are querying the version structure
  for their specific entries. They all return TRUE if the specific entry has specific value,
  FALSE otherwise.
--*/

BOOL
CompanyName (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return GlobalVersionCheck (AttribParams->FileParams->FullFileSpec, "CompanyName", Args);
}

BOOL
FileDescription (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return GlobalVersionCheck (AttribParams->FileParams->FullFileSpec, "FileDescription", Args);
}

BOOL
FileVersion (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return GlobalVersionCheck (AttribParams->FileParams->FullFileSpec, "FileVersion", Args);
}

BOOL
InternalName (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return GlobalVersionCheck (AttribParams->FileParams->FullFileSpec, "InternalName", Args);
}

BOOL
LegalCopyright (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return GlobalVersionCheck (AttribParams->FileParams->FullFileSpec, "LegalCopyright", Args);
}

BOOL
OriginalFilename (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return GlobalVersionCheck (AttribParams->FileParams->FullFileSpec, "OriginalFilename", Args);
}

BOOL
ProductName (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return GlobalVersionCheck (AttribParams->FileParams->FullFileSpec, "ProductName", Args);
}

BOOL
ProductVersion (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return GlobalVersionCheck (AttribParams->FileParams->FullFileSpec, "ProductVersion", Args);
}

BOOL
FileSize (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  FileSize checks for the size of a file.

Arguments:

  Params - See definition.

  Args   - MultiSz. First Sz is the file size we need to check.

Return value:

  TRUE  - the file size matches Args
  FALSE - otherwise

--*/
{
    DWORD fileSize;

    if (!sscanf (Args, "%lx", &fileSize)) {
        DEBUGMSG ((DBG_ERROR, "FileSize: Invalid argument value (%s) in migdb.inf", Args));
        return FALSE;
    }
    if (fileSize == AttribParams->FileParams->FindData->nFileSizeLow) {
        return TRUE;
    }
    else {
        return (_atoi64 (Args) == AttribParams->FileParams->FindData->nFileSizeLow);
    }
}

BOOL
IsMsBinary (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  IsMsBinary checks to see if a certain file is Microsoft stuff. For 32 bit modules
  we query CompanyName for "Microsoft" somewhere inside. For other modules we are
  relying on InWinDir attribute

Arguments:

  Params - See definition.

  Args   - MultiSz. Not used.

Return value:

  TRUE  - the file is MS stuff
  FALSE - otherwise

--*/
{
    VERSION_STRUCT Version;
    PCTSTR CompanyStr;
    BOOL result = FALSE;

    //
    // InWinDir has some collision risks.  But for some files, we have no other
    // choice.  We know the file was shipped by Microsoft.
    //

    if (InWinDir (AttribParams, Args)) {

        result = TRUE;

    }

    //
    // If it's not in %WinDir%, then it has to have Microsoft in the company name
    //

    else if (CreateVersionStruct (
                    &Version,
                    AttribParams->FileParams->FullFileSpec
                    )) {

        __try {
            CompanyStr = EnumFirstVersionValue (&Version, TEXT("CompanyName"));
            while (CompanyStr) {
                if (_mbsistr (CompanyStr, TEXT("Microsoft"))) {
                    result = TRUE;
                    __leave;
                }
                CompanyStr = EnumNextVersionValue (&Version);
            }
        }
        __finally {
            DestroyVersionStruct (&Version);
        }
    }

    return result;
}

BOOL
IsWin9xBinary (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  IsWon9xBinary checks to see if a certain file is Microsoft Win9x stuff. It works only for
  16 and 32 bit modules with version stamp. The COMPANYNAME is checked against *Microsoft* and
  the PRODUCTVERSION is checked against 4.*

Arguments:

  Params - See definition.

  Args   - MultiSz. Not used.

Return value:

  TRUE  - the file is MS stuff
  FALSE - otherwise

--*/
{
    VERSION_STRUCT Version;
    PCTSTR CurrentStr;
    BOOL result;

    if (CreateVersionStruct (&Version, AttribParams->FileParams->FullFileSpec)) {

        result = FALSE;
        CurrentStr = EnumFirstVersionValue (&Version, TEXT("CompanyName"));
        while (CurrentStr) {
            CurrentStr = SkipSpace (CurrentStr);
            TruncateTrailingSpace ((PSTR) CurrentStr);
            if (IsPatternMatchA (TEXT("*Microsoft*"), CurrentStr)) {
                result = TRUE;
                break;
            }
            CurrentStr = EnumNextVersionValue (&Version);
        }
        if (result) {
            result = FALSE;
            CurrentStr = EnumFirstVersionValue (&Version, TEXT("ProductVersion"));
            while (CurrentStr) {
                CurrentStr = SkipSpace (CurrentStr);
                TruncateTrailingSpace ((PSTR) CurrentStr);
                if (IsPatternMatchA (TEXT("4.*"), CurrentStr)) {
                    result = TRUE;
                    break;
                }
                CurrentStr = EnumNextVersionValue (&Version);
            }
        }

        DestroyVersionStruct (&Version);
    }
    else {
        result = FALSE;
    }
    return result;
}

BOOL
InWinDir (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  InWinDir returns TRUE if file is located in %Windir% or one of it's subdirectories

Arguments:

  Params - See definition.

  Args   - MultiSz. Not used.

Return value:

  TRUE  - the file is located in %Windir%
  FALSE - otherwise

--*/
{
    if (g_InAnyDir) {
        return TRUE;
    }
    return (StringIMatchCharCount (AttribParams->FileParams->FullFileSpec, g_WinDirWack, g_WinDirWackChars));
}

BOOL
InCatDir (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  InCatDir returns TRUE if file is located in %Windir%\CATROOT or one of it's subdirectories

Arguments:

  Params - See definition.

  Args   - MultiSz. Not used.

Return value:

  TRUE  - the file is located in %Windir%
  FALSE - otherwise

--*/
{
    if (g_InAnyDir) {
        return TRUE;
    }
    return (StringIMatchCharCount (AttribParams->FileParams->FullFileSpec, g_CatRootDirWack, g_CatRootDirWackChars));
}

BOOL
InHlpDir (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  InHlpDir returns TRUE if file is located in %Windir%\HELP or one of it's subdirectories

Arguments:

  Params - See definition.

  Args   - MultiSz. Not used.

Return value:

  TRUE  - the file is located in %Windir%
  FALSE - otherwise

--*/
{
    if (g_InAnyDir) {
        return TRUE;
    }
    return (StringIMatchCharCount (AttribParams->FileParams->FullFileSpec, g_HelpDirWack, g_HelpDirWackChars));
}

BOOL
InSysDir (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  InSysDir returns TRUE if file is located in %Windir%\SYSTEM or one of it's subdirectories

Arguments:

  Params - See definition.

  Args   - MultiSz. Not used.

Return value:

  TRUE  - the file is located in %Windir%
  FALSE - otherwise

--*/
{
    if (g_InAnyDir) {
        return TRUE;
    }
    return (StringIMatchCharCount (AttribParams->FileParams->FullFileSpec, g_SystemDirWack, g_SystemDirWackChars));
}

BOOL
InProgramFiles (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  InProgramFiles returns TRUE if file is located in Program Files or one of it's subdirectories

Arguments:

  Params - See definition.

  Args   - MultiSz. Not used.

Return value:

  TRUE  - the file is located in Program Files
  FALSE - otherwise

--*/
{
    if (g_InAnyDir) {
        return TRUE;
    }
    return (StringIMatchCharCount (AttribParams->FileParams->FullFileSpec, g_ProgramFilesDirWack, g_ProgramFilesDirWackChars));
}

BOOL
IsNotSysRoot (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  IsNotSysRoot returns TRUE if file is not located in C:\ directory

Arguments:

  Params - See definition.

  Args   - MultiSz. Not used.

Return value:

  TRUE  - the file is not located in C:\ directory
  FALSE - otherwise

--*/
{
    PSTR pathEnd;
    CHAR savedChar;
    BOOL result = FALSE;

    pathEnd = (PSTR)GetFileNameFromPath (AttribParams->FileParams->FullFileSpec);
    if (pathEnd == NULL) {
        return TRUE;
    }

    savedChar = pathEnd [0];

    __try {
        pathEnd [0] = 0;
        result = (!StringIMatch (AttribParams->FileParams->FullFileSpec, g_BootDrivePath));
    }
    __finally {
        pathEnd [0] = savedChar;
    }

    return result;
}


UINT
ComputeCheckSum (
    PFILE_HELPER_PARAMS Params
    )
/*++

Routine Description:

  ComputeCheckSum will compute the check sum for 4096 bytes starting at offset 512. The offset and the size of
  the chunk are modified if the file size is too small.

Arguments:

  Params - See definition.

Return value:

  The computed checksum

--*/
{
    INT    i,size     = 4096;
    DWORD  startAddr  = 512;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCHAR  buffer     = NULL;
    UINT   checkSum   = 0;
    DWORD  dontCare;

    if (Params->FindData->nFileSizeLow < (ULONG)size) {
        //
        // File size is less than 4096. We set the start address to 0 and set the size for the checksum
        // to the actual file size.
        //
        startAddr = 0;
        size = Params->FindData->nFileSizeLow;
    }
    else
    if (startAddr + size > Params->FindData->nFileSizeLow) {
        //
        // File size is too small. We set the start address so that size of checksum can be 4096 bytes
        //
        startAddr = Params->FindData->nFileSizeLow - size;
    }
    if (size <= 3) {
        //
        // we need at least 3 bytes to be able to do something here.
        //
        return 0;
    }
    __try {
        buffer = MemAlloc (g_hHeap, 0, size);
        if (buffer == NULL) {
            __leave;
        }
        fileHandle = CreateFile (Params->FullFileSpec, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (fileHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (SetFilePointer (fileHandle, startAddr, NULL, FILE_BEGIN) != startAddr) {
            __leave;
        }

        if (!ReadFile (fileHandle, buffer, size, &dontCare, NULL)) {
            __leave;
        }
        for (i = 0; i<(size - 3); i+=4) {
            checkSum += *((PDWORD) (buffer + i));
            checkSum = _rotr (checkSum ,1);
        }
    }
    __finally {
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (buffer != NULL) {
            MemFree (g_hHeap, 0, buffer);
        }
    }
    return checkSum;
}

BOOL
CheckSum (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  CheckSum returns TRUE if file's checksum equals the value in Args

Arguments:

  Params - See definition.

  Args   - checksum value.

Return value:

  TRUE  - the file's checksum equals the value in Args
  FALSE - otherwise

--*/
{
    UINT   checkSum   = 0;
    UINT   oldSum     = 0;

    checkSum = ComputeCheckSum (AttribParams->FileParams);

    if (!sscanf (Args, "%lx", &oldSum)) {
        DEBUGMSG ((DBG_ERROR, "Invalid checksum value (%s) in migdb.inf", Args));
        return FALSE;
    }
    if (oldSum == checkSum) {
        return TRUE;
    }
    else {
        return (_atoi64 (Args) == checkSum);
    }
}

BOOL
SizeCheckSum (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  Returns TRUE if file's size equals first arg and checksum equals to the second arg

Arguments:

  Params - See definition.

  Args   - checksum value.

Return value:

  TRUE  - the file's checksum equals the value in Args
  FALSE - otherwise

--*/
{
    PCSTR currArg = Args;

    if (!FileSize (AttribParams, currArg)) {
        return FALSE;
    }
    currArg = GetEndOfString (currArg);
    if (!currArg) {
        return FALSE;
    }
    currArg = _mbsinc (currArg);
    if (!currArg) {
        return FALSE;
    }
    return (CheckSum (AttribParams, currArg));
}

PSTR g_ExeTypes[] = {
    "NONE",
    "DOS",
    "WIN16",
    "WIN32"
};

BOOL
ExeType (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  ExeType returns TRUE if file's type is according with Args. This can be:
  NONE, DOS, WIN16, WIN32

Arguments:

  Params - See definition.

  Args   - type of module.

Return value:

  TRUE  - the file's type is the same as Args
  FALSE - otherwise

--*/
{
    return IsPatternMatch (Args, g_ExeTypes[GetModuleType (AttribParams->FileParams->FullFileSpec)]);
}


BOOL
Description (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
/*++

Routine Description:

  Description returns TRUE if file's description matches Args

Arguments:

  Params - See definition.

  Args   - description

Return value:

  TRUE  - the file's description matches Args
  FALSE - otherwise

--*/
{
    PCSTR descr = NULL;
    BOOL result = FALSE;

    descr = Get16ModuleDescription (AttribParams->FileParams->FullFileSpec);

    if (descr != NULL) {
        result = IsPatternMatch (Args, descr);
        FreePathString (descr);
    }
    return result;
}


BOOL
InParentDir (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )

/*++

Routine Description:

  InParentDir compares the sub directory of the matching file against the arg
  specified.  This is used for apps that maintain static subdirs off their
  main app dir.

Arguments:

  Params - Specifies parameters for current file being processed.
  Args   - Specifies multi-sz of args passed in migdb.inf.

Return Value:

  TRUE - the file's subdirectory matches Args
  FALSE - otherwise

--*/

{
    PCTSTR stop = NULL;
    PCTSTR start = NULL;
    TCHAR lastDir[MAX_TCHAR_PATH];

    // _tcsrchr validates the multibyte characters
    stop = _tcsrchr (AttribParams->FileParams->FullFileSpec, TEXT('\\'));

    if (stop) {
        //
        // Go back to previous wack
        //

        start = _tcsdec2 (AttribParams->FileParams->FullFileSpec, stop);
        if (start) {
            start = GetPrevChar (AttribParams->FileParams->FullFileSpec, start, TEXT('\\'));
        }
    }

    if (start) {
        //
        // Check string against arg
        //

        start = _tcsinc (start);
        _tcssafecpyab (lastDir, start, stop, MAX_TCHAR_PATH);
        if (Args) {
            return (IsPatternMatch (Args, lastDir));
        } else {
            DEBUGMSG ((DBG_WHOOPS, "InParentDir requires arg"));
        }
    }

    return FALSE;
}


BOOL
InRootDir (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )

/*++

Routine Description:

  InRootDir returns TRUE is the file is located in root dir of the drive, FALSE otherwise.

Arguments:

  Params - Specifies parameters for current file being processed.
  Args   - Specifies multi-sz of args passed in migdb.inf.

Return Value:

  TRUE  - the file is in root dir of the drive
  FALSE - otherwise

--*/

{
    PCTSTR p1,p2;

    p1 = _tcschr (AttribParams->FileParams->FullFileSpec, TEXT('\\'));
    p2 = _tcsrchr (AttribParams->FileParams->FullFileSpec, TEXT('\\'));

    if (p1 && p2) {
        return (p1==p2);
    }
    return FALSE;
}


BOOL
PnpIdAttrib (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )

/*++

Routine Description:

  PnpIdAttrib implements the PNPID() attribute, which is TRUE if the
  specified ID exists on the machine.  The ID can be a complete instance ID
  (enumerator\PNPID\instance), or part of the ID (PNPID for example).

Arguments:

  Params - Specifies parameters for current file being processed
  Args   - Specifies the PNP ID argument

Return Value:

  TRUE if the specified argument exists on the machine, otherwise FALSE.

--*/

{
    BOOL Result = FALSE;
    MULTISZ_ENUM e;
    TCHAR Node[MEMDB_MAX];

    if (EnumFirstMultiSz (&e, Args)) {

        Result = TRUE;

        do {

            MemDbBuildKey (Node, MEMDB_CATEGORY_PNPIDS, e.CurrentString, NULL, NULL);
            if (!MemDbGetValue (Node, NULL)) {
                Result = FALSE;
                break;
            }

        } while (EnumNextMultiSz (&e));

    }

    return Result;

}


BOOL
HlpTitle (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    PSTR title = NULL;
    BOOL result=FALSE;

    title = GetHlpFileTitle (AttribParams->FileParams->FullFileSpec);
    if (title) {
        result = StringIMatch (title, Args);
    }
    if (title) {
        FreePathString (title);
    }
    return result;
}

BOOL
IsWin98 (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return ISMEMPHIS();
}


BOOL
HasVersion (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )

/*++

Routine Description:

  HasVersion determines if a file has any entries in its version
  stamp.

Arguments:

  Params - Specifies the helper params that give the files to test.
  Args   - Unused

Return Value:

  TRUE if the specified file has an entry in its version stamp,
  FALSE otherwsie.

--*/

{
    VERSION_STRUCT Version;
    BOOL Result = FALSE;

    if (CreateVersionStruct (&Version, AttribParams->FileParams->FullFileSpec)) {
        Result = TRUE;
        DestroyVersionStruct (&Version);
    }

    return Result;
}

BOOL
ReqFile (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    static INT reqFileSeq = 0;
    TCHAR reqFileSeqStr [20];
    PMIGDB_REQ_FILE reqFile;
    DBATTRIB_PARAMS reqFileAttribs;
    PMIGDB_ATTRIB migDbAttrib;
    FILE_HELPER_PARAMS newParams;
    WIN32_FIND_DATA findData;
    HANDLE findHandle;
    PSTR oldFileSpec;
    PSTR oldFilePtr;
    BOOL result = TRUE;

    if (!AttribParams->ExtraData) {
        return TRUE;
    }

    reqFile = (PMIGDB_REQ_FILE)AttribParams->ExtraData;
    while (reqFile) {

        newParams.Handled = 0;
        oldFileSpec = DuplicatePathString (AttribParams->FileParams->FullFileSpec, 0);
        oldFilePtr = (PSTR)GetFileNameFromPath (oldFileSpec);
        if (oldFilePtr) {
            *oldFilePtr = 0;
        }
        newParams.FullFileSpec = JoinPaths (oldFileSpec, reqFile->ReqFilePath);
        FreePathString (oldFileSpec);
        newParams.Extension = GetFileExtensionFromPath (reqFile->ReqFilePath);
        findHandle = FindFirstFile (newParams.FullFileSpec, &findData);
        if (findHandle == INVALID_HANDLE_VALUE) {
            result = FALSE;
            break;
        }
        newParams.IsDirectory = ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);
        newParams.FindData = &findData;
        newParams.VirtualFile = FALSE;
        newParams.CurrentDirData = AttribParams->FileParams->CurrentDirData;

        reqFileAttribs.FileParams = &newParams;
        reqFileAttribs.ExtraData = NULL;

        migDbAttrib = reqFile->FileAttribs;
        while (migDbAttrib) {

            if (!CallAttribute (migDbAttrib, &reqFileAttribs)) {
                result = FALSE;
                break;
            }
            migDbAttrib = migDbAttrib->Next;
        }
        if (newParams.FullFileSpec) {
            FreePathString (newParams.FullFileSpec);
            newParams.FullFileSpec = NULL;
        }
        if (migDbAttrib == NULL) {
            reqFileSeq ++;
            _itoa (reqFileSeq, reqFileSeqStr, 10);
            if (MemDbSetValueEx (
                    MEMDB_CATEGORY_REQFILES_MAIN,
                    AttribParams->FileParams->FullFileSpec,
                    reqFileSeqStr,
                    NULL,
                    0,
                    NULL
                    )) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_REQFILES_ADDNL,
                    reqFileSeqStr,
                    reqFile->ReqFilePath,
                    NULL,
                    0,
                    NULL
                    );
            }
        }
        reqFile = reqFile->Next;
    }
    if (newParams.FullFileSpec) {
        FreePathString (newParams.FullFileSpec);
    }

    return result;
}

BOOL
pHexMatch (
    IN      DWORD NewValue,
    IN      PCSTR Args
    )
{
    DWORD oldValue;

    if (!sscanf (Args, "%lx", &oldValue)) {
        DEBUGMSG ((DBG_ERROR, "pHexMatch: Invalid argument value (%s) in migdb.inf", Args));
        return FALSE;
    }
    if (oldValue == NewValue) {
        return TRUE;
    }
    else {
        return (_atoi64 (Args) == NewValue);
    }
}


BOOL
pConvertDotStringToValue (
    IN      PCSTR String,
    OUT     ULONGLONG *Value
    )
{
    PWORD valueIdx;
    UINT index;

    valueIdx = (PWORD) Value + 3;

    for (index = 0 ; index < 4 ; index++) {

        if (*String == 0) {
            *valueIdx = 0xFFFF;
            valueIdx--;
            continue;
        }

        *valueIdx = (WORD) strtoul (String, &(PSTR) String, 10);
        if (*String && (_mbsnextc (String) != '.')) {
            return FALSE;
        }

        String = _mbsinc (String);
        valueIdx--;
    }

    return TRUE;
}


BOOL
pMaskHexMatch (
    IN      ULONGLONG NewValue,
    IN      PCSTR Args
    )
{
    ULONGLONG oldValue = 0;
    ULONGLONG mask = 0;
    PWORD maskIdx;
    PWORD valueIdx;
    UINT index;

    maskIdx = (PWORD)&mask + 3;
    valueIdx = (PWORD)&oldValue + 3;
    index = 0;

    while (Args && *Args) {

        if (index >= 4) {
            return FALSE;
        }

        *valueIdx = (WORD) strtoul ((PSTR)Args, &((PSTR)Args), 10);

        if (*Args) {
            if (_mbsnextc (Args) != '.') {
                return FALSE;
            }

            Args = _mbsinc (Args);
        }

        *maskIdx = 65535;

        valueIdx--;
        maskIdx--;
        index++;
    }

    NewValue = NewValue & mask;

    return (oldValue == NewValue);
}

BOOL
BinFileVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return pMaskHexMatch (GetBinFileVer (AttribParams->FileParams->FullFileSpec), Args);
}

BOOL
BinProductVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return pMaskHexMatch (GetBinProductVer (AttribParams->FileParams->FullFileSpec), Args);
}

BOOL
FileDateHi (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return pHexMatch (GetFileDateHi (AttribParams->FileParams->FullFileSpec), Args);
}

BOOL
FileDateLo (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return pHexMatch (GetFileDateLo (AttribParams->FileParams->FullFileSpec), Args);
}

BOOL
FileVerOs (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return pHexMatch (GetFileVerOs (AttribParams->FileParams->FullFileSpec), Args);
}

BOOL
FileVerType (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return pHexMatch (GetFileVerType (AttribParams->FileParams->FullFileSpec), Args);
}


BOOL
UpToBinProductVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    VERSION_STRUCT Version;
    ULONGLONG versionStampValue = 0;
    ULONGLONG maxValue;

    if (CreateVersionStruct (&Version, AttribParams->FileParams->FullFileSpec)) {
        versionStampValue = VerGetProductVer (&Version);
        DestroyVersionStruct (&Version);
    } else {
        return FALSE;
    }

    if (!pConvertDotStringToValue (Args, &maxValue)) {
        DEBUGMSG ((DBG_WHOOPS, "Invalid value of %s caused UpToBinProductVer to fail", Args));
        return FALSE;
    }

    return versionStampValue <= maxValue;
}


BOOL
UpToBinFileVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    VERSION_STRUCT Version;
    ULONGLONG versionStampValue = 0;
    ULONGLONG maxValue;

    if (CreateVersionStruct (&Version, AttribParams->FileParams->FullFileSpec)) {
        versionStampValue = VerGetFileVer (&Version);
        DestroyVersionStruct (&Version);
    } else {
        return FALSE;
    }

    if (!pConvertDotStringToValue (Args, &maxValue)) {
        DEBUGMSG ((DBG_WHOOPS, "Invalid value of %s caused UpToBinFileVer to fail", Args));
        return FALSE;
    }

    return versionStampValue <= maxValue;
}

BOOL
SectionKey (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    PSTR Section, Key;
    PSTR Value = NULL;
    CHAR Return[1024];
    DWORD Count;
    BOOL b = FALSE;

    Section = DuplicateText (Args);
    MYASSERT (Section);

    Key = _mbschr (Section, '\\');
    if (Key) {

        *Key = 0;
        Key++;

        Value = _mbschr (Key, '\\');

        if (Value) {

            *Value = 0;
            Value++;
        }
    }

    Count = GetPrivateProfileString (
                Section,
                Key,
                "",
                Return,
                sizeof (Return),
                AttribParams->FileParams->FullFileSpec
                );

    if (Count > 0) {
        if (!Value || StringIMatch (Value, Return)) {
            b = TRUE;
        }
    }

    FreeText (Section);

    return b;
}

BOOL 
IsItInstalled (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    TCHAR RegKey[MAX_REGISTRY_KEY] = "HKLM\\SOFTWARE\\Microsoft\\";
    StringCat(RegKey, Args);
    
    return RegKeyPresent(AttribParams, RegKey);
}

BOOL 
HasUninstall (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    TCHAR RegKey[MAX_REGISTRY_KEY] = "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\";
    StringCat(RegKey, Args);
    StringCat(RegKey, TEXT("\\[UninstallString]"));

    return RegKeyPresent(AttribParams, RegKey);
}

BOOL
RegKeyPresent (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    BOOL b = FALSE;
    CHAR RegKey[MAX_REGISTRY_KEY];
    CHAR RegValue[MAX_REGISTRY_VALUE_NAME];
    BOOL HasValue;
    INT Index;
    PCSTR p;
    BOOL IsHkr;
    BOOL Present;
    HKEY Key;
    PBYTE Data;

    HasValue = DecodeRegistryString (Args, RegKey, RegValue, NULL);

    //
    // Is this HKR?
    //

    Index = GetOffsetOfRootString (RegKey, NULL);
    p = GetRootStringFromOffset (Index);

    if (!p) {
        DEBUGMSG ((DBG_WHOOPS, "Parse error: %s is not a valid key", Args));
        return FALSE;
    }

    IsHkr = !StringICompare (p, "HKR") || !StringICompare (p, "HKEY_ROOT");

    //
    // Verify value is present
    //

    if (IsHkr) {
        //
        // Check global table for the root
        //

        if (!g_PerUserRegKeys) {
            return FALSE;
        }

        if (HtFindStringAndData (g_PerUserRegKeys, Args, &Present)) {
            b = Present;
        }
        ELSE_DEBUGMSG ((DBG_WHOOPS, "Arg %s is not in the HKR hash table", Args));

    } else {
        //
        // Ping the registry
        //

        Key = OpenRegKeyStr (RegKey);

        if (Key) {
            if (HasValue) {
                Data = GetRegValueData (Key, RegValue);
                if (Data) {
                    b = TRUE;
                    MemFree (g_hHeap, 0, Data);
                }
            } else {
                b = TRUE;
            }

            CloseRegKey (Key);
        }
    }

    return b;
}



BOOL
AtLeastWin98 (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCSTR Args
    )
{
    return ISATLEASTWIN98();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\hlpfiles.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hlpfiles.c

Abstract:

    Implements a function that is called for every file or directory,
    selects HLP files trying to detect help files that will not
    work after upgrade is complete.

    This code might run if _UNICODE is defined, although it processes only ANSI
    strings. The only exception is in it's entry point (ProcessHelpFile) and
    in function pCheckSubsystemMatch.

Author:

    Calin Negreanu (calinn) 25-Oct-1997

Revision History:

    calinn      23-Sep-1998 File mapping

--*/

#include "pch.h"

//since we are reading from a file we need that sizeof to give us the accurate result
#pragma pack(push,1)


#define DBG_HELPFILES    "HlpCheck"


// Help 3.0 version and format numbers

#define Version3_0  15
#define Format3_0   1


// Help 3.1 version and format numbers

#define Version3_1  21
#define Format3_5   1


// Help 4.0 version and format numbers

#define Version40   33
#define Version41   34


//magic numbers and various constants

#define HF_MAGIC    0x5F3F
#define HF_VERSION  0x03
#define WhatWeKnow  'z'
#define BT_MAGIC    0x293B
#define BT_VERSION  0x02
#define SYSTEM_FILE "|SYSTEM"

#define MACRO_NEEDED_0 "RegisterRoutine(\""
#define MACRO_NEEDED_1 "RR(\""


//help file header
typedef struct _HF_HEADER {
    WORD    Magic;          //magic number, for hlp files is 0x5F3F (?_ - the help icon (with shadow))
    BYTE    Version;        //version identification number, must be 0x03
    BYTE    Flags;          //file flags
    LONG    Directory;      //offset of directory block
    LONG    FirstFree;      //offset of head of free list
    LONG    Eof;            //virtual end of file
} HF_HEADER, *PHF_HEADER;

//internal file header
typedef struct _IF_HEADER {
    LONG    BlockSize;      //block size (including header)
    LONG    FileSize;       //file size (not including header)
    BYTE    Permission;     //low byte of file permissions
} IF_HEADER, *PIF_HEADER;

//internal |SYSTEM file header
typedef struct _SF_HEADER {
    LONG    BlockSize;      //block size (including header)
    LONG    FileSize;       //file size (not including header)
    BYTE    Permission;     //low byte of file permissions
    WORD    Magic;          //Magic word = 0x036C
    WORD    VersionNo;      //version   :   15 - version 3.0
                            //              21 - version 3.5
                            //              33 - version 4.0
                            //              34 - version 4.1
    WORD    VersionFmt;     //version format    1 - format 3.0
                            //                  1 - format 3.5
    LONG    DateCreated;    //creation date
    WORD    Flags;          //flags : fDEBUG  0x01, fBLOCK_COMPRESSION  0x4
} SF_HEADER, *PSF_HEADER;

#define MAX_FORMAT  15

//btree header
typedef struct _BT_HEADER {
    WORD    Magic;          //magic number = 0x293B
    BYTE    Version;        //version = 2
    BYTE    Flags;          //r/o, open r/o, dirty, isdir
    WORD    BlockSize;      //size of a block (bytes)
    CHAR    Format[MAX_FORMAT+1];//key and record format string  - MAXFORMAT=15
    //**WARNING! the first character should be z for the btree we are going to read**

    WORD    First;          //first leaf block in tree
    WORD    Last;           //last leaf block in tree
    WORD    Root;           //root block
    WORD    Free;           //head of free block list
    WORD    Eof;            //next bk to use if free list empty
    WORD    Levels;         //number of levels currently in tree
    LONG    Entries;        //number of keys in btree
} BT_HEADER, *PBT_HEADER;

//index page header
typedef struct _IDX_PAGE {
    SHORT   Slack;          //unused space at the end of page (bytes)
    SHORT   Keys;           //# of keys in page
    WORD    PreviousPage;   //pointer to parent page (FFFF if it's root page)
} IDX_PAGE, *PIDX_PAGE;

//leaf page header
typedef struct _LEAF_PAGE {
    SHORT   Slack;          //unused space at the end of page (bytes)
    SHORT   Keys;           //# of keys in page
    WORD    PreviousPage;   //pointer to previous page (FFFF if it's first)
    WORD    NextPage;       //pointer to next page (FFFF if it's last)
} LEAF_PAGE, *PLEAF_PAGE;

//format of info in |SYSTEM file
typedef struct _DATA_HEADER {
    WORD    InfoType;       //info type
    WORD    InfoLength;     //# of bytes containing the info
} DATA_HEADER, *PDATA_HEADER;

//types of info in |SYSTEM file
enum {
    tagFirst,     // First tag in the list
    tagTitle,     // Title for Help window (caption)
    tagCopyright, // Custom text for About box
    tagContents,  // Address for contents topic
    tagConfig,    // Macros to be run at load time
    tagIcon,      // override of default help icon
    tagWindow,    // secondary window info
    tagCS,        // character set
    tagCitation,  // Citation String

    // The following are new to 4.0

    tagLCID,      // Locale ID and flags for CompareStringA
    tagCNT,       // .CNT help file is associated with
    tagCHARSET,   // charset of help file
    tagDefFont,   // default font for keywords, topic titles, etc.
    tagPopupColor,// color of popups from a window
    tagIndexSep,  // index separating characters
    tagLast       // Last tag in the list
};

//
// for tagLCID
//
typedef struct {
	DWORD  fsCompareI;
	DWORD  fsCompare;
	LANGID langid;
} KEYWORD_LOCALE, *PKEYWORD_LOCALE;


#define DOS_SIGNATURE 0x5A4D      // MZ
#define NE_SIGNATURE  0x454E      // New Executable file format signature - NE
#define PE_SIGNATURE  0x00004550  // Portable Executable file format signature - PE00

#pragma pack(pop)


ULONG
pQueryBtreeForFile (
    IN PCSTR BtreeImage,
    IN PCSTR StringNeeded
    )

/*++

Routine Description:

  This routine will traverse a b tree trying to find the string passed as parameter.
  It will return the pointer associated with the passed string or NULLto the beginning of the internal |SYSTEM file of a HLP file.

Arguments:

  BtreeImage - Pointer to the beginning of the b tree
  StringNeeded - String to find in b tree

Return Value:

  It will return the pointer associated with the passed string or NULL if string could not be found or some error occured.

--*/

{
    PBT_HEADER pbt_Header;
    ULONG systemFileOffset = 0;

    WORD bt_Page;
    UINT bt_Deep;
    INT  bt_KeysRead;

    PIDX_PAGE pbt_PageHeader;
    PCSTR pbt_LastString;
    PCSTR pbt_CurrentKey;

    LONG *pbt_LastLongOff = NULL;
    WORD *pbt_LastWordOff = NULL;

    BOOL found = FALSE;

    //let's read b tree header
    pbt_Header = (PBT_HEADER) BtreeImage;

    //check this b tree header to see if it's valid
    if ((pbt_Header->Magic      != BT_MAGIC  ) ||
        (pbt_Header->Version    != BT_VERSION) ||
        (pbt_Header->Format [0] != WhatWeKnow)
       ) {
        //invalid b tree header.
        return 0;
    }

    //let's see if there is something in this b tree
    if ((pbt_Header->Levels  == 0) ||
        (pbt_Header->Entries <= 0)
       ) {
        //nothing else to do
        return 0;
    }

    //now we are going to loop until we find our string or until we are sure that the string
    //does not exist. We are reffering all the time to a certain page from the b tree (starting
    //with root page.

    //initializing current processing page
    bt_Page = pbt_Header->Root;

    //initializing deep counter
    //we count how deep we are to know if we are processing an index page (deep < btree deepmax)
    //or a leaf page (deep == btree deepmax)
    bt_Deep = 1;

    //we are breaking the loop if:
    // 1. we reached the maximum deep level and we didn't find the string
    // 2. first key in the current page was already greater than our string and
    //    there is no previous page.
    while (!found) {
        //for each page we are using three pointers:
        //  one to the page header
        //  one to the key currently beeing processed
        //  one to the last string <= our string (this can be NULL)
        pbt_PageHeader = (PIDX_PAGE) (BtreeImage + sizeof (BT_HEADER) + (bt_Page * pbt_Header->BlockSize));
        pbt_CurrentKey = (PCSTR) pbt_PageHeader;
        pbt_CurrentKey += (bt_Deep == pbt_Header->Levels) ? sizeof (LEAF_PAGE) : sizeof (IDX_PAGE);
        pbt_LastString = NULL;

        //initializing number of keys read.
        bt_KeysRead = 0;

        //we are reading every key in this page until the we find one greater than our string
        //In the same time we try not to read too many keys
        while ((bt_KeysRead < pbt_PageHeader->Keys) &&
               (StringCompareA (StringNeeded, pbt_CurrentKey) >= 0)
              ) {

            pbt_LastString = pbt_CurrentKey;

            bt_KeysRead++;

            //passing the string in this key
            pbt_CurrentKey = GetEndOfStringA (pbt_CurrentKey) + 1;

            //read this key associated value
            pbt_LastLongOff = (LONG *)pbt_CurrentKey;
            pbt_LastWordOff = (WORD *)pbt_CurrentKey;

            //now if this is an index page then there is a WORD here, otherwise a LONG
            pbt_CurrentKey += (bt_Deep == pbt_Header->Levels) ? sizeof (LONG) : sizeof (WORD);

        }

        //OK, now we have passed the string we are looking for. If the last found value is valid
        //(is <= for an index page) (is == for a leaf page) then keep with it.
        if (!pbt_LastString) {
            //we found nothing. The first key was already greater that our string
            //we try to get to the previous page if we have one. If not, there is
            //nothing else to do
            if (pbt_PageHeader->PreviousPage != 0xFFFF) {
                bt_Deep++;
                bt_Page = pbt_PageHeader->PreviousPage;
                continue;
            }
            else {
                return 0;
            }
        }

        //Now in the string pointed by pbt_LastString we have something <= our string. If this is an index
        //page then we move on else those two strings should be equal.
        if (bt_Deep != pbt_Header->Levels) {
            //We are on an index page. Mark going deeper and moving on.
            bt_Deep++;
            bt_Page = *pbt_LastWordOff;
            continue;
        }

        if (!StringMatchA (StringNeeded, pbt_LastString)) {
            //We are on a leaf page and the strings are not equal. Our string does not exist.
            //nothing else to do
            return 0;
        }

        found = TRUE;
        systemFileOffset = *pbt_LastLongOff;
    }

    return systemFileOffset;
}


PCSTR
pGetSystemFilePtr (
    IN PCSTR FileImage
    )

/*++

Routine Description:

  This routine will return a pointer to the beginning of the internal |SYSTEM file of a HLP file.

Arguments:

  FileImage - Pointer to the beginning of the HLP file

Return Value:

  NULL if an error occured, a valid pointer to the beginning of the |SYSTEM file otherwise

--*/
{
    PCSTR systemFileImage = NULL;
    PHF_HEADER phf_Header;

    //we are going to read from various portions of this memory mapped file. There
    //is no guarantee that we are going to keep our readings inside the file so let's
    //prevent any access violation.
    __try {

        //first check if we are really dealing with a HLP file
        phf_Header = (PHF_HEADER) FileImage;

        if ((phf_Header->Magic   != HF_MAGIC  ) ||
            (phf_Header->Version != HF_VERSION)
           ) {
            __leave;
        }

        //according to the hacked specs phf_header->Directory gives us the offset of
        //directory block relativ to the beginning of the HLP file. Here we find an
        //internal file header followed by a b tree.

        //now get the |SYSTEM internal file address passing the address of the b tree header.
        systemFileImage = FileImage + pQueryBtreeForFile (FileImage + phf_Header->Directory + sizeof (IF_HEADER), SYSTEM_FILE);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    return systemFileImage;
}


#define MODULE_OK          0
#define MODULE_NOT_FOUND   1
#define MODULE_BROKEN      2
#define MODULE_MISMATCHED  3

INT
pCheckSubsystemByModule (
    IN PCSTR FileName,
    IN WORD VersionNo,
    IN PCSTR ModuleName
    )

/*++

Routine Description:

  Checks a help file and an extension module to see if are going to be loaded in the same
  subsystem while running in NT.

Arguments:

  FileName - The help file (full path)
  VersionNo - version of help file
  ModuleName - contains module name

Return Value:

  MODULE_OK - if both help file and module will be loaded in same subsystems in NT.
  MODULE_NOT_FOUND - if the needed module could not be located
  MODULE_BROKEN - if broken or not a windows module
  MODULE_MISMATCHED - if help file and module will be loaded in different subsystems in NT.

--*/

{
    PCSTR  fileImage   = NULL;
    HANDLE mapHandle   = NULL;
    HANDLE fileHandle  = INVALID_HANDLE_VALUE;


    PDOS_HEADER pdos_Header;
    LONG *pPE_Signature;
    WORD *pNE_Signature;
    CHAR fullPath [MAX_MBCHAR_PATH];
    CHAR key [MEMDB_MAX];
    PSTR endPtr;
    PSTR dontCare;
    INT result = MODULE_BROKEN;

    MemDbBuildKey (key, MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, ModuleName, NULL, NULL);
    if (MemDbGetValue (key, NULL)) {
        return MODULE_OK;
    }

    //if out of memory we will not come back here so not checking this
    __try {

        //preparing fullPath to contain only the HelpFile path
        StringCopyA (fullPath, FileName);

        endPtr = (PSTR) GetFileNameFromPathA (fullPath);

        if (!endPtr) {
            result = MODULE_OK;
            __leave;
        }

        *endPtr = 0;

        if ((!SearchPathA (
                fullPath,
                ModuleName,
                ".EXE",
                MAX_MBCHAR_PATH,
                fullPath,
                &dontCare)) &&
            (!SearchPathA (
                fullPath,
                ModuleName,
                ".DLL",
                MAX_MBCHAR_PATH,
                fullPath,
                &dontCare)) &&
            (!SearchPathA (
                NULL,
                ModuleName,
                ".EXE",
                MAX_MBCHAR_PATH,
                fullPath,
                &dontCare)) &&
            (!SearchPathA (
                NULL,
                ModuleName,
                ".DLL",
                MAX_MBCHAR_PATH,
                fullPath,
                &dontCare))
           ) {
            result = MODULE_NOT_FOUND;
            __leave;
        }

        //map the file into memory and get a it's address
        fileImage = MapFileIntoMemory (fullPath, &fileHandle, &mapHandle);

        if (fileImage == NULL) {
            result = MODULE_NOT_FOUND;
            __leave;
        }

        //map dos header into view of file
        pdos_Header = (PDOS_HEADER) fileImage;

        //now see what kind of signature we have there
        pNE_Signature = (WORD *) (fileImage + pdos_Header->e_lfanew);
        pPE_Signature = (LONG *) (fileImage + pdos_Header->e_lfanew);

        if (*pNE_Signature == NE_SIGNATURE) {

            //this is New Executable format
            result = (VersionNo > Version3_1) ? MODULE_MISMATCHED : MODULE_OK;

        } else if (*pPE_Signature == PE_SIGNATURE) {

            //this is Portable Executable format
            result = (VersionNo <= Version3_1) ? MODULE_MISMATCHED : MODULE_OK;

        }

    }
    __finally {
        //unmap and close module
        UnmapFile ((PVOID) fileImage, mapHandle, fileHandle);
    }

    return result;
}


BOOL
pCheckSubsystemMatch (
    IN PCSTR HlpName,
    IN PCSTR FriendlyName,          OPTIONAL
    IN WORD VersionNo
    )

/*++

Routine Description:

  Checks all extension modules listed in MemDB category MEMDB_CATEGORY_HELP_FILES_DLLA
  to see if are going to be loaded in the same subsystem while running in NT.

Arguments:

  HlpName - The help file (full path)
  VersionNo - version of help file
  KeyPath - contains category and module name (Ex:HelpFilesDll\foo.dll)

Return Value:

  TRUE if successful, FALSE if at least one error occured

--*/

{
    INT result;
    MEMDB_ENUMA e;
    PCSTR moduleName;

    PCTSTR ArgList[3];
    PCTSTR Comp;

    //see if there is any aditional dll
    if (!MemDbEnumFirstValueA (
            &e,
            MEMDB_CATEGORY_HELP_FILES_DLLA,
            MEMDB_ALL_SUBLEVELS,
            MEMDB_ENDPOINTS_ONLY
            )) {
        return TRUE;
    }

    do {
        moduleName = _mbschr (e.szName, '\\');
        if (!moduleName) {
            continue;
        }
        moduleName = (PCSTR) _mbsinc (moduleName);
        result = pCheckSubsystemByModule (
                    HlpName,
                    VersionNo,
                    moduleName
                    );
        switch (result) {
        case MODULE_NOT_FOUND:

#ifdef UNICODE
            ArgList[0] = ConvertAtoW (moduleName);
            ArgList[1] = ConvertAtoW (HlpName);
#else
            ArgList[0] = moduleName;
            ArgList[1] = HlpName;
#endif
            LOG ((LOG_WARNING, (PCSTR)MSG_HELPFILES_NOTFOUND_LOG, ArgList[0], ArgList[1]));
#ifdef UNICODE
            FreeConvertedStr (ArgList[0]);
            FreeConvertedStr (ArgList[1]);
#endif
            break;
        case MODULE_BROKEN:
#ifdef UNICODE
            ArgList[0] = ConvertAtoW (moduleName);
            ArgList[1] = ConvertAtoW (HlpName);
#else
            ArgList[0] = moduleName;
            ArgList[1] = HlpName;
#endif
            LOG ((LOG_WARNING, (PCSTR)MSG_HELPFILES_BROKEN_LOG, ArgList[0], ArgList[1]));
#ifdef UNICODE
            FreeConvertedStr (ArgList[0]);
            FreeConvertedStr (ArgList[1]);
#endif
            break;
        case MODULE_MISMATCHED:
            if ((!FriendlyName) || (*FriendlyName == 0)) {
                FriendlyName = (PCSTR) GetFileNameFromPathA (HlpName);
            }
#ifdef UNICODE
            ArgList[0] = ConvertAtoW (moduleName);
            ArgList[1] = ConvertAtoW (HlpName);
            ArgList[2] = ConvertAtoW (FriendlyName);
#else
            ArgList[0] = moduleName;
            ArgList[1] = HlpName;
            ArgList[2] = FriendlyName;
#endif
            Comp = BuildMessageGroup (MSG_MINOR_PROBLEM_ROOT, MSG_HELPFILES_SUBGROUP, ArgList[2]);
            MsgMgr_ObjectMsg_Add (HlpName, Comp, NULL);
            FreeText (Comp);
            LOG ((LOG_WARNING, (PCSTR)MSG_HELPFILES_MISMATCHED_LOG, ArgList[0], ArgList[1]));
#ifdef UNICODE
            FreeConvertedStr (ArgList[0]);
            FreeConvertedStr (ArgList[1]);
            FreeConvertedStr (ArgList[2]);
#endif
            break;
        }

    }
    while (MemDbEnumNextValueA (&e));

    MemDbDeleteTreeA (MEMDB_CATEGORY_HELP_FILES_DLLA);

    return TRUE;
}


BOOL
pSkipPattern (
    IN PCSTR Source,
    IN OUT PCSTR *Result,
    IN PCSTR StrToSkip
    )

/*++

Routine Description:

  Skips a whole pattern. Usually when making simple parsers that are not supposed to
  raise an error message it's enough to know if the string that you parse is correct or not.
  For example if you want to see if a string complies with a pattern like "RR(\"" you don't
  have to scan for each symbol separately, just call this function with StrToSkip="RR(\""
  The good thing is that this function skips also the spaces for you so a string like
  "   RR  (  \"  " will match the pattern above.
  ANSI only!!!

Arguments:

  Source - String to scan
  Result - If not NULL it will point right after the pattern if successful
  StrToSkip - Pattern to match and skip

Return Value:

  TRUE if was able to match the pattern, FALSE otherwise

--*/

{

    //first skip spaces
    Source    = SkipSpaceA (Source   );
    StrToSkip = SkipSpaceA (StrToSkip);

    //now try to see if the strings match
    while ((*Source   ) &&
           (*StrToSkip) &&
           (_totlower (*Source) == _totlower (*StrToSkip))
           ) {
        Source    = _mbsinc (Source   );
        StrToSkip = _mbsinc (StrToSkip);
        Source    = SkipSpaceA (Source   );
        StrToSkip = SkipSpaceA (StrToSkip);
    }

    if (*StrToSkip) {
        return FALSE;
    }

    if (Result) {
        *Result = Source;
    }

    return TRUE;

}


BOOL
pParseMacro (
    IN PCSTR FileName,
    IN WORD VersionNo,
    IN PCSTR MacroStr
    )

/*++

Routine Description:

  Parses a macro from |SYSTEM file inside a HLP file to see if there is a RegisterRoutine macro
  If true, then it will eventually do something with that information.

Arguments:

  MacroStr - String to parse

  VersionNo - Version number for this help file (we will use this to identify the subsystem where
              this file is more likely to be loaded).

Return Value:

  TRUE if successful, FALSE if at least one error occured

--*/

{
    BOOL result = TRUE;

    PCSTR endStr;

    char dllName[MAX_MBCHAR_PATH];
    char exportName[MAX_MBCHAR_PATH];
    PCSTR dllNameNoPath;

    //let's see if we have a pattern like RegisterRoutine(" or RR(" here
    if (!pSkipPattern (MacroStr, &MacroStr, MACRO_NEEDED_0)) {
        if (!pSkipPattern (MacroStr, &MacroStr, MACRO_NEEDED_1)) {
            return TRUE;
        }
    }

    //OK, we are ready to extract the dll name from the macro string
    endStr = _mbschr (MacroStr, '\"');

    if (!endStr) {
        return FALSE;
    }

    endStr = (PCSTR) _mbsinc (SkipSpaceRA (MacroStr, _mbsdec(MacroStr, endStr)));

    if (!endStr) {
        return FALSE;
    }

    //now we have the dll name between MacroStr and EndStr
    //a little safety check
    if ((endStr - MacroStr) >= MAX_MBCHAR_PATH-1) {
        return FALSE;
    }

    StringCopyABA (dllName, MacroStr, endStr);
    if (!dllName[0]) {
        return FALSE;
    }

    //now see if this is a full path file name or not
    dllNameNoPath = GetFileNameFromPathA (dllName);

    //ok, now the following pattern should be >>","<<
    if (!pSkipPattern (endStr, &MacroStr, "\",\"")) {
        return TRUE;
    }

    //OK, we are ready to extract the export function name from the macro string
    endStr = _mbschr (MacroStr, '\"');

    if (!endStr) {
        return FALSE;
    }

    endStr = (PCSTR) _mbsinc (SkipSpaceRA (MacroStr, _mbsdec(MacroStr, endStr)));

    if (!endStr) {
        return FALSE;
    }

    //now we have the dll name between MacroStr and EndStr

    //a little safety check
    if ((endStr - MacroStr) >= MAX_MBCHAR_PATH-1) {
        return FALSE;
    }

    StringCopyABA (exportName, MacroStr, endStr);
    if (!exportName[0]) {
        return FALSE;
    }

    //add to MemDb in HelpFilesDll category
    if (!MemDbSetValueExA (
            MEMDB_CATEGORY_HELP_FILES_DLLA,
            dllNameNoPath,
            NULL,
            NULL,
            0,
            NULL
            )) {
        return FALSE;
    }

    return result;
}


BOOL
pCheckDlls (
    IN PCSTR FileName,
    IN PCSTR SystemFileImage
    )

/*++

Routine Description:

  This routine checks the internal |SYSTEM file of a HLP file looking for additional
  Dll's. It does that trying to find either "RegisterRoutine" or "RR" macros.
  For every Dll found tries to match the Dll with the HLP file version.
  For every incompatibility found, adds an entry in the report presented to the user.

Arguments:

  FileName - Full name of the help file
  SystemFileImage - Pointer to the beginning of the internal |SYSTEM file.

Return Value:

  TRUE if successful, FALSE if at least one error occured

--*/

{
    PSF_HEADER psf_Header;
    PDATA_HEADER pdata_Header;
    PCSTR currImage;
    PCSTR friendlyName = NULL;
    LONG sf_BytesToRead;
    BOOL result = TRUE;
    BOOL bNoFriendlyName = FALSE;

    //we are going to read from various portions of this memory mapped file. There
    //is no guarantee that we are going to keep our readings inside the file so let's
    //prevent any access violation.
    __try {

        //first thing. Extract help file version
        psf_Header = (PSF_HEADER) SystemFileImage;

        //if file version is 3.0 or less we have nothing else to do
        if (psf_Header->VersionNo <= Version3_0) {
            __leave;
        }

        //Now scanning |SYSTEM file looking for macros. We must be careful to stop when
        //this internal file is over.
        sf_BytesToRead = psf_Header->FileSize + sizeof (IF_HEADER) - sizeof (SF_HEADER);
        currImage = SystemFileImage + sizeof (SF_HEADER);

        while (sf_BytesToRead > 0) {

            //map a data header
            pdata_Header = (PDATA_HEADER) currImage;

            currImage += sizeof (DATA_HEADER);
            sf_BytesToRead -= sizeof (DATA_HEADER);

            //see what kind of info we have here (macros are in tagConfig)
            if (pdata_Header->InfoType == tagConfig) {

                //parsing the string to see if there is a RegisterRoutine macro
                //If so we are going to store the Dll into MemDB.
                if (!pParseMacro(FileName, psf_Header->VersionNo, currImage)) {
                    result = FALSE;
                    __leave;
                }

            } else if (pdata_Header->InfoType == tagTitle) {

                //Now we have the help file friendly name. Map ANSI string
                if (!bNoFriendlyName) {
                    friendlyName = currImage;
                }
            } else if (pdata_Header->InfoType == tagLCID) {
                if (pdata_Header->InfoLength == sizeof (KEYWORD_LOCALE)) {

                    DWORD lcid;
                    PKEYWORD_LOCALE pkl = (PKEYWORD_LOCALE)currImage;

                    lcid = MAKELCID (pkl->langid, SORT_DEFAULT);
                    if (!IsValidLocale (lcid, LCID_INSTALLED)) {
                        //
                        // the title is not friendly
                        //
                        bNoFriendlyName = TRUE;
                        friendlyName = NULL;
                    }
                }
            }

            currImage      += pdata_Header->InfoLength;
            sf_BytesToRead -= pdata_Header->InfoLength;

        }

        //we finally finished scanning the help file. Let's take advantage of the __try __except block
        //and try to see if this help file and all it's extension dlls will run in the same
        //subsystem on NT.
        if (!pCheckSubsystemMatch (
                FileName,
                friendlyName,
                psf_Header->VersionNo
                )) {
            result = FALSE;
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        //if some exception occured maybe we managed to get something in MemDB
        //so let's make some cleanup
        MemDbDeleteTreeA (MEMDB_CATEGORY_HELP_FILES_DLLA);
        return FALSE;
    }

    return result;
}



BOOL
pProcessHelpFile (
    IN PCSTR FileName
    )

/*++

Routine Description:

  This routine checks a HLP file looking for additional DLLs used. If such a DLL is found
  we will try to see if this combination will run on NT. The fact is that depending on
  the version of the HLP file it will be opened by WinHelp.EXE (16 bit app) or
  WinHlp32.EXE (32 bit app). Now suppose that a HLP file is opened by WinHlp32.EXE and
  it has an additional 16 bit DLL, this combination will not work on NT (WinHlp32.EXE
  and the aditional DLL are running in differend subsystems).
  For every incompatibility found, we will add an entry in the report presented to the
  user.

Arguments:

  FileName - Full information about the location of the file

Return Value:

  TRUE if file was processed successful, FALSE if at least one error occured

--*/

{
    PCSTR  fileImage   = NULL;
    HANDLE mapHandle   = NULL;
    HANDLE fileHandle  = INVALID_HANDLE_VALUE;
    PCSTR  systemFileImage = NULL;

    BOOL result = TRUE;

    //map the file into memory and get a it's address
    fileImage = MapFileIntoMemory (FileName, &fileHandle, &mapHandle);

    __try {

        if (fileImage == NULL) {
            result = FALSE;
            __leave;
        }

        //find the internal file |SYSTEM
        systemFileImage = pGetSystemFilePtr (fileImage);

        if (systemFileImage == fileImage) {
            result = FALSE;
            __leave;
        }

        //check every additional dll used by help file
        result = result && pCheckDlls (FileName, systemFileImage);

    }
    __finally {
        //unmap and close help file
        UnmapFile ((PVOID) fileImage, mapHandle, fileHandle);
    }

    return result;
}


PSTR
pGetTitle (
    IN PCSTR FileName,
    IN PCSTR SystemFileImage
    )

/*++

Routine Description:

  This routine checks the internal |SYSTEM file of a HLP file looking for it's title

Arguments:

  FileName - Full name of the help file
  SystemFileImage - Pointer to the beginning of the internal |SYSTEM file.

Return Value:

  HLP file title (if available)

--*/

{
    PSF_HEADER psf_Header;
    PDATA_HEADER pdata_Header;
    PCSTR currImage;

    LONG sf_BytesToRead;

    PSTR result = NULL;

    //we are going to read from various portions of this memory mapped file. There
    //is no guarantee that we are going to keep our readings inside the file so let's
    //prevent any access violation.
    __try {

        //first thing. Extract help file version
        psf_Header = (PSF_HEADER) SystemFileImage;

        //if file version is 3.0 or less we have nothing else to do
        if (psf_Header->VersionNo <= Version3_0) {
            __leave;
        }

        //Now scanning |SYSTEM file looking for macros. We must be careful to stop when
        //this internal file is over.
        sf_BytesToRead = psf_Header->FileSize + sizeof (IF_HEADER) - sizeof (SF_HEADER);
        currImage = SystemFileImage + sizeof (SF_HEADER);

        while (sf_BytesToRead > 0) {

            //map a data header
            pdata_Header = (PDATA_HEADER) currImage;

            currImage += sizeof (DATA_HEADER);
            sf_BytesToRead -= sizeof (DATA_HEADER);

            if (pdata_Header->InfoType == tagTitle) {

                //Now we have the help file friendly name. Map ANSI string
                result = DuplicatePathStringA (currImage, 0);
                break;
            }

            currImage      += pdata_Header->InfoLength;
            sf_BytesToRead -= pdata_Header->InfoLength;

        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        result = NULL;
    }

    return result;
}


PSTR
GetHlpFileTitle (
    IN PCSTR FileName
    )

/*++

Routine Description:

  This routine opens a HLP file looking for it's title.

Arguments:

  FileName - Full information about the location of the file

Return Value:

  The title of the HLP file if available

--*/

{
    PCSTR  fileImage   = NULL;
    HANDLE mapHandle   = NULL;
    HANDLE fileHandle  = INVALID_HANDLE_VALUE;
    PCSTR  systemFileImage = NULL;

    PSTR result = NULL;

    //map the file into memory and get a it's address
    fileImage = MapFileIntoMemory (FileName, &fileHandle, &mapHandle);

    __try {

        if (fileImage == NULL) {
            __leave;
        }

        //find the internal file |SYSTEM
        systemFileImage = pGetSystemFilePtr (fileImage);

        if (systemFileImage == fileImage) {
            __leave;
        }

        //check every additional dll used by help file
        result = pGetTitle (FileName, systemFileImage);

    }
    __finally {
        //unmap and close help file
        UnmapFile ((PVOID) fileImage, mapHandle, fileHandle);
    }

    return result;
}


BOOL
ProcessHelpFile (
    IN PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  This routine is mainly a dispatcher. Will pass HLP files to routine pProcessHelpFile
  and modules to pProcessModule. The goal is to create two MemDb trees containing
  the export functions needed and provided to be able to estimate about some
  modules or help files not working after migration.

Arguments:

  Params - Full information about the location of the file

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PSTR fileName;
    TCHAR key[MEMDB_MAX];
    DWORD dontCare;

    //we are going to process this file if :
    // 1. has HLP extension
    // 2. is not marked as incompatible (this routine also checks for handled)

    if (!StringIMatch (Params->Extension, TEXT(".HLP"))||
        IsReportObjectIncompatible (Params->FullFileSpec)
       ) {
        return TRUE;
    }

    MemDbBuildKey (key, MEMDB_CATEGORY_COMPATIBLE_HLP, Params->FullFileSpec, NULL, NULL);
    if (MemDbGetValue (key, &dontCare)) {
        return TRUE;
    }

#ifdef UNICODE
    fileName = ConvertWtoA (Params->FullFileSpec);
#else
    fileName = (PSTR) Params->FullFileSpec;
#endif

    if (!pProcessHelpFile (fileName)) {
        DEBUGMSG ((DBG_HELPFILES, "Error processing help file %s", fileName));
    }

#ifdef UNICODE
    FreeConvertedStr (fileName);
#endif

    return TRUE;
}


DWORD
InitHlpProcessing (
    IN     DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_INIT_HLP_PROCESSING;
    case REQUEST_RUN:
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "KERNEL", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "KERNEL.EXE", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "KERNEL32", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "KERNEL32.DLL", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "KRNL386", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "KRNL386.EXE", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "USER", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "USER.EXE", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "USER32", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "USER32.DLL", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "GDI", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "GDI.EXE", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "GDI32", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "GDI32.DLL", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "SHELL", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "SHELL.DLL", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "SHELL32", NULL, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS, "SHELL32.DLL", NULL, NULL, 0, NULL);
        return ERROR_SUCCESS;
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in InitHlpProcessing"));
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\filescan.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    filescan.c

Abstract:

    This source file deals with file scanning phase.

Author:

    Calin Negreanu (calinn) 09-Feb-1998

Revision History:

    ovidiut     22-May-1999 Made AddMigrationPath globally accessible through w95upg.h
    jimschm     23-Sep-1998 mapif.h removal,
    calinn      31-Mar-1998 Dir recursion limited to ENUM_MAX_LEVELS (1024)

--*/

#include "pch.h"
#include "migappp.h"
#include "migdbp.h"

#define PROGBAR_DIR_LEVEL   2
#define MAX_BACKUPDIRS_IN_REPORT 5

GROWBUFFER g_OtherOsPaths = GROWBUF_INIT;

DWORD g_ProgressBarTicks;
BOOL g_OtherOsExists = FALSE;
BOOL g_IsFusionDir = FALSE;
HASHTABLE g_UseNtFileHashTable;

#define WINNT_FLAT              TEXT("WINNT.EXE")
#define WIN9X_FLAT              TEXT("WINSETUP.BIN")
#define WIN98_FLAT              TEXT("W98SETUP.BIN")
#define WIN3X_FLAT_1            TEXT("KRNL386.EX_")
#define WIN3X_FLAT_2            TEXT("KERNEL.EXE")
#define WINNT_INSTALLATION      TEXT("SYSTEM32\\NTOSKRNL.EXE")
#define WIN9X_INSTALLATION      TEXT("SYSTEM\\KERNEL32.DLL")
#define WIN3X_INSTALLATION_1    TEXT("SYSTEM\\KRNL386.EXE")
#define WIN3X_INSTALLATION_2    TEXT("SYSTEM\\KRNL386.EXE")
#define WIN3X_INSTALLATION_3    TEXT("SYSTEM\\KERNEL.EXE")
#define WINNT_SETUP_1           TEXT(":\\$WIN_NT$.~BT")
#define WINNT_SETUP_2           TEXT(":\\$WIN_NT$.~LS")
#define RECYCLE_1               TEXT(":\\RECYCLED")
#define RECYCLE_2               TEXT(":\\RECYCLER")

BOOL
pSpecialExcludedDir (
    IN      PCTSTR FullFileSpec
    )
{

    PCTSTR testPath = NULL;
    BOOL Result = TRUE;

    __try {

        if (StringIMatch (g_WinDir, FullFileSpec)) {
            Result = FALSE;
            __leave;
        }

        //
        // let's see if it's one of our dirs.
        //
        if (((*SOURCEDIRECTORY(0))&&(StringIMatch            (FullFileSpec, SOURCEDIRECTORY(0))                        )) ||
            ((*g_TempDirWack     )&&(StringIMatchCharCount (FullFileSpec, g_TempDirWack,     g_TempDirWackChars-1)     )) ||
            ((*g_PlugInDirWack   )&&(StringIMatchCharCount (FullFileSpec, g_PlugInDirWack,   g_PlugInDirWackChars-1)   )) ||
            ((*g_RecycledDirWack )&&(StringIMatchCharCount (FullFileSpec, g_RecycledDirWack, g_RecycledDirWackChars-1) ))) {
            __leave;
        }

        //
        //we are trying to see if we are entering a winnt, win95 or win3.x
        //flat directory
        //
        testPath = JoinPaths (FullFileSpec, WINNT_FLAT);
        if (DoesFileExist (testPath)) {
            __leave;
        }
        FreePathString (testPath);

        testPath = JoinPaths (FullFileSpec, WIN9X_FLAT);
        if (DoesFileExist (testPath)) {
            __leave;
        }
        FreePathString (testPath);

        testPath = JoinPaths (FullFileSpec, WIN98_FLAT);
        if (DoesFileExist (testPath)) {
            __leave;
        }
        FreePathString (testPath);

        testPath = JoinPaths (FullFileSpec, WIN3X_FLAT_1);
        if (DoesFileExist (testPath)) {
            __leave;
        }
        FreePathString (testPath);

        testPath = JoinPaths (FullFileSpec, WIN3X_FLAT_2);
        if (DoesFileExist (testPath)) {
            __leave;
        }
        FreePathString (testPath);

        //
        //we are trying to see if we are entering a winnt installation,
        //win95 installation or win3.x installation
        //
        testPath = JoinPaths (FullFileSpec, WINNT_INSTALLATION);
        if (DoesFileExist (testPath)) {
            MultiSzAppend (&g_OtherOsPaths, FullFileSpec);
            __leave;
        }
        FreePathString (testPath);

        if (FullFileSpec [0]) {

            testPath = _tcsinc (FullFileSpec);

            if ((StringIMatch (testPath, WINNT_SETUP_1)) ||
                (StringIMatch (testPath, WINNT_SETUP_2)) ||
                (StringIMatch (testPath, RECYCLE_1    )) ||
                (StringIMatch (testPath, RECYCLE_2    ))) {
                testPath = NULL;
                __leave;
            }
        }

        testPath = NULL;
        Result = FALSE;

    }
    __finally {
        if (testPath) {
            FreePathString (testPath);
            testPath = NULL;
        }
    }

    return Result;

}


INT
pCountDirectories (
    IN PCTSTR FullPath,
    IN PCTSTR DontCare,
    IN WIN32_FIND_DATA *FindData,
    IN DWORD EnumHandle,
    IN PVOID Params,
    PDWORD CurrentDirData
    )
{
    if (pSpecialExcludedDir (FullPath)) {

        ExcludePath (g_ExclusionValue, FullPath);
        return CALLBACK_DO_NOT_RECURSE_THIS_DIRECTORY;
    }

    if (!(FindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)) {
        g_ProgressBarTicks += TICKS_FILESCAN_DIR_INCREMENT;
    }

    return CALLBACK_CONTINUE;
}


DWORD
FileScan_GetProgressMax (
        VOID
        )
{
    ACCESSIBLE_DRIVE_ENUM e;
    DWORD Count = 0;

    g_ProgressBarTicks = 0;

    //
    // Enumerate of the accessible drives. The callback routine will keep track of all
    // of the directories on that drive to a depth of two.
    //
    if (GetFirstAccessibleDriveEx (&e, TRUE)) {
        do {

            //
            // restrict file system analyze to the windows drive
            //
            if (!EnumerateTree (
                e->Drive,
                pCountDirectories,
                NULL,                       // failure-logging callback
                g_ExclusionValue ,
                NULL,                       // unused
                PROGBAR_DIR_LEVEL,
                NULL,                       // Unused exclusion structure.
                FILTER_DIRECTORIES
                )) {

                LOG((LOG_ERROR,"Error counting directories on drive %s.",e->Drive));
            }

        } while (GetNextAccessibleDrive(&e));
    }

    DEBUGLOGTIME (("FileScan_GetProgressMax estimation: %lu", g_ProgressBarTicks));
    return g_ProgressBarTicks;
}


INT
pGetDirLevel (
    IN      PCTSTR DirName
    )
{
    INT result = 0;
    PCTSTR dirPtr = DirName;

    do {
        dirPtr = _tcschr (dirPtr, TEXT('\\'));
        if (dirPtr != NULL) {
            result++;
            dirPtr = _tcsinc (dirPtr);
            if (dirPtr[0] == 0) {
                result--;
                dirPtr = NULL;
            }
        }
    }
    while (dirPtr);

    return result;
}


INT
pProcessFileOrDir (
    IN      PCTSTR FullFileSpec,
    IN      PCTSTR DontCare,
    IN      WIN32_FIND_DATA *FindData,
    IN      DWORD EnumHandle,
    IN      LPVOID Params,
    IN OUT  PDWORD CurrentDirData
    )
{
    FILE_HELPER_PARAMS HelperParams;
    INT result = CALLBACK_CONTINUE;

    if (CANCELLED()) {
        SetLastError (ERROR_CANCELLED);
        return CALLBACK_FAILED;
    }

#ifdef DEBUG
    {
        TCHAR DbgBuf[256];

        if (GetPrivateProfileString ("FileScan", FullFileSpec, "", DbgBuf, 256, g_DebugInfPath)) {
            DEBUGMSG ((DBG_NAUSEA, "%s found", FullFileSpec));
        }
        if (GetPrivateProfileString ("FileScan", "All", "", DbgBuf, 256, g_DebugInfPath)) {
            DEBUGMSG ((DBG_NAUSEA, "%s", FullFileSpec));
        }
    }
#endif

    if (!SafeModeActionCrashed (SAFEMODEID_FILES, FullFileSpec)) {

        SafeModeRegisterAction(SAFEMODEID_FILES, FullFileSpec);

        __try {

            //
            //prepare structure for calling helper functions
            //
            HelperParams.FullFileSpec = FullFileSpec;
            HelperParams.Handled = 0;
            HelperParams.FindData = FindData;
            HelperParams.Extension = GetDotExtensionFromPath (HelperParams.FullFileSpec);
            HelperParams.VirtualFile = (FindData == NULL);
            HelperParams.CurrentDirData = CurrentDirData;

            if (FindData) {

                if ((FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {

                    if (pGetDirLevel (FullFileSpec) <= PROGBAR_DIR_LEVEL) {
                        // This is an increment point
                        if (!TickProgressBarDelta (TICKS_FILESCAN_DIR_INCREMENT)) {
                            SetLastError (ERROR_CANCELLED);
                            result = CALLBACK_FAILED;
                            __leave;
                        }
                        ProgressBar_SetSubComponent (FullFileSpec);
                    }
                    //
                    // If we know that this dir has something special and we must exclude it
                    // if you need to add code to exclude some dir plug it in pSpecialExcludedDir
                    //
                    if (pSpecialExcludedDir (FullFileSpec)) {
                        result = CALLBACK_DO_NOT_RECURSE_THIS_DIRECTORY;
                        __leave;
                    }

                    _tcssafecpy (HelperParams.DirSpec, FullFileSpec, MAX_TCHAR_PATH);
                    HelperParams.IsDirectory = TRUE;

                }
                else {

                    _tcssafecpyab (HelperParams.DirSpec, FullFileSpec, GetFileNameFromPath (FullFileSpec), MAX_TCHAR_PATH);
                    HelperParams.IsDirectory = FALSE;

                }
            } else {
                HelperParams.IsDirectory = FALSE;
            }

            // calling the process helper functions
            if (!ProcessFileHelpers (&HelperParams)) {
                result = CALLBACK_FAILED;
                __leave;
            }
        }
        __finally {
        }

        SafeModeUnregisterAction();
    }

    return result;
}


static
BOOL
pExamineAccessibleDrive (
    IN ACCESSIBLE_DRIVE_ENUM Enum
    )
{

    BOOL fRet = TRUE;

    //
    // Enumerate volume. FALSE retval ends enumeration; callback sets last error.
    //
    SetLastError (ERROR_SUCCESS);

    if (!(fRet = EnumerateTree (
            Enum -> Drive,
            pProcessFileOrDir,
            NULL,                         // No failure callback
            g_ExclusionValue,
            NULL,                         // Params - Unused.
            ENUM_MAX_LEVELS,
            NULL,
            FILTER_ALL
            ))
        ) {


        DEBUGMSG_IF ((
            GetLastError() != ERROR_SUCCESS         &&
                GetLastError() != ERROR_PATH_NOT_FOUND  &&
                GetLastError() != ERROR_CANCELLED,
            DBG_ERROR,
            "pAccessibleDrivesEnum_Callback: EnumerateTree failed."
            ));

        if (GetLastError() != ERROR_SUCCESS &&
            GetLastError() != ERROR_PATH_NOT_FOUND &&
            GetLastError() != ERROR_CANCELLED) {
            LOG ((
                LOG_ERROR,
                "Failure while enumerating tree. rc: %u",
                GetLastError()
                ));
        }
    }

    return fRet;
}

VOID
pReportOtherOs (
    VOID
    )
/*
    This function will report if other OS was found in the system. It will also report (with a strong message) if PATH variable points to
    some directories that belong to some other OSes.
*/
{
    MULTISZ_ENUM enumOsPaths;
    PCTSTR Group;
    PCTSTR Message;

    if (g_ConfigOptions.IgnoreOtherOS) {
        return;
    }

    if (g_OtherOsExists) {
        //
        // Already done.
        //
        return;
    }

    if (EnumFirstMultiSz (&enumOsPaths, g_OtherOsPaths.Buf)) {

        g_OtherOsExists = TRUE;
        Group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_OTHER_OS_WARNING_SUBGROUP, NULL);
        Message = GetStringResource (MSG_OTHER_OS_WARNING);

        if (Message && Group) {
            MsgMgr_ObjectMsg_Add (TEXT("*OtherOsFound"), Group, Message);
        }
        FreeText (Group);
        FreeStringResource (Message);

    }
}


VOID
AddMigrationPathEx (
    IN      PCTSTR PathLong,
    IN      DWORD Levels,
    IN      BOOL Win9xOsPath
    )

/*++

Routine Description:

  AddMigrationPath adds the specified path to MEMDB_CATEGORY_MIGRATION_PATHS,
  ensuring that PathLong is not a drive root; in this case Levels is set to 0

Arguments:

  PathLong - Specifies the path to be added (long file name format)

  Levels - Specifies how many levels (subdirs) are valid

  Win9xOsPath - Specifies TRUE if the path supplied should be treated as an OS path

Return Value:

  none

--*/

{
    TCHAR key[MEMDB_MAX];

    //
    // a drive spec is supposed to be one driveletter followed by a column (eg. l:)
    //
    if (_istalpha (PathLong[0]) && PathLong[1] == TEXT(':') &&
        (PathLong[2] == 0 || PathLong[2] == TEXT('\\') && PathLong[3] == 0)) {
        //
        // this is the root of a drive, so override Levels
        //
        Levels = 0;
    }
    if (StringIMatch (PathLong, g_ProgramFilesDir)) {
        Levels = 0;
    }
    MemDbBuildKey (key, MEMDB_CATEGORY_MIGRATION_PATHS, PathLong, NULL, NULL);
    MemDbSetValueAndFlags (key, Levels, Win9xOsPath ? TRUE : FALSE, 0);
}


VOID
pAddValueEnumDirsAsMigDirs (
    IN      PCTSTR Key,
    IN      DWORD Levels
    )
{
    HKEY key;
    REGVALUE_ENUM e;
    TCHAR  pathLong[MAX_TCHAR_PATH];
    PTSTR Data;
    PCTSTR pathExp;
    PTSTR filePtr;

    key = OpenRegKeyStr (Key);
    if (key != NULL) {
        if (EnumFirstRegValue (&e, key)) {
            do {
                Data = GetRegValueString (e.KeyHandle, e.ValueName);
                if (Data) {

                    ExtractArgZeroEx (Data, pathLong, NULL, FALSE);

                    if (*pathLong) {

                        pathExp = ExpandEnvironmentTextA(pathLong);
                        if (pathExp) {
                            // eliminate the file name
                            filePtr = (PTSTR)GetFileNameFromPath (pathExp);
                            if (filePtr) {
                                filePtr = _tcsdec (pathExp, filePtr);
                                if (filePtr) {
                                    *filePtr = 0;
                                }
                            }
                            if (filePtr && OurGetLongPathName (pathExp, pathLong, MAX_TCHAR_PATH)) {
                                AddMigrationPath (pathLong, Levels);
                            }
                            FreeText (pathExp);
                        }
                    }
                    MemFree (g_hHeap, 0, Data);
                }
            }
            while (EnumNextRegValue (&e));
        }
        CloseRegKey (key);
    }
}


VOID
pBuildMigrationPaths (
    VOID
    )
/*
    This function will create a list with all the paths that are considered "ours". Any other path that has OS files in it is considered
    a backup path. If an OS file is found in a "backup" path a warning is presented to the user.
*/
{
    PCTSTR pathExp  = NULL;
    TCHAR  pathLong [MAX_TCHAR_PATH];
    CHAR  pathExpAnsi [MAX_TCHAR_PATH];

    PATH_ENUM pathEnum;
    TCHAR dirName [MAX_TCHAR_PATH];
    INFCONTEXT context;

    PCTSTR argList[]={"ProgramFiles", g_ProgramFilesDir, "SystemDrive", g_WinDrive, NULL};

    HKEY appPathsKey, currentAppKey;
    REGKEY_ENUM appPathsEnum;
    PCTSTR appPaths = NULL;

    MEMDB_ENUM eFolder;
    TREE_ENUM eFile;
    PCTSTR extPtr;
    TCHAR shortcutTarget   [MAX_TCHAR_PATH];
    TCHAR shortcutArgs     [MAX_TCHAR_PATH];
    TCHAR shortcutWorkDir  [MAX_TCHAR_PATH];
    TCHAR shortcutIconPath [MAX_TCHAR_PATH];
    INT shortcutIcon;
    WORD shortcutHotKey;
    BOOL msDosMode;
    IShellLink *shellLink;
    IPersistFile *persistFile;
    PTSTR filePtr;

    HKEY sharedDllsKey;
    REGVALUE_ENUM sharedDllsEnum;
    DWORD Levels;

    //
    // First thing. Include PATH variable and root of the boot drive in our migration paths.
    //
    AddMigrationPath (g_BootDrive, 0);
    if (EnumFirstPath (&pathEnum, NULL, g_WinDir, g_SystemDir)) {
        do {
            pathExp = ExpandEnvironmentTextA(pathEnum.PtrCurrPath);
            filePtr = (PTSTR)GetFileNameFromPath (pathExp);
            if (*filePtr == 0) {
                filePtr = _tcsdec (pathExp, filePtr);
                if (filePtr) {
                    *filePtr = 0;
                }
            }
            if (OurGetLongPathName (pathExp, pathLong, MAX_TCHAR_PATH)) {
                AddMigrationPathEx (pathLong, 2, TRUE);
            }
            FreeText (pathExp);
        }
        while (EnumNextPath (&pathEnum));
        EnumPathAbort (&pathEnum);
    }

    //
    // Then include temporary directory as a tree
    //
    if (GetTempPath (MAX_TCHAR_PATH, pathLong)) {

        // eliminate \ from the end of a path
        filePtr = GetEndOfString (pathLong);
        filePtr = _tcsdec (pathLong, filePtr);
        if ((filePtr) &&
            (*filePtr == TEXT('\\'))
            ) {
            *filePtr = 0;
        }
        AddMigrationPath (pathLong, MAX_DEEP_LEVELS);
    }

    //
    // Then include known directories from win95upg.inf section "MigrationDirs".
    //
    MYASSERT (g_Win95UpgInf != INVALID_HANDLE_VALUE);

    if (SetupFindFirstLine (g_Win95UpgInf, S_MIGRATION_DIRS, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 1, dirName, MAX_TCHAR_PATH, NULL)) {
                pathExp = ExpandEnvironmentTextExA(dirName, argList);
                if (pathExp) {
                    filePtr = (PTSTR)GetFileNameFromPath (pathExp);
                    if (*filePtr == 0) {
                        filePtr = _tcsdec (pathExp, filePtr);
                        if (filePtr) {
                            *filePtr = 0;
                        }
                    }
                    if (OurGetLongPathName (pathExp, pathLong, MAX_TCHAR_PATH)) {
                        AddMigrationPathEx (pathLong, MAX_DEEP_LEVELS, TRUE);
                    }
                    //
                    // also add the path translated to ANSI (if different)
                    //
                    OemToCharA (pathExp, pathExpAnsi);
                    if (OurGetLongPathName (pathExpAnsi, pathLong, MAX_TCHAR_PATH)) {
                        AddMigrationPathEx (pathLong, MAX_DEEP_LEVELS, TRUE);
                    }

                    FreeText (pathExp);
                }
            }
        }
        while (SetupFindNextLine (&context, &context));
    }

    //
    // Then include known OEM directories from win95upg.inf section "OemMigrationDirs".
    //
    if (SetupFindFirstLine (g_Win95UpgInf, S_OEM_MIGRATION_DIRS, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 1, dirName, MAX_TCHAR_PATH, NULL)) {
                pathExp = ExpandEnvironmentTextExA(dirName, argList);
                if (pathExp) {
                    filePtr = (PTSTR)GetFileNameFromPath (pathExp);
                    if (*filePtr == 0) {
                        filePtr = _tcsdec (pathExp, filePtr);
                        if (filePtr) {
                            *filePtr = 0;
                        }
                    }
                    if (OurGetLongPathName (pathExp, pathLong, MAX_TCHAR_PATH)) {
                        Levels = 0;
                        if (SetupGetStringField (&context, 2, dirName, MAX_TCHAR_PATH, NULL)) {
                            if (_ttoi (dirName) != 0) {
                                Levels = MAX_DEEP_LEVELS;
                            }
                        }
                        AddMigrationPathEx (pathLong, Levels, TRUE);
                    }
                    FreeText (pathExp);
                }
            }
        }
        while (SetupFindNextLine (&context, &context));
    }

    //
    // Then include paths listed in SharedDlls key.
    //
    sharedDllsKey = OpenRegKeyStr (S_REG_SHARED_DLLS);
    if (sharedDllsKey != NULL) {
        if (EnumFirstRegValue (&sharedDllsEnum, sharedDllsKey)) {
            do {
                pathExp = ExpandEnvironmentTextA(sharedDllsEnum.ValueName);
                if (pathExp) {
                    // eliminate the file name
                    filePtr = (PTSTR)GetFileNameFromPath (pathExp);
                    if (filePtr) {
                        filePtr = _tcsdec (pathExp, filePtr);
                        if (filePtr) {
                            *filePtr = 0;
                        }
                    }
                    if (OurGetLongPathName (pathExp, pathLong, MAX_TCHAR_PATH)) {
                        AddMigrationPath (pathLong, 0);
                    }
                    FreeText (pathExp);
                }
            }
            while (EnumNextRegValue (&sharedDllsEnum));
        }
        CloseRegKey (sharedDllsKey);
    }

    //
    // Then include paths listed in AppPaths key.
    //
    appPathsKey = OpenRegKeyStr (S_SKEY_APP_PATHS);
    if (appPathsKey != NULL) {
        if (EnumFirstRegKey (&appPathsEnum, appPathsKey)) {
            do {
                currentAppKey = OpenRegKey (appPathsKey, appPathsEnum.SubKeyName);
                if (currentAppKey != NULL) {
                    appPaths = GetRegValueString (currentAppKey, TEXT("Path"));

                    if (appPaths != NULL) {

                        if (EnumFirstPath (&pathEnum, appPaths, NULL, NULL)) {
                            do {
                                pathExp = ExpandEnvironmentTextA(pathEnum.PtrCurrPath);
                                if (pathExp) {
                                    // eliminate \ from the end of a path
                                    filePtr = GetEndOfString (pathExp);
                                    filePtr = _tcsdec (pathExp, filePtr);
                                    if ((filePtr) &&
                                        (*filePtr == TEXT('\\'))
                                        ) {
                                        *filePtr = 0;
                                    }
                                    if (OurGetLongPathName (pathExp, pathLong, MAX_TCHAR_PATH)) {
                                        AddMigrationPath (pathLong, 2);
                                    }
                                    FreeText (pathExp);
                                }
                            }
                            while (EnumNextPath (&pathEnum));
                            EnumPathAbort (&pathEnum);
                        }
                        MemFree (g_hHeap, 0, appPaths);
                    }
                    CloseRegKey (currentAppKey);
                }
            }
            while (EnumNextRegKey (&appPathsEnum));
        }
        CloseRegKey (appPathsKey);
    }

    //
    // Then include paths listed in Run* keys.
    //
    pAddValueEnumDirsAsMigDirs (S_RUNKEY, 2);
    pAddValueEnumDirsAsMigDirs (S_RUNONCEKEY, 2);
    pAddValueEnumDirsAsMigDirs (S_RUNONCEEXKEY, 2);
    pAddValueEnumDirsAsMigDirs (S_RUNSERVICESKEY, 2);
    pAddValueEnumDirsAsMigDirs (S_RUNSERVICESONCEKEY, 2);
    pAddValueEnumDirsAsMigDirs (S_RUNKEY_USER, 2);
    pAddValueEnumDirsAsMigDirs (S_RUNONCEKEY_USER, 2);
    pAddValueEnumDirsAsMigDirs (S_RUNONCEEXKEY_USER, 2);
    pAddValueEnumDirsAsMigDirs (S_RUNONCEKEY_DEFAULTUSER, 2);
    pAddValueEnumDirsAsMigDirs (S_RUNONCEEXKEY_DEFAULTUSER, 2);
    pAddValueEnumDirsAsMigDirs (S_RUNKEY_DEFAULTUSER, 2);

    //
    // Finally include paths listed in all links from all user profiles.
    //
    if (InitCOMLink (&shellLink, &persistFile)) {

        if (MemDbEnumFirstValue (&eFolder, MEMDB_CATEGORY_NICE_PATHS"\\*", MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {

            do {
                if (*eFolder.szName == 0) {
                    continue;
                }
                // first: this directory is a migration directory
                AddMigrationPath (eFolder.szName, MAX_DEEP_LEVELS);
                //
                // For each shell folder we enumerate all links trying to get the path where the links are running
                //
                if (EnumFirstFileInTreeEx (&eFile, eFolder.szName, TEXT("*.*"), FALSE, FALSE, 0)) {
                    do {
                        if (!eFile.Directory) {
                            extPtr = GetFileExtensionFromPath (eFile.Name);
                            if (extPtr) {
                                if (StringIMatch (extPtr, TEXT("LNK"))) {
                                    if (ExtractShellLinkInfo (
                                            shortcutTarget,
                                            shortcutArgs,
                                            shortcutWorkDir,
                                            shortcutIconPath,
                                            &shortcutIcon,
                                            &shortcutHotKey,
                                            NULL,
                                            eFile.FullPath,
                                            shellLink,
                                            persistFile
                                            )) {
                                        if (shortcutWorkDir [0] != 0) {
                                            AddMigrationPath  (shortcutWorkDir, 2);
                                        }
                                        if (shortcutTarget [0] != 0) {
                                            filePtr = (PTSTR)GetFileNameFromPath (shortcutTarget);
                                            if (filePtr) {
                                                filePtr = _tcsdec (shortcutTarget, filePtr);
                                                if (filePtr) {
                                                    *filePtr = 0;
                                                    AddMigrationPath (shortcutTarget, 2);
                                                }
                                            }
                                        }
                                    }
                                }
                                if (StringIMatch (extPtr, TEXT("PIF"))) {
                                    if (ExtractPifInfo (
                                            shortcutTarget,
                                            shortcutArgs,
                                            shortcutWorkDir,
                                            shortcutIconPath,
                                            &shortcutIcon,
                                            &msDosMode,
                                            NULL,
                                            eFile.FullPath
                                            ) == ERROR_SUCCESS) {
                                        if (shortcutWorkDir [0] != 0) {
                                            AddMigrationPath (shortcutWorkDir, 2);
                                        }
                                        if (shortcutTarget [0] != 0) {
                                            filePtr = (PTSTR)GetFileNameFromPath (shortcutTarget);
                                            if (filePtr) {
                                                filePtr = _tcsdec (shortcutTarget, filePtr);
                                                if (filePtr) {
                                                    *filePtr = 0;
                                                    AddMigrationPath (shortcutTarget, 2);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    while (EnumNextFileInTree (&eFile));
                }
            }
            while (MemDbEnumNextValue (&eFolder));
        }
        FreeCOMLink (&shellLink, &persistFile);
    }

#ifdef DEBUG
    if (GetPrivateProfileIntA ("Debug", "MigPaths", 0, g_DebugInfPathBufA) == 1) {
        if (MemDbGetValueEx (&eFolder, MEMDB_CATEGORY_MIGRATION_PATHS, NULL, NULL)) {
            DEBUGMSG(("Migration Paths:",""));
            do {
                DEBUGMSG(("","%s - %ld", eFolder.szName, eFolder.dwValue));
            }
            while (MemDbEnumNextValue (&eFolder));
        }
    }
#endif
}


VOID
pReportBackupDirs (
    )
{
    MEMDB_ENUM e;
    PCTSTR BackupDirsGroup;
    PCTSTR Message;
    PCTSTR ArgArray[2];
    TCHAR Buffer[12];

    if (g_BackupDirCount <= MAX_BACKUPDIRS_IN_REPORT) {

        if (MemDbGetValueEx (&e, MEMDB_CATEGORY_BACKUPDIRS, NULL, NULL)) {

            do {
                BackupDirsGroup = BuildMessageGroup (
                                        MSG_INSTALL_NOTES_ROOT,
                                        MSG_BACKUP_DETECTED_LIST_SUBGROUP,
                                        e.szName
                                        );
                if (BackupDirsGroup) {

                    MsgMgr_ObjectMsg_Add(
                        e.szName,
                        BackupDirsGroup,
                        S_EMPTY
                        );

                    FreeText (BackupDirsGroup);
                }
            } while (MemDbEnumNextValue (&e));

        } else {
            MYASSERT (!g_BackupDirCount);
        }

    } else {
        //
        // just put a generic message
        //
        BackupDirsGroup = BuildMessageGroup (
                                MSG_INSTALL_NOTES_ROOT,
                                MSG_BACKUP_DETECTED_SUBGROUP,
                                NULL
                                );
        if (BackupDirsGroup) {

            ArgArray[0] = g_Win95Name;
            wsprintf (Buffer, TEXT("%lu"), g_BackupDirCount);
            ArgArray[1] = Buffer;
            Message = ParseMessageID (MSG_BACKUP_DETECTED, ArgArray);
            if (Message) {

                MsgMgr_ObjectMsg_Add (
                    TEXT("*BackupDetected"),
                    BackupDirsGroup,
                    Message
                    );

                FreeStringResource (Message);

                //
                // write all backup dirs to the log file
                //
                if (MemDbGetValueEx (&e, MEMDB_CATEGORY_BACKUPDIRS, NULL, NULL)) {

                    do {
                        //
                        // write it in the log
                        //
                        LOG ((LOG_WARNING, (PCSTR)MSG_BACKUP_DETECTED_LOG, e.szName, g_Win95Name));
                    } while (MemDbEnumNextValue (&e));

                } else {
                    MYASSERT (FALSE);
                }
            }

            FreeText (BackupDirsGroup);
        } else {
            MYASSERT (FALSE);
        }
    }
}


BOOL
pScanFileSystem (
    VOID
    )
{
    BOOL fStatus = TRUE;
    BOOL fRet = TRUE;
    ACCESSIBLE_DRIVE_ENUM e;
    LONG ReturnCode = ERROR_SUCCESS;
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCTSTR virtualFile;
    PCTSTR pathExp;
    PCTSTR argList[3]={"ProgramFiles", g_ProgramFilesDir, NULL};

    pReportOtherOs ();

    pBuildMigrationPaths ();

    if (!InitLinkAnnounce ()) {
        return FALSE;
    }

    TickProgressBar ();

    if (GetFirstAccessibleDriveEx (&e, TRUE)) {
        do {

            fStatus = pExamineAccessibleDrive(e);

        } while (fStatus && GetNextAccessibleDrive(&e));
    }
    else {
        fRet = FALSE;
    }

    //
    // Act on status
    //
    if (!fRet || !fStatus) {
        ReturnCode = GetLastError ();
        if (ReturnCode != ERROR_CANCELLED && !CANCELLED()) {

            ERROR_CRITICAL

            LOG ((LOG_ERROR, (PCSTR)MSG_ENUMDRIVES_FAILED_LOG));
            DEBUGMSG((DBG_ERROR,"FileScan: Error enumerating drives"));
        }

        return FALSE;
    }
    //
    // OK, we are now at the end of filescan. Let's enumerate virtual files
    //
    MYASSERT (g_Win95UpgInf != INVALID_HANDLE_VALUE);

    if (InfFindFirstLine (g_Win95UpgInf, S_VIRTUAL_FILES, NULL, &context)) {
        do {
            virtualFile = InfGetStringField (&context, 1);
            if (virtualFile) {
                pathExp = ExpandEnvironmentTextExA(virtualFile, argList);
                if (pathExp) {
                    if (!DoesFileExist (pathExp)) {
                        pProcessFileOrDir (pathExp, NULL, NULL, 0, NULL, NULL);
                    }
                    FreeText (pathExp);
                }
            }
        }
        while (InfFindNextLine (&context));

        InfCleanUpInfStruct (&context);
    }

    CleanupUseNtFilesMap ();

    return TRUE;
}


DWORD
ScanFileSystem (
    IN      DWORD Request
    )
{
    DWORD Ticks;

    switch (Request) {

    case REQUEST_QUERYTICKS:
        return FileScan_GetProgressMax ();

    case REQUEST_RUN:

        Ticks = GetTickCount();

        if (!pScanFileSystem ()) {
            return GetLastError ();
        }

        pReportBackupDirs ();

        Ticks = GetTickCount() - Ticks;
        g_ProgressBarTime += Ticks;

        return ERROR_SUCCESS;

    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in ScanFileSystem"));
    }
    return 0;
}

VOID
InitUseNtFilesMap (
    VOID
    )
{
    INFSTRUCT context = INITINFSTRUCT_POOLHANDLE;
    PTSTR name;
    DWORD zero = 0;

    g_UseNtFileHashTable = HtAllocWithData (sizeof (DWORD));
    if (!g_UseNtFileHashTable) {
        return;
    }

    if (InfFindFirstLine (g_MigDbInf, S_USENTFILES, NULL, &context)) {

        do {
            name = InfGetStringField (&context, 4);
            if (name) {
                HtAddStringAndData (g_UseNtFileHashTable, name, &zero);
            }
        } while (InfFindNextLine (&context));

        InfCleanUpInfStruct (&context);
    }
}

VOID
CleanupUseNtFilesMap (
    VOID
    )
{
    if (g_UseNtFileHashTable) {
        HtFree (g_UseNtFileHashTable);
        g_UseNtFileHashTable = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\links.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    links.c

Abstract:

    This source file implements the Win95 side of LNK and PIF processing

Author:

    Calin Negreanu (calinn) 09-Feb-1998

Revision History:

    calinn      23-Sep-1998 Redesigned several pieces

--*/

#include "pch.h"
#include "migdbp.h"
#include "migappp.h"


POOLHANDLE      g_LinksPool = NULL;
INT g_LinkStubSequencer = 0;

typedef struct _LINK_STRUCT {
    PCTSTR ReportEntry;
    PCTSTR Category;
    PCTSTR Context;
    PCTSTR Object;
    PCTSTR LinkName;
    PCTSTR LinkNameNoPath;
    PMIGDB_CONTEXT MigDbContext;
} LINK_STRUCT, *PLINK_STRUCT;

BOOL
InitLinkAnnounce (
    VOID
    )
{
    //
    // Create PoolMem for keeping all structures during this phase
    //
    g_LinksPool = PoolMemInitNamedPool ("Links Pool");

    return TRUE;
}

BOOL
DoneLinkAnnounce (
    VOID
    )
{
    // Write LinkStub max sequencer data
    MemDbSetValue (MEMDB_CATEGORY_LINKSTUB_MAXSEQUENCE, g_LinkStubSequencer);

    //
    // Free Links Pool.
    //
    if (g_LinksPool != NULL) {
        PoolMemDestroyPool (g_LinksPool);
        g_LinksPool = NULL;
    }
    return TRUE;
}


BOOL
SaveLinkFiles (
    IN      PFILE_HELPER_PARAMS Params
    )
{
    PCTSTR Ext;

    if (Params->Handled) {
        return TRUE;
    }

    Ext = GetFileExtensionFromPath (Params->FullFileSpec);

    // Save LNK and PIF filenames to memdb to enumerate later
    if (Ext && (StringIMatch (Ext, TEXT("LNK")) || StringIMatch (Ext, TEXT("PIF")))) {

        MemDbSetValueEx (
            MEMDB_CATEGORY_SHORTCUTS,
            Params->FullFileSpec,
            NULL,
            NULL,
            0,
            NULL
            );
    }

    return TRUE;
}


VOID
RemoveLinkFromSystem (
    IN      LPCTSTR LinkPath
    )
{
    //
    // Remove any move or copy operation specified for the link, then
    // mark it for deletion.
    //
    RemoveOperationsFromPath (LinkPath, ALL_DEST_CHANGE_OPERATIONS);
    MarkFileForDelete (LinkPath);
}


//
// Function to send instruction to MemDb to edit a shell link or pif file.
// It checks to see whether the link involved has been touched yet by any
// MemDb operation. It modifies the target path, if in a relocating directory,
// to one of the relocated copies.
//
VOID
pAddLinkEditToMemDb (
    IN      PCTSTR LinkPath,
    IN      PCTSTR NewTarget,
    IN      PCTSTR NewArgs,
    IN      PCTSTR NewWorkDir,
    IN      PCTSTR NewIconPath,
    IN      INT NewIconNr,
    IN      PLNK_EXTRA_DATA ExtraData,  OPTIONAL
    IN      BOOL ForceToShowNormal
    )
{
    UINT sequencer;
    TCHAR tmpStr [20];

    sequencer = AddOperationToPath (LinkPath, OPERATION_LINK_EDIT);

    if (sequencer == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Cannot set OPERATION_LINK_EDIT on %s", LinkPath));
        return;
    }

    if (NewTarget) {
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, NewTarget, MEMDB_CATEGORY_LINKEDIT_TARGET);
    }

    if (NewArgs) {
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, NewArgs, MEMDB_CATEGORY_LINKEDIT_ARGS);
    }

    if (NewWorkDir) {
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, NewWorkDir, MEMDB_CATEGORY_LINKEDIT_WORKDIR);
    }

    if (NewIconPath) {
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, NewIconPath, MEMDB_CATEGORY_LINKEDIT_ICONPATH);
    }

    if (NewIconPath) {
        _itoa (NewIconNr, tmpStr, 16);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, tmpStr, MEMDB_CATEGORY_LINKEDIT_ICONNUMBER);
    }
    if (ForceToShowNormal) {
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, TEXT("1"), MEMDB_CATEGORY_LINKEDIT_SHOWNORMAL);
    }
    if (ExtraData) {
        _itoa (ExtraData->FullScreen, tmpStr, 10);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, tmpStr, MEMDB_CATEGORY_LINKEDIT_FULLSCREEN);
        _itoa (ExtraData->xSize, tmpStr, 10);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, tmpStr, MEMDB_CATEGORY_LINKEDIT_XSIZE);
        _itoa (ExtraData->ySize, tmpStr, 10);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, tmpStr, MEMDB_CATEGORY_LINKEDIT_YSIZE);
        _itoa (ExtraData->QuickEdit, tmpStr, 10);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, tmpStr, MEMDB_CATEGORY_LINKEDIT_QUICKEDIT);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, ExtraData->FontName, MEMDB_CATEGORY_LINKEDIT_FONTNAME);
        _itoa (ExtraData->xFontSize, tmpStr, 10);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, tmpStr, MEMDB_CATEGORY_LINKEDIT_XFONTSIZE);
        _itoa (ExtraData->yFontSize, tmpStr, 10);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, tmpStr, MEMDB_CATEGORY_LINKEDIT_YFONTSIZE);
        _itoa (ExtraData->FontWeight, tmpStr, 10);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, tmpStr, MEMDB_CATEGORY_LINKEDIT_FONTWEIGHT);
        _itoa (ExtraData->FontFamily, tmpStr, 10);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, tmpStr, MEMDB_CATEGORY_LINKEDIT_FONTFAMILY);
        _itoa (ExtraData->CurrentCodePage, tmpStr, 10);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_EDIT, tmpStr, MEMDB_CATEGORY_LINKEDIT_CODEPAGE);
    }
    MYASSERT (IsFileMarkedForOperation (LinkPath, OPERATION_LINK_EDIT));
}

//
// Function to send instruction to MemDb to save some data about a link that's going to be edited.
// We do that to be able to restore this link later using lnkstub.exe
//
UINT
pAddLinkStubToMemDb (
    IN      PCTSTR LinkPath,
    IN      PCTSTR OldTarget,
    IN      PCTSTR OldArgs,
    IN      PCTSTR OldWorkDir,
    IN      PCTSTR OldIconPath,
    IN      INT OldIconNr,
    IN      DWORD OldShowMode,
    IN      DWORD Announcement,
    IN      DWORD Availability
    )
{
    UINT sequencer;
    TCHAR tmpStr [20];
    MEMDB_ENUM e, e1;
    TCHAR key [MEMDB_MAX];

    MYASSERT (OldTarget || OldWorkDir || OldIconPath || OldIconNr);

    sequencer = AddOperationToPath (LinkPath, OPERATION_LINK_STUB);

    if (sequencer == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Cannot set OPERATION_LINK_STUB on %s", LinkPath));
        return 0;
    }

    g_LinkStubSequencer++;

    if (OldTarget) {
        AddPropertyToPathEx (sequencer, OPERATION_LINK_STUB, OldTarget, MEMDB_CATEGORY_LINKSTUB_TARGET);
    }

    if (OldArgs) {
        AddPropertyToPathEx (sequencer, OPERATION_LINK_STUB, OldArgs, MEMDB_CATEGORY_LINKSTUB_ARGS);
    }

    if (OldWorkDir) {
        AddPropertyToPathEx (sequencer, OPERATION_LINK_STUB, OldWorkDir, MEMDB_CATEGORY_LINKSTUB_WORKDIR);
    }

    if (OldIconPath) {
        AddPropertyToPathEx (sequencer, OPERATION_LINK_STUB, OldIconPath, MEMDB_CATEGORY_LINKSTUB_ICONPATH);
    }

    if (OldIconPath) {
        _itoa (OldIconNr, tmpStr, 16);
        AddPropertyToPathEx (sequencer, OPERATION_LINK_STUB, tmpStr, MEMDB_CATEGORY_LINKSTUB_ICONNUMBER);
    }

    _itoa (OldShowMode, tmpStr, 16);
    AddPropertyToPathEx (sequencer, OPERATION_LINK_STUB, tmpStr, MEMDB_CATEGORY_LINKSTUB_SHOWMODE);

    _itoa (g_LinkStubSequencer, tmpStr, 16);
    AddPropertyToPathEx (sequencer, OPERATION_LINK_STUB, tmpStr, MEMDB_CATEGORY_LINKSTUB_SEQUENCER);

    _itoa (Announcement, tmpStr, 16);
    AddPropertyToPathEx (sequencer, OPERATION_LINK_STUB, tmpStr, MEMDB_CATEGORY_LINKSTUB_ANNOUNCEMENT);

    _itoa (Availability, tmpStr, 16);
    AddPropertyToPathEx (sequencer, OPERATION_LINK_STUB, tmpStr, MEMDB_CATEGORY_LINKSTUB_REPORTAVAIL);

    MemDbBuildKey (key, MEMDB_CATEGORY_REQFILES_MAIN, OldTarget, TEXT("*"), NULL);

    if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            MemDbBuildKey (key, MEMDB_CATEGORY_REQFILES_ADDNL, e.szName, TEXT("*"), NULL);
            if (MemDbEnumFirstValue (&e1, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
                AddPropertyToPathEx (sequencer, OPERATION_LINK_STUB, e1.szName, MEMDB_CATEGORY_LINKSTUB_REQFILE);
            }
        } while (MemDbEnumNextValue (&e));
    }

    MYASSERT (IsFileMarkedForOperation (LinkPath, OPERATION_LINK_STUB));

    return g_LinkStubSequencer;
}


BOOL
pReportEntry (
    IN      PCTSTR ReportEntry,
    IN      PCTSTR Category,
    IN      PCTSTR Message,
    IN      PCTSTR Context,
    IN      PCTSTR Object
    )
{
    PCTSTR component;

    component = JoinPaths (ReportEntry, Category);
    MsgMgr_ContextMsg_Add (Context, component, Message);
    MsgMgr_LinkObjectWithContext (Context, Object);
    FreePathString (component);

    return TRUE;
}

PTSTR
GetLastDirFromPath (
    IN      PCTSTR FileName
    )
{
    PTSTR result = NULL;
    PTSTR temp = NULL;
    PTSTR ptr;

    temp = DuplicatePathString (FileName, 0);
    __try {
        ptr = (PTSTR)GetFileNameFromPath (temp);
        if (ptr == temp) {
            __leave;
        }
        ptr = _tcsdec (temp, ptr);
        if (!ptr) {
            __leave;
        }
        *ptr = 0;
        ptr = (PTSTR)GetFileNameFromPath (temp);
        if (ptr == temp) {
            __leave;
        }
        result = DuplicatePathString (ptr, 0);
    }
    __finally {
        FreePathString (temp);
    }

    return result;
}

PTSTR
GetDriveFromPath (
    IN      PCTSTR FileName
    )
{
    PTSTR result;
    PTSTR ptr;

    result = DuplicatePathString (FileName, 0);
    ptr = _tcschr (result, TEXT(':'));
    if (!ptr) {
        FreePathString (result);
        result = NULL;
    }
    else {
        *ptr = 0;
    }

    return result;
}

#define MAX_PRIORITY    0xFFFF

BOOL
HandleDeferredAnnounce (
    IN      PCTSTR LinkName,
    IN      PCTSTR ModuleName,
    IN      BOOL DosApp
    )
{
    TCHAR key [MEMDB_MAX];
    PMIGDB_CONTEXT migDbContext;
    DWORD actType;
    PLINK_STRUCT linkStruct;
    PCTSTR reportEntry = NULL;
    DWORD priority;
    PCTSTR newLinkName = NULL;
    PCTSTR linkName = NULL;
    PCTSTR extPtr;
    MEMDB_ENUM eNicePaths;
    DWORD messageId = 0;
    PTSTR pattern = NULL;
    PTSTR category = NULL;
    PTSTR tempParse = NULL;
    PTSTR lastDir;
    PTSTR drive;
    DWORD oldValue;
    DWORD oldPrior;
    PTSTR argArray[3];
    PCTSTR p;
    PTSTR q;
    BOOL reportEntryIsResource = TRUE;
    PCTSTR temp1, temp2;

    MYASSERT(ModuleName);

    MemDbBuildKey (key, MEMDB_CATEGORY_DEFERREDANNOUNCE, ModuleName, NULL, NULL);
    if (!MemDbGetValueAndFlags (key, (PDWORD)(&migDbContext), &actType)) {
        actType = ACT_UNKNOWN;
        migDbContext = NULL;
    }
    //
    // we need to set the following variables:
    // - ReportEntry - is going to be either "Software Incompatible with NT",
    //                                       "Software with minor problems" or
    //                                       "Software that require reinstallation"
    // - Category - is one of the following: - Localized section name
    //                                       - link name (with friendly addition)
    //                                       - Unlocalized section name
    // - Message - this is in migdb context
    //
    // - Object - this is module name
    //
    linkStruct = (PLINK_STRUCT) PoolMemGetMemory (g_LinksPool, sizeof (LINK_STRUCT));
    ZeroMemory (linkStruct, sizeof (LINK_STRUCT));

    linkStruct->MigDbContext = migDbContext;
    linkStruct->Object = PoolMemDuplicateString (g_LinksPool, ModuleName);

    switch (actType) {

    case ACT_REINSTALL:
#if 0
        if ((linkStruct->MigDbContext) &&
            (linkStruct->MigDbContext->Message)
            ) {
            reportEntry = GetStringResource (MSG_MINOR_PROBLEM_ROOT);
        } else {
            reportEntry = GetStringResource (MSG_REINSTALL_ROOT);
        }
#endif
        temp1 = GetStringResource (MSG_REINSTALL_ROOT);
        if (!temp1) {
            break;
        }
        temp2 = GetStringResource (
                    linkStruct->MigDbContext && linkStruct->MigDbContext->Message ?
                        MSG_REINSTALL_DETAIL_SUBGROUP :
                        MSG_REINSTALL_LIST_SUBGROUP
                        );
        if (!temp2) {
            break;
        }

        reportEntry = JoinPaths (temp1, temp2);
        reportEntryIsResource = FALSE;

        FreeStringResource (temp1);
        FreeStringResource (temp2);
        break;

    case ACT_REINSTALL_BLOCK:
        temp1 = GetStringResource (MSG_BLOCKING_ITEMS_ROOT);
        if (!temp1) {
            break;
        }
        temp2 = GetStringResource (MSG_REINSTALL_BLOCK_ROOT);
        if (!temp2) {
            break;
        }

        reportEntry = JoinPaths (temp1, temp2);
        reportEntryIsResource = FALSE;

        FreeStringResource (temp1);
        FreeStringResource (temp2);

        break;

    case ACT_MINORPROBLEMS:
        reportEntry = GetStringResource (MSG_MINOR_PROBLEM_ROOT);
        break;

    case ACT_INCOMPATIBLE:
    case ACT_INC_NOBADAPPS:
    case ACT_INC_IHVUTIL:
    case ACT_INC_PREINSTUTIL:
    case ACT_INC_SIMILAROSFUNC:

        if (DosApp && (*g_Boot16 != BOOT16_NO)) {
            reportEntry = GetStringResource (MSG_DOS_DESIGNED_ROOT);
        }
        else {
            temp1 = GetStringResource (MSG_INCOMPATIBLE_ROOT);

            switch (actType) {

            case ACT_INC_SIMILAROSFUNC:
                temp2 = GetStringResource (MSG_INCOMPATIBLE_UTIL_SIMILAR_FEATURE_SUBGROUP);
                break;

            case ACT_INC_PREINSTUTIL:
                temp2 = GetStringResource (MSG_INCOMPATIBLE_PREINSTALLED_UTIL_SUBGROUP);
                break;

            case ACT_INC_IHVUTIL:
                temp2 = GetStringResource (MSG_INCOMPATIBLE_HW_UTIL_SUBGROUP);
                break;

            default:
                temp2 = GetStringResource (
                            linkStruct->MigDbContext && linkStruct->MigDbContext->Message ?
                                MSG_INCOMPATIBLE_DETAIL_SUBGROUP:
                                MSG_TOTALLY_INCOMPATIBLE_SUBGROUP
                            );
                break;
            }

            MYASSERT (temp1 && temp2);

            reportEntry = JoinPaths (temp1, temp2);

            reportEntryIsResource = FALSE;

            FreeStringResource (temp1);
            FreeStringResource (temp2);
        }
        break;

    case ACT_INC_SAFETY:
        MYASSERT (LinkName);

        temp1 = GetStringResource (MSG_INCOMPATIBLE_ROOT);
        temp2 = GetStringResource (MSG_REMOVED_FOR_SAFETY_SUBGROUP);

        MYASSERT (temp1 && temp2);

        reportEntry = JoinPaths (temp1, temp2);
        reportEntryIsResource = FALSE;

        FreeStringResource (temp1);
        FreeStringResource (temp2);

        newLinkName = JoinPaths (S_RUNKEYFOLDER, GetFileNameFromPath (LinkName));
        break;

    case ACT_UNKNOWN:
        reportEntry = GetStringResource (MSG_UNKNOWN_ROOT);
        break;

    default:
        LOG((LOG_ERROR, "Unknown action for deferred announcement."));
        return FALSE;
    }

    if (!newLinkName) {
        newLinkName = LinkName;
    }

    if (reportEntry != NULL) {
        linkStruct->ReportEntry = PoolMemDuplicateString (g_LinksPool, reportEntry);

        if (reportEntryIsResource) {
            FreeStringResource (reportEntry);
        } else {
            FreePathString (reportEntry);
        }
    }

    linkStruct->LinkName = newLinkName?PoolMemDuplicateString (g_LinksPool, newLinkName):NULL;

    //
    // all we need to set now is the category
    //

    // if we have a migdb context with a Localized name section
    //
    if ((migDbContext != NULL) &&
        (migDbContext->SectLocalizedName != NULL)
        ) {
        linkStruct->Context = PoolMemDuplicateString (g_LinksPool, migDbContext->SectLocalizedName);
        linkStruct->Category = PoolMemDuplicateString (g_LinksPool, migDbContext->SectLocalizedName);
        priority = 0;
    }
    else {
        linkStruct->Context = PoolMemDuplicateString (g_LinksPool, newLinkName?newLinkName:ModuleName);
        if (newLinkName == NULL) {
            MYASSERT (migDbContext);
            if (migDbContext->SectName) {
                linkStruct->Category = PoolMemDuplicateString (g_LinksPool, migDbContext->SectName);
            }
            else {
                linkStruct->Category = NULL;
            }
            priority = 0;
        }
        else {
            linkName = GetFileNameFromPath (newLinkName);
            extPtr = GetFileExtensionFromPath (linkName);
            if (extPtr != NULL) {
                extPtr = _tcsdec (linkName, extPtr);
            }
            if (extPtr == NULL) {
                extPtr = GetEndOfString (linkName);
            }
            messageId = 0;
            priority  = MAX_PRIORITY;
            if (MemDbEnumFirstValue (&eNicePaths, MEMDB_CATEGORY_NICE_PATHS"\\*", MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
                do {
                    pattern = JoinPaths (eNicePaths.szName, "\\*");
                    if (IsPatternMatch (pattern, newLinkName)) {
                        if (priority > eNicePaths.UserFlags) {
                            messageId = eNicePaths.dwValue;
                            priority = eNicePaths.UserFlags;
                        }
                    }
                    FreePathString (pattern);
                }
                while (MemDbEnumNextValue (&eNicePaths));
            }

            category = AllocText ((PBYTE) extPtr - (PBYTE) linkName + sizeof (TCHAR));

            p = linkName;
            q = category;

            while (p < extPtr) {
                if (_tcsnextc (p) == TEXT(' ')) {

                    do {
                        p++;
                    } while (_tcsnextc (p) == TEXT(' '));

                    if (q > category && *p) {
                        *q++ = TEXT(' ');
                    }

                } else if (IsLeadByte (*p)) {
                    *q++ = *p++;
                    *q++ = *p++;
                } else {
                    *q++ = *p++;
                }
            }

            *q = 0;

            if (messageId == 0) {

                lastDir = GetLastDirFromPath (newLinkName);
                drive = GetDriveFromPath (newLinkName);
                if (drive != NULL) {
                    drive[0] = (TCHAR)toupper (drive[0]);
                    if (lastDir != NULL) {
                        argArray [0] = category;
                        argArray [1] = lastDir;
                        argArray [2] = drive;
                        tempParse = (PTSTR)ParseMessageID (MSG_NICE_PATH_DRIVE_AND_FOLDER, argArray);
                    }
                    else {
                        argArray [0] = category;
                        argArray [1] = drive;
                        tempParse = (PTSTR)ParseMessageID (MSG_NICE_PATH_DRIVE, argArray);
                    }
                }
                else {
                    if (lastDir != NULL) {
                        argArray [0] = category;
                        argArray [1] = lastDir;
                        tempParse = (PTSTR)ParseMessageID (MSG_NICE_PATH_FOLDER, argArray);
                    }
                    else {
                        argArray [0] = category;
                        tempParse = (PTSTR)ParseMessageID (MSG_NICE_PATH_LINK, argArray);
                    }
                }
                linkStruct->Category = PoolMemDuplicateString (g_LinksPool, tempParse);
                FreeStringResourcePtrA (&tempParse);

                priority = MAX_PRIORITY;
            } else {
                tempParse = (PTSTR)ParseMessageID (messageId, &category);

                StringCopy (category, tempParse);
                linkStruct->Category = PoolMemDuplicateString (g_LinksPool, tempParse);
                FreeStringResourcePtrA (&tempParse);
            }

            FreeText (category);
        }
    }

    linkStruct->LinkNameNoPath = linkName?PoolMemDuplicateString (g_LinksPool, linkName):linkStruct->Context;

    MemDbBuildKey (
        key,
        MEMDB_CATEGORY_REPORT_LINKS,
        linkStruct->ReportEntry,
        linkName?linkName:linkStruct->Context,
        ModuleName);

    if ((!MemDbGetValueAndFlags (key, &oldValue, &oldPrior)) ||
        (oldPrior > priority)
        ) {
        MemDbSetValueAndFlags (key, (DWORD)linkStruct, priority, 0);
    }

    if (newLinkName != LinkName) {
        FreePathString (newLinkName);
    }

    return TRUE;
}

BOOL
pIsGUIDLauncherApproved (
    IN      PCTSTR FileName
    )
{
    INFCONTEXT context;
    MYASSERT (g_Win95UpgInf != INVALID_HANDLE_VALUE);
    return (SetupFindFirstLine (g_Win95UpgInf, S_APPROVED_GUID_LAUNCHER, FileName, &context));
}


#define GUID_LEN        (sizeof ("{00000000-0000-0000-0000-000000000000}") - 1)
#define GUID_DASH_1     (sizeof ("{00000000") - 1)
#define GUID_DASH_2     (sizeof ("{00000000-0000") - 1)
#define GUID_DASH_3     (sizeof ("{00000000-0000-0000") - 1)
#define GUID_DASH_4     (sizeof ("{00000000-0000-0000-0000") - 1)

BOOL
pSendCmdLineGuidsToMemdb (
    IN      PCTSTR File,
    IN      PCTSTR Target,
    IN      PCTSTR Arguments
    )

/*++

Routine Description:

  pSendCmdLineGuidsToMemdb saves any GUIDs contained in a command line to
  memdb, along with the file name.  Later, OLEREG resolves the GUIDs and
  deletes the file if a GUID is incompatible.

Arguments:

  File  - Specifies the file to delete if the command line arguments contain
          an invalid GUID.

  Target - Specifies the Target (needs to be one of the approved targets for the
           LNK file to go away in an incompatible case).

  Arguments - Specifies a command line that may contain one or more GUIDs in
              the {a-b-c-d-e} format.

Return value:

  TRUE - the operation was successful
  FALSE - the operation failed

--*/

{
    LPCTSTR p, q;
    DWORD Offset;
    BOOL b;
    static DWORD Seq = 0;
    TCHAR TextSeq[16];
    TCHAR Guid[GUID_LEN + 1];
    PCTSTR namePtr;

    namePtr = GetFileNameFromPath (Target);
    if (namePtr && pIsGUIDLauncherApproved (namePtr)) {

        p = _tcschr (Arguments, TEXT('{'));
        while (p) {
            q = _tcschr (p, TEXT('}'));

            if (q && ((q - p) == (GUID_LEN - 1))) {
                if (p[GUID_DASH_1] == TEXT('-') &&
                    p[GUID_DASH_2] == TEXT('-') &&
                    p[GUID_DASH_3] == TEXT('-') &&
                    p[GUID_DASH_4] == TEXT('-')
                    ) {
                    //
                    // Extract the GUID
                    //

                    q = _tcsinc (q);
                    StringCopyAB (Guid, p, q);

                    //
                    // Add the file name
                    //
                    b = MemDbSetValueEx (
                            MEMDB_CATEGORY_LINK_STRINGS,
                            File,
                            NULL,
                            NULL,
                            0,
                            &Offset
                            );

                    if (b) {
                        //
                        // Now add an entry for the GUID
                        //

                        Seq++;
                        wsprintf (TextSeq, TEXT("%u"), Seq);
                        b = MemDbSetValueEx (
                                MEMDB_CATEGORY_LINK_GUIDS,
                                Guid,
                                TextSeq,
                                NULL,
                                Offset,
                                NULL
                                );
                    }

                    if (!b) {
                        LOG ((LOG_ERROR, "Failed to store command line guids."));
                    }
                }
            }

            p = _tcschr (p + 1, TEXT('{'));
        }
    }

    return TRUE;
}

BOOL
pIsFileInStartup (
    IN      PCTSTR FileName
    )
{
    TCHAR key [MEMDB_MAX];

    MemDbBuildKey (key, MEMDB_CATEGORY_SF_STARTUP, FileName, NULL, NULL);
    return (MemDbGetPatternValue (key, NULL));
}


BOOL
pProcessShortcut (
        IN      PCTSTR FileName,
        IN      IShellLink *ShellLink,
        IN      IPersistFile *PersistFile
        )
{
    TCHAR shortcutTarget   [MEMDB_MAX];
    TCHAR shortcutArgs     [MEMDB_MAX];
    TCHAR shortcutWorkDir  [MEMDB_MAX];
    TCHAR shortcutIconPath [MEMDB_MAX];
    PTSTR shortcutNewTarget   = NULL;
    PTSTR shortcutNewArgs     = NULL;
    PTSTR shortcutNewIconPath = NULL;
    PTSTR shortcutNewWorkDir  = NULL;
    PTSTR commandPath         = NULL;
    PTSTR fullPath            = NULL;
    PCTSTR extPtr;
    INT   shortcutIcon;
    INT   newShortcutIcon;
    DWORD shortcutShowMode;
    WORD  shortcutHotKey;
    DWORD fileStatus;
    BOOL  msDosMode;
    BOOL  dosApp;
    DWORD attrib;
    LNK_EXTRA_DATA ExtraData;
    INT lnkIdx;
    TCHAR lnkIdxStr [10];
    BOOL toBeModified = FALSE;
    BOOL ConvertedLnk = FALSE;
    DWORD announcement;
    DWORD availability;



    __try {
        fileStatus = GetFileStatusOnNt (FileName);
        if (((fileStatus & FILESTATUS_DELETED ) == FILESTATUS_DELETED ) ||
            ((fileStatus & FILESTATUS_REPLACED) == FILESTATUS_REPLACED)
            ) {
            __leave;
        }
        if (!ExtractShortcutInfo (
                shortcutTarget,
                shortcutArgs,
                shortcutWorkDir,
                shortcutIconPath,
                &shortcutIcon,
                &shortcutHotKey,
                &dosApp,
                &msDosMode,
                &shortcutShowMode,
                &ExtraData,
                FileName,
                ShellLink,
                PersistFile
                )) {
            __leave;
        }

        if (msDosMode) {
            //
            // we want to modify this PIF file so it doesn't have MSDOS mode set
            // we will only add it to the modify list. The NT side will know what
            // to do when a PIF is marked for beeing modify
            //
            toBeModified = TRUE;

        }

        if (IsFileMarkedForAnnounce (shortcutTarget)) {
            announcement = GetFileAnnouncement (shortcutTarget);
            if (g_ConfigOptions.ShowAllReport ||
                ((announcement != ACT_INC_IHVUTIL) &&
                 (announcement != ACT_INC_PREINSTUTIL) &&
                 (announcement != ACT_INC_SIMILAROSFUNC)
                 )
                ) {
                HandleDeferredAnnounce (FileName, shortcutTarget, dosApp);
            }
        }

        fileStatus = GetFileStatusOnNt (shortcutTarget);

        if ((fileStatus & FILESTATUS_DELETED) == FILESTATUS_DELETED) {

            if (IsFileMarkedForAnnounce (shortcutTarget)) {

                if (!pIsFileInStartup (FileName)) {

                    if (!g_ConfigOptions.KeepBadLinks) {
                        RemoveLinkFromSystem (FileName);
                    } else {
                        // we only care about LNK files
                        if (StringIMatch (GetFileExtensionFromPath (FileName), TEXT("LNK"))) {
                            // let's see what kind of announcement we have here.
                            // We want to leave the LNK as is if the app was announced
                            // using MigDb. However, if the app was announced using
                            // dynamic checking (module checking) then we want to point
                            // this shortcut to our stub EXE
                            announcement = GetFileAnnouncement (shortcutTarget);
                            if ((announcement == ACT_INC_NOBADAPPS) ||
                                (announcement == ACT_REINSTALL) ||
                                (announcement == ACT_REINSTALL_BLOCK) ||
                                (announcement == ACT_INC_IHVUTIL) ||
                                (announcement == ACT_INC_PREINSTUTIL) ||
                                (announcement == ACT_INC_SIMILAROSFUNC)
                                ) {

                                //
                                // This is the case when we want to redirect this LNK to point
                                // to our lnk stub. Extract will fail if the icon is known-good.
                                // In that case, keep using the target icon.
                                //

                                if (ExtractIconIntoDatFile (
                                        (*shortcutIconPath)?shortcutIconPath:shortcutTarget,
                                        shortcutIcon,
                                        &g_IconContext,
                                        &newShortcutIcon
                                        )) {
                                    shortcutNewIconPath = JoinPaths (g_System32Dir, TEXT("migicons.exe"));
                                    shortcutIcon = newShortcutIcon;
                                } else {
                                    shortcutNewIconPath = GetPathStringOnNt (
                                                                (*shortcutIconPath) ?
                                                                    shortcutIconPath : shortcutTarget
                                                                );
                                }

                                availability = g_ConfigOptions.ShowAllReport ||
                                                ((announcement != ACT_INC_IHVUTIL) &&
                                                 (announcement != ACT_INC_PREINSTUTIL) &&
                                                 (announcement != ACT_INC_SIMILAROSFUNC)
                                                );

                                lnkIdx = pAddLinkStubToMemDb (
                                            FileName,
                                            shortcutTarget,
                                            shortcutArgs,
                                            shortcutWorkDir,
                                            shortcutNewIconPath,
                                            shortcutIcon + 1,           // Add 1 because lnkstub.exe is one-based, but we are zero based
                                            shortcutShowMode,
                                            announcement,
                                            availability
                                            );

                                wsprintf (lnkIdxStr, TEXT("%d"), lnkIdx);
                                shortcutNewTarget = JoinPaths (g_System32Dir, S_LNKSTUB_EXE);
                                shortcutNewArgs = DuplicatePathString (lnkIdxStr, 0);
                                pAddLinkEditToMemDb (
                                        FileName,
                                        shortcutNewTarget,
                                        shortcutNewArgs,
                                        shortcutNewWorkDir,
                                        shortcutNewIconPath,
                                        shortcutIcon,           // don't add one -- shortcuts are zero based
                                        NULL,
                                        TRUE
                                        );
                            }
                        }  else {
                            RemoveLinkFromSystem (FileName);
                        }
                    }
                } else {
                    //
                    // This is a startup item
                    //

                    RemoveLinkFromSystem (FileName);
                }
            } else {
                RemoveLinkFromSystem (FileName);
            }
            __leave;
        }

        if ((fileStatus & FILESTATUS_REPLACED) != FILESTATUS_REPLACED) {
            //
            // this target is not replaced by a migration DLL or by NT. We need
            // to know if this is a "known good" target. If not, we will announce
            // this link as beeing "unknown"
            //
            if (!IsFileMarkedAsKnownGood (shortcutTarget)) {

                fullPath = JoinPaths (shortcutWorkDir, shortcutTarget);

                if (!IsFileMarkedAsKnownGood (fullPath)) {
                    extPtr = GetFileExtensionFromPath (shortcutTarget);

                    if (extPtr) {
                        if (StringIMatch (extPtr, TEXT("EXE"))) {
                            //
                            //          This one statement controls our
                            //          "unknown" category.  We have the
                            //          ability to list the things we don't
                            //          recognize.
                            //
                            //          It is currently "off".
                            //
                            //HandleDeferredAnnounce (FileName, shortcutTarget, dosApp);
                        }
                    }
                }
                FreePathString (fullPath);
            }
        }

        //
        // If this LNK points to a target that will change, back up the
        // original LNK, because we might change it.
        //

        if (fileStatus & ALL_CHANGE_OPERATIONS) {
            MarkFileForBackup (FileName);
        }

        //
        // If target points to an OLE object, remove any links to incompatible OLE objects
        //
        pSendCmdLineGuidsToMemdb (FileName, shortcutTarget, shortcutArgs);

        //all we try to do now is to see if this lnk or pif file is going to be edited
        //on NT side. That is if target or icon should change.

        shortcutNewTarget = GetPathStringOnNt (shortcutTarget);
        if (!StringIMatch (shortcutNewTarget, shortcutTarget)) {
            toBeModified = TRUE;

            //
            // special case for COMMAND.COM
            //
            if (shortcutArgs [0] == 0) {

                commandPath = JoinPaths (g_System32Dir, S_COMMAND_COM);
                if (StringIMatch (commandPath, shortcutNewTarget)) {
                    if (msDosMode) {
                        //
                        // remove MS-DOS mode PIF files that point to command.com
                        //
                        RemoveLinkFromSystem (FileName);
                        //
                        // If msdosmode was on, we need to determine how we are going to handle
                        // boot16. We will turn on boot16 mode if:
                        // (a) The .pif points to something besides command.com
                        // (b) The .pif is in a shell folder.
                        //
                        // Note that the check for b simply entails seeing if the PIF file has
                        // OPERATION_FILE_MOVE_SHELL_FOLDER associated with it.
                        //
                        //
                        if (msDosMode && *g_Boot16 == BOOT16_AUTOMATIC) {

                            if (!StringIMatch(GetFileNameFromPath (shortcutNewTarget?shortcutNewTarget:shortcutTarget), S_COMMAND_COM) ||
                                 IsFileMarkedForOperation (FileName, OPERATION_FILE_MOVE_SHELL_FOLDER)) {

                                    *g_Boot16 = BOOT16_YES;
                            }
                        }
                        __leave;
                    } else {
                        ConvertedLnk = TRUE;
                        FreePathString (shortcutNewTarget);
                        shortcutNewTarget = JoinPaths (g_System32Dir, S_CMD_EXE);
                    }
                }
                FreePathString (commandPath);
                shortcutNewArgs = NULL;
            }
            else {
                shortcutNewArgs = DuplicatePathString (shortcutArgs, 0);
            }
        }
        else {
            FreePathString (shortcutNewTarget);
            shortcutNewTarget = NULL;
        }

        //
        // If msdosmode was on, we need to determine how we are going to handle
        // boot16. We will turn on boot16 mode if:
        // (a) The .pif points to something besides command.com
        // (b) The .pif is in a shell folder.
        //
        // Note that the check for b simply entails seeing if the PIF file has
        // OPERATION_FILE_MOVE_SHELL_FOLDER associated with it.
        //
        //
        if (msDosMode && *g_Boot16 == BOOT16_AUTOMATIC) {

            if (!StringIMatch(GetFileNameFromPath (shortcutNewTarget?shortcutNewTarget:shortcutTarget), S_COMMAND_COM) ||
                 IsFileMarkedForOperation (FileName, OPERATION_FILE_MOVE_SHELL_FOLDER)) {

                    *g_Boot16 = BOOT16_YES;
            }
        }
        //
        // If the link points to a directory, see that the directory survives on NT.
        // Potentially this directory can be cleaned up if it's in a shell folder and
        // becomes empty after our ObsoleteLinks check
        //
        attrib = QuietGetFileAttributes (shortcutTarget);
        if ((attrib != INVALID_ATTRIBUTES) &&
            (attrib & FILE_ATTRIBUTE_DIRECTORY)
            ){
            MarkDirectoryAsPreserved (shortcutNewTarget?shortcutNewTarget:shortcutTarget);
        }

        //OK, so much with target, let's see what's with the work dir
        shortcutNewWorkDir = GetPathStringOnNt (shortcutWorkDir);
        if (!StringIMatch (shortcutNewWorkDir, shortcutWorkDir)) {
            toBeModified = TRUE;
        }
        else {
            FreePathString (shortcutNewWorkDir);
            shortcutNewWorkDir = NULL;
        }

        //
        // If the working dir for this link is a directory, see that the directory survives on NT.
        // Potentially this directory can be cleaned up if it's in a shell folder and
        // becomes empty after our ObsoleteLinks check
        //
        attrib = QuietGetFileAttributes (shortcutWorkDir);
        if ((attrib != INVALID_ATTRIBUTES) &&
            (attrib & FILE_ATTRIBUTE_DIRECTORY)
            ){
            MarkDirectoryAsPreserved (shortcutNewWorkDir?shortcutNewWorkDir:shortcutWorkDir);
        }

        //OK, so much with workdir, let's see what's with icon
        fileStatus = GetFileStatusOnNt (shortcutIconPath);
        if ((fileStatus & FILESTATUS_DELETED) ||
            ((fileStatus & FILESTATUS_REPLACED) && (fileStatus & FILESTATUS_NTINSTALLED)) ||
            (IsFileMarkedForOperation (shortcutIconPath, OPERATION_FILE_MOVE_SHELL_FOLDER))
            ) {
            //
            // Our icon will go away, because our file is getting deleted or
            // replaced. Let's try to preserve it. Extract will fail only if
            // the icon is known-good.
            //

            if (ExtractIconIntoDatFile (
                    shortcutIconPath,
                    shortcutIcon,
                    &g_IconContext,
                    &newShortcutIcon
                    )) {
                shortcutNewIconPath = JoinPaths (g_System32Dir, TEXT("migicons.exe"));
                shortcutIcon = newShortcutIcon;
                toBeModified = TRUE;
            }
        }

        if (!shortcutNewIconPath) {
            shortcutNewIconPath = GetPathStringOnNt (shortcutIconPath);
            if (!StringIMatch (shortcutNewIconPath, shortcutIconPath)) {
                toBeModified = TRUE;
            }
            else {
                FreePathString (shortcutNewIconPath);
                shortcutNewIconPath = NULL;
            }
        }

        if (toBeModified) {
            if (ConvertedLnk) {
                //
                // Set this for modifying PIF to LNK
                //
                pAddLinkEditToMemDb (
                        FileName,
                        shortcutNewTarget?shortcutNewTarget:shortcutTarget,
                        shortcutNewArgs?shortcutNewArgs:shortcutArgs,
                        shortcutNewWorkDir?shortcutNewWorkDir:shortcutWorkDir,
                        shortcutNewIconPath?shortcutNewIconPath:shortcutIconPath,
                        shortcutIcon,
                        &ExtraData,
                        FALSE
                        );
            } else {
                pAddLinkEditToMemDb (
                        FileName,
                        shortcutNewTarget,
                        shortcutNewArgs,
                        shortcutNewWorkDir,
                        shortcutNewIconPath,
                        shortcutIcon,
                        NULL,
                        FALSE
                        );
            }
        }
    }
    __finally {
        if (shortcutNewWorkDir != NULL) {
            FreePathString (shortcutNewWorkDir);
        }
        if (shortcutNewIconPath != NULL) {
            FreePathString (shortcutNewIconPath);
        }
        if (shortcutNewArgs != NULL) {
            FreePathString (shortcutNewArgs);
        }
        if (shortcutNewTarget != NULL) {
            FreePathString (shortcutNewTarget);
        }
    }
    return TRUE;
}

PCTSTR
pBuildNewCategory (
    IN      PCTSTR LinkName,
    IN      PCTSTR Category,
    IN      UINT Levels
    )
{
    PCTSTR *levPtrs = NULL;
    PCTSTR wackPtr = NULL;
    PCTSTR result = NULL;
    PCTSTR resultTmp = NULL;
    UINT index = 0;
    UINT indexLnk = 0;

    MYASSERT (Levels);

    levPtrs = (PCTSTR *) PoolMemGetMemory (g_LinksPool, (Levels + 1) * sizeof (PCTSTR));

    wackPtr = LinkName;

    while (wackPtr) {
        levPtrs[index] = wackPtr;

        wackPtr = _tcschr (wackPtr, TEXT('\\'));
        if (wackPtr) {
            wackPtr = _tcsinc (wackPtr);

            index ++;
            if (index > Levels) {
                index = 0;
            }
        }
    }

    indexLnk = index;

    if (index == Levels) {
        index = 0;
    } else {
        index ++;
    }

    resultTmp = StringSearchAndReplace (levPtrs [index], levPtrs [indexLnk], Category);
    if (resultTmp) {
        result = StringSearchAndReplace (resultTmp, TEXT("\\"), TEXT("->"));
    } else {
        result = NULL;
    }

    FreePathString (resultTmp);

    PoolMemReleaseMemory (g_LinksPool, (PVOID) levPtrs);

    return result;
}


VOID
pGatherInfoFromDefaultPif (
    VOID
    )
{
    PCTSTR defaultPifPath = NULL;
    TCHAR tmpStr [20];
    TCHAR pifTarget   [MEMDB_MAX];
    TCHAR pifArgs     [MEMDB_MAX];
    TCHAR pifWorkDir  [MEMDB_MAX];
    TCHAR pifIconPath [MEMDB_MAX];
    INT   pifIcon;
    BOOL  pifMsDosMode;
    LNK_EXTRA_DATA pifExtraData;

    defaultPifPath = JoinPaths (g_WinDir, S_COMMAND_PIF);
    if (ExtractPifInfo (
            pifTarget,
            pifArgs,
            pifWorkDir,
            pifIconPath,
            &pifIcon,
            &pifMsDosMode,
            &pifExtraData,
            defaultPifPath
            )) {
        _itoa (pifExtraData.FullScreen, tmpStr, 10);
        MemDbSetValueEx (MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_FULLSCREEN, tmpStr, NULL, 0, NULL);
        _itoa (pifExtraData.xSize, tmpStr, 10);
        MemDbSetValueEx (MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_XSIZE, tmpStr, NULL, 0, NULL);
        _itoa (pifExtraData.ySize, tmpStr, 10);
        MemDbSetValueEx (MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_YSIZE, tmpStr, NULL, 0, NULL);
        _itoa (pifExtraData.QuickEdit, tmpStr, 10);
        MemDbSetValueEx (MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_QUICKEDIT, tmpStr, NULL, 0, NULL);
        MemDbSetValueEx (MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_FONTNAME, pifExtraData.FontName, NULL, 0, NULL);
        _itoa (pifExtraData.xFontSize, tmpStr, 10);
        MemDbSetValueEx (MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_XFONTSIZE, tmpStr, NULL, 0, NULL);
        _itoa (pifExtraData.yFontSize, tmpStr, 10);
        MemDbSetValueEx (MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_YFONTSIZE, tmpStr, NULL, 0, NULL);
        _itoa (pifExtraData.FontWeight, tmpStr, 10);
        MemDbSetValueEx (MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_FONTWEIGHT, tmpStr, NULL, 0, NULL);
        _itoa (pifExtraData.FontFamily, tmpStr, 10);
        MemDbSetValueEx (MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_FONTFAMILY, tmpStr, NULL, 0, NULL);
        _itoa (pifExtraData.CurrentCodePage, tmpStr, 10);
        MemDbSetValueEx (MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_CODEPAGE, tmpStr, NULL, 0, NULL);
    }
    FreePathString (defaultPifPath);
}


BOOL
pProcessLinks (
    VOID
    )
{
    MEMDB_ENUM enumItems;
    MEMDB_ENUM enumDups;
    TCHAR pattern[MEMDB_MAX];
    IShellLink *shellLink;
    IPersistFile *persistFile;
    PLINK_STRUCT linkStruct, linkDup;
    BOOL resolved;
    PCTSTR newCategory = NULL;
    PCTSTR dupCategory = NULL;
    UINT levels = 0;
    DWORD count = 0;

    MYASSERT (g_LinksPool);

    if (InitCOMLink (&shellLink, &persistFile)) {

        wsprintf (pattern, TEXT("%s\\*"), MEMDB_CATEGORY_SHORTCUTS);

        if (MemDbEnumFirstValue (
                &enumItems,
                pattern,
                MEMDB_ALL_SUBLEVELS,
                MEMDB_ENDPOINTS_ONLY
                )) {
            do {

                if (!SafeModeActionCrashed (SAFEMODEID_LNK9X, enumItems.szName)) {

                    SafeModeRegisterAction(SAFEMODEID_LNK9X, enumItems.szName);

                    if (!pProcessShortcut (enumItems.szName, shellLink, persistFile)) {
                        LOG((LOG_ERROR, "Error processing shortcut %s", enumItems.szName));
                    }
                    count++;
                    if (!(count % 4)) {
                        TickProgressBar ();
                    }

                    SafeModeUnregisterAction();
                }
            }
            while (MemDbEnumNextValue (&enumItems));
        }
        FreeCOMLink (&shellLink, &persistFile);
    }

    if (MemDbEnumFirstValue (&enumItems, MEMDB_CATEGORY_REPORT_LINKS"\\*", MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            newCategory = NULL;
            levels = 0;

            linkStruct = (PLINK_STRUCT)enumItems.dwValue;


            if (linkStruct->LinkName) {
                resolved = !(StringIMatch (linkStruct->LinkNameNoPath, GetFileNameFromPath (linkStruct->LinkName)));
            }
            else {
                resolved = TRUE;
            }

            while (!resolved) {

                resolved = TRUE;

                MemDbBuildKey (
                    pattern,
                    MEMDB_CATEGORY_REPORT_LINKS,
                    TEXT("*"),
                    linkStruct->LinkNameNoPath,
                    TEXT("*")
                    );

                if (MemDbEnumFirstValue (&enumDups, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {

                    do {

                        linkDup = (PLINK_STRUCT)enumDups.dwValue;

                        if ((enumItems.Offset != enumDups.Offset) &&
                            (enumItems.UserFlags == enumDups.UserFlags) &&
                            (StringIMatch (linkStruct->Category, linkDup->Category))
                            ) {

                            if (newCategory) {

                                dupCategory = pBuildNewCategory (linkDup->LinkName, linkDup->Category, levels);
                                if (!dupCategory) {
                                    MYASSERT (FALSE);
                                    continue;
                                }

                                if (!StringIMatch (dupCategory, newCategory)) {
                                    FreePathString (dupCategory);
                                    continue;
                                }
                                FreePathString (newCategory);
                            }
                            levels++;
                            newCategory = pBuildNewCategory (linkStruct->LinkName, linkStruct->Category, levels);
                            resolved = FALSE;
                            break;
                        }
                    } while (MemDbEnumNextValue (&enumDups));
                }
            }
            pReportEntry (
                linkStruct->ReportEntry,
                newCategory?newCategory:linkStruct->Category,
                linkStruct->MigDbContext?linkStruct->MigDbContext->Message:NULL,
                linkStruct->Context,
                linkStruct->Object
                );

            if (newCategory) {
                newCategory = NULL;
            }

        } while (MemDbEnumNextValue (&enumItems));
    }

    TickProgressBar ();

    // gather default command prompt attributes
    pGatherInfoFromDefaultPif ();

    DoneLinkAnnounce ();

    //
    // Delete MemDb tree used for this phase
    //
    MemDbDeleteTree (MEMDB_CATEGORY_REPORT_LINKS);

    return TRUE;
}


DWORD
ProcessLinks (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_PROCESS_LINKS;
    case REQUEST_RUN:
        if (!pProcessLinks ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in ProcessLinks"));
    }
    return 0;
}


BOOL
pProcessCPLs (
    VOID
    )
{
    CHAR pattern[MEMDB_MAX];
    MEMDB_ENUM enumItems;
    DWORD announcement;
    PMIGDB_CONTEXT context;

    MemDbBuildKey (pattern, MEMDB_CATEGORY_CPLS, TEXT("*"), NULL, NULL);

    if (MemDbEnumFirstValue (&enumItems, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if ((IsFileMarkedForAnnounce (enumItems.szName)) &&
                (IsDisplayableCPL (enumItems.szName))
                ) {
                announcement = GetFileAnnouncement (enumItems.szName);
                context = (PMIGDB_CONTEXT) GetFileAnnouncementContext (enumItems.szName);
                ReportControlPanelApplet (
                    enumItems.szName,
                    context,
                    announcement
                    );
            }
        }
        while (MemDbEnumNextValue (&enumItems));
    }

    return TRUE;
}


DWORD
ProcessCPLs (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_PROCESS_CPLS;
    case REQUEST_RUN:
        if (!pProcessCPLs ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in ProcessCPLs"));
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\maioctl.c ===
/*
*
* maioctl.c -- Disk-querying IOCTLs for MigApp.
*
*/

#include "pch.h"
#include "migappp.h"

#ifdef UNICODE
#error "UNICODE not supported for maioctl.c"
#endif

////////////////////////////////////////////////////////////////////////////

#define VWIN32_DIOC_DOS_IOCTL 1

typedef struct _DEVIOCTL_REGISTERS {
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DEVIOCTL_REGISTERS, *PDEVIOCTL_REGISTERS;

typedef struct _MID {
    WORD  midInfoLevel;
    DWORD midSerialNum;
    BYTE  midVolLabel[11];
    BYTE  midFileSysType[8];
} MID, *PMID;

typedef struct _DEVPARAMS {
    BYTE dpSpecFunc;
    BYTE dpDevType;
    WORD dpDevAttr;
    WORD dpCylinders;
    BYTE dpMediaType;
    BYTE dpBiosParameterBlock[25];
} DEVPARAMS, *PDEVPARAMS;


BOOL DoIOCTL(PDEVIOCTL_REGISTERS preg)
{
    HANDLE hDevice;

    BOOL fResult;
    DWORD cb;

    preg->reg_Flags = 0x8000; /* assume error (carry flag set) */

    hDevice = CreateFile("\\\\.\\vwin32",
        GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
        (LPSECURITY_ATTRIBUTES) NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE) NULL);

    if (hDevice == (HANDLE) INVALID_HANDLE_VALUE) {
        return FALSE;
    } else {
        fResult = DeviceIoControl(hDevice, VWIN32_DIOC_DOS_IOCTL,
            preg, sizeof(*preg), preg, sizeof(*preg), &cb, 0);

        if (!fResult)
            return FALSE;
    }

    CloseHandle(hDevice);

    return TRUE;
}

BOOL
IsDriveRemoteOrSubstituted(
        UINT nDrive,        // 'A'==1, etc.
        BOOL *fRemote,
        BOOL *fSubstituted)
{
    DEVIOCTL_REGISTERS reg;
    MID mid;

    reg.reg_EAX = 0x4409;       /* "Check if block device remote" */
    reg.reg_EBX = nDrive;       /* zero-based drive ID       */
    reg.reg_ECX = 0;            /* Believe this is no-care   */
    reg.reg_EDX = (DWORD) &mid; /* Believe this is no-care   */

    if (!DoIOCTL(&reg)) {
        return FALSE;
    }

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */ {
        return FALSE;
    }

    // Check bit 15 for SUBST-ness
    *fSubstituted = (0 != (reg.reg_EDX & 0x8000));

    // Check bit 12 for REMOTE-ness
    *fRemote      = (0 != (reg.reg_EDX & 0x1000));

    return TRUE;
}


BOOL GetMediaID(
        PMID pmid,
        UINT nDrive)        // 'A'==1, etc.
{
    DEVIOCTL_REGISTERS reg;

    reg.reg_EAX = 0x440D;       /* IOCTL for block devices */
    reg.reg_EBX = nDrive;       /* zero-based drive ID     */
    reg.reg_ECX = 0x0866;       /* Get Media ID command    */
    reg.reg_EDX = (DWORD) pmid; /* receives media ID info  */

    if (!DoIOCTL(&reg)) {
        return FALSE;
    }

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */ {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsFloppyDrive(
              UINT nDrive)      // 'A'==1, etc.
{
    DEVIOCTL_REGISTERS reg;
    DEVPARAMS devparams;
    DWORD driveType;
    TCHAR szDriveRoot[] = TEXT("A:\\");

    *szDriveRoot += (TCHAR)(nDrive - 1);
    driveType = GetDriveType(szDriveRoot);
    if (driveType != DRIVE_REMOVABLE) {
        return FALSE;
    }

    reg.reg_EAX = 0x440d;       /* Generic IOctl */
    reg.reg_EBX = nDrive;       /* zero-based drive ID */
    reg.reg_ECX = 0x0860;       /* device category (must be 08h) and "Get Device Parameters" */
    reg.reg_EDX = (DWORD)&devparams;    /* offset of Device Parameters Structure */
    devparams.dpSpecFunc = 0;           /* request default information */

    if (!DoIOCTL(&reg) || (reg.reg_Flags & 0x8000)) {
        return FALSE;
    }

    switch (devparams.dpDevType) {
        case (0x00):         // 320/360KB
        case (0x01):         // 1.2MB
        case (0x02):         // 720KB
        case (0x03):         // 8-inch, single-density
        case (0x04):         // 8-inch, single-density
            return TRUE;
        case (0x05):         // Hard disk
        case (0x06):         // Tape drive
            return FALSE;
        case (0x07):         // 1.44MB
            return TRUE;
        case (0x08):         // Read/Write optical
            return FALSE;
        case (0x09):         // 2.88MB
            return TRUE;
        default:             // other
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\masys32.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    masys32.c

Abstract:

    Functions to migrate a Win9x user's system directory to system32.

Author:

    Mike Condra (mikeco)     25-Feb-1997

Revision History:

    ovidiut     09-Mar-1999 Added support to rename files on Win9x side
    jimschm     23-Sep-1998 Updated for new fileops code
    jimschm     02-Dec-1997 Removed rename of system32 if it already exists
    mikeco      23-Jun-1997 NT-style file- & fn-header comments

--*/



#include "pch.h"
#include "migdbp.h"
#include "migappp.h"

#define DBG_SYS32 "Sys32"


PCTSTR
pGetNewName (
    PCTSTR FileName
    )

/*++

Routine Description:

  This function generates a new name for the file that is going to be renames.

Arguments:

  FileName - Original file name

Return Value:

  the new name for file

--*/

{
    PCTSTR pattern;
    PTSTR  result ;
    UINT   count  ;
    DWORD  attrib ;

    pattern = JoinText (FileName, TEXT(".%03u"));
    result  = JoinText (FileName, TEXT("XXXX"));
    count   = 0;
    do {
        if (count == 999) {
            return result;
        }
        _stprintf (result, pattern, count);
        attrib = GetFileAttributes (result);
        count ++;
    }
    while (attrib != 0xFFFFFFFF);
    FreeText (pattern);
    return result;
}


BOOL
pRenameSystem32File (
    IN      PCTSTR NewName,
    IN OUT  PGROWBUFFER msgBufRename,
    OUT     PBOOL FileDeleted
    )

/*++

Routine Description:
  pRenameSystem32File handles the special file %windir%\system32. If it exists and cannot
  be automatically renamed, 2 things may happen:
    - in unattended mode, the file will be deleted (this will be done by textmode setup)
    - otherwise the user is asked to take a decision: either rename the file or cancels
      Setup

Arguments:

  DirName - name of NT dir to check

  msgBufRename  - growbuffer to append a Message when renaming a file.

  msgBufDelete  - growbuffer to append a Message when deleting a file (system32 only).

Return Value:

  TRUE if the operation was successful and Setup can continue, FALSE if user cancelled

--*/

{
    DWORD  attrib;
    PCTSTR Message = NULL;
    PCTSTR button1 = NULL;
    PCTSTR button2 = NULL;
    BOOL Quit;
    BOOL b = FALSE;

    *FileDeleted = FALSE;

    while (!b && !((attrib = GetFileAttributes (g_System32Dir)) & FILE_ATTRIBUTE_DIRECTORY)) {

        //
        // rename this file now
        //
        if (SetFileAttributes (g_System32Dir, FILE_ATTRIBUTE_NORMAL)) {

            if (MoveFile (g_System32Dir, NewName)) {

                b = TRUE;

                SetFileAttributes (g_System32Dir, attrib);

            } else {

                DEBUGMSG ((
                    DBG_SYS32,
                    "CheckNtDirs: Unable to set normal attributes on file %s",
                    g_System32Dir
                    ));
                SetFileAttributes (g_System32Dir, attrib);

            }
        }

        if (!b) {

            if (!UNATTENDED()) {

                //
                // ask user to take a decision about this
                //
                Message = ParseMessageID (MSG_CANNOT_RENAME_FILE, &g_System32Dir);
                button1 = GetStringResource (MSG_RETRY_RENAME);
                button2 = GetStringResource (MSG_QUIT_SETUP);

                Quit = IDBUTTON1 != TwoButtonBox (g_ParentWnd, Message, button1, button2);

                FreeStringResource (Message);
                FreeStringResource (button1);
                FreeStringResource (button2);

                if (Quit) {

                    SetLastError (ERROR_CANCELLED);

                    DEBUGMSG ((
                        DBG_SYS32,
                        "CheckNtDirs: user cancelled Setup on renaming file %s",
                        g_System32Dir
                        ));

                    return FALSE;
                }

            } else {
                //
                // suppose the admin would delete the file anyway;
                // that's exactly what textmode setup does, so leave it there and
                // return success
                //
                *FileDeleted = TRUE;
                b = TRUE;
            }
        }
    }

    return GetFileAttributes (g_System32Dir) & FILE_ATTRIBUTE_DIRECTORY;
}


BOOL
pHandleSingleDir (
    IN      PCTSTR DirName,
    IN OUT  PGROWBUFFER msgBufRename,
    IN OUT  PGROWBUFFER msgBufDelete
    )

/*++

Routine Description:
  This function checks if a file is in one of NT5 dirs way. If so, the file is renamed and
  a Message is send to log. If there is a file named %windir%\system32, it is renamed
  at this point (special behaviour) and if this fails, Setup is cancelled.

Arguments:

  DirName - name of NT dir to check

  msgBufRename  - growbuffer to append a Message when renaming a file.

  msgBufDelete  - growbuffer to append a Message when deleting a file (system32 only).

Return Value:

  TRUE if the operation was successful and Setup can continue, FALSE if user cancelled

--*/

{
    PCTSTR newFileName, FileNamePart;
    DWORD  attributes;
    TCHAR msg[MAX_TCHAR_PATH * 2 + 5];
    BOOL FileDeleted;

    attributes = GetFileAttributes (DirName);

    if (!(attributes & FILE_ATTRIBUTE_DIRECTORY)) {

        newFileName = pGetNewName (DirName);

        DEBUGMSG ((DBG_SYS32, "CheckNtDirs: Renaming %s to %s", DirName, newFileName));

        FileDeleted = FALSE;

        //
        // special case: if DirName is g_System32Dir, rename the file right now
        // because textmode Setup doesn't have a chance to rename it before
        // it is already deleted and the System32 dir is created
        //
        if (StringIMatch (DirName, g_System32Dir)) {

            if (!pRenameSystem32File (newFileName, msgBufRename, &FileDeleted)) {
                return FALSE;
            }

            if (!FileDeleted) {

                FileNamePart = GetFileNameFromPath (newFileName);
                MYASSERT (FileNamePart);

                //
                // mark this info for undo on cancel
                //
                MemDbSetValueEx (
                            MEMDB_CATEGORY_CHG_FILE_PROPS,
                            DirName,
                            FileNamePart,
                            NULL,
                            attributes,
                            NULL
                            );
            }

        } else {

            MemDbSetValueEx (MEMDB_CATEGORY_DIRS_COLLISION, DirName, NULL, NULL, 0, NULL);
        }

        //
        // append to the log
        //
        if (FileDeleted) {
            wsprintf (msg, TEXT("\n\t\t%s"), DirName);
            GrowBufAppendString (msgBufDelete, msg);
        } else {
            wsprintf (msg, TEXT("\n\t\t%s -> %s"), DirName, newFileName);
            GrowBufAppendString (msgBufRename, msg);
        }

        FreeText (newFileName);
    }

    return TRUE;
}


VOID
pCheckProfilesDir (
    IN OUT      PGROWBUFFER msgBufRename
    )

/*++

Routine Description:

  pCheckProfilesDir makes sure that there is no directory named "g_ProfileDirNt". If
  there is, it is renamed, all files and folders within are marked for external move
  and a message is added to the user report.

Arguments:

  msgBufRename - A grow buffer where the rename message will be appended,
                 if this is the case

Return Value:

  none

--*/

{
    TCHAR msg[MAX_TCHAR_PATH * 2 + 5];
    DWORD  attrib;
    PCTSTR NewName;
    PTSTR p;
    TREE_ENUM TreeEnum;
    TCHAR NewDest[MAX_MBCHAR_PATH];
    PCTSTR Message;
    PCTSTR Group;
    PCTSTR array[2];

    MYASSERT (g_ProfileDirNt);

    attrib = GetFileAttributes (g_ProfileDirNt);
    if (attrib != INVALID_ATTRIBUTES) {

        MemDbSetValueEx (MEMDB_CATEGORY_DIRS_COLLISION, g_ProfileDirNt, NULL, NULL, 0, NULL);

        NewName = pGetNewName (g_ProfileDirNt);

        DEBUGMSG ((DBG_SYS32, "CheckNtDirs: Renaming %s to %s", g_ProfileDirNt, NewName));
        MarkFileForMove (g_ProfileDirNt, NewName);

        wsprintf (msg, TEXT("\n\t\t%s -> %s"), g_ProfileDirNt, NewName);
        GrowBufAppendString (msgBufRename, msg);

        if (attrib & FILE_ATTRIBUTE_DIRECTORY) {
            //
            // mark all files in the tree for move
            //
            if (EnumFirstFileInTree (&TreeEnum, g_ProfileDirNt, NULL, TRUE)) {

                StringCopy (NewDest, NewName);
                p = AppendWack (NewDest);

                do {

                    MYASSERT (*TreeEnum.SubPath != '\\');
                    StringCopy (p, TreeEnum.SubPath);
                    if (!TreeEnum.Directory) {
                        if (CanSetOperation (TreeEnum.FullPath, OPERATION_TEMP_PATH)) {
                            //
                            // remove old operation and set a new one
                            // with the updated final dest
                            //
                            MarkFileForTemporaryMove (TreeEnum.FullPath, NewDest, g_TempDir);
                        } else {
                            if (CanSetOperation (TreeEnum.FullPath, OPERATION_FILE_MOVE)) {
                                MarkFileForMove (TreeEnum.FullPath, NewDest);
                            }
                        }
                    } else {
                        if (CanSetOperation (TreeEnum.FullPath, OPERATION_FILE_MOVE_EXTERNAL)) {
                            MarkFileForMoveExternal (TreeEnum.FullPath, NewDest);
                        }
                    }

                } while (EnumNextFileInTree (&TreeEnum));
            }

            array[0] = g_ProfileDirNt;
            array[1] = NewName;
            Message = ParseMessageID (MSG_DIRECTORY_COLLISION_SUBCOMPONENT, array);

            if (Message) {

                Group = BuildMessageGroup (
                            MSG_INSTALL_NOTES_ROOT,
                            MSG_DIRECTORY_COLLISION_SUBGROUP,
                            Message
                            );

                if (Group) {

                        MsgMgr_ObjectMsg_Add (TEXT("*RenameFolders"), Group, S_EMPTY);

                        FreeText (Group);
                    }

                FreeStringResource (Message);
            }
        }

        FreeText (NewName);
    }
}


BOOL
pCheckNtDirs (
    VOID
    )

/*++

Routine Description:

  This function makes sure that there is no file with the same name as one of
  the NT5 directories.

Arguments:

  none

Return Value:

  TRUE if check was successful; FALSE if Setup was cancelled by the user

--*/

{
    MEMDB_ENUM enumDirs;
    GROWBUFFER msgBufRename = GROWBUF_INIT;
    GROWBUFFER msgBufDelete = GROWBUF_INIT;
    BOOL Success = TRUE;

    //
    // check first for g_ProfileDirNt
    //
    pCheckProfilesDir (&msgBufRename);

    if (MemDbEnumFirstValue (
            &enumDirs,
            TEXT(MEMDB_CATEGORY_NT_DIRSA)TEXT("\\*"),
            MEMDB_ALL_SUBLEVELS,
            MEMDB_ENDPOINTS_ONLY
            )) {

        do {
            if (!pHandleSingleDir (enumDirs.szName, &msgBufRename, &msgBufDelete)) {
                Success = FALSE;
                break;
            }
        }
        while (MemDbEnumNextValue (&enumDirs));
    }

    if (Success) {

        //
        // warn user about what will happen
        //
        if (msgBufDelete.Buf) {
            LOG ((LOG_WARNING, (PCSTR)MSG_DIR_COLLISION_DELETE_LOG, msgBufDelete.Buf));
        }

        if (msgBufRename.Buf) {
            LOG ((LOG_WARNING, (PCSTR)MSG_DIR_COLLISION_LOG, msgBufRename.Buf));
        }
    }

    FreeGrowBuffer (&msgBufDelete);
    FreeGrowBuffer (&msgBufRename);

    return Success;
}


DWORD
CheckNtDirs (
    IN     DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_CHECK_NT_DIRS;
    case REQUEST_RUN:
        if (!pCheckNtDirs ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        LOG ((LOG_ERROR, "Bad parameter while checking Nt Directories."));
    }
    return 0;
}

BOOL
pReadSystemFixedFiles (
    IN OUT  HASHTABLE SystemFixedFiles
    )

/*++

Routine Description:

  This function reads a section from Win95upg.inf with all modules that must remain in System directory.

Arguments:

  none

Return Value:

  TRUE if successfull, FALSE otherwise

--*/

{
    INFCONTEXT context;
    TCHAR fileName[MAX_TCHAR_PATH];
    BOOL result = TRUE;

    if (g_Win95UpgInf == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Unable to read from WIN95UPG.INF"));
        SetLastError (ERROR_FILE_NOT_FOUND);
        return FALSE;
    }

    if (SetupFindFirstLine (g_Win95UpgInf, WINDIR_SYSTEM_FIXED_FILES, NULL, &context)) {
        do {
            if (SetupGetStringField (
                    &context,
                    1,
                    fileName,
                    MAX_TCHAR_PATH,
                    NULL
                    )) {

                HtAddString (SystemFixedFiles, fileName);
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "File name not found in %s", WINDIR_SYSTEM_FIXED_FILES));
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}

BOOL
pReadSystemForcedMoveFiles (
    VOID
    )

/*++

Routine Description:

  This function reads a section from Win95upg.inf with patterns for all modules that should be moved to System32 directory.

Arguments:

  none

Return Value:

  TRUE if successfull, FALSE otherwise

--*/

{
    INFCONTEXT context;
    TCHAR filePattern[MAX_TCHAR_PATH];
    BOOL result = TRUE;

    if (g_Win95UpgInf == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Unable to read from WIN95UPG.INF"));
        SetLastError (ERROR_FILE_NOT_FOUND);
        return FALSE;
    }

    if (SetupFindFirstLine (g_Win95UpgInf, SYSTEM32_FORCED_MOVE, NULL, &context)) {
        do {
            if (SetupGetStringField (
                    &context,
                    1,
                    filePattern,
                    MAX_TCHAR_PATH,
                    NULL
                    )) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_SYSTEM32_FORCED_MOVE,
                    filePattern,
                    NULL,
                    NULL,
                    0,
                    NULL
                    );
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "File name not found in %s", SYSTEM32_FORCED_MOVE));
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}


VOID
pMarkFileForSys32Move (
    IN      PCTSTR FileName,
    IN      PCTSTR FullFileSpec,
    IN      PCTSTR MovedFile,
    IN      BOOL CheckExeType
    )

/*++

Routine Description:

  pMarkFileForSys32Move marks a file in %windir%\system to be moved to
  %windir%\system32.  It takes into account all previous processing, so there
  is no operation collisions.

Arguments:

  FileName     - Specifies the src file name or sub-path from %windir%\system.
  FullFileSpec - Specifies the full path to the source file (which is
                 supposed to be in the system dir)
  MovedFile    - Specifies the destination path (which is supposed to be in
                 the system32 dir)
  CheckExeType - Specifies TRUE if only 32-bit binaries should be moved.  If TRUE
                 and FullFileSpec does not point to a 32-bit binary, then
                 memdb is queried for non-32-bit binaries that should be moved.

Return Value:

  None.

--*/

{
    TCHAR key [MEMDB_MAX];

    //
    // Skip file if we already plan to move or delete it.
    //
    if (!CanSetOperation (FullFileSpec, OPERATION_FILE_MOVE)) {
        DEBUGMSG ((
            DBG_SYS32,
            "File already flagged for change: %s",
            FullFileSpec
            ));

        return;
    }

    if (!IsFileMarkedForChange (MovedFile)) {

        if (CheckExeType) {
            //
            // See if Win32 PE
            //

            if (GetModuleType (FullFileSpec) != W32_MODULE) {

                MemDbBuildKey (key, MEMDB_CATEGORY_SYSTEM32_FORCED_MOVE, FileName, NULL, NULL);
                if (!MemDbGetPatternValue (key, NULL)) {
                    return;
                }
            }
        }

    } else {
        //
        // Move file during text mode because we know it is going to be
        // created.  This allows text mode to compare versions before
        // overwriting.
        //
        // NOTE: We can be certain that the creation isn't from a file copy,
        //       because we tested the source file above, and there is no
        //       other reason why a file in system32 will be copied from
        //       any other location than system or the NT sources.
        //
        //       Also note that migration DLLs have not been processed yet.
        //

        RemoveOperationsFromPath (MovedFile, ALL_DEST_CHANGE_OPERATIONS);
    }

    //
    // All tests passed -- do the move
    //

    DEBUGMSG ((DBG_SYS32, "Moving %s to %s", FullFileSpec, MovedFile));
    MarkFileForMove (FullFileSpec, MovedFile);

}


BOOL
pMoveSystemDir (
    VOID
    )

/*++

Routine Description:

  MoveSystemDir scans the %windir%\system directory for all 32-bit
  executables that are not excluded in win95upg.inf.  Any matches are moved
  to system32.

Arguments:

  none

Return Value:

  TRUE if successfull, FALSE otherwise

--*/

{
    TCHAR SystemDirPattern[MAX_TCHAR_PATH];
    TCHAR FullFileSpec[MAX_TCHAR_PATH];
    TCHAR MovedFile[MAX_TCHAR_PATH];
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    TCHAR key [MEMDB_MAX];
    TREE_ENUM e;
    PTSTR p, q;
    PTSTR SubPathEnd;
    HASHTABLE systemFixedFiles;
    DWORD count = 0;

    DEBUGMSG ((DBG_SYS32, "Begining system to system32 processing"));

    systemFixedFiles = HtAlloc();

    if (!pReadSystemFixedFiles (systemFixedFiles)) {

        HtFree (systemFixedFiles);
        return FALSE;
    }

    pReadSystemForcedMoveFiles ();

    //
    // Build the string %sysdir%\\*.*
    //
    StringCopy(SystemDirPattern, g_SystemDir);
    StringCat(SystemDirPattern, TEXT("\\*.*"));

    hFind = FindFirstFile (SystemDirPattern, &fd);

    if (INVALID_HANDLE_VALUE != hFind) {

        StringCopy (FullFileSpec, g_SystemDir);
        p = AppendWack (FullFileSpec);

        StringCopy (MovedFile, g_System32Dir);
        q = AppendWack (MovedFile);

        do {
            //
            // Reject "." and ".."
            //
            if (StringMatch(fd.cFileName, _T(".")) ||
                StringMatch(fd.cFileName, _T(".."))) {

                continue;
            }

            //
            // See if is on list of files that stay in system dir
            //
            if (HtFindString (systemFixedFiles, fd.cFileName)) {
                continue;
            }

            //
            // If it's a directory, see if we should move it, and if so,
            // move it!
            //
            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                MemDbBuildKey (key, MEMDB_CATEGORY_SYSTEM32_FORCED_MOVE, fd.cFileName, NULL, NULL);
                if (!MemDbGetPatternValue (key, NULL)) {
                    continue;
                }

                //
                // To move a subdir, we enumerate all files in the tree, mark
                // each of them for move, and then follow the normal code path
                // to mark the dir itself to be moved.
                //

                StringCopy (p, fd.cFileName);

                StringCopy (q, fd.cFileName);
                SubPathEnd = AppendWack (q);

                if (EnumFirstFileInTree (&e, FullFileSpec, NULL, FALSE)) {

                    do {
                        StringCopy (SubPathEnd, e.SubPath);
                        pMarkFileForSys32Move (q, e.FullPath, MovedFile, FALSE);

                    } while (EnumNextFileInTree (&e));
                }
                TickProgressBar ();
            }

            //
            // Make full file spec
            //
            StringCopy (p, fd.cFileName);
            StringCopy (q, fd.cFileName);

            pMarkFileForSys32Move (fd.cFileName, FullFileSpec, MovedFile, TRUE);

            count++;
            if (!(count % 128)) {
                TickProgressBar ();
            }
        } while (FindNextFile (hFind, &fd));

        FindClose (hFind);
    }

    HtFree (systemFixedFiles);

    DEBUGMSG ((DBG_SYS32, "End of system to system32 processing"));

    return TRUE;
}


DWORD
MoveSystemDir (
    IN     DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_MOVE_SYSTEM_DIR;
    case REQUEST_RUN:
        if (!pMoveSystemDir ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        LOG ((LOG_ERROR, "Bad parameter found while moving system directory."));
    }
    return 0;
}


BOOL
UndoChangedFileProps (
    VOID
    )

/*++

Routine Description:

  UndoChangedFileProps enumerates all values in MEMDB_CATEGORY_CHG_FILE_PROPS and
  restore files to their original state (name, attributes). This function should
  be called when the user cancels the upgrade.

Arguments:

  none

Return Value:

  TRUE if all files were successfully set to their original attributes, FALSE otherwise

--*/

{
    MEMDB_ENUM e;
    PTSTR FileNamePart, NewName, DirNameEnd;
    BOOL b = TRUE;

    if (MemDbGetValueEx (
            &e,
            TEXT(MEMDB_CATEGORY_CHG_FILE_PROPS) TEXT("\\*"),
            NULL,
            NULL
            )) {

        do {

            FileNamePart = _tcsrchr (e.szName, TEXT('\\'));
            MYASSERT(FileNamePart);

            *FileNamePart = 0;
            FileNamePart++;

            DirNameEnd = _tcsrchr (e.szName, TEXT('\\'));
            MYASSERT(DirNameEnd);
            *DirNameEnd = 0;

            NewName = JoinPaths (e.szName, FileNamePart);

            *DirNameEnd = TEXT('\\');

            if (!SetFileAttributes (NewName, FILE_ATTRIBUTE_NORMAL) ||
                !MoveFile (NewName, e.szName) ||
                !SetFileAttributes (e.szName, e.dwValue)) {

                b = FALSE;
            }

            FreePathString (NewName);

        } while (MemDbEnumNextValue (&e));
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\migappp.h ===
#pragma once

//
// values for FILE_HELPER_PARAMS.CurrentDirData bits, used for the migapp module
//
#define MIGAPP_DIRDATA_FUSION_DIR_DETERMINED    0x0001
#define MIGAPP_DIRDATA_IS_FUSION_DIR            0x0002

//
// values for GetExeType
//
#define EXE_UNKNOWN         0
#define EXE_WIN32_APP       1
#define EXE_WIN32_DLL       2
#define EXE_WIN16_APP       3
#define EXE_WIN16_DLL       4


DWORD
GetExeType (
    IN      PCTSTR ModuleName
    );

//
// Function to build mapping between Win95 and WinNT profile directories.
// Enumerates users; looks at a series of directories in each user's
// profile; builds a mapping (now written temporarily to c:\\profile.map).
//
DWORD
ReadProfileDirs (
    VOID
    );


//
// Module name has to be present in DeferredAnnounce category in MigDb. If LinkName == NULL then
// a valid MigDbContext needs to be pointed by the value of MemDb key
//
BOOL
HandleDeferredAnnounce (
    IN      PCTSTR LinkName,
    IN      PCTSTR ModuleName,
    IN      BOOL DosApp
    );

DWORD
PrepareProcessModules (
    IN      DWORD Request
    );

DWORD
ProcessModules (
    IN      DWORD Request
    );

BOOL
InitLinkAnnounce (
    VOID
    );

BOOL
DoneLinkAnnounce (
    VOID
    );

BOOL
ProcessFileHelpers (
    IN OUT  PFILE_HELPER_PARAMS Params
    );


DWORD
CheckModule (
    IN      PCSTR ModuleName,
    IN      PCSTR AppPaths              OPTIONAL
    );

BOOL
IsNtCompatibleModule (
    IN      PCTSTR ModuleName
    );

//
// hash table used to deal with [UseNtFiles]
//
extern HASHTABLE g_UseNtFileHashTable;

VOID
InitUseNtFilesMap (
    VOID
    );

VOID
CleanupUseNtFilesMap (
    VOID
    );


BOOL
IsMigrationPathEx (
    IN      PCTSTR Path,
    OUT     PBOOL IsWin9xOsPath         OPTIONAL
    );

#define IsMigrationPath(p)      IsMigrationPathEx(p,NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\migapp.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    migapp.c

Abstract:

    Majority of functions for application migration on the Win95 side..
    Everything in this source file called from MigApp_Main.

Author:

    Mike Condra (mikeco)    28-Oct-1996

Revision History:

    jimschm     23-Sep-1998 Updated for new fileops code
    calinn      22-May-1998 Added code for broken CPLs processing.
    calinn      03-Feb-1998 ** Major cleanup ** More than 1500 line were deleted.
    jimschm     20-Jan-1998 Replaced migration DLL code
    marcw       03-Dec-1997 Suprressed the display of hidden directories.
    jimschm     02-Dec-1997 Turned off rename of system32 when it is a directory
    marcw       15-Jul-1997 Switched to common acc. drives/exclusion handling code.
    mikeco      08-Jul-1997 Format per NT common std
    mikeco      06-Jun-1997 Pass exclude.inf exclusions thru to migrate.infs.
    mikeco      17-Apr-1997 BadSoftwareDeferred_* functions.
    marcw       14-Apr-1997 Retrofitted new Progress Bar code into project.

--*/

#include "pch.h"
#include "migdbp.h"
#include "migappp.h"
#include <regstr.h>

#define DBG_MIGAPP          "MigApp"

HASHTABLE g_PerUserRegKeys;


//
// MigApp initialization and cleanup (not static)
//
BOOL
WINAPI
MigApp_Entry (
        IN      HINSTANCE hInstance,
        IN      DWORD dwReason,
        LPVOID  lpReserved
        )
{
    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
            g_RegKeyPresentIndex = MigDb_GetAttributeIdx ("REGKEYPRESENT");
            g_PerUserRegKeys = HtAllocWithData (sizeof (BOOL));
            break;

        case DLL_PROCESS_DETACH:
            HtFree (g_PerUserRegKeys);
            break;
    }
    return TRUE;
}


BOOL
pSearchCompatibleModule (
    IN      PCTSTR CommandLine,
    OUT     PTSTR *FullFileName,    // OPTIONAL
    IN      PCTSTR Category95
    )
{
    TCHAR key    [MEMDB_MAX];
    TCHAR module     [MAX_TCHAR_PATH] = TEXT("");
    TCHAR moduleLong [MAX_TCHAR_PATH] = TEXT("");
    PATH_ENUM pathEnum;
    BOOL result = FALSE;

    if (FullFileName) {
        *FullFileName = NULL;
    }

    ExtractArgZeroEx (CommandLine, module, NULL, FALSE);
    if (OurGetLongPathName (module, moduleLong, MAX_TCHAR_PATH)) {
        MemDbBuildKey (key, Category95, moduleLong, NULL, NULL);
        result = MemDbGetValue (key, NULL);
        if (FullFileName) {
            *FullFileName = DuplicatePathString (moduleLong, 0);
        }
    } else {
        if (EnumFirstPath (&pathEnum, NULL, g_WinDir, g_SystemDir)) {
            do {
                MemDbBuildKey (key, pathEnum.PtrCurrPath, module, NULL, NULL);
                if (OurGetLongPathName (key, moduleLong, MAX_TCHAR_PATH)) {
                    MemDbBuildKey (key, Category95, moduleLong, NULL, NULL);
                    result = MemDbGetValue (key, NULL);
                    if (FullFileName) {
                        *FullFileName = DuplicatePathString (moduleLong, 0);
                    }
                    break;
                }
            }
            while (EnumNextPath (&pathEnum));
        }
        EnumPathAbort (&pathEnum);

        MemDbBuildKey (key, Category95, module, NULL, NULL);
        result = MemDbGetValue (key, NULL);
        if (FullFileName) {
            *FullFileName = DuplicatePathString (module, 0);
        }
    }
    return result;
}


BOOL
pReportBadShell (
    VOID
    )
{
    PCTSTR object  = NULL;
    PCTSTR message = NULL;

    BOOL result = TRUE;

    __try {
        object = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_REPORT_SHELL_SUBGROUP, NULL);
        message = GetStringResource (MSG_REPORT_SHELL_INCOMPATIBLE);
        if (object && message) {
            MsgMgr_ObjectMsg_Add (TEXT("*BadShell"), object, message);
        } else {
            result = FALSE;
        }

    }
    __finally {
        if (object != NULL) {
            FreeText (object);
        }
        if (message != NULL) {
            FreeStringResource (message);
        }
    }
    return result;
}

VOID
pProcessAsRunKey (
    IN      HKEY RunKey
    )
{
    PCTSTR        entryStr;
    REGVALUE_ENUM runKeyEnum;
    PTSTR         fullFileName;
    DWORD         Status;

    if (EnumFirstRegValue (&runKeyEnum, RunKey)) {

        do {

            entryStr = GetRegValueString (RunKey, runKeyEnum.ValueName);
            if (entryStr != NULL) {

                if (pSearchCompatibleModule (entryStr, &fullFileName, MEMDB_CATEGORY_COMPATIBLE_RUNKEY)) {
                    MemDbSetValueEx (
                        MEMDB_CATEGORY_COMPATIBLE_RUNKEY_NT,
                        runKeyEnum.ValueName,
                        NULL,
                        NULL,
                        0,
                        NULL
                        );

                } else {

                    if (fullFileName) {

                        Status = GetFileStatusOnNt (fullFileName);

                        if (!TreatAsGood (fullFileName)) {

                            if (!(Status & FILESTATUS_REPLACED)) {

                                if (!IsFileMarkedAsOsFile (fullFileName)) {
                                    if (!IsFileMarkedForAnnounce (fullFileName)) {
                                        // unknown
                                        AnnounceFileInReport (fullFileName, 0, ACT_INC_SAFETY);
                                    } else {
                                        // known bad
                                        MemDbSetValueEx (
                                            MEMDB_CATEGORY_INCOMPATIBLE_RUNKEY_NT,
                                            runKeyEnum.ValueName,
                                            NULL,
                                            NULL,
                                            0,
                                            NULL
                                            );
                                    }
                                }
                            }

                        } else {
                            MemDbSetValueEx (
                                MEMDB_CATEGORY_COMPATIBLE_RUNKEY_NT,
                                runKeyEnum.ValueName,
                                NULL,
                                NULL,
                                0,
                                NULL
                                );
                        }
                    }
                }

                FreePathString (fullFileName);
                MemFree (g_hHeap, 0, entryStr);
            }

        } while (EnumNextRegValue (&runKeyEnum));
    }
}


BOOL
pProcessRunKey (
    VOID
    )
{
    HKEY          runKey;

    runKey = OpenRegKeyStr (S_RUNKEY);
    if (runKey != NULL) {
        pProcessAsRunKey (runKey);
        CloseRegKey (runKey);
    }
    return TRUE;
}


DWORD
ProcessRunKey (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_PROCESS_RUN_KEY;
    case REQUEST_RUN:
        if (!pProcessRunKey ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        LOG ((LOG_ERROR, "Bad parameter while processing run key."));
    }
    return 0;
}


VOID
pProcessRunKey_User (
    IN      PUSERENUM EnumPtr
    )
{
    HKEY          runKey;

    runKey = OpenRegKey (EnumPtr->UserRegKey, REGSTR_PATH_RUN);
    if (runKey != NULL) {
        pProcessAsRunKey (runKey);
        CloseRegKey (runKey);
    }
}


DWORD
ProcessRunKey_User (
    IN      DWORD Request,
    IN      PUSERENUM EnumPtr
    )
{
    switch (Request) {

    case REQUEST_QUERYTICKS:
        return TICKS_PROCESS_RUN_KEY;

    case REQUEST_BEGINUSERPROCESSING:
        //
        // No initialization needed.
        //
        break;

    case REQUEST_RUN:
        pProcessRunKey_User (EnumPtr);
        break;

    case REQUEST_ENDUSERPROCESSING:
        //
        // No cleanup needed.
        //
        break;
    }

    return ERROR_SUCCESS;
}

PTSTR
GetFullLongName (
    PCTSTR FileName
    )
{
    PTSTR result = NULL;
    TCHAR longName [MAX_TCHAR_PATH];
    PTSTR dontCare;


    if (DoesFileExist (FileName)) {
        if (!OurGetLongPathName (FileName, longName, MAX_TCHAR_PATH)) {
            _tcsncpy (longName, FileName, MAX_TCHAR_PATH);
        }
        result = DuplicatePathString (longName, 0);
    }
    else {
        if (SearchPath (NULL, FileName, NULL, MAX_TCHAR_PATH, longName, &dontCare)) {
            result = DuplicatePathString (longName, 0);
        }
    }
    return result;
}


BOOL
pReportIncompatibleSCR (
    IN      PCTSTR FileName,
    IN      PMIGDB_CONTEXT Context,
    IN      WORD ActType
    )
{
    PTSTR friendlyName = NULL;
    PTSTR extPtr = NULL;
    PTSTR displayName = NULL;
    PCTSTR reportEntry = NULL;
    PTSTR component = NULL;
    PCTSTR temp1, temp2;
    BOOL reportEntryIsResource = TRUE;

    if ((Context != NULL) &&
        (Context->SectLocalizedName != NULL)
        ) {
        friendlyName = DuplicatePathString (Context->SectLocalizedName, 0);
    }
    else {
        friendlyName = DuplicatePathString (GetFileNameFromPath (FileName), 0);
        extPtr = (PTSTR) GetFileExtensionFromPath (friendlyName);
        if (extPtr != NULL) {
            extPtr = _tcsdec (friendlyName, extPtr);
            if (extPtr != NULL) {
                *extPtr = 0;
            }
        }

        displayName = (PTSTR)ParseMessageID (MSG_NICE_PATH_SCREEN_SAVER, &friendlyName);

        FreePathString (friendlyName);
        friendlyName = NULL;
    }
    switch (ActType) {

    case ACT_REINSTALL:
        temp1 = GetStringResource (MSG_REINSTALL_ROOT);
        if (!temp1) {
            break;
        }
        temp2 = GetStringResource (
                    Context && Context->Message ?
                        MSG_REINSTALL_DETAIL_SUBGROUP :
                        MSG_REINSTALL_LIST_SUBGROUP
                        );
        if (!temp2) {
            break;
        }

        reportEntry = JoinPaths (temp1, temp2);
        reportEntryIsResource = FALSE;

        FreeStringResource (temp1);
        FreeStringResource (temp2);
        break;

    case ACT_REINSTALL_BLOCK:
        temp1 = GetStringResource (MSG_BLOCKING_ITEMS_ROOT);
        if (!temp1) {
            break;
        }
        temp2 = GetStringResource (MSG_REINSTALL_BLOCK_ROOT);
        if (!temp2) {
            break;
        }

        reportEntry = JoinPaths (temp1, temp2);
        reportEntryIsResource = FALSE;

        FreeStringResource (temp1);
        FreeStringResource (temp2);
        break;

    case ACT_MINORPROBLEMS:
        reportEntry = GetStringResource (MSG_MINOR_PROBLEM_ROOT);
        break;

    case ACT_INCOMPATIBLE:
    case ACT_INC_NOBADAPPS:

        temp1 = GetStringResource (MSG_INCOMPATIBLE_ROOT);
        if (!temp1) {
            break;
        }
        temp2 = GetStringResource (
                    Context && Context->Message ?
                        MSG_INCOMPATIBLE_DETAIL_SUBGROUP :
                        MSG_TOTALLY_INCOMPATIBLE_SUBGROUP
                        );
        if (!temp2) {
            break;
        }

        reportEntry = JoinPaths (temp1, temp2);
        reportEntryIsResource = FALSE;

        FreeStringResource (temp1);
        FreeStringResource (temp2);

        break;

    default:
        LOG((LOG_ERROR, "Bad parameter found while processing incompatible screen savers."));
        return FALSE;
    }

    if (!reportEntry) {
        LOG((LOG_ERROR, "Cannot read resources while processing incompatible screen savers."));
    } else {

        component = JoinPaths (reportEntry, displayName?displayName:friendlyName);

        MsgMgr_ObjectMsg_Add (FileName, component, Context ? Context->Message : NULL);

        FreePathString (component);

        if (reportEntryIsResource) {
            FreeStringResource (reportEntry);
        } else {
            FreePathString (reportEntry);
        }
        reportEntry = NULL;
    }

    if (displayName) {
        FreeStringResourcePtrA (&displayName);
    }

    if (friendlyName) {
        FreePathString (friendlyName);
    }

    return TRUE;
}


BOOL
pProcessShellSettings (
    VOID
    )
{
    HINF    infHandle = INVALID_HANDLE_VALUE;
    PCTSTR  infName = NULL;
    PCTSTR  field   = NULL;
    INFSTRUCT context = INITINFSTRUCT_POOLHANDLE;
    PCTSTR  saverName = NULL;
    TCHAR key [MEMDB_MAX];
    PMIGDB_CONTEXT migDbContext;
    DWORD actType;

    infName = JoinPaths (g_WinDir, TEXT("SYSTEM.INI"));

    __try {
        infHandle = InfOpenInfFile (infName);
        if (infHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }
        if (InfFindFirstLine (infHandle, TEXT("boot"), TEXT("SCRNSAVE.EXE"), &context)) {
            field = InfGetStringField (&context, 1);
            if (field != NULL) {
                // see if this is a compatible module so far
                saverName = GetFullLongName (field);
                if (saverName) {
                    MemDbBuildKey (key, MEMDB_CATEGORY_DEFERREDANNOUNCE, saverName, NULL, NULL);
                    if (MemDbGetValueAndFlags (key, (PDWORD)(&migDbContext), &actType)) {
                        pReportIncompatibleSCR (saverName, migDbContext, (WORD) actType);
                    }
                    FreePathString (saverName);
                }
            }
        }
        if (InfFindFirstLine (infHandle, TEXT("boot"), TEXT("SHELL"), &context)) {
            field = InfGetStringField (&context, 1);
            if (field != NULL) {
                if (pSearchCompatibleModule (field, NULL, MEMDB_CATEGORY_COMPATIBLE_SHELL)) {
                    MemDbSetValueEx (
                        MEMDB_CATEGORY_COMPATIBLE_SHELL_NT,
                        field,
                        NULL,
                        NULL,
                        0,
                        NULL);
                }
                else {
                    pReportBadShell ();
                }
            }
        }
    }
    __finally {
        if (infHandle != INVALID_HANDLE_VALUE) {
            InfCloseInfFile (infHandle);
        }
        if (infName != NULL) {
            FreePathString (infName);
        }
        InfCleanUpInfStruct(&context);
    }
    return TRUE;
}


DWORD
ProcessShellSettings (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_PROCESS_SHELL_SETTINGS;
    case REQUEST_RUN:
        if (!pProcessShellSettings ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        LOG ((LOG_ERROR, "Bad parameter found while processing shell settings."));
    }
    return 0;
}


BOOL
pProcessCompatibleSection (
    VOID
    )
{
    INFCONTEXT context;
    CHAR object [MEMDB_MAX];

    MYASSERT (g_MigDbInf);
    if (SetupFindFirstLine (g_MigDbInf, S_COMPATIBLE, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 1, object, MEMDB_MAX, NULL)) {
                HandleReportObject (object);
            }
        }
        while (SetupFindNextLine (&context, &context));
    }
    return TRUE;
}

DWORD
ProcessCompatibleSection (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_PROCESS_COMPATIBLE_SECTION;
    case REQUEST_RUN:
        if (!pProcessCompatibleSection ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        LOG ((LOG_ERROR, "Bad parameter found while processing compatible files."));
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\migdbp.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migdbp.h

Abstract:

    Header file for implementing old AppDb functionality

Author:

    Calin Negreanu (calinn) 07-Ian-1998

Revision History:

    <alias> <date> <comments>

--*/

#include <cpl.h>
#include "dbattrib.h"

extern INT g_RegKeyPresentIndex;
extern HASHTABLE g_PerUserRegKeys;

typedef struct _MIGDB_REQ_FILE;

typedef struct _MIGDB_CONTEXT;

typedef struct _MIGDB_SECTION {
    BOOL    Satisfied;
    struct _MIGDB_CONTEXT *Context;
    struct _MIGDB_SECTION *Next;
} MIGDB_SECTION, *PMIGDB_SECTION;

typedef struct _MIGDB_CONTEXT {
    INT     ActionIndex;
    UINT    TriggerCount;
    BOOL    VirtualFile;
    PCSTR   SectName;
    PCSTR   SectLocalizedName;
    PCSTR   SectNameForDisplay;     // SectLocalizedName, or SectName if not localized
    PCSTR   Message;
    PCSTR   Arguments;
    GROWBUFFER FileList;
    PMIGDB_SECTION Sections;
    struct _MIGDB_CONTEXT *Next;
} MIGDB_CONTEXT, *PMIGDB_CONTEXT;

typedef struct _MIGDB_FILE {
    PMIGDB_SECTION Section;
    PMIGDB_ATTRIB  Attributes;
    struct _MIGDB_FILE *Next;
} MIGDB_FILE, *PMIGDB_FILE;

typedef struct _MIGDB_REQ_FILE {
    PCSTR   ReqFilePath;
    PMIGDB_ATTRIB FileAttribs;
    struct _MIGDB_REQ_FILE *Next;
} MIGDB_REQ_FILE, *PMIGDB_REQ_FILE;

typedef struct {
    PMIGDB_FILE First;
    PMIGDB_FILE Last;
} FILE_LIST_STRUCT, *PFILE_LIST_STRUCT;


//
// Declare the action functions prototype
//
typedef BOOL (ACTION_PROTOTYPE) (PMIGDB_CONTEXT Context);
typedef ACTION_PROTOTYPE * PACTION_PROTOTYPE;

//
// Declare MigDb hook function prototype
//
typedef BOOL (MIGDB_HOOK_PROTOTYPE) (PCSTR FileName, PMIGDB_CONTEXT Context, PMIGDB_SECTION Section, PMIGDB_FILE File, PMIGDB_ATTRIB Attrib);
typedef MIGDB_HOOK_PROTOTYPE * PMIGDB_HOOK_PROTOTYPE;


extern  HINF            g_MigDbInf;
extern  BOOL            g_InAnyDir;


PACTION_PROTOTYPE
MigDb_GetActionAddr (
    IN      INT ActionIdx
    );

INT
MigDb_GetActionIdx (
    IN      PCSTR ActionStr
    );

PCSTR
MigDb_GetActionName (
    IN      INT ActionIdx
    );

BOOL
MigDb_CallWhenTriggered (
    IN      INT ActionIdx
    );

BOOL
MigDb_CanHandleVirtualFiles (
    IN      INT ActionIdx
    );

BOOL
MigDb_CallAlways (
    IN      INT ActionIdx
    );

PMIGDB_HOOK_PROTOTYPE
SetMigDbHook (
    PMIGDB_HOOK_PROTOTYPE HookFunction
    );


PSTR
QueryVersionEntry (
    IN      PCSTR FileName,
    IN      PCSTR VersionEntry
    );

UINT
ComputeCheckSum (
    PFILE_HELPER_PARAMS Params
    );

#define UNKNOWN_MODULE  0
#define DOS_MODULE      1
#define W16_MODULE      2
#define W32_MODULE      3

DWORD
GetModuleType (
    IN      PCSTR ModuleName
    );


PCSTR
Get16ModuleDescription (
    IN      PCSTR ModuleName
    );

ULONG
GetPECheckSum (
    IN      PCSTR ModuleName
    );

BOOL
DeleteFileWithWarning (
    IN      PCTSTR FileName
    );


PSTR
GetHlpFileTitle (
    IN PCSTR FileName
    );


BOOL
ReportControlPanelApplet (
    IN      PCTSTR FileName,
    IN      PMIGDB_CONTEXT Context,         OPTIONAL
    IN      DWORD ActType
    );

BOOL
IsDisplayableCPL (
    IN      PCTSTR FileName
    );

ULONGLONG
GetBinFileVer (
    IN      PCSTR FileName
    );

ULONGLONG
GetBinProductVer (
    IN      PCSTR FileName
    );

DWORD
GetFileDateHi (
    IN      PCSTR FileName
    );

DWORD
GetFileDateLo (
    IN      PCSTR FileName
    );

DWORD
GetFileVerOs (
    IN      PCSTR FileName
    );

DWORD
GetFileVerType (
    IN      PCSTR FileName
    );

BOOL
GlobalVersionCheck (
    IN      PCSTR FileName,
    IN      PCSTR NameToCheck,
    IN      PCSTR ValueToCheck
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\modules.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    modules.c

Abstract:

    Implements a function that checkes every module listed in MEMDB_CATEGORY_MODULE_CHECK
    trying to see if all modules listed in IMPORT section are going to be available on NT.

    The entry point is ProcessModules

Author:

    Calin Negreanu (calinn) 27-Nov-1997

Revision History:

    mvander     26-Map-1999 Moved MODULESTATUS defines to fileops.h
    calinn      23-Sep-1998 Added support for NT installed files

--*/

#include "pch.h"
#include "migdbp.h"
#include "migappp.h"

#define DBG_MODULES   "Modules"

#ifdef DEBUG
DWORD g_NumEXEs     = 0;
#endif

DWORD           g_ModuleRecursionLevel = 0;
#define         MAX_MODULE_RECURSION_LEVEL  50

#define WIN32_EXE_SET_BITS      (IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_32BIT_MACHINE)
#define WIN32_EXE_CLEAR_BITS    (IMAGE_FILE_DLL)
#define WIN32_DLL_SET_BITS      (WIN32_EXE_SET_BITS | IMAGE_FILE_DLL)
#define WIN32_DLL_CLEAR_BITS    0

#define WIN16_LIBRARY           0x8000

//since we are reading from a file we need that sizeof to give us the accurate result
#pragma pack(push,1)

typedef struct _NE_HEADER {
    WORD  Magic;
    BYTE  MajorLinkerVersion;
    BYTE  MinorLinkerVersion;
    WORD  EntryTableOff;
    WORD  EntryTableLen;
    ULONG Reserved;
    WORD  Flags;
    WORD  NumberOfDataSeg;
    WORD  SizeOfHeap;
    WORD  SizeOfStack;
    ULONG CS_IP;
    ULONG SS_SP;
    WORD  NumEntriesSegTable;
    WORD  NumEntriesModuleTable;
    WORD  NonResNameTableSize;
    WORD  SegTableOffset;
    WORD  ResTableOffset;
    WORD  ResNameTableOffset;
    WORD  ModuleTableOffset;
    WORD  ImportedTableOffset;
    ULONG NonResNameTableOffset;
    WORD  NumberOfMovableEntryPoints;
    WORD  ShiftCount;
    WORD  NumberOfResourceSegments;
    BYTE  TargetOS;
    BYTE  AdditionalInfo;
    WORD  FastLoadOffset;
    WORD  FastLoadSize;
    WORD  Reserved1;
    WORD  WinVersionExpected;
} NE_HEADER, *PNE_HEADER;

typedef struct _NE_SEGMENT_ENTRY {
    WORD  SegmentOffset;
    WORD  SegmentLen;
    WORD  SegmentFlags;
    WORD  SegMinAlloc;
} NE_SEGMENT_ENTRY, *PNE_SEGMENT_ENTRY;

typedef struct _NE_RELOC_ITEM {
    BYTE  AddressType;
    BYTE  RelocType;
    WORD  RelocOffset;
    WORD  ModuleOffset;
    WORD  FunctionOffset;
} NE_RELOC_ITEM, *PNE_RELOC_ITEM;

#define SEG_CODE_MASK                   0x0001
#define SEG_CODE                        0x0000
#define SEG_PRELOAD_MASK                0x0040
#define SEG_PRELOAD                     0x0040
#define SEG_RELOC_MASK                  0x0100
#define SEG_RELOC                       0x0100

#define RELOC_IMPORTED_ORDINAL          0x01
#define RELOC_IMPORTED_NAME             0x02
#define RELOC_ADDR_TYPE                 0x03

#pragma pack(pop)



typedef struct _IMPORT_ENUM32 {
    /*user area - BEGIN*/
    PCSTR ImportModule;
    PCSTR ImportFunction;
    ULONG ImportFunctionOrd;
    /*user area - END*/

    PLOADED_IMAGE Image;
    PIMAGE_IMPORT_DESCRIPTOR ImageDescriptor;
    DWORD ImportFunctionAddr;
    PIMAGE_THUNK_DATA ImageData;
    PIMAGE_IMPORT_BY_NAME ImageName;
} IMPORT_ENUM32, *PIMPORT_ENUM32;

typedef struct _IMPORT_ENUM16 {
    /*user area - BEGIN*/
    CHAR  ImportModule[MAX_MBCHAR_PATH];
    CHAR  ImportFunction[MAX_MBCHAR_PATH];
    ULONG ImportFunctionOrd;
    /*user area - END*/

    PCSTR Image;
    PDOS_HEADER DosHeader;
    PNE_HEADER NeHeader;
    PNE_SEGMENT_ENTRY SegmentEntry;
    WORD CurrSegEntry;
    PWORD CurrNrReloc;
    PNE_RELOC_ITEM RelocItem;
    WORD CurrRelocItem;
} IMPORT_ENUM16, *PIMPORT_ENUM16;

typedef struct _MODULE_IMAGE {
    UINT ModuleType;
    union {
        struct {
            LOADED_IMAGE Image;
        } W32Data;
        struct {
            PCSTR Image;
            HANDLE FileHandle;
            HANDLE MapHandle;
            NE_HEADER Neh;
        } W16Data;
    } ModuleData;
} MODULE_IMAGE, *PMODULE_IMAGE;

static CHAR g_TempKey[MEMDB_MAX];

#define CLEARBUFFER() g_TempKey[0] = 0
#define ISBUFFEREMPTY() (g_TempKey[0] == 0)


BOOL
LoadModuleData (
    IN      PCSTR ModuleName,
    IN OUT  PMODULE_IMAGE ModuleImage
    )
{
    HANDLE fileHandle;
    DWORD bytesRead;
    DOS_HEADER dh;
    DWORD sign;
    PWORD signNE = (PWORD)&sign;
    BOOL result = FALSE;

    ZeroMemory (ModuleImage, sizeof (MODULE_IMAGE));
    ModuleImage->ModuleType = UNKNOWN_MODULE;

    fileHandle = CreateFile (ModuleName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    __try {
        __try {
            if ((!ReadFile (fileHandle, &dh, sizeof (DOS_HEADER), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DOS_HEADER))
                ) {
                __leave;
            }
            result = TRUE;
            if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
                ModuleImage->ModuleType = UNKNOWN_MODULE;
                __leave;
            }
            ModuleImage->ModuleType = DOS_MODULE;

            if (SetFilePointer (fileHandle, dh.e_lfanew, NULL, FILE_BEGIN) != (DWORD)dh.e_lfanew) {
                __leave;
            }
            if ((!ReadFile (fileHandle, &sign, sizeof (DWORD), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DWORD))
                ) {
                __leave;
            }

            if (sign == IMAGE_PE_SIGNATURE) {
                ModuleImage->ModuleType = W32_MODULE;
                result = MapAndLoad ((PSTR)ModuleName, NULL, &ModuleImage->ModuleData.W32Data.Image, FALSE, TRUE);
            }
            if (*signNE == IMAGE_NE_SIGNATURE) {
                ModuleImage->ModuleType = W16_MODULE;
                ModuleImage->ModuleData.W16Data.Image = MapFileIntoMemory (
                                                            ModuleName,
                                                            &ModuleImage->ModuleData.W16Data.FileHandle,
                                                            &ModuleImage->ModuleData.W16Data.MapHandle
                                                            );
                if (SetFilePointer (fileHandle, dh.e_lfanew, NULL, FILE_BEGIN) != (DWORD)dh.e_lfanew) {
                    __leave;
                }
                if ((!ReadFile (fileHandle, &ModuleImage->ModuleData.W16Data.Neh, sizeof (NE_HEADER), &bytesRead, NULL)) ||
                    (bytesRead != sizeof (NE_HEADER))
                    ) {
                    __leave;
                }
                MYASSERT (ModuleImage->ModuleData.W16Data.Neh.Magic == IMAGE_NE_SIGNATURE);
                result = (ModuleImage->ModuleData.W16Data.Image != NULL);
            }
        }
        __finally {
            if (fileHandle != INVALID_HANDLE_VALUE) {
                CloseHandle (fileHandle);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        CloseHandle (fileHandle);
    }
    return result;
}

BOOL
UnloadModuleData (
    IN OUT  PMODULE_IMAGE ModuleImage
    )
{
    switch (ModuleImage->ModuleType) {
    case W32_MODULE:
        UnMapAndLoad (&ModuleImage->ModuleData.W32Data.Image);
        break;
    case W16_MODULE:
        UnmapFile (
            (PVOID) ModuleImage->ModuleData.W16Data.Image,
            ModuleImage->ModuleData.W16Data.FileHandle,
            ModuleImage->ModuleData.W16Data.MapHandle
            );
        break;
    default:;
    }
    return TRUE;
}


DWORD
GetExeType (
    IN      PCTSTR ModuleName
    )
{
    MODULE_IMAGE moduleImage;
    DWORD result = EXE_UNKNOWN;
    DWORD d;

    __try {
        if (!LoadModuleData (ModuleName, &moduleImage)) {
            LOG ((LOG_WARNING, DBG_MODULES":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        if (moduleImage.ModuleType == W32_MODULE) {
            d = moduleImage.ModuleData.W32Data.Image.Characteristics;
            result = (d & IMAGE_FILE_DLL) ? EXE_WIN32_DLL : EXE_WIN32_APP;
        } else if (moduleImage.ModuleType == W16_MODULE) {
            result = (moduleImage.ModuleData.W16Data.Neh.Flags & WIN16_LIBRARY) ? EXE_WIN16_DLL : EXE_WIN16_APP;
        }
    }
    __finally {
        UnloadModuleData (&moduleImage);
    }

    return result;
}


BOOL
IsNtCompatibleModule (
    IN      PCTSTR ModuleName
    )
{
    if (CheckModule (ModuleName, NULL) == MODULESTATUS_BAD) {
        return FALSE;
    }

    //
    // other tests?
    //
    return TRUE;
}

PTSTR
pBuildModulePaths (
    IN      PCTSTR ModuleName,
    IN      PCTSTR AppPaths              OPTIONAL
    )
{
    PTSTR currentPaths;
    HKEY appPathsKey, currentAppKey;
    REGKEY_ENUM appPathsEnum;
    PCTSTR appPathsValue;
    PTSTR appPathValueExp;
    PATH_ENUM pathEnum;
    DWORD attrib;
    PTSTR pathsPtr;
    TCHAR modulePath[MAX_PATH];
    BOOL b;

    StringCopy (modulePath, ModuleName);
    pathsPtr = (PTSTR)GetFileNameFromPath (modulePath);
    MYASSERT (pathsPtr && *(pathsPtr - 1) == TEXT('\\'));
    *(pathsPtr - 1) = 0;

    if (AppPaths) {
        currentPaths = DuplicateText (AppPaths);
        b = FALSE;
        if (EnumFirstPathEx (&pathEnum, currentPaths, NULL, NULL, FALSE)) {
            do {
                if (StringIMatch (pathEnum.PtrCurrPath, modulePath)) {
                    b = TRUE;
                    break;
                }
            } while (EnumNextPath (&pathEnum));
        }

        if (!b) {
            pathsPtr = JoinTextEx (NULL, modulePath, currentPaths, ";", 0, NULL);
            FreeText (currentPaths);
            currentPaths = pathsPtr;
        }
    } else {
        currentPaths = DuplicateText (modulePath);
    }

    appPathsKey = OpenRegKeyStr (S_SKEY_APP_PATHS);
    if (appPathsKey != NULL) {
        currentAppKey = OpenRegKey (appPathsKey, GetFileNameFromPath (ModuleName));
        if (currentAppKey != NULL) {

            appPathsValue = GetRegValueString (currentAppKey, TEXT("Path"));

            if (appPathsValue) {

                if (EnumFirstPathEx (&pathEnum, appPathsValue, NULL, NULL, FALSE)) {
                    do {
                        MYASSERT (*pathEnum.PtrCurrPath != 0);
                        appPathValueExp = ExpandEnvironmentTextA(pathEnum.PtrCurrPath);

                        _mbsctrim (appPathValueExp, '\\');

                        attrib = QuietGetFileAttributes (appPathValueExp);

                        if ((attrib != INVALID_ATTRIBUTES) &&
                            ((attrib & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY)
                            ) {
                            continue;
                        }

                        pathsPtr = JoinTextEx (NULL, currentPaths, appPathValueExp, ";", 0, NULL);
                        FreeText (currentPaths);
                        currentPaths = pathsPtr;

                        FreeText (appPathValueExp);
                    }
                    while (EnumNextPath (&pathEnum));
                }

                MemFree (g_hHeap, 0, appPathsValue);
            }

            appPathsValue = GetRegValueString (currentAppKey, TEXT("UpdatesPath"));

            if (appPathsValue) {

                if (EnumFirstPathEx (&pathEnum, appPathsValue, NULL, NULL, FALSE)) {
                    do {
                        MYASSERT (*pathEnum.PtrCurrPath != 0);
                        appPathValueExp = ExpandEnvironmentTextA(pathEnum.PtrCurrPath);

                        _mbsctrim (appPathValueExp, '\\');

                        attrib = QuietGetFileAttributes (appPathValueExp);

                        if ((attrib != INVALID_ATTRIBUTES) &&
                            ((attrib & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY)
                            ) {
                            continue;
                        }

                        pathsPtr = JoinTextEx (NULL, currentPaths, appPathValueExp, ";", 0, NULL);
                        FreeText (currentPaths);
                        currentPaths = pathsPtr;

                        FreeText (appPathValueExp);
                    }
                    while (EnumNextPath (&pathEnum));
                }

                MemFree (g_hHeap, 0, appPathsValue);
            }

            CloseRegKey (currentAppKey);
        }
        CloseRegKey (appPathsKey);
    }

    return currentPaths;
}

BOOL
EnumNextImport16 (
    IN OUT  PIMPORT_ENUM16 ModuleImports
    )
{
    PCSTR currSegmentOffset,importPtr;
    PWORD moduleNameOffset;
    BOOL itemFound;

    ModuleImports->RelocItem ++;
    ModuleImports->CurrRelocItem ++;

    itemFound = FALSE;

    while ((ModuleImports->CurrSegEntry <= ModuleImports->NeHeader->NumEntriesSegTable) && (!itemFound)) {

        if (((ModuleImports->SegmentEntry->SegmentFlags & SEG_CODE_MASK   ) == SEG_CODE   ) &&
            ((ModuleImports->SegmentEntry->SegmentFlags & SEG_RELOC_MASK  ) == SEG_RELOC  ) &&
            ((ModuleImports->SegmentEntry->SegmentFlags & SEG_PRELOAD_MASK) == SEG_PRELOAD)
           ) {
            __try {

                while ((ModuleImports->CurrRelocItem <= *(ModuleImports->CurrNrReloc)) && (!itemFound)) {

                    if (((ModuleImports->RelocItem->AddressType ==  0) ||
                         (ModuleImports->RelocItem->AddressType ==  2) ||
                         (ModuleImports->RelocItem->AddressType ==  3) ||
                         (ModuleImports->RelocItem->AddressType ==  5) ||
                         (ModuleImports->RelocItem->AddressType == 11) ||
                         (ModuleImports->RelocItem->AddressType == 13)
                        ) &&
                        ((ModuleImports->RelocItem->RelocType == RELOC_IMPORTED_ORDINAL) ||
                         (ModuleImports->RelocItem->RelocType == RELOC_IMPORTED_NAME   )
                        )
                       ) {
                        itemFound = TRUE;
                        moduleNameOffset = (PWORD) (ModuleImports->Image +
                                                    ModuleImports->DosHeader->e_lfanew +
                                                    ModuleImports->NeHeader->ModuleTableOffset +
                                                    (ModuleImports->RelocItem->ModuleOffset - 1) * sizeof (WORD));
                        importPtr = ModuleImports->Image +
                                    ModuleImports->DosHeader->e_lfanew +
                                    ModuleImports->NeHeader->ImportedTableOffset +
                                    *moduleNameOffset;
                        strncpy (ModuleImports->ImportModule, importPtr + 1, (BYTE)importPtr[0]);
                        ModuleImports->ImportModule[(BYTE)importPtr[0]] = 0;

                        if (ModuleImports->RelocItem->RelocType == RELOC_IMPORTED_ORDINAL) {
                            ModuleImports->ImportFunction[0] = 0;
                            ModuleImports->ImportFunctionOrd = ModuleImports->RelocItem->FunctionOffset;
                        }
                        else {
                            importPtr = ModuleImports->Image +
                                        ModuleImports->DosHeader->e_lfanew +
                                        ModuleImports->NeHeader->ImportedTableOffset +
                                        ModuleImports->RelocItem->FunctionOffset;
                            strncpy (ModuleImports->ImportFunction, importPtr + 1, (BYTE)importPtr[0]);
                            ModuleImports->ImportFunction[(BYTE)importPtr[0]] = 0;
                            ModuleImports->ImportFunctionOrd = 0;
                        }
                    }

                    if (!itemFound) {
                        ModuleImports->RelocItem ++;
                        ModuleImports->CurrRelocItem ++;
                    }
                }
            }
            __except (1) {
                itemFound = FALSE;
            }
        }
        if (!itemFound) {
            ModuleImports->SegmentEntry ++;
            ModuleImports->CurrSegEntry ++;

            currSegmentOffset = ModuleImports->Image +
                                (ModuleImports->SegmentEntry->SegmentOffset << ModuleImports->NeHeader->ShiftCount);
            if (ModuleImports->SegmentEntry->SegmentLen == 0) {
                currSegmentOffset += 65535;
            }
            else {
                currSegmentOffset += ModuleImports->SegmentEntry->SegmentLen;
            }
            ModuleImports->CurrNrReloc = (PWORD) currSegmentOffset;
            currSegmentOffset += sizeof(WORD);

            ModuleImports->RelocItem = (PNE_RELOC_ITEM) currSegmentOffset;

            ModuleImports->CurrRelocItem = 1;
        }
    }
    return itemFound;
}


BOOL
EnumFirstImport16 (
    IN      PCSTR ModuleImage,
    IN OUT  PIMPORT_ENUM16 ModuleImports
    )
{
    PCSTR currSegmentOffset;

    ZeroMemory (ModuleImports, sizeof (IMPORT_ENUM16));

    ModuleImports->Image = ModuleImage;

    ModuleImports->DosHeader = (PDOS_HEADER) (ModuleImports->Image);
    ModuleImports->NeHeader = (PNE_HEADER) (ModuleImports->Image + ModuleImports->DosHeader->e_lfanew);

    ModuleImports->SegmentEntry = (PNE_SEGMENT_ENTRY) (ModuleImports->Image +
                                                       ModuleImports->DosHeader->e_lfanew +
                                                       ModuleImports->NeHeader->SegTableOffset
                                                       );
    ModuleImports->CurrSegEntry = 1;

    currSegmentOffset = ModuleImports->Image +
                        (ModuleImports->SegmentEntry->SegmentOffset << ModuleImports->NeHeader->ShiftCount);
    if (ModuleImports->SegmentEntry->SegmentLen == 0) {
        currSegmentOffset += 65535;
    }
    else {
        currSegmentOffset += ModuleImports->SegmentEntry->SegmentLen;
    }
    ModuleImports->CurrNrReloc = (PWORD) currSegmentOffset;
    currSegmentOffset += sizeof(WORD);

    ModuleImports->RelocItem = (PNE_RELOC_ITEM) currSegmentOffset;

    ModuleImports->CurrRelocItem = 1;

    ModuleImports->RelocItem --;
    ModuleImports->CurrRelocItem --;

    return EnumNextImport16 (ModuleImports);
}

BOOL
EnumNextImportFunction32 (
    IN OUT  PIMPORT_ENUM32 ModuleImports
    )
{
    if (ModuleImports->ImportFunctionAddr == 0) {
        return FALSE;
    }
    ModuleImports->ImageData = (PIMAGE_THUNK_DATA)
                                    ImageRvaToVa (
                                        ModuleImports->Image->FileHeader,
                                        ModuleImports->Image->MappedAddress,
                                        ModuleImports->ImportFunctionAddr,
                                        NULL
                                        );

    if (ModuleImports->ImageData->u1.AddressOfData) {
        ModuleImports->ImageName = (PIMAGE_IMPORT_BY_NAME)
                                        ImageRvaToVa (
                                            ModuleImports->Image->FileHeader,
                                            ModuleImports->Image->MappedAddress,
                                            (DWORD)ModuleImports->ImageData->u1.AddressOfData,
                                            NULL
                                            );

        if (ModuleImports->ImageName) {    //import by name

            ModuleImports->ImportFunction = ModuleImports->ImageName->Name;
            ModuleImports->ImportFunctionOrd = 0;
        }
        else {  //import by number

            ModuleImports->ImportFunction = NULL;
            ModuleImports->ImportFunctionOrd = ModuleImports->ImageData->u1.Ordinal & (~0x80000000);
        }
        ModuleImports->ImportFunctionAddr += 4;
        return TRUE;
    }
    else {
        ModuleImports->ImportFunctionAddr = 0;
        return FALSE;
    }
}

BOOL
EnumFirstImportFunction32 (
    IN OUT  PIMPORT_ENUM32 ModuleImports
    )
{
    if ((ModuleImports->ImageDescriptor == NULL) ||
        (ModuleImports->ImportModule == NULL)
        ) {
        return FALSE;
    }
    ModuleImports->ImportFunctionAddr = ModuleImports->ImageDescriptor->OriginalFirstThunk;

    return EnumNextImportFunction32 (ModuleImports);
}

BOOL
EnumNextImportModule32 (
    IN OUT  PIMPORT_ENUM32 ModuleImports
    )
{
    if (ModuleImports->ImageDescriptor == NULL) {
        return FALSE;
    }

    ModuleImports->ImageDescriptor ++;

    if (ModuleImports->ImageDescriptor->Name == 0) {
        return FALSE;
    }
    ModuleImports->ImportModule = (PCSTR) ImageRvaToVa (
                                            ModuleImports->Image->FileHeader,
                                            ModuleImports->Image->MappedAddress,
                                            ModuleImports->ImageDescriptor->Name,
                                            NULL
                                            );
    return (ModuleImports->ImportModule != NULL);
}

BOOL
EnumFirstImportModule32 (
    IN      PLOADED_IMAGE ModuleImage,
    IN OUT  PIMPORT_ENUM32 ModuleImports
    )
{
    ULONG imageSize;

    ZeroMemory (ModuleImports, sizeof (IMPORT_ENUM32));

    ModuleImports->Image = ModuleImage;

    ModuleImports->ImageDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)
                                        ImageDirectoryEntryToData (
                                            ModuleImage->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                                            &imageSize
                                            );
    if (!ModuleImports->ImageDescriptor) {
        LOG((LOG_WARNING, DBG_MODULES":Cannot load import directory for %s", ModuleImage->ModuleName));
        return FALSE;
    }
    if (ModuleImports->ImageDescriptor->Name == 0) {
        return FALSE;
    }
    ModuleImports->ImportModule = (PCSTR) ImageRvaToVa (
                                            ModuleImports->Image->FileHeader,
                                            ModuleImports->Image->MappedAddress,
                                            ModuleImports->ImageDescriptor->Name,
                                            NULL
                                            );
    return (ModuleImports->ImportModule != NULL);
}


DWORD
pCheckDependency (
    IN      PCSTR CurrentPaths,
    IN      PCSTR ModuleImported)
{
    PSTR tempName = NULL;
    DWORD memDbValue = 0;
    PATH_ENUM pathEnum;
    DWORD result = MODULESTATUS_FILENOTFOUND;
    DWORD moduleStatus;

    pathEnum.BufferPtr = NULL;

    if (EnumFirstPath (&pathEnum, CurrentPaths, g_WinDir, g_SystemDir)) {
        __try {
            do {
                if (*pathEnum.PtrCurrPath == 0) {
                    continue;
                }

                tempName = JoinPathsA (pathEnum.PtrCurrPath, ModuleImported);
                if (SizeOfStringA (tempName) > MAX_PATH) {
                    //
                    // path too long, ignore it
                    //
                    FreePathStringA (tempName);
                    tempName = NULL;
                    continue;
                }


                MemDbBuildKey (g_TempKey, MEMDB_CATEGORY_MODULE_CHECK, tempName, NULL, NULL);
                if (MemDbGetValue (g_TempKey, &memDbValue)) {
                    if ((memDbValue == MODULESTATUS_CHECKED ) ||
                        (memDbValue == MODULESTATUS_CHECKING)) {
                        result = MODULESTATUS_CHECKED;
                        __leave;
                    }
                    if (memDbValue == MODULESTATUS_NT_MODULE){
                        result = MODULESTATUS_NT_MODULE;
                        __leave;
                    }
                }

                moduleStatus = GetFileStatusOnNt (tempName);

                if ((moduleStatus & FILESTATUS_DELETED) == 0) {
                    if ((moduleStatus & FILESTATUS_REPLACED) == FILESTATUS_REPLACED) {
                        result = MODULESTATUS_NT_MODULE;
                        __leave;
                    }
                    if (DoesFileExist (tempName)) {
                        result = CheckModule (tempName, CurrentPaths);
                        __leave;
                    }
                }
                if (moduleStatus & FILESTATUS_NTINSTALLED) {
                    result = MODULESTATUS_NT_MODULE;
                    __leave;
                }
            }
            while (EnumNextPath (&pathEnum));
        }
        __finally {
            EnumPathAbort (&pathEnum);
            if (tempName) {
                FreePathStringA (tempName);
            }
        }
    }

    return result;
}

BOOL
pIsWin9xModule (
    IN      PCTSTR ModuleName
    )
{
    MEMDB_ENUM me;
    MemDbBuildKey (g_TempKey, MEMDB_CATEGORY_WIN9X_APIS, ModuleName, TEXT("*"), NULL);
    return MemDbEnumFirstValue (&me, g_TempKey, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY);
}


DWORD
pCheckPEModule (
    IN      PCSTR CurrentPaths,
    IN      PLOADED_IMAGE ModuleImage
    )
{
    IMPORT_ENUM32 e;
    DWORD result;

    if (EnumFirstImportModule32 (ModuleImage, &e)) {
        do {
            result = pCheckDependency (CurrentPaths, e.ImportModule);
            if (result == MODULESTATUS_BAD) {
                LOG((
                    LOG_WARNING,
                    "%s will be incompatible because %s is incompatible",
                    ModuleImage->ModuleName,
                    e.ImportModule));
                return result;
            }

            if (result == MODULESTATUS_NT_MODULE) {

                if (pIsWin9xModule (e.ImportModule)) {

                    if (EnumFirstImportFunction32 (&e)) {
                        do {
                            if (e.ImportFunction) {

                                MemDbBuildKey (g_TempKey, MEMDB_CATEGORY_WIN9X_APIS, e.ImportModule, e.ImportFunction, NULL);
                                if (MemDbGetValue (g_TempKey, NULL)) {
                                    LOG((
                                        LOG_WARNING,
                                        "%s will be incompatible because %s export will not be available in %s",
                                        ModuleImage->ModuleName,
                                        e.ImportFunction,
                                        e.ImportModule));
                                    return MODULESTATUS_BAD;
                                }

                            }
                            else {
                                wsprintf (g_TempKey, "%s\\%s\\%lu", MEMDB_CATEGORY_WIN9X_APIS, e.ImportModule, e.ImportFunctionOrd);
                                if (MemDbGetValue (g_TempKey, NULL)) {
                                    LOG((
                                        LOG_WARNING,
                                        "%s will be incompatible because export index %lu will point to a different export in %s",
                                        ModuleImage->ModuleName,
                                        e.ImportFunctionOrd,
                                        e.ImportModule));
                                    return MODULESTATUS_BAD;
                                }
                            }
                        }
                        while (EnumNextImportFunction32 (&e));
                    }
                }
            }

            if (result == MODULESTATUS_FILENOTFOUND) {
                LOG ((
                    LOG_WARNING,
                    "Dependency %s of %s not found",
                    e.ImportModule,
                    ModuleImage->ModuleName
                    ));
            }
        }
        while (EnumNextImportModule32 (&e));
    }
    return MODULESTATUS_CHECKED;
}

DWORD
pCheckDependency16 (
    IN      PCSTR CurrentPaths,
    IN OUT  PCSTR ModuleImported
    )
{
    PCTSTR moduleImported;
    DWORD result = MODULESTATUS_BAD;
    DWORD memDbValue;

    MemDbBuildKey (g_TempKey, MEMDB_CATEGORY_MODULE_CHECK, ModuleImported, NULL, NULL);
    if (MemDbGetValue (g_TempKey, &memDbValue)) {
        if ((memDbValue == MODULESTATUS_CHECKED ) ||
            (memDbValue == MODULESTATUS_CHECKING)) {
            result = MODULESTATUS_CHECKED;
        }
        if (memDbValue == MODULESTATUS_NT_MODULE){
            result = MODULESTATUS_NT_MODULE;
        }
    }

    if (result != MODULESTATUS_BAD) {
        return result;
    }

    moduleImported = JoinText (ModuleImported, ".DLL");
    result = pCheckDependency (CurrentPaths, moduleImported);
    FreeText (moduleImported);

    if (result != MODULESTATUS_BAD) {
        return result;
    }

    moduleImported = JoinText (ModuleImported, ".EXE");
    result = pCheckDependency (CurrentPaths, moduleImported);
    FreeText (moduleImported);

    if (result != MODULESTATUS_BAD) {
        return result;
    }

    moduleImported = JoinText (ModuleImported, ".DRV");
    result = pCheckDependency (CurrentPaths, moduleImported);
    FreeText (moduleImported);

    if (result != MODULESTATUS_BAD) {
        return result;
    }
    return result;
}

DWORD
pCheckNEModule (
    IN      PCSTR CurrentPaths,
    IN      PCSTR ModuleName,
    IN      PCSTR ModuleImage
    )
{
    IMPORT_ENUM16 e;
    DWORD result;
    DWORD memDbValue;

    if (EnumFirstImport16 (ModuleImage, &e)) {
        do {
            if (e.ImportModule [0] != 0) {
                result = pCheckDependency16 (CurrentPaths, e.ImportModule);
                if (result == MODULESTATUS_BAD) {
                    LOG((
                        LOG_WARNING,
                        "%s will be incompatible because %s is incompatible",
                        ModuleName,
                        e.ImportModule));
                    return result;
                }
                if (result == MODULESTATUS_NT_MODULE) {

                    if (e.ImportFunctionOrd) {
                        //import by ordinal
                        wsprintf (g_TempKey, "%s\\%s\\%lu", MEMDB_CATEGORY_WIN9X_APIS, e.ImportModule, e.ImportFunctionOrd);
                        if (MemDbGetValue (g_TempKey, NULL)) {
                            LOG((
                                LOG_WARNING,
                                "%s will be incompatible because export index %lu will point to a different export in %s",
                                ModuleName,
                                e.ImportFunctionOrd,
                                e.ImportModule));
                            return MODULESTATUS_BAD;
                        }
                    }
                    else {
                        //import by name
                        MemDbBuildKey (g_TempKey, MEMDB_CATEGORY_WIN9X_APIS, e.ImportModule, e.ImportFunction, NULL);
                        if (MemDbGetValue (g_TempKey, &memDbValue)) {
                            LOG((
                                LOG_WARNING,
                                "%s will be incompatible because %s export will not be available in %s",
                                ModuleName,
                                e.ImportFunction,
                                e.ImportModule));
                            return MODULESTATUS_BAD;
                        }
                    }
                }
            }
        }
        while (EnumNextImport16 (&e));
    }
    return MODULESTATUS_CHECKED;
}

DWORD
pCheckModule (
    IN      PCSTR ModuleName,
    IN      PCSTR AppPaths              OPTIONAL
    )
{
    MODULE_IMAGE moduleImage;
    DWORD result = MODULESTATUS_CHECKED;
    PTSTR CurrentPaths = NULL;

    __try {
        if (!LoadModuleData (ModuleName, &moduleImage)) {
            LOG((LOG_WARNING, DBG_MODULES":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        __try {

            CurrentPaths = pBuildModulePaths (ModuleName, AppPaths);

            switch (moduleImage.ModuleType) {
            case DOS_MODULE:
                DEBUGMSG((DBG_MODULES, "Examining %s : DOS module.", ModuleName));
                break;
            case W16_MODULE:
                DEBUGMSG((DBG_MODULES, "Examining %s : W16 module.", ModuleName));
                result = pCheckNEModule (CurrentPaths, ModuleName, moduleImage.ModuleData.W16Data.Image);
                break;
            case W32_MODULE:
                DEBUGMSG((DBG_MODULES, "Examining %s : W32 module.", ModuleName));
                result = pCheckPEModule (CurrentPaths, &moduleImage.ModuleData.W32Data.Image);
                break;
            default:
                DEBUGMSG((DBG_MODULES, "Examining %s : Unknown module type.", ModuleName));
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            DWORD rc = _exception_code();
            DEBUGMSG((DBG_WARNING, DBG_MODULES":Access violation while checking %s (ec=%#x)", ModuleName, rc));
            result = MODULESTATUS_CHECKED;
        }
    }
    __finally {
        UnloadModuleData (&moduleImage);
        if (CurrentPaths) {
            FreeText (CurrentPaths);
        }
    }
    return result;
}


DWORD
GetModuleType (
    IN      PCSTR ModuleName
    )
{
    MODULE_IMAGE moduleImage;
    DWORD result = UNKNOWN_MODULE;

    __try {
        if (!LoadModuleData (ModuleName, &moduleImage)) {
            LOG((LOG_WARNING, DBG_MODULES":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        result = moduleImage.ModuleType;
    }
    __finally {
        UnloadModuleData (&moduleImage);
    }
    return result;
}


PCSTR
Get16ModuleDescription (
    IN      PCSTR ModuleName
    )
{
    MODULE_IMAGE moduleImage;
    PSTR result = NULL;

    PDOS_HEADER dosHeader;
    PNE_HEADER  neHeader;
    PBYTE size;

    __try {
        if (!LoadModuleData (ModuleName, &moduleImage)) {
            LOG((LOG_WARNING, DBG_MODULES":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        if (moduleImage.ModuleType != W16_MODULE) {
            __leave;
        }
        __try {
            dosHeader = (PDOS_HEADER) (moduleImage.ModuleData.W16Data.Image);
            neHeader  = (PNE_HEADER)  (moduleImage.ModuleData.W16Data.Image + dosHeader->e_lfanew);
            size = (PBYTE) (moduleImage.ModuleData.W16Data.Image + neHeader->NonResNameTableOffset);
            if (*size == 0) {
                __leave;
            }
            result = AllocPathString (*size + 1);
            strncpy (result, moduleImage.ModuleData.W16Data.Image + neHeader->NonResNameTableOffset + 1, *size);
            result [*size] = 0;
        }
        __except (1) {
            DEBUGMSG((DBG_WARNING, DBG_MODULES":Access violation while examining %s.", ModuleName));
            if (result != NULL) {
                FreePathString (result);
                result = NULL;
            }
            __leave;
        }
    }
    __finally {
        UnloadModuleData (&moduleImage);
    }
    return result;
}

PIMAGE_NT_HEADERS
pGetImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);
            if (NtHeaders->Signature == IMAGE_NT_SIGNATURE) {
                return NtHeaders;
            }
        }
    }
    return NULL;
}

ULONG
GetPECheckSum (
    IN      PCSTR ModuleName
    )
{
    MODULE_IMAGE moduleImage;
    ULONG result = 0;
    PIMAGE_NT_HEADERS NtHeaders;

    __try {
        if (!LoadModuleData (ModuleName, &moduleImage)) {
            LOG((LOG_WARNING, DBG_MODULES":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        if (moduleImage.ModuleType != W32_MODULE) {
            __leave;
        }
        __try {
            NtHeaders = pGetImageNtHeader(moduleImage.ModuleData.W32Data.Image.MappedAddress);
            if (NtHeaders) {
                if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                    result = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum;
                } else
                if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                    result = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum;
                }
            }
        }
        __except (1) {
            DEBUGMSG((DBG_WARNING, DBG_MODULES":Access violation while examining %s.", ModuleName));
            result = 0;
            __leave;
        }
    }
    __finally {
        UnloadModuleData (&moduleImage);
    }
    return result;
}


DWORD
CheckModule (
    IN      PCSTR ModuleName,
    IN      PCSTR AppPaths              OPTIONAL
    )
{
    DWORD result;
    DWORD moduleStatus;

    MemDbSetValueEx (MEMDB_CATEGORY_MODULE_CHECK, ModuleName, NULL, NULL, MODULESTATUS_CHECKING, NULL);

    g_ModuleRecursionLevel++;

    if (g_ModuleRecursionLevel < MAX_MODULE_RECURSION_LEVEL) {

        result = pCheckModule (ModuleName, AppPaths);

        if (result == MODULESTATUS_BAD) {

            moduleStatus = GetFileStatusOnNt (ModuleName);

            if ((moduleStatus & FILESTATUS_NTINSTALLED) == FILESTATUS_NTINSTALLED) {
                MarkFileForDelete (ModuleName);
                result = MODULESTATUS_NT_MODULE;
            }
        }
    } else {
        result = MODULESTATUS_CHECKED;
    }

    g_ModuleRecursionLevel--;

    MemDbSetValueEx (MEMDB_CATEGORY_MODULE_CHECK, ModuleName, NULL, NULL, result, NULL);

    return result;
}

BOOL
pProcessModules (
    VOID
    )
{
    MEMDB_ENUM enumItems;
    PSTR pathsPtr;
    DWORD moduleStatus;

    DWORD attrib;
    LONG stringId;
    DWORD status;
    DWORD Count  = 0;

    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("KERNEL32"),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("KERNEL"  ),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("USER32"  ),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("USER"    ),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("GDI32"   ),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("GDI"     ),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("SHELL32" ),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("SHELL"   ),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("SOUND32" ),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("SOUND"   ),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("DISPLAY" ),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);
    MemDbSetValueEx(MEMDB_CATEGORY_MODULE_CHECK,TEXT("KEYBOARD"),NULL,NULL,MODULESTATUS_NT_MODULE,NULL);

    MemDbBuildKey (g_TempKey, MEMDB_CATEGORY_MODULE_CHECK, TEXT("*"), NULL, NULL);

    if (MemDbEnumFirstValue (&enumItems, g_TempKey, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {

            if (CANCELLED()) {
                SetLastError (ERROR_CANCELLED);
                return FALSE;
            }

            #ifdef DEBUG
            {
                CHAR DbgBuf[256];

                if (GetPrivateProfileString ("MigDb", GetFileNameFromPath (enumItems.szName), "", DbgBuf, 256, g_DebugInfPath)) {
                    DEBUGMSG((DBG_NAUSEA, "Debug point hit in Modules.c"));
                }
            }
            #endif

            if (enumItems.dwValue == MODULESTATUS_UNCHECKED) {

                moduleStatus = GetFileStatusOnNt (enumItems.szName);

                if ((moduleStatus & FILESTATUS_DELETED) == FILESTATUS_DELETED) {
                    continue;
                }
                if ((moduleStatus & FILESTATUS_REPLACED) == FILESTATUS_REPLACED) {
                    continue;
                }

                g_ModuleRecursionLevel = 0;

                moduleStatus = CheckModule (enumItems.szName, NULL);

                if (moduleStatus == MODULESTATUS_BAD) {

                    status = GetFileStatusOnNt (enumItems.szName);

                    if (!(status & FILESTATUS_DELETED)) {
                        RemoveOperationsFromPath (enumItems.szName, ALL_CHANGE_OPERATIONS);
                        MarkFileForExternalDelete (enumItems.szName);
                    }

                    if (!IsFileMarkedForAnnounce (enumItems.szName)) {
                        AnnounceFileInReport (enumItems.szName, 0, ACT_INC_NOBADAPPS);
                    }
                    LOG ((LOG_INFORMATION, (PCSTR)MSG_MODULE_REQUIRES_EXPORT_LOG, enumItems.szName));
                }
            }
            Count++;
            if (!(Count % 4)) {
                TickProgressBar ();
            }
        }
        while (MemDbEnumNextValue (&enumItems));
    }

    DEBUGMSG((DBG_MODULES, "Modules checking : ==========================="));
    DEBUGMSG((DBG_MODULES, "Number of executables checked  : %ld", g_NumEXEs));
    DEBUGMSG((DBG_MODULES, "Number of modules in MEMDB tree: %ld", Count));

    MemDbDeleteTree (MEMDB_CATEGORY_MODULE_CHECK);

    return TRUE;
}


DWORD
ProcessModules (
    IN     DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_PROCESS_MODULES;
    case REQUEST_RUN:
        if (!pProcessModules ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in ProcessModules"));
    }
    return 0;
}


BOOL
pPrepareProcessModules (
    VOID
    )
{
    PCTSTR TempStr;

    TempStr = JoinPaths (g_UpgradeSources, S_E95ONLY_DAT);

    MemDbImport (TempStr);

    FreePathString (TempStr);

    return TRUE;
}

DWORD
PrepareProcessModules (
    IN     DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_PREPARE_PROCESS_MODULES;
    case REQUEST_RUN:
        if (!pPrepareProcessModules ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in PrepareProcessModules"));
    }
    return 0;
}


BOOL
SaveExeFiles (
    IN PFILE_HELPER_PARAMS Params
    )
{
    if (Params->Handled) {
        return TRUE;
    }

    // Save EXE and SCR files to MemDB to enumerate later
    if ((StringIMatch (Params->Extension, TEXT(".EXE"))) ||
        (StringIMatch (Params->Extension, TEXT(".SCR")))
        ) {
        if (!IsFileMarkedAsKnownGood (Params->FullFileSpec)) {
            MemDbSetValueEx (
                MEMDB_CATEGORY_MODULE_CHECK,
                Params->FullFileSpec,
                NULL,
                NULL,
                MODULESTATUS_UNCHECKED,
                NULL);

#ifdef DEBUG
            g_NumEXEs++;
#endif
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\pch\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migapp\migdb.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migdb.c

Abstract:

    This source implements old AppDb functionality

Author:

    Calin Negreanu (calinn) 07-Jan-1998

Revision History:

    jimschm     23-Sep-1998 Updated for new fileops code
    jimschm     25-Feb-1998 Added UninstallSection support
    calinn      19-Jan-1998 Added CANCELLED response

--*/

#include "pch.h"
#include "migdbp.h"
#include "migappp.h"

// #define _OLDAPPDB
#define DBG_MIGDB           "MigDb"

//
// Globals
//

POOLHANDLE g_MigDbPool;
PMIGDB_CONTEXT g_ContextList;
HASHTABLE g_FileTable;
HINF g_MigDbInf = INVALID_HANDLE_VALUE;
INT g_RegKeyPresentIndex;

static PINFCONTEXT g_Line;
PMIGDB_HOOK_PROTOTYPE g_MigDbHook;

typedef LONG (CPL_PROTOTYPE) (HWND hwndCPl, UINT uMsg, LONG lParam1, LONG lParam2);
typedef CPL_PROTOTYPE * PCPL_PROTOTYPE;


#define ArgFunction     TEXT("ARG")
#define ArgFunctionLen  3


BOOL
pCallAction (
    IN      PMIGDB_CONTEXT MigDbContext
    );

PMIGDB_HOOK_PROTOTYPE
SetMigDbHook (
    PMIGDB_HOOK_PROTOTYPE HookFunction
    )
{
    PMIGDB_HOOK_PROTOTYPE savedHook;

    savedHook = g_MigDbHook;
    g_MigDbHook = HookFunction;
    return savedHook;
}


INT
pGetAttribIndex (
    IN      PCSTR AttribName
    )

/*++

Routine Description:

  This routine returns the index in attribute functions array for a specified attribute.

Arguments:

  AttribName - Attribute name

Return value:

  -1 - no such attribute in attribute table

--*/

{
    INT attribIndex;
    INT rc = 0;
    PSTR attrEnd = NULL;
    CHAR savedChar = 0;

    attrEnd = (PSTR)SkipSpaceR (AttribName, GetEndOfStringA (AttribName));
    if (attrEnd != NULL) {
        attrEnd = _mbsinc (attrEnd);
        savedChar = attrEnd [0];
        attrEnd [0] = 0;
    }
    __try {
        attribIndex = MigDb_GetAttributeIdx (AttribName);
        if (attribIndex == -1) {
            LOG((LOG_ERROR, "Attribute not found: %s", AttribName));
        }
        rc = attribIndex;
    }
    __finally {
        if (attrEnd != NULL) {
            attrEnd [0] = savedChar;
        }
    }

    return rc;
}

PMIGDB_REQ_FILE
pReadReqFiles (
    IN      PCSTR SectionName
    )
{
    INFCONTEXT context;
    CHAR fileName  [MEMDB_MAX];
    CHAR tempField [MEMDB_MAX];
    PMIGDB_REQ_FILE result = NULL;
    PMIGDB_REQ_FILE tmpResult = NULL;

    MYASSERT (g_MigDbInf != INVALID_HANDLE_VALUE);

    if (SetupFindFirstLine (g_MigDbInf, SectionName, NULL, &context)) {
        do {
            if (!SetupGetStringField (&context, 1, fileName, MEMDB_MAX, NULL)) {
                LOG ((LOG_ERROR, "Error while loading file name."));
                break;
            }
            tmpResult = (PMIGDB_REQ_FILE) PoolMemGetMemory (g_MigDbPool, sizeof (MIGDB_REQ_FILE));
            ZeroMemory (tmpResult, sizeof (MIGDB_REQ_FILE));
            tmpResult->Next = result;
            result = tmpResult;
            result->ReqFilePath = PoolMemDuplicateString (g_MigDbPool, fileName);
            if (SetupGetMultiSzField (&context, 2, tempField, MEMDB_MAX, NULL)) {
                result->FileAttribs = LoadAttribData (tempField, g_MigDbPool);
            }
        } while (SetupFindNextLine (&context, &context));
    }
    return result;
}


BOOL
pValidateArg (
    IN OUT  PMIGDB_ATTRIB AttribStruct
    )
{
    BOOL b;
    INT Index;
    PCSTR p;
    BOOL IsHkr;

    MYASSERT (AttribStruct);

    if (AttribStruct->ArgCount != MigDb_GetReqArgCount (AttribStruct->AttribIndex)) {

#ifdef DEBUG
        if (AttribStruct->AttribIndex != -1) {
            CHAR Buffer[16384];

            SetupGetLineText (g_Line, NULL, NULL, NULL, Buffer, ARRAYSIZE(Buffer), NULL);
            DEBUGMSG ((
                DBG_WHOOPS,
                "Discarding attribute %s because of too few arguments.\n"
                    "  Line: %s\n",
                MigDb_GetAttributeName (AttribStruct->AttribIndex),
                Buffer
                ));
        }
#endif

        AttribStruct->AttribIndex = -1;
        return FALSE;
    }

    //
    // HACK: If REGKEYPRESENT attrib with HKR, put in a special
    //       global list.
    //

    if (AttribStruct->AttribIndex == g_RegKeyPresentIndex) {
        //
        // Is this HKR?
        //

        Index = GetOffsetOfRootString (AttribStruct->Arguments, NULL);
        p = GetRootStringFromOffset (Index);

        if (!p) {
            DEBUGMSG ((DBG_WHOOPS, "RegKeyPresent: %s is not a valid key", AttribStruct->Arguments));
        } else {

            IsHkr = StringICompare (p, "HKR") || StringICompare (p, "HKEY_ROOT");

            if (IsHkr) {
                //
                // Yes, add full arg to the hash table
                //

                b = FALSE;
                HtAddStringAndData (
                    g_PerUserRegKeys,
                    AttribStruct->Arguments,
                    &b
                    );
            }
        }
    }

    return TRUE;
}


#define STATE_ATTRNAME  1
#define STATE_ATTRARG   2

PMIGDB_ATTRIB
LoadAttribData (
    IN      PCSTR MultiSzStr,
    IN      POOLHANDLE hPool
    )

/*++

Routine Description:

  This routine creates a list of MIGDB_ATTRIBs from a multisz.

Arguments:

  MultiSzStr - multisz to be processed

Return value:

  MIGDB_ATTRIB nodes

--*/

{
    MULTISZ_ENUM multiSzEnum;
    PMIGDB_ATTRIB result  = NULL;
    PMIGDB_ATTRIB tmpAttr = NULL;
    INT state = STATE_ATTRNAME;
    PSTR currStrPtr = NULL;
    PSTR currArgPtr = NULL;
    PSTR endArgPtr  = NULL;
    CHAR savedChar  = 0;
    GROWBUFFER argList = GROWBUF_INIT;

    if (EnumFirstMultiSz (&multiSzEnum, MultiSzStr)) {
        do {
            currStrPtr = (PSTR) SkipSpace (multiSzEnum.CurrentString);
            if (state == STATE_ATTRNAME) {
                tmpAttr = (PMIGDB_ATTRIB) PoolMemGetMemory (hPool, sizeof (MIGDB_ATTRIB));

                ZeroMemory (tmpAttr, sizeof (MIGDB_ATTRIB));

                if (_mbsnextc (currStrPtr) == '!') {
                    currStrPtr = _mbsinc (currStrPtr);
                    currStrPtr = (PSTR) SkipSpace (currStrPtr);
                    tmpAttr->NotOperator = TRUE;
                }

                currArgPtr = _mbschr (currStrPtr, '(');

                if (currArgPtr) {
                    endArgPtr = _mbsdec (currStrPtr, currArgPtr);
                    if (endArgPtr) {
                        endArgPtr = (PSTR) SkipSpaceR (currStrPtr, endArgPtr);
                        endArgPtr = _mbsinc (endArgPtr);
                    }
                    else {
                        endArgPtr = currStrPtr;
                    }
                    savedChar = *endArgPtr;
                    *endArgPtr = 0;
                    tmpAttr->AttribIndex = pGetAttribIndex (currStrPtr);
                    *endArgPtr = savedChar;
                    currStrPtr = _mbsinc (currArgPtr);
                    state = STATE_ATTRARG;
                }
                else {
                    // this attribute has no arguments.
                    tmpAttr->AttribIndex = pGetAttribIndex (currStrPtr);
                    tmpAttr->Next = result;
                    result = tmpAttr;

                    pValidateArg (result);
                    continue;
                }
            }
            if (state == STATE_ATTRARG) {
                currStrPtr = (PSTR) SkipSpace (currStrPtr);
                endArgPtr = _mbsrchr (currStrPtr, ')');
                if (endArgPtr) {
                    endArgPtr = _mbsdec (currStrPtr, endArgPtr);
                    if (endArgPtr) {
                        endArgPtr = (PSTR) SkipSpaceR (currStrPtr, endArgPtr);
                        endArgPtr = _mbsinc (endArgPtr);
                    }
                    else {
                        endArgPtr = currStrPtr;
                    }
                    savedChar = *endArgPtr;
                    *endArgPtr = 0;
                }

                MultiSzAppend (&argList, currStrPtr);

                tmpAttr->ArgCount++;

                if (endArgPtr) {
                    *endArgPtr = savedChar;
                    tmpAttr->Arguments = PoolMemDuplicateMultiSz (hPool, (PSTR)argList.Buf);
                    FreeGrowBuffer (&argList);
                    state = STATE_ATTRNAME;
                    tmpAttr->Next = result;
                    result = tmpAttr;

                    pValidateArg (result);
                }
            }
            if (state == STATE_ATTRNAME) {
                // we successfully parsed one attribute
                // we have a special case here (REQFILE attribute)
                if (StringIMatch (MigDb_GetAttributeName (result->AttribIndex), TEXT("ReqFile"))) {
                    // we found ReqFile attribute. For this attribute a field will point to a special structure
                    // of PMIGDB_REQ_FILE type
                    result->ExtraData = pReadReqFiles (result->Arguments);
                }
            }
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    return result;
}

VOID
FreeAttribData(
    IN      POOLHANDLE hPool,
    IN      PMIGDB_ATTRIB pData
    )
{
    while(pData){
        if(pData->Arguments){
            PoolMemReleaseMemory(hPool, (PVOID)pData->Arguments);
        }
        PoolMemReleaseMemory(hPool, pData);
        pData = pData->Next;
    }
}


BOOL
AddFileToMigDbLinkage (
    IN      PCTSTR FileName,
    IN      PINFCONTEXT Context,        OPTIONAL
    IN      DWORD FieldIndex            OPTIONAL
    )
{
    CHAR tempField [MEMDB_MAX];
    DWORD fieldIndex = FieldIndex;
    PMIGDB_FILE   migDbFile   = NULL;
    PMIGDB_ATTRIB migDbAttrib = NULL;
    HASHITEM stringId;
    FILE_LIST_STRUCT fileList;

    //creating MIGDB_FILE structure for current file
    migDbFile = (PMIGDB_FILE) PoolMemGetMemory (g_MigDbPool, sizeof (MIGDB_FILE));
    if (migDbFile != NULL) {
        ZeroMemory (migDbFile, sizeof (MIGDB_FILE));
        migDbFile->Section = g_ContextList->Sections;

        if (Context) {
            fieldIndex ++;

            if (SetupGetMultiSzField (Context, fieldIndex, tempField, MEMDB_MAX, NULL)) {

                g_Line = Context;
                migDbFile->Attributes = LoadAttribData (tempField, g_MigDbPool);

                if (g_MigDbHook != NULL) {
                    migDbAttrib = migDbFile->Attributes;
                    while (migDbAttrib) {
                        g_MigDbHook (FileName, g_ContextList, g_ContextList->Sections, migDbFile, migDbAttrib);
                        migDbAttrib = migDbAttrib->Next;
                    }
                }
            }
        }

        //adding this file into string table and create a MIGDB_FILE node. If file
        //already exists in string table then just create another MIGDB_FILE node
        //chained with already existing ones.
        stringId = HtFindString (g_FileTable, FileName);

        if (stringId) {
            HtCopyStringData (g_FileTable, stringId, &fileList);

            fileList.Last->Next = migDbFile;
            fileList.Last = migDbFile;

            HtSetStringData (g_FileTable, stringId, &fileList);

        } else {
            fileList.First = fileList.Last = migDbFile;
            HtAddStringAndData (g_FileTable, FileName, &fileList);
        }
    }

    return TRUE;
}


BOOL
pScanForFile (
    IN      PINFCONTEXT Context,
    IN      DWORD FieldIndex
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified file info from inf file.
  Creates a migdb file node and the file is added in a string table for fast query.

Arguments:

  SectionStr  - section to process

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    CHAR fileName  [MEMDB_MAX];

    if (CANCELLED()) {
        SetLastError (ERROR_CANCELLED);
        return FALSE;
    }
    //scanning for file name
    if (!SetupGetStringField (Context, FieldIndex, fileName, MEMDB_MAX, NULL)) {
        LOG ((LOG_ERROR, "Error while loading file name."));
        return FALSE;
    }

    return AddFileToMigDbLinkage (fileName, Context, FieldIndex);
}


/*++

Routine Description:

  The subsequent two routines enumerate the sections with a particular name and
  with .999 extension from an inf file.

Arguments:

  SectEnum  - enumeration structure

Return value:

  TRUE  - enumeration continues
  FALSE - enumeration ended

--*/

typedef struct _SECT_ENUM {
    HINF InfHandle;
    INT  SectIndex;
    PSTR SectNameEnd;
    CHAR SectName [MAX_PATH];
} SECT_ENUM, *PSECT_ENUM;


BOOL
pEnumNextSection (
    IN OUT  PSECT_ENUM SectEnum
    )
{
    INFCONTEXT context;

    if (SectEnum->SectIndex == -1) {
        return FALSE;
    }
    SectEnum->SectIndex ++;
    sprintf (SectEnum->SectNameEnd, ".%d", SectEnum->SectIndex);
    return SetupFindFirstLine (SectEnum->InfHandle, SectEnum->SectName, NULL, &context);
}


BOOL
pEnumFirstSection (
    OUT     PSECT_ENUM SectEnum,
    IN      PCSTR SectionStr,
    IN      HINF InfHandle
    )
{
    INFCONTEXT context;

    SectEnum->SectIndex = -1;
    SectEnum->InfHandle = InfHandle;
    StringCopyA (SectEnum->SectName, SectionStr);
    SectEnum->SectNameEnd = GetEndOfStringA (SectEnum->SectName);
    if (SetupFindFirstLine (SectEnum->InfHandle, SectEnum->SectName, NULL, &context)) {
        //good, only one section
        return TRUE;
    }
    else {
        //more than one section
        SectEnum->SectIndex = 0;
        return pEnumNextSection (SectEnum);
    }
}


BOOL
pLoadSectionData (
    IN      PCSTR SectionStr
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified section from inf file. For
  every line in the section there is a migdb file node created. Also the file is added in
  a string table for fast query.

Arguments:

  SectionStr  - section to process

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    INFCONTEXT context;
    SECT_ENUM sectEnum;
    PMIGDB_SECTION migDbSection;
    BOOL result = TRUE;

    if (CANCELLED()) {
        SetLastError (ERROR_CANCELLED);
        return FALSE;
    }

    MYASSERT (g_MigDbInf != INVALID_HANDLE_VALUE);

    if (pEnumFirstSection (&sectEnum, SectionStr, g_MigDbInf)) {
        do {
            //initialize the section (this context can have multiple sections)
            //and parse the file info
            migDbSection = (PMIGDB_SECTION) PoolMemGetMemory (g_MigDbPool, sizeof (MIGDB_SECTION));
            if (migDbSection != NULL) {

                ZeroMemory (migDbSection, sizeof (MIGDB_SECTION));
                migDbSection->Context = g_ContextList;
                migDbSection->Next = g_ContextList->Sections;
                g_ContextList->Sections = migDbSection;
                if (SetupFindFirstLine (g_MigDbInf, sectEnum.SectName, NULL, &context)) {
                    do {
                        if (!pScanForFile (&context, 1)) {
                            return FALSE;
                        }
                    }
                    while (SetupFindNextLine (&context, &context));
                }
            }
            else {
                LOG ((LOG_ERROR, "Unable to create section for %s", SectionStr));
            }
        }
        while (pEnumNextSection (&sectEnum));
    }
    return result;
}

BOOL
pLoadTypeData (
    IN      PCSTR TypeStr
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified type data from inf file. For
  every line in type section there is a migdb context created. Also for every migdb context
  the coresponding section(s) is processed.

Arguments:

  TypeStr     - file type to process

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    CHAR section [MEMDB_MAX];
    CHAR locSection [MEMDB_MAX];
    CHAR message [MEMDB_MAX];
    CHAR tempField [MEMDB_MAX];
    PSTR tempFieldPtr;
    PSTR endOfArg  = NULL;
    DWORD fieldIndex;
    PMIGDB_CONTEXT migDbContext = NULL;
    INFCONTEXT context, context1;
    BOOL result = TRUE;
    INT actionIndex;
    GROWBUFFER argList = GROWBUF_INIT;

    if (CANCELLED()) {
        SetLastError (ERROR_CANCELLED);
        return FALSE;
    }

    MYASSERT (g_MigDbInf != INVALID_HANDLE_VALUE);

    if (SetupFindFirstLine (g_MigDbInf, TypeStr, NULL, &context)) {
        //let's identify the action function index to update MIGDB_CONTEXT structure
        actionIndex = MigDb_GetActionIdx (TypeStr);
        if (actionIndex == -1) {
            LOG ((LOG_ERROR, "Unable to identify action index for %s", TypeStr));
        }

        do {
            if (!SetupGetStringField (&context, 1, section, MEMDB_MAX, NULL)) {
                LOG ((LOG_ERROR, "Unable to load section for %s", TypeStr));
                return FALSE;
            }

            if (!SetupGetStringField (&context, 2, message, MEMDB_MAX, NULL)) {
                message [0] = 0;
            }

            migDbContext = (PMIGDB_CONTEXT) PoolMemGetMemory (g_MigDbPool, sizeof (MIGDB_CONTEXT));
            if (migDbContext == NULL) {
                LOG ((LOG_ERROR, "Unable to create context for %s.", TypeStr));
                return FALSE;
            }

            ZeroMemory (migDbContext, sizeof (MIGDB_CONTEXT));
            migDbContext->Next = g_ContextList;
            g_ContextList = migDbContext;

            // update ActionIndex with known value
            migDbContext->ActionIndex = actionIndex;

            // update SectName field
            migDbContext->SectName = PoolMemDuplicateString (g_MigDbPool, section);

            // update SectLocalizedName field
            if (SetupFindFirstLine (g_MigDbInf, S_STRINGS, section, &context1)) {
                if (SetupGetStringField (&context1, 1, locSection, MEMDB_MAX, NULL)) {
                    migDbContext->SectLocalizedName = PoolMemDuplicateString (g_MigDbPool, locSection);
                }
            }

            // set SectNameForDisplay to localized name, or sect name if no localized name
            if (migDbContext->SectLocalizedName) {
                migDbContext->SectNameForDisplay = migDbContext->SectLocalizedName;
            } else {
                migDbContext->SectNameForDisplay = migDbContext->SectName;
            }

            // update Message field
            if (message[0] != 0) {
                migDbContext->Message  = PoolMemDuplicateString (g_MigDbPool, message);
            }

            // OK, now let's scan all the remaining fields
            fieldIndex = 3;
            do {
                if (!TickProgressBar()) {
                    return FALSE;
                }

                tempField [0] = 0;

                if (SetupGetStringField (&context, fieldIndex, tempField, MEMDB_MAX, NULL)) {
                    if (StringIMatchCharCountA (tempField, ArgFunction, ArgFunctionLen)) {
                        //we have an additional argument for action function
                        tempFieldPtr = _mbschr (tempField, '(');
                        if (tempFieldPtr != NULL) {

                            tempFieldPtr = (PSTR) SkipSpaceA (_mbsinc (tempFieldPtr));

                            if (tempFieldPtr != NULL) {

                                endOfArg = _mbschr (tempFieldPtr, ')');

                                if (endOfArg != NULL) {
                                    *endOfArg = 0;
                                    endOfArg = (PSTR) SkipSpaceRA (tempFieldPtr, endOfArg);
                                }

                                if (endOfArg != NULL) {
                                    *_mbsinc (endOfArg) = 0;
                                    MultiSzAppend (&argList, tempFieldPtr);
                                }
                                ELSE_DEBUGMSG ((
                                    DBG_WHOOPS,
                                    "Improperly formatted arg: %s in %s",
                                    tempField,
                                    TypeStr
                                    ));
                            }
                        }
                    }
                    else {
                        //we have something else, probably file name and attributes
                        if (_tcschr (tempField, TEXT('.')) == NULL) {
                            LOG ((LOG_ERROR, "Dot not found in %s\\%s", TypeStr, section));
                        }

                        //therefore we initialize the section (this context will have
                        //only one section) and parse the file info
                        migDbContext->Sections = (PMIGDB_SECTION) PoolMemGetMemory (
                                                                        g_MigDbPool,
                                                                        sizeof (MIGDB_SECTION)
                                                                        );
                        if (migDbContext->Sections != NULL) {
                            ZeroMemory (migDbContext->Sections, sizeof (MIGDB_SECTION));
                            migDbContext->Sections->Context = migDbContext;
                            migDbContext->Arguments = PoolMemDuplicateMultiSz (g_MigDbPool, (PSTR)argList.Buf);
                            FreeGrowBuffer (&argList);
                            if (!pScanForFile (&context, fieldIndex)) {
                                return FALSE;
                            }
                            tempField [0] = 0;
                        }
                        else {
                            LOG ((LOG_ERROR, "Unable to create section for %s/%s", TypeStr, section));
                            return FALSE;
                        }
                    }
                }

                fieldIndex ++;
            } while (tempField [0] != 0);

            if (migDbContext->Sections == NULL) {
                //now let's add action function arguments in MIGDB_CONTEXT structure
                migDbContext->Arguments = PoolMemDuplicateMultiSz (g_MigDbPool, (PSTR)argList.Buf);
                FreeGrowBuffer (&argList);

                //let's go to the sections and scan all files
                if (!pLoadSectionData (section)) {
                    return FALSE;
                }
            }

        }
        while (SetupFindNextLine (&context, &context));
    }
    return result;
}


#define szMigDbFile     TEXT("MIGDB.INF")
#define szMigDbFile2    TEXT("MIGDB2.INF")
#define szExtraMigDbDir TEXT("INF\\NTUPG")

BOOL
InitMigDbEx (
    PCSTR MigDbFile
    )

/*++

Routine Description:

  This routine initialize memory and data structures used by MigDb.

Arguments:

  NONE

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    PCSTR migDbFile      = NULL;
    PCSTR migDbFile2     = NULL;
    PCSTR extraMigDbDir  = NULL;
    PCSTR pattern        = NULL;
    PCSTR extraMigDbFile = NULL;
    WIN32_FIND_DATA migDbFiles;
    HANDLE findHandle;
    BOOL result = TRUE;
    INT i;
    PCSTR typeStr;

    TCHAR fileName [MAX_TCHAR_PATH] = "";
    PTSTR dontCare;

    if (CANCELLED()) {
        SetLastError (ERROR_CANCELLED);
        return FALSE;
    }

    MYASSERT (g_MigDbInf == INVALID_HANDLE_VALUE);

    __try {
        if (MigDbFile != NULL) {
            g_MigDbInf = InfOpenInfFile (MigDbFile);
            if (g_MigDbInf == INVALID_HANDLE_VALUE) {
                SearchPath (NULL, MigDbFile, NULL, MAX_TCHAR_PATH, fileName, &dontCare);
                g_MigDbInf = InfOpenInfFile (fileName);
                if (g_MigDbInf == INVALID_HANDLE_VALUE) {
                    LOG((LOG_ERROR, "Cannot open migration database : %s", MigDbFile));
                    result = FALSE;
                    __leave;
                }
            }
        }
        else {

            migDbFile = JoinPaths (g_UpgradeSources, szMigDbFile);
            g_MigDbInf = InfOpenInfFile (migDbFile);
            if (g_MigDbInf == INVALID_HANDLE_VALUE) {
               LOG((LOG_ERROR, "Cannot open migration database : %s", migDbFile));
                result = FALSE;
                __leave;
            }
            TickProgressBar ();

            migDbFile2 = JoinPaths (g_UpgradeSources, szMigDbFile2);
            if (!SetupOpenAppendInfFile (migDbFile2, g_MigDbInf, NULL)) {
                DEBUGMSG((DBG_WARNING, "Cannot append second migration database : %s", migDbFile2));
            }

            extraMigDbDir  = JoinPaths (g_WinDir, szExtraMigDbDir);
            pattern = JoinPaths (extraMigDbDir, TEXT("*.INF"));
            findHandle = FindFirstFile (pattern, &migDbFiles);
            FreePathString (pattern);

            if (findHandle != INVALID_HANDLE_VALUE) {
                do {
                    extraMigDbFile = JoinPaths (extraMigDbDir, migDbFiles.cFileName);
                    if (!SetupOpenAppendInfFile (extraMigDbFile, g_MigDbInf, NULL)) {
                        DEBUGMSG((DBG_WARNING, "Cannot append external migration database : %s", extraMigDbFile));
                    }
                    FreePathString (extraMigDbFile);
                }
                while (FindNextFile (findHandle, &migDbFiles));
                FindClose (findHandle);
            }

            //
            // need to read [UseNtFiles] section to decide exclusion of some
            // file names replacement
            //
            InitUseNtFilesMap ();
        }
        g_MigDbPool = PoolMemInitNamedPool ("MigDb Pool");

        PoolMemDisableTracking (g_MigDbPool);
        g_FileTable = HtAllocWithData (sizeof (FILE_LIST_STRUCT));

        if (g_FileTable == NULL) {
            LOG((LOG_ERROR, "Cannot initialize memory for migdb operations"));
            result = FALSE;
            __leave;
        }

        //load known types from migdb
        i = 0;
        do {
            typeStr = MigDb_GetActionName (i);
            if (typeStr != NULL) {
                if (!pLoadTypeData (typeStr)) {
                    result = FALSE;
                    __leave;
                }
            }
            i++;
        }
        while (typeStr != NULL);
    }
    __finally {
        if (extraMigDbDir != NULL) {
            FreePathString (extraMigDbDir);
        }
        if (migDbFile2 != NULL) {
            FreePathString (migDbFile2);
        }
        if (migDbFile != NULL) {
            FreePathString (migDbFile);
        }
    }
    return result;
}


VOID
pCheckForPerUserKeys (
    VOID
    )

/*++

Routine Description:

  pCheckForPerUserKeys scans all users for the keys or values specified in
  the g_PerUserRegKeys hash table.  The values of the hash table are updated,
  so the RegKeyExists attribute is fast.

Arguments:

  None.

Return Value:

  None.

--*/

{
    BOOL b = FALSE;
    CHAR RegKey[MAX_REGISTRY_KEY];
    CHAR RegValue[MAX_REGISTRY_VALUE_NAME];
    BOOL HasValue;
    USERENUM ue;
    HASHTABLE_ENUM he;
    HKEY Key;
    PBYTE Data;
    HKEY OldRoot;

    if (!EnumFirstHashTableString (&he, g_PerUserRegKeys)) {
        return;
    }

    //
    // Enumerate each user, then enumerate the g_PerUserRegKeys hash
    // table and test the registry
    //

    if (EnumFirstUser (&ue, 0)) {
        do {

            //
            // Skip users we don't care about
            //

            if (!ue.UserRegKey || ue.CreateAccountOnly || (ue.AccountType & INVALID_ACCOUNT)) {
                continue;
            }

            //
            // Set HKR to this user
            //

            OldRoot = GetRegRoot();
            SetRegRoot (ue.UserRegKey);

            //
            // Process the hash table
            //

            if (EnumFirstHashTableString (&he, g_PerUserRegKeys)) {
                do {

                    //
                    // Skip this entry if we already know it exists for
                    // one user.
                    //

                    if (*((PBOOL) he.ExtraData)) {
                        continue;
                    }

                    //
                    // Decode registry string using hash table entry
                    //

                    HasValue = DecodeRegistryString (
                                    he.String,
                                    RegKey,
                                    RegValue,
                                    NULL
                                    );

                    //
                    // Ping the registry.  RegKey always starts with HKR.
                    //

                    b = FALSE;
                    Key = OpenRegKeyStr (RegKey);

                    if (Key) {
                        if (HasValue) {
                            Data = GetRegValueData (Key, RegValue);
                            if (Data) {
                                b = TRUE;
                                MemFree (g_hHeap, 0, Data);
                            }
                        } else {
                            b = TRUE;
                        }

                        CloseRegKey (Key);
                    }

                    //
                    // Update hash table if the key or value exists
                    //

                    if (b) {
                        HtAddStringAndData (g_PerUserRegKeys, he.String, &b);
                    }

                } while (EnumNextHashTableString (&he));
            }

            //
            // Restore HKR
            //

            SetRegRoot (OldRoot);

        } while (EnumNextUser (&ue));
    }
}


DWORD
InitMigDb (
    IN      DWORD Request
    )
{
    switch (Request) {

    case REQUEST_QUERYTICKS:
        return TICKS_INIT_MIGDB;

    case REQUEST_RUN:
        if (!InitMigDbEx (NULL)) {
            return GetLastError ();
        }

        pCheckForPerUserKeys();

        return ERROR_SUCCESS;

    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in InitMigDb"));
    }
    return 0;
}


BOOL
CleanupMigDb (
    VOID
    )

/*++

Routine Description:

  This routine cleans up all memory used by MigDb.

Arguments:

  NONE

Return value:

  always TRUE

--*/

{
    PMIGDB_CONTEXT migDbContext = NULL;

    // first, let's walk through any context and check if it's a required one
    migDbContext = g_ContextList;

    while (migDbContext) {
        if ((!MigDb_CallWhenTriggered (migDbContext->ActionIndex)) &&
            (migDbContext->TriggerCount == 0)
            ) {

            pCallAction (migDbContext);
        }
        migDbContext = migDbContext->Next;
    }

    if (g_FileTable != NULL) {
        HtFree (g_FileTable);
        g_FileTable = NULL;
    }

    if (g_MigDbPool != NULL) {
        PoolMemDestroyPool (g_MigDbPool);
        g_MigDbPool = NULL;
    }

    if (g_MigDbInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_MigDbInf);
        g_MigDbInf = INVALID_HANDLE_VALUE;
    }

    g_ContextList = NULL;
    return TRUE;
}


DWORD
DoneMigDb (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_DONE_MIGDB;
    case REQUEST_RUN:
        if (!CleanupMigDb ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in DoneMigDb"));
    }
    return 0;
}


BOOL
IsKnownMigDbFile (
    IN      PCTSTR FileName
    )

/*++

Routine Description:

  This routine looks if the file given as argument is in MigDb string table.

Arguments:

  FileName  - file name

Return value:

  TRUE  - the file is in MigDb string table
  FALSE - otherwise

--*/

{
    return (HtFindString (g_FileTable, FileName) != 0);
}


BOOL
CallAttribute (
    IN      PMIGDB_ATTRIB MigDbAttrib,
    IN      PDBATTRIB_PARAMS AttribParams
    )

/*++

Routine Description:

  This routine calls a specified attribute function for a specified file.

Arguments:

  MigDbAttrib - See definition.
  AttribParams - See definition

Return value:

  TRUE  - if attribute function succeded
  FALSE - otherwise

--*/

{
    PATTRIBUTE_PROTOTYPE p;
    BOOL b;
#ifdef DEBUG
    TCHAR DbgBuf[32];
    BOOL InterestingFile;
#endif

    if (MigDbAttrib->AttribIndex == -1) {
        //invalid index for attribute function
        return FALSE;
    }

#ifdef DEBUG
    if (!g_ConfigOptions.Fast) {
        //
        // Check if this file is in [FilesToTrack] inside debug.inf
        //

        GetPrivateProfileString ("FilesToTrack", AttribParams->FileParams->FullFileSpec, "", DbgBuf, ARRAYSIZE(DbgBuf), g_DebugInfPath);
        if (!(*DbgBuf)) {
            GetPrivateProfileString ("FilesToTrack", AttribParams->FileParams->FindData->cFileName, "", DbgBuf, ARRAYSIZE(DbgBuf), g_DebugInfPath);
        }

        InterestingFile = (*DbgBuf != 0);

        if (InterestingFile) {
            DEBUGMSG ((
                DBG_TRACK,
                "Calling %s for %s",
                MigDb_GetAttributeName (MigDbAttrib->AttribIndex),
                AttribParams->FileParams->FindData->cFileName
                ));
        }
    }

#endif

    p = MigDb_GetAttributeAddr (MigDbAttrib->AttribIndex);
    MYASSERT (p);

    if (MigDbAttrib->NotOperator) {
        b = !(p (AttribParams, MigDbAttrib->Arguments));
    } else {
        b = p (AttribParams, MigDbAttrib->Arguments);
    }

#ifdef DEBUG

    if (!g_ConfigOptions.Fast && InterestingFile) {
        DEBUGMSG ((
            DBG_TRACK,
            "Result of %s is %s",
            MigDb_GetAttributeName (MigDbAttrib->AttribIndex),
            b ? TEXT("TRUE") : TEXT("FALSE")
            ));
    }

#endif

    return b;
}


BOOL
pCallAction (
    IN      PMIGDB_CONTEXT MigDbContext
    )

/*++

Routine Description:

  This routine calls an appropriate action for a specified migdb context.

Arguments:

  MigDbContext - See definition.

Return value:

  TRUE  - if action function succeded
  FALSE - otherwise

--*/

{
    PACTION_PROTOTYPE p;
    BOOL b;

#ifdef DEBUG
    TCHAR DbgBuf[512];
    BOOL InterestingFile = FALSE;
    MULTISZ_ENUM e;
    PCTSTR FileName;
    UINT FileCount = 0;

    if (!g_ConfigOptions.Fast) {
        //
        // Dump out action information if this file is being tracked
        //

        if (EnumFirstMultiSz (&e, (PCTSTR) MigDbContext->FileList.Buf)) {

            do {
                //
                // Check if this file is in [FilesToTrack] inside debug.inf
                //

                FileName = GetFileNameFromPath (e.CurrentString);
                *DbgBuf = 0;

                if (FileName) {
                    GetPrivateProfileString ("FilesToTrack", FileName, "", DbgBuf, ARRAYSIZE(DbgBuf), g_DebugInfPath);
                }

                if (!(*DbgBuf)) {
                    GetPrivateProfileString ("FilesToTrack", e.CurrentString, "", DbgBuf, ARRAYSIZE(DbgBuf), g_DebugInfPath);
                }

                FileCount++;
                InterestingFile |= (*DbgBuf != 0);

            } while (EnumNextMultiSz (&e));

            if (InterestingFile) {
                if (FileCount == 1) {
                    DEBUGMSG ((
                        DBG_TRACK,
                        "Calling action %s for %s",
                        MigDb_GetActionName (MigDbContext->ActionIndex),
                        (PCTSTR) MigDbContext->FileList.Buf
                        ));
                } else {
                    wsprintf (DbgBuf, "Calling %s for:", MigDb_GetActionName (MigDbContext->ActionIndex));
                    LOGTITLE (DBG_TRACK, DbgBuf);

                    if (EnumFirstMultiSz (&e, (PCTSTR) MigDbContext->FileList.Buf)) {

                        do {
                            wsprintf (DbgBuf, "   %s", e.CurrentString);
                            LOGLINE ((DbgBuf));
                        } while (EnumNextMultiSz (&e));
                    }
                }
            }

        } else {
            DEBUGMSG ((
                DBG_TRACK,
                "Calling action %s",
                MigDb_GetActionName (MigDbContext->ActionIndex)
                ));
        }
    }

#endif

    p = MigDb_GetActionAddr (MigDbContext->ActionIndex);

    MYASSERT (p);

    b = p (MigDbContext);

#ifdef DEBUG

    if (!g_ConfigOptions.Fast && InterestingFile) {
        DEBUGMSG ((
            DBG_TRACK,
            "%s returned %s",
            MigDb_GetActionName (MigDbContext->ActionIndex),
            b ? "TRUE" : "FALSE"
            ));
    }

#endif

    return b;
}


BOOL
pCheckContext (
    IN      PMIGDB_CONTEXT MigDbContext,
    IN      BOOL Handled
    )

/*++

Routine Description:

  This routine checkes to see if a migdb context is met, that is if all sections
  have Satisfied field TRUE.

Arguments:

  MigDbContext - See definition.

Return value:

  always TRUE

--*/

{
    PMIGDB_SECTION migDbSection;
    BOOL contextSelected;
    BOOL result = FALSE;

    migDbSection = MigDbContext->Sections;
    contextSelected = TRUE;
    while (migDbSection) {
        if (!migDbSection->Satisfied) {
            contextSelected = FALSE;
            break;
        }
        migDbSection = migDbSection->Next;
    }
    if (contextSelected) {
        MigDbContext->TriggerCount ++;

        if (MigDbContext->ActionIndex == -1) {
            //
            // invalid index for action function
            //
            DEBUGMSG ((DBG_ERROR, "MigDb: Invalid action index"));
            return FALSE;
        }

        //
        // if appropriate call the action
        //
        if (MigDb_CallWhenTriggered (MigDbContext->ActionIndex)) {
            if ((!Handled) ||
                (MigDb_CallAlways (MigDbContext->ActionIndex))
                ) {
                if ((!MigDbContext->VirtualFile) ||
                    (MigDb_CanHandleVirtualFiles (MigDbContext->ActionIndex))
                    ) {
                    result = pCallAction (MigDbContext);
                }
            }
        }
        //clean up the grow buffer with file list
        FreeGrowBuffer (&MigDbContext->FileList);
    }
    return result;
}

BOOL
MigDbTestFile (
    IN OUT  PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  This is a callback function called for every file scanned. If the file is not handled we try
  to see if we have this file in database. If so then we check for attributes, update the migdb
  context and if necessarry call the appropriate action.

Arguments:

  Params - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    HASHITEM stringId;
    PMIGDB_FILE migDbFile;
    PMIGDB_ATTRIB migDbAttrib;
    DBATTRIB_PARAMS attribParams;
    BOOL fileSelected;
    PCTSTR fileName;
    PCTSTR fileExt;
    FILE_LIST_STRUCT fileList;

    // we don't check the Handled field here because the code will be carefull enough not
    // to call actions that are not gathering informations if the Handled field is not 0.

    fileName = GetFileNameFromPath (Params->FullFileSpec);
    fileExt  = GetFileExtensionFromPath (fileName);

#ifdef DEBUG
    {
        TCHAR DbgBuf[256];

        if (GetPrivateProfileString ("MigDb", fileName, "", DbgBuf, 256, g_DebugInfPath) ||
            GetPrivateProfileString ("MigDb", Params->FullFileSpec, "", DbgBuf, 256, g_DebugInfPath)
            ) {

            DEBUGMSG ((DBG_WHOOPS, "Ready to process %s", Params->FullFileSpec));

        }
    }
#endif

    stringId = HtFindString (g_FileTable, fileName);

    if (stringId) {

        //The string table has extra data (a pointer to a MigDbFile node)

        HtCopyStringData (g_FileTable, stringId, &fileList);
        migDbFile = fileList.First;

        while (migDbFile) {

            //check all attributes for this file
            migDbAttrib = migDbFile->Attributes;
            fileSelected = TRUE;
            if (!Params->VirtualFile) {
                while (migDbAttrib != NULL) {
                    attribParams.FileParams = Params;
                    attribParams.ExtraData = migDbAttrib->ExtraData;
                    if (!CallAttribute (migDbAttrib, &attribParams)) {
                        fileSelected = FALSE;
                        break;
                    }
                    migDbAttrib = migDbAttrib->Next;
                }
            }
            if (fileSelected) {
                MYASSERT (migDbFile->Section);
                //go to section and mark it as satisfied
                migDbFile->Section->Satisfied = TRUE;
                //go to context and mark there if this is a virtual file or not
                migDbFile->Section->Context->VirtualFile = Params->VirtualFile;
                //go to context and add there the file we found in file list
                MultiSzAppend (&migDbFile->Section->Context->FileList, Params->FullFileSpec);
                //check if context is satisfied and if so then call the appropriate action
                if (pCheckContext (migDbFile->Section->Context, Params->Handled)) {
                    Params->Handled = TRUE;
                }
            }
            migDbFile = migDbFile->Next;
        }
    }

    if ((!Params->Handled) &&
        (fileExt) &&
        ((StringIMatch (fileExt, TEXT("VXD")))  ||
         (StringIMatch (fileExt, TEXT("DRV")))  ||
         (StringIMatch (fileExt, TEXT("SPD")))  ||
         (StringIMatch (fileExt, TEXT("386")))) &&
        (StringIMatchCharCount (g_WinDirWack, Params->FullFileSpec, g_WinDirWackChars))
        ) {
        DeleteFileWithWarning (Params->FullFileSpec);
        Params->Handled = TRUE;
        return TRUE;
    }
    return TRUE;
}


BOOL
pProcessMigrationLine (
    IN      PCTSTR Source,
    IN      PCTSTR Destination,
    IN      PCTSTR AppDir
    )

/*++

Routine Description:

  pProcessMigrationLine processes one line and adds the appropriate operations for files
  or registry

Arguments:

  Source      - Specifies the source registry key/value or file.
  Destination - Specifies the destination registry key/value or file.
                If destination is same as source => handled
                If destination is null => delete
                Otherwise add a move operation
  AppDir      - Specifies the application directory, which is put in front of Line
                when Line does not specify the drive but points to a file.

Return Value:

  TRUE on success, FALSE on failure.

--*/

{
    PCTSTR LocalSource = NULL;
    PCTSTR LocalDestination = NULL;
    DWORD Attribs;
    PTSTR PathCopy;
    PTSTR p;
    BOOL Excluded;
    TREE_ENUM TreeEnum;
    CHAR NewDest[MEMDB_MAX];

    //
    // Is this HKLM or HKR?  If so, go directly to MemDb.
    //

    if (StringIMatchCharCount (Source, TEXT("HKLM"), 4) ||
        StringIMatchCharCount (Source, TEXT("HKR"), 3)
        ) {
        if (Destination) {
            DEBUGMSG ((DBG_WHOOPS, "Handling and moving registry is not implemented. Do it yourself!"));
        } else {
            DEBUGMSG ((DBG_MIGDB, "Will uninstall %s", Source));
            Suppress95Object (Source);
        }
    }

    //
    // Else this is a file/dir spec.
    //

    else {
        if (_tcsnextc (_tcsinc (Source)) != ':') {
            LocalSource = JoinPaths (AppDir, Source);
        } else {
            LocalSource = Source;
        }

        if ((Destination) && (_tcsnextc (_tcsinc (Destination)) != ':')) {
            LocalDestination = JoinPaths (AppDir, Destination);
        } else {
            LocalDestination = Destination;
        }

        //
        // Is this path excluded?
        //

        Excluded = FALSE;

        if (!Excluded && LocalSource) {
            PathCopy = DuplicatePathString (LocalSource, 0);
            p = GetEndOfString (PathCopy);

            do {
                *p = 0;
                if (IsPathExcluded (g_ExclusionValue, PathCopy)) {
                    DEBUGMSG ((DBG_MIGDB, "%s is excluded and will not be processed", LocalSource));
                    Excluded = TRUE;
                    break;
                }
                p = _tcsrchr (PathCopy, TEXT('\\'));
            } while (p);
            FreePathString (PathCopy);
        }

        if (!Excluded && LocalDestination) {
            PathCopy = DuplicatePathString (LocalDestination, 0);
            p = GetEndOfString (PathCopy);

            do {
                *p = 0;
                if (IsPathExcluded (g_ExclusionValue, PathCopy)) {
                    DEBUGMSG ((DBG_MIGDB, "%s is excluded and will not be processed", LocalDestination));
                    Excluded = TRUE;
                    break;
                }
                p = _tcsrchr (PathCopy, TEXT('\\'));
            } while (p);
            FreePathString (PathCopy);
        }

        if (!Excluded) {

            Attribs = QuietGetFileAttributes (LocalSource);

            if (Attribs != 0xffffffff) {

                if (LocalDestination) {

                    if (StringIMatch (LocalSource, LocalDestination)) {
                        //
                        // This object is handled
                        //
                        if (Attribs & FILE_ATTRIBUTE_DIRECTORY) {
                            HandleObject (LocalSource, S_DIRECTORY);
                        } else {
                            HandleObject (LocalSource, S_FILE);
                        }
                    } else {
                        //
                        // This object is moved
                        //
                        if (Attribs & FILE_ATTRIBUTE_DIRECTORY) {
                            if (EnumFirstFileInTree (&TreeEnum, LocalSource, NULL, TRUE)) {
                                StringCopy (NewDest, LocalDestination);
                                p = AppendWack (NewDest);
                                do {
                                    DontTouchThisFile (TreeEnum.FullPath);
                                    MYASSERT (*TreeEnum.SubPath != '\\');
                                    StringCopy (p, TreeEnum.SubPath);
                                    MarkFileForMove (TreeEnum.FullPath, NewDest);

                                } while (EnumNextFileInTree (&TreeEnum));
                            }
                        } else {
                            DontTouchThisFile (LocalSource);
                            MarkFileForMove (LocalSource, LocalDestination);
                        }
                    }
                } else {
                    if (Attribs & FILE_ATTRIBUTE_DIRECTORY) {
                        MemDbSetValueEx (
                            MEMDB_CATEGORY_CLEAN_UP_DIR,
                            LocalSource,
                            NULL,
                            NULL,
                            0,
                            NULL
                            );
                    } else {
                        DontTouchThisFile (LocalSource);
                        MarkFileForDelete (LocalSource);
                    }
                }
            }
            ELSE_DEBUGMSG ((DBG_MIGDB, "pProcessMigrationLine: source %s not found", LocalSource));
        }

        if (LocalSource != Source) {
            FreePathString (LocalSource);
        }
        if (LocalDestination != Destination) {
            FreePathString (LocalDestination);
        }
    }

    return TRUE;

    // add this

    /*
    //
    // Add the app dir to CleanUpDirs
    //

    MemDbSetValueEx (
        MEMDB_CATEGORY_CLEAN_UP_DIR,
        p,
        NULL,
        NULL,
        0,
        NULL
        );

    */
}


BOOL
pProcessMigrationSection (
    IN      PCTSTR SectionName,
    IN      PCTSTR AppDir
    )

/*++

Routine Description:

  pProcessMigrationSection enumerates the caller-specified section and adds
  appropriate operations for files and/or registry. This routine
  supports the following environment variable
  replacement:

    %WINDIR%
    %SYSTEMDIR%
    %SYSTEM32DIR%
    %SYSTEMDRIVE%
    %USERPROFILE%
    %APPDIR%

Arguments:

  SectionName - Specifies the uninstall section name in migdb.inf.

  AppDir - Specifies the directory where the installed app was found

Return Value:

  TRUE if successful, or FALSE if an error occurrs.  GetLastError provides
  failure code.

--*/

{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR Source = NULL;
    PCTSTR Destination = NULL;
    PCTSTR NewSource = NULL;
    PCTSTR NewDestination = NULL;
    PCTSTR UserSource = NULL;
    PCTSTR UserDestination = NULL;
    TCHAR Drive[3];
    USERENUM e;

    MYASSERT (g_MigDbInf != INVALID_HANDLE_VALUE);

    Drive[0] = g_SystemDir[0];
    Drive[1] = g_SystemDir[1];
    Drive[2] = 0;

    if (InfFindFirstLine (g_MigDbInf, SectionName, NULL, &is)) {
        do {
            //
            // Get INF line
            //

            Source = InfGetStringField (&is, 1);
            Destination = InfGetStringField (&is, 2);

            //
            // Expand system environment variables
            //

            if (Source) {
                ReplaceOneEnvVar (&NewSource, Source, S_WINDIR_ENV, g_WinDir);
                ReplaceOneEnvVar (&NewSource, Source, S_SYSTEMDIR_ENV, g_SystemDir);
                ReplaceOneEnvVar (&NewSource, Source, S_SYSTEM32DIR_ENV, g_System32Dir);
                ReplaceOneEnvVar (&NewSource, Source, S_SYSTEMDRIVE_ENV, Drive);
                ReplaceOneEnvVar (&NewSource, Source, S_APPDIR_ENV, AppDir);
                ReplaceOneEnvVar (&NewSource, Source, S_PROGRAMFILES_ENV, g_ProgramFilesDir);
                ReplaceOneEnvVar (&NewSource, Source, S_COMMONPROGRAMFILES_ENV, g_ProgramFilesCommonDir);
            }
            if (Destination) {
                ReplaceOneEnvVar (&NewDestination, Destination, S_WINDIR_ENV, g_WinDir);
                ReplaceOneEnvVar (&NewDestination, Destination, S_SYSTEMDIR_ENV, g_SystemDir);
                ReplaceOneEnvVar (&NewDestination, Destination, S_SYSTEM32DIR_ENV, g_System32Dir);
                ReplaceOneEnvVar (&NewDestination, Destination, S_SYSTEMDRIVE_ENV, Drive);
                ReplaceOneEnvVar (&NewDestination, Destination, S_APPDIR_ENV, AppDir);
                ReplaceOneEnvVar (&NewDestination, Destination, S_PROGRAMFILES_ENV, g_ProgramFilesDir);
                ReplaceOneEnvVar (&NewDestination, Destination, S_COMMONPROGRAMFILES_ENV, g_ProgramFilesCommonDir);
            }

            if (NewSource) {
                Source = NewSource;
            }
            if (NewDestination) {
                Destination = NewDestination;
            }

            //
            // If %USERPROFILE% exists in the string, then expand for all users
            //

            if (((Source) && (_tcsistr (Source, S_USERPROFILE_ENV))) ||
                ((Destination) && (_tcsistr (Destination, S_USERPROFILE_ENV)))
                ) {
                if (EnumFirstUser (&e, ENUMUSER_ENABLE_NAME_FIX|ENUMUSER_DO_NOT_MAP_HIVE)) {
                    do {
                        //
                        // Skip invalid users and logon account
                        //

                        if (e.AccountType & (INVALID_ACCOUNT|DEFAULT_USER)) {
                            continue;
                        }

                        if (Source) {
                            UserSource = DuplicatePathString (Source, 0);
                            MYASSERT (UserSource);
                            ReplaceOneEnvVar (
                                &UserSource,
                                UserSource,
                                S_USERPROFILE_ENV,
                                e.OrgProfilePath
                                );
                        }

                        if (Destination) {
                            UserDestination = DuplicatePathString (Destination, 0);
                            MYASSERT (UserDestination);
                            ReplaceOneEnvVar (
                                &UserDestination,
                                UserDestination,
                                S_USERPROFILE_ENV,
                                e.OrgProfilePath
                                );
                        }

                        //
                        // Add the uninstall line for the user
                        //

                        pProcessMigrationLine (UserSource, UserDestination, AppDir);

                        if (UserSource) {
                            FreePathString (UserSource);
                            UserSource = NULL;
                        }

                        if (UserDestination) {
                            FreePathString (UserDestination);
                            UserDestination = NULL;
                        }

                    } while (EnumNextUser (&e));
                }

            } else {

                //
                // When %USERPROFILE% is not in the string, add the uninstall line
                // for the system
                //

                pProcessMigrationLine (Source, Destination, AppDir);
            }

            //
            // Free the expanded string
            //

            if (NewSource) {
                FreePathString (NewSource);
                NewSource = NULL;
            }

            if (NewDestination) {
                FreePathString (NewDestination);
                NewDestination = NULL;
            }

        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);

    return TRUE;
}


DWORD
ProcessMigrationSections (
    IN      DWORD Request
    )

/*++

Routine Description:

  ProcessMigrationSections processes all sections in the memdb category
  MigrationSections, generating memdb operations for files and registry

Arguments:

  Request - Specifies weather the progress bar is being computed (REQUEST_QUERYTICKS),
            or if the actual operation should be performed (REQUEST_RUN).
            This routine estimates 1 tick for all of its operations.  (It's pretty
            fast.)

Return Value:

  Win32 status code.

--*/

{
    MEMDB_ENUM e;
    PCTSTR p;
    TCHAR SectionName[MEMDB_MAX];

    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_PROCESSMIGRATIONSECTIONS;

    case REQUEST_RUN:
        if (MemDbGetValueEx (&e, MEMDB_CATEGORY_MIGRATION_SECTION, NULL, NULL)) {
            do {
                p = _tcschr (e.szName, TEXT('\\'));
                MYASSERT (p);

                StringCopyAB (SectionName, e.szName, p);
                p = _tcsinc (p);

                if (CharCount (p) < 3) {
                    DEBUGMSG ((
                        DBG_WARNING,
                        "Ignoring migration section %s: Application detected in the root directory",
                        SectionName
                        ));
                    continue;
                }

                if (!pProcessMigrationSection (SectionName, p)) {
                    return GetLastError();
                }

            } while (MemDbEnumNextValue (&e));
        }
        return ERROR_SUCCESS;
    }

    MYASSERT (FALSE);
    return 0;
}


BOOL
IsDisplayableCPL (
    IN      PCTSTR FileName
    )
{
    PCTSTR filePtr;
    HINF   infHandle = INVALID_HANDLE_VALUE;
    PCTSTR infName = NULL;
    PCTSTR field   = NULL;
    INFSTRUCT context = INITINFSTRUCT_POOLHANDLE;
    BOOL   result;

    filePtr = GetFileNameFromPath (FileName);
    if (!filePtr) {
        return FALSE;
    }

    result = TRUE;
    infName = JoinPaths (g_WinDir, TEXT("CONTROL.INI"));
    __try {
        infHandle = InfOpenInfFile (infName);
        if (infHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }
        if (InfFindFirstLine (infHandle, TEXT("don't load"), NULL, &context)) {
            do {
                field = InfGetStringField (&context, 0);
                if ((field != NULL) &&
                    ((StringIMatch (field, filePtr )) ||
                     (StringIMatch (field, FileName))
                    )) {
                    result = FALSE;
                    __leave;
                }
            }
            while (InfFindNextLine (&context));
        }
    }
    __finally {
        if (infHandle != INVALID_HANDLE_VALUE) {
            InfCloseInfFile (infHandle);
        }
        if (infName != NULL) {
            FreePathString (infName);
        }
        InfCleanUpInfStruct(&context);
    }
    if (!result) {
        return FALSE;
    }

    result = FALSE;
    infName = JoinPaths (g_WinDir, TEXT("CONTROL.INI"));
    __try {
        infHandle = InfOpenInfFile (infName);
        if (infHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }
        if (InfFindFirstLine (infHandle, TEXT("MMCPL"), NULL, &context)) {
            do {
                field = InfGetStringField (&context, 1);
                if ((field != NULL) &&
                    ((StringIMatch (field, filePtr )) ||
                     (StringIMatch (field, FileName))
                    )) {
                    result = TRUE;
                    __leave;
                }
            }
            while (InfFindNextLine (&context));
        }
    }
    __finally {
        if (infHandle != INVALID_HANDLE_VALUE) {
            InfCloseInfFile (infHandle);
        }
        if (infName != NULL) {
            FreePathString (infName);
        }
        InfCleanUpInfStruct(&context);
    }
    if (result) {
        return TRUE;
    }

    if (StringIMatchAB (g_SystemDirWack, FileName, filePtr)) {
        return TRUE;
    }

    if (StringIMatchAB (g_System32DirWack, FileName, filePtr)) {
        return TRUE;
    }
    return FALSE;
}


BOOL
pGetCPLFriendlyName (
    IN      PCTSTR FileName,
    IN OUT  PGROWBUFFER FriendlyName
    )
{
    HANDLE cplInstance;
    PCPL_PROTOTYPE cplMain;
    LONG numEntries,i;
    TCHAR localName[MEMDB_MAX];
    UINT oldErrorMode;
    PTSTR p, q;
    LPCPLINFO info;
    LPNEWCPLINFO newInfo;
    UINT u;

    oldErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);

    cplInstance = LoadLibrary (FileName);
    if (!cplInstance) {
        LOG ((LOG_ERROR, "Cannot load %s. Error:%ld", FileName, GetLastError()));
        SetErrorMode (oldErrorMode);
        return FALSE;
    }

    cplMain = (PCPL_PROTOTYPE)GetProcAddress (cplInstance, TEXT("CPlApplet"));
    if (!cplMain) {
        LOG ((LOG_ERROR, "Cannot get main entry point for %s. Error:%ld", FileName, GetLastError()));
        SetErrorMode (oldErrorMode);
        return FALSE;
    }
    if ((*cplMain) (NULL, CPL_INIT, 0, 0) == 0) {
        (*cplMain) (NULL, CPL_EXIT, 0, 0);
        LOG ((LOG_ERROR, "%s failed unexpectedly. Error:%ld", FileName, GetLastError()));
        FreeLibrary (cplInstance);
        SetErrorMode (oldErrorMode);
        return FALSE;
    }

    numEntries = (*cplMain) (NULL, CPL_GETCOUNT, 0, 0);
    if (numEntries == 0) {
        (*cplMain) (NULL, CPL_EXIT, 0, 0);
        FreeLibrary (cplInstance);
        SetErrorMode (oldErrorMode);
        DEBUGMSG ((DBG_WARNING, "CPL: No display info available for %s.", FileName));
        return FALSE;
    }

    info = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (CPLINFO) * numEntries);
    newInfo = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NEWCPLINFO) * numEntries);

    for (i=0;i<numEntries;i++) {
        (*cplMain) (NULL, CPL_INQUIRE, i, (LONG)&info[i]);
        (*cplMain) (NULL, CPL_NEWINQUIRE, i, (LONG)&newInfo[i]);

        u = FriendlyName->End;

        if (newInfo[i].szName[0]) {

            MultiSzAppend (FriendlyName, newInfo[i].szName);

        } else if (LoadString (cplInstance, info[i].idName, localName, MEMDB_MAX)) {

            MultiSzAppend (FriendlyName, localName);

        }
        ELSE_DEBUGMSG ((DBG_ERROR, "CPL: Can't get string id %u", info[i].idName));

        //
        // Remove ampersands from the name
        //

        if (FriendlyName->End > u) {

            q = p = (PTSTR) (FriendlyName->Buf + u);

            while (*p) {
                if (_tcsnextc (p) != TEXT('&')) {
                    _copytchar (q, p);
                    q = _tcsinc (q);
                } else {
                    if (_tcsnextc (p + 1) == TEXT('&')) {
                        p++;
                        _copytchar (q, p);
                        q = _tcsinc (q);
                    }
                }

                p = _tcsinc (p);
            }

            *q = 0;
        }
    }

    for (i=0;i<numEntries;i++) {
        (*cplMain) (NULL, CPL_STOP, i, info[i].lData?info[i].lData:newInfo[i].lData);
    }

    (*cplMain) (NULL, CPL_EXIT, 0, 0);

    FreeLibrary (cplInstance);

    MemFree (g_hHeap, 0, newInfo);
    MemFree (g_hHeap, 0, info);

    SetErrorMode (oldErrorMode);

    return (FriendlyName->Buf != NULL);
}


BOOL
ReportControlPanelApplet (
    IN      PCTSTR FileName,
    IN      PMIGDB_CONTEXT Context,         OPTIONAL
    IN      DWORD ActType
    )
{
    GROWBUFFER friendlyName = GROWBUF_INIT;
    MULTISZ_ENUM namesEnum;
    PTSTR displayName = NULL;
    PCTSTR reportEntry = NULL;
    PTSTR component = NULL;
    BOOL reportEntryIsResource = TRUE;
    BOOL padName = FALSE;
    PCTSTR temp1, temp2;

    if ((Context != NULL) &&
        (Context->SectLocalizedName != NULL)
        ) {
        MultiSzAppend (&friendlyName, Context->SectLocalizedName);
    }
    if (friendlyName.Buf == NULL) {
        if (!pGetCPLFriendlyName (FileName, &friendlyName)) {

            FreeGrowBuffer (&friendlyName);
            return FALSE;
        }
        padName = TRUE;
    }
    MYASSERT (friendlyName.Buf);

    if (EnumFirstMultiSz (&namesEnum, friendlyName.Buf)) {
        do {
            if (padName) {
                displayName = (PTSTR)ParseMessageID (MSG_NICE_PATH_CONTROL_PANEL, &namesEnum.CurrentString);
            } else {
                displayName = DuplicatePathString (namesEnum.CurrentString, 0);
            }

            MYASSERT (displayName);

            switch (ActType) {

            case ACT_MINORPROBLEMS:
                reportEntry = GetStringResource (MSG_MINOR_PROBLEM_ROOT);
                break;

            case ACT_INCOMPATIBLE:
            case ACT_INC_NOBADAPPS:
            case ACT_INC_IHVUTIL:
            case ACT_INC_PREINSTUTIL:
            case ACT_INC_SIMILAROSFUNC:

                temp1 = GetStringResource (MSG_INCOMPATIBLE_ROOT);
                if (!temp1) {
                    break;
                }

                switch (ActType) {

                case ACT_INC_SIMILAROSFUNC:
                    temp2 = GetStringResource (MSG_INCOMPATIBLE_UTIL_SIMILAR_FEATURE_SUBGROUP);
                    break;

                case ACT_INC_PREINSTUTIL:
                    temp2 = GetStringResource (MSG_INCOMPATIBLE_PREINSTALLED_UTIL_SUBGROUP);
                    break;

                case ACT_INC_IHVUTIL:
                    temp2 = GetStringResource (MSG_INCOMPATIBLE_HW_UTIL_SUBGROUP);
                    break;

                default:
                    temp2 = GetStringResource (
                                Context && Context->Message ?
                                    MSG_INCOMPATIBLE_DETAIL_SUBGROUP :
                                    MSG_TOTALLY_INCOMPATIBLE_SUBGROUP
                                    );
                    break;
                }

                if (!temp2) {
                    break;
                }

                reportEntry = JoinPaths (temp1, temp2);
                reportEntryIsResource = FALSE;

                FreeStringResource (temp1);
                FreeStringResource (temp2);
                break;

            case ACT_INC_SAFETY:
                temp1 = GetStringResource (MSG_INCOMPATIBLE_ROOT);
                if (!temp1) {
                    break;
                }
                temp2 = GetStringResource (MSG_REMOVED_FOR_SAFETY_SUBGROUP);
                if (!temp2) {
                    break;
                }

                reportEntry = JoinPaths (temp1, temp2);
                reportEntryIsResource = FALSE;

                FreeStringResource (temp1);
                FreeStringResource (temp2);
                break;

            case ACT_REINSTALL:
                temp1 = GetStringResource (MSG_REINSTALL_ROOT);
                if (!temp1) {
                    break;
                }
                temp2 = GetStringResource (
                            Context && Context->Message ?
                                MSG_REINSTALL_DETAIL_SUBGROUP :
                                MSG_REINSTALL_LIST_SUBGROUP
                            );
                if (!temp2) {
                    break;
                }

                reportEntry = JoinPaths (temp1, temp2);
                reportEntryIsResource = FALSE;

                FreeStringResource (temp1);
                FreeStringResource (temp2);
                break;

            case ACT_REINSTALL_BLOCK:
                temp1 = GetStringResource (MSG_BLOCKING_ITEMS_ROOT);
                if (!temp1) {
                    break;
                }
                temp2 = GetStringResource (MSG_REINSTALL_BLOCK_ROOT);
                if (!temp2) {
                    break;
                }

                reportEntry = JoinPaths (temp1, temp2);
                reportEntryIsResource = FALSE;

                FreeStringResource (temp1);
                FreeStringResource (temp2);
                break;

            default:
                LOG((LOG_ERROR, "Bad parameter found while processing control panel applets: %u", ActType));
                return FALSE;
            }

            if (!reportEntry) {

                LOG((LOG_ERROR, "Could not read resources while processing control panel applets: %u", ActType));
                break;

            } else {

                component = JoinPaths (reportEntry, displayName);

                MsgMgr_ObjectMsg_Add (FileName, component, Context ? Context->Message : NULL);

                FreePathString (component);

                if (reportEntryIsResource) {
                    FreeStringResource (reportEntry);
                } else {
                    FreePathString (reportEntry);
                    reportEntryIsResource = TRUE;
                }
                reportEntry = NULL;
            }

            if (padName) {
                FreeStringResourcePtrA (&displayName);
            } else {
                FreePathString (displayName);
            }

        } while (EnumNextMultiSz (&namesEnum));
    }
    FreeGrowBuffer (&friendlyName);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migdll9x\caller.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    caller.c

Abstract:

    Calls the entry points for a specific DLL.

Author:

    Jim Schmidt (jimschm) 14-Jan-1998

Revision History:

    jimschm     23-Sep-1998 Updated for new IPC mechanism

--*/

#include "pch.h"
#include "plugin.h"
#include "migdllp.h"

#define DBG_MIGDLLS "MigDLLs"

//
// Globals
//

PBYTE g_Data;
DWORD g_DataSize;
BOOL g_UseMigIsol = TRUE;

TCHAR g_OldDirectory[MAX_TCHAR_PATH];
HINSTANCE g_MigDllLib;
P_QUERY_VERSION TestQueryVersion;
P_INITIALIZE_9X TestInitialize9x;
P_MIGRATE_USER_9X TestMigrateUser9x;
P_MIGRATE_SYSTEM_9X TestMigrateSystem9x;
P_INITIALIZE_NT TestInitializeNT;
P_MIGRATE_USER_NT TestMigrateUserNT;
P_MIGRATE_SYSTEM_NT TestMigrateSystemNT;
PCSTR g_DllName;
CHAR g_DllPath[MAX_MBCHAR_PATH];

//
// Local prototypes
//

VOID
pFreeGlobalIpcBuffer (
    VOID
    );

DWORD
pFinishHandshake9x(
    VOID
    );

//
// Implementation
//


BOOL
OpenMigrationDll (
    IN      PCSTR MigrationDllPath,
    IN      PCSTR WorkingDir
    )
{
    CHAR MigIsolPath[MAX_MBCHAR_PATH];
    PCSTR TempDir;

    StringCopyA (g_DllPath, MigrationDllPath);
    if (!g_DllName) {
        g_DllName = g_DllPath;
    }

    GetCurrentDirectory (MAX_TCHAR_PATH, g_OldDirectory);

    if (!g_UseMigIsol) {

        //
        // Load the library and verify that all required functions exist
        //

        g_MigDllLib = LoadLibrary (MigrationDllPath);
        if (!g_MigDllLib) {
            return FALSE;
        }

        TestQueryVersion    = (P_QUERY_VERSION)     GetProcAddress (g_MigDllLib, PLUGIN_QUERY_VERSION);
        TestInitialize9x    = (P_INITIALIZE_9X)     GetProcAddress (g_MigDllLib, PLUGIN_INITIALIZE_9X);
        TestMigrateUser9x   = (P_MIGRATE_USER_9X)   GetProcAddress (g_MigDllLib, PLUGIN_MIGRATE_USER_9X);
        TestMigrateSystem9x = (P_MIGRATE_SYSTEM_9X) GetProcAddress (g_MigDllLib, PLUGIN_MIGRATE_SYSTEM_9X);
        TestInitializeNT    = (P_INITIALIZE_NT)     GetProcAddress (g_MigDllLib, PLUGIN_INITIALIZE_NT);
        TestMigrateUserNT   = (P_MIGRATE_USER_NT)   GetProcAddress (g_MigDllLib, PLUGIN_MIGRATE_USER_NT);
        TestMigrateSystemNT = (P_MIGRATE_SYSTEM_NT) GetProcAddress (g_MigDllLib, PLUGIN_MIGRATE_SYSTEM_NT);

        if (!TestQueryVersion ||
            !TestInitialize9x ||
            !TestMigrateUser9x ||
            !TestMigrateSystem9x ||
            !TestInitializeNT ||
            !TestMigrateUserNT ||
            !TestMigrateSystemNT
            ) {
            FreeLibrary (g_MigDllLib);
            g_MigDllLib = NULL;
            return FALSE;
        }

    } else {
        //
        // Generate path to migisol.exe, installed by the copy thread in UI
        //

        TempDir = ConvertAtoT (g_TempDir);
        MYASSERT (TempDir);
        wsprintfA (MigIsolPath, "%s\\%s", TempDir, S_MIGISOL_EXE);
        FreeAtoT (TempDir);

        if (!OpenIpc (
                TRUE,               // TRUE: Win95 side
                MigIsolPath,
                MigrationDllPath,
                WorkingDir
                )) {

            LOG ((
                LOG_WARNING,
                "Can't establish IPC connection for %s",
                MigrationDllPath
                ));


            return FALSE;
        }
    }

    return TRUE;
}


VOID
CloseMigrationDll (
    VOID
    )
{
    if (!g_UseMigIsol) {
        if (g_MigDllLib) {
            FreeLibrary (g_MigDllLib);
            g_MigDllLib = NULL;
        }

        SetCurrentDirectory (g_OldDirectory);

    } else {
        CloseIpc();
    }

    pFreeGlobalIpcBuffer();
}


BOOL
pValidateBinary (
    IN      PBYTE Data,
    IN      UINT Size
    )
{
    BYTE Remember;

    if (!Data || !Size) {
        return TRUE;
    }

    __try {
        Remember = Data[0];
        Data[0] = Remember;
        Remember = Data[Size - 1];
        Data[Size - 1] = Remember;
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_MIGDLLS, "pValidateBinary failed for %u bytes", Size));
        return FALSE;
    }

    return TRUE;
}

BOOL
pValidateNonNullString (
    IN      PCSTR String
    )
{
    __try {
        SizeOfStringA (String);
        if (*String == 0) {
            DEBUGMSG ((DBG_MIGDLLS, "pValidateNonNullString found zero-length string"));
            return FALSE;
        }
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_MIGDLLS, "pValidateNonNullString failed"));
        return FALSE;
    }

    return TRUE;
}

BOOL
pValidateIntArray (
    IN      PINT Array
    )
{
    PINT End;

    if (!Array) {
        return TRUE;
    }

    __try {
        End = Array;
        while (*End != -1) {
            End++;
        }
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_MIGDLLS, "Int Array is invalid (or not terminated with -1)"));
        return FALSE;
    }

    return TRUE;
}

BOOL
pValidateMultiString (
    IN      PCSTR Strings
    )
{
    if (!Strings) {
        return TRUE;
    }

    __try {
        while (*Strings) {
            Strings = GetEndOfStringA (Strings) + 1;
        }
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_MIGDLLS, "pValidateMultiString failed"));
        return FALSE;
    }

    return TRUE;
}


DWORD
pRemoteQueryVersion(
    OUT     PCSTR *ProductId,
    OUT     PUINT DllVersion,
    OUT     PDWORD *CodePageArray,
    OUT     PCSTR *ExeNamesBuf,
    IN      PCSTR WorkingDir,
    OUT     PVENDORINFO *VendorInfo
    )
{
    PBYTE DataPtr;
    INT ReturnArraySize;
    PDWORD ReturnArray;
    DWORD rc = ERROR_SUCCESS;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PCTSTR p;
    DWORD DataSize;

    //
    // Free any previous data... but do not free before we return, because the
    // new data buffer will be used directly by the caller.  (The caller will
    // make copies of all the settings.)
    //

    pFreeGlobalIpcBuffer();

    __try {

        //
        // Send the working directory, since migisol will need to set this before
        // calling QueryVersion.
        //

        MultiSzAppendA (&GrowBuf, WorkingDir);

        DEBUGMSG ((DBG_MIGDLLS, "Calling QueryVersion via migisol.exe"));

        if (!SendIpcCommand (
                IPC_QUERY,
                GrowBuf.Buf,
                GrowBuf.End
                )) {

            LOG ((LOG_ERROR,"pRemoteQueryVersion failed to send command"));
            rc = GetLastError();
            __leave;
        }

        //
        // Finish transaction. Caller will interpret return code.
        //

        DEBUGMSG ((DBG_MIGDLLS, "Getting results from migisol.exe"));

        rc = pFinishHandshake9x();

        //
        // Unpack the buffer, if received.
        //
        if (g_Data) {

            DEBUGMSG ((DBG_MIGDLLS, "Parsing QueryVersion return data"));

            __try {
                DataPtr = g_Data;

                //
                // Unpack product ID
                //
                *ProductId = DataPtr;
                DataPtr = GetEndOfStringA ((PCSTR) DataPtr) + 1;

                //
                // Unpack DLL version
                //
                *DllVersion = *((PINT) DataPtr);
                DataPtr += sizeof(INT);

                //
                // Unpack the CP array
                //
                ReturnArraySize = *((PINT) DataPtr);
                DataPtr += sizeof(INT);

                if (ReturnArraySize) {
                    ReturnArray = (PDWORD) DataPtr;
                    DataPtr += ReturnArraySize * sizeof (DWORD);
                } else {
                    ReturnArray = NULL;
                }

                *CodePageArray = ReturnArray;

                //
                // Unpack Exe name buffer
                //
                *ExeNamesBuf = (PCSTR) DataPtr;

                p = *ExeNamesBuf;
                while (*p) {
                    p = GetEndOfStringA (p) + 1;
                }
                DataPtr = (PBYTE) (p + 1);

                *VendorInfo = *((PVENDORINFO *) DataPtr);
                DataPtr += sizeof (PVENDORINFO);

                DEBUGMSG ((DBG_MIGDLLS, "Unpacked VendorInfo pointer is 0x%X", *VendorInfo));

                if (*VendorInfo) {
                    DataSize = *((PDWORD) DataPtr);
                    DataPtr += sizeof (DWORD);
                    MYASSERT (DataSize == sizeof (VENDORINFO));

                    *VendorInfo = (PVENDORINFO) PoolMemDuplicateMemory (g_MigDllPool, DataPtr, sizeof (VENDORINFO));
                    DataPtr += sizeof (VENDORINFO);
                }

                DEBUGMSG ((DBG_MIGDLLS, "QueryVersion is complete, rc=%u", rc));
            }

            __except(TRUE) {
                LOG ((LOG_ERROR, "An error occurred while unpacking params"));
                rc = ERROR_INVALID_PARAMETER;
            }
        } else {
            DEBUGMSG ((DBG_WARNING, "pRemoteQueryVersion: No OUT params received"));

            //
            // We should never return ERROR_SUCCESS if no buffer is received.
            //
            if (rc == ERROR_SUCCESS) {
                rc = ERROR_INVALID_PARAMETER;
            }
        }
    }
    __finally {
        FreeGrowBuffer (&GrowBuf);
    }

    return rc;
}


DWORD
pRemoteInitialize9x(
    IN      PCSTR WorkingDir,
    IN      PCSTR SourceDirs,
            PVOID *Reserved,
            DWORD SizeOfReserved
    )
{
    DWORD rc = ERROR_SUCCESS;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PCSTR p;
    PBYTE Data;
    DWORD ReturnSize;

    pFreeGlobalIpcBuffer();

    __try {
        //
        // Send working dir and source dirs
        //
        MultiSzAppendA (&GrowBuf, WorkingDir);

        for (p = SourceDirs ; *p ; p = GetEndOfStringA (p) + 1) {
            MultiSzAppendA (&GrowBuf, p);
        }

        MultiSzAppendA (&GrowBuf, p);
        GrowBufAppendDword (&GrowBuf, SizeOfReserved);

        if (SizeOfReserved) {
            Data = GrowBuffer (&GrowBuf, SizeOfReserved);
            CopyMemory (Data, *Reserved, SizeOfReserved);
        }

        //
        // Send command to migisol
        //

        if (!SendIpcCommand (
                IPC_INITIALIZE,
                GrowBuf.Buf,
                GrowBuf.End
                )) {

            LOG ((LOG_ERROR,"pRemoteInitialize9x failed to send command"));
            rc = GetLastError();
            __leave;
        }

        //
        // Finish transaction. Caller will interpret return code.
        //
        rc = pFinishHandshake9x();

        //
        // The reserved parameter may come back
        //

        if (g_Data) {
            Data = g_Data;
            ReturnSize = *((PDWORD) Data);
            if (ReturnSize) {
                Data += sizeof (DWORD);
                CopyMemory (*Reserved, Data, ReturnSize);
            } else if (SizeOfReserved) {
                ZeroMemory (*Reserved, SizeOfReserved);
            }
        }
    }
    __finally {
        FreeGrowBuffer (&GrowBuf);
    }

    return rc;
}


VOID
pGetParentWindowTitleAndId (
    IN      HWND ParentWnd,
    OUT     PSTR TitleBuf,
    OUT     PDWORD IdPtr
    )
{
    *IdPtr = 0;

    if (ParentWnd) {
        GetWindowTextA (ParentWnd, TitleBuf, MAX_PATH);
        GetWindowThreadProcessId (ParentWnd, IdPtr);
    } else {
        TitleBuf[0] = 0;
    }
}


DWORD
pRemoteMigrateUser9x (
        IN      HWND ParentWnd,             OPTIONAL
        IN      PCSTR UnattendFile,
        IN      PCSTR RootKey,
        IN      PCSTR User                  OPTIONAL
        )
{
    DWORD rc = ERROR_SUCCESS;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    CHAR ParentWindowTitle[MAX_PATH];
    DWORD ProcessId;

    pGetParentWindowTitleAndId (ParentWnd, ParentWindowTitle, &ProcessId);

    pFreeGlobalIpcBuffer();

    __try {
        MultiSzAppendA (&GrowBuf, ParentWindowTitle);
        GrowBufAppendDword (&GrowBuf, ProcessId);
        MultiSzAppendA (&GrowBuf, UnattendFile);
        MultiSzAppendA (&GrowBuf, RootKey);
        MultiSzAppendA (&GrowBuf, (NULL == User ? S_EMPTY : User));

        if (!SendIpcCommand (
                 IPC_MIGRATEUSER,
                 GrowBuf.Buf,
                 GrowBuf.End
                 )) {

            LOG ((LOG_ERROR, "pRemoteMigrateUser9x failed to send command"));
            rc = GetLastError();
            __leave;
        }

        //
        // Complete the transaction. The caller will interpret the return
        // value.
        //
        rc = pFinishHandshake9x();

        //
        // No data buffer is coming back at this time
        //
    }

    __finally {
        FreeGrowBuffer (&GrowBuf);
    }

    return rc;
}


DWORD
pRemoteMigrateSystem9x (
    IN      HWND ParentWnd,              OPTIONAL
    IN      PCSTR UnattendFile
    )
{
    DWORD rc = ERROR_SUCCESS;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    CHAR ParentWindowTitle[MAX_PATH];
    DWORD ProcessId;

    pGetParentWindowTitleAndId (ParentWnd, ParentWindowTitle, &ProcessId);

    pFreeGlobalIpcBuffer();

    __try {
        MultiSzAppendA (&GrowBuf, ParentWindowTitle);
        GrowBufAppendDword (&GrowBuf, ProcessId);
        MultiSzAppendA (&GrowBuf, UnattendFile);

        if (!SendIpcCommand (
                IPC_MIGRATESYSTEM,
                GrowBuf.Buf,
                GrowBuf.End
                )) {

            LOG ((LOG_ERROR,"pRemoteMigrateSystem9x failed to send command"));
            rc = GetLastError();
            __leave;
        }

        //
        // Finish transaction. Caller will interpret return value.
        //

        rc = pFinishHandshake9x();

        //
        // No data buffer is coming back at this time
        //
    }

    __finally {
        FreeGrowBuffer (&GrowBuf);
    }

    return rc;
}


VOID
pFreeGlobalIpcBuffer (
    VOID
    )
{
    //
    // Free old return param buffer
    //
    if (g_Data) {
        MemFree (g_hHeap, 0, g_Data);
        g_Data = NULL;
    }

    g_DataSize = 0;
}


DWORD
pFinishHandshake9x(
    VOID
    )
{
    DWORD TechnicalLogId;
    DWORD GuiLogId;
    DWORD rc = ERROR_SUCCESS;
    DWORD DataSize = 0;
    PBYTE Data = NULL;
    BOOL b;

    pFreeGlobalIpcBuffer();

    do {
        b = GetIpcCommandResults (
                IPC_GET_RESULTS_WIN9X,
                &Data,
                &DataSize,
                &rc,
                &TechnicalLogId,
                &GuiLogId
                );

        if (g_AbortDllEvent) {
            if (WaitForSingleObject (g_AbortDllEvent, 0) == WAIT_OBJECT_0) {
                rc = ERROR_CANCELLED;
                break;
            }
        }

        //
        // Loop if no data received, but process is alive
        //
        if (!b) {
            if (!IsIpcProcessAlive()) {
                rc = ERROR_NOACCESS;
                break;
            }

            if (*g_CancelFlagPtr) {
                rc = ERROR_CANCELLED;
                break;
            }
        }

    } while (!b);

    if (b) {
        //
        // Save return param block and loop back for IPC_LOG or IPC_DONE
        //

        g_DataSize = DataSize;
        g_Data = Data;

        //
        // Recognize log messages
        //
        if (!CANCELLED()) {
            if (TechnicalLogId) {

            //
            // LOG message with three args: DllDesc, DllPath, User
            //
                LOG ((
                    LOG_ERROR,
                    (PCSTR) TechnicalLogId,
                    g_DllPath,
                    g_DllName,
                    S_EMPTY,
                    S_EMPTY
                    ));
            }
            if (GuiLogId) {
                LOG ((
                    LOG_ERROR,
                    (PCSTR) GuiLogId,
                    g_DllPath,
                    g_DllName,
                    S_EMPTY,
                    S_EMPTY
                    ));
            }
        }
    }

    return rc;
}

BOOL
pIsCodePageArrayValid (
    IN      PDWORD CodePageArray
    )
{
    DWORD CodePage;
    UINT u;

    if (!CodePageArray) {
        return TRUE;
    }

    //
    // Scan system's code pages
    //

    CodePage = GetACP();

    __try {
        for (u = 0 ; CodePageArray[u] != -1 ; u++) {
            if (CodePage == CodePageArray[u]) {
                return TRUE;
            }
        }
    }
    __except (TRUE) {
        LOG ((LOG_ERROR, "Caugh an exception while validating array of code pages."));
    }

    return FALSE;
}


LONG
CallQueryVersion (
    IN      PCSTR WorkingDir,
    OUT     PCSTR *ProductId,
    OUT     PUINT DllVersion,
    OUT     PCSTR *ExeNamesBuf,
    OUT     PVENDORINFO *VendorInfo
    )
{
    PDWORD CodePageArray = NULL;
    LONG rc;

    if (!g_UseMigIsol) {
        //
        // Call the entry point directly
        //

        MYASSERT (TestQueryVersion);

        *ProductId = NULL;
        *DllVersion = 1;
        *ExeNamesBuf = NULL;
        *VendorInfo = NULL;

        SetCurrentDirectory (WorkingDir);

        rc = TestQueryVersion (
                ProductId,
                DllVersion,
                &CodePageArray,
                ExeNamesBuf,
                VendorInfo
                );

    } else {

        rc = pRemoteQueryVersion (
                  ProductId,
                  DllVersion,
                  &CodePageArray,
                  ExeNamesBuf,
                  WorkingDir,
                  VendorInfo
                  );

    }

    DEBUGMSG ((DBG_MIGDLLS, "VendorInfo pointer is 0x%X", *VendorInfo));

    if (rc == ERROR_SUCCESS) {
        //
        // Trim whitespace off of product ID
        //

        if (pValidateNonNullString (*ProductId)) {
            *ProductId = SkipSpace (*ProductId);
            if (pValidateBinary ((PBYTE) (*ProductId), SizeOfStringA (*ProductId))) {
                TruncateTrailingSpace ((PSTR) (*ProductId));
            }
        }

        //
        // Validate inbound parameters
        //

        if (!pValidateNonNullString (*ProductId) ||
            !pValidateIntArray (CodePageArray) ||
            !pValidateMultiString (*ExeNamesBuf) ||
            !pValidateBinary ((PBYTE) (*VendorInfo), sizeof (VENDORINFO))
            ) {
            LOG ((LOG_ERROR, "One or more parameters from the DLL are invalid."));
            return ERROR_NOT_INSTALLED;
        }

        if (!pIsCodePageArrayValid (CodePageArray)) {
            return ERROR_NOT_INSTALLED;
        }

        //
        // Trim the product ID
        //

        if (ByteCountA (*ProductId) > MAX_PATH) {
            *CharCountToPointerA (*ProductId, MAX_PATH) = 0;
        }

        //
        // Make sure VENDORINFO is valid
        //
        if (!(*VendorInfo)) {
            LOG ((LOG_ERROR, "DLL %s did not provide a VENDORINFO struct", *ProductId));
            return ERROR_NOT_INSTALLED;
        }

        g_DllName = *ProductId;
    }

    return rc;
}


LONG
CallInitialize9x (
    IN      PCSTR WorkingDir,
    IN      PCSTR SourceDirList,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    )
{
    LONG rc;
    CHAR WorkingDirCopy[MAX_MBCHAR_PATH];
    PSTR SourceDirListCopy = NULL;
    PCSTR p;
    PVOID CopyOfReserved;

    if (!g_UseMigIsol) {
        //
        // Call the entry point directly
        //

        MYASSERT (TestInitialize9x);

        SetCurrentDirectory (WorkingDir);

        //
        // Make a copy of all the supplied params, so if the migration DLL changes
        // them, the rest of the upgrade isn't changed.
        //

        StringCopyA (WorkingDirCopy, WorkingDir);
        p = SourceDirList;
        while (*p) {
            p = GetEndOfStringA (p) + 1;
        }
        p++;

        SourceDirListCopy = AllocText (p - SourceDirList);
        MYASSERT (SourceDirListCopy);
        if (SourceDirListCopy) {
            CopyMemory (SourceDirListCopy, SourceDirList, p - SourceDirList);
        }

        //
        // Call the entry point
        //

        rc = TestInitialize9x (
                WorkingDirCopy,
                SourceDirListCopy,
                Reserved
                );

        FreeText (SourceDirListCopy);

    } else {

        //
        // Call the entry point via migisol.exe.  Make a copy of the
        // reserved because currently reserved is only an IN (an
        // undocumented feature actually).
        //

        CopyOfReserved = MemAlloc (g_hHeap, 0, ReservedSize);
        CopyMemory (CopyOfReserved, Reserved, ReservedSize);

        rc = pRemoteInitialize9x (
                  WorkingDir,
                  SourceDirList,
                  &CopyOfReserved,
                  ReservedSize
                  );

        //
        // CopyOfReserved now has the return value.  We don't
        // use it currently.
        //

        MemFree (g_hHeap, 0, CopyOfReserved);

    }

    return rc;
}


LONG
CallMigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UserName,
    IN      PCSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    )
{
    LONG rc;
    CHAR UserNameBuf[MAX_USER_NAME];
    CHAR UnattendTxtCopy[MAX_USER_NAME];
    PSTR UserNameCopy = NULL;
    HKEY UserHandle;

    if (!g_UseMigIsol) {
        //
        // Call the entry point directly
        //

        MYASSERT (TestMigrateUser9x);

        //
        // Prepare copies of params
        //

        if (UserName && *UserName) {
            UserNameCopy = UserNameBuf;
            StringCopyA (UserNameCopy, UserName);
        }

        StringCopyA (UnattendTxtCopy, UnattendTxt);

        MYASSERT(g_UserKey);
        if (!g_UserKey) {
            g_UserKey = S_EMPTY;
        }

        UserHandle = OpenRegKeyStr (g_UserKey);
        if (!UserHandle) {
            DEBUGMSG ((DBG_WHOOPS, "Cannot open %s", g_UserKey));
            return FALSE;
        }

        //
        // Call the migration DLL
        //

        rc = TestMigrateUser9x (
                ParentWnd,
                UnattendTxtCopy,
                UserHandle,
                UserNameCopy,
                Reserved
                );

    } else {
        //
        // Call the entry point via migisol.exe
        //

        rc = pRemoteMigrateUser9x (
                  ParentWnd,
                  UnattendTxt,
                  g_UserKey,
                  UserName
                  );
    }

    return rc;
}


LONG
CallMigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendTxt,
    IN      PVOID Reserved,
    IN      DWORD ReservedSize
    )
{
    LONG rc;
    CHAR UnattendTxtCopy[MAX_MBCHAR_PATH];

    if (!g_UseMigIsol) {
        //
        // Call the entry point directly
        //

        MYASSERT (TestMigrateSystem9x);

        StringCopyA (UnattendTxtCopy, UnattendTxt);

        rc = TestMigrateSystem9x (
                 ParentWnd,
                 UnattendTxtCopy,
                 Reserved
                 );

    } else {

        rc = pRemoteMigrateSystem9x (
                  ParentWnd,
                  UnattendTxt
                  );

    }

    g_DllName = NULL;

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migdll9x\migdll9x.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migdll9x.c

Abstract:

    Implements migration DLL interface for the Win9x side of the upgrade.

Author:

    Jim Schmidt (jimschm) 13-Jan-1998

Revision History:

    jimschm     23-Sep-1998 Updated for new IPC mechanism

--*/

#include "pch.h"
#include "plugin.h"
#include "migdllp.h"
#include "dbattrib.h"

#include <ntverp.h>

// This file has mixed mbcs and tchar code; this was because
// some code was ported from the original MikeCo implementation,
// and it is now clear that this file will always be an ANSI compile.
#ifdef UNICODE
#error UNICODE cannot be defined
#endif

#define DBG_MIGDLLS     "MigDLLs"


//
// Globals
//

PVOID g_DllTable;
PVOID g_DllFileTable;
POOLHANDLE g_MigDllPool;
PSTR g_MessageBuf;
PMIGRATION_DLL_PROPS g_HeadDll;
CHAR g_MigDllAnswerFile[MAX_MBCHAR_PATH];
CHAR g_MigrateInfTemplate[MAX_MBCHAR_PATH];
GROWBUFFER g_SourceDirList = GROWBUF_INIT;
UINT g_MigDllsAlive;
HANDLE g_AbortDllEvent;
BOOL g_ProgressBarExists;
WINVERIFYTRUST WinVerifyTrustApi;
HANDLE g_WinTrustDll;
UINT g_TotalDllsToProcess;
BOOL g_MediaDllsQueried;
HASHTABLE g_ExcludedMigDlls = NULL;
GROWLIST g_ExcludedMigDllsByInfo = GROWLIST_INIT;

#define MAX_MESSAGE     8192

#define S_HARDWARE_IN_WACKS     "\\Hardware\\"
#define S_HARDWARE_CHARS        10


typedef struct {
    UINT MsgId;
    PCSTR Variable;
    PCSTR LocalizedName;
} MSG_VARIABLE, *PMSG_VARIABLE;

MSG_VARIABLE g_MsgVarTable[] = {
    { 0, "%OriginalOsName%", g_Win95Name },
    { MSG_SHORT_OS_NAME, "%ShortTargetOsName%", NULL },
    { MSG_NORMAL_OS_NAME, "%TargetOsName%", NULL },
    { MSG_FULL_OS_NAME, "%CompleteOsName%", NULL },
    { 0, NULL, NULL }
};

#define MESSAGE_VARIABLES   ((sizeof (g_MsgVarTable) / sizeof (g_MsgVarTable[0])) - 1)

PMAPSTRUCT g_MsgVariableMap;


//
// Implementation
//

BOOL
WINAPI
MigDll9x_Entry (
    IN      HINSTANCE DllInstance,
    IN      DWORD Reason,
    IN      PVOID Reserved
    )

/*++

Routine Description:

  This is a DllMain-like init funciton, called at process attach and detach.

Arguments:

  DllInstance - (OS-supplied) instance handle for the DLL

  Reason - (OS-supplied) indicates attach or detatch from process or
           thread

  Reserved - unused

Return Value:

  TRUE if initialization succeeded, or FALSE if it failed.

--*/

{
    TCHAR PathBuf[16384];
    TCHAR CurDir[MAX_TCHAR_PATH];
    PTSTR p;

    if (g_ToolMode) {
        return TRUE;
    }

    switch (Reason) {

    case DLL_PROCESS_ATTACH:
        if(!pSetupInitializeUtils()) {
            return FALSE;
        }
        g_DllTable = pSetupStringTableInitializeEx (sizeof (PMIGRATION_DLL_PROPS), 0);
        if (!g_DllTable) {
            return FALSE;
        }

        g_DllFileTable = pSetupStringTableInitializeEx (sizeof (PMIGRATION_DLL_PROPS), 0);
        if (!g_DllFileTable) {
            return FALSE;
        }

        g_MigDllPool = PoolMemInitNamedPool ("Migration DLLs - 95 side");
        if (!g_MigDllPool) {
            return FALSE;
        }

        g_MessageBuf = PoolMemGetMemory (g_MigDllPool, MAX_MESSAGE);
        if (!g_MessageBuf) {
            return FALSE;
        }

        g_HeadDll = NULL;

        g_WinTrustDll = LoadLibrary ("wintrust.dll");
        if (g_WinTrustDll) {
            (FARPROC) WinVerifyTrustApi = GetProcAddress (g_WinTrustDll, "WinVerifyTrust");
        }

        GetModuleFileName (g_hInst, CurDir, MAX_TCHAR_PATH);
        p = _tcsrchr (CurDir, TEXT('\\'));
        MYASSERT (p);

        if (p) {
            MYASSERT (StringIMatch (p + 1, TEXT("w95upg.dll")));
            *p = 0;
        }

        if (!GetEnvironmentVariable (
                TEXT("Path"),
                PathBuf,
                sizeof (PathBuf) / sizeof (PathBuf[0])
                )) {

            StackStringCopy (PathBuf, CurDir);

        } else {

            p = (PTSTR) ((PBYTE) PathBuf + sizeof (PathBuf) - MAX_TCHAR_PATH);
            *p = 0;

            p = _tcsrchr (PathBuf, TEXT(';'));
            if (!p || p[1]) {
                StringCat (PathBuf, TEXT(";"));
            }

            StringCat (PathBuf, CurDir);
        }

        SetEnvironmentVariable (TEXT("Path"), PathBuf);

        break;


    case DLL_PROCESS_DETACH:
        if (g_DllTable) {
            pSetupStringTableDestroy (g_DllTable);
            g_DllTable = NULL;
        }

        if (g_DllFileTable) {
            pSetupStringTableDestroy (g_DllFileTable);
            g_DllFileTable = NULL;
        }

        if (g_MigDllPool) {
            PoolMemDestroyPool (g_MigDllPool);
            g_MigDllPool = NULL;
        }

        if (g_WinTrustDll) {
            FreeLibrary (g_WinTrustDll);
            g_WinTrustDll = NULL;
        }

        DestroyStringMapping (g_MsgVariableMap);

        pSetupUninitializeUtils();

        break;
    }

    return TRUE;
}


BOOL
pTextToInt (
    IN      PCTSTR Text,
    OUT     PINT Number
    )
{
    return _stscanf (Text, TEXT("%i"), Number) == 1;
}



BOOL
BeginMigrationDllProcessing (
    VOID
    )

/*++

Routine Description:

  BeginMigrationDllProcessing initializes the global variables needed to
  implement the migration DLL spec.  It is called during deferred init.

Arguments:

  none

Return Value:

  TRUE if init succeeded, or FALSE if an error occurred.

--*/

{
    HANDLE h;
    CHAR Buffer[4096];
    UINT i;
    PGROWBUFFER MsgAllocTable;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PTSTR productId, versionStr;
    UINT version;

#ifdef PRERELEASE

    if (g_ConfigOptions.DiffMode) {
        TakeSnapShot();
    }

#endif

    if (InfFindFirstLine (g_Win95UpgInf, S_EXCLUDEDMIGRATIONDLLS, NULL, &is)) {

        g_ExcludedMigDlls = HtAllocWithData (sizeof (UINT));
        if (!g_ExcludedMigDlls) {
            return FALSE;
        }

        do {
            productId = InfGetStringField (&is, 1);
            versionStr = InfGetStringField (&is, 2);

            if (!productId || !*productId ||
                !versionStr || !(version = _ttol (versionStr))
                ) {
                DEBUGMSG ((DBG_ERROR, "Error in win95upg.inf section %s", S_EXCLUDEDMIGRATIONDLLS));
                continue;
            }

            HtAddStringAndData (g_ExcludedMigDlls, productId, &version);

        } while (InfFindNextLine (&is));

        InfCleanUpInfStruct (&is);
    }

    if (InfFindFirstLine (g_Win95UpgInf, S_EXCLUDEDMIGDLLSBYATTR, NULL, &is)) {

        do {
            PCTSTR Attributes;
            PMIGDB_ATTRIB migDbAttrib = NULL;

            Attributes = InfGetMultiSzField(&is, 1);

            if (!Attributes) {
                DEBUGMSG ((DBG_ERROR, "Error in win95upg.inf section %s line %u", S_EXCLUDEDMIGDLLSBYATTR, is.Context.Line));
                continue;
            }

            migDbAttrib = LoadAttribData(Attributes, g_MigDllPool);
            if(!migDbAttrib){
                MYASSERT(FALSE);
                continue;
            }

            GrowListAppend (&g_ExcludedMigDllsByInfo, (PBYTE)&migDbAttrib, sizeof(PMIGDB_ATTRIB));

        } while (InfFindNextLine (&is));

        InfCleanUpInfStruct (&is);
    }

    //
    // Fill in all the resource strings
    //

    g_MsgVariableMap = CreateStringMapping();

    MsgAllocTable = CreateAllocTable();
    MYASSERT (MsgAllocTable);

    for (i = 0 ; g_MsgVarTable[i].Variable ; i++) {

        if (g_MsgVarTable[i].MsgId) {

            MYASSERT (!g_MsgVarTable[i].LocalizedName);

            g_MsgVarTable[i].LocalizedName = GetStringResourceEx (
                                                    MsgAllocTable,
                                                    g_MsgVarTable[i].MsgId
                                                    );

            MYASSERT (g_MsgVarTable[i].LocalizedName);
            if (g_MsgVarTable[i].LocalizedName) {
                AddStringMappingPair (
                    g_MsgVariableMap,
                    g_MsgVarTable[i].Variable,
                    g_MsgVarTable[i].LocalizedName
                    );
            }
        } else {
            AddStringMappingPair (
                g_MsgVariableMap,
                g_MsgVarTable[i].Variable,
                g_MsgVarTable[i].LocalizedName
                );
        }
    }

    DestroyAllocTable (MsgAllocTable);

    //
    // Global init
    //

    g_MigDllsAlive = 0;

    //
    // Build source dirs
    //

    for (i = 0 ; i < SOURCEDIRECTORYCOUNT(); i++) {
        MultiSzAppend (&g_SourceDirList, SOURCEDIRECTORY(i));
    }

    //
    // Generate a private copy of the answer file
    //

    wsprintf (g_MigDllAnswerFile, "%s\\unattend.tmp", g_TempDir);

    if (g_UnattendScriptFile && *g_UnattendScriptFile && **g_UnattendScriptFile) {
        if (!CopyFile (*g_UnattendScriptFile, g_MigDllAnswerFile, FALSE)) {
            LOG ((LOG_ERROR, "Can't copy %s to %s", *g_UnattendScriptFile, g_MigDllAnswerFile));
            return FALSE;
        }
    } else {
        h = CreateFile (
                g_MigDllAnswerFile,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

        if (h == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "Unable to create %s", g_MigDllAnswerFile));
            return FALSE;
        }

        WriteFileString (h, "[Version]\r\nSignature = $Windows NT$\r\n\r\n");

        CloseHandle (h);
    }

    //
    // Generate stub of migrate.inf
    //

    wsprintf (g_MigrateInfTemplate, "%s\\migrate.tmp", g_TempDir);

    h = CreateFile (
            g_MigrateInfTemplate,
            GENERIC_READ|GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if (h == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Unable to create %s", g_MigrateInfTemplate));
        return FALSE;
    }

    //
    // Generate header of migrate.inf
    //

    MYASSERT (g_ProductFlavor);
    wsprintf (
        Buffer,
        "[Version]\r\n"
            "Signature = $Windows NT$\r\n"
            "SetupOS = %s\r\n"
            "SetupPlatform = %s\r\n"
            "SetupSKU = %s\r\n"
            "SetupBuild = %u\r\n"
            ,
        VER_PRODUCTNAME_STR,
        S_WORKSTATIONA,
        *g_ProductFlavor == PERSONAL_PRODUCTTYPE ? S_PERSONALA : S_PROFESSIONALA,
        VER_PRODUCTBUILD
        );

    WriteFileString (h, Buffer);
    CloseHandle (h);

    return TRUE;
}


BOOL
pEndMigrationDllProcessing (
    VOID
    )

/*++

Routine Description:

  EndMigrationDllProcessing cleans up all the resources used to process
  migration DLLs.  It is called before the incompatibility report is
  displayed, and after all DLLs have been processed.

Arguments:

  none

Return Value:

  TRUE if processing completed, or FALSE if an error occurred.

--*/

{
    MIGDLL_ENUM e;
    CHAR FullPath[MAX_MBCHAR_PATH];
    UINT Sequencer = 0;
    CHAR SeqStr[16];
    BOOL b = FALSE;
    PCTSTR group;
    INT i;
    PMIGDB_ATTRIB * ppMigDBattrib;

    __try {

        g_ProgressBarExists = TRUE;

        if (g_ExcludedMigDlls) {
            HtFree (g_ExcludedMigDlls);
            g_ExcludedMigDlls = NULL;
        }

        for(i = GrowListGetSize(&g_ExcludedMigDllsByInfo) - 1; i >= 0; i--){
            ppMigDBattrib = (PMIGDB_ATTRIB *)GrowListGetItem(&g_ExcludedMigDllsByInfo, i);
            MYASSERT(ppMigDBattrib);
            FreeAttribData(g_MigDllPool, *ppMigDBattrib);
        }

        FreeGrowList (&g_ExcludedMigDllsByInfo);

        //
        // Write list of DLLs to memdb
        //

        if (EnumFirstMigrationDll (&e)) {
            do {
                if (e.AllDllProps->WantsToRunOnNt) {
                    wsprintf (FullPath, "%s\\migrate.dll", e.AllDllProps->WorkingDir);
                    wsprintf (SeqStr, "%u", Sequencer);
                    Sequencer++;

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_MIGRATION_DLL,
                        SeqStr,
                        MEMDB_FIELD_DLL,
                        FullPath,
                        0,
                        NULL
                        );

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_MIGRATION_DLL,
                        SeqStr,
                        MEMDB_FIELD_WD,
                        e.AllDllProps->WorkingDir,
                        0,
                        NULL
                        );

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_MIGRATION_DLL,
                        SeqStr,
                        MEMDB_FIELD_DESC,
                        e.AllDllProps->ProductId,
                        0,
                        NULL
                        );

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_MIGRATION_DLL,
                        SeqStr,
                        MEMDB_FIELD_COMPANY_NAME,
                        e.AllDllProps->VendorInfo->CompanyName,
                        0,
                        NULL
                        );

                    if (*e.AllDllProps->VendorInfo->SupportNumber) {
                        MemDbSetValueEx (
                            MEMDB_CATEGORY_MIGRATION_DLL,
                            SeqStr,
                            MEMDB_FIELD_SUPPORT_PHONE,
                            e.AllDllProps->VendorInfo->SupportNumber,
                            0,
                            NULL
                            );
                    }

                    if (*e.AllDllProps->VendorInfo->SupportUrl) {
                        MemDbSetValueEx (
                            MEMDB_CATEGORY_MIGRATION_DLL,
                            SeqStr,
                            MEMDB_FIELD_SUPPORT_URL,
                            e.AllDllProps->VendorInfo->SupportUrl,
                            0,
                            NULL
                            );
                    }

                    if (*e.AllDllProps->VendorInfo->InstructionsToUser) {
                        MemDbSetValueEx (
                            MEMDB_CATEGORY_MIGRATION_DLL,
                            SeqStr,
                            MEMDB_FIELD_SUPPORT_INSTRUCTIONS,
                            e.AllDllProps->VendorInfo->InstructionsToUser,
                            0,
                            NULL
                            );
                    }

                    if (g_ConfigOptions.ShowPacks) {

                        //
                        // Add a message in the incompatibility report for the pack.
                        //
                        group = BuildMessageGroup (
                                    MSG_INSTALL_NOTES_ROOT,
                                    MSG_RUNNING_MIGRATION_DLLS_SUBGROUP,
                                    e.AllDllProps->ProductId
                                    );

                        if (group) {

                            MsgMgr_ObjectMsg_Add (
                                e.AllDllProps->ProductId,
                                group,
                                S_EMPTY
                                );


                            FreeText (group);
                        }
                    }
                }

            } while (EnumNextMigrationDll (&e));
        }

        if (!MergeMigrationDllInf (g_MigDllAnswerFile)) {
            __leave;
        }

        b = TRUE;
    }
    __finally {
        DeleteFile (g_MigDllAnswerFile);
        DeleteFile (g_MigrateInfTemplate);
        FreeGrowBuffer (&g_SourceDirList);

        g_ProgressBarExists = FALSE;
    }

#ifdef PRERELEASE

    if (g_ConfigOptions.DiffMode) {
        CHAR szMigdllDifPath[] = "c:\\migdll.dif";
        if (ISPC98()) {
            szMigdllDifPath[0] = (CHAR)g_SystemDir[0];
        }
        GenerateDiffOutputA (szMigdllDifPath, NULL, FALSE);
    }

#endif

    return b;
}


DWORD
EndMigrationDllProcessing (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_END_MIGRATION_DLL_PROCESSING;
    case REQUEST_RUN:
        if (!pEndMigrationDllProcessing ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in EndMigrationDllProcessing"));
    }
    return 0;
}


BOOL
pIsPathLegal (
    PCTSTR Path
    )
{
    UINT Chars;
    CHARTYPE ch;
    static UINT TempDirLen = 0;

    // loop optimization, relies on fact that we never change g_TempDir
    if (!TempDirLen) {
        TempDirLen = CharCount (g_TempDir);
    }

    //
    // Determine if path is a containment case of the setup temp dir
    //

    Chars = min (CharCount (Path), TempDirLen);
    if (StringIMatchCharCount (Path, g_TempDir, Chars)) {
        ch = _tcsnextc (CharCountToPointer (Path, Chars));
        if (!ch || ch == TEXT('\\')) {
            return FALSE;
        }
    }

    return TRUE;
}


UINT
ScanPathForMigrationDlls (
    IN      PCSTR PathSpec,
    IN      HANDLE CancelEvent,     OPTIONAL
    OUT     PBOOL MatchFound        OPTIONAL
    )

/*++

Routine Description:

  ScanPathForMigrationDlls searches the specified path, including all
  subdirectories, for migrate.dll.  If found, the entry points are
  verified, and if all exist, QueryVersion is called.  When Queryversion
  succeeds, the DLL is added to the list of DLLs and is moved to
  local storage.

Arguments:

  PathSpec - Specifies the directory to search.  Must be a complete
             path.

  CancelEvent - Specifies the handle of an event that causes migration DLL
                searching to be canceled.

  MatchFound - Receives TRUE if a migrate.dll was found and QueryVersion
               was called, or FALSE if no migrate.dll was found.  This is
               used to distinguish between loaded DLLs and unneeded DLLs.

Return Value:

  The number of migrate.dll modules successfully loaded.

--*/

{
    TREE_ENUMA e;
    UINT DllsFound = 0;
    DWORD rc = ERROR_SUCCESS;

    g_AbortDllEvent = CancelEvent;

    if (MatchFound) {
        *MatchFound = FALSE;
    }

    if (EnumFirstFileInTree (&e, PathSpec, "migrate.dll", FALSE)) {
        do {
            //
            // Check for user cancel
            //

            if (CancelEvent) {
                if (WaitForSingleObject (CancelEvent, 0) == WAIT_OBJECT_0) {
                    rc = ERROR_CANCELLED;
                    break;
                }
            }

            if (CANCELLED()) {
                rc = ERROR_CANCELLED;
                break;
            }

            if (e.Directory) {
                continue;
            }

            //
            // Don't allow scan of our temp dir!
            //

            if (!pIsPathLegal (e.FullPath)) {
                continue;
            }

            //
            // Found DLL -- see if it's real, then move it to local
            // storage.
            //

            DEBUGMSG ((DBG_MIGDLLS, "Found DLL: %hs", e.FullPath));

            if (pValidateAndMoveDll (e.FullPath, MatchFound)) {
                DllsFound++;
                if (g_ProgressBarExists) {
                    TickProgressBar ();
                }
            } else {
                rc = GetLastError();
                if (rc != ERROR_SUCCESS) {
                    break;
                }
            }

        } while (EnumNextFileInTree (&e));

        if (rc != ERROR_SUCCESS) {
            AbortEnumFileInTree (&e);
        }
    }

    g_AbortDllEvent = NULL;

    if (g_ProgressBarExists) {
        TickProgressBar ();
    }

    SetLastError (rc);
    return DllsFound;
}


BOOL
pProcessAllLocalDlls (
    VOID
    )

/*++

Routine Description:

  ProcessAllLocalDlls processes all the DLLs that were moved to local
  storage.  It enumerates each DLL, then calls ProcessDll.  This
  function also allows the user to cancel Setup in the middle of
  processing.

Arguments:

  none

Return Value:

  Returns TRUE if all DLLs were processed, or FALSE if an error occurred.
  If FALSE is returned, call GetLastError to determine the reason for
  failure.

--*/

{
    MIGDLL_ENUM e;
    UINT DllsProcessed = 0;

    g_ProgressBarExists = TRUE;

    if (EnumFirstMigrationDll (&e)) {
        do {
            if (!ProgressBar_SetSubComponent (e.ProductId)) {
                SetLastError (ERROR_CANCELLED);
                return FALSE;
            }

            if (!ProcessDll (&e)) {
                e.AllDllProps->WantsToRunOnNt = FALSE;

                if (GetLastError() != ERROR_SUCCESS) {
                    return FALSE;
                }
            }

            TickProgressBarDelta (TICKS_MIGDLL_DELTA);
            DllsProcessed++;

        } while (EnumNextMigrationDll (&e));
    }

    // Adjust for difference of DLLs on media that were not processed
    TickProgressBarDelta ((g_TotalDllsToProcess - DllsProcessed) * TICKS_MIGDLL_DELTA);

    g_ProgressBarExists = FALSE;

    return TRUE;
}


DWORD
ProcessAllLocalDlls (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        g_TotalDllsToProcess = GetTotalMigrationDllCount();
        return (g_TotalDllsToProcess * TICKS_MIGDLL_DELTA);

    case REQUEST_RUN:
        if (!pProcessAllLocalDlls ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in ProcessAllLocalDlls"));
    }
    return 0;
}


BOOL
pEnumPreLoadedDllWorker (
    IN OUT  PPRELOADED_DLL_ENUM e
    )
{
    PCTSTR Data;
    BOOL b = FALSE;
    PTSTR p;

    //
    // Suppressed?
    //

    MemDbBuildKey (
        e->Node,
        MEMDB_CATEGORY_DISABLED_MIGDLLS,
        NULL,                                   // no item
        NULL,                                   // no field
        e->eValue.ValueName
        );

    if (!MemDbGetValue (e->Node, NULL)) {
        //
        // Not suppressed.  Contains legal path?
        //

        Data = GetRegValueString (e->Key, e->eValue.ValueName);
        if (Data) {
            _tcssafecpy (e->Path, Data, MAX_TCHAR_PATH);
            p = _tcsrchr (e->Path, TEXT('\\'));
            if (p && StringIMatch (_tcsinc (p), TEXT("migrate.dll"))) {
                *p = 0;
            }

            MemFree (g_hHeap, 0, Data);

            b = pIsPathLegal (e->Path);
        }
    }

    return b;
}


BOOL
EnumFirstPreLoadedDll (
    OUT     PPRELOADED_DLL_ENUM e
    )
{
    ZeroMemory (e, sizeof (PRELOADED_DLL_ENUM));

    e->Key = OpenRegKeyStr (S_PREINSTALLED_MIGRATION_DLLS);
    if (!e->Key) {
        return FALSE;
    }

    if (!EnumFirstRegValue (&e->eValue, e->Key)) {
        AbortPreLoadedDllEnum (e);
        return FALSE;
    }

    //
    // Find first reg value that has a legal path
    //

    while (!pEnumPreLoadedDllWorker (e)) {
        if (!EnumNextRegValue (&e->eValue)) {
            AbortPreLoadedDllEnum (e);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
EnumNextPreLoadedDll (
    IN OUT  PPRELOADED_DLL_ENUM e
    )
{
    do {
        if (!EnumNextRegValue (&e->eValue)) {
            AbortPreLoadedDllEnum (e);
            return FALSE;
        }
    } while (!pEnumPreLoadedDllWorker (e));

    return TRUE;
}


VOID
AbortPreLoadedDllEnum (
    IN OUT  PPRELOADED_DLL_ENUM e
    )
{
    if (e->Key) {
        CloseRegKey (e->Key);
    }

    ZeroMemory (e, sizeof (PRELOADED_DLL_ENUM));
}


BOOL
pProcessDllsOnCd (
    VOID
    )

/*++

Routine Description:

  ProcessDllsOnCd scans all source directories for migration DLLs.
  Each one found is moved to local storage.

Arguments:

  none

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.

--*/

{
    UINT u;
    CHAR Path[MAX_MBCHAR_PATH];
    PCSTR p;
    BOOL b = FALSE;
    PRELOADED_DLL_ENUM e;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PTSTR Subdir = NULL;

#ifdef PRERELEASE

    if (g_ConfigOptions.DiffMode) {
        return TRUE;
    }

#endif

    //
    // Build path for each source dir, scan the dir for migration DLLs,
    // and watch for any failures.
    //

    g_ProgressBarExists = TRUE;

    __try {

        //
        // Process cmdline DLLs the very first
        //
        p = g_ConfigOptions.MigrationDlls;
        if (p) {
            while (*p) {
                if (CANCELLED()) {
                    SetLastError (ERROR_CANCELLED);
                    __leave;
                }

                ScanPathForMigrationDlls (p, NULL, NULL);

                if (GetLastError() != ERROR_SUCCESS) {
                    __leave;
                }

                p = GetEndOfString (p) + 1;
            }
        }

        //
        // Process pre-loaded DLLs first to give them a chance to register stuff
        // before "standard" migdlls run
        //

        if (EnumFirstPreLoadedDll (&e)) {
            do {
                if (CANCELLED()) {
                    SetLastError (ERROR_CANCELLED);
                    __leave;
                }

                ScanPathForMigrationDlls (e.Path, NULL, NULL);

                if (GetLastError() != ERROR_SUCCESS) {
                    __leave;
                }
            } while (EnumNextPreLoadedDll (&e));
        }

        for (u = 0 ; u < SOURCEDIRECTORYCOUNT() ; u++) {

            if (CANCELLED()) {
                SetLastError (ERROR_CANCELLED);
                __leave;
            }

            //
            // We look for migration dlls in all of the directories listed in
            // win95upg.inf [MigrationDllPaths].
            //
            if (InfFindFirstLine (g_Win95UpgInf, S_CD_MIGRATION_DLLS, NULL, &is)) {

                do {

                    Subdir = InfGetStringField (&is, 0);

                    if (!Subdir) {
                        continue;
                    }


                    wsprintf (Path, "%s\\%s", SOURCEDIRECTORY(u), Subdir);

                    if (GetFileAttributes (Path) == INVALID_ATTRIBUTES) {
                        //
                        // Try the non-cd layout.
                        //
                        wsprintf (Path, "%s\\WINNT32\\%s", SOURCEDIRECTORY(u), Subdir);
                        if (GetFileAttributes (Path) == INVALID_ATTRIBUTES) {
                            continue;
                        }
                    }
                    SetLastError (ERROR_SUCCESS);

                    ScanPathForMigrationDlls (Path, NULL, NULL);

                } while (InfFindNextLine (&is));
            }

            if (GetLastError() != ERROR_SUCCESS && GetLastError() != ERROR_LINE_NOT_FOUND) {
                __leave;
            }

        }

        InfCleanUpInfStruct (&is);

        b = TRUE;
    }
    __finally {
        g_ProgressBarExists = FALSE;
        g_MediaDllsQueried = TRUE;
    }

    return b;
}

DWORD
ProcessDllsOnCd (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:

#ifdef PRERELEASE

        if (g_ConfigOptions.DiffMode) {
            return 0;
        }

#endif
        return (GetMediaMigrationDllCount() * TICKS_MIGDLL_QUERYVERSION);

    case REQUEST_RUN:
        if (!pProcessDllsOnCd ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }

    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in ProcessDllsOnCd"));
    }
    return 0;
}


UINT
pCountMigrateDllsInPath (
    IN      PCSTR Path
    )

/*++

Routine Description:

  pCountMigrateDllsInPath scans a path for files named migrate.dll
  and returns the number found.

Arguments:

  Path - Specifies root of the path to search

Return Value:

  The number of migrate.dll modules found in the path.

--*/

{
    TREE_ENUM e;
    UINT Count = 0;

    if (EnumFirstFileInTree (&e, Path, "migrate.dll", FALSE)) {
        do {
            if (CANCELLED()) {
                return 0;
            }

            if (!e.Directory) {
                Count++;
            }
        } while (EnumNextFileInTree (&e));
    }

    return Count;
}


UINT
GetMediaMigrationDllCount (
    VOID
    )

/*++

Routine Description:

  GetMediaMigrationDllCount scans all the source directories, registry and
  unattended directories and returns the number of migrate.dll files found.

Arguments:

  none

Return Value:

  The number of migrate.dll modules found in the source directories and
  directories supplied by the answer file.

--*/

{
    UINT u;
    CHAR Path[MAX_MBCHAR_PATH];
    PCSTR p;
    BOOL TurnItOff = FALSE;
    PRELOADED_DLL_ENUM e;
    static UINT MediaDlls = 0;

    if (MediaDlls) {
        return MediaDlls;
    }

    //
    // Build path for each source dir, scan the dir for migration DLLs,
    // and watch for any failures.
    //

    __try {
        p = g_ConfigOptions.MigrationDlls;
        if (SOURCEDIRECTORYCOUNT() > 1 || (p && *p)) {
            TurnOnWaitCursor();
            TurnItOff = TRUE;
        }

        for (u = 0 ; u < SOURCEDIRECTORYCOUNT() ; u++) {
            if (CANCELLED()) {
                SetLastError (ERROR_CANCELLED);
                __leave;
            }

            wsprintf (Path, "%s\\win9xmig", SOURCEDIRECTORY(u));
            MediaDlls += pCountMigrateDllsInPath (Path);
        }

        if (p) {
            while (*p) {
                if (CANCELLED()) {
                    SetLastError (ERROR_CANCELLED);
                    __leave;
                }

                MediaDlls += pCountMigrateDllsInPath (p);

                p = GetEndOfString (p) + 1;
            }
        }

        //
        // Count pre-loaded DLLs
        //

        if (EnumFirstPreLoadedDll (&e)) {
            do {
                if (CANCELLED()) {
                    SetLastError (ERROR_CANCELLED);
                    __leave;
                }

                MediaDlls += pCountMigrateDllsInPath (e.Path);

            } while (EnumNextPreLoadedDll (&e));
        }

    }
    __finally {
        if (TurnItOff) {
            TurnOffWaitCursor();
        }
    }

    return MediaDlls;
}


UINT
GetMigrationDllCount (
    VOID
    )

/*++

Routine Description:

  GetMigrationDllCount returns the number of migration DLLs in local storage.

Arguments:

  none

Return Value:

  The number of migrate.dll modules successfully moved to local storage.

--*/

{
    return g_MigDllsAlive;
}


UINT
GetTotalMigrationDllCount (
    VOID
    )

/*++

Routine Description:

  GetTotalMigrationDllCount returns the number of DLLs that will be
  processed.  This includes media-based DLLs, DLLs supplied by the wizard
  page UI, DLLs specified in the registry, and DLLs specified in the answer file.

Arguments:

  None.

Return Value:

  The total number of DLLs to be processed.

--*/

{
    UINT DllCount;

    if (g_MediaDllsQueried) {
        DllCount = 0;
    } else {
        DllCount = GetMediaMigrationDllCount();
    }

    DllCount += g_MigDllsAlive;

    return DllCount;
}



BOOL
pVerifyDllIsTrusted (
    IN      PCSTR DllPath
    )

/*++

Routine Description:

  pVerifyDllIsTrusted determines if the specified DLL is digitally signed
  and is trusted by the system.

Arguments:

  none

Return Value:

  The number of migrate.dll modules successfully moved to local storage.
  The caller uses GetLastError when the return value is FALSE to determine
  if Setup was cancelled via UI.

--*/

{
    static BOOL TrustAll = FALSE;
    UINT Status;

    if (TrustAll) {
        return TRUE;
    }

    if (!IsDllSigned (WinVerifyTrustApi, DllPath)) {
        Status = UI_UntrustedDll (DllPath);

        if (Status == IDC_TRUST_IT) {
            return TRUE;
        } else if (Status == IDC_TRUST_ANY) {
            TrustAll = TRUE;
            return TRUE;
        } else if (Status == IDCANCEL) {
            SetLastError (ERROR_CANCELLED);
            return FALSE;
        }

        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    return TRUE;
}

BOOL
pMatchAttributes(
    IN      DBATTRIB_PARAMS * pdbAttribParams,
    IN      MIGDB_ATTRIB * pMigDbAttrib
    )
{
    BOOL bResult = TRUE;

    while (pMigDbAttrib != NULL) {
        pdbAttribParams->ExtraData = pMigDbAttrib->ExtraData;
        if (!CallAttribute (pMigDbAttrib, pdbAttribParams)) {
            bResult = FALSE;
            break;
        }
        pMigDbAttrib = pMigDbAttrib->Next;
    }

    return bResult;
}

BOOL
pValidateAndMoveDll (
    IN      PCSTR DllPath,
    IN OUT  PBOOL MatchFound        OPTIONAL
    )

/*++

Routine Description:

  pValidateAndMoveDll calls the DLL's QueryVersion function, and if the DLL
  returns success, it is moved to local storage, along with all the files
  associated with it.

Arguments:

  DllPath - Specifies full path to the migrate.dll to process

  MatchFound - Specifies an initialized BOOL, which may be either TRUE or
               FALSE depending on whether another valid migration DLL has
               been processed by the caller.  Receives TRUE if the
               migrate.dll is valid, otherwise the value is not changed.

Return Value:

  TRUE if the DLL specified by DllPath is valid and needs to run, or FALSE
  if not.  GetLastError is used by the caller to detect fatal errors.

--*/

{
    PCSTR ProductId = NULL;
    UINT DllVersion = 0;
    PCSTR ExeNamesBuf = NULL;
    CHAR WorkingDir[MAX_MBCHAR_PATH];
    PVENDORINFO VendorInfo = NULL;
    UINT SizeNeeded;
    CHAR QueryVersionDir[MAX_MBCHAR_PATH];
    PSTR p;
    BOOL b;
    LONG rc;
    PMIGRATION_DLL_PROPS ExistingDll;
    UINT version;
    UINT i;
    UINT listSize;

    //
    // Verify trust of DLL
    //

    if (!pVerifyDllIsTrusted (DllPath)) {
        DEBUGMSG ((DBG_WARNING, "DLL %s is not trusted and will not be processed", DllPath));

        //
        // Implicit: SetLastError (ERROR_SUCCESS);  (may be ERROR_CANCELLED if user
        // cancelled via UI)
        //

        return FALSE;
    }

    //
    // verify if this is one of the excluded migdlls, based on their file characteristics
    //
    if (GrowListGetSize (&g_ExcludedMigDllsByInfo)) {

        WIN32_FIND_DATA fd;
        HANDLE h;
        FILE_HELPER_PARAMS params;
        DBATTRIB_PARAMS dbAttribParams;
        PMIGDB_ATTRIB * ppMigDBattrib;

        h = FindFirstFile (DllPath, &fd);
        if (h != INVALID_HANDLE_VALUE) {
            CloseHandle (h);

            ZeroMemory (&params, sizeof(params));
            params.FindData = &fd;
            params.FullFileSpec = DllPath;
            ZeroMemory (&dbAttribParams, sizeof(dbAttribParams));
            dbAttribParams.FileParams = &params;

            for(i = 0, listSize = GrowListGetSize(&g_ExcludedMigDllsByInfo); i < listSize; i++){
                ppMigDBattrib = (PMIGDB_ATTRIB *)GrowListGetItem(&g_ExcludedMigDllsByInfo, i);
                MYASSERT(ppMigDBattrib);
                if(pMatchAttributes(&dbAttribParams, *ppMigDBattrib)){
                        LOG ((
                            LOG_INFORMATION,
                            TEXT("Found upgrade pack %s, but it is excluded from processing [%s]"),
                            DllPath,
                            S_EXCLUDEDMIGDLLSBYATTR
                            ));
                        SetLastError (ERROR_SUCCESS);
                        return FALSE;
                }
            }
        }
    }

    //
    // Copy base of DLL to QueryVersionDir, and trim off migrate.dll
    //

    StackStringCopyA (QueryVersionDir, DllPath);
    p = _mbsrchr (QueryVersionDir, '\\');
    MYASSERT (StringIMatch (p, "\\migrate.dll"));
    if (p) {
        *p = 0;
    }

    SizeNeeded = pCalculateSizeOfTree (QueryVersionDir);

    if (!pCreateWorkingDir (WorkingDir, QueryVersionDir, SizeNeeded)) {
        return FALSE;
    }

    //
    // Call QueryVersion directly from the suppling media
    //

    b = OpenMigrationDll (DllPath, WorkingDir);

    if (b) {

        rc = CallQueryVersion (
                WorkingDir,
                &ProductId,
                &DllVersion,
                &ExeNamesBuf,
                &VendorInfo
                );

        if (g_ProgressBarExists) {
            TickProgressBarDelta (TICKS_MIGDLL_QUERYVERSION);
        }

        if (rc != ERROR_SUCCESS) {
            b = FALSE;

            if (rc == ERROR_NOT_INSTALLED) {

                if (MatchFound) {
                    *MatchFound = TRUE;
                }

                rc = ERROR_SUCCESS;

            } else if (rc != ERROR_SUCCESS) {
                if (rc == RPC_S_CALL_FAILED) {
                    rc = ERROR_NOACCESS;
                }

                pMigrationDllFailedMsg (
                    NULL,
                    DllPath,
                    0,
                    MSG_MIGDLL_QV_FAILED_LOG,
                    rc
                    );

                rc = ERROR_SUCCESS;
            }

        } else {
            //
            // QueryVersion was called and it returned success (it wants to run)
            // but first check if this migration dll is intentionally excluded
            //

            if (g_ExcludedMigDlls &&
                HtFindStringAndData (g_ExcludedMigDlls, ProductId, &version) &&
                DllVersion <= version
                ) {

                LOG ((
                    LOG_INFORMATION,
                    TEXT("Found upgrade pack %s (ProductId=%s, Version=%u), but it is excluded from processing"),
                    DllPath,
                    ProductId,
                    DllVersion
                    ));

                b = FALSE;

            } else {

                if (MatchFound) {
                    *MatchFound = TRUE;
                }
            }
        }

    } else {
        //
        // Don't pass errors on.
        //
        if (g_ProgressBarExists) {
            TickProgressBarDelta (TICKS_MIGDLL_QUERYVERSION);       // early out, account for DLL not being processed
        }                                           // (see similar case below in finally block)

        rc = ERROR_SUCCESS;
    }

    if (!b) {
        DEBUGMSG ((DBG_MIGDLLS, "%hs will not be processed", DllPath));
        CloseMigrationDll();
        pDestroyWorkingDir (WorkingDir);

        SetLastError (rc);
        return FALSE;
    }

    //
    // We have found a DLL that wants to run.  Try moving it to local storage.
    //

    DEBUGMSG ((DBG_MIGDLLS, "Moving DLL for %s to local storage: %s", ProductId, DllPath));

    __try {
        b = FALSE;

        //
        // Look for existing version of DLL
        //

        ExistingDll = pFindMigrationDll (ProductId);
        if (ExistingDll && ExistingDll->Version >= DllVersion) {
            DEBUGMSG_IF ((
                ExistingDll->Version > DllVersion,
                DBG_MIGDLLS,
                "%hs will not be processed because it is an older version",
                DllPath
                ));
            SetLastError (ERROR_SUCCESS);
            __leave;
        }

        if (ExistingDll) {
            RemoveDllFromList (ExistingDll->Id);
        }

        //
        // Add the DLL to the list of loaded DLLs, and move all of the files
        //

        if (!pAddDllToList (
                QueryVersionDir,
                WorkingDir,
                ProductId,
                DllVersion,
                ExeNamesBuf,
                VendorInfo
                )) {
            pDestroyWorkingDir (WorkingDir);
            __leave;
        }

        //
        // DLL is now on a local drive and has returned success from QueryVersion.
        //

        b = TRUE;
    }
    __finally {
        DEBUGMSG ((DBG_MIGDLLS, "Done with %s", ProductId));
        CloseMigrationDll();
    }

    return b;

}


BOOL
pCreateWorkingDir (
    OUT     PSTR WorkingDir,
    IN      PCSTR QueryVersionDir,
    IN      UINT SizeNeeded
    )

/*++

Routine Description:

  pCreateWorkingDir generates a working directory name and creates it.
  The directory will have enough space to hold the size requested.

Arguments:

  WorkingDir - Receives the full path to the working directory

  QueryVersionDir - Specifies the version where the migration DLL is
                    when QueryVersion is called

  SizeNeeded - Specifies the number of bytes, rounded up to the next
               cluster size, indicating the total space to be occupied
               by migration DLL files

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.

--*/

{
    static UINT Sequencer = 1;

    //
    // For now, just put the files in %windir%\setup\temp
    //

    wsprintf (WorkingDir, "%s\\dll%05u", g_PlugInTempDir, Sequencer);
    Sequencer++;

    //
    // Establish the directory
    //

    if (CreateEmptyDirectory (WorkingDir) != ERROR_SUCCESS) {
        LOG ((LOG_ERROR, "pCreateWorkingDir: Can't create %hs", WorkingDir));
        return FALSE;
    }

    return TRUE;
}


VOID
pDestroyWorkingDir (
    IN      PCSTR WorkingDir
    )

/*++

Routine Description:

  pDestroyWorkingDir cleans up the specified working directory

Arguments:

  WorkingDir - Specifies the name of the directory to clean up

Return Value:

  none

--*/

{
    BOOL b;
    BOOL TurnItOff = FALSE;
    UINT Files = 0;
    TREE_ENUM e;

    //
    // Count the number of things that will be deleted, and if there
    // are more than 20, turn on the wait cursor.  (This keeps the
    // UI responsive.)
    //

    if (EnumFirstFileInTree (&e, WorkingDir, NULL, FALSE)) {
        do {
            Files++;
            if (Files > 30) {
                AbortEnumFileInTree (&e);
                TurnOnWaitCursor();
                TurnItOff = TRUE;
                break;
            }
        } while (EnumNextFileInTree (&e));
    }

    b = DeleteDirectoryContents (WorkingDir);
    b &= RemoveDirectory (WorkingDir);

    if (!b) {
        LOG ((LOG_ERROR, "Unable to delete %hs", WorkingDir));
    }

    if (TurnItOff) {
        TurnOffWaitCursor();
    }
}


PMIGRATION_DLL_PROPS
pFindMigrationDll (
    IN      PCSTR ProductId
    )

/*++

Routine Description:

  pFindMigrationDll searches the private data structures for the specified
  ProductId.  The ProductId is in a string table, so lookup is fast.

Arguments:

  ProductId - Specifies the ID of the DLL to find

Return Value:

  A pointer to the DLL's property struct, or NULL if the product ID does
  not match any of the DLLs.

--*/

{
    PMIGRATION_DLL_PROPS Props;
    LONG rc;

    rc = pSetupStringTableLookUpStringEx (
             g_DllTable,
             (PTSTR) ProductId,
             STRTAB_CASE_INSENSITIVE,
             &Props,
             sizeof (Props)
             );

    if (rc == -1) {
        return NULL;
    }

    return Props;
}


PMIGRATION_DLL_PROPS
pFindMigrationDllById (
    IN      LONG Id
    )

/*++

Routine Description:

  pFindMigrationDllById returns the migration DLL property structure for
  a DLL ID.  The ID is the same ID returned by the DLL enumeration routines.

Arguments:

  Id - Specifies the ID to find properties for

Return Value:

  A pointer to the DLL's property struct, or NULL if the ID is not valid.

--*/

{
    PMIGRATION_DLL_PROPS Props;

    if (Id == -1) {
        return NULL;
    }

    if (!pSetupStringTableGetExtraData (
             g_DllTable,
             Id,
             &Props,
             sizeof (Props)
             )) {
        return NULL;
    }

    return Props;
}


UINT
pGetMaxClusterSize (
    VOID
    )

/*++

Routine Description:

  pGetMaxClusterSize determines the maximum cluster size of all disks
  that are candidates for working directories.

Arguments:

  none

Return Value:

  The number of bytes per cluster.

--*/

{
    ACCESSIBLE_DRIVE_ENUM e;
    static DWORD MaxSize = 0;

    if (MaxSize) {
        return MaxSize;
    }

    if (GetFirstAccessibleDriveEx (&e, TRUE)) {
        do {
            MaxSize = max (MaxSize, e->ClusterSize);
        } while (GetNextAccessibleDrive (&e));
    }

    MYASSERT (MaxSize);

    return MaxSize;
}


UINT
pCalculateSizeOfTree (
    IN      PCSTR PathSpec
    )

/*++

Routine Description:

  pCalculateSizeOfTree enumerates the specified path and calculates
  the number of physical bytes occupied by the files and directory
  structures.

Arguments:

  PathSpec - Specifies root of path to find

Return Value:

  The number of bytes physically occupied by the path

--*/

{
    TREE_ENUM e;
    UINT Size = 0;
    UINT ClusterSize;

    ClusterSize = pGetMaxClusterSize();

    if (EnumFirstFileInTree (&e, PathSpec, NULL, FALSE)) {
        do {
            //
            // We assume the migrate.dll will never pack more than 4G of
            // files.
            //

            if (!e.Directory) {
                MYASSERT (Size + e.FindData->nFileSizeLow >= Size);
                MYASSERT (!e.FindData->nFileSizeHigh);
                Size += e.FindData->nFileSizeLow + ClusterSize -
                        (e.FindData->nFileSizeLow % ClusterSize);
            } else {
                // Add a fudge factor here, we don't know the exact size
                e.Directory += ClusterSize;
            }

        } while (EnumNextFileInTree (&e));
    }

    return Size;
}


BOOL
pEnumMigrationDllWorker (
    IN OUT  PMIGDLL_ENUM EnumPtr,
    IN      PMIGRATION_DLL_PROPS Props
    )

/*++

Routine Description:

  pEnumMigrationDllWorker is a common routine that completes the
  enumeration of a DLL.  It fills in the EnumPtr data members
  and returns TRUE.  Also, it screens out invalid DLL structures
  (those that have been disabled by RemoveDllFromList).

Arguments:

  EnumPtr - Specifies the partially completed enumeration structure,
            receives the complete information.

  Props - Specifies the properties of the item that was enumerated.

Return Value:

  FALSE if all remaining of the properties are invalid, or TRUE otherwise

--*/

{
    while (Props && Props->Id == -1) {
        Props = Props->Next;
    }

    if (!Props) {
        return FALSE;
    }

    EnumPtr->ProductId = Props->ProductId;
    EnumPtr->VendorInfo = Props->VendorInfo;
    EnumPtr->CurrentDir = Props->WorkingDir;
    EnumPtr->AllDllProps = Props;
    EnumPtr->Id = Props->Id;

    return TRUE;
}


BOOL
EnumFirstMigrationDll (
    OUT     PMIGDLL_ENUM EnumPtr
    )

/*++

Routine Description:

  EnumFirstMigrationDll begins an enumeration of migration DLLs.
  Callers can then use the enumerated information to fill list
  boxes or any other processing.

Arguments:

  EnumPtr - Receives the first enumerated DLL's properties

Return Value:

  TRUE if a DLL was enumerated, or FALSE if not.

--*/

{
    ZeroMemory (EnumPtr, sizeof (MIGDLL_ENUM));
    return pEnumMigrationDllWorker (EnumPtr, g_HeadDll);
}


BOOL
EnumNextMigrationDll (
    IN OUT  PMIGDLL_ENUM EnumPtr
    )

/*++

Routine Description:

  EnumNextMigrationDll continues enumeration started by EnumFirstMigrationDll.

Arguments:

  EnumPtr - Specifies the last enumerated item, receives the next enumerated
            item.

Return Value:

  TRUE if another DLL was enumerated, or FALSE if not.

--*/

{
    if (EnumPtr->AllDllProps->Next) {
        return pEnumMigrationDllWorker (EnumPtr, EnumPtr->AllDllProps->Next);
    }

    return FALSE;
}


BOOL
pAddDllToList (
    IN      PCSTR MediaDir,
    IN      PCSTR WorkingDir,
    IN      PCSTR ProductId,
    IN      UINT Version,
    IN      PCSTR ExeNamesBuf,          OPTIONAL
    IN      PVENDORINFO VendorInfo
    )

/*++

Routine Description:

  pAddDllToList adds the supplied properties to the private data structures
  used to organize the migration DLLs.  The ProductId is placed in a string
  table, the ExeNamesBuf is put in a list of files, and the rest of the
  members are duplciated into a memory pool.

Arguments:

  MediaDir - Specifies the directory containing the migration DLL

  WorkingDir - Specifies the working directory assigned to the DLL on local
               storage

  ProductId - Specifies the display name of the migration DLL

  Version - Specifies the DLL's version number

  ExeNamesBuf - Specifies a multi-sz listing file names that need to
                be located

  VendorInfo - Specifies the vendor info provided by the migration DLL

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.

--*/

{
    PMIGRATION_DLL_PROPS Props;
    CHAR MigrateInfPath[MAX_MBCHAR_PATH];
    PCSTR p;
    HANDLE File;

    //
    // Copy the DLL into the working directory
    //

    if (!CopyTree (
            MediaDir,
            WorkingDir,
            0,
            COPYTREE_DOCOPY | COPYTREE_NOOVERWRITE,
            ENUM_ALL_LEVELS,
            FILTER_ALL,
            NULL,
            NULL,
            NULL
            )) {
        LOG ((LOG_ERROR, "Error while copying files for migration.dll."));
        return FALSE;
    }

    //
    // Generate a new DLL struct
    //

    Props = (PMIGRATION_DLL_PROPS) PoolMemGetMemory (g_MigDllPool, sizeof (MIGRATION_DLL_PROPS));

    //
    // Link props to list of all DLLs
    //

    Props->Next = g_HeadDll;
    g_HeadDll = Props;

    //
    // Add product ID to string table for quick lookup
    //

    Props->Id = pSetupStringTableAddStringEx (
                    g_DllTable,
                    (PTSTR) ProductId,
                    STRTAB_CASE_INSENSITIVE|STRTAB_NEW_EXTRADATA,
                    &Props,
                    sizeof (Props)
                    );

    if (Props->Id == -1) {
        LOG ((LOG_ERROR, "Error adding migration.dll to list."));
        return FALSE;
    }

    //
    // Fill in the rest of the DLL properties
    //

    Props->ProductId    = PoolMemDuplicateString (g_MigDllPool, ProductId);
    Props->VendorInfo   = (PVENDORINFO) PoolMemDuplicateMemory (g_MigDllPool, (PBYTE) VendorInfo, sizeof (VENDORINFO));
    Props->WorkingDir   = PoolMemDuplicateString (g_MigDllPool, WorkingDir);
    Props->Version      = Version;
    Props->OriginalDir  = PoolMemDuplicateString (g_MigDllPool, MediaDir);

    wsprintf (MigrateInfPath, "%s\\migrate.inf", Props->WorkingDir);
    Props->MigrateInfPath = PoolMemDuplicateString (g_MigDllPool, MigrateInfPath);

    Props->WantsToRunOnNt = FALSE;  // MigrateUser9x or MigrateSystem9x must return success for this to be TRUE
    Props->MigInfAppend = INVALID_HANDLE_VALUE;

    //
    // Dump vendor info to log
    //

    LOG ((
        LOG_INFORMATION,
        "Upgrade Pack: %s\n"
            "Version: %u\n"
            "Company Name: %s\n"
            "Support Number: %s\n"
            "Support URL: %s\n"
            "Instructions: %s\n",
        Props->ProductId,
        Props->Version,
        VendorInfo->CompanyName,
        VendorInfo->SupportNumber,
        VendorInfo->SupportUrl,
        VendorInfo->InstructionsToUser
        ));

    //
    // Add all search files to string table
    //

    p = ExeNamesBuf;
    if (p) {
        while (*p) {
            pAddFileToSearchTable (p, Props);
            p = GetEndOfStringA (p) + 1;
        }
    }

    //
    // Copy migrate.inf to DLL dir
    //

    SetFileAttributes (Props->MigrateInfPath, FILE_ATTRIBUTE_NORMAL);
    CopyFile (g_MigrateInfTemplate, Props->MigrateInfPath, FALSE);

    File = CreateFile (Props->MigrateInfPath, GENERIC_READ|GENERIC_WRITE, 0, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (File != INVALID_HANDLE_VALUE) {
        SetFilePointer (File, 0, NULL, FILE_END);
        WriteFileString (File, TEXT("\r\n; "));
        WriteFileString (File, Props->ProductId);
        WriteFileString (File, TEXT("\r\n"));
        CloseHandle (File);
    } else {
        LOG ((LOG_ERROR, "Cannot open %s", Props->MigrateInfPath));
    }

    g_MigDllsAlive++;

    return TRUE;
}


VOID
RemoveDllFromList (
    IN      LONG ItemId
    )

/*++

Routine Description:

  RemoveDllFromList disables the data structures for the specified DLL and
  removes it from local storage.

Arguments:

  ItemId - Specifies the ID of the migration DLL to remove

Return Value:

  none

--*/

{
    PMIGRATION_DLL_PROPS Prev, This;
    PMIGRATION_DLL_PROPS Props;

    Props = pFindMigrationDllById (ItemId);
    if (!Props) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot remove migration DLL id %i", ItemId));
        return;
    }

    //
    // Delete the linkage
    //

    Prev = NULL;
    This = g_HeadDll;
    while (This && This != Props) {
        Prev = This;
        This = This->Next;
    }

    if (Prev) {
        Prev->Next = Props->Next;
    } else {
        g_HeadDll = Props->Next;
    }

    //
    // Delete the string table entry by making the item data NULL
    //

    This = NULL;
    pSetupStringTableSetExtraData (
        g_DllTable,
        ItemId,
        &This,
        sizeof (This)
        );

    //
    // Set Id to -1 so any search files are ignored
    //

    Props->Id = -1;

    pDestroyWorkingDir (Props->WorkingDir);

    g_MigDllsAlive--;
}


BOOL
pAddFileToSearchTable (
    IN      PCSTR File,
    IN      PMIGRATION_DLL_PROPS Props
    )

/*++

Routine Description:

  pAddFileToSearchTable adds the specified file name to the global lookup
  table used to quickly find the DLL (or DLLs) that want the location
  of the file.

Arguments:

  File - Specifies the long file name of the file to find

  Props - Specifies the properties of the DLL that wants the location of
          File

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.

--*/

{
    PFILETOFIND IndexedFile;
    PFILETOFIND NewFile;
    LONG rc;
    LONG Offset;

    //
    // Allocate a new file struct
    //

    NewFile = (PFILETOFIND) PoolMemGetMemory (g_MigDllPool, sizeof (FILETOFIND));
    if (!NewFile) {
        return FALSE;
    }
    NewFile->Next = NULL;
    NewFile->Dll = Props;

    //
    // Does a struct already exist in string table?
    //

    Offset = pSetupStringTableLookUpStringEx (
                 g_DllFileTable,
                 (PTSTR) File,
                 STRTAB_CASE_INSENSITIVE,
                 &IndexedFile,
                 sizeof (IndexedFile)
                 );

    if (Offset == -1) {
        //
        // No, add it now
        //

        rc = pSetupStringTableAddStringEx (
                 g_DllFileTable,
                 (PTSTR) File,
                 STRTAB_CASE_INSENSITIVE,
                 &NewFile,
                 sizeof (NewFile)
                 );
    } else {
        //
        // Yes, put it at the head of the list
        //

        rc = pSetupStringTableSetExtraData (
                 g_DllFileTable,
                 Offset,
                 &NewFile,
                 sizeof (NewFile)
                 );

        IndexedFile->Next = NewFile;
    }

    return rc != -1;
}


BOOL
pWriteStringToEndOfInf (
    IN OUT  PMIGRATION_DLL_PROPS Dll,
    IN      PCSTR String,
    IN      PCSTR HeaderString,             OPTIONAL
    IN      BOOL WriteLineFeed
    )

/*++

Routine Description:

  pWriteStringToEndOfInf writes the specified string to migrate.inf.
  This routine also opens migrate.inf if it has not already been
  opened.

  If HeaderString is provided and migrate.inf needs to be opened,
  the header string is written to the file, ahead of String.

Arguments:

  Dll - Specifies the DLL associated with the migrate.inf

  String - Specifies the string to write

  HeaderString - Specifies text that is written when migrate.inf is
                 opened for writing for the first time.

  WriteLineFeed - Specifies TRUE if a \r\n sequence should be written
                  after String, or FALSE if not.

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.

--*/

{
    if (Dll->MigInfAppend == INVALID_HANDLE_VALUE) {
        //
        // Flush the profile APIs
        //

        WritePrivateProfileString(
            NULL,
            NULL,
            NULL,
            Dll->MigrateInfPath
            );

        //
        // Open the file for writing
        //

        Dll->MigInfAppend = CreateFile (
                                Dll->MigrateInfPath,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );
    } else {
        HeaderString = NULL;
    }

    if (Dll->MigInfAppend == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Cannot open %s", Dll->MigrateInfPath));
        return FALSE;
    }

    SetFilePointer (Dll->MigInfAppend, 0, NULL, FILE_END);

    if (HeaderString) {
        if (!WriteFileString (Dll->MigInfAppend, HeaderString)) {
            return FALSE;
        }
    }

    if (!WriteFileString (Dll->MigInfAppend, String)) {
        return FALSE;
    }

    if (WriteLineFeed) {
        if (!WriteFileString (Dll->MigInfAppend, "\r\n")) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
UpdateFileSearch (
    IN      PCSTR FullFileSpec,
    IN      PCSTR FileOnly
    )

/*++

Routine Description:

  UpdateFileSearch is called for every file on the machine being upgraded,
  and any file that the DLL wants the location file will receive its path
  in the DLL's migrate.inf.

Arguments:

  FullFileSpec - specifies the full path to the file, in long name format

  FileOnly - Specifies only the file name and must match the file in
             FullFileSpec.

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.

--*/

{
    PFILETOFIND FileWanted;
    LONG rc;

    //
    // Look in string table for an indexed file, and if found, enumerate
    // all the DLLs that want to know where the file is.
    //

    rc = pSetupStringTableLookUpStringEx (
             g_DllFileTable,
             (PTSTR) FileOnly,
             STRTAB_CASE_INSENSITIVE,
             &FileWanted,
             sizeof (FileWanted)
             );

    if (rc == -1) {
        return TRUE;
    }

    while (FileWanted) {
        if (FileWanted->Dll->Id != -1) {
            //
            // Append path to the end of the file
            //

            if (!pWriteStringToEndOfInf (
                    FileWanted->Dll,
                    FullFileSpec,
                    "\r\n[Migration Paths]\r\n",
                    TRUE
                    )) {
                return FALSE;
            }
        }

        FileWanted = FileWanted->Next;
    }

    return TRUE;
}


VOID
pMigrationDllFailedMsg (
    IN      PMIGRATION_DLL_PROPS Dll,       OPTIONAL
    IN      PCSTR Path,                     OPTIONAL
    IN      UINT PopupId,                   OPTIONAL
    IN      UINT LogId,                     OPTIONAL
    IN      LONG rc
    )

/*++

Routine Description:

  pMigrationDllFailedMsg presents a popup for DLLs that fail to run,
  and also logs the failure to setuperr.log.

  The system's last error is preserved.  Also, no output is generated
  if the user has chosen to cancel or if rc is ERROR_SUCCESS.

Arguments:

  Dll - Specifies the DLL that failed.  If Dll is not provided, PopupId
        must be zero.

  Path - Specifies the path to the DLL media

  PopupId - Specifies the message ID for the popup dialog box

  LogId - Specifies the message ID for the log

  rc - Specifies the failure code

Return Value:

  None.

--*/

{
    CHAR ErrorCode[16];
    PCTSTR FixupPhone;
    PCTSTR FixupUrl;
    PCTSTR FixupInstructions;
    PCTSTR LineBreak = S_EMPTY;
    PCTSTR ArgArray[1];

    PushError();

    if (!CANCELLED() && rc != ERROR_SUCCESS && rc != ERROR_CANCELLED) {

        wsprintf (ErrorCode, "%u", rc);

        if (Dll) {
            //
            // Generate fixup strings
            //

            if (Dll->VendorInfo->SupportNumber[0]) {
                ArgArray[0] = Dll->VendorInfo->SupportNumber;
                FixupPhone = ParseMessageID (MSG_MIGDLL_SUPPORT_PHONE_FIXUP, ArgArray);
                LineBreak = TEXT("\n");
            } else {
                FixupPhone = S_EMPTY;
            }

            if (Dll->VendorInfo->SupportUrl[0]) {
                ArgArray[0] = Dll->VendorInfo->SupportUrl;
                FixupUrl = ParseMessageID (MSG_MIGDLL_SUPPORT_URL_FIXUP, ArgArray);
                LineBreak = TEXT("\n");
            } else {
                FixupUrl = S_EMPTY;
            }

            if (Dll->VendorInfo->InstructionsToUser[0]) {
                ArgArray[0] = Dll->VendorInfo->InstructionsToUser;
                FixupInstructions = ParseMessageID (MSG_MIGDLL_INSTRUCTIONS_FIXUP, ArgArray);
                LineBreak = TEXT("\n");
            } else {
                FixupInstructions = S_EMPTY;
            }

            LOG ((
                LOG_ERROR,
                (PCSTR) LogId,
                Dll->WorkingDir,
                Dll->ProductId,
                ErrorCode,
                Dll->LastFnName,
                Dll->VendorInfo->CompanyName,
                FixupPhone,
                FixupUrl,
                FixupInstructions,
                LineBreak
                ));
            LOG ((
                LOG_ERROR,
                (PCSTR) PopupId,
                Dll->WorkingDir,
                Dll->ProductId,
                ErrorCode,
                Dll->LastFnName,
                Dll->VendorInfo->CompanyName,
                FixupPhone,
                FixupUrl,
                FixupInstructions,
                LineBreak
                ));
        } else {
            MYASSERT (!PopupId);
            LOG ((
                LOG_ERROR,
                (PCSTR) LogId,
                Path ? Path : S_EMPTY,
                S_EMPTY,
                ErrorCode,
                TEXT("QueryVersion")
                ));
        }
    }

    PopError();
}


PCTSTR
pQuoteMe (
    IN      PCTSTR String
    )
{
    static TCHAR QuotedString[1024];

    QuotedString[0] = TEXT('\"');
    _tcssafecpy (&QuotedString[1], String, 1022);
    StringCat (QuotedString, TEXT("\""));

    return QuotedString;
}


BOOL
ProcessDll (
    IN      PMIGDLL_ENUM EnumPtr
    )

/*++

Routine Description:

  ProcessDll calls the Initialize9x, MigrateUser9x and MigrateSystem9x
  entry points of the DLL.  The DLL's migrate.inf is then processed.

  ProcessDll must NOT be called more than once for the same DLL.

Arguments:

  EnumPtr - Specifies the DLL to process, as enumerated by
            EnumFirstMigrationDll/EnumNextMigrationDll.

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.
  If an error occurred, GetLastError will contain the failure.  If the
  error is ERROR_SUCCESS, the DLL should be abandoned.  If the error
  is something else, Setup should terminate.

--*/

{
    CHAR DllPath[MAX_MBCHAR_PATH];
    PMIGRATION_DLL_PROPS Dll;
    MEMDB_ENUM e;
    PSTR End;
    LONG rc;
    BOOL result;

    Dll = EnumPtr->AllDllProps;

    //
    // Write the path exclusions now
    //

    if (!pWriteStringToEndOfInf (Dll, "\r\n[Excluded Paths]", NULL, TRUE)) {
        return FALSE;
    }

    if (MemDbGetValueEx (
            &e,
            MEMDB_CATEGORY_FILEENUM,
            g_ExclusionValueString,
            MEMDB_FIELD_FE_PATHS
            )) {

        do {

            End = GetEndOfStringA (e.szName);
            MYASSERT (End);

            End = _mbsdec2 (e.szName, End);
            if (End && *End == '*') {
                *End = 0;
            }

            if (!pWriteStringToEndOfInf (Dll, pQuoteMe (e.szName), NULL, TRUE)) {
                return FALSE;
            }

        } while (MemDbEnumNextValue(&e));
    }

    if (MemDbGetValueEx (
            &e,
            MEMDB_CATEGORY_FILEENUM,
            g_ExclusionValueString,
            MEMDB_FIELD_FE_FILES
            )) {

        do {
            if (!pWriteStringToEndOfInf (Dll, pQuoteMe (e.szName), NULL, TRUE)) {
                return FALSE;
            }
        } while (MemDbEnumNextValue (&e));
    }

    //
    // Make sure the migrate.inf file is closed now
    //

    if (Dll->MigInfAppend != INVALID_HANDLE_VALUE) {
        CloseHandle (Dll->MigInfAppend);
        Dll->MigInfAppend = INVALID_HANDLE_VALUE;
    }

    //
    // Open the migrate.dll
    //

    wsprintf (DllPath, "%s\\migrate.dll", Dll->WorkingDir);
    if (!OpenMigrationDll (DllPath, Dll->WorkingDir)) {
        LOG ((LOG_ERROR, "Can't open %s", DllPath));
        return FALSE;
    }

    result = FALSE;

    __try {
        //
        // Call the entry points
        //

        if (!pProcessInitialize9x (Dll) ||
            !pProcessUser9x (Dll) ||
            !pProcessSystem9x (Dll) ||
            !pProcessMigrateInf (Dll)
            ) {
            rc = GetLastError();
            if (rc == RPC_S_CALL_FAILED) {
                rc = ERROR_NOACCESS;
            }

            pMigrationDllFailedMsg (Dll, NULL, MSG_MIGDLL_FAILED_POPUP, MSG_MIGDLL_FAILED_LOG, rc);

            SetLastError (ERROR_SUCCESS);
            __leave;
        }

        TickProgressBar ();
        result = TRUE;

    }
    __finally {

        PushError();

        //
        // Close the DLL
        //

        CloseMigrationDll();

        PopError();
    }

    return result;
}


BOOL
pProcessInitialize9x (
    IN      PMIGRATION_DLL_PROPS Dll
    )

/*++

Routine Description:

  pProcessInitialize9x calls the Initialize9x entry point of the
  specified DLL.

Arguments:

  Dll - Specifies the properties of the DLL to call

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.

--*/

{
    LONG rc;

    if (CANCELLED()) {
        SetLastError (ERROR_CANCELLED);
        return FALSE;
    }

    Dll->LastFnName = "Initialize9x";

    //
    // Call the entry points
    //

    rc = CallInitialize9x (
               Dll->WorkingDir,
               (PCSTR) g_SourceDirList.Buf,
               (PVOID) Dll->OriginalDir,
               SizeOfString (Dll->OriginalDir)
               );

    //
    // If DLL returns ERROR_NOT_INSTALLED, do not call it any further
    // If DLL returns something other than ERROR_SUCCESS, abandon the DLL
    //

    if (rc == ERROR_NOT_INSTALLED) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        DEBUGMSG ((DBG_MIGDLLS, "DLL failed with rc=%u", rc));
        return FALSE;
    }

    return TRUE;

}


BOOL
pProcessUser9x (
    IN      PMIGRATION_DLL_PROPS Dll
    )

/*++

Routine Description:

  pProcessUser9x calls the MigrateUser9x for every user that will be migrated.

Arguments:

  Dll - Specifies the properites of the DLL to call

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.

--*/

{
    USERENUM e;
    LONG rc;

    Dll->LastFnName = "MigrateUser9x";

    //
    // Enumerate all the users
    //

    if (EnumFirstUser (&e, ENUMUSER_ENABLE_NAME_FIX)) {
        do {

            if (CANCELLED()) {
                SetLastError (ERROR_CANCELLED);
                return FALSE;
            }

            if (e.AccountType & INVALID_ACCOUNT) {
                continue;
            }

            rc = CallMigrateUser9x (
                     g_ParentWnd,
                     e.FixedUserName,
                     g_MigDllAnswerFile,
                     NULL,
                     0
                     );

            if (rc == ERROR_SUCCESS) {
                Dll->WantsToRunOnNt = TRUE;
            } else if (rc != ERROR_NOT_INSTALLED) {
                EnumUserAbort (&e);
                SetLastError (rc);
                DEBUGMSG ((DBG_MIGDLLS, "DLL failed with rc=%u", rc));
                return FALSE;
            }

        } while (EnumNextUser (&e));
    }

    return TRUE;
}


BOOL
pProcessSystem9x (
    IN      PMIGRATION_DLL_PROPS Dll
    )

/*++

Routine Description:

  pProcessSystem9x calls the MigrateSystem9x entry point.

Arguments:

  Dll - Specifies the properties of the DLL to process

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.

--*/

{
    LONG rc;

    if (CANCELLED()) {
        SetLastError (ERROR_CANCELLED);
        return FALSE;
    }

    Dll->LastFnName = "MigrateSystem9x";

    rc = CallMigrateSystem9x (g_ParentWnd, g_MigDllAnswerFile, NULL, 0);

    if (rc == ERROR_SUCCESS) {
        Dll->WantsToRunOnNt = TRUE;
    } else if (rc != ERROR_NOT_INSTALLED) {
        SetLastError (rc);
        DEBUGMSG ((DBG_MIGDLLS, "DLL failed with rc=%u", rc));
        return FALSE;
    }

    return TRUE;
}


BOOL
pProcessMigrateInf (
    IN      PMIGRATION_DLL_PROPS Dll
    )

/*++

Routine Description:

  pProcessMigrateInf reads in all the sections of migrate.inf that a DLL might
  write to and performs the actions necessary.  The following sections are
  supported:

  [Handled]   - Any file, directory or reg location will suppress
                incompatibility messages associated with the handled item.
                Also, any file or directory will not be touched by Setup,
                and any registry key will not be copied.

  [Moved] - Any file or directory marked for move will cause the rest of the
            upgrade to make the correct changes, such as updating links or
            replacing the old path with the new path in the registry or INI
            files.

            Any file marked for deletion is simply noted, and all links to the
            file are also deleted.

  [Incompatible Messages] - All messages are added to the report (and may be
                            suppressed if someone else handles the problem)

  [NT Disk Space Requirements] - Any additional space needed by a migration DLL
                                 will be added to the computations performed
                                 by Setup


Arguments:

  Dll - Specifies the properties of the DLL who owns the migrate.inf

Return Value:

  TRUE if processing was successful, or FALSE if an error occurred.

--*/

{
    HINF Inf;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    INFSTRUCT is2 = INITINFSTRUCT_POOLHANDLE;
    PCSTR Object;
    PCSTR ObjectType;
    PCSTR Source;
    PCSTR Dest;
    PCSTR Size;
    PCSTR Drive;
    CHAR WithColonAndWack[4];
    PCSTR ObjectSection;
    CHAR MsgMgrContext[MAX_MBCHAR_PATH];
    PSTR DisplayObjectSection;
    PCSTR MigDllGroup;
    BOOL HardwareSpecialCase;
    PSTR p;
    CHAR QuotedObjectSection[256];
    PCSTR ResText;
    DWORD SrcAttribs;
    TREE_ENUM TreeEnum;
    CHAR FixedSrc[MAX_MBCHAR_PATH];
    CHAR NewDest[MAX_MBCHAR_PATH];
    PCSTR OtherDevices = NULL;
    PCSTR DeviceType;
    PCSTR PrintDevice = NULL;
    PCSTR Num;
    UINT Value;
    PCSTR PreDefGroup;
    INT PrevChar;

    //
    // Open the INF
    //

    WritePrivateProfileString(
            NULL,
            NULL,
            NULL,
            Dll->MigrateInfPath
            );

    Inf = InfOpenInfFile (Dll->MigrateInfPath);

    if (Inf == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Cannot open %s for processing", Dll->MigrateInfPath));
        return TRUE;
    }

    //
    // Read in the [Handled] section
    //

    if (InfFindFirstLine (Inf, "Handled", NULL, &is)) {
        do {
            Object = InfGetStringField (&is, 0);
            ObjectType = InfGetStringField (&is, 1);

            if (Object) {
                //
                // Suppress all incompatibility messages associated with the object
                //

                DEBUGMSG ((DBG_MIGDLLS, "%s handled %s", Dll->MigrateInfPath, Object));
                HandleObject (Object, ObjectType);
            }

            InfResetInfStruct (&is);

        } while (InfFindNextLine (&is));
    }

    //
    // Read in the [Moved] section
    //

    if (InfFindFirstLine (Inf, "Moved", NULL, &is)) {
        do {
            Source = InfGetStringField (&is, 0);
            Dest = InfGetStringField (&is, 1);

            if (Source) {

                StackStringCopy (FixedSrc, Source);
                RemoveWackAtEnd (FixedSrc);

                SrcAttribs = QuietGetFileAttributes (FixedSrc);

                if (SrcAttribs != INVALID_ATTRIBUTES) {

                    if (Source && *Source) {
                        if (SrcAttribs & FILE_ATTRIBUTE_DIRECTORY) {
                            DEBUGMSG ((DBG_MIGDLLS, "Directory %s marked as handled because %s will move it.", Source, Dll->MigrateInfPath));
                            HandleObject (Source, TEXT("Directory"));
                        }
                        else {
                            DEBUGMSG ((DBG_MIGDLLS, "File %s marked as handled because %s will move it.", Source, Dll->MigrateInfPath));
                            HandleObject (Source, TEXT("File"));
                        }
                    }
                    if (Dest && *Dest) {
                        if (SrcAttribs & FILE_ATTRIBUTE_DIRECTORY) {
                            //
                            // Migration DLL will move this dir
                            //

                            DEBUGMSG ((DBG_MIGDLLS, "%s moved dir %s to %s", Dll->MigrateInfPath, Source, Dest));

                            if (EnumFirstFileInTree (&TreeEnum, Source, NULL, TRUE)) {

                                StackStringCopy (NewDest, Dest);
                                p = AppendWack (NewDest);

                                do {

                                    RemoveOperationsFromPath (TreeEnum.FullPath, ALL_CHANGE_OPERATIONS);
                                    MYASSERT (*TreeEnum.SubPath != '\\');
                                    StringCopy (p, TreeEnum.SubPath);
                                    MarkFileForMoveExternal (TreeEnum.FullPath, NewDest);

                                } while (EnumNextFileInTree (&TreeEnum));
                            }

                            StackStringCopy (NewDest, Dest);
                            RemoveWackAtEnd (NewDest);

                            RemoveOperationsFromPath (FixedSrc, ALL_CHANGE_OPERATIONS);
                            MarkFileForMoveExternal (FixedSrc, NewDest);

                        } else {
                            //
                            // Migration DLL will move this file
                            //

                            DEBUGMSG ((DBG_MIGDLLS, "%s moved %s to %s", Dll->MigrateInfPath, Source, Dest));

                            RemoveOperationsFromPath (Source, ALL_CHANGE_OPERATIONS);
                            MarkFileForMoveExternal (Source, Dest);
                        }

                    } else {
                        if (SrcAttribs & FILE_ATTRIBUTE_DIRECTORY) {

                            DEBUGMSG ((DBG_MIGDLLS, "%s deleted dir %s", Dll->MigrateInfPath, Source));

                            if (EnumFirstFileInTree (&TreeEnum, Source, NULL, TRUE)) {

                                do {

                                    RemoveOperationsFromPath (TreeEnum.FullPath, ALL_CHANGE_OPERATIONS);
                                    MarkFileForExternalDelete (TreeEnum.FullPath);

                                } while (EnumNextFileInTree (&TreeEnum));
                            }

                        } else {
                            //
                            // Migration DLL will delete this file
                            //

                            DEBUGMSG ((DBG_MIGDLLS, "%s deleted %s", Dll->MigrateInfPath, Source));
                            RemoveOperationsFromPath (Source, ALL_CHANGE_OPERATIONS);
                            MarkFileForExternalDelete (Source);
                        }
                    }
                }
                ELSE_DEBUGMSG ((
                    DBG_WARNING,
                    "Ignoring non-existent soruce in [Moved]: %s",
                    Source
                    ));
            }

            InfResetInfStruct (&is);

        } while (InfFindNextLine (&is));
    }

    //
    // Read in the [Incompatible Messages] section
    //

    if (InfFindFirstLine (Inf, "Incompatible Messages", NULL, &is)) {

        OtherDevices = GetStringResource (MSG_UNKNOWN_DEVICE_CLASS);
        PrintDevice = GetStringResource (MSG_PRINTERS_DEVICE_CLASS);

        do {
            //
            // Add incompatible messages
            //

            ObjectSection = InfGetStringField (&is, 0);

            if (!ObjectSection) {
                DEBUGMSG ((DBG_ERROR, "Malformed migrate.inf. Some incompatibility messages may be missing."));
                continue;
            }

            GetPrivateProfileString (
                "Incompatible Messages",
                ObjectSection,
                "",
                g_MessageBuf,
                MAX_MESSAGE - 4,
                Dll->MigrateInfPath
                );

            if (*g_MessageBuf == 0 && ByteCount (ObjectSection) < 250) {
                wsprintf (QuotedObjectSection, TEXT("\"%s\""), ObjectSection);

                GetPrivateProfileString (
                    "Incompatible Messages",
                    QuotedObjectSection,
                    "",
                    g_MessageBuf,
                    MAX_MESSAGE - 4,
                    Dll->MigrateInfPath
                    );
            }

            // Remove quote pairs, replace \n with actual line break character
            for (p = g_MessageBuf ; *p ; p = _mbsinc (p)) {
                PrevChar = _mbsnextc (p);
                if (PrevChar == '\"' || PrevChar == '%') {
                    if (_mbsnextc (p + 1) == PrevChar) {
                        MoveMemory ((PSTR) p, p + 1, SizeOfStringA (p + 1));
                    }
                } else if (_mbsnextc (p) == '\\') {
                    if (_mbsnextc (p + 1) == 'n') {
                        MoveMemory ((PSTR) p, p + 1, SizeOfStringA (p + 1));
                        *((PSTR) p) = '\r';
                    }
                }
            }

            // Terminate anchor tag if DLL forgot it, harmless otherwise
            StringCatA (g_MessageBuf, "</A>");

            //
            // Replace OS name variables
            //

            MappingSearchAndReplace (g_MsgVariableMap, g_MessageBuf, MAX_MESSAGE);

            //
            // Associate objects with the message
            //

            if (InfFindFirstLine (Inf, ObjectSection, NULL, &is2)) {
                wsprintf (MsgMgrContext, "%s,%s", Dll->MigrateInfPath, ObjectSection);

                //
                // The ObjectSection specified by the migration DLL indicates
                // what message group it goes in.  There are four possibilities:
                //
                // 1. ObjectSection starts with a # and gives the group number,
                //    as in #1\Program Name.  In this case we parse the number,
                //    and then put the message in the proper group.
                //
                // 2. ObjectSection starts with a well-defined, localized root
                //    name.  In this case we use that name.
                //
                // 3. ObjectSection is in the form of \Hardware\<device>. In
                //    this case we put the device in the "Other devices"
                //    subgroup.
                //
                // 4. ObjectSection is in another format than above.  In this
                //    case we put the object section into the migration DLL group.
                //

                DisplayObjectSection = NULL;

                if (*ObjectSection == TEXT('#')) {
                    Value = 0;
                    Num = ObjectSection + 1;
                    while (*Num >= TEXT('0') && *Num <= TEXT('9')) {
                        Value = Value * 10 + (*Num - TEXT('0'));
                        Num++;
                    }
                    if (_tcsnextc (Num) == TEXT('\\')) {
                        Num++;
                        if (*Num) {
                            PreDefGroup = GetPreDefinedMessageGroupText (Value);

                            if (PreDefGroup) {
                                DisplayObjectSection = JoinText (PreDefGroup, Num);
                                DEBUGMSG ((
                                    DBG_MIGDLLS,
                                    "Pre-defined group created: %s -> %s",
                                    ObjectSection,
                                    DisplayObjectSection
                                    ));
                            }
                        }
                    }
                }

                if (!DisplayObjectSection) {

                    if (IsPreDefinedMessageGroup (ObjectSection)) {
                        DisplayObjectSection = DuplicateText (ObjectSection);
                        MYASSERT (DisplayObjectSection);
                    } else {
                        //
                        // Put message in migration DLL group
                        //

                        HardwareSpecialCase = StringIMatchCharCount (
                                                  ObjectSection,
                                                  S_HARDWARE_IN_WACKS,
                                                  S_HARDWARE_CHARS
                                                  );

                        if (HardwareSpecialCase) {

                            //
                            // Hack -- if this is the printer migration DLL,
                            //         then use Printers instead of Other Devices.
                            //

                            p = (PSTR) _tcsistr (Dll->OriginalDir, TEXT("\\print"));

                            if (p && (*(p + ARRAYSIZE(TEXT("\\print"))) == 0)) {

                                DeviceType = PrintDevice;
                            } else {

                                DeviceType = OtherDevices;
                            }

                            MigDllGroup = BuildMessageGroup (
                                                MSG_INCOMPATIBLE_HARDWARE_ROOT,
                                                MSG_INCOMPATIBLE_HARDWARE_PNP_SUBGROUP,
                                                DeviceType
                                                );

                            ObjectSection += S_HARDWARE_CHARS;
                            MYASSERT (MigDllGroup);

                        } else {

                            ResText = GetStringResource (MSG_MIGDLL_ROOT);
                            MYASSERT (ResText);

                            MigDllGroup = DuplicateText (ResText);
                            FreeStringResource (ResText);

                            MYASSERT (MigDllGroup);
                        }

                        DisplayObjectSection = AllocText (SizeOfStringA (MigDllGroup) +
                                                          SizeOfStringA (ObjectSection) +
                                                          SizeOfStringA (Dll->ProductId)
                                                          );
                        MYASSERT (DisplayObjectSection);

                        if (HardwareSpecialCase) {
                            wsprintf (DisplayObjectSection, "%s\\%s", MigDllGroup, ObjectSection);
                        } else if (StringIMatch (Dll->ProductId, ObjectSection)) {
                            wsprintf (DisplayObjectSection, "%s\\%s", MigDllGroup, Dll->ProductId);
                        } else {
                            wsprintf (DisplayObjectSection, "%s\\%s\\%s", MigDllGroup, Dll->ProductId, ObjectSection);
                        }

                        FreeText (MigDllGroup);
                    }
                }

                MsgMgr_ContextMsg_Add (
                    MsgMgrContext,
                    DisplayObjectSection,
                    g_MessageBuf
                    );

                FreeText (DisplayObjectSection);

                do {
                    Object = InfGetStringField (&is2, 0);

                    if (Object) {
                        MsgMgr_LinkObjectWithContext (
                            MsgMgrContext,
                            Object
                            );
                    }
                    ELSE_DEBUGMSG ((DBG_WHOOPS, "pProcessMigrateInf: InfGetStringField failed"));
                    if (Object == NULL) {
                        LOG ((LOG_ERROR, "Failed to get string field from migration.dll migrate.inf."));
                    }

                } while (InfFindNextLine (&is2));

                InfResetInfStruct (&is2);
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Object section %s not found", ObjectSection));

            InfResetInfStruct (&is);

        } while (InfFindNextLine (&is));

        if (OtherDevices) {
            FreeStringResource (OtherDevices);
        }

        if (PrintDevice) {
            FreeStringResource (PrintDevice);
        }

    }

    //
    // Read in the [NT Disk Space Requirements] section
    //

    if (InfFindFirstLine (Inf, "NT Disk Space Requirements", NULL, &is)) {
        do {
            Drive = InfGetStringField (&is, 0);

            if (!Drive) {
                DEBUGMSG ((DBG_ERROR, "Could not read some NT Disk Space Requirements from migrate.inf"));
                continue;
            }

            WithColonAndWack[0] = Drive[0];
            WithColonAndWack[1] = ':';
            WithColonAndWack[2] = '\\';
            WithColonAndWack[3] = 0;

            Size = InfGetStringField (&is, 1);
            UseSpace (WithColonAndWack, (LONGLONG) atoi (Size));

            InfResetInfStruct (&is);

        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);
    InfCleanUpInfStruct (&is2);
    InfCloseInfFile (Inf);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\migdll9x\migdllp.h ===
#ifndef _MIGDLLP_H
#define _MIGDLLP_H

//
// Private
//

extern PVOID g_DllTable;
extern PVOID g_DllFileTable;
extern POOLHANDLE g_MigDllPool;
extern PMIGRATION_DLL_PROPS g_HeadDll;
extern HANDLE g_AbortDllEvent;

typedef struct _tagFILETOFIND {
    struct _tagFILETOFIND *Next;
    PMIGRATION_DLL_PROPS Dll;
} FILETOFIND, *PFILETOFIND;


//
// Local routines
//

BOOL
pValidateAndMoveDll (
    IN      PCSTR DllPath,
    OUT     PBOOL MatchFound        OPTIONAL
    );

UINT
pCalculateSizeOfTree (
    IN      PCSTR PathSpec
    );

BOOL
pCreateWorkingDir (
    OUT     PSTR WorkingDir,
    IN      PCSTR QueryVersionDir,
    IN      UINT SizeNeeded
    );

VOID
pDestroyWorkingDir (
    IN      PCSTR WorkingDir
    );

BOOL
pAddFileToSearchTable (
    IN      PCSTR File,
    IN      PMIGRATION_DLL_PROPS Props
    );

BOOL
pAddDllToList (
    IN      PCSTR MediaDir,
    IN      PCSTR WorkingDir,
    IN      PCSTR ProductId,
    IN      UINT Version,
    IN      PCSTR ExeNamesBuf,          OPTIONAL
    IN      PVENDORINFO VendorInfo
    );

VOID
pMigrationDllFailedMsg (
    IN      PMIGRATION_DLL_PROPS Dll,   OPTIONAL
    IN      PCSTR DllPath,              OPTIONAL
    IN      UINT PopupId,
    IN      UINT LogId,
    IN      LONG rc
    );

BOOL
pProcessInitialize9x (
    IN      PMIGRATION_DLL_PROPS Dll
    );

BOOL
pProcessUser9x (
    IN      PMIGRATION_DLL_PROPS Dll
    );

BOOL
pProcessSystem9x (
    IN      PMIGRATION_DLL_PROPS Dll
    );

BOOL
pProcessMigrateInf (
    IN      PMIGRATION_DLL_PROPS Dll
    );

PMIGRATION_DLL_PROPS
pFindMigrationDll (
    IN      PCSTR ProductId
    );


BOOL
OpenMigrationDll (
    IN      PCSTR MigrationDllPath,
    IN      PCSTR WorkingDir
    );

VOID
CloseMigrationDll (
    VOID
    );

LONG
CallQueryVersion (
    IN      PCSTR WorkingDir,
    OUT     PCSTR *ProductId,
    OUT     PUINT DllVersion,
    OUT     PCSTR *ExeNamesBuf,
    OUT     PVENDORINFO *VendorInfo
    );

LONG
CallInitialize9x (
    IN      PCSTR WorkingDir,
    IN      PCSTR SourceDirList,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );

LONG
CallMigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UserName,
    IN      PCSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );

LONG
CallMigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendTxt,
    IN      PVOID Reserved,
    IN      DWORD ReservedSize
    );





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\pch\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\compacct.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    compacct.c

Abstract:

    Implements DoesComputerAccountExistOnDomain, which determines if a computer
    account exists given an NT domain and computer name.  This is used to
    warn the user if they are going to be joining an NT domain but do not have
    a computer account ready.

Author:

    Jim Schmidt (jimschm) 02-Jan-1998

Revision History:

    jimschm     23-Sep-1998 Added 20 retries for datagram write

--*/

#include "pch.h"
#include <netlogon.h>                                           // private\inc

//
// Contants from sdk\inc\ntsam.h -- copied here because ntsam.h redefines things
//

//
// User account control flags...
//

#define USER_ACCOUNT_DISABLED                (0x00000001)
#define USER_HOME_DIRECTORY_REQUIRED         (0x00000002)
#define USER_PASSWORD_NOT_REQUIRED           (0x00000004)
#define USER_TEMP_DUPLICATE_ACCOUNT          (0x00000008)
#define USER_NORMAL_ACCOUNT                  (0x00000010)
#define USER_MNS_LOGON_ACCOUNT               (0x00000020)
#define USER_INTERDOMAIN_TRUST_ACCOUNT       (0x00000040)
#define USER_WORKSTATION_TRUST_ACCOUNT       (0x00000080)
#define USER_SERVER_TRUST_ACCOUNT            (0x00000100)
#define USER_DONT_EXPIRE_PASSWORD            (0x00000200)
#define USER_ACCOUNT_AUTO_LOCKED             (0x00000400)
#define USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED (0x00000800)
#define USER_SMARTCARD_REQUIRED              (0x00001000)


#define USER_MACHINE_ACCOUNT_MASK      \
            ( USER_INTERDOMAIN_TRUST_ACCOUNT |\
              USER_WORKSTATION_TRUST_ACCOUNT |\
              USER_SERVER_TRUST_ACCOUNT)

#define USER_ACCOUNT_TYPE_MASK         \
            ( USER_TEMP_DUPLICATE_ACCOUNT |\
              USER_NORMAL_ACCOUNT |\
              USER_MACHINE_ACCOUNT_MASK )


//
// Defines
//

#define LM20_TOKENBYTE    0xFF                                  // net\inc\logonp.h
#define LMNT_TOKENBYTE    0xFF

#define MAX_INBOUND_MESSAGE     400
#define PING_RETRY_MAX          3               // number of attempts made against domain

#define NETRES_INITIAL_SIZE     16384


//
// Types
//

typedef enum {
    ACCOUNT_FOUND,
    ACCOUNT_NOT_FOUND,
    DOMAIN_NOT_FOUND
} SCAN_STATE;

//
// Local prototypes
//

BOOL
pEnumNetResourceWorker (
    IN OUT  PNETRESOURCE_ENUM EnumPtr
    );



//
// Implementation
//

VOID
pGenerateLogonMailslotNameA (
    OUT     PSTR SlotName,
    IN      PCSTR DomainName
    )

/*++

Routine Description:

  pGenerateLogonMailslotNameA creates the mailslot name needed to query
  an NT domain server.  It uses an undocumented syntax to open a mailslot
  to DomainName with the 16th character 1Ch.

Arguments:

  SlotName - Receives the mailslot name.  Should be a MAX_PATH buffer.

  DomainName - Specifies the name of the domain to query.

Return Value:

  none

--*/

{
    StringCopyA (SlotName, "\\\\");
    StringCatA (SlotName, DomainName);
    StringCatA (SlotName, "*");
    StringCatA (SlotName, NETLOGON_NT_MAILSLOT_A);
}



PSTR
pAppendStringA (
    OUT     PSTR Buffer,
    IN      PCSTR Source
    )

/*++

Routine Description:

  pAppendStringA appends the specified string in Source to the specified
  Buffer.  The entire string, including the nul, is copied.  The return
  value points to the character after the nul in Buffer.

Arguments:

  Buffer - Receives the copy of Source, up to and including the nul.

  Source - Specifies the nul-terminated string to copy.

Return Value:

  A pointer to the next character after the newly copied string in Buffer.
  The caller will use this pointer for additional append operations.

--*/

{
    while (*Source) {
        *Buffer++ = *Source++;
    }

    *Buffer++ = 0;

    return Buffer;
}


PWSTR
pAppendStringW (
    OUT     PWSTR Buffer,
    IN      PCWSTR Source
    )

/*++

Routine Description:

  pAppendStringW appends the specified string in Source to the specified
  Buffer.  The entire string, including the nul, is copied.  The return
  value points to the character after the nul in Buffer.

Arguments:

  Buffer - Receives the copy of Source, up to and including the nul.

  Source - Specifies the nul-terminated string to copy.

Return Value:

  A pointer to the next character after the newly copied string in Buffer.
  The caller will use this pointer for additional append operations.

--*/

{
    while (*Source) {
        *Buffer++ = *Source++;
    }

    *Buffer++ = 0;

    return Buffer;
}


PBYTE
pAppendBytes (
    OUT     PBYTE Buffer,
    IN      PBYTE Source,
    IN      UINT Len
    )

/*++

Routine Description:

  pAppendBytes appends the specified block of data in Source to the specified
  Buffer.  Len specifies the size of Source.  The return value points to
  the byte after the copied block of data in Buffer.

Arguments:

  Buffer - Receives the copy of Source

  Source - Specifies the block of data to copy

  Len - Specifies the number of bytes in Source

Return Value:

  A pointer to the next byte after the newly copied blcok of data in Buffer.
  The caller will use this pointer for additional append operations.

--*/

{
    while (Len > 0) {
        *Buffer++ = *Source++;
        Len--;
    }

    return Buffer;
}


INT
pBuildDomainPingMessageA (
    OUT     PBYTE Buffer,               // must be sizeof (NETLOGON_SAM_LOGON_REQUEST) + sizeof (DWORD)
    IN      PCSTR LookUpName,
    IN      PCSTR ReplySlotName
    )

/*++

Routine Description:

  pBuildDomainPingMessageA generates a SAM logon SMB that can be sent to
  the NT domain server's NTLOGON mailslot.  If the server receives this
  message, it will reply with either LOGON_SAM_USER_UNKNOWN, LOGON_SAM_LOGON_RESPONSE
  or LOGON_SAM_LOGON_PAUSED.

Arguments:

  Buffer - Receives the SMB message

  LookUpName - Specifies the name of the computer account that may be on
               the domain.  (The domain is specified by the mailslot name.)

  ReplySlotName - Specifies the name of an open mailslot that will receive the
                  server's response, if any.

Return Value:

  The number of bytes used in Buffer, or zero if an error occurred, such as
  out of memory.

--*/

{
    CHAR ComputerName[MAX_COMPUTER_NAMEA];
    DWORD Size;
    PNETLOGON_SAM_LOGON_REQUEST SamLogonRequest;
    PSTR p;
    DWORD ControlBits;
    DWORD DomainSidSize;
    DWORD NtVersion;
    BYTE NtTokenByte;
    BYTE LmTokenByte;
    PCWSTR UnicodeComputerName;
    PCWSTR UnicodeLookUpName;

    //
    // Get computer name
    //

    Size = sizeof (ComputerName) / sizeof (ComputerName[0]);
    if (!GetComputerNameA (ComputerName, &Size)) {
        LOG ((LOG_ERROR, "Can't get computer name."));
        return FALSE;
    }

    //
    // Create unicode strings
    //

    UnicodeComputerName = CreateUnicode (ComputerName);
    if (!UnicodeComputerName) {
        return 0;
    }

    UnicodeLookUpName = CreateUnicode (LookUpName);
    if (!UnicodeLookUpName) {
        DestroyUnicode (UnicodeComputerName);
        return 0;
    }

    //
    // Init pointers
    //

    SamLogonRequest = (PNETLOGON_SAM_LOGON_REQUEST) Buffer;
    p = (PSTR) (SamLogonRequest->UnicodeComputerName);

    //
    // Initialize request packet
    //

    SamLogonRequest->Opcode = LOGON_SAM_LOGON_REQUEST;
    SamLogonRequest->RequestCount = 0;

    //
    // Append the rest of the params together
    //

    p = (PSTR) pAppendStringW ((PWSTR) p, UnicodeComputerName);
    p = (PSTR) pAppendStringW ((PWSTR) p, UnicodeLookUpName);
    p = pAppendStringA (p, ReplySlotName);

    ControlBits = USER_MACHINE_ACCOUNT_MASK;
    p = (PSTR) pAppendBytes ((PBYTE) p, (PBYTE) (&ControlBits), sizeof (DWORD));

    DomainSidSize = 0;
    p = (PSTR) pAppendBytes ((PBYTE) p, (PBYTE) (&DomainSidSize), sizeof (DWORD));

    NtVersion = NETLOGON_NT_VERSION_1;
    p = (PSTR) pAppendBytes ((PBYTE) p, (PBYTE) (&NtVersion), sizeof (DWORD));

    NtTokenByte = LMNT_TOKENBYTE;
    LmTokenByte = LM20_TOKENBYTE;

    p = (PSTR) pAppendBytes ((PBYTE) p, &NtTokenByte, sizeof (BYTE));
    p = (PSTR) pAppendBytes ((PBYTE) p, &NtTokenByte, sizeof (BYTE));
    p = (PSTR) pAppendBytes ((PBYTE) p, &LmTokenByte, sizeof (BYTE));
    p = (PSTR) pAppendBytes ((PBYTE) p, &LmTokenByte, sizeof (BYTE));

    DestroyUnicode (UnicodeComputerName);
    DestroyUnicode (UnicodeLookUpName);

    return p - Buffer;
}


LONG
DoesComputerAccountExistOnDomain (
    IN      PCTSTR DomainName,
    IN      PCTSTR LookUpName,
    IN      BOOL WaitCursorEnable
    )

/*++

Routine Description:

  DoesComputerAccountExistOnDomain queries a domain for the existence of
  a computer account.  It does the following:

  1. Open inbound mailslot to receive server's reply
  2. Open outbound mailslot to domain server
  3. Perpare a message to query the domain server
  4. Send the message on the outbound mailslot
  5. Wait 5 seconds for a reply; stop when a response is obtained.
  6. Repeat 3, 4 and 5 three times if no repsonce

Arguments:

  DomainName - Specifies the domain to query

  LookUpName - Specifies the name of the computer account that may be on
               the domain.

Return Value:

  1 if the account was found
  0 if the account does not exist
  -1 if the domain did not respond

--*/

{
    BYTE Buffer[MAX_INBOUND_MESSAGE];
    CHAR InboundSlotSubName[MAX_MBCHAR_PATH];
    CHAR InboundSlotName[MAX_MBCHAR_PATH];
    CHAR OutboundSlotName[MAX_MBCHAR_PATH];
    PCSTR AnsiDomainName;
    PCSTR AnsiLookUpName;
    PCSTR AnsiLookUpNameWithDollar = NULL;
    HANDLE InboundSlot, OutboundSlot;
    INT OutData, InData;
    INT Size;
    INT Retry;
    BYTE OpCode;
    SCAN_STATE State = DOMAIN_NOT_FOUND;
    BOOL b;
    INT WriteRetries;
    static UINT Sequencer = 0;

#ifdef PRERELEASE
    //
    // Stress mode: do not search the net
    //

    if (g_Stress) {
        DEBUGMSG ((DBG_WARNING, "Domain lookup skipped because g_Stress is TRUE"));
        return TRUE;
    }
#endif

    //
    // Create an inbound mailslot
    //

    wsprintf (InboundSlotSubName, "\\MAILSLOT\\WIN9XUPG\\NETLOGON\\%u", Sequencer);
    InterlockedIncrement (&Sequencer);

    StringCopyA (InboundSlotName, "\\\\.");
    StringCatA (InboundSlotName, InboundSlotSubName);

    InboundSlot = CreateMailslotA (
                      InboundSlotName,
                      MAX_INBOUND_MESSAGE,
                      1000,
                      NULL
                      );

    if (InboundSlot == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "DoesComputerAccountExistOnDomain: Can't open %hs", InboundSlotName));
        return -1;
    }

    __try {
        if (WaitCursorEnable) {
            TurnOnWaitCursor();
        }

        //
        // Generate ANSI versions of domain and lookup names
        //

        AnsiDomainName = CreateDbcs (DomainName);
        AnsiLookUpName = CreateDbcs (LookUpName);

        __try {
            if (!AnsiDomainName || !AnsiLookUpName) {
                LOG ((LOG_ERROR, "Can't convert DomainName or LookUpName to ANSI"));
                __leave;
            }

            AnsiLookUpNameWithDollar = JoinTextA (AnsiLookUpName, "$");
            if (!AnsiLookUpNameWithDollar) {
                __leave;
            }

            //
            // Create outbound mailslot
            //

            pGenerateLogonMailslotNameA (OutboundSlotName, AnsiDomainName);

            OutboundSlot = CreateFileA (
                               OutboundSlotName,
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );

            if (OutboundSlot == INVALID_HANDLE_VALUE) {
                LOG ((LOG_ERROR, "Can't open %s", OutboundSlotName));
                __leave;
            }

            for (Retry = 0, State = DOMAIN_NOT_FOUND;
                 State == DOMAIN_NOT_FOUND && Retry < PING_RETRY_MAX;
                 Retry++
                 ) {

                //
                // Generate message
                //

                Size = pBuildDomainPingMessageA (Buffer, AnsiLookUpNameWithDollar, InboundSlotSubName);

                if (Size > 0) {
                    //
                    // Send the message and wait for a response
                    //

                    WriteRetries = 20;
                    do {
                        b = WriteFile (OutboundSlot, Buffer, Size, (PDWORD) &OutData, NULL);

                        if (!b || OutData != Size) {
                            if (WriteRetries && GetLastError() == ERROR_NETWORK_BUSY) {
                                b = TRUE;
                                OutData = Size;
                                WriteRetries--;
                                Sleep (50);

                                DEBUGMSG ((DBG_WARNING, "DoesComputerAccountExistOnDomain: Network busy!  Retrying..."));

                            } else {
                                LOG ((LOG_ERROR, "Machine account query failed: can't write to network mailslot."));
                                __leave;
                            }
                        }
                    } while (!b || OutData != Size);

                    //
                    // Sit on mailslot for 5 seconds until data is available.
                    // If no data comes back, assume failure.
                    // If an unrecognized response comes back, wait for another response.
                    //

                    do {
                        if (!WaitCursorEnable) {
                            //
                            // Only wait 1 second in search mode
                            //

                            Size = CheckForWaitingData (InboundSlot, sizeof (BYTE), 1000);
                        } else {
                            Size = CheckForWaitingData (InboundSlot, sizeof (BYTE), 5000);
                        }

                        if (Size > 0) {
                            //
                            // Response available!
                            //

                            if (!ReadFile (InboundSlot, Buffer, Size, (PDWORD) &InData, NULL)) {
                                LOG ((LOG_ERROR, "Failed while reading from network mail slot."));
                                __leave;
                            }

                            OpCode = *((PBYTE) Buffer);

                            if (OpCode == LOGON_SAM_USER_UNKNOWN || OpCode == LOGON_SAM_USER_UNKNOWN_EX) {
                                State = ACCOUNT_NOT_FOUND;
                            } else if (OpCode == LOGON_SAM_LOGON_RESPONSE || OpCode == LOGON_SAM_LOGON_RESPONSE_EX) {
                                State = ACCOUNT_FOUND;
                            }
                        }
                    } while (State != ACCOUNT_FOUND && Size > 0);

                } else {
                    DEBUGMSG ((DBG_WHOOPS, "Can't build domain ping message"));
                    __leave;
                }
            }
        }
        __finally {
            FreeText (AnsiLookUpNameWithDollar);
            DestroyDbcs (AnsiDomainName);   // this routine checks for NULL
            DestroyDbcs (AnsiLookUpName);
        }
    }
    __finally {
        CloseHandle (InboundSlot);
        if (WaitCursorEnable) {
            TurnOffWaitCursor();
        }
    }

    if (State == ACCOUNT_FOUND) {
        return 1;
    }

    if (State == ACCOUNT_NOT_FOUND) {
        return 0;
    }

    return -1;
}


BOOL
EnumFirstNetResource (
    OUT     PNETRESOURCE_ENUM EnumPtr,
    IN      DWORD WNetScope,                OPTIONAL
    IN      DWORD WNetType,                 OPTIONAL
    IN      DWORD WNetUsage                 OPTIONAL
    )

/*++

Routine Description:

  EnumFirstNetResource begins an enumeration of the network resources.  It
  uses pEnumNetResourceWorker to do the enumeration.

Arguments:

  EnumPtr - Receives the first enumerated network resource

  WNetScope - Specifies the RESOURCE_* flag to limit the enumeration.  If zero,
              the default scope is RESOURCE_GLOBALNET.

  WNetType - Specifies the RESOURCETYPE_* flag(s) to limit the enumerattion.
             If zero, the default type is RESOURCETYPE_ANY.

  WNetUsage - Specifies the RESOURCEUSAGE_* flag(s) to limit the enumeration.
              If zero, the default usage is all resources.

Return Value:

  TRUE if a network resource was enumerated, or FALSE if none were found.
  If return value is FALSE, GetLastError will return an error code, or
  ERROR_SUCCESS if all items were successfully enumerated.

--*/

{
    ZeroMemory (EnumPtr, sizeof (NETRESOURCE_ENUM));
    EnumPtr->State = NETRES_INIT;
    EnumPtr->EnumScope = WNetScope ? WNetScope : RESOURCE_GLOBALNET;
    EnumPtr->EnumType  = WNetType ? WNetType : RESOURCETYPE_ANY;
    EnumPtr->EnumUsage = WNetUsage ? WNetUsage : 0;         // 0 is "any"

    return pEnumNetResourceWorker (EnumPtr);
}


BOOL
EnumNextNetResource (
    IN OUT  PNETRESOURCE_ENUM EnumPtr
    )

/*++

Routine Description:

  EnumNextNetResource continues an enumeration of the network resources.  It
  uses pEnumNetResourceWorker to do the enumeration.

Arguments:

  EnumPtr - Specifies the previously enumerated item, receives the first
            enumerated network resource

Return Value:

  TRUE if a network resource was enumerated, or FALSE if none were found.
  If return value is FALSE, GetLastError will return an error code, or
  ERROR_SUCCESS if all items were successfully enumerated.

--*/

{
    return pEnumNetResourceWorker (EnumPtr);
}


BOOL
pEnumNetResourceWorker (
    IN OUT  PNETRESOURCE_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumNetResourceWorker implements a state machine to enumerate network
  resources.  The WNet APIs are used to do the enumeration.  Each call
  to the WNetEnumResources function returns up to 64 items, but
  pEnumNetResourceWorker returns only one at a time.  For this reason,
  a stack of handles and buffers are maintained by the state machine,
  simplifying the work for the caller.

Arguments:

  EnumPtr - Specifies the current enumeration state, receives the next
            enumerated network resource

Return Value:

  TRUE if a network resource was enumerated, or FALSE if none were found.
  If return value is FALSE, GetLastError will return an error code, or
  ERROR_SUCCESS if all items were successfully enumerated.

--*/

{
    LPNETRESOURCE CurrentResBase;
    LPNETRESOURCE CurrentRes;
    LPNETRESOURCE ParentRes;
    HANDLE CurrentHandle;
    UINT Entries;
    UINT Pos;
    DWORD rc;
    UINT Size;
    UINT u;

    for (;;) {
        u = EnumPtr->StackPos;

        Entries = EnumPtr->Entries[u];
        Pos = EnumPtr->Pos[u];
        CurrentResBase = (LPNETRESOURCE) EnumPtr->ResStack[u];
        CurrentRes = &CurrentResBase[Pos];
        CurrentHandle = EnumPtr->HandleStack[u];

        if (EnumPtr->StackPos) {
            ParentRes = (LPNETRESOURCE) EnumPtr->ResStack[EnumPtr->StackPos - 1];
        } else {
            ParentRes = NULL;
        }

        switch (EnumPtr->State) {

        case NETRES_INIT:
            EnumPtr->State = NETRES_OPEN_ENUM;
            break;

        case NETRES_OPEN_ENUM:
            EnumPtr->ResStack[EnumPtr->StackPos] = (PBYTE) MemAlloc (
                                                                g_hHeap,
                                                                0,
                                                                NETRES_INITIAL_SIZE
                                                                );

            rc = WNetOpenEnum (
                     EnumPtr->EnumScope,
                     EnumPtr->EnumType,
                     EnumPtr->EnumUsage,
                     ParentRes,
                     &CurrentHandle
                     );

            if (rc != NO_ERROR) {
                AbortNetResourceEnum (EnumPtr);
                SetLastError (rc);
                LOG ((LOG_ERROR, "Failed to open network resource enumeration. (%u)", rc));
                return FALSE;
            }

            EnumPtr->HandleStack[EnumPtr->StackPos] = CurrentHandle;
            EnumPtr->State = NETRES_ENUM_BLOCK;
            break;

        case NETRES_ENUM_BLOCK:
            Entries = 64;
            Size = NETRES_INITIAL_SIZE;

            rc = WNetEnumResource (
                     CurrentHandle,
                     &Entries,
                     (PBYTE) CurrentResBase,
                     &Size
                     );

            if (rc == ERROR_NO_MORE_ITEMS) {
                EnumPtr->State = NETRES_CLOSE_ENUM;
                break;
            }

            if (rc != NO_ERROR) {
                AbortNetResourceEnum (EnumPtr);
                SetLastError (rc);
                LOG ((LOG_ERROR, "Failure while enumerating network resources. (%u)", rc));
                return FALSE;
            }

            EnumPtr->Entries[EnumPtr->StackPos] = Entries;
            EnumPtr->Pos[EnumPtr->StackPos] = 0;
            EnumPtr->State = NETRES_RETURN_ITEM;
            break;

        case NETRES_RETURN_ITEM:
            EnumPtr->Connected  = (CurrentRes->dwScope & RESOURCE_CONNECTED) != 0;
            EnumPtr->GlobalNet  = (CurrentRes->dwScope & RESOURCE_GLOBALNET) != 0;
            EnumPtr->Persistent = (CurrentRes->dwScope & RESOURCE_REMEMBERED) != 0;

            EnumPtr->DiskResource  = (CurrentRes->dwType & RESOURCETYPE_DISK) != 0;
            EnumPtr->PrintResource = (CurrentRes->dwType & RESOURCETYPE_PRINT) != 0;
            EnumPtr->TypeUnknown   = (CurrentRes->dwType & RESOURCETYPE_ANY) != 0;

            EnumPtr->Domain     = (CurrentRes->dwDisplayType & RESOURCEDISPLAYTYPE_DOMAIN) != 0;
            EnumPtr->Generic    = (CurrentRes->dwDisplayType & RESOURCEDISPLAYTYPE_GENERIC) != 0;
            EnumPtr->Server     = (CurrentRes->dwDisplayType & RESOURCEDISPLAYTYPE_SERVER) != 0;
            EnumPtr->Share      = (CurrentRes->dwDisplayType & RESOURCEDISPLAYTYPE_SHARE) != 0;

            EnumPtr->Connectable = (CurrentRes->dwUsage & RESOURCEUSAGE_CONNECTABLE) != 0;
            EnumPtr->Container   = (CurrentRes->dwUsage & RESOURCEUSAGE_CONTAINER) != 0;

            EnumPtr->RemoteName = CurrentRes->lpRemoteName ? CurrentRes->lpRemoteName : S_EMPTY;
            EnumPtr->LocalName  = CurrentRes->lpLocalName ? CurrentRes->lpLocalName : S_EMPTY;
            EnumPtr->Comment    = CurrentRes->lpComment;
            EnumPtr->Provider   = CurrentRes->lpProvider;

            if (EnumPtr->Container) {
                //
                // Enum container resource
                //

                if (EnumPtr->StackPos + 1 < MAX_NETENUM_DEPTH) {
                    EnumPtr->StackPos += 1;
                    EnumPtr->State = NETRES_OPEN_ENUM;
                }
            }

            if (EnumPtr->State == NETRES_RETURN_ITEM) {
                EnumPtr->State = NETRES_ENUM_BLOCK_NEXT;
            }
            return TRUE;

        case NETRES_ENUM_BLOCK_NEXT:
            u = EnumPtr->StackPos;
            EnumPtr->Pos[u] += 1;
            if (EnumPtr->Pos[u] >= EnumPtr->Entries[u]) {
                EnumPtr->State = NETRES_ENUM_BLOCK;
            } else {
                EnumPtr->State = NETRES_RETURN_ITEM;
            }

            break;

        case NETRES_CLOSE_ENUM:
            WNetCloseEnum (CurrentHandle);
            MemFree (g_hHeap, 0, EnumPtr->ResStack[EnumPtr->StackPos]);

            if (!EnumPtr->StackPos) {
                EnumPtr->State = NETRES_DONE;
                break;
            }

            EnumPtr->StackPos -= 1;
            EnumPtr->State = NETRES_ENUM_BLOCK_NEXT;
            break;

        case NETRES_DONE:
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }
    }
}


VOID
AbortNetResourceEnum (
    IN OUT  PNETRESOURCE_ENUM EnumPtr
    )

/*++

Routine Description:

  AbortNetResourceEnum cleans up all allocated memory and open handles,
  and then sets the enumeration state to NETRES_DONE to stop any
  subsequent enumeration.

  If enumeration has already completed or was previously aborted, this
  routine simply returns without doing anything.

Arguments:

  EnumPtr - Specifies the enumeration to stop, receives an enumeration
            structure that will not enumerate any more items unless it
            is given back to EnumFirstNetResource.

Return Value:

  none

--*/

{
    UINT u;

    if (EnumPtr->State == NETRES_DONE) {
        return;
    }

    for (u = 0 ; u <= EnumPtr->StackPos ; u++) {
        WNetCloseEnum (EnumPtr->HandleStack[u]);
        MemFree (g_hHeap, 0, EnumPtr->ResStack[u]);
    }

    EnumPtr->State = NETRES_DONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\dosmig95.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dosmig95.c

Abstract:

    Handles win95 side gathering of data from config.sys and autoexec.bat files.

Author:

    Marc R. Whitten (marcw) 15-Feb-1997

Revision History:

    Marc R. Whitten (marcw) 08-Mar-1999 - Cleanup Environment variable parsing.
    Marc R. Whitten (marcw) 5-Sep-1997  - Major changes.
    Marc R. Whitten (marcw) 18-Aug-1997 - Bug sweep.
    Marc R. Whitten (marcw) 14-Apr-1997 - Dosmig is now ProgressBar aware.

--*/
#include "pch.h"

#define DBG_DOSMIG  "DOSMIG"




typedef BOOL (RULEFUNC)(PLINESTRUCT,DWORD);

typedef struct _PARSERULE PARSERULE, *PPARSERULE;

struct _PARSERULE {

    PCTSTR      Name;
    PCTSTR      Pattern;
    RULEFUNC *  Handle;
    DWORD       Parameter;
    PPARSERULE  Next;

};


typedef enum {

    DOSMIG_UNUSED,
    DOSMIG_BAD,
    DOSMIG_UNKNOWN,
    DOSMIG_USE,
    DOSMIG_MIGRATE,
    DOSMIG_IGNORE,
    DOSMIG_LAST

} DOSMIG_LINETAG, *PDOSMIG_LINETAG;



typedef struct _PARSERULES {

    PCTSTR      Name;
    PPARSERULE  RuleList;
    PPARSERULE  DefaultRule;

} PARSERULES, *PPARSERULES;


BOOL        g_IncompatibilityDetected = FALSE;
GROWBUFFER  g_IncompatibilityBuffer = GROWBUF_INIT;


//
// Global pointers to the rule lists for config.sys and batch files.
//
PARSERULES  g_ConfigSysRules;
PARSERULES  g_BatchFileRules;
PPARSERULES g_CurrentRules = NULL;

//
// This variable holds the offset within memdb to where the file currently being parsed is saved.
//
DWORD       g_CurrentFileOffset;

//
// This growlist holds the list of all files that will be parsed. It can increase during parsing
// (e.g. by encountering a CALL statement in a batch file.)
//
GROWLIST    g_FileList = GROWLIST_INIT;


GROWBUFFER g_LineGrowBuf = GROWBUF_INIT;
GROWBUFFER  g_ExtraPaths = GROWBUF_INIT;
#define MAXFILESIZE 0xFFFFFFFF


//
// Various bits of state that are kept during parsing..
//
PCTSTR      g_CurrentFile;
PCTSTR      g_CurrentLine;
DWORD       g_CurrentLineNumber;
POOLHANDLE  g_DosMigPool = NULL;


#define BATCHFILELIST                                                                           \
    DEFAULTPARSERULE(TEXT("Default Rule"),NULL,pHandleUnknownBatLine,0)                         \
    PARSERULE(TEXT("Rem"),TEXT("REM *"),pSaveItem,DOSMIG_USE)                                   \
    PARSERULE(TEXT("    "),TEXT("*DOSKEY*"),pSaveItem,DOSMIG_MIGRATE)                           \
    PARSERULE(TEXT(": (Menu or Label"),TEXT(":*"),pSaveItem,DOSMIG_USE)                         \
    PARSERULE(TEXT("@"),TEXT("@*"),pHandleAtSign,0)                                             \
    PARSERULE(TEXT("CLS"),TEXT("CLS *"),pSaveItem,DOSMIG_USE)                                   \
    PARSERULE(TEXT("CD"),TEXT("CD *"),pSaveItem,DOSMIG_USE)                                     \
    PARSERULE(TEXT("CHDIR"),TEXT("CHDIR *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("PAUSE"),TEXT("PAUSE *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("ECHO"),TEXT("ECHO *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("ATTRIB"),TEXT("ATTRIB *"),pSaveItem,DOSMIG_USE)                             \
    PARSERULE(TEXT("CHDIR"),TEXT("CHDIR *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("CHCP"),TEXT("CHCP *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("CHOICE"),TEXT("CHOICE *"),pSaveItem,DOSMIG_IGNORE)                          \
    PARSERULE(TEXT("CALL"),TEXT("CALL *"),pHandleCall,0)                                        \
    PARSERULE(TEXT("COMMAND"),TEXT("COMMAND *"),pSaveItem,DOSMIG_MIGRATE)                       \
    PARSERULE(TEXT("CHKDSK"),TEXT("CHKDSK *"),pSaveItem,DOSMIG_IGNORE)                          \
    PARSERULE(TEXT("COPY"),TEXT("COPY *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("CTTY"),TEXT("CTTY *"),pSaveItem,DOSMIG_IGNORE)                              \
    PARSERULE(TEXT("DATE"),TEXT("DATE *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("DBLSPACE"),TEXT("DBLSPACE *"),pSaveItem,DOSMIG_BAD)                         \
    PARSERULE(TEXT("DEFRAG"),TEXT("DEFRAG *"),pSaveItem,DOSMIG_IGNORE)                          \
    PARSERULE(TEXT("DEL"),TEXT("DEL *"),pSaveItem,DOSMIG_BAD)                                   \
    PARSERULE(TEXT("DELETE"),TEXT("DELETE *"),pSaveItem,DOSMIG_USE)                             \
    PARSERULE(TEXT("DELOLDDOS"),TEXT("DELOLDDOS *"),pSaveItem,DOSMIG_IGNORE)                    \
    PARSERULE(TEXT("DELTREE"),TEXT("DELTREE *"),pSaveItem,DOSMIG_BAD)                           \
    PARSERULE(TEXT("DIR"),TEXT("DIR *"),pSaveItem,DOSMIG_USE)                                   \
    PARSERULE(TEXT("DISKCOMP"),TEXT("DISKCOMP *"),pSaveItem,DOSMIG_USE)                         \
    PARSERULE(TEXT("DISKCOPY"),TEXT("DISKCOPY *"),pSaveItem,DOSMIG_USE)                         \
    PARSERULE(TEXT("DOSSHELL"),TEXT("DOSSHELL *"),pSaveItem,DOSMIG_BAD)                         \
    PARSERULE(TEXT("DRVSPACE"),TEXT("DRVSPACE *"),pSaveItem,DOSMIG_BAD)                         \
    PARSERULE(TEXT("ECHO"),TEXT("ECHO *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("EDIT"),TEXT("EDIT *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("EMM386"),TEXT("EMM386 *"),pSaveItem,DOSMIG_IGNORE)                          \
    PARSERULE(TEXT("ERASE"),TEXT("ERASE *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("EXIT"),TEXT("EXIT *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("EXPAND"),TEXT("EXPAND *"),pSaveItem,DOSMIG_USE)                             \
    PARSERULE(TEXT("FASTHELP"),TEXT("FASTHELP *"),pSaveItem,DOSMIG_IGNORE)                      \
    PARSERULE(TEXT("FASTOPEN"),TEXT("FASTOPEN *"),pSaveItem,DOSMIG_IGNORE)                      \
    PARSERULE(TEXT("FC"),TEXT("FC *"),pSaveItem,DOSMIG_USE)                                     \
    PARSERULE(TEXT("FDISK"),TEXT("FDISK *"),pSaveItem,DOSMIG_BAD)                               \
    PARSERULE(TEXT("FIND"),TEXT("FIND *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("FOR"),TEXT("FOR *"),pSaveItem,DOSMIG_USE)                                   \
    PARSERULE(TEXT("FORMAT"),TEXT("FORMAT *"),pSaveItem,DOSMIG_USE)                             \
    PARSERULE(TEXT("GOTO"),TEXT("GOTO *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("GRAPHICS"),TEXT("GRAPHICS *"),pSaveItem,DOSMIG_USE)                         \
    PARSERULE(TEXT("HELP"),TEXT("HELP *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("IF"),TEXT("IF *"),pSaveItem,DOSMIG_USE)                                     \
    PARSERULE(TEXT("INTERLNK"),TEXT("INTERLNK*"),pSaveItem,DOSMIG_BAD)                          \
    PARSERULE(TEXT("INTERSVR"),TEXT("INTERSVR*"),pSaveItem,DOSMIG_BAD)                          \
    PARSERULE(TEXT("KEYB"),TEXT("KEYB *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("LABEL"),TEXT("LABEL *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("LH"),TEXT("LH *"),pHandleLoadHigh,0)                                        \
    PARSERULE(TEXT("LOADHIGH"),TEXT("LOADHIGH *"),pHandleLoadHigh,0)                            \
    PARSERULE(TEXT("MD"),TEXT("MD *"),pSaveItem,DOSMIG_USE)                                     \
    PARSERULE(TEXT("MKDIR"),TEXT("MKDIR *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("MEM"),TEXT("MEM *"),pSaveItem,DOSMIG_USE)                                   \
    PARSERULE(TEXT("MEMMAKER"),TEXT("MEMMAKER *"),pSaveItem,DOSMIG_BAD)                         \
    PARSERULE(TEXT("MODE"),TEXT("MODE *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("MORE"),TEXT("MORE *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("MOVE"),TEXT("MOVE *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("MSAV"),TEXT("MSAV *"),pSaveItem,DOSMIG_BAD)                                 \
    PARSERULE(TEXT("MSBACKUP"),TEXT("MSBACKUP *"),pSaveItem,DOSMIG_BAD)                         \
    PARSERULE(TEXT("MSCDEX"),TEXT("*MSCDEX*"),pHandleMSCDEX,0)                                  \
    PARSERULE(TEXT("MSD"),TEXT("MSD *"),pSaveItem,DOSMIG_IGNORE)                                \
    PARSERULE(TEXT("NLSFUNC"),TEXT("NLSFUNC *"),pSaveItem,DOSMIG_IGNORE)                        \
    PARSERULE(TEXT("NUMLOCK"),TEXT("NUMLOCK *"),pSaveItem,DOSMIG_IGNORE)                        \
    PARSERULE(TEXT("PATH"),TEXT("PATH *"),pSaveItem,DOSMIG_MIGRATE)                             \
    PARSERULE(TEXT("PATH"),TEXT("PATH*=*"),pSaveItem,DOSMIG_MIGRATE)                            \
    PARSERULE(TEXT("PAUSE"),TEXT("PAUSE *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("POWER"),TEXT("POWER *"),pSaveItem,DOSMIG_IGNORE)                            \
    PARSERULE(TEXT("PRINT"),TEXT("PRINT *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("PROMPT"),TEXT("PROMPT*"),pSaveItem,DOSMIG_MIGRATE)                          \
    PARSERULE(TEXT("QBASIC"),TEXT("QBASIC *"),pSaveItem,DOSMIG_USE)                             \
    PARSERULE(TEXT("RD"),TEXT("RD *"),pSaveItem,DOSMIG_USE)                                     \
    PARSERULE(TEXT("RMDIR"),TEXT("RMDIR *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("REN"),TEXT("REN *"),pSaveItem,DOSMIG_USE)                                   \
    PARSERULE(TEXT("RENAME"),TEXT("RENAME *"),pSaveItem,DOSMIG_USE)                             \
    PARSERULE(TEXT("REPLACE"),TEXT("REPLACE *"),pSaveItem,DOSMIG_USE)                           \
    PARSERULE(TEXT("RESTORE"),TEXT("RESTORE *"),pSaveItem,DOSMIG_USE)                           \
    PARSERULE(TEXT("SCANDISK"),TEXT("SCANDISK *"),pSaveItem,DOSMIG_BAD)                         \
    PARSERULE(TEXT("SET"),TEXT("SET*=*"),pSaveItem,DOSMIG_MIGRATE)                              \
    PARSERULE(TEXT("SET"),TEXT("SET *"),pSaveItem,DOSMIG_MIGRATE)                               \
    PARSERULE(TEXT("SETVER"),TEXT("SETVER *"),pSaveItem,DOSMIG_USE)                             \
    PARSERULE(TEXT("SHARE"),TEXT("SHARE *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("SHIFT"),TEXT("SHIFT *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("SMARTDRV"),TEXT("SMARTDRV*"),pSaveItem,DOSMIG_IGNORE)                       \
    PARSERULE(TEXT("SORT"),TEXT("SORT *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("SUBST"),TEXT("SUBST *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("SYS"),TEXT("SYS *"),pSaveItem,DOSMIG_BAD)                                   \
    PARSERULE(TEXT("TIME"),TEXT("TIME *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("TREE"),TEXT("TREE *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("TRUENAME"),TEXT("TRUENAME *"),pSaveItem,DOSMIG_BAD)                         \
    PARSERULE(TEXT("TYPE"),TEXT("TYPE *"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("UNDELETE"),TEXT("UNDELETE *"),pSaveItem,DOSMIG_BAD)                         \
    PARSERULE(TEXT("UNFORMAT"),TEXT("UNFORMAT *"),pSaveItem,DOSMIG_BAD)                         \
    PARSERULE(TEXT("VER"),TEXT("VER *"),pSaveItem,DOSMIG_USE)                                   \
    PARSERULE(TEXT("VERIFY"),TEXT("VERIFY *"),pSaveItem,DOSMIG_USE)                             \
    PARSERULE(TEXT("VOL"),TEXT("VOL *"),pSaveItem,DOSMIG_USE)                                   \
    PARSERULE(TEXT("VSAFE"),TEXT("VSAFE *"),pSaveItem,DOSMIG_BAD)                               \
    PARSERULE(TEXT("XCOPY"),TEXT("XCOPY *"),pSaveItem,DOSMIG_USE)                               \
    PARSERULE(TEXT("High"),TEXT("*High *"),pHandleHighFilter,0)



#define CONFIGSYSLIST                                                                           \
    DEFAULTPARSERULE(TEXT("Default Rule"),NULL,pSaveItem,DOSMIG_UNKNOWN)                        \
    PARSERULE(TEXT("Rem"),TEXT("REM *"),pSaveItem,DOSMIG_USE)                                   \
    PARSERULE(TEXT("[ (Menu)"),TEXT("[*"),pSaveItem,DOSMIG_USE)                                 \
    PARSERULE(TEXT("DEVICE"),TEXT("DEVICE *"),pHandleConfigSysDevice,0)                        \
    PARSERULE(TEXT("INSTALL"),TEXT("INSTALL *"),pHandleConfigSysDevice,0)                      \
    PARSERULE(TEXT("MENUITEM"),TEXT("MENUITEM *"),pSaveItem,DOSMIG_IGNORE)                     \
    PARSERULE(TEXT("MENUDEFAULT"),TEXT("MENUDEFAULT*"),pSaveItem,DOSMIG_IGNORE)               \
    PARSERULE(TEXT("MENUCOLOR"),TEXT("MENUCOLOR *"),pSaveItem,DOSMIG_IGNORE)                    \
    PARSERULE(TEXT("SUBMENU"),TEXT("SUBMENU *"),pSaveItem,DOSMIG_IGNORE)                       \
    PARSERULE(TEXT("STACKS"),TEXT("STACKS *"),pSaveItem,DOSMIG_IGNORE)                         \
    PARSERULE(TEXT("DOS"),TEXT("DOS *"),pSaveItem,DOSMIG_IGNORE)                               \
    PARSERULE(TEXT("FILES"),TEXT("FILES *"),pSaveItem,DOSMIG_IGNORE)                           \
    PARSERULE(TEXT("SHELL"),TEXT("SHELL *"),pHandleShell,0)                                    \
    PARSERULE(TEXT("COUNTRY"),TEXT("COUNTRY *"),pSaveItem,DOSMIG_IGNORE)                       \
    PARSERULE(TEXT("BUFFERS"),TEXT("BUFFERS *"),pSaveItem,DOSMIG_IGNORE)                       \
    PARSERULE(TEXT("BREAK"),TEXT("BREAK *"),pSaveItem,DOSMIG_IGNORE)                            \
    PARSERULE(TEXT("DRIVEPARM"),TEXT("DRIVEPARM *"),pSaveItem,DOSMIG_BAD)                      \
    PARSERULE(TEXT("FCBS"),TEXT("FCBS *"),pSaveItem,DOSMIG_IGNORE)                             \
    PARSERULE(TEXT("INCLUDE"),TEXT("INCLUDE *"),pSaveItem,DOSMIG_IGNORE)                       \
    PARSERULE(TEXT("LASTDRIVE"),TEXT("LASTDRIVE *"),pSaveItem,DOSMIG_IGNORE)                   \
    PARSERULE(TEXT("SET"),TEXT("SET*=*"),pSaveItem,DOSMIG_MIGRATE)                              \
    PARSERULE(TEXT("SET"),TEXT("SET *"),pSaveItem,DOSMIG_MIGRATE)                               \
    PARSERULE(TEXT("SWITCHES"),TEXT("SWITCHES*"),pSaveItem,DOSMIG_IGNORE)                       \
    PARSERULE(TEXT("VERIFY"),TEXT("VERIFY *"),pSaveItem,DOSMIG_USE)                             \
    PARSERULE(TEXT("High"),TEXT("*High *"),pHandleHighFilter,0)

BOOL
InitParser (
    VOID
    );


VOID
CleanUpParser (
    VOID
    );


BOOL
ParseLine (
    IN  PTSTR        Line,
    IN  PPARSERULES  ParseRules
    );

BOOL
ParseFile (
    IN LPCTSTR      File,
    IN PPARSERULES  ParseRules
    );




BOOL
ParseDosFiles (
    VOID
    );

BOOL
ParseEnvironmentVariables (
    VOID
    );

VOID
BuildParseRules (
    VOID
    );




/*++

Routine Description:

  pGetNextLine retrieves a complete line from the file being processed.

Arguments:

  None.

Return Value:

  A valid lline from the current file being parsed, or, NULL if there are no
  more lines to parse..

--*/

PTSTR
pGetNextLine (
    VOID
    )

{
    PTSTR rLine = NULL;
    PTSTR eol = NULL;

    MYASSERT(g_LineGrowBuf.Buf);


    while (!rLine && g_LineGrowBuf.UserIndex < g_LineGrowBuf.End) {

        //
        // Set rLine to the current user index within the growbuf.
        //
        rLine = g_LineGrowBuf.Buf + g_LineGrowBuf.UserIndex;

        //
        // Walk forward in the growbuf, looking for a \r or \n or the end of the file.
        //
        eol = _tcschr(rLine, TEXT('\n'));
        if(!eol) {
            eol = _tcschr(rLine, TEXT('\r'));
        }

        if (!eol) {
            eol = _tcschr(rLine, 26);
        }

        if (!eol) {
            eol = GetEndOfString (rLine);
        }

        //
        // Remember where to start from next time.
        //
        g_LineGrowBuf.UserIndex = (DWORD) eol - (DWORD) g_LineGrowBuf.Buf + 1;

        //
        // Now, walk backwards, trimming off all of the white space.
        //
        do {

            *eol = 0;
            eol  = _tcsdec2(rLine,eol);

        } while (eol && _istspace(*eol));

        if (!eol) {
            //
            // This is a blank line. NULL out rLine and get the next line.
            //
            rLine = NULL;
        }

    }

    g_CurrentLineNumber++;


    return rLine;
}


/*++

Routine Description:

  pGetFirstLine is responsible for setting up the data structure that will
  hold the lines of the file to parse. After setting up the data structure,
  pGetFirstLine calls pGetNextLine to return the first line of the file.

Arguments:

  FileHandle - Contains a valid file handle opened via CreateFile.

Return Value:

  The first complete line of the file being parse, or NULL if there are no
  lines, or there was an error..

--*/


PTSTR
pGetFirstLine (
    IN HANDLE FileHandle
    )
{
    DWORD fileSize;
    DWORD numBytesRead;
    PTSTR rLine = NULL;

    MYASSERT(FileHandle != INVALID_HANDLE_VALUE);

    g_LineGrowBuf.End = 0;
    g_LineGrowBuf.UserIndex = 0;

    //
    // Get the file size. We'll read the whole file into a grow buf.
    //
    fileSize = GetFileSize(FileHandle,NULL);

    if (fileSize != MAXFILESIZE && fileSize != 0) {

        //
        // Ensure that the growbuffer is large enough for this file and
        // then read the file into it.
        //
        if (GrowBuffer(&g_LineGrowBuf,fileSize)) {

            if (ReadFile(
                    FileHandle,
                    g_LineGrowBuf.Buf,
                    fileSize,
                    &numBytesRead,
                    NULL
                    )) {

                //
                // Null terminate the whole file..for good measure.
                //
                *(g_LineGrowBuf.Buf + g_LineGrowBuf.End) = 0;


                //
                // Now that we have the file in memory, return the first line to the
                // caller.
                //
                rLine = pGetNextLine();
            }
            else {

                LOG((LOG_ERROR,"Dosmig: Error reading from file."));

            }

        } else {

            DEBUGMSG((DBG_ERROR,"Dosmig: Growbuf failure in pGetFirstLine."));
        }
    }
    else {

        DEBUGMSG((DBG_WARNING, "Dosmig: File to large to read or empty file... (filesize: %u)",fileSize));
    }

    return rLine;
}



/*++

Routine Description:

  pFindParseRule trys to find a parse rule that matches the line passed in.
  The function will first search the regular rules in the PARSERULES
  structure passed in. If the line does not match any of the rules found
  there, it will return the default rule.

Arguments:

  Line  - Contains the valid line to try to match with a parse rule.
  Rules - Contains a pointer to the set of rules to look through.

Return Value:

  The rule that should be used to parse the given line. Since a default rule
  is required, this function is guaranteed not to return NULL.

--*/


PPARSERULE
pFindParseRule (
    IN PLINESTRUCT LineStruct,
    IN PPARSERULES Rules
    )
{
    PPARSERULE rRule                    = NULL;
    PTSTR      matchLine                = NULL;


    MYASSERT(LineStruct && Rules && Rules -> DefaultRule);

    rRule = Rules -> RuleList;

    //
    // Minor kludge here: The parse code uses pattern matches with rules that look
    // something like: "REM *" for example. This pattern depends on there being at least
    // one bit of white space after a REM statement. Unfortunately, a line such as
    // "REM" is entirely possible in the growbuf (Line). So, we actually perform the match
    // against the line with an extra space added.
    //
    matchLine = JoinText(LineStruct -> Command,TEXT(" "));

    if (matchLine) {

        while (rRule && !IsPatternMatch(rRule -> Pattern, matchLine)) {
            rRule = rRule -> Next;
        }


        if (!rRule) {
            rRule = Rules -> DefaultRule;
        }

        FreeText(matchLine);
    }

    return rRule;
}



/*++

Routine Description:

  InitParser is responsible for doing any one-time initialization of the
  parser. It should be called only once, before any parsing is done.

Arguments:

  None.

Return Value:

  TRUE if the parser was successfully initialized, FALSE otherwise.

--*/


BOOL
InitParser (
    VOID
    )
{

    BOOL rSuccess = TRUE;

    if (g_ToolMode) {
        g_DosMigPool = PoolMemInitNamedPool ("DosMig");
    }

    return rSuccess;
}



/*++

Routine Description:

  CleanUpParser is responsible for doing any one time cleanup of the parser.
  It should be called after all parsing is done.

Arguments:

  None.

Return Value:



--*/


VOID
CleanUpParser (
    VOID
    )
{
    if (g_ToolMode) {

        PoolMemDestroyPool (g_DosMigPool);

    }



    FreeGrowBuffer(&g_LineGrowBuf);
    FreeGrowBuffer(&g_ExtraPaths);

}


BOOL
pEnsurePathHasExecutableExtension (
    OUT    PTSTR NewPath,
    IN     PTSTR OldPath,
    IN     PTSTR File OPTIONAL
    )
{

    BOOL            rSuccess    = FALSE;
    PCTSTR          p           = NULL;
    WIN32_FIND_DATA findData;
    HANDLE          h           = INVALID_HANDLE_VALUE;

    StringCopy(NewPath,OldPath);

    if (File) {
        AppendPathWack(NewPath);
        StringCat(NewPath,File);
    }

    StringCat(NewPath,TEXT("*"));


    if ((h=FindFirstFile(NewPath,&findData)) != INVALID_HANDLE_VALUE) {
        do {
            p = GetFileExtensionFromPath(findData.cFileName);
            if (p) {
                if (StringIMatch(p,TEXT("exe")) ||
                    StringIMatch(p,TEXT("bat")) ||
                    StringIMatch(p,TEXT("com")) ||
                    StringIMatch(p,TEXT("sys"))) {

                    p = _tcsrchr(NewPath,TEXT('\\'));

                    MYASSERT (p);
                    if (p) {

                        StringCopy(
                            _tcsinc(p),
                            *findData.cAlternateFileName ? findData.cAlternateFileName : findData.cFileName
                            );

                        FindClose(h);
                        rSuccess = TRUE;
                        break;
                    }
                }
            }
        } while (FindNextFile(h,&findData));
    }


    return rSuccess;
}

BOOL
pGetFullPath (
    IN OUT PLINESTRUCT LineStruct
    )
{
    BOOL            rSuccess    = TRUE;
    PATH_ENUM       e;
    HANDLE          h           = INVALID_HANDLE_VALUE;
    BOOL            pathFound   = FALSE;

    if (StringIMatch(LineStruct -> Path, LineStruct -> Command)) {

         //
         // No path information was stored in the config line. We have to find the full path ourselves.
         //
         if (EnumFirstPath (&e, g_ExtraPaths.Buf, NULL, NULL)) {

            do {
                rSuccess = pEnsurePathHasExecutableExtension(LineStruct -> FullPath, e.PtrCurrPath, LineStruct -> Command);
                if (rSuccess) {
                    EnumPathAbort(&e);
                    break;
                }
            } while (EnumNextPath(&e));
         }

    }
    else {

        //
        // A full path name was specified in the line. Now all we need to do is ensure that it includes the extension.
        //
        rSuccess = pEnsurePathHasExecutableExtension(LineStruct -> FullPath, LineStruct -> Path, NULL);
    }

    return rSuccess;
}



VOID
InitLineStruct (
    OUT PLINESTRUCT LineStruct,
    IN  PTSTR       Line
    )
{

    BOOL            inQuotes = FALSE;
    PTSTR           p       = NULL;
    TCHAR           oldChar;
    TCHAR           ntPath[MEMDB_MAX];
    static  TCHAR   extraPath[MEMDB_MAX] = "";

    MYASSERT(Line);

    ZeroMemory(LineStruct,sizeof(LINESTRUCT));


    //
    // If line is empty, we are done..
    //
    if (!*Line) {
        return;
    }

    //
    // Save away a copy of the full line.
    //
    StringCopy(LineStruct -> FullLine,Line);

    //
    // Seperate the path and the arguments.
    //
    p = Line;
    while(!*LineStruct -> Path) {

        if (!*p) {
            StringCopy(LineStruct -> Path,Line);
            break;
        }

        if (*p == TEXT('"')) {
            inQuotes = !inQuotes;
        }

        if ((*p == TEXT(' ') && !inQuotes) || *p == TEXT('=')) {

            //
            // reached the end of the command/path part of the string.
            //
            oldChar = *p;
            *p       = 0;
            StringCopy(LineStruct -> Path,Line);
            *p       = oldChar;
            StringCopy(LineStruct -> Arguments,p);
            break;
        }

        p = _tcsinc(p);
    }

    //
    // Grab the actual command.
    //
    p = _tcsrchr(LineStruct -> Path,TEXT('\\'));
    if (p) {
        StringCopy(LineStruct -> Command,_tcsinc(p));
    }
    else {
        StringCopy(LineStruct -> Command,LineStruct -> Path);
    }

    //
    // We need to find the fully qualified path, with extension, and if that path will change on NT.
    //
    if (!pGetFullPath(LineStruct)) {
        DEBUGMSG((DBG_VERBOSE,"Could not get full path for %s.",LineStruct -> FullLine));
        StringCopy(LineStruct -> FullPath,LineStruct -> Path);
        LineStruct -> StatusOnNt = FILESTATUS_UNCHANGED;
    }
    else {

        LineStruct -> StatusOnNt = GetFileInfoOnNt(LineStruct -> FullPath, ntPath, MEMDB_MAX);
    }

    //
    // We only change the line if it is moved on NT and they specified a path before.
    //
    if ((LineStruct -> StatusOnNt & FILESTATUS_MOVED) && (!StringIMatch(LineStruct -> Path, LineStruct -> Command))) {

        StringCopy(LineStruct -> PathOnNt,ntPath);

    }
    else {
        StringCopy(LineStruct -> PathOnNt,LineStruct -> Path);
    }

}


/*++

Routine Description:

  ParseLine parses a single line of a text using the provided parse rules.

Arguments:

  Line       - Contains a valid string that the caller wishes to be
               parsed.

  ParseRules - Points to the list of rules to use in parsing the provided
               line.

Return Value:

  TRUE if the line was successfully parsed, FALSE
  otherwise.


--*/

BOOL
ParseLine (
    IN  PTSTR        Line,
    IN  PPARSERULES  ParseRules
    )
{

    BOOL rSuccess = FALSE;
    PPARSERULE  rule;
    LINESTRUCT  ls;


    InitLineStruct(&ls,Line);

    //
    // Look for a match in the parse rules. call the matching rule.
    // If no match is found, call the default rule.
    //

    rule = pFindParseRule(&ls,ParseRules);

    if (rule) {

        rSuccess = (rule -> Handle)(&ls,rule -> Parameter);
        DEBUGMSG_IF ((!rSuccess,DBG_ERROR,"The %s rule reported an error parsing the line:\n\t%s",rule -> Name, Line));
        if (!rSuccess) {
            LOG ((
                LOG_WARNING,
                "There was an error processing the line %s in the file %s. "
                "There could be problems associated with this file after migration.",
                Line,
                g_CurrentFile
                ));
        }
    }

    return rSuccess;

}




/*++

Routine Description:

  ParseFile parses an entire file using the provided parse rules.

Arguments:

  File       - The path of a file that the caller wishes parsed.
  ParseRules - Points to the list of rules to use in parsing this file.

Return Value:

  TRUE if the file was successfully parsed, FALSE otherwise.

--*/


BOOL
ParseFile (
    IN LPCTSTR      File,
    IN PPARSERULES  ParseRules
    )
{
    BOOL        rSuccess = TRUE;
    HANDLE      fileHandle;
    PTSTR       line;

    MYASSERT(File);
    MYASSERT(ParseRules);

    DEBUGMSG((DBG_DOSMIG,"Parsing file %s. Parse rules: %s",File,ParseRules -> Name));

    //
    // Initialize global per file parse variables.
    //
    g_CurrentFile       = File;
    g_CurrentLineNumber = 0;
    g_CurrentLine       = NULL;

    //
    // Open File for parsing
    //
    fileHandle = CreateFile(
                    File,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,                   // Handle cannot be inherited.
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL                    // No template file.
                    );



    if (fileHandle != INVALID_HANDLE_VALUE) {

        //
        // Parse each line of the file.
        //
        line = pGetFirstLine(fileHandle);

        if (line) {

            do {

                //
                // Save the current line away.
                //
                g_CurrentLine = line;

                if (SizeOfString (line) <= MEMDB_MAX) {
                    ParseLine(line,ParseRules);
                } else {
                    SetLastError (ERROR_SUCCESS);
                    LOG((LOG_ERROR, "Line too long in %s; setup will not migrate it", File));
                }
                //
                // Get the next line.
                //
                line = pGetNextLine();


            } while (line && rSuccess);
        }

        CloseHandle(fileHandle);

    }
    ELSE_DEBUGMSG((DBG_WARNING,"Could not open file %s for parsing. ",File));

    return rSuccess;

}










VOID
pAddMessage (
    IN UINT         Type,
    IN UINT         LineNumber,
    IN PCTSTR       File,
    IN PCTSTR       Line,
    IN PCTSTR       Path
    )

{



    TCHAR   lineNumberString[20];
    UINT    messageId;
    PCTSTR  message;
    PCTSTR  totalMessage;
    PCTSTR  argArray[3];




    //
    // if this is the first message found, add a report message. In any case, add
    // a message to the setupact.log.
    //
    if (!g_IncompatibilityDetected) {
        /*
        Don't Display this message -- It just confuses users without offering any real information.

        baseGroup   = GetStringResource(MSG_INSTALL_NOTES_ROOT);
        subGroup    = GetStringResource(MSG_DOS_WARNING_SUBGROUP);
        message     = GetStringResource(MSG_DOS_WARNING);

        if (baseGroup && subGroup && message) {

            group = JoinPaths(baseGroup,subGroup);

            MsgMgr_ObjectMsg_Add (
                Path,
                group,
                message
                );
        }

        if (message) {
            FreeStringResource(message);
        }
        if (subGroup) {
            FreeStringResource(subGroup);
        }
        if (baseGroup) {
            FreeStringResource(baseGroup);
        }
        if (group) {
            FreePathString(group);
        }
        */

        g_IncompatibilityDetected = TRUE;
    }

    messageId = Type == DOSMIG_BAD ? MSG_DOS_INCOMPATIBLE_ITEM : MSG_DOS_UNKNOWN_ITEM;

    //
    // Prepare message
    //
    wsprintf(lineNumberString,"%u",LineNumber);


    argArray[0] = lineNumberString,
    argArray[1] = File;
    argArray[2] = Line;

    message = ParseMessageID(messageId,argArray);

    if (message) {

        totalMessage=GrowBuffer(&g_IncompatibilityBuffer,SizeOfString(message) + 2);
        if (totalMessage) {

            StringCopy( (PTSTR) (g_IncompatibilityBuffer.Buf + g_IncompatibilityBuffer.UserIndex), message);
            StringCat( (PTSTR) (g_IncompatibilityBuffer.Buf + g_IncompatibilityBuffer.UserIndex), TEXT("\r\n"));

            g_IncompatibilityBuffer.UserIndex += ByteCount (message) + 2;
        }

        FreeStringResource(message);
    }
}





/*++

Routine Description:

  pSaveItem is a common routine that saves a line into memdb along with the
  information that dosmignt will need to successfully migrate the line in GUI
  mode. Depending on the type of the line, this function may also add an
  incompatibility message to memdb.

Arguments:

  Line - A valid line of text. The current line being parsed. Note that this
         line may have been altered through parse rules and thus be different
         than g_CurrentLine. g_CurrentLine is what is saved into memdb, this
         parameter is ignored.
  Type - The type of the line. This information is saved into memdb where it
         will be used by dosmignt during GUI mode processing. Type is also
         used to trigger incompatibility messages, if necessary.

Return Value:

  TRUE if the line was successfully saved, FALSE otherwise.

--*/


BOOL
pSaveItem (
    IN PLINESTRUCT  LineStruct,
    IN DWORD        Type
    )
{
    BOOL            rSuccess = TRUE;
    static  DWORD   enumerator = 0;
    TCHAR           enumString[20];
    TCHAR           key[MEMDB_MAX];
    TCHAR           lineToSave[MEMDB_MAX];

    MYASSERT(LineStruct);


    //
    // First, save away all of the information into memdb. We'll need it on the NT side.
    //
    wsprintf(enumString,TEXT("%07u"),enumerator++);

    //
    // Fix up the g_CurrentLine as necessary..
    //

    StringCopy(lineToSave,g_CurrentLine);
    if (!StringIMatch(LineStruct -> Path, LineStruct -> Command)) {
        //
        // path was specified..
        //

        if (!StringIMatch(LineStruct -> Path,LineStruct -> PathOnNt)) {
            //
            // Different path on NT..
            //
            StringSearchAndReplace(lineToSave,LineStruct -> Path,LineStruct -> PathOnNt);
        }
    }



    //
    // Build the key for this line (can't use the EX Memdb calls since we are setting userflags..)
    //
    MemDbBuildKey(key,MEMDB_CATEGORY_DM_LINES,enumString,NULL,lineToSave);
    rSuccess = MemDbSetValueAndFlags(key,g_CurrentFileOffset,(WORD) Type,0);

    //
    // Now, if the passed in parameter was either unknown or bad, we need to add a message to the
    // message manager.
    //

    if (Type == DOSMIG_BAD || Type == DOSMIG_UNKNOWN) {

        pAddMessage(Type,g_CurrentLineNumber,g_CurrentFile,g_CurrentLine,LineStruct -> FullPath);

    }

    return rSuccess;
}


BOOL
pHandleMSCDEX (
    IN PLINESTRUCT  LineStruct,
    DWORD Parameter
    )
{
    BOOL    rSuccess = TRUE;
    PCTSTR  driveSwitch = NULL;
    TCHAR   driveLetter;
    TCHAR   driveString[20];


    //
    // This function is a minor kludge. MSCDEX can assign a drive letter to real mode
    // cd roms.. Since it is handled in dos files instead of the registry, the code
    // that is supposed to collect this information (drvlettr.c) does not have a chance.
    // We will catch this case and save it into the winnt.sif file just as drvlettr.c
    // would have.
    //
    driveSwitch = _tcsistr(LineStruct -> Arguments,TEXT("/l:"));
    if (driveSwitch) {
        //
        // This mscdex line is one of the one's we care about.
        //
        driveLetter = *(driveSwitch + 3);

        if (driveLetter) {

            DEBUGMSG((DBG_DOSMIG,"Drive letter information is contained in the line %s. Preserving it. (%c)", LineStruct -> FullLine,driveLetter));

            wsprintf(driveString,TEXT("%u"),toupper(driveLetter) - TEXT('A'));
            rSuccess &= WriteInfKey(WINNT_D_WIN9XDRIVES,driveString,TEXT("5,"));

            DEBUGMSG_IF((!rSuccess,DBG_ERROR,"Unable to save drive letter information for line %s.",LineStruct -> FullLine));
        }

    }


    //
    // Go ahead and save this into memdb.
    //
    rSuccess &= pSaveItem(LineStruct,DOSMIG_IGNORE);

    return rSuccess;
}


/*++

Routine Description:

  pHandleAtSign takes care of lines that begin with the '@' symbol. The
  symbol is trimmed of f of the line and this modified line is parsed again.

Arguments:

  Line      - Contains the valid line that is currently being parsed.
  Parameter - This parameter is unused.

Return Value:

  TRUE if the function completed successfully, FALSE otherwise.

--*/


BOOL
pHandleAtSign (
    IN PLINESTRUCT  LineStruct,
    DWORD Parameter
    )
{
    BOOL rSuccess = TRUE;
    TCHAR buffer[MEMDB_MAX];

    MYASSERT(_tcschr(LineStruct -> FullLine,TEXT('@')));

    StringCopy(buffer,_tcsinc(_tcschr(LineStruct -> FullLine,TEXT('@'))));

    rSuccess = ParseLine(buffer,&g_BatchFileRules);

    return rSuccess;
}


/*++

Routine Description:

  pHandleLoadHigh - Is responsible for handling the "loadhigh" and "lh" dos
  statements. It simply skips past these statements and calls parseline on
  the remainder of the line.

Arguments:

  Line      - Contains the valid line that is currently being parsed.
  Parameter - This parameter is unused.

Return Value:

  TRUE if the function completed successfully, FALSE otherwise.

--*/


BOOL
pHandleLoadHigh (
    IN PLINESTRUCT  LineStruct,
    DWORD Parameter
    )
{
    BOOL    rSuccess = TRUE;
    TCHAR   buffer[MEMDB_MAX];
    PCTSTR p;

    p = _tcschr(LineStruct -> Arguments, TEXT(' '));
    if (!p) {
        return FALSE;
    }

    buffer[0] = 0;
    StringCopy(buffer,SkipSpace(p));
    rSuccess = ParseLine(buffer,&g_BatchFileRules);

    return rSuccess;
}




/*++

Routine Description:

  pHandleCall takes care of call statements in batch files. It saves these
  lines to memdb and adds the file mentioned in the call statement to the
  list of files to be parsed.

Arguments:

  Line      - Contains the valid line that is currently being parsed.
  Parameter - This parameter is unused.

Return Value:

  TRUE if the function completed successfully, FALSE otherwise.

--*/


BOOL
pHandleCall (
    IN PLINESTRUCT  LineStruct,
    DWORD Parameter
    )
{
    BOOL rSuccess = TRUE;
    LINESTRUCT ls;

    rSuccess = pSaveItem(LineStruct,DOSMIG_USE);

    InitLineStruct (&ls, (PTSTR) SkipSpace (LineStruct -> Arguments));

    if (!GrowListAppendString(&g_FileList,ls.FullPath)) {
        rSuccess = FALSE;
    }

    return rSuccess;
}


/*++

Routine Description:

  pHandleConfigSysDevice is responsible for device and devicehigh statements
  in config.sys. The function extracts the driver from the line and tries to
  determine if the compatibility of that driver. The line is eventually
  written to memdb.

Arguments:

  Line      - Contains the valid line that is currently being parsed.
  Parameter - This parameter is unused.

Return Value:

  TRUE if the function completed successfully, FALSE otherwise.

--*/


BOOL
pHandleConfigSysDevice (
    IN PLINESTRUCT  LineStruct,
    DWORD Parameter
    )
{
    BOOL rSuccess = TRUE;
    TCHAR buffer[MEMDB_MAX];
    PCTSTR p;

    //
    // looks like there ARE config.sys files with INSTALLHIGH "driver",
    // without "equal" sign (like INSTALLHIGH driver, and not INSTALLHIGH=driver)

    p = SkipSpace(LineStruct -> Arguments);
    if (_tcsnextc (p) == TEXT('=')) {
        p = SkipSpace (p + 1);
    }

    StringCopy(buffer, p);
    return ParseLine(buffer, &g_BatchFileRules);
}

DWORD
pGetLineTypeFromNtStatusAndPath (
    IN DWORD Status,
    IN PCTSTR Path
    )
{
    DWORD unused;
    DWORD rType = DOSMIG_UNKNOWN;


    if (Status & (FILESTATUS_MOVED | FILESTATUS_REPLACED)) {

        rType = DOSMIG_USE;

    } else if (Status & FILESTATUS_DELETED) {

        rType = DOSMIG_IGNORE;

    } else {

        if (IsFileMarkedAsHandled (Path)) {

            rType = DOSMIG_IGNORE;

        }else if (IsReportObjectHandled(Path)) {

            rType = DOSMIG_USE;

        } else if (MemDbGetOffsetEx(MEMDB_CATEGORY_COMPATIBLE_DOS,Path,NULL,NULL,&unused)) {

            rType = DOSMIG_USE;

        } else if (MemDbGetOffsetEx(MEMDB_CATEGORY_DEFERREDANNOUNCE,Path,NULL,NULL,&unused)) {

            rType = DOSMIG_IGNORE;
        }
    }

    return rType;
}

BOOL
pHandleShell (
    IN PLINESTRUCT LineStruct,
    DWORD Parameter
    )
{
    PTSTR p=LineStruct->Arguments;
    LINESTRUCT ls;
    TCHAR buffer[MEMDB_MAX];
    UINT lineType;


    if (p) {
        p = _tcsinc (p);

    }
    else {
        return pSaveItem (LineStruct, DOSMIG_IGNORE);
    }

    InitLineStruct (&ls, p);

    lineType = pGetLineTypeFromNtStatusAndPath (ls.StatusOnNt, ls.FullPath);

    if (lineType == DOSMIG_USE) {

        //
        // Fix up the line and save it back.
        //
        wsprintf(buffer, TEXT("SHELL=%s %s"), ls.PathOnNt, ls.Arguments ? ls.Arguments : S_EMPTY);
        g_CurrentLine = PoolMemDuplicateString (g_DosMigPool, buffer);

    }

    return pSaveItem (LineStruct, lineType);
}

/*++

Routine Description:

  pHandleUnknownBatLine _tries_ to deal with any line that is not caught by
  another explicit rule...The first thing it will do is see if the line
  starts with a path containing *.bat. If so, it will add that bat file to
  the list to be parsed. If the file does not end with *.bat, then, the
  function will assume that this is a tsr and attempt to determine its
  compatibility.

Arguments:

  Line      - Contains the valid line that is currently being parsed.
  Parameter - This parameter is unused.

Return Value:

  TRUE if the function completed successfully, FALSE otherwise.

--*/


BOOL
pHandleUnknownBatLine (
    IN PLINESTRUCT  LineStruct,
    DWORD Parameter
    )
{

    BOOL        rSuccess = TRUE;
    DWORD       lineType = DOSMIG_UNKNOWN;

    DEBUGMSG((DBG_DOSMIG,"Processing unknown bat line...%s.",LineStruct -> FullLine));

    //
    // First, see if this is a *.bat file..
    //
    if (IsPatternMatch(TEXT("*.bat"),LineStruct -> Command)) {
        //
        // This is another batch file..add it to those to be parsed..
        //
        DEBUGMSG((DBG_DOSMIG,"...The line is a batch file. Add it to those to be parsed.."));
        if (!GrowListAppendString(&g_FileList,LineStruct -> FullLine)) {
            rSuccess = FALSE;
        }

        lineType = DOSMIG_USE;
    }

    //
    // See if they are changing the drive.
    //
    if (IsPatternMatch(TEXT("?:"),LineStruct->Command)) {

        lineType = DOSMIG_USE;
    }


    if (lineType == DOSMIG_UNKNOWN) {

        //
        // Still don't know what the line is. Lets check its status on NT. if it is moved ore replaced,
        // we'll just change the path if necessary, and use it. Otherwise,
        //

        lineType = pGetLineTypeFromNtStatusAndPath (LineStruct->StatusOnNt, LineStruct->FullPath);
    }

    //
    // In anycase, save away the line in memdb.
    //
    rSuccess &= pSaveItem(LineStruct,lineType);



    return rSuccess;

}

/*++

Routine Description:

  pHandleHighFilter - Is responsible for handling the "*high" statements
  besides LoadHigh and lh.

Arguments:

  Line      - Contains the valid line that is currently being parsed.
  Parameter - This parameter is unused.

Return Value:

  TRUE if the function completed successfully, FALSE otherwise.

--*/
BOOL
pHandleHighFilter (
    IN PLINESTRUCT LineStruct,
    DWORD Parameter
    )
{
    PTSTR p;
    BOOL rSuccess = TRUE;


    if (!StringIMatch (LineStruct->Command, LineStruct->FullPath)) {

        return pHandleUnknownBatLine (LineStruct, Parameter);
    }

    _tcslwr (LineStruct->FullLine);
    p = _tcsstr (LineStruct->FullLine,TEXT("high"));
    if (!p || p == LineStruct->FullLine) {
        return pHandleUnknownBatLine (LineStruct, Parameter);
    }

    *p = 0;
    p = JoinTextEx (NULL, LineStruct->FullLine, p + 4, TEXT(""), 0, NULL);
    rSuccess = ParseLine (p, g_CurrentRules);
    FreeText (p);


    return rSuccess;

}




/*++

Routine Description:

  pAddRuleToList creates a PARSERULE out of the parameters passed in and adds
  it to the List provided by the caller.

Arguments:

  Name      - The name of the parse rule.
  Pattern   - The pattern for this parse rule
  Function  - The function to call when this rule is hit.
  Parameter - The extra parameter data to pass to the function when this rule
              is hit.
  List      - This list of rules to add the new parse rule to.

Return Value:

  TRUE if the rule was successfully added, FALSE
  otherwise.



--*/


BOOL
pAddRuleToList (
    PCTSTR          Name,
    PCTSTR          Pattern,
    RULEFUNC *      Function,
    DWORD           Parameter,
    PPARSERULE *    List
    )

{

    BOOL        rSuccess = TRUE;
    PPARSERULE  newRule = NULL;
    PPARSERULE  curRule = NULL;

    MYASSERT(List);
    MYASSERT(Function);
    MYASSERT(Name);


    //
    // Allocate memory for the new rule.
    //
    newRule = PoolMemGetMemory(g_DosMigPool,sizeof(PARSERULE));
    if (newRule) {


        //
        // Fill in the new rule.
        //
        newRule -> Name = Name;
        newRule -> Pattern = Pattern;
        newRule -> Handle = Function;
        newRule -> Parameter = Parameter;
        newRule -> Next = NULL;


        //
        // Attach the rule into the provided list.
        //
        if (!*List) {
            *List = newRule;
        }
        else {
            curRule = *List;
            while (curRule -> Next) {
                curRule = curRule -> Next;
            }
            curRule -> Next = newRule;
        }
    }
    ELSE_DEBUGMSG((DBG_ERROR,"Not enough memory to create rule."));

    return rSuccess;
}




/*++

Routine Description:

  pBuildParseRules builds the rule lists for config.sys and autoexec.bat
  files.

Arguments:

  None.

Return Value:

  None.

--*/

VOID
pBuildParseRules (
    VOID
    )
{



#define DEFAULTPARSERULE(Name,Pattern,Function,Parameter)     \
    pAddRuleToList(Name,Pattern,Function,Parameter,&(curRules -> DefaultRule));

#define PARSERULE(Name,Pattern,Function,Parameter)   \
    pAddRuleToList(Name,Pattern,Function,Parameter,&(curRules -> RuleList));


    PPARSERULES curRules = NULL;


    //
    // Create config sys rules.
    //
    curRules = &g_ConfigSysRules;
    curRules -> Name = TEXT("Config.sys Rules");

    CONFIGSYSLIST;

    //
    // Create batch file rules.
    //
    curRules = &g_BatchFileRules;
    curRules -> Name = TEXT("Batch File Rules");

    BATCHFILELIST;



}


/*++

Routine Description:

  ParseDosFiles is the function which handles the parsing of legacy
  configuration files (config.sys and batch files...)

Arguments:

  None.

Return Value:

  True if the files were successfully parsed, FALSE
  otherwise.


--*/


BOOL
ParseDosFiles (
    VOID
    )
{

    BOOL    rSuccess = TRUE;
    PCTSTR  curFile;
    DWORD   curIndex = 0;
    TCHAR   autoexecPath[] = S_AUTOEXECPATH;
    TCHAR   configsysPath[] = S_CONFIGSYSPATH;
    PTSTR   p;

    //
    // Initialize the parser.
    //
    if (InitParser()) {

        //
        // build the lists of parse rules.
        //
        pBuildParseRules();

        //
        // Update drive letter
        //

        autoexecPath[0]  = g_BootDriveLetter;
        configsysPath[0] = g_BootDriveLetter;

        p = _tcschr(autoexecPath, TEXT('a'));
        *p = 0;
        GrowBufAppendString(&g_ExtraPaths,autoexecPath);
        *p = TEXT('a');

        //
        // Add config.sys and autoexec.bat to the list of files to parse.
        //
        GrowListAppendString(&g_FileList,configsysPath);
        GrowListAppendString(&g_FileList,autoexecPath);

        //
        // Now, parse the files in the list. Note that additional files may be added
        // to the list as a result of parsing. (i.e. by finding a call statement.)
        //
        while (curFile = GrowListGetString(&g_FileList,curIndex++)) {

            if (DoesFileExist (curFile)) {

                //
                // Save the file into memdb.
                //
                MemDbSetValueEx(MEMDB_CATEGORY_DM_FILES,NULL,NULL,curFile,0,&g_CurrentFileOffset);

                //
                // parse the file using config.sys parse rules if the file is config.sys and
                // the batch file parse rules otherwise.
                //
                if (StringIMatch(configsysPath,curFile)) {

                    g_CurrentRules = &g_ConfigSysRules;
                    rSuccess &= ParseFile(curFile,&g_ConfigSysRules);

                }
                else {

                    g_CurrentRules = &g_BatchFileRules;
                    rSuccess &= ParseFile(curFile,&g_BatchFileRules);

                }
            }
            ELSE_DEBUGMSG((DBG_DOSMIG,"The path %s does not exist. This file will not be processed.", curFile));
        }


        //
        // There was an incompatibility detected. Write the incompatibility buffer to the log.
        //
        if (g_IncompatibilityDetected) {

            LOG ((LOG_WARNING, (PCSTR)MSG_DOS_LOG_WARNING, g_IncompatibilityBuffer.Buf));
        }

        //
        // Cleanup resources.
        //
        FreeGrowBuffer(&g_IncompatibilityBuffer);
        FreeGrowList(&g_FileList);
        CleanUpParser();
    }

    return rSuccess;
}


#define S_PATH_PATTERN TEXT("Path*")

BOOL
ParseEnvironmentVariables (
    VOID
    )
{

    BOOL rSuccess = TRUE;
    PVOID envVars = NULL;
    PTSTR line    = NULL;
    MULTISZ_ENUM e;
    LINESTRUCT ls;
    PTSTR p;
    HASHTABLE excludeTable = NULL;
    HASHITEM hashResult;

    envVars = GetEnvironmentStrings();


    __try {

        if (!envVars) {
            LOG((
                LOG_WARNING,
                "Unable to retrieve environment variables. "
                "Some environment variables may not be migrated correctly. "
                "rc from GetEnvironmentStrings: %u",
                GetLastError()
                ));

            return FALSE;
        }


        //
        // Set fake name of file for envvars.
        //
        MemDbSetValueEx (MEMDB_CATEGORY_DM_FILES, NULL, NULL, S_ENVVARS, 0, &g_CurrentFileOffset);

        //
        // Enumerate through each of the environment variables and save them away for migration.
        //
        if (EnumFirstMultiSz (&e, envVars)) {

            //
            // Create list of environment variables to skip.
            //
            excludeTable = HtAlloc ();
            MYASSERT (excludeTable);

            HtAddString (excludeTable, TEXT("path"));
            HtAddString (excludeTable, TEXT("comspec"));
            HtAddString (excludeTable, TEXT("cmdline"));

            ZeroMemory(&ls,sizeof(LINESTRUCT));


            do {

                p = _tcschr (e.CurrentString, TEXT('='));

                //
                // Get rid of empty environment strings or the dummy env string starting
                // with '='
                //
                if (!p || p == e.CurrentString) {
                    continue;
                }

                *p = 0;

                hashResult = HtFindString (excludeTable, e.CurrentString);

                *p = TEXT('=');

                if (!hashResult) {
                    //
                    // This is a good environment string. As long as the length is ok, lets migrate it.
                    //
                    line = JoinTextEx (NULL, TEXT("SET"), e.CurrentString, TEXT(" "), 0, NULL);
                    if (line) {

                        if (CharCount (line) < (MEMDB_MAX/sizeof(WCHAR))) {

                            g_CurrentLine = line;
                            StringCopy (ls.FullLine, line);
                            pSaveItem (&ls, DOSMIG_MIGRATE);
                        }


                        FreeText (line);
                    }


                }
                ELSE_DEBUGMSG ((DBG_VERBOSE, "Skipping excluded environment variable %s.", e.CurrentString));


            } while (EnumNextMultiSz (&e));

            //
            // Add %windir% as an environment variable in NT. %windir% is implicit, but is not passed down to the
            // WOW layer on NT.
            //
            line = AllocPathString (MAX_TCHAR_PATH);
            wsprintf (line, TEXT("SET WINDIR=%s"), g_WinDir);

            g_CurrentLine = line;
            StringCopy (ls.FullLine, line);
            pSaveItem (&ls, DOSMIG_MIGRATE);

            FreePathString (line);


        }
    }
    __finally {

        if (envVars) {
            FreeEnvironmentStrings(envVars);
        }
        HtFree (excludeTable);
    }

    return rSuccess;
}

LONG
pProcessDosConfigFiles (
    void
    )

{

    BeginMessageProcessing();

    g_DosMigPool = PoolMemInitNamedPool ("DosMig");

    if (g_DosMigPool) {

        if (!ParseDosFiles()) {
            DEBUGMSG ((DBG_ERROR, "Errors occurred during the processing of DOS configuration files. Some dos settings may not be preserved."));

        }
        if (!ParseEnvironmentVariables()) {
            DEBUGMSG ((DBG_ERROR, "Errors occured during the processing of environment variables. Environment variables may not be preserved."));
        }

        PoolMemDestroyPool(g_DosMigPool);
    }

    EndMessageProcessing();


    return ERROR_SUCCESS;

}

DWORD
ProcessDosConfigFiles (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_DOSMIG_PREPARE_REPORT;
    case REQUEST_RUN:
        return pProcessDosConfigFiles ();
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in DosMig_PrepareReport"));
    }
    return 0;
}

BOOL
DosMig_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD     dwReason,
    IN LPVOID    lpv
    )
/*++

Routine Description:

    This routine initializes the g_CfgFiles structure.

Arguments:

    None.

Return Value:

    Returns true if g_CfgFiles was successfully initialized,
    FALSE otherwise.

--*/
{
    BOOL rFlag = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    break;
    case DLL_PROCESS_DETACH:
        break;
    }

    return rFlag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\betacfg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    betacfg.c

Abstract:

    This file enumerates various parts of the user's system and saves
    entries into the config log.

    The format of each line in config.dmp is:

    <ID>\t<data>\t<data>\t<data>

Author:

    Jim Schmidt (jimschm) 04-Aug-1998

Revision History:

    None.

--*/

#include "pch.h"

//
// Function type declaration
//

typedef VOID (DUMP_FUNCTION_PROTOTYPE)(VOID);

typedef DUMP_FUNCTION_PROTOTYPE * DUMP_FUNCTION;

//
// Array of dump functions
//

#define FUNCTION_LIST                               \
    DEFMAC(pDumpUserName)                           \
    DEFMAC(pDumpHardware)                           \
    DEFMAC(pDumpDosLines)                           \
    DEFMAC(pDumpNetworkInfo)                        \
    DEFMAC(pDumpUninstallList)                      \
    DEFMAC(pDumpCompatReport)                       \


//     DEFMAC(pDumpUserShellFolders)                   \


//
// Declare the function prototypes
//

#define DEFMAC(x) DUMP_FUNCTION_PROTOTYPE x;

FUNCTION_LIST

#undef DEFMAC

//
// Create a lookup array
//

typedef struct {
    DUMP_FUNCTION Proc;
} DUMP_FUNCTION_LIST, *PDUMP_FUNCTION_LIST;

#define DEFMAC(x) {x},

static DUMP_FUNCTION_LIST g_Functions[] = {
    FUNCTION_LIST /*,*/
    {NULL}
};

#undef DEFMAC


VOID
SaveConfigurationForBeta (
    VOID
    )
{
    INT i;

    for (i = 0 ; g_Functions[i].Proc ; i++) {
        g_Functions[i].Proc();
    }
}


VOID
pDumpUserName (
    VOID
    )
{
    TCHAR UserName[MAX_USER_NAME];
    TCHAR ComputerName[MAX_COMPUTER_NAME];
    DWORD Size;

    Size = MAX_USER_NAME;
    if (!GetUserName (UserName, &Size)) {
        UserName[0] = 0;
    }

    Size = MAX_COMPUTER_NAME;
    if (!GetComputerName (ComputerName, &Size)) {
        ComputerName[0] = 0;
    }

    LOG ((LOG_CONFIG, "User\t%s", UserName));
    LOG ((LOG_CONFIG, "Computer Name\t%s", ComputerName));
}


VOID
pDumpHardware (
    VOID
    )
{
    HARDWARE_ENUM e;

    if (EnumFirstHardware (&e, ENUM_ALL_DEVICES, ENUM_WANT_ALL)) {
        do {
            LOG ((
                LOG_CONFIG,
                "Device\t%s\t%s\t%s\t%s\t%s\t%s\t%u\t%u\t%u\t%u",
                e.DeviceDesc,
                e.Mfg,
                e.HardwareID,
                e.CompatibleIDs,
                e.HWRevision,
                e.UserDriveLetter,
                e.Online,
                e.SuppliedByUi,
                e.HardwareIdCompatible,
                e.CompatibleIdCompatible
                ));

        } while (EnumNextHardware (&e));
    }
}


#if 0
VOID
pDumpShellFolder (
    IN      PCTSTR ShellFolder
    )
{
    SHELLFOLDER_ENUM e;
    TREE_ENUM te;

    if (EnumFirstShellFolder (&e, USF_9X, ShellFolder)) {
        do {
            if (EnumFirstFileInTree (&te, e.ShellFolder, NULL, FALSE)) {
                do {
                    if (!te.Directory) {

                        LOG ((
                            LOG_CONFIG,
                            "Shell Folder\t%s",
                            te.FullPath
                            ));

                    }
                } while (EnumNextFileInTree (&te));
            }

        } while (EnumNextShellFolder (&e));
    }
}



VOID
pDumpUserShellFolders (
    VOID
    )
{
    pDumpShellFolder (TEXT("Start Menu"));
    pDumpShellFolder (TEXT("Programs"));
    pDumpShellFolder (TEXT("Startup"));
    pDumpShellFolder (TEXT("Desktop"));
    pDumpShellFolder (TEXT("Recent"));
    pDumpShellFolder (TEXT("AppData"));
    pDumpShellFolder (TEXT("Local AppData"));
    pDumpShellFolder (TEXT("Local Settings"));
    pDumpShellFolder (TEXT("My Pictures"));
    pDumpShellFolder (TEXT("SendTo"));
    pDumpShellFolder (TEXT("Templates"));
}
#endif


VOID
pDumpDosLines (
    VOID
    )
{
    MEMDB_ENUM e;
    TCHAR line[MEMDB_MAX];

    if (MemDbEnumItems(&e, MEMDB_CATEGORY_DM_LINES)) {

        do {

            if (MemDbGetEndpointValueEx (
                MEMDB_CATEGORY_DM_LINES,
                e.szName,
                NULL,
                line
                )) {

                LOG ((
                    LOG_CONFIG,
                    "Dos Lines\t%s",
                    line
                    ));
            }

        } while (MemDbEnumNextValue (&e));
    }
}



VOID
pDumpNetworkInfo (
    VOID
    )
{

    MEMDB_ENUM e;
    TCHAR buffer[MEMDB_MAX];

    //
    // Network protocols.
    //
    if (MemDbEnumFields (&e,  MEMDB_CATEGORY_AF_SECTIONS, S_PAGE_NETPROTOCOLS)) {
        do {

            if (MemDbBuildKeyFromOffset (e.dwValue, buffer, 1, NULL)) {

                LOG ((
                    LOG_CONFIG,
                    "Network Protocols\t%s",
                    buffer
                    ));
            }
        } while (MemDbEnumNextValue (&e));
    }

    //
    // Network clients.
    //
    if (MemDbEnumFields (&e,  MEMDB_CATEGORY_AF_SECTIONS, S_PAGE_NETCLIENTS)) {
        do {

            if (MemDbBuildKeyFromOffset(e.dwValue,buffer,1,NULL)) {

                LOG ((
                    LOG_CONFIG,
                    "Network Clients\t%s",
                    buffer
                    ));
            }

        } while (MemDbEnumNextValue (&e));
    }

    //
    // Network services.
    //
    if (MemDbEnumFields (&e,  MEMDB_CATEGORY_AF_SECTIONS, S_PAGE_NETSERVICES)) {
        do {

            if (MemDbBuildKeyFromOffset(e.dwValue,buffer,1,NULL)) {

                LOG ((
                    LOG_CONFIG,
                    "Network Services\t%s",
                    buffer
                    ));
            }

        } while (MemDbEnumNextValue (&e));
    }

}


VOID
pDumpUninstallList (
    VOID
    )
{
    REGKEY_ENUM e;
    PCTSTR DisplayName, UninstallString;
    HKEY Key;
    HKEY SubKey;

    Key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"));
    if (Key) {
        if (EnumFirstRegKey (&e, Key)) {
            do {
                SubKey = OpenRegKey (Key, e.SubKeyName);
                if (SubKey) {
                    DisplayName = GetRegValueString (SubKey, TEXT("DisplayName"));
                    UninstallString = GetRegValueString (SubKey, TEXT("UninstallString"));

                    if (DisplayName && UninstallString) {
                        LOG ((LOG_CONFIG, "Add/Remove Programs\t%s\t%s", DisplayName, UninstallString));
                    }

                    if (DisplayName) {
                        MemFree (g_hHeap, 0, DisplayName);
                    }
                    if (UninstallString) {
                        MemFree (g_hHeap, 0, UninstallString);
                    }

                    CloseRegKey (SubKey);
                }
            } while (EnumNextRegKey (&e));
        }
        CloseRegKey (Key);
    }
}


VOID
pDumpCompatReport (
    VOID
    )
{
    MEMDB_ENUM e;
    TCHAR key[MEMDB_MAX];
    PTSTR p, q, append;
    TCHAR line[MEMDB_MAX];
    INT i;

#define COMPONENT_ITEMS_MAX 2

    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_COMPATREPORT, MEMDB_ITEM_OBJECTS, NULL)) {

        do {

            if (!MemDbBuildKeyFromOffset (e.dwValue, key, 3, NULL)) {
                continue;
            }

            line[0] = 0;
            append = StringCat (line, TEXT("Compat Report\t"));
            //
            // first append the Object that generated this entry
            //
            append = StringCat (append, e.szName);

            //
            // next append the Components as generated for the user report
            //
            p = key;
            for (i = 0; i < COMPONENT_ITEMS_MAX; i++) {
                q = _tcschr (p, TEXT('\\'));
                if (!q || !q[1]) {
                    break;
                }
                *q = 0;
                append = StringCat (append, TEXT("\t"));
                append = StringCat (append, p);
                p = q + 1;
            }
            append = StringCat (append, TEXT("\t"));
            append = StringCat (append, p);

            LOG ((LOG_CONFIG, line));

        } while (MemDbEnumNextValue (&e));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\mmedia.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mmedia.c

Abstract:

    Multimedia settings migration functions for Win95

Author:

    Calin Negreanu (calinn) 02-Dec-1997

Revision History:

    Ovidiu Temereanca (ovidiut) 29-Jan-1999

--*/

#include "pch.h"
#include "mmediap.h"


POOLHANDLE g_MmediaPool = NULL;

#define MM_POOLGETMEM(STRUCT, COUNT)  \
            (COUNT * sizeof(STRUCT) < 1024) ? \
                (STRUCT*) PoolMemGetMemory (g_MmediaPool, COUNT * sizeof(STRUCT)) : \
                NULL


static PCTSTR g_UserData = NULL;
static HKEY g_UserRoot = NULL;


BOOL
pSaveSystemValue (
    IN      PCTSTR KeyName,
    IN      PCTSTR Field,       OPTIONAL
    IN      PCTSTR StrValue,    OPTIONAL
    IN      DWORD NumValue      OPTIONAL
    )
{
    return MemDbSetValueEx (
                MEMDB_CATEGORY_MMEDIA_SYSTEM,
                KeyName,
                Field,
                StrValue,
                NumValue,
                NULL);
}


BOOL
pSaveSystemBinaryValue (
    IN      PCTSTR KeyName,
    IN      PCTSTR Field,       OPTIONAL
    IN      PCBYTE Data,
    IN      DWORD DataSize
    )
{
    return MemDbSetBinaryValueEx (
                MEMDB_CATEGORY_MMEDIA_SYSTEM,
                KeyName,
                Field,
                Data,
                DataSize,
                NULL);
}


BOOL
pSaveMMSystemMixerSettings (
    VOID
    )
{
    UINT MixerID, MixerMaxID;
    HMIXER mixer;
    MIXERCAPS mixerCaps;
    MIXERLINE mixerLine, mixerLineSource;
    MIXERLINECONTROLS mixerLineControls;
    MIXERCONTROL* pmxControl;
    MIXERCONTROLDETAILS mixerControlDetails;
    MMRESULT rc;
    DWORD Dest, Src, Control;
    TCHAR MixerKey[MAX_PATH], LineKey[MAX_PATH], SrcKey[MAX_PATH], SubKey[MAX_PATH];
    DWORD ValuesCount;

    MixerMaxID = mixerGetNumDevs ();
    pSaveSystemValue (S_MIXERNUMDEVS, NULL, NULL, MixerMaxID);

    for (MixerID = 0; MixerID < MixerMaxID; MixerID++) {

        rc = mixerGetDevCaps (MixerID, &mixerCaps, sizeof (MIXERCAPS));
        if (rc != MMSYSERR_NOERROR) {
            DEBUGMSG ((DBG_MMEDIA, "mixerGetDevCaps failed for mixer %lu [rc=%#X]. No settings will be preserved.", MixerID, rc));
            continue;
        }

        rc = mixerOpen (&mixer, MixerID, 0L, 0L, MIXER_OBJECTF_MIXER);
        if (rc != MMSYSERR_NOERROR) {
            DEBUGMSG ((DBG_MMEDIA, "mixerOpen failed for mixer %lu [rc=%#X]. No settings will be preserved.", MixerID, rc));
            continue;
        }

        wsprintf (MixerKey, S_MIXERID, MixerID);
        pSaveSystemValue (MixerKey, S_NUMLINES, NULL, mixerCaps.cDestinations);

        for (Dest = 0; Dest < mixerCaps.cDestinations; Dest++) {

            ZeroMemory (&mixerLine, sizeof (MIXERLINE));

            mixerLine.cbStruct = sizeof (MIXERLINE);
            mixerLine.dwDestination = Dest;

            rc = mixerGetLineInfo ((HMIXEROBJ)mixer, &mixerLine, MIXER_GETLINEINFOF_DESTINATION);
            if (rc == MMSYSERR_NOERROR) {

                wsprintf (LineKey, S_LINEID, Dest);

                if (mixerLine.cControls > 0) {
                    //
                    // get all control values for the destination
                    //
                    ZeroMemory (&mixerLineControls, sizeof (MIXERLINECONTROLS));

                    mixerLineControls.cbStruct = sizeof (MIXERLINECONTROLS);
                    mixerLineControls.dwLineID = mixerLine.dwLineID;
                    mixerLineControls.cControls = mixerLine.cControls;
                    mixerLineControls.cbmxctrl = sizeof (MIXERCONTROL);
                    mixerLineControls.pamxctrl = MM_POOLGETMEM (MIXERCONTROL, mixerLineControls.cControls);
                    if (mixerLineControls.pamxctrl) {

                        rc = mixerGetLineControls((HMIXEROBJ)mixer, &mixerLineControls, MIXER_GETLINECONTROLSF_ALL);
                        if (rc == MMSYSERR_NOERROR) {

                            pSaveSystemValue (MixerKey, LineKey, S_NUMCONTROLS, mixerLine.cControls);

                            for (
                                Control = 0, pmxControl = mixerLineControls.pamxctrl;
                                Control < mixerLineControls.cControls;
                                Control++, pmxControl++
                                ) {

                                ZeroMemory (&mixerControlDetails, sizeof (MIXERCONTROLDETAILS));

                                mixerControlDetails.cbStruct = sizeof (MIXERCONTROLDETAILS);
                                mixerControlDetails.dwControlID = pmxControl->dwControlID;
                                mixerControlDetails.cMultipleItems = pmxControl->cMultipleItems;
                                mixerControlDetails.cChannels = mixerLine.cChannels;
                                if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) {
                                    mixerControlDetails.cChannels = 1;
                                }
                                ValuesCount = mixerControlDetails.cChannels;
                                if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_MULTIPLE) {
                                    ValuesCount *= mixerControlDetails.cMultipleItems;
                                }
                                mixerControlDetails.cbDetails = sizeof (DWORD);
                                mixerControlDetails.paDetails = MM_POOLGETMEM (DWORD, ValuesCount);
                                if (mixerControlDetails.paDetails) {

                                    rc = mixerGetControlDetails ((HMIXEROBJ)mixer, &mixerControlDetails, MIXER_GETCONTROLDETAILSF_VALUE);
                                    if (rc == MMSYSERR_NOERROR) {
                                        wsprintf (SubKey, TEXT("%s\\%lu"), LineKey, Control);
                                        pSaveSystemBinaryValue (
                                            MixerKey,
                                            SubKey,
                                            mixerControlDetails.paDetails,
                                            mixerControlDetails.cbDetails * ValuesCount
                                            );
                                    } else {
                                        DEBUGMSG ((DBG_MMEDIA, "mixerGetControlDetails failed for mixer %lu, Line=%lu, Ctl=%lu [rc=%#X]", MixerID, Dest, Control, rc));
                                    }
                                }
                            }
                        } else {
                            DEBUGMSG ((DBG_MMEDIA, "mixerGetLineControls failed for mixer %lu, Line=%#X [rc=%#X].", MixerID, mixerLineControls.dwLineID, rc));
                        }
                    }
                }

                //
                // get this information for all source connections
                //
                pSaveSystemValue (MixerKey, LineKey, S_NUMSOURCES, mixerLine.cConnections);

                for (Src = 0; Src < mixerLine.cConnections; Src++) {

                    ZeroMemory (&mixerLineSource, sizeof (MIXERLINE));

                    mixerLineSource.cbStruct = sizeof(MIXERLINE);
                    mixerLineSource.dwDestination = Dest;
                    mixerLineSource.dwSource = Src;

                    rc = mixerGetLineInfo((HMIXEROBJ)mixer, &mixerLineSource, MIXER_GETLINEINFOF_SOURCE);
                    if (rc == MMSYSERR_NOERROR) {

                        wsprintf (SrcKey, S_SRCID, Src);

                        if (mixerLineSource.cControls > 0) {
                            //
                            // get all control values
                            //
                            
                            ZeroMemory (&mixerLineControls, sizeof (MIXERLINECONTROLS));

                            mixerLineControls.cbStruct = sizeof (MIXERLINECONTROLS);
                            mixerLineControls.dwLineID = mixerLineSource.dwLineID;
                            mixerLineControls.cControls = mixerLineSource.cControls;
                            mixerLineControls.cbmxctrl = sizeof (MIXERCONTROL);
                            mixerLineControls.pamxctrl = MM_POOLGETMEM (MIXERCONTROL, mixerLineControls.cControls);
                            
                            if (mixerLineControls.pamxctrl) {

                                rc = mixerGetLineControls((HMIXEROBJ)mixer, &mixerLineControls, MIXER_GETLINECONTROLSF_ALL);
                                if (rc == MMSYSERR_NOERROR) {

                                    wsprintf (SubKey, TEXT("%s\\%s"), SrcKey, S_NUMCONTROLS);
                                    pSaveSystemValue (
                                        MixerKey,
                                        LineKey,
                                        SubKey,
                                        mixerLineSource.cControls
                                        );

                                    for (
                                        Control = 0, pmxControl = mixerLineControls.pamxctrl;
                                        Control < mixerLineControls.cControls;
                                        Control++, pmxControl++
                                        ) {

                                        ZeroMemory (&mixerControlDetails, sizeof (MIXERCONTROLDETAILS));

                                        mixerControlDetails.cbStruct = sizeof (MIXERCONTROLDETAILS);
                                        mixerControlDetails.dwControlID = pmxControl->dwControlID;
                                        mixerControlDetails.cMultipleItems = pmxControl->cMultipleItems;
                                        mixerControlDetails.cChannels = mixerLineSource.cChannels;
                                        if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) {
                                            mixerControlDetails.cChannels = 1;
                                        }
                                        ValuesCount = mixerControlDetails.cChannels;
                                        if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_MULTIPLE) {
                                            ValuesCount *= mixerControlDetails.cMultipleItems;
                                        }
                                        mixerControlDetails.cbDetails = sizeof (DWORD);
                                        mixerControlDetails.paDetails = MM_POOLGETMEM (DWORD, ValuesCount);
                                        if (mixerControlDetails.paDetails) {

                                            rc = mixerGetControlDetails ((HMIXEROBJ)mixer, &mixerControlDetails, MIXER_GETCONTROLDETAILSF_VALUE);
                                            if (rc == MMSYSERR_NOERROR) {
                                                wsprintf (SubKey, TEXT("%s\\%s\\%lu"), LineKey, SrcKey, Control);
                                                pSaveSystemBinaryValue (
                                                    MixerKey,
                                                    SubKey,
                                                    mixerControlDetails.paDetails,
                                                    mixerControlDetails.cbDetails * ValuesCount
                                                    );
                                            } else {
                                                DEBUGMSG ((DBG_MMEDIA, "mixerGetControlDetails failed for mixer %lu, Line=%lu, Src=%lu, Ctl=%lu [rc=%#X]", MixerID, Dest, Src, Control, rc));
                                            }
                                        }
                                    }

                                } else {
                                    DEBUGMSG ((DBG_MMEDIA, "mixerGetLineControls failed for mixer %lu, Src=%lu, Line=%#X [rc=%#X].", MixerID, Src, mixerLineControls.dwLineID, rc));
                                }
                            }
                        }
                    } else {
                        DEBUGMSG ((DBG_MMEDIA, "mixerGetLineInfo failed for mixer %lu, Src=%lu [rc=%#X].", MixerID, Src, rc));
                    }
                }
            } else {
                DEBUGMSG ((DBG_MMEDIA, "mixerGetLineInfo failed for mixer %lu [rc=%#X]. No settings will be preserved.", MixerID, rc));
            }
        }

        mixerClose (mixer);
    }

    return TRUE;
}


BOOL
pGetSoftwareKey (
    OUT     LPTSTR SoftwareKey,
    IN      DWORD MaxKeyLen,
    IN      DWORD DeviceID,
    IN      HKEY WaveDevices
    )
{
    TCHAR Buffer[MAX_PATH];
    DWORD Type, Len;
    HKEY Device;
    BOOL b;
    LONG rc;

    Len = sizeof (Buffer);
    rc = RegEnumKeyEx (WaveDevices, DeviceID++, Buffer, &Len, NULL, NULL, NULL, NULL);
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    rc = TrackedRegOpenKeyEx (WaveDevices, Buffer, 0, KEY_READ, &Device);
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    rc = RegQueryValueEx (
            Device,
            S_SOFTWAREKEY,
            NULL,
            &Type,
            (LPBYTE)SoftwareKey,
            &MaxKeyLen
            );
    b = (rc == ERROR_SUCCESS) && (Type == REG_SZ);

    CloseRegKey (Device);

    return b;
}


VOID
pSaveDeviceDSSettings (
    IN      DWORD DeviceID,
    IN      HKEY Device
    )
{
    TCHAR MemDBKey[MAX_PATH];
    DWORD Type, Len, Value;
    HKEY Key;
    LONG rc;

    wsprintf (MemDBKey, S_WAVEID, DeviceID);

    //
    // DirectSound props
    //
    rc = TrackedRegOpenKeyEx (Device, S_DSMIXERDEFAULTS, 0, KEY_READ, &Key);
    if (rc == ERROR_SUCCESS) {

        Len = sizeof (Value);
        rc = RegQueryValueEx (Key, S_ACCELERATION, NULL, &Type, (LPBYTE)&Value, &Len);
        if (rc == ERROR_SUCCESS && (Type == REG_DWORD)) {

            pSaveSystemValue (MemDBKey, S_DIRECTSOUND, S_ACCELERATION, Value);
        }

        Len = sizeof (Value);
        rc = RegQueryValueEx (Key, S_SRCQUALITY, NULL, &Type, (LPBYTE)&Value, &Len);
        if (rc == ERROR_SUCCESS && (Type == REG_DWORD)) {

            pSaveSystemValue (MemDBKey, S_DIRECTSOUND, S_SRCQUALITY, Value);
        }

        CloseRegKey (Key);
    }

    rc = TrackedRegOpenKeyEx (Device, S_DSSPEAKERCONFIG, 0, KEY_READ, &Key);
    if (rc == ERROR_SUCCESS) {

        Len = sizeof (Value);
        rc = RegQueryValueEx (Key, S_SPEAKERCONFIG, NULL, &Type, (LPBYTE)&Value, &Len);
        if (rc == ERROR_SUCCESS && (Type == REG_DWORD)) {

            pSaveSystemValue (MemDBKey, S_DIRECTSOUND, S_SPEAKERCONFIG, Value);
        }

        CloseRegKey (Key);
    }

    rc = TrackedRegOpenKeyEx (Device, S_DSSPEAKERTYPE, 0, KEY_READ, &Key);
    if (rc == ERROR_SUCCESS) {

        Len = sizeof (Value);
        rc = RegQueryValueEx (Key, S_SPEAKERTYPE, NULL, &Type, (LPBYTE)&Value, &Len);
        if (rc == ERROR_SUCCESS && (Type == REG_DWORD)) {

            pSaveSystemValue (MemDBKey, S_DIRECTSOUND, S_SPEAKERTYPE, Value);
        }

        CloseRegKey (Key);
    }

    //
    // DirectSoundCapture props
    //
    rc = TrackedRegOpenKeyEx (Device, S_DSCMIXERDEFAULTS, 0, KEY_READ, &Key);
    if (rc == ERROR_SUCCESS) {

        Len = sizeof (Value);
        rc = RegQueryValueEx (Key, S_ACCELERATION, NULL, &Type, (LPBYTE)&Value, &Len);
        if (rc == ERROR_SUCCESS && (Type == REG_DWORD)) {

            pSaveSystemValue (MemDBKey, S_DIRECTSOUNDCAPTURE, S_ACCELERATION, Value);
        }

        Len = sizeof (Value);
        rc = RegQueryValueEx (Key, S_SRCQUALITY, NULL, &Type, (LPBYTE)&Value, &Len);
        if (rc == ERROR_SUCCESS && (Type == REG_DWORD)) {

            pSaveSystemValue (MemDBKey, S_DIRECTSOUNDCAPTURE, S_SRCQUALITY, Value);
        }

        CloseRegKey (Key);
    }

}


BOOL
pSaveMMSystemDirectSound (
    VOID
    )
{
    HKEY WaveDevices, Device;
    DWORD NumDevs;
    DWORD DeviceID;
    TCHAR SoftwareKey[MAX_PATH];
    LONG rc;

    rc = TrackedRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                S_SKEY_WAVEDEVICES,
                0,
                KEY_READ,
                &WaveDevices
                );
    if (rc == ERROR_SUCCESS) {

        if (GetRegSubkeysCount (WaveDevices, &NumDevs, NULL)) {

            pSaveSystemValue (S_WAVENUMDEVS, NULL, NULL, NumDevs);

            for (DeviceID = 0; DeviceID < NumDevs; DeviceID++) {

                if (pGetSoftwareKey (SoftwareKey, sizeof (SoftwareKey), DeviceID, WaveDevices)) {
                    //
                    // got the key, go get DirectSound values
                    //
                    rc = TrackedRegOpenKeyEx (
                                HKEY_LOCAL_MACHINE,
                                SoftwareKey,
                                0,
                                KEY_READ,
                                &Device
                                );
                    if (rc == ERROR_SUCCESS) {

                        pSaveDeviceDSSettings (DeviceID, Device);

                        CloseRegKey (Device);
                    }
                }
            }
        }

        CloseRegKey (WaveDevices);
    }

    return TRUE;
}


BOOL
pSaveMMSystemCDSettings (
    VOID
    )
{
    HKEY cdKey;
    HKEY unitKey;
    PBYTE cdRomNumber = NULL;
    PBYTE cdRomVolume = NULL;
    PBYTE cdRomVolInc = NULL;

    TCHAR unitKeyStr [MAX_TCHAR_PATH];

    cdKey = OpenRegKey (HKEY_LOCAL_MACHINE, S_SKEY_CDAUDIO);
    if (cdKey != NULL) {

        cdRomNumber = GetRegValueBinary (cdKey, S_DEFAULTDRIVE);
        if (cdRomNumber != NULL) {

            pSaveSystemValue (S_CDROM, S_DEFAULTDRIVE, NULL, *cdRomNumber);
            wsprintf (unitKeyStr, S_SKEY_CDUNIT, *cdRomNumber);
            unitKey = OpenRegKey (HKEY_LOCAL_MACHINE, unitKeyStr);

            if (unitKey != NULL) {

                cdRomVolume = GetRegValueBinary (unitKey, S_VOLUMESETTINGS);

                if (cdRomVolume != NULL) {
                    pSaveSystemValue (S_CDROM, S_VOLUMESETTINGS, NULL, *(cdRomVolume + 4));
                    MemFreeWrapper (cdRomVolume);
                }

                CloseRegKey (unitKey);
            }

            MemFreeWrapper (cdRomNumber);
        }

        CloseRegKey (cdKey);
    }
    return TRUE;
}


BOOL
pSaveMMSystemMCISoundSettings (
    VOID
    )
{
    TCHAR Buffer[MAX_PATH];
    PTSTR p;
    PCTSTR  infName;
    DWORD Chars;

    infName = JoinPaths (g_WinDir, S_SYSTEM_INI);

    Chars = GetPrivateProfileString (
                S_MCI,
                S_WAVEAUDIO,
                TEXT(""),
                Buffer,
                MAX_PATH,
                infName
                );
    if (Chars > 0) {

        //
        // skip driver name
        //
        p = Buffer;
        while (*p && (*p != TEXT(' ') && *p != TEXT('\t'))) {
            p++;
        }
        //
        // skip white spaces
        //
        while (*p && (*p == TEXT(' ') || *p == TEXT('\t'))) {
            p++;
        }
        if (*p) {
            //
            // save this param; legal values for NT driver are 2-9
            //
            if (*(p + 1) == 0 && *p >= TEXT('2') && *p <= TEXT('9')) {
                pSaveSystemValue (S_MCI, S_WAVEAUDIO, NULL, *p - TEXT('0'));
            }
        }
    }

    FreePathString (infName);

    return TRUE;
}


BOOL
pSaveUserValue (
    IN      PCTSTR KeyName,
    IN      PCTSTR Field,       OPTIONAL
    IN      PCTSTR StrValue,    OPTIONAL
    IN      DWORD NumValue      OPTIONAL
    )
{
    return MemDbSetValueEx (
                g_UserData,
                KeyName,
                Field,
                StrValue,
                NumValue,
                NULL
                );
}


BOOL
pSaveMMUserPreferredOnly (
    VOID
    )
{
    HKEY soundMapperKey;
    PDWORD preferredOnly;

    soundMapperKey = OpenRegKey (g_UserRoot, S_SKEY_SOUNDMAPPER);
    if (soundMapperKey != NULL) {

        preferredOnly = GetRegValueDword (soundMapperKey, S_PREFERREDONLY);
        if (preferredOnly != NULL) {

            pSaveUserValue (S_AUDIO, S_PREFERREDONLY, NULL, *preferredOnly);
            MemFreeWrapper (preferredOnly);
        }
        CloseRegKey (soundMapperKey);
    }

    return TRUE;
}


BOOL
pSaveMMUserShowVolume (
    VOID
    )
{
    HKEY sysTrayKey;
    PDWORD showVolume;
    BOOL ShowVolume;

    sysTrayKey = OpenRegKey (g_UserRoot, S_SKEY_SYSTRAY);
    if (sysTrayKey != NULL) {

        showVolume = GetRegValueDword (sysTrayKey, S_SERVICES);
        if (showVolume != NULL) {

            ShowVolume = (*showVolume & SERVICE_SHOWVOLUME) != 0;
            pSaveUserValue (S_AUDIO, S_SHOWVOLUME, NULL, ShowVolume);
            MemFreeWrapper (showVolume);
        }
        CloseRegKey (sysTrayKey);
    }
    return TRUE;
}


BOOL
pSaveMMUserVideoSettings (
    VOID
    )
{
    HKEY videoSetKey;
    PDWORD videoSettings;

    videoSetKey = OpenRegKey (g_UserRoot, S_SKEY_VIDEOUSER);
    if (videoSetKey != NULL) {

        videoSettings = GetRegValueDword (videoSetKey, S_DEFAULTOPTIONS);
        if (videoSettings != NULL) {

            pSaveUserValue (S_VIDEO, S_VIDEOSETTINGS, NULL, *videoSettings);
            MemFreeWrapper (videoSettings);
        }

        CloseRegKey (videoSetKey);
    }
    return TRUE;
}


BOOL
pSaveMMUserPreferredPlayback (
    VOID
    )
{
    HKEY soundMapperKey;
    PTSTR playbackStr;
    UINT waveOutNumDevs, waveCrt;
    WAVEOUTCAPS waveOutCaps;
    MMRESULT waveOutResult;

    soundMapperKey = OpenRegKey (g_UserRoot, S_SKEY_SOUNDMAPPER);
    if (soundMapperKey != NULL) {

        if (ISMEMPHIS()) {
            playbackStr = GetRegValueString (soundMapperKey, S_USERPLAYBACK);
        } else {
            playbackStr = GetRegValueString (soundMapperKey, S_PLAYBACK);
        }
        if (playbackStr != NULL) {

            if (playbackStr [0] != 0) {

                waveOutNumDevs = waveOutGetNumDevs();
                if (waveOutNumDevs > 1) {
                    //
                    // try to match string with one returned by waveOutGetDevCaps
                    //
                    pSaveSystemValue (S_WAVEOUTNUMDEVS, NULL, NULL, waveOutNumDevs);
                    for (waveCrt = 0; waveCrt < waveOutNumDevs; waveCrt++) {
                        waveOutResult = waveOutGetDevCaps (waveCrt, &waveOutCaps, sizeof (waveOutCaps));
                        if (waveOutResult == MMSYSERR_NOERROR &&
                            StringIMatch (playbackStr, waveOutCaps.szPname)
                            ) {
                            pSaveUserValue (S_AUDIO, S_PREFERREDPLAY, NULL, waveCrt);
                            break;
                        }
                    }
                }
            }
            MemFreeWrapper (playbackStr);
        }
        CloseRegKey (soundMapperKey);
    }
    return TRUE;
}


BOOL
pSaveMMUserPreferredRecord (
    VOID
    )
{
    HKEY soundMapperKey;
    PTSTR recordStr;
    UINT waveInNumDevs, waveCrt;
    WAVEINCAPS waveInCaps;
    MMRESULT waveInResult;

    soundMapperKey = OpenRegKey (g_UserRoot, S_SKEY_SOUNDMAPPER);
    if (soundMapperKey != NULL) {

        if (ISMEMPHIS()) {
            recordStr = GetRegValueString (soundMapperKey, S_USERRECORD);
        } else {
            recordStr = GetRegValueString (soundMapperKey, S_RECORD);
        }
        if (recordStr != NULL) {

            if (recordStr [0] != 0) {

                waveInNumDevs = waveInGetNumDevs();
                if (waveInNumDevs > 1) {
                    //
                    // try to match string with one returned by waveInGetDevCaps
                    //
                    pSaveSystemValue (S_WAVEINNUMDEVS, NULL, NULL, waveInNumDevs);
                    for (waveCrt = 0; waveCrt < waveInNumDevs; waveCrt++) {
                        waveInResult = waveInGetDevCaps (waveCrt, &waveInCaps, sizeof (waveInCaps));
                        if (waveInResult == MMSYSERR_NOERROR &&
                            StringIMatch (recordStr, waveInCaps.szPname)
                            ) {
                            pSaveUserValue (S_AUDIO, S_PREFERREDREC, NULL, waveCrt);
                            break;
                        }
                    }
                }
            }
            MemFreeWrapper (recordStr);
        }
        CloseRegKey (soundMapperKey);
    }
    return TRUE;
}


BOOL
pSaveMMUserSndVol32 (
    VOID
    )
{
    HKEY VolControl, Options, MixerKey;
    PDWORD Style, Value;
    BOOL ShowAdvanced;
    UINT MixerID, MixerMaxID;
    MIXERCAPS mixerCaps;
    TCHAR MixerNum[MAX_PATH];
    TCHAR Buffer[MAX_PATH];
    DWORD Len, NumEntries, Index;
    LONG rc;

    Options = OpenRegKey (g_UserRoot, S_SKEY_VOLCTL_OPTIONS);
    if (Options != NULL) {

        Style = GetRegValueDword (Options, S_STYLE);
        if (Style != NULL) {

            ShowAdvanced = (*Style & STYLE_SHOWADVANCED) != 0;
            pSaveUserValue (S_SNDVOL32, S_SHOWADVANCED, NULL, ShowAdvanced);
            MemFreeWrapper (Style);
        }

        CloseRegKey (Options);
    }

    //
    // save window position for each mixer device
    //
    VolControl = OpenRegKey (g_UserRoot, S_SKEY_VOLUMECONTROL);
    if (VolControl != NULL) {

        if (GetRegSubkeysCount (VolControl, &NumEntries, NULL)) {

            MixerMaxID = mixerGetNumDevs ();

            for (MixerID = 0; MixerID < MixerMaxID; MixerID++) {

                rc = mixerGetDevCaps (MixerID, &mixerCaps, sizeof (MIXERCAPS));
                if (rc == MMSYSERR_NOERROR) {
                    //
                    // find corresponding subkey
                    //
                    wsprintf (MixerNum, S_MIXERID, MixerID);

                    for (Index = 0; Index < NumEntries; Index++) {

                        Len = sizeof (Buffer);
                        rc = RegEnumKeyEx (VolControl, Index, Buffer, &Len, NULL, NULL, NULL, NULL);
                        if (rc != ERROR_SUCCESS) {
                            continue;
                        }
                        if (StringMatch (Buffer, mixerCaps.szPname)) {
                            //
                            // this is the one
                            //
                            MixerKey = OpenRegKey (VolControl, Buffer);
                            if (MixerKey) {

                                Value = GetRegValueDword (MixerKey, S_X);
                                if (Value) {
                                    pSaveUserValue (S_SNDVOL32, MixerNum, S_X, *Value);
                                    MemFreeWrapper (Value);
                                }

                                Value = GetRegValueDword (MixerKey, S_Y);
                                if (Value) {
                                    pSaveUserValue (S_SNDVOL32, MixerNum, S_Y, *Value);
                                    MemFreeWrapper (Value);
                                }

                                CloseRegKey (MixerKey);
                            }

                            break;
                        }
                    }
                }
            }
        }

        CloseRegKey (VolControl);
    }

    return TRUE;
}


#define DEFMAC(Item)         pSave##Item,

static MM_SETTING_ACTION g_MMSaveSystemSettings [] = {
    MM_SYSTEM_SETTINGS
};

static MM_SETTING_ACTION g_MMSaveUserSettings [] = {
    MM_USER_SETTINGS
};

#undef DEFMAC


BOOL
pSaveMMSettings_System (
    VOID
    )
{
    int i;

    g_MmediaPool = PoolMemInitNamedPool ("MMedia9x");
    if (!g_MmediaPool) {
        return FALSE;
    }

    for (i = 0; i < sizeof (g_MMSaveSystemSettings) / sizeof (MM_SETTING_ACTION); i++) {
        (*g_MMSaveSystemSettings[i]) ();
    }

    PoolMemDestroyPool (g_MmediaPool);
    g_MmediaPool = NULL;

    return TRUE;
}


BOOL
pSaveMMSettings_User (
    PCTSTR UserName,
    HKEY UserRoot
    )
{
    int i;

    if (!UserName || UserName[0] == 0) {
        return TRUE;
    }

    MYASSERT (g_UserData == NULL);
    g_UserData = JoinPaths (MEMDB_CATEGORY_MMEDIA_USERS, UserName);
    g_UserRoot = UserRoot;

    __try {
        for (i = 0; i < sizeof (g_MMSaveUserSettings) / sizeof (MM_SETTING_ACTION); i++) {
            (*g_MMSaveUserSettings[i]) ();
        }
    }
    __finally {
        FreePathString (g_UserData);
        g_UserData = NULL;
        g_UserRoot = NULL;
    }

    return TRUE;
}


DWORD
SaveMMSettings_System (
    IN      DWORD Request
    )
{
    switch (Request) {

    case REQUEST_QUERYTICKS:

        return TICKS_SAVE_MM_SETTINGS_SYSTEM;

    case REQUEST_RUN:

        if (!pSaveMMSettings_System ()) {
            return GetLastError ();
        }

        break;

    default:

        DEBUGMSG ((DBG_ERROR, "Bad parameter in SaveMMSettings_System"));

    }

    return ERROR_SUCCESS;
}


DWORD
SaveMMSettings_User (
    IN      DWORD Request,
    IN      PUSERENUM EnumPtr
    )
{
    switch (Request) {

    case REQUEST_QUERYTICKS:

        return TICKS_SAVE_MM_SETTINGS_USER;

    case REQUEST_BEGINUSERPROCESSING:

        //
        // No initialization needed.
        //

        break;

    case REQUEST_RUN:

        if (!pSaveMMSettings_User (EnumPtr -> UserName, EnumPtr -> UserRegKey )) {

            return GetLastError ();

        }

        break;

    case REQUEST_ENDUSERPROCESSING:
        //
        // No cleanup needed.
        //
        break;

    default:

        DEBUGMSG ((DBG_ERROR, "Bad parameter in SaveMMSettings_User"));
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\migmain.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migmain.c

Abstract:

    Main migration file for Win95 side. Calls all migration functions

Author:

    Calin Negreanu (calinn) 09-Feb-1998

Revision History:

    jimschm     19-Mar-2001 Removed DVD code
    mvander     26-Map-1999 Added GatherDead()
    ovidiut     18-May-1999 Enhanced DeleteStaticFiles; added eval fn. support
    jimschm     12-May-1999 DVD Video check
    marcw       10-Feb-1999 Scan the File system before calling user routines.
    jimschm     18-Jan-1999 Added forced-good GUID
    jimschm     04-Dec-1998 Added generalized file delete
    jimschm     29-Sep-1998 TWAIN and Joystick messages
    jimschm     23-Sep-1998 Very early TWAIN check code
    jimschm     24-Aug-1998 Support for NT environment vars
    marcw       06-Jul-1998 Cleaned up user function processing.
    jimschm     06-Jul-1998 Added support for PNP ID attribute
    jimschm     30-Apr-1998 global init/termination, icon context
    jimschm     25-Feb-1998 Added ProcessUninstallSections

--*/

#include "pch.h"
#include "sysmigp.h"


ICON_EXTRACT_CONTEXT g_IconContext;


/*++

Macro Expansion Lists Description:

  The following three lists represent all the function called during the scan page.
  MIGMAIN_SYSFIRST_FUNCTIONS are called first, then for each user MIGMAIN_USER_FUNCTIONS
  are called and, finally, MIGMAIN_SYSFIRST_FUNCTIONS are called.

Line Syntax:

   DEFMAC(Function, MessageId, Critical)

Arguments:

   Function   - These functions must return DWORD and are called with a request as a parameter,
                request that can be either REQUEST_QUERYTICKS (the function should return the
                number of ticks it needs) or REQUEST_RUN (the function can actually do it's job).
                For user functions there are also three more parameters (UserName, UserAccount,
                and a handle to HKCU)

   MessageId -  This is the message that will be displayed during the run phase for each function.
                If a function needs to update the progress bar by itself you should let this
                HAS_DYNAMIC_UI_PROCESSING.

   Critical  -  TRUE if the upgrade should be cancelled if an exception is encountered during that function.

Variables Generated From List:

   g_FirstSystemRoutines
   g_UserRoutines
   g_LastSystemRoutines

For accessing the arrays there are the following functions:

   PrepareProcessingProgressBar
   RunSysFirstMigrationRoutines
   RunUserMigrationRoutines
   RunSysLastMigrationRoutines

--*/

#define HAS_DYNAMIC_UI_PROCESSING       0


#define MIGMAIN_SYSFIRST_FUNCTIONS        \
        DEFMAC(PreparePnpIdList,                MSG_INITIALIZING,               TRUE)   \
        DEFMAC(PrepareIconList,                 MSG_INITIALIZING,               TRUE)   \
        DEFMAC(AddDefaultCleanUpDirs,           MSG_INITIALIZING,               FALSE)  \
        DEFMAC(DeleteWinDirWackInf,             MSG_INITIALIZING,               TRUE)   \
        DEFMAC(HardwareProfileWarning,          MSG_INITIALIZING,               FALSE)  \
        DEFMAC(UnsupportedProtocolsWarning,     MSG_INITIALIZING,               FALSE)  \
        DEFMAC(SaveMMSettings_System,           MSG_INITIALIZING,               FALSE)  \
        DEFMAC(BadNamesWarning,                 MSG_INITIALIZING,               TRUE)   \
        DEFMAC(InitWin95Registry,               MSG_INITIALIZING,               TRUE)   \
        DEFMAC(InitIniProcessing,               MSG_INITIALIZING,               TRUE)   \
        DEFMAC(ReadNtFiles,                     HAS_DYNAMIC_UI_PROCESSING,      TRUE)   \
        DEFMAC(MigrateShellFolders,             MSG_INITIALIZING,               TRUE)   \
        DEFMAC(DeleteStaticFiles,               MSG_INITIALIZING,               FALSE)  \
        DEFMAC(ProcessDllsOnCd,                 HAS_DYNAMIC_UI_PROCESSING,      TRUE)   \
        DEFMAC(InitMigDb,                       MSG_MIGAPP,                     TRUE)   \
        DEFMAC(InitHlpProcessing,               MSG_MIGAPP,                     TRUE)   \
        DEFMAC(ScanFileSystem,                  HAS_DYNAMIC_UI_PROCESSING,      TRUE)   \




#define MIGMAIN_USER_FUNCTIONS            \
        DEFMAC(SaveMMSettings_User,             MSG_INITIALIZING,               FALSE)  \
        DEFMAC(ProcessRasSettings,              MSG_INITIALIZING,               TRUE)   \
        DEFMAC(ProcessRunKey_User,              MSG_INITIALIZING,               TRUE)   \




#define MIGMAIN_SYSLAST_FUNCTIONS         \
        DEFMAC(ConditionalIncompatibilities,    MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(ProcessMigrationSections,        MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(ProcessAllLocalDlls,             HAS_DYNAMIC_UI_PROCESSING,      TRUE)   \
        DEFMAC(MoveSystemRegistry,              MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(ProcessCompatibleSection,        MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(CheckNtDirs,                     MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(MoveSystemDir,                   MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(MoveStaticFiles,                 MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(CopyStaticFiles,                 MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(ElevateReportObjects,            MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(PrepareProcessModules,           MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(ProcessModules,                  MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(ProcessRunKey,                   MSG_PROCESSING_SHELL_LINKS,     TRUE)   \
        DEFMAC(ProcessLinks,                    MSG_PROCESSING_SHELL_LINKS,     TRUE)   \
        DEFMAC(ProcessCPLs,                     MSG_PROCESSING_SHELL_LINKS,     TRUE)   \
        DEFMAC(ProcessShellSettings,            MSG_PROCESSING_SHELL_LINKS,     TRUE)   \
        DEFMAC(TwainCheck,                      MSG_PROCESSING_SHELL_LINKS,     FALSE)  \
        DEFMAC(ReportIncompatibleJoysticks,     MSG_PROCESSING_SHELL_LINKS,     FALSE)  \
        DEFMAC(ProcessDosConfigFiles,           MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(SuppressOleGuids,                HAS_DYNAMIC_UI_PROCESSING,      TRUE)   \
        DEFMAC(SaveShares,                      MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(PreserveShellIcons,              MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(MoveWindowsIniFiles,             MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(SaveDosFiles,                    MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(BuildWinntSifFile,               MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(ProcessMiscMessages,             MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(AnswerFileDetection,             MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(ProcessRecycleBins,              MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(EndMigrationDllProcessing,       MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(GatherImeInfo,                   MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(ReportMapiIfNotHandled,          MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(ReportDarwinIfNotHandled,        MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \
        DEFMAC(CreateFileLists,                 MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(ComputeBackupLayout,             MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(DetermineSpaceUsage,             MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(DoneMigDb,                       MSG_PROCESSING_SYSTEM_FILES,    TRUE)   \
        DEFMAC(GatherDead,                      MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \

#if 0
        //
        // the appcompat team doesn't support "APPMIG.INF" any longer
        // and they requested us to no longer depend on it
        //
        DEFMAC(InitAppCompat,                   MSG_MIGAPP,                     FALSE)  \

        DEFMAC(DoneAppCompat,                   MSG_PROCESSING_SYSTEM_FILES,    FALSE)  \

#endif

//
// Declare tables of processing structures
//

// Processing functions types
typedef DWORD (MIGMAIN_SYS_PROTOTYPE) (DWORD Request);
typedef MIGMAIN_SYS_PROTOTYPE * MIGMAIN_SYS_FN;

typedef DWORD (MIGMAIN_USER_PROTOTYPE) (DWORD Request, PUSERENUM EnumPtr);
typedef MIGMAIN_USER_PROTOTYPE * MIGMAIN_USER_FN;

// Structure holding state for processing functions
typedef struct {
    // One of the two will be NULL, the other will be a valid fn ptr:
    MIGMAIN_SYS_FN SysFnPtr;
    MIGMAIN_USER_FN UserFnPtr;

    DWORD MsgId;
    UINT Ticks;
    PCTSTR FnName;
    GROWBUFFER SliceIdArray;
    BOOL Critical;
} PROCESSING_ROUTINE, *PPROCESSING_ROUTINE;

#define PROCESSING_ROUTINE_TERMINATOR   {NULL, NULL, 0, 0, NULL, GROWBUF_INIT}


// Declaration of prototypes
#define DEFMAC(fn, MsgId, Critical) MIGMAIN_SYS_PROTOTYPE fn;
MIGMAIN_SYSFIRST_FUNCTIONS
MIGMAIN_SYSLAST_FUNCTIONS
#undef DEFMAC

#define DEFMAC(fn, MsgId, Critical) MIGMAIN_USER_PROTOTYPE fn;
MIGMAIN_USER_FUNCTIONS
#undef DEFMAC

// Declaration of tables
#define DEFMAC(fn, MsgId, Critical) {fn, NULL, MsgId, 0, #fn, GROWBUF_INIT, Critical},
static PROCESSING_ROUTINE g_FirstSystemRoutines[] = {
                              MIGMAIN_SYSFIRST_FUNCTIONS /* , */
                              PROCESSING_ROUTINE_TERMINATOR
                              };
static PROCESSING_ROUTINE g_LastSystemRoutines[] = {
                              MIGMAIN_SYSLAST_FUNCTIONS /* , */
                              PROCESSING_ROUTINE_TERMINATOR
                              };
#undef DEFMAC

#define DEFMAC(fn, MsgId, Critical) {NULL, fn, MsgId, 0, #fn, GROWBUF_INIT, Critical},
static PROCESSING_ROUTINE g_UserRoutines[] = {
                              MIGMAIN_USER_FUNCTIONS /* , */
                              PROCESSING_ROUTINE_TERMINATOR
                              };
#undef DEFMAC


/*++

Macro Expansion Lists Description:

  FILESTODELETE_EVALUATION_FUNCTIONS contains a list of functions related with [Delete Files]
  section in win95upg.inf; if a file should be conditionally deleted, the corresponding eval
  function is called; if it returns TRUE and the result is not negated or if it returns FALSE
  and the result is negated, then the file is deleted.
  (see comments in win95upg.inx\[Delete Files])

Line Syntax:

   DEFMAC(Function)

Arguments:

   Function   - Name of an evaluation function; it receives as a parameter the name of
                the file for which it is called

Variables Generated From List:

   g_MapNameToEvalFn

For accessing the arrays there are the following functions:

   pFindEvalFnByName

--*/

#define FILESTODELETE_EVALUATION_FUNCTIONS          \
            DEFMAC(Boot16Enabled)                   \
            DEFMAC(DoesRegKeyValuesExist)           \
            DEFMAC(IsMillennium)                    \

//
// define function prototipes
//
typedef BOOL (EVALFN) (IN PCTSTR PathToEval, IN OUT PINFSTRUCT InfStruct, IN UINT FirstArgIndex);
typedef EVALFN* PEVALFN;

#define DEFMAC(Fn)  EVALFN Fn;

FILESTODELETE_EVALUATION_FUNCTIONS

#undef DEFMAC


//
// define the mapping structure
//
typedef struct {
    PCTSTR      FnName;
    PEVALFN     EvalFn;
} MAP_NAME_TO_EVALFN;

#define DEFMAC(Fn)  TEXT(#Fn), Fn,

static MAP_NAME_TO_EVALFN g_MapNameToEvalFn[] = {
    FILESTODELETE_EVALUATION_FUNCTIONS
    NULL, NULL
};

#undef DEFMAC

typedef SYNCENGAPI TWINRESULT (WINAPI *POPENBRIEFCASE) (LPCTSTR, DWORD, HWND, PHBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *PANYTWINS)(HBRFCASE, PBOOL);
typedef SYNCENGAPI TWINRESULT (WINAPI *PCLOSEBRIEFCASE)(HBRFCASE);

//
// Local private prototypes
//

VOID
pGlobalProcessingInit (
    VOID
    );

VOID
pGlobalProcessingTerminate (
    VOID
    );

VOID
pWriteAccountToMemDb (
    PUSERENUM EnumPtr
    );


//
// Implementation
//

VOID
pInitTable (
    PPROCESSING_ROUTINE p
    )
{
    for ( ; p->SysFnPtr || p->UserFnPtr ; p++) {
        p->SliceIdArray.GrowSize = sizeof (DWORD) * 8;
    }
}


VOID
InitProcessingTable (
    VOID
    )
{
    pInitTable (g_FirstSystemRoutines);
    pInitTable (g_UserRoutines);
    pInitTable (g_LastSystemRoutines);
}


VOID
pTerminateTable (
    PPROCESSING_ROUTINE p
    )
{
    for ( ; p->SysFnPtr || p->UserFnPtr ; p++) {
        FreeGrowBuffer (&p->SliceIdArray);
    }
}


VOID
TerminateProcessingTable (
    VOID
    )
{
    pTerminateTable (g_FirstSystemRoutines);
    pTerminateTable (g_UserRoutines);
    pTerminateTable (g_LastSystemRoutines);
}


DWORD
pProcessWorker (
    IN      DWORD Request,
    IN      PPROCESSING_ROUTINE fn,
    IN      PUSERENUM EnumPtr           OPTIONAL
    )
{
    DWORD rc;
    PDWORD SliceId;
    DWORD Size;


    //
    // If running the function, start the progress bar slice
    //

    if (Request == REQUEST_RUN) {

        if (fn->Ticks == 0) {
            return ERROR_SUCCESS;
        }

        Size = fn->SliceIdArray.End / sizeof (DWORD);
        if (fn->SliceIdArray.UserIndex >= Size) {
            DEBUGMSG ((DBG_WHOOPS, "pProcessWorker: QUERYTICKS vs. RUN mismatch"));
            return ERROR_SUCCESS;
        }

        SliceId = (PDWORD) fn->SliceIdArray.Buf + fn->SliceIdArray.UserIndex;
        fn->SliceIdArray.UserIndex += 1;

        //
        // Set the progress bar title
        //

        if (fn->MsgId) {
            ProgressBar_SetComponentById (fn->MsgId);
            ProgressBar_SetSubComponent (NULL);
        }

        ProgressBar_SetFnName (fn->FnName);
        BeginSliceProcessing (*SliceId);

        DEBUGLOGTIME (("Starting function: %s (slice %u)", fn->FnName, *SliceId));
    }


    __try {
        //
        // Now call the function
        //

        if (fn->SysFnPtr) {
            //
            // System processing
            //

            rc = fn->SysFnPtr (Request);
        } else {
            //
            // User processing
            //
            MYASSERT (EnumPtr || Request == REQUEST_BEGINUSERPROCESSING || Request == REQUEST_ENDUSERPROCESSING);
            MYASSERT (fn->UserFnPtr);

            rc = fn->UserFnPtr (Request, EnumPtr);
        }

#ifdef DEBUG

        if (!g_ConfigOptions.Fast) {

            TCHAR dbgBuf[256];
            PTSTR BadPtr = NULL;
            if (GetPrivateProfileString ("Exception", fn->FnName, "", dbgBuf, 256, g_DebugInfPath)) {

                StringCopy (BadPtr, TEXT("Blow Up!!"));
            }
        }





#endif


    }
    __except (1) {


        //
        // Caught an exception..
        //
        LOG ((LOG_WARNING, "Function %s threw an exception.", fn->FnName));
        SafeModeExceptionOccured ();

        if (fn->Critical && Request == REQUEST_RUN) {


            //
            // Since this was a critical function, inform the user and tank the upgrade.
            //
            SetLastError (ERROR_NOACCESS);

            LOG ((LOG_FATAL_ERROR, (PCSTR)MSG_UNEXPECTED_ERROR_ENCOUNTERED, GetLastError()));
            pGlobalProcessingTerminate();
            rc = ERROR_CANCELLED;
        }


    }

    if (CANCELLED()) {
        rc = ERROR_CANCELLED;
    }


    //
    // If running the function, end the progress bar slice
    //

    if (Request == REQUEST_RUN) {
        DEBUGLOGTIME (("Function complete: %s", fn->FnName));

        EndSliceProcessing();

        if (rc != ERROR_SUCCESS) {
            pGlobalProcessingTerminate();
            if (!CANCELLED()) {
                LOG ((LOG_ERROR, "Failure in %s, rc=%u", fn->FnName, rc));
            }
            ELSE_DEBUGMSG ((DBG_VERBOSE, "Winnt32 was cancelled during %s.", fn->FnName));
        }

        ProgressBar_ClearFnName();

        SetLastError (rc);
    }

    //
    // If querying the ticks, register them and add slice ID to grow buffer
    //

    else {
        fn->Ticks += rc;

        SliceId = (PDWORD) GrowBuffer (&fn->SliceIdArray, sizeof (DWORD));
        *SliceId = RegisterProgressBarSlice (rc);

        rc = ERROR_SUCCESS;
    }

    return rc;
}


DWORD
pProcessTable (
    IN      DWORD Request,
    IN      PPROCESSING_ROUTINE Table
    )

/*++

Routine Description:

  pProcessTable calls all routines in the specified table to perform
  the specified request.

Arguments:

  Request - Specifies REQUEST_QUERYTICKS when a tick estimate is needed,
            or REQUEST_RUN when the function needs to perform its
            processing.

Return Value:

  Win32 status code.

--*/

{
    PPROCESSING_ROUTINE OrgStart;
    DWORD rc = ERROR_SUCCESS;
    USERENUM e;
    BOOL validUserFound = FALSE;
    static BOOL firstTime = TRUE;

    while (rc == ERROR_SUCCESS && (Table->SysFnPtr || Table->UserFnPtr)) {

        //
        // If the table is a system function table or the request is to begin/end user processing,
        // then this is the simple case. No enumeration of users is needed.
        //
        if (Table->SysFnPtr || Request == REQUEST_BEGINUSERPROCESSING || Request == REQUEST_ENDUSERPROCESSING) {

            rc = pProcessWorker (Request, Table, NULL);
            Table++;

        } else {

            MYASSERT (Table->UserFnPtr);

            //
            // Enumerate each user, and run through all the per-user
            // routines in the group.
            //

            OrgStart = Table;

            if (EnumFirstUser (&e, ENUMUSER_ENABLE_NAME_FIX)) {

                do {

                    //
                    // Skip invalid users
                    //
                    if (e.AccountType & INVALID_ACCOUNT) {
                        continue;
                    }

                    //
                    // Create user-specific environment variables
                    //

                    InitNtUserEnvironment (&e);

                    //
                    // Set global user profile root.
                    //
                    g_UserProfileRoot = e.OrgProfilePath;


                    if (firstTime) {

                        //
                        // Log information about the user to the debug log.
                        //
                        DEBUGMSG ((
                            DBG_SYSMIG,
                            "--- User Info ---\n"
                                " User Name: %s (%s)\n"
                                " Admin User Name: %s (%s)\n"
                                " User Hive: %s\n"
                                " Profile Dir: %s\n"
                                " User Hive Key: 0%0Xh\n"
                                " Win9x Profile Path: %s\n"
                                " WinNT Profile Path: %s\n"
                                " Common Profiles: %s\n",
                            e.UserName,
                            e.FixedUserName,
                            e.AdminUserName,
                            e.FixedAdminUserName,
                            e.UserDatPath,
                            e.ProfileDirName,
                            e.UserRegKey,
                            e.OrgProfilePath,
                            e.NewProfilePath,
                            e.CommonProfilesEnabled ? TEXT("Yes") : TEXT("No")
                            ));


                        DEBUGMSG ((
                            DBG_SYSMIG,
                            "--- User Flags ---\n"
                                " Named User: %s\n"
                                " Default User: %s\n"
                                " Administrator: %s\n"
                                " Last Logged On User: %s\n"
                                " Invalid Account: %s\n"
                                " Logon Prompt Account: %s\n"
                                " Current User: %s\n",
                            e.AccountType & NAMED_USER ? TEXT("Yes") : TEXT("No"),
                            e.AccountType & DEFAULT_USER ? TEXT("Yes") : TEXT("No"),
                            e.AccountType & ADMINISTRATOR ? TEXT("Yes") : TEXT("No"),
                            e.AccountType & LAST_LOGGED_ON_USER ? TEXT("Yes") : TEXT("No"),
                            e.AccountType & INVALID_ACCOUNT ? TEXT("Yes") : TEXT("No"),
                            e.AccountType & LOGON_PROMPT ? TEXT("Yes") : TEXT("No"),
                            e.AccountType & CURRENT_USER ? TEXT("Yes") : TEXT("No")
                            ));


                        //
                        // Special case: record the Administrator/Owner account
                        //
                        if ((e.AccountType & (ADMINISTRATOR|NAMED_USER)) == (ADMINISTRATOR|NAMED_USER)) {
                            //
                            // Administrator account on machine that has named users
                            //

                            MemDbSetValueEx (
                                MEMDB_CATEGORY_ADMINISTRATOR_INFO,  // "AdministratorInfo"
                                MEMDB_ITEM_AI_ACCOUNT,              // "Account"
                                NULL,                               // no field
                                e.FixedAdminUserName,               // the Win9x user name
                                0,
                                NULL
                                );

                        } else if ((e.AccountType & (ADMINISTRATOR|NAMED_USER|DEFAULT_USER)) ==
                                   (ADMINISTRATOR|DEFAULT_USER)
                                   ) {
                            //
                            // Administrator account on machine with no users at all
                            //

                            MemDbSetValueEx (
                                MEMDB_CATEGORY_ADMINISTRATOR_INFO,  // "AdministratorInfo"
                                MEMDB_ITEM_AI_ACCOUNT,              // "Account"
                                NULL,                               // no field
                                e.FixedUserName,                    // "Administrator" or "Owner"
                                0,
                                NULL
                                );
                        }

                        //
                        // Save user account to memdb
                        //
                        pWriteAccountToMemDb(&e);
                    }

                    //
                    // if we have gotten this far, then we have a valid user to process.
                    //
                    validUserFound = TRUE;

                    //
                    // Call all the user processing functions.
                    //
                    DEBUGMSG ((DBG_SYSMIG, "Processing User: %s.", e.UserName ));

                    for (Table = OrgStart ; Table->UserFnPtr ; Table++) {
                        if (rc == ERROR_SUCCESS) {
                            rc = pProcessWorker (Request, Table, &e);
                        }
                    }

                    //
                    // Clear out the global user profile variable.
                    //
                    g_UserProfileRoot = NULL;

                    //
                    // Remove user-specific environment variables
                    //

                    TerminateNtUserEnvironment();

                } while (EnumNextUser (&e));
            }
            ELSE_DEBUGMSG ((DBG_WARNING, "No active users to process!"));


            //
            // Inform the user if there were no valid users to process
            // (Probably will never happen)
            //
            if (!validUserFound) {
                if (CANCELLED()) {

                    rc = ERROR_CANCELLED;

                } else {

                    OkBox (g_ParentWnd, MSG_NO_VALID_ACCOUNTS_POPUP);
                    rc = ERROR_BADKEY;
                }
            }

            //
            // Make sure that we have passed all of the user functions in the
            // table.
            //
            while (Table->UserFnPtr) {
                Table++;
            }

            firstTime = FALSE;
        }
    }

    return rc;
}


VOID
PrepareProcessingProgressBar (
    VOID
    )

/*++

Routine Description:

  Prepares the progress bar by estimating the number of ticks for each slice
  of the progress bar.  pQueryWorker is called for each table of functions
  to run during the processing wizard page.

Arguments:

  none

Return value:

  none

--*/

{
    pGlobalProcessingInit();
    InitProcessingTable();

    pProcessTable (REQUEST_QUERYTICKS, g_FirstSystemRoutines);
    pProcessTable (REQUEST_QUERYTICKS, g_UserRoutines);
    pProcessTable (REQUEST_QUERYTICKS, g_LastSystemRoutines);
}


DWORD
RunSysFirstMigrationRoutines (
    VOID
    )

/*++

Routine Description:

  runs all functions from g_FirstSystemRoutines array.
  If the messageId is not 0 also updates progress bar title.

Arguments:

  none

Return value:

  Win32 status code.

--*/

{
    return pProcessTable (REQUEST_RUN, g_FirstSystemRoutines);
}


DWORD
RunUserMigrationRoutines (
    VOID
    )

/*++

Routine Description:

  RunUserMigrationRoutines is called by userloop.c, between the first system
  processing and the last system processing.  Routines in the
  MIGMAIN_USER_FUNCTIONS macro expansion list are called.  The progress bar
  is updated automatically.

Arguments:

  User     - Specifies the user name
  UserType - Specifies the user account type
  UserRoot - Specifies the mapped registry handle (equivalent to HKCU)

Return value:

  Win32 status code.

--*/

{
    DWORD rc = ERROR_SUCCESS;

    //
    // First, let routines know that processing will soon begin. This gives them
    // an opportunity to allocate any needed resources.
    //

    rc = pProcessTable (REQUEST_BEGINUSERPROCESSING, g_UserRoutines);

    //
    // Now, do the actual work.
    //
    if (rc == ERROR_SUCCESS) {

        rc = pProcessTable (REQUEST_RUN, g_UserRoutines);

    }

    //
    // Finally, give the user routines a chance to clean up any resources that may
    // have been allocated in REQUEST_BEGINUSERPROCESSING.
    //
    if (rc == ERROR_SUCCESS) {

        rc = pProcessTable (REQUEST_ENDUSERPROCESSING, g_UserRoutines);
    }

    return rc;

}


DWORD
RunSysLastMigrationRoutines (
    VOID
    )

/*++

Routine Description:

  runs all functions from g_LastSystemRoutines array.
  If the messageId is not 0 also updates progress bar title.

Arguments:

  none

Return value:

  Win32 status code.

--*/

{
    DWORD Result;

    Result = pProcessTable (REQUEST_RUN, g_LastSystemRoutines);

    TerminateProcessingTable();

    if (Result == ERROR_SUCCESS) {
        pGlobalProcessingTerminate();
    }

    return Result;
}


DWORD
AddDefaultCleanUpDirs (
    DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_ADDDEFAULTCLEANUPDIRS;

    case REQUEST_RUN:
        MemDbSetValueEx (
            MEMDB_CATEGORY_CLEAN_UP_DIR,
            g_SystemDir,
            NULL,
            NULL,
            0,
            NULL
            );

        MemDbSetValueEx (
            MEMDB_CATEGORY_CLEAN_UP_DIR,
            g_ProgramFilesDir,
            NULL,
            NULL,
            0,
            NULL
            );
        break;

    }

    return ERROR_SUCCESS;
}


VOID
pGlobalProcessingInit (
    VOID
    )
{
    TCHAR TempPath[MAX_TCHAR_PATH];

    InitGlobalPaths();

    if (!BeginIconExtraction (&g_IconContext, NULL)) {
        LOG ((LOG_ERROR, "DefaultIconPreservation: Can't start icon extraction"));
        return;
    }

    wsprintf (TempPath, TEXT("%s\\%s"), g_TempDir, S_MIGICONS_DAT);
    if (!OpenIconImageFile (&g_IconContext, TempPath, TRUE)) {
        LOG ((LOG_ERROR, "DefaultIconPreservation: Can't create %s", TempPath));
        EndIconExtraction (&g_IconContext);
    }

    return;
}

VOID
pGlobalProcessingTerminate (
    VOID
    )
{
    EndIconExtraction (&g_IconContext);
}


VOID
pAddAllIds (
    IN      PCTSTR IdList
    )
{
    PCTSTR Temp;
    PTSTR p;
    CHARTYPE ch;

    Temp = DuplicateText (IdList);

    p = _tcspbrk (Temp, TEXT("&\\"));

    while (p) {
        ch = *p;
        *p = 0;

        DEBUGMSG ((DBG_NAUSEA, "System has PNP ID: %s", Temp));

        MemDbSetValueEx (
            MEMDB_CATEGORY_PNPIDS,
            Temp,
            NULL,
            NULL,
            0,
            NULL
            );

        *p = (TCHAR)ch;
        p = _tcspbrk (_tcsinc (p), TEXT("&\\"));
    }

    FreeText (Temp);
}


DWORD
PreparePnpIdList (
    DWORD Request
    )

/*++

Routine Description:

  PreparePnpIdList puts all PNP IDs in a memdb category to allow the PNPID
  attribute to work in migdb.inf.

Arguments:

  Request - Specifies REQUEST_QUERYTICKS or REQUEST_RUN.

Return Value:

  Always TICKS_PREPAREPNPIDLIST for REQUEST_QUERYTICKS, always ERROR_SUCCESS for REQUEST_RUN.

--*/

{
    HARDWARE_ENUM e;
    PTSTR p;

    if (Request == REQUEST_RUN) {

        if (EnumFirstHardware (
                &e,
                ENUM_ALL_DEVICES,
                ENUM_DONT_WANT_DEV_FIELDS|ENUM_DONT_WANT_USER_SUPPLIED|ENUM_DONT_REQUIRE_HARDWAREID
                )) {

            do {
                //
                // Add each part of the PNP ID as an endpoint
                //

                //
                // Skip past HKLM\Enum and add all IDs with the root
                //

                p = _tcschr (e.FullKey, TEXT('\\'));
                p = _tcschr (_tcsinc (p), TEXT('\\'));
                p = _tcsinc (p);

                pAddAllIds (p);

                //
                // Add all IDs without the root
                //

                pAddAllIds (e.InstanceId);

            } while (EnumNextHardware (&e));
        }

        return ERROR_SUCCESS;

    } else {
        return TICKS_PREPAREPNPIDLIST;
    }
}


DWORD
PrepareIconList (
    DWORD Request
    )

/*++

Routine Description:

  PrepareIconList reads win95upg.inf [Moved Icons] and puts them
  in memdb for future use.

Arguments:

  Request - Specifies REQUEST_QUERYTICKS or REQUEST_RUN.

Return Value:

  Always TICKS_PREPAREPNPIDLIST for REQUEST_QUERYTICKS, always ERROR_SUCCESS
  for REQUEST_RUN.

--*/

{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR srcPath;
    TCHAR expandedSrcPath[MAX_TCHAR_PATH];
    PCTSTR destPath;
    TCHAR expandedDestPath[MAX_TCHAR_PATH];
    INT srcIndex;
    INT destIndex;
    INT srcId;
    INT destId;
    BOOL ok;
    DWORD destOffset;
    TCHAR num[32];
    TCHAR node[MEMDB_MAX];

    if (Request == REQUEST_RUN) {

        if (InfFindFirstLine (g_Win95UpgInf, S_MOVED_ICONS, NULL, &is)) {
            do {
                srcPath = InfGetStringField (&is, 1);
                ok = (srcPath != NULL);

                ok = ok && InfGetIntField (&is, 2, &srcIndex);
                ok = ok && (srcIndex >= 0);

                ok = ok && InfGetIntField (&is, 3, &srcId);
                ok = ok && (srcId >= 0);

                destPath = InfGetStringField (&is, 4);
                ok = ok && (destPath != NULL);

                ok = ok && InfGetIntField (&is, 5, &destIndex);
                ok = ok && (destIndex >= 0);

                ok = ok && InfGetIntField (&is, 6, &destId);
                ok = ok && (destId >= 0);

                if (!ok) {
                    DEBUGMSG ((DBG_WHOOPS, "Syntax error in %s of win95upg.inf", S_MOVED_ICONS));
                } else {
                    //
                    // Convert env vars in srcPath and destPath
                    //

                    Expand9xEnvironmentVariables (
                        srcPath,
                        expandedSrcPath,
                        sizeof (expandedSrcPath)
                        );

                    Expand9xEnvironmentVariables (
                        destPath,
                        expandedDestPath,
                        sizeof (expandedDestPath)
                        );

                    //
                    // Write out memdb nodes
                    //

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_DATA,
                        expandedDestPath,
                        NULL,
                        NULL,
                        0,
                        &destOffset
                        );

                    wsprintf (num, TEXT("%i"), srcIndex);
                    MemDbBuildKey (
                        node,
                        MEMDB_CATEGORY_ICONS_MOVED,
                        expandedSrcPath,
                        num,
                        NULL
                        );

                    MemDbSetValueAndFlags (node, destOffset, destIndex, 0xFFFFFFFF);

                    wsprintf (num, TEXT("-%i"), srcId);
                    MemDbBuildKey (
                        node,
                        MEMDB_CATEGORY_ICONS_MOVED,
                        expandedSrcPath,
                        num,
                        NULL
                        );

                    MemDbSetValueAndFlags (node, destOffset, destId, 0xFFFFFFFF);
                }

            } while (InfFindNextLine (&is));
        }

        return ERROR_SUCCESS;

    } else {
        return TICKS_PREPAREPNPIDLIST;
    }
}



VOID
pWriteAccountToMemDb (
    PUSERENUM EnumPtr
    )
{
    HKEY LogonKey, AuthAgentKey=NULL;
    PCTSTR LastLoggedOnUser, Provider, AuthAgent=NULL;
    TCHAR Domain[MAX_SERVER_NAME];
    BOOL MsNetInstalled = FALSE;

    //
    // Write account name to KnownDomain if the user was the
    // last logged on user
    //

    Domain[0] = 0;

    //
    // Determine if Microsoft Network is installed
    //
    if ((EnumPtr -> AccountType & LOGON_PROMPT) || (EnumPtr -> AccountType & DEFAULT_USER)) {

        //
        // Nothing to do for logon user.
        //
        return;

    } else if (EnumPtr -> AccountType & ADMINISTRATOR) {

        //
        // Because this user is the local Administrator, we must default
        // to a local account.  We get this behavior by assuming the
        // MSNP32 key doesn't exist (even if it really does).
        //

        AuthAgentKey = NULL;

    } else if (EnumPtr -> AccountType & DEFAULT_USER) {

        //
        // Nothing to do for default user
        //
        return;

    } else {

        //
        // Real user. Get the MSNP32 key.
        //

        AuthAgentKey = OpenRegKeyStr (S_MSNP32);

    }

    if (AuthAgentKey) {

        //
        // If last logged on user was the same as the user being processed,
        // and the user is a Microsoft Network user, obtain the domain name.
        //

        MsNetInstalled = TRUE;

        LogonKey = OpenRegKeyStr (S_LOGON_KEY);
        if (LogonKey) {
            LastLoggedOnUser = GetRegValueData (LogonKey, S_USERNAME_VALUE);

            if (LastLoggedOnUser) {
                if (StringIMatch (LastLoggedOnUser, EnumPtr -> UserName)) {
                    //
                    // User is the same as last logged on user.  If the primary
                    // provider is Microsoft Network, then get the authenticating
                    // agent (which is the domain name).
                    //

                    Provider = GetRegValueData (LogonKey, S_PRIMARY_PROVIDER);
                    if (Provider) {
                        if (StringIMatch (Provider, S_LANMAN)) {
                            //
                            // Obtain the domain name
                            //

                            if (AuthAgentKey) {
                                AuthAgent = GetRegValueData (AuthAgentKey, S_AUTHENTICATING_AGENT);
                                if (AuthAgent) {
                                    StringCopy (Domain, AuthAgent);
                                    MemFree (g_hHeap, 0, AuthAgent);
                                }
                            }
                        }
                        MemFree (g_hHeap, 0, Provider);
                    }
                }

                MemFree (g_hHeap, 0, LastLoggedOnUser);
            }

            CloseRegKey (LogonKey);
        }

        CloseRegKey (AuthAgentKey);
    }

    if (!MsNetInstalled || *Domain) {
        //
        // Assuming we have a valid user name:
        //   If MSNP32 is not installed, default to a local account.
        //   If it is installed, we must have a valid domain name.
        //
        // If we do not have a valid user name, then the current user
        // is the .Default account, which does not need to be verified
        // on the net.
        //

        if (*EnumPtr -> UserName) {
            MemDbSetValueEx (MEMDB_CATEGORY_KNOWNDOMAIN, Domain, EnumPtr -> FixedUserName, NULL, 0, NULL);
        }
    } else {

        //
        // MSNP32 is installed, but the domain name for this user is unknown.
        // Perform a search.
        //

        MemDbSetValueEx (MEMDB_CATEGORY_AUTOSEARCH, EnumPtr -> FixedUserName, NULL, NULL, 0, NULL);
    }
}


BOOL
pReportMapiIfNotHandled (
    VOID
    )
{
    PCTSTR Group;
    PCTSTR Message;
    TCHAR pattern[MEMDB_MAX];
    MEMDB_ENUM enumItems;
    BOOL addMsg = FALSE;
    DWORD status = 0;
    HKEY key;

    key = OpenRegKeyStr (S_INBOX_CFG);
    if (key) {
        CloseRegKey (key);

        MemDbBuildKey (pattern, MEMDB_CATEGORY_MAPI32_LOCATIONS, TEXT("*"), NULL, NULL);

        if (MemDbEnumFirstValue (&enumItems, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {

            do {
                if (IsReportObjectHandled (enumItems.szName)) {
                    continue;
                }
                status = GetFileStatusOnNt (enumItems.szName);
                if ((status & FILESTATUS_REPLACED) != FILESTATUS_REPLACED) {
                    addMsg = TRUE;
                    break;
                }

            } while (MemDbEnumNextValue (&enumItems));
        }
    }

    if (addMsg) {

        Group = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_MAPI_NOT_HANDLED_SUBGROUP, NULL);
        Message = GetStringResource (MSG_MAPI_NOT_HANDLED);

        if (Message && Group) {
            MsgMgr_ObjectMsg_Add (TEXT("*MapiNotHandled"), Group, Message);
        }
        FreeText (Group);
        FreeStringResource (Message);
    }

    return TRUE;
}

DWORD
ReportMapiIfNotHandled (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_REPORTMAPIIFNOTHANDLED;

    case REQUEST_RUN:
        if (pReportMapiIfNotHandled ()) {
            return ERROR_SUCCESS;
        }
        return GetLastError ();
    }
    return ERROR_SUCCESS;
}


DWORD
GatherImeInfo (
    IN      DWORD Request
    )
{

    REGKEY_ENUM e;
    PCTSTR imeFile = NULL;
    TCHAR imePath[MAX_TCHAR_PATH];
    HKEY topKey = NULL;
    HKEY layoutKey = NULL;
    UINT status = 0;

    switch (Request) {

    case REQUEST_QUERYTICKS:
        return TICKS_GATHER_IME_INFO;
        break;

    case REQUEST_RUN:


        //
        // Enumerate through the keyboard layout registry looking for IMEs.
        //
        topKey = OpenRegKeyStr (S_KEYBOARD_LAYOUT_REG);
        if (!topKey) {
            DEBUGMSG ((DBG_ERROR, "Could not open keyboard layouts registry."));
            return ERROR_SUCCESS;
        }


        if (EnumFirstRegKey (&e, topKey)) {
            do {

                //
                // We only care about IME entries.
                //
                if (*e.SubKeyName == TEXT('e') || *e.SubKeyName == TEXT('E')) {

                    layoutKey = OpenRegKey (topKey, e.SubKeyName);
                    if (layoutKey) {

                        imeFile = GetRegValueString (layoutKey, TEXT("IME File"));
                        if (imeFile && SearchPath (NULL, imeFile, NULL, MAX_TCHAR_PATH, imePath, NULL)) {


                            //
                            // We are only going to migrate this IME file if it is left around after we
                            // are done.
                            //
                            status = GetFileStatusOnNt (imePath);
                            if ((status & FILESTATUS_DELETED) == 0) {
                                MemDbSetValueEx (MEMDB_CATEGORY_GOOD_IMES, imeFile, NULL, NULL, 0, NULL);

                            }
                            ELSE_DEBUGMSG ((DBG_NAUSEA, "IME %s will be suppressed from the keyboard layout merge.", e.SubKeyName));
                        }

                        if (imeFile) {
                            MemFree (g_hHeap, 0, imeFile);
                        }

                        CloseRegKey (layoutKey);
                    }
                }

            } while (EnumNextRegKey (&e));
        }

        CloseRegKey (topKey);


        break;
    }
    return ERROR_SUCCESS;
}


PEVALFN
pFindEvalFnByName (
    IN      PCTSTR FnName
    )
{
    INT i;

    i = 0;
    while (g_MapNameToEvalFn[i].FnName) {
        if (StringMatch (FnName, g_MapNameToEvalFn[i].FnName)) {
            return g_MapNameToEvalFn[i].EvalFn;
        }
        i++;
    }

    return NULL;
}


DWORD
DeleteStaticFiles (
    IN      DWORD Request
    )
{

#define MAX_DRIVE_STRINGS (26 * 4 + 1)

    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR Data;
    TCHAR ExpandedData[MAX_TCHAR_PATH];
    PTSTR Pattern;
    FILE_ENUM e;
    BOOL Negate, Eval;
    PEVALFN fn;
    DWORD attr;
    TCHAR drives[MAX_DRIVE_STRINGS];
    DWORD rc;
    PTSTR p;
    PCTSTR q;
    TREE_ENUM eFiles;

    switch (Request) {

    case REQUEST_QUERYTICKS:
        return TICKS_DELETESTATICFILES;

    case REQUEST_RUN:

        if (InfFindFirstLine (g_Win95UpgInf, S_FILES_TO_REMOVE, NULL, &is)) {
            do {
                Data = InfGetStringField (&is, 1);
                if (!Data) {
                    continue;
                }

                Expand9xEnvironmentVariables (
                    Data,
                    ExpandedData,
                    sizeof (ExpandedData)
                    );

                Data = InfGetStringField (&is, 2);
                if (Data) {
                    if (*Data == TEXT('!')) {
                        ++Data;
                        Negate = TRUE;
                    } else {
                        Negate = FALSE;
                    }
                    //
                    // call the function by name
                    //
                    fn = pFindEvalFnByName (Data);
                    //
                    // did you forget to implement it?
                    //
                    MYASSERT (fn);
                    if (!fn) {
                        //
                        // don't remove the file/dir
                        //
                        continue;
                    }
                } else {
                    fn = NULL;
                }

                p = drives;
                if (*ExpandedData == TEXT('?')) {
                    ACCESSIBLE_DRIVE_ENUM e;
                    if (GetFirstAccessibleDrive (&e)) {
                        do {
                            *p++ = e->Drive[0];
                        } while (GetNextAccessibleDrive (&e));
                    }
                } else {
                    *p++ = *ExpandedData;
                }
                *p = 0;

                p = drives;
                do {
                    *ExpandedData = *p++;
                    attr = GetFileAttributes (ExpandedData);
                    if ((attr != -1) && (attr & FILE_ATTRIBUTE_DIRECTORY)) {

                        if (fn) {
                            Eval = (*fn)(ExpandedData, &is, 3) ? TRUE : FALSE;
                            //
                            // !Negate && !Eval || Negate && Eval means !(Negate ^ Eval)
                            //
                            if (!(Negate ^ Eval)) {
                                //
                                // don't remove the directory
                                //
                                continue;
                            }
                        }

                        if (IsDriveExcluded (ExpandedData)) {
                            DEBUGMSG ((DBG_VERBOSE, "Skipping static file %s because it is excluded", ExpandedData));
                            continue;
                        }

                        if (!IsDriveAccessible (ExpandedData)) {
                            DEBUGMSG ((DBG_VERBOSE, "Skipping static file %s because it is not accessible", ExpandedData));
                            continue;
                        }

                        if (EnumFirstFileInTree (&eFiles, ExpandedData, NULL, FALSE)) {
                            do {
                                //
                                // Tally up the saved bytes, and free the space on the drive.
                                //
                                FreeSpace (
                                    eFiles.FullPath,
                                    eFiles.FindData->nFileSizeHigh * MAXDWORD + eFiles.FindData->nFileSizeLow
                                    );
                            } while (EnumNextFileInTree (&eFiles));
                        }

                        MemDbSetValueEx (MEMDB_CATEGORY_FULL_DIR_DELETES, ExpandedData, NULL, NULL, 0, NULL);

                    } else {
                        Pattern = _tcsrchr (ExpandedData, TEXT('\\'));
                        //
                        // full path please
                        //
                        MYASSERT (Pattern);
                        if (!Pattern) {
                            continue;
                        }

                        *Pattern = 0;

                        if (EnumFirstFile (&e, ExpandedData, Pattern + 1)) {
                            do {

                                if (fn) {
                                    Eval = (*fn)(e.FullPath, &is, 3) ? TRUE : FALSE;
                                    //
                                    // !Negate && !Eval || Negate && Eval means !(Negate ^ Eval)
                                    //
                                    if (!(Negate ^ Eval)) {
                                        //
                                        // don't remove the file
                                        //
                                        continue;
                                    }
                                }

                                MarkFileForDelete (e.FullPath);

                            } while (EnumNextFile (&e));
                        }
                        *Pattern = TEXT('\\');
                    }
                } while (*p);
            } while (InfFindNextLine (&is));
        }

        InfCleanUpInfStruct (&is);

        break;
    }

    return ERROR_SUCCESS;
}


BOOL
Boot16Enabled (
    IN      PCTSTR PathToEval,
    IN OUT  PINFSTRUCT InfStruct,
    IN      UINT FirstArgIndex
    )
{
    //
    // at this point, check *g_ForceNTFSConversion to be FALSE
    // and *g_Boot16 not to be disabled
    //
    return (!*g_ForceNTFSConversion) && (*g_Boot16 != BOOT16_NO);
}


BOOL
DoesRegKeyValuesExist (
    IN      PCTSTR PathToEval,
    IN OUT  PINFSTRUCT InfStruct,
    IN      UINT FirstArgIndex
    )
{
    PCTSTR RegKey;
    PCTSTR Value;
    HKEY key;
    BOOL b = FALSE;

    RegKey = InfGetStringField (InfStruct, FirstArgIndex++);
    if (RegKey) {
        key = OpenRegKeyStr (RegKey);
        if (key) {
            b = TRUE;
            while (b && (Value = InfGetStringField (InfStruct, FirstArgIndex++)) != NULL) {
                b = (RegQueryValueEx (key, Value, NULL, NULL, NULL, NULL) == ERROR_SUCCESS);
            }
            CloseRegKey (key);
        }
    }

    return b;
}

BOOL
IsMillennium (
    IN      PCTSTR PathToEval,
    IN OUT  PINFSTRUCT InfStruct,
    IN      UINT FirstArgIndex
    )
{
    return ISMILLENNIUM();
}


/*++

Routine Description:

  GatherDead() gathers disabled or bad objects (apps, cpls, runkeys,
  links) and saves them to a file (dead.ini) so they can be tested
  to see if they actually are not bad.  This functions only in
  PRERELEASE mode.

Arguments:

  Request   - reason for calling function

Return Value:

  if in REQUEST_RUN mode, always returns ERROR_SUCCESS
  because we don't want to break setup.

--*/

DWORD
GatherDead (
    IN      DWORD Request
    )
{
    FILEOP_ENUM FileEnum;
    MEMDB_ENUM MemDbEnum;
    REGVALUE_ENUM RegEnum;
    HKEY Key;
    HANDLE File;
    TCHAR Temp[MEMDB_MAX];
    TCHAR MemDbKey[MEMDB_MAX];
    TCHAR DeadPath[MEMDB_MAX];
    PTSTR Data;

    switch (Request) {

    case REQUEST_QUERYTICKS:
#ifndef PRERELEASE
        return 0;
#else
        return TICKS_GATHERDEAD;
#endif  //PRERELEASE


    case REQUEST_RUN:

        //
        // We only do stuff here if in PRERELEASE mode, because
        // in release mode REQUEST_QUERYTICKS returns 0, so
        // REQUEST_RUN is not called.
        //

        wsprintf (DeadPath, TEXT("%s\\%s"), g_WinDir, DEAD_FILE);

        File = CreateFile (
            DeadPath,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

        if (File==INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_WARNING, "Could not create " DEAD_FILE "!"));
            return ERROR_SUCCESS;
        }


        WriteFileString(File, TEXT("[Version]\r\nSignature=\"$Chicago$\""));
        WriteFileString(File, TEXT("\r\n\r\n[DEAD]\r\n"));

        //
        //  add links to dead.ini file
        //
        if (MemDbEnumFirstValue (
            &MemDbEnum,
            MEMDB_CATEGORY_LINKEDIT,
            MEMDB_ALL_SUBLEVELS,
            MEMDB_ENDPOINTS_ONLY
            ))
        {
            do {
                wsprintf(Temp, TEXT("%s=%d\r\n"), MemDbEnum.szName, OBJECTTYPE_LINK);
                WriteFileString(File, Temp);
            } while (MemDbEnumNextValue (&MemDbEnum));
        }


        //
        // add bad apps to dead.ini file
        //
        if (MemDbEnumFirstValue (
            &MemDbEnum,
            MEMDB_CATEGORY_MODULE_CHECK,
            MEMDB_ALL_SUBLEVELS,
            MEMDB_ENDPOINTS_ONLY
            ))
        {
            do {
                //
                // only include app if it is marked as 'bad'
                //
                if (MemDbEnum.dwValue==MODULESTATUS_BAD) {
                    wsprintf(Temp, TEXT("%s=%d\r\n"), MemDbEnum.szName, OBJECTTYPE_APP);
                    WriteFileString(File, Temp);
                }
            } while (MemDbEnumNextValue (&MemDbEnum));
        }


        //
        // add CPLs in OPERATION_FILE_DISABLED
        //
        if (EnumFirstPathInOperation (&FileEnum, OPERATION_FILE_DISABLED)) {
            do {
                //
                // only include disabled CPLs (for now, thats all there is)
                //
                if (_tcsistr(FileEnum.Path, TEXT(".cpl"))) {
                    wsprintf(Temp, TEXT("%s=%d\r\n"), FileEnum.Path, OBJECTTYPE_CPL);
                    WriteFileString(File, Temp);
                }
            } while (EnumNextPathInOperation (&FileEnum));
        }

        //
        // add RunKeys that are not in COMPATIBLE_RUNKEY list
        //
        if (Key = OpenRegKeyStr (S_RUN_KEY))
        {
            if (EnumFirstRegValue(&RegEnum, Key))
            {
                do {
                    Data=GetRegValueString(Key, RegEnum.ValueName);
                    MemDbBuildKey (
                        MemDbKey,
                        MEMDB_CATEGORY_COMPATIBLE_RUNKEY,
                        Data,
                        NULL,
                        NULL
                        );

                    //
                    // only add runkey to dead.ini if it was not put
                    // in the compatible runkey memdb category.
                    // (we only want incompatible runkeys)
                    //
                    if (!MemDbGetValue(MemDbKey, NULL))
                    {
                        //
                        // we have a friendly name (ValueName)
                        // so include it in dead.ini
                        //
                        wsprintf (
                            Temp,
                            TEXT("%s=%d,%s\r\n"),
                            Data,
                            OBJECTTYPE_RUNKEY,
                            RegEnum.ValueName
                            );
                        WriteFileString(File, Temp);
                    }
                    MemFreeWrapper(Data);
                } while (EnumNextRegValue(&RegEnum));
            }

            CloseRegKey (Key);
        }

        WriteFileString(File, TEXT("\r\n"));
        CloseHandle(File);

        break;

    }

    return ERROR_SUCCESS;
}


VOID
pReportDarwinIfNotHandled (
    VOID
    )
{
    PCTSTR Group;
    PCTSTR Message;
    HKEY key;
    DWORD rc;
    DWORD subkeys;
    MSGMGROBJENUM e;

    key = OpenRegKeyStr (S_REGKEY_DARWIN_COMPONENTS);
    if (key) {

        rc = RegQueryInfoKey (key, NULL, NULL, NULL, &subkeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        if (rc == ERROR_SUCCESS && subkeys) {
            if (!IsReportObjectHandled (S_REGKEY_DARWIN_COMPONENTS)) {
                Group = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_DARWIN_NOT_HANDLED_SUBGROUP, NULL);
                Message = GetStringResource (MSG_DARWIN_NOT_HANDLED);

                if (Message && Group) {
                    MsgMgr_ObjectMsg_Add (TEXT("*DarwinNotHandled"), Group, Message);
                    //
                    // disable Outlook 2000 message
                    //
                    if (MsgMgr_EnumFirstObject (&e)) {
                        do {
                            if (StringMatch (e.Context, TEXT("Microsoft_Outlook_2000"))) {
                                HandleReportObject (e.Object);
                                break;
                            }
                        } while (MsgMgr_EnumNextObject (&e));
                    }
                }
                FreeText (Group);
                FreeStringResource (Message);
            }
        }
        CloseRegKey (key);
    }
}

DWORD
ReportDarwinIfNotHandled (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_REPORTDARWINIFNOTHANDLED;

    case REQUEST_RUN:
        pReportDarwinIfNotHandled ();
        break;
    }
    return ERROR_SUCCESS;
}


DWORD
ElevateReportObjects (
    IN DWORD Request
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR data;

    switch (Request) {
    case REQUEST_QUERYTICKS:
        return 1;
    case REQUEST_RUN:
        if (InfFindFirstLine (g_Win95UpgInf, TEXT("ShowInSimplifiedView"), NULL, &is)) {
            do {
                data = InfGetStringField (&is, 1);
                if (data) {
                    ElevateObject (data);
                }
            } while (InfFindNextLine (&is));
        }

        InfCleanUpInfStruct (&is);
        return ERROR_SUCCESS;
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in CopyStaticFiles."));
    }
    return 0;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\condmsg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    condmsg.c

Abstract:

    Win95upg.inf has a section named [Conditional Incompatibilities] where the
    lines in the section have the following syntax:

    %group%, %subgroup%, %object%, %msg% [,<function>[,<argument>]]

        %group% - A predefined root group number

        %subgroup% - A localized subgroup displayed in the UI

        %object% - The file, directory or registry location in which the message
                   is associated with

        %msg% - A localized message

        <function> - A function that determines if the message should be added to the
                     incompatible report

        <argument> - An optional string parameter that is passed to <function.>

    The code below implements the functions that are used in Win95upg.inf.

Author:

    Marc Whitten (marcw) 3-Apr-1997

Revision History:

    marcw   21-Jan-1999  Stale Beta messages removed.
    marcw   10-Sep-1997  OSR2 beta warning added.
    jimschm 06-Jul-1997  Added "object" to everything
    jimschm 25-Jun-1997  Protocols warning
    jimschm 28-May-1997  Hardware Profile warning
    marcw   25-Apr-1997  <argument> ability passed.
    jimschm 08-Apr-1997  Generalized

--*/

#include "pch.h"
#include "sysmigp.h"
#include "hwcomp.h"

//
// Function type declaration
//

typedef BOOL (TEST_FUNCTION_PROTOTYPE)(PCTSTR Object,
                                       PCTSTR GroupBase,
                                       PCTSTR Description,
                                       PCTSTR Argument
                                       );

typedef TEST_FUNCTION_PROTOTYPE * TEST_FUNCTION;

//
// Array of supported functions
//

#define FUNCTION_LIST                               \
    DECLARATION_MACRO(SysAgentExtension)            \
    DECLARATION_MACRO(ArePasswordProvidersPresent)  \
    DECLARATION_MACRO(DoesRegKeyExist)              \
    DECLARATION_MACRO(DoRegKeyValuesExist)          \
    DECLARATION_MACRO(IsWin95Osr2)                  \
    DECLARATION_MACRO(IsMSNInstalled)               \
    DECLARATION_MACRO(IsRasServerEnabled)           \
    DECLARATION_MACRO(IsDefValueEqual)              \



//
// Declare the function prototypes
//

#define DECLARATION_MACRO(x) BOOL x (PCTSTR Object,        \
                                     PCTSTR GroupBase,     \
                                     PCTSTR Description,   \
                                     PCTSTR Argument       \
                                     );

FUNCTION_LIST

#undef DECLARATION_MACRO

//
// Create a lookup array
//

typedef struct {
    PCTSTR Name;
    TEST_FUNCTION Proc;
} FUNCTION_LIST_ELEMENT,*PFUNCTION_LIST_ELEMENT;

#define DECLARATION_MACRO(x) {#x, x},

FUNCTION_LIST_ELEMENT g_TestFunctionList[] = {
    FUNCTION_LIST /*,*/
    {NULL, NULL}
};

#undef DECLARATION_MACRO


//
// Function to locate Proc given a string
//

TEST_FUNCTION
pFindTestFunction (
    IN      PCTSTR FunctionStr
    )

/*++

Routine Description:

  pFindTestFunction searches the test function table declared above for
  a specified function name and returns a pointer to the actual function
  or NULL if the function does not exist.

Arguments:

  FunctionStr - Specifies the name of function to find.

Return Value:

  A pointer to the corresponding code, or NULL if the function does not exist.

--*/

{
    INT Index;

    for (Index = 0 ; g_TestFunctionList[Index].Name ; Index++) {

        if (StringIMatch (g_TestFunctionList[Index].Name, FunctionStr)) {
            return g_TestFunctionList[Index].Proc;
        }
    }

    DEBUGMSG ((DBG_ERROR,"SysMig: %s is not a valid test function.", FunctionStr));
    return NULL;
}



PTSTR
pGetFieldUsingPool (
    IN OUT  POOLHANDLE Pool,
    IN      INFCONTEXT *pic,
    IN      INT Field
    )

/*++

Routine Description:

  This function retrieves a string field using the Setup APIs but uses
  PoolMem for allocation.

Arguments:

  Pool - Specifies a handle to a valid pool (from PoolMemInitPool).  Memory
         is allocated from this pool.

  pic - Specifies the INF section and line being queried.

  Field - Specifies the field to retrieve.

Return Value:

  A pointer to the field text, allocated in Pool, or NULL if the field was
  not found or an error is encountered.

--*/

{
    DWORD SizeNeeded;
    PTSTR String;

    if (!SetupGetStringField (pic, Field, NULL, 0, &SizeNeeded)) {
        DEBUGMSG ((DBG_ERROR, "SysMig: SetupGetStringField failed for field %u.", Field));
        return NULL;
    }

    String = PoolMemCreateString (Pool, SizeNeeded);

    if (!SetupGetStringField (pic, Field, String, SizeNeeded, NULL)) {
        DEBUGMSG ((DBG_ERROR,"SysMig: SetupGetStringField failed for field %u.", Field));
        return NULL;
    }

    return String;
}


PCTSTR
pTranslateGroupString (
    IN      POOLHANDLE AllocPool,
    IN      UINT GroupId
    )

/*++

Routine Description:

  pTranslateGroupString converts a standard group number (1-based) into a
  message ID, then loads the string resource.  The group string is then
  copied into the specified pool.

  In win95upg.txt, the list is defined as:

   1 - Hardware That Does Not Support Windows NT 5.0
   2 - General Information
   3 - Settings That Will Not Be Upgraded
   4 - Software That Does Not Support Windows NT 5.0
   5 - Software That Will Require Reinstallation
   6 - Software with Minor Incompatibilities
   7 - Software to Be Uninstalled by Setup
   8 - Upgrade Pack Information

Arguments:

  AllocPool - Specifies the pool to allocate the return string from
  GroupId   - Specifies a one-based ID that identifies the group.  The
              definition of the ID is hard-coded here.

Return Value:

  A pointer to the string, or NULL if an invalid group was specified.

--*/

{
    PCTSTR ResStr;
    PCTSTR ResSubStr;
    PTSTR ReturnStr = NULL;
    UINT SubGroupId = 0;

    switch (GroupId) {
    case 0:
        GroupId = MSG_BLOCKING_ITEMS_ROOT;
        break;

    case 1:
        GroupId = MSG_INCOMPATIBLE_HARDWARE_ROOT;
        break;

    case 2:
        GroupId = MSG_INSTALL_NOTES_ROOT;
        break;

    case 3:
        GroupId = MSG_LOSTSETTINGS_ROOT;
        break;

    case 4:
        GroupId = MSG_INCOMPATIBLE_ROOT;
        SubGroupId = MSG_INCOMPATIBLE_DETAIL_SUBGROUP;
        break;

    case 5:
        GroupId = MSG_REINSTALL_ROOT;
        SubGroupId = MSG_REINSTALL_DETAIL_SUBGROUP;
        break;

    case 6:
        GroupId = MSG_MINOR_PROBLEM_ROOT;
        break;

    case 7:
        GroupId = MSG_INCOMPATIBLE_ROOT;
        SubGroupId = MSG_AUTO_UNINSTALL_SUBGROUP;
        break;

    case 8:
        GroupId = MSG_MIGDLL_ROOT;
        break;

    default:
        return NULL;
    }

    ResStr = GetStringResource (GroupId);

    if (ResStr) {

        if (SubGroupId) {

            ResSubStr = GetStringResource (SubGroupId);

            if (ResSubStr) {

                //
                // We count the nul twice, assuming the nul is the same
                // size as a backslash.
                //

                ReturnStr = PoolMemGetAlignedMemory (
                                AllocPool,
                                SizeOfString (ResStr) + SizeOfString (ResSubStr)
                                );

                wsprintf (ReturnStr, TEXT("%s\\%s"), ResStr, ResSubStr);

                FreeStringResource (ResSubStr);
            }

        } else {

            ReturnStr = PoolMemDuplicateString (AllocPool, ResStr);

        }

        FreeStringResource (ResStr);
    }

    return ReturnStr;
}


VOID
pConditionalIncompatibilities (
    VOID
    )

/*++

Routine Description:

  Processes the Conditional Incompatibilities section of WIN95UPG.INF, and does
  other conditional incompatibility processing.  Incompatibilities are added
  via the API in w95upg\ui.

Arguments:

  none

Return Value:

  none

--*/

{
    INFCONTEXT  context;
    POOLHANDLE  aPool;
    PTSTR       descriptionString;
    PTSTR       functionString;
    PTSTR       argumentString;
    TCHAR       buffer[32];
    static INT  msgId = 0;
    PCTSTR     objectString;
    PTSTR completeString;
    TEST_FUNCTION Proc;
    PCTSTR SubGroupString;
    PCTSTR GroupString;
    UINT GroupId;
    BOOL fr;
    BOOL negate;

    aPool = PoolMemInitNamedPool ("Conditional Incompatibilities");

    if (aPool) {

        if (SetupFindFirstLine (
                g_Win95UpgInf,
                S_CONDITIONAL_INCOMPATIBILITIES,
                NULL,
                &context
                )
            ) {

            //
            // Load in the standard group name
            //

            do {
                //
                // Get the group number
                //

                GroupString = pGetFieldUsingPool (aPool, &context, 1);
                if (!GroupString) {
                    continue;
                }

                GroupId = _tcstoul (GroupString, NULL, 10);
                GroupString = pTranslateGroupString (aPool, GroupId);

                if (!GroupString) {
                    DEBUGMSG ((DBG_WHOOPS, "Invalid group ID: %u", GroupId));
                    continue;
                }

                //
                // Get the subgroup string
                //

                SubGroupString = pGetFieldUsingPool (aPool, &context, 2);
                if (!SubGroupString) {
                    DEBUGMSG ((DBG_WHOOPS, "Field 2 required in conditional message lines"));
                    continue;
                }

                if (*SubGroupString) {
                    completeString = (PTSTR) PoolMemGetMemory (
                                                aPool,
                                                SizeOfString (GroupString) +
                                                    SizeOfString (SubGroupString) +
                                                    2 * sizeof (TCHAR)
                                                );

                    StringCopy (completeString, GroupString);
                    StringCopy (AppendWack (completeString), SubGroupString);
                } else {
                    completeString = (PTSTR) GroupString;
                }

                //
                // Get the object string
                //

                objectString = pGetFieldUsingPool (aPool, &context, 3);
                if (!objectString) {
                    DEBUGMSG ((DBG_WHOOPS, "Field 3 required in conditional message lines"));
                    continue;
                }

                //
                // Get the description
                //

                descriptionString = pGetFieldUsingPool (aPool, &context, 4);
                if (!descriptionString) {
                    DEBUGMSG ((DBG_WHOOPS, "Field 4 required in conditional message lines"));
                    continue;
                }

                //
                // If the field count is greater than two, there is a
                // function string..
                //

                if (SetupGetFieldCount (&context) > 4) {

                    argumentString = NULL;

                    //
                    // Read in the functionString..
                    //

                    functionString = pGetFieldUsingPool (aPool, &context, 5);
                    if (!functionString) {
                        continue;
                    }
                    negate = *functionString == TEXT('!');
                    if (negate) {
                        functionString++;
                    }

                    if (SetupGetFieldCount(&context) > 5) {

                        //
                        // Read in the argument string.
                        //
                        argumentString = pGetFieldUsingPool(aPool,&context, 6);
                    }

                    //
                    // Find the function to call..
                    //
                    Proc = pFindTestFunction (functionString);
                    if (!Proc) {
                        continue;
                    }
                    fr = Proc (objectString, completeString, descriptionString,argumentString);
                    if (!negate && !fr || negate && fr) {
                        continue;
                    }
                }

                if (!objectString[0]) {
                    DEBUGMSG ((DBG_WARNING, "Manufacturing an object for %s message", completeString));
                    objectString = buffer;
                    msgId++;
                    wsprintf (buffer, "msg%u", msgId);
                }

                MsgMgr_ObjectMsg_Add (objectString, completeString, descriptionString);

            } while (SetupFindNextLine (&context,&context));
        }
        else {
            DEBUGMSG ((DBG_VERBOSE,"SysMig: %s not found in win95upg.inf.", S_CONDITIONAL_INCOMPATIBILITIES));
        }
    }

    PoolMemDestroyPool(aPool);
}

DWORD
ConditionalIncompatibilities (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_CONDITIONAL_INCOMPATIBILITIES;
    case REQUEST_RUN:
        pConditionalIncompatibilities ();
        return ERROR_SUCCESS;
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in ConditionalIncompatibilities"));
    }
    return 0;
}

BOOL
pIsDefaultSystemAgent (
    PCTSTR SageSubKey
    )
{
    INFCONTEXT context;

    if (SetupFindFirstLine (
            g_Win95UpgInf,
            S_SAGE_EXCLUSIONS,
            SageSubKey,
            &context
            )) {
        return TRUE;
    }

    return FALSE;
}

BOOL
SysAgentExtension (
    IN      PCTSTR Object,
    IN      PCTSTR GroupBase,
    IN      PCTSTR Description,
    IN      PCTSTR Argument
    )

/*++

Routine Description:

    Produces conditional incompatibilities based on the presense of the
    system agent extension, which is part of the Win95 plus pack but
    not supported by NT.

Arguments:

    Object        - Unused

    GroupBase     - A WIN95UPG.INF-specified group name that is used
                    as the base of the message.  The actual group name
                    stored in the registry is appended for the UI.

    Description   - A WIN95UPG.INF-specified description

    Argument      - Unused

Return Value:

    FALSE, because we add the incompatibility message ourself.

Comments:

    SAGE-aware programs declare themselves as such by creating a key in
    HKLM\Software\Microsoft\Plus!\System Agent\SAGE. The name of the key
    can be anything the program wants, but it should contain the following
    values:

    Program=        Name of the program's .EXE file. This must be the same
                    .EXE name under which the program's PerApp path is
                    registered. You may append a command line parameter
                    indicating unattended operation (see Settings=,
                    below).

    Friendly Name=  Display name that System Agent will use in populating
                    the drop-down list in its "Schedule a program" dialog
                    box.
    Settings=       1-bit binary field indicating whether program has a
                    Settings dialog box. If "Settings = "Settings = 0",
                    but the application supports an interactive mode, then
                    the "Program=" value should contain a command-line
                    parameter that tells your program it's being run by
                    SAGE, so that it knows to run in an unattended
                    fashion, for example, "DRVSPACE.EXE /noprompt" or
                    "MyApp.EXE /SAGERUN".
    Result Codes    Optional key containing a set of value pairs mapping
                    an exit code to a string describing the meaning of
                    that exit code. For example, for SCANDSKW, the
                    Result Codes key may contain a value such as:
                    0="ScanDisk completed successfully; no errors were
                    found." This is to allow SAGE to keep a
                    human-comprehensible log of the results of the
                    programs it runs. In addition to the value pairs,
                    this key should also contain a String value named
                    "Success", which indicates the highest value for an
                    exit code that designates that the program completed
                    successfully. The value names should be string
                    values, specified in decimal; the allowable range is
                    032767.

--*/

{
    REGKEY_ENUM e;
    PCTSTR Data;
    PCTSTR Module;
    TCHAR FullKey[MAX_REGISTRY_KEY];
    PCTSTR Group;
    PCTSTR FullPathKeyStr;
    PCTSTR FullPath;

    HKEY ExtensionKey;
    HKEY AppPathsKey;

    //
    // Scan HKLM\Software\Microsoft\Plus!\System Agent\SAGE for
    // subkeys, then throw messages out for each friendly name.
    //

    if (EnumFirstRegKeyStr (&e, S_SAGE)) {
        do {
            ExtensionKey = OpenRegKey (e.KeyHandle, e.SubKeyName);
            if (ExtensionKey) {
                Data = GetRegValueData (ExtensionKey, S_SAGE_FRIENDLY_NAME);
                if (Data && *Data) {
                    // Create full object string
                    wsprintf (FullKey, TEXT("%s\\%s"), S_SAGE, e.SubKeyName);

                    // Test win95upg.inf to see if this is a standard agent
                    if (!pIsDefaultSystemAgent (e.SubKeyName)) {

                        // Generate group string
                        Group = JoinPaths (GroupBase, Data);

                        // Get the full path for this EXE

                        FullPath = NULL;
                        Module = GetRegValueData (ExtensionKey, S_SAGE_PROGRAM);

                        if (Module && *Module) {

                            FullPathKeyStr = JoinPaths (S_SKEY_APP_PATHS, Module);
                            AppPathsKey = OpenRegKeyStr (FullPathKeyStr);

                            if (AppPathsKey) {
                                FullPath = GetRegValueData (AppPathsKey, S_EMPTY);
                                if (!(*FullPath)) {
                                    MemFree (g_hHeap, 0, FullPath);
                                    FullPath = NULL;
                                }
                                CloseRegKey (AppPathsKey);
                            }

                            FreePathString (FullPathKeyStr);
                            MemFree (g_hHeap, 0, Module);
                        }

                        // Add message
                        if ((!FullPath) || (!IsFileMarkedForAnnounce (FullPath))) {
                            MsgMgr_ObjectMsg_Add (FullPath?FullPath:FullKey, Group, Description);
                        }

                        // Cleanup
                        FreePathString (Group);

                        if (FullPath) {
                            MemFree (g_hHeap, 0 , FullPath);
                            FullPath = NULL;
                        }
                    }

                    MemFree (g_hHeap, 0, Data);
                }

                CloseRegKey (ExtensionKey);
            }
        } while (EnumNextRegKey (&e));
    }

    return FALSE;       // pretend like it's not installed
}



BOOL
DoesRegKeyExist (
    IN      PCTSTR Object,
    IN      PCTSTR  GroupBase,
    IN      PCTSTR  Description,
    IN      PCTSTR  Argument
    )

/*++

Routine Description:

  Returns TRUE if the registry key specified in Argument exists,
  forcing an incompatibility message to be generated.

Arguments:

  Object      - Specifies the registry key to examine

  GroupBase   - A WIN95UPG.INF-specified group name

  Description - A WIN95UPG.INF-specified description

  Argument    - Unused

Return Value:

  TRUE if the registry key exists, or FALSE if it is not.  TRUE
  forces the message to be added to the report.

--*/

{
    BOOL rKeyExists = FALSE;
    HKEY key = NULL;

    if (Object) {
        key = OpenRegKeyStr (Object);
    }


    if (key) {
        rKeyExists = TRUE;
        CloseRegKey (key);
    }

    return rKeyExists;

}


BOOL
DoRegKeyValuesExist (
    IN      PCTSTR Object,
    IN      PCTSTR GroupBase,
    IN      PCTSTR Description,
    IN      PCTSTR Argument
    )

/*++

Routine Description:

  Returns TRUE if the registry key specified in Argument exists,
  and has at least one named value, forcing an incompatibility
  message to be generated.

Arguments:

  Object      - A WIN95UPG.INF-specified registry key

  GroupBase   - A WIN95UPG.INF-specified group name

  Description - A WIN95UPG.INF-specified description

  Argument    - Unused

Return Value:

  TRUE if the registry key exists, or FALSE if it is not.  TRUE
  forces the message to be added to the report.

--*/

{
    BOOL ValuesExists = FALSE;
    HKEY key = NULL;
    REGVALUE_ENUM e;

    if (Argument) {
        key = OpenRegKeyStr (Argument);
    }


    if (key) {
        if (EnumFirstRegValue (&e, key)) {
            do {
                if (e.ValueName[0]) {
                    ValuesExists = TRUE;
                    break;
                }
            } while (EnumNextRegValue (&e));
        }

        CloseRegKey (key);
    }

    return ValuesExists;

}


BOOL
IsWin95Osr2 (
    IN      PCTSTR Object,
    IN      PCTSTR GroupBase,
    IN      PCTSTR Description,
    IN      PCTSTR Argument
    )
{

    return ISWIN95_OSR2();
}


BOOL
IsMSNInstalled (
    IN      PCTSTR Object,
    IN      PCTSTR GroupBase,
    IN      PCTSTR Description,
    IN      PCTSTR Argument
    )
{
    HKEY key = NULL;
    PCTSTR Data = NULL;
    BOOL installed = FALSE;

    if (Object) {
        key = OpenRegKeyStr (Object);
    }


    if (key) {

        Data = (PCTSTR) GetRegKeyData (key, S_EMPTY);

        if (Data) {
            if (DoesFileExist (Data)) {
                installed = TRUE;
            }
            MemFree (g_hHeap, 0, Data);
        }
        CloseRegKey (key);
    }

    //
    // Special cases
    //

    if (installed) {
        //
        // Win98 -- make sure setup GUID was deleted
        //

        key = OpenRegKeyStr (TEXT("HKLM\\Software\\Classes\\CLSID\\{4b876a40-11d1-811e-00c04fb98eec}"));

        if (key) {
            installed = FALSE;
            CloseRegKey (key);
        }
    }

    if (installed) {
        //
        // Win95 -- make sure SignUpDone flag is written
        //

        key = OpenRegKeyStr (TEXT("HKLM\\Software\\Microsoft\\MOS\\SoftwareInstalled"));

        if (key) {
            CloseRegKey (key);
        } else {
            installed = FALSE;
        }
    }

    return installed;
}


BOOL
IsRasServerEnabled (
    IN      PCTSTR Object,
    IN      PCTSTR GroupBase,
    IN      PCTSTR Description,
    IN      PCTSTR Argument
    )
{
    BOOL rAddMessage = FALSE;
    HKEY key;
    PBYTE data;

    if (!Object) {
        return FALSE;
    }


    key = OpenRegKeyStr (Object);

    if (key) {

        data = GetRegValueData (key, TEXT("Enabled"));

        if (data) {

            if ((*(PDWORD)data) == 1) {
                rAddMessage = TRUE;
            }

            MemFree (g_hHeap, 0, data);
        }

        CloseRegKey (key);
    }

    return rAddMessage;

}


BOOL
ArePasswordProvidersPresent (
    IN      PCTSTR Object,
    IN      PCTSTR GroupBase,
    IN      PCTSTR Description,
    IN      PCTSTR Argument
    )

/*++

Routine Description:

  Adds incompatibility messages for all password providers, excluding
  password providers of known components such as the Microsoft
  Networking Client or the Microsoft Client for NetWare.

Arguments:

  Object      - Unused

  GroupBase   - A WIN95UPG.INF-specified group name

  Description - A WIN95UPG.INF-specified description

  Argument    - Unused

Return Value:

  Always FALSE.

--*/

{
    REGKEY_ENUM e;
    PCTSTR     data;
    HKEY        key;
    INFCONTEXT  ic;
    TCHAR       FullKey[MAX_REGISTRY_KEY];
    PCTSTR      FullGroup;
    PCTSTR      IncompatibleSoftware;

    IncompatibleSoftware = GetStringResource (MSG_INCOMPATIBLE_ROOT);
    if (!IncompatibleSoftware) {
        return FALSE;
    }

    if (EnumFirstRegKeyStr (&e, S_PASSWORDPROVIDER)) {
        do {

            //
            // See if this is a known password provider.
            //

            if (SetupFindFirstLine (
                    g_Win95UpgInf,
                    S_SUPPORTED_PASSWORD_PROVIDERS,
                    e.SubKeyName,
                    &ic
                    )) {
                continue;
            }

            //
            // This is an unsupported password provider key. Add a message.
            //
            key = OpenRegKey (e.KeyHandle, e.SubKeyName);
            if (key) {
                data = GetRegValueData (key, S_PASSWORDPROVIDER_DESCRIPTION);
                if (data) {
                    wsprintf (FullKey, TEXT("%s\\%s"), S_PASSWORDPROVIDER, e.SubKeyName);
                    FullGroup = JoinPaths (IncompatibleSoftware, data);

                    MsgMgr_ObjectMsg_Add(
                        FullKey,            // Object name
                        FullGroup,      // Message title
                        Description         // Message text
                        );

                    FreePathString (FullGroup);

                    MemFree (g_hHeap, 0, data);
                }

                CloseRegKey (key);
            }
        } while (EnumNextRegKey (&e));
    }

    FreeStringResource (IncompatibleSoftware);


    //
    // Since we build the message ourselves, just return FALSE. This will
    // keep the ConditionalMessage function from adding this twice.
    //
    return FALSE;
}

BOOL
IsDefValueEqual (
    IN      PCTSTR Object,
    IN      PCTSTR GroupBase,
    IN      PCTSTR Description,
    IN      PCTSTR Argument
    )
{
    HKEY key = NULL;
    PCTSTR Data = NULL;
    BOOL equal = FALSE;

    if (Object) {
        key = OpenRegKeyStr (Object);
    }

    if (key) {

        Data = (PCTSTR) GetRegKeyData (key, S_EMPTY);

        if (Data) {
            if (StringIMatch (Data, Argument)) {
                equal = TRUE;
            }
            MemFree (g_hHeap, 0, Data);
        }
        CloseRegKey (key);
    }

    return equal;
}



VOID
pHardwareProfileWarning (
    VOID
    )

/*++

Routine Description:

  Produces incompatibility messages for all hardware profiles that
  have different hardware configurations.  The upgrade cannot maintain
  the list of disabled hardware in a hardware profile, so a warning
  is generated.

Arguments:

  none

Return Value:

  none

--*/

{
    REGKEY_ENUM e;
    REGKEY_ENUM e2;
    HKEY ProfileKey;
    HKEY EnumKey;
    HKEY ConfigDbKey;
    DWORD Config;
    TCHAR FriendlyName[MAX_PATH];
    PCTSTR MsgGroup;
    PCTSTR RootGroup;
    PCTSTR HwProfiles;
    PCTSTR Data;
    TCHAR FullKey[MAX_REGISTRY_KEY];
    UINT Profiles;

    //
    // How many hardware profiles?  If just one, don't give a warning.
    //

    Profiles = 0;
    if (EnumFirstRegKeyStr (&e, S_CONFIG_KEY)) {
        do {
            Profiles++;
        } while (EnumNextRegKey (&e));
    }

    if (Profiles < 2) {
        DEBUGMSG ((DBG_VERBOSE, "Hardware profiles: %u, suppressed all warnings", Profiles));
        return;
    }

    //
    // Enumerate the hardware profiles in HKLM\Config
    //

    if (EnumFirstRegKeyStr (&e, S_CONFIG_KEY)) {
        do {
            //
            // Determine if profile has an Enum key
            //

            ProfileKey = OpenRegKey (e.KeyHandle, e.SubKeyName);

            if (ProfileKey) {
                EnumKey = OpenRegKey (ProfileKey, S_ENUM_SUBKEY);

                if (EnumKey) {
                    //
                    // Determine if Enum key is empty
                    //

                    if (EnumFirstRegKey (&e2, EnumKey)) {
                        AbortRegKeyEnum (&e2);

                        //
                        // Obtain friendly name for config
                        //

                        ConfigDbKey = OpenRegKeyStr (S_FRIENDLYNAME_KEY);
                        if (ConfigDbKey) {

                            Config = _ttoi (e.SubKeyName);

                            wsprintf (FriendlyName, S_FRIENDLYNAME_SPRINTF, Config);

                            Data = GetRegValueData (ConfigDbKey, FriendlyName);
                            if (Data) {
                                //
                                // Put message in incompatibility report
                                //
                                wsprintf (FullKey, TEXT("%s\\%s"), S_CONFIG_KEY, e.SubKeyName);

                                //
                                // Generate Msg and MsgGroup
                                //

                                RootGroup = GetStringResource (MSG_INSTALL_NOTES_ROOT);
                                MYASSERT (RootGroup);

                                HwProfiles = GetStringResource (MSG_HWPROFILES_SUBGROUP);
                                MYASSERT (HwProfiles);

                                MsgGroup = JoinPaths (RootGroup, HwProfiles);
                                MYASSERT (MsgGroup);

                                FreeStringResource (RootGroup);
                                FreeStringResource (HwProfiles);

                                RootGroup = MsgGroup;
                                MsgGroup = JoinPaths (RootGroup, Data);
                                MYASSERT (MsgGroup);

                                FreePathString (RootGroup);

                                //
                                // Add the message and clean up
                                //

                                MsgMgr_ObjectMsg_Add (FullKey, MsgGroup, S_EMPTY);

                                FreePathString (MsgGroup);
                                MemFree (g_hHeap, 0, Data);
                            }
                            ELSE_DEBUGMSG ((DBG_ERROR, "Hardware profile lacks friendly name"));


                            CloseRegKey (ConfigDbKey);
                        }
                        ELSE_DEBUGMSG ((DBG_ERROR, "Hardware profile lacks config DB key"));

                        if (!ConfigDbKey) {
                            LOG ((LOG_ERROR, "Hardware profile lacks config DB key"));
                        }
                    }

                    CloseRegKey (EnumKey);
                }
                CloseRegKey (ProfileKey);
            }

        } while (EnumNextRegKey (&e));
    }
}


DWORD
HardwareProfileWarning (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_HARDWARE_PROFILE_WARNING;
    case REQUEST_RUN:
        pHardwareProfileWarning ();
        return ERROR_SUCCESS;
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in HardwareProfileWarning"));
    }
    return 0;
}


VOID
pUnsupportedProtocolsWarning (
    VOID
    )

/*++

Routine Description:

  Produces incompatibility messages for network protocols that
  do not ship with equivalent versions on NT.

Arguments:

  none

Return Value:

  none

--*/

{
    PCTSTR NetworkProtocols;
    PCTSTR Message;
    PCTSTR ArgArray[2];
    REGKEY_ENUM e;
    HKEY ProtocolKey, BindingKey, DriverKey;
    REGKEY_ENUM ProtocolEnum;
    INFCONTEXT ic;
    PCTSTR Driver, DriverDesc, Mfg;
    DWORD MsgId;
    TCHAR DriverKeyStr[MAX_REGISTRY_KEY];
    TCHAR FullKey[MAX_REGISTRY_KEY];

    //
    // Enumerate the HKLM\Enum\Network key
    //

    if (EnumFirstRegKeyStr (&e, S_ENUM_NETWORK_KEY)) {
        do {
            //
            // Check win95upg.inf to see if the network protocol is known
            //

            if (SetupFindFirstLine (
                    g_Win95UpgInf,
                    S_SUPPORTED_PROTOCOLS,
                    e.SubKeyName,
                    &ic
                    )) {
                // It is, skip to next protocol
                continue;
            }

            //
            // A warning message must be generated.  We must take the first
            // subkey of the protocol, query its Driver value, and look up
            // the DriverDesc in HKLM\System\CCS\Services\Class\<driver>.
            //

            ProtocolKey = OpenRegKey (e.KeyHandle, e.SubKeyName);

            if (ProtocolKey) {
                if (EnumFirstRegKey (&ProtocolEnum, ProtocolKey)) {
                    BindingKey = OpenRegKey (ProtocolKey, ProtocolEnum.SubKeyName);
                    if (BindingKey) {
                        Driver = (PCTSTR) GetRegValueDataOfType (
                                                BindingKey,
                                                S_DRIVER,
                                                REG_SZ
                                                );
                        if (Driver) {
                            //
                            // We now know the driver... let's get the
                            // driver description.
                            //

                            wsprintf (DriverKeyStr, S_CLASS_KEY TEXT("\\%s"), Driver);
                            MemFree (g_hHeap, 0, Driver);

                            DriverKey = OpenRegKeyStr (DriverKeyStr);
                            if (DriverKey) {
                                DriverDesc = (PCTSTR) GetRegValueDataOfType (
                                                            DriverKey,
                                                            S_DRIVERDESC,
                                                            REG_SZ
                                                            );

                                if (DriverDesc) {
                                    //
                                    // Obtain the manufacturer for use in message.
                                    // If the manufacturer is not known, display
                                    // a generic message.
                                    //

                                    Mfg = (PCTSTR) GetRegValueDataOfType (
                                                        BindingKey,
                                                        S_MFG,
                                                        REG_SZ
                                                        );

                                    if (!Mfg) {
                                        MsgId = MSG_UNSUPPORTED_PROTOCOL;
                                    } else {
                                        MsgId = MSG_UNSUPPORTED_PROTOCOL_KNOWN_MFG;
                                    }

                                    ArgArray[0] = DriverDesc;
                                    ArgArray[1] = Mfg;

                                    NetworkProtocols = ParseMessageID (MSG_NETWORK_PROTOCOLS, ArgArray);

                                    if(Mfg && StringIMatch(Mfg, TEXT("Microsoft"))){
                                        Message = ParseMessageID (MSG_UNSUPPORTED_PROTOCOL_FROM_MICROSOFT, ArgArray);
                                    }
                                    else {
                                        Message = ParseMessageID (MsgId, ArgArray);
                                    }

                                    MYASSERT (NetworkProtocols && Message);

                                    wsprintf (FullKey, TEXT("%s\\%s"), S_ENUM_NETWORK_KEY, e.SubKeyName);

                                    MsgMgr_ObjectMsg_Add (FullKey, NetworkProtocols, Message);

                                    if (Mfg) {
                                        MemFree (g_hHeap, 0, Mfg);
                                    }

                                    MemFree (g_hHeap, 0, DriverDesc);
                                }
                            }

                            CloseRegKey (DriverKey);
                        }

                        CloseRegKey (BindingKey);
                    }
                }

                CloseRegKey (ProtocolKey);
            }
        } while (EnumNextRegKey (&e));
    }
}


DWORD
UnsupportedProtocolsWarning (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_UNSUPPORTED_PROTOCOLS_WARNING;
    case REQUEST_RUN:
        pUnsupportedProtocolsWarning ();
        return ERROR_SUCCESS;
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in UnsupportedProtocolWarning"));
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\drives.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    drives.c

Abstract:

    Implements apis for managing accessible drives (Drives that are usable both on win9x
    side an NT side) and for managing the space on those drives.

Author:

    Marc R. Whitten (marcw)     03-Jul-1997

Revision History:

    marcw       16-Sep-1998 Revamped disk space usage.
    marcw       04-Dec-1997 Don't warn the user about obvious things (CD-Roms and
                            Floppys not migrating..)

--*/

#include "pch.h"
#include "sysmigp.h"
#include "drives.h"
//#include "..\migapp\maioctl.h"


/*
    The following APIs are defined in this file.

    InitAccessibleDrives()
    CleanUpAccessibleDrives()
    GetFirstAccessibleDriveEx()
    GetNextAccessibleDrive()

    QuerySpace()
    UseSpace()
    FindSpace()
    OutOfSpaceMsg()
*/

#define MAX_DRIVE_STRING MAX_PATH
#define MAX_VOLUME_NAME  MAX_PATH
#define MAX_FILE_SYSTEM_NAME MAX_PATH
#define DBG_ACCESSIBLE_DRIVES "Drives"

//
// Win95Upg uninstall paramters
//

#define S_COMPRESSIONFACTOR         TEXT("CompressionFactor")
#define S_BOOTCABIMAGEPADDING       TEXT("BootCabImagePadding")
#define S_BACKUPDISKSPACEPADDING    TEXT("BackupDiskSpacePadding")


typedef struct _ACCESSIBLE_DRIVES {

    DWORD                       Count;
    ACCESSIBLE_DRIVE_ENUM       Head;
    ACCESSIBLE_DRIVE_ENUM       Tail;

} ACCESSIBLE_DRIVES, *PACCESSIBLE_DRIVES;



#define MAX_NUM_DRIVES  26

UINT g_DriveTypes [MAX_NUM_DRIVES];
ULARGE_INTEGER g_SpaceNeededForSlowBackup = {0, 0};
ULARGE_INTEGER g_SpaceNeededForFastBackup = {0, 0};
ULARGE_INTEGER g_SpaceNeededForUpgrade = {0, 0};

//
// List of accessible drives.
//
ACCESSIBLE_DRIVES g_AccessibleDrives;
DWORD             g_ExclusionValue = 0;
TCHAR             g_ExclusionValueString[20];
POOLHANDLE        g_DrivePool;
PCTSTR            g_NotEnoughSpaceMessage = NULL;

BOOL g_NotEnoughDiskSpace;
LONGLONG g_OriginalDiskSpace = 0l;

LONGLONG
pRoundToNearestCluster (
    IN LONGLONG Space,
    IN UINT ClusterSize
    )

/*++

Routine Description:

  This routine performs the correct rounding to the nearest cluster, given an
  amount of space in bytes and a cluster size.

Arguments:

  Space       - Contains the number of bytes to be rounded.
  ClusterSize - Contains the size in bytes of a cluster on the disk.

Return Value:

  the number of bytes rounded to the next cluster.

--*/


{
    LONGLONG rRoundedSize;

    if (Space % ClusterSize) {

        rRoundedSize = Space + (ClusterSize - (Space % ClusterSize));

    } else {

        rRoundedSize = Space;
    }

    return rRoundedSize;
}


BOOL
IsDriveExcluded (
    IN PCTSTR DriveOrPath
    )
/*++

Routine Description:

    This routine tests whether a specified drive is excluded in memdb.

Arguments:

    DriveOrPath - Contains the path in question (e.g. "c:\")

Return Value:

    TRUE if the drive is found in the exclusion list in memdb, FALSE otherwise.

--*/
{
    TCHAR   key[MEMDB_MAX];
    PSTR    drive;
    BOOL    rDriveIsExcluded = FALSE;
    TCHAR   rootDir[] = TEXT("?:\\");

    rootDir[0] = DriveOrPath[0];

    MemDbBuildKey(
        key,
        MEMDB_CATEGORY_FILEENUM,
        g_ExclusionValueString,
        MEMDB_FIELD_FE_PATHS,
        rootDir
        );

    rDriveIsExcluded = MemDbGetValue (key, NULL);

    if (!rDriveIsExcluded) {
        drive = JoinPaths (rootDir, TEXT("*"));
        MemDbBuildKey(
            key,
            MEMDB_CATEGORY_FILEENUM,
            g_ExclusionValueString,
            MEMDB_FIELD_FE_PATHS,
            drive
            );

        FreePathString(drive);
        rDriveIsExcluded = MemDbGetValue (key, NULL);
    }

    return rDriveIsExcluded;
}



BOOL
pBuildInitialExclusionsList (
    VOID
    )

/*++

Routine Description:

    This routine is responsible for constructing the initial exclusion list in memdb.
    This list will contain the contents of the exclude.inf file if it exists.

    As a side effect, the g_ExclusionValue and g_ExclusionValueString global variables
    will be initialized.

Arguments:

    None.

Return Value:

    TRUE if the exclusion list was successfully built, FALSE otherwise.

--*/
{
    BOOL rSuccess = TRUE;
    EXCLUDEINF excludeInf;
    TCHAR excludeInfPath[] = TEXT("?:\\exclude.inf");

    //
    // Fill in exclude inf structre.
    //
    excludeInfPath[0] = g_BootDriveLetter;

    excludeInf.ExclusionInfPath = excludeInfPath;
    excludeInf.PathSection = TEXT("Paths");
    excludeInf.FileSection = TEXT("Files");

    //
    // Build a enumeration ID for the exclude.inf.
    //
    g_ExclusionValue = GenerateEnumID();
    wsprintf(g_ExclusionValueString,TEXT("%X"),g_ExclusionValue);

    if (DoesFileExist (excludeInf.ExclusionInfPath)) {
        rSuccess = BuildExclusionsFromInf(g_ExclusionValue,&excludeInf);
    }
    ELSE_DEBUGMSG((DBG_VERBOSE,"No exclude.inf file. There are no initial exclusions."));


    return rSuccess;
}





BOOL
pFindDrive (
    IN  PCTSTR DriveString,
    OUT PACCESSIBLE_DRIVE_ENUM AccessibleDriveEnum
    )
/*++

Routine Description:

    This private routine searches the internal list of accessible drives looking for the specified
    drive.

Arguments:

    DriveString         - Contains the root directory of the drive in question. (e.g. "c:\").
                          May contain a complete path. This routine will only use the first
                          three characters while searching.

    AccessibleDriveEnum - Receives the ACCESSIBLE_DRIVE_ENUM structure associated with the
                          drive if it is found.

Return Value:

    TRUE if the drive was found in the list, FALSE otherwise.

--*/
{
    BOOL    rFound = FALSE;

    //
    // Enumerate the list of drives, looking for the specified drive.
    //
    if (GetFirstAccessibleDrive(AccessibleDriveEnum)) {
        do {

            if (StringIMatchCharCount (DriveString,(*AccessibleDriveEnum)->Drive,3)) {
                rFound = TRUE;
                break;
            }

        } while(GetNextAccessibleDrive(AccessibleDriveEnum));
    }

    return rFound;
}





BOOL
pAddAccessibleDrive (
    IN PTSTR Drive
    )
/*++

Routine Description:

    pAddAccessibleDrive is a private routine to add a drive to the list of accessible drives.
    It is responsible for creation and initialization of the ACCESSIBLE_DRIVE_ENUM structure
    for the drive and for linking that structure into the list.

Arguments:

    Drive - Contains the root directory of the drive to add.

Return Value:

    TRUE if the drive was successfully added to the list, FALSE otherwise.

--*/
{
    BOOL                    rSuccess = TRUE;
    ACCESSIBLE_DRIVE_ENUM   newDrive = NULL;
    DWORD                   SectorsPerCluster;
    DWORD                   BytesPerSector;
    ULARGE_INTEGER          FreeClusters = {0, 0};
    ULARGE_INTEGER          TotalClusters = {0, 0};


    //
    // Create the list node for this drive.
    //
    newDrive = PoolMemGetMemory(g_DrivePool,sizeof(struct _ACCESSIBLE_DRIVE_ENUM));
    ZeroMemory(newDrive, sizeof(struct _ACCESSIBLE_DRIVE_ENUM));



    //
    // Copy the drive string for this drive.
    //
    if (rSuccess) {

        newDrive -> Drive = PoolMemDuplicateString(g_DrivePool,Drive);
    }


    //
    // Get the free space for this drive.
    //
    if (rSuccess) {

        if (GetDiskFreeSpaceNew (
                Drive,
                &SectorsPerCluster,
                &BytesPerSector,
                &FreeClusters,
                &TotalClusters
                )) {


            //
            // Initialize our count of the usable space for this drive.
            //
            newDrive -> UsableSpace =
                (LONGLONG) SectorsPerCluster * (LONGLONG) BytesPerSector * FreeClusters.QuadPart;

            //
            //  Save the cluster size for this drive.
            //
            newDrive -> ClusterSize = BytesPerSector * SectorsPerCluster;

            //
            // also set the flag indicating if this is the system drive
            //
            MYASSERT (g_WinDir && g_WinDir[0]);
            newDrive -> SystemDrive = toupper (newDrive->Drive[0]) == toupper (g_WinDir[0]);
        }
        else {

            LOG((LOG_ERROR,"Could not retrieve disk space for drive %s.",Drive));
            rSuccess = FALSE;

        }
    }

    //
    // Finally, link this into the list and update the count of accessible drives.
    //
    newDrive -> Next = NULL;
    if (g_AccessibleDrives.Tail) {
        g_AccessibleDrives.Tail -> Next = newDrive;
    }
    else {
        g_AccessibleDrives.Head = newDrive;
    }

    g_AccessibleDrives.Tail = newDrive;

    g_AccessibleDrives.Count++;

    DEBUGMSG_IF((rSuccess,DBG_ACCESSIBLE_DRIVES,"Accessible Drive %s added to list.",Drive));

    return rSuccess;
}


/*++

Routine Description:

    This private routine is responsible for excluding a drive from migration. This involves
    addding an incompatibility message for the drive and also adding that drive to the
    exclusion list in MEMDB.

Arguments:

    Drive - Contains the root directory of the drive to exclude from migration.
    MsgId - Contains a Message Resource ID for the message to add to the incompatibility message.
            The message will be processed by ParseMessageID and will be passed Drive as an
            argument. If zero, no message will be displayed to the user.

Return Value:

    None.

--*/
VOID
pExcludeDrive (
    IN PTSTR Drive,
    IN DWORD MsgId  OPTIONAL
    )
{
    PCTSTR excludedDriveGroup       = NULL;
    PCTSTR excludedDriveArgs[2];
    PCTSTR excludeString            = NULL;

    if (MsgId) {
        //
        // Fill in the argument array for the excluded drive component string.
        //
        excludedDriveArgs[0] = Drive;
        excludedDriveArgs[1] = NULL;



        excludedDriveGroup = BuildMessageGroup (
                                 MSG_INSTALL_NOTES_ROOT,
                                 MsgId,
                                 Drive
                                 );

        if (excludedDriveGroup) {
            //
            // Report to the user that this drive will not be accessible during migration.
            //
            MsgMgr_ObjectMsg_Add(
                Drive,
                excludedDriveGroup,
                S_EMPTY
                );

            FreeText (excludedDriveGroup);
        }
    }
    //
    // Note it in the debug log as well.
    //
    DEBUGMSG((
        DBG_ACCESSIBLE_DRIVES,
        "The Drive %s will be excluded from migration.\n\tReason: %s",
        Drive,
        S_EMPTY
        ));


    //
    // Now, add the drive to the excluded paths.
    //
    excludeString = JoinPaths(Drive,TEXT("*"));
    ExcludePath(g_ExclusionValue,excludeString);
    FreePathString(excludeString);

}


BOOL
pGetAccessibleDrives (
    VOID
    )
/*++

Routine Description:

    This routine is the private worker routine that attempts to build in the list of accessible
    drives. It searches through all drive strings returned through GetLogicalDriveStrings()
    and applies various tests to them to determine wether they are accessible or not.
    Accessible drives are added to the list of accessible drives while non-accessible drives
    are excluded from migration.

Arguments:

    None.

Return Value:

    TRUE if the list was successfully built, FALSE otherwise.

--*/
{
    BOOL    rSuccess = TRUE;
    TCHAR   drivesString[MAX_DRIVE_STRING];
    PTSTR   curDrive;
    DWORD   rc;
    TCHAR   volumeName[MAX_VOLUME_NAME];
    TCHAR   systemNameBuffer[MAX_FILE_SYSTEM_NAME];
    DWORD   volumeSerialNumber;
    DWORD   maximumComponentLength;
    DWORD   fileSystemFlags;
    BOOL    remoteDrive;
    BOOL    substitutedDrive;
    DWORD   driveType;
    UINT    Count;
    UINT    u;
    MULTISZ_ENUM e;

    //
    // Add user-supplied drives to the list
    //

    if (g_ConfigOptions.ReportOnly) {
        if (EnumFirstMultiSz (&e, g_ConfigOptions.ScanDrives)) {
            do {
                curDrive = (PTSTR) e.CurrentString;

                if (_istalpha(*curDrive) && *(curDrive + 1) == TEXT(':')) {
                    pAddAccessibleDrive (curDrive);
                }
            } while (EnumNextMultiSz (&e));
        }
    }

    //
    // Get the list of drives on the system.
    //
    rc = GetLogicalDriveStrings(MAX_DRIVE_STRING,drivesString);

    if (rc == 0 || rc > MAX_DRIVE_STRING) {
        LOG((LOG_ERROR,"Could not build list of accessible drives. GetLogicalDriveStrings failed."));
        rSuccess = FALSE;
    }
    else {

        for (curDrive = drivesString;*curDrive;curDrive = GetEndOfString (curDrive) + 1) {

            if (!SafeModeActionCrashed (SAFEMODEID_DRIVE, curDrive)) {

                SafeModeRegisterAction(SAFEMODEID_DRIVE, curDrive);

                __try {

                    //
                    // Test cancel
                    //
                    if (*g_CancelFlagPtr) {
                        __leave;
                    }

                    //
                    // ensure that the drive is not excluded in the exclude.inf.
                    //
                    if (IsDriveExcluded (curDrive)) {
                        pExcludeDrive(curDrive,MSG_DRIVE_EXCLUDED_SUBGROUP);
                        __leave;
                    }

                    if (!GetVolumeInformation (
                            curDrive,
                            volumeName,
                            MAX_VOLUME_NAME,
                            &volumeSerialNumber,
                            &maximumComponentLength,
                            &fileSystemFlags,
                            systemNameBuffer,
                            MAX_FILE_SYSTEM_NAME
                            )) {

                            pExcludeDrive(curDrive,0);
                            __leave;
                    }


                    //
                    // GetVolumeInformation succeeded, now, determine if this drive will be accessible.
                    //

                    //
                    // Skip drives that are compressed
                    //
                    if (fileSystemFlags & FS_VOL_IS_COMPRESSED)
                    {
                        pExcludeDrive(curDrive, MSG_DRIVE_INACCESSIBLE_SUBGROUP);
                        __leave;
                    }

                    driveType = GetDriveType(curDrive);

                    OurSetDriveType (toupper(_mbsnextc(curDrive)), driveType);

                    //
                    // Skip cdroms.
                    //
                    if (driveType == DRIVE_CDROM) {
                        //
                        // Is this drive the same as a local source drive?
                        //

                        Count = SOURCEDIRECTORYCOUNT();
                        for (u = 0 ; u < Count ; u++) {
                            if (_tcsnextc (SOURCEDIRECTORY(u)) == (CHARTYPE) curDrive) {
                                break;
                            }
                        }

                        if (u == Count) {
                            pExcludeDrive(curDrive,0);
                        }

                        __leave;
                    }

                    //
                    // Skip ramdisks.
                    //
                    if (driveType == DRIVE_RAMDISK)
                    {
                        pExcludeDrive(curDrive,MSG_DRIVE_RAM_SUBGROUP);
                        __leave;
                    }

                    //
                    // Skip any drive that does not begin "<alpha>:" (i.e. UNC drives.)
                    //
                    if (*curDrive == TEXT('\\') || !_istalpha(*curDrive) || *(curDrive + 1) != TEXT(':')) {

                        pExcludeDrive(curDrive,MSG_DRIVE_INACCESSIBLE_SUBGROUP);
                        __leave;
                    }

                    //
                    // Skip floppy drives.
                    //
                    if (IsFloppyDrive(toupper(*curDrive) - TEXT('A') + 1)) {
                        __leave;
                    }

                    //
                    // Skip drive if it is substituted or remote.
                    //
                    if (!IsDriveRemoteOrSubstituted(
                            toupper(*curDrive) - TEXT('A') + 1,
                            &remoteDrive,
                            &substitutedDrive
                            )) {

                        //
                        // Special cases: ignore floppy drives and boot drive
                        //
                        if (ISPC98()) {
                            if (IsFloppyDrive(toupper(*curDrive) - TEXT('A') + 1)) {
                                __leave;
                            }
                            if (toupper (*curDrive) == g_BootDriveLetter) {
                                __leave;
                            }
                        } else {
                            if (toupper (*curDrive) == TEXT('A') ||
                                toupper (*curDrive) == TEXT('C')
                                ) {
                                __leave;
                            }
                        }

                        pExcludeDrive(curDrive,MSG_DRIVE_INACCESSIBLE_SUBGROUP);
                        __leave;
                    }

                    if (remoteDrive) {
                        pExcludeDrive(curDrive,MSG_DRIVE_NETWORK_SUBGROUP);
                        __leave;
                    }

                    if (substitutedDrive) {
                        pExcludeDrive(curDrive,MSG_DRIVE_SUBST_SUBGROUP);
                        __leave;
                    }

                    //
                    // If we have gotten to this point, then this drive is accessible. Add it to our list.
                    //
                    if (!pAddAccessibleDrive(curDrive)) {
                        pExcludeDrive(curDrive,MSG_DRIVE_INACCESSIBLE_SUBGROUP);
                    }

                }
                __finally {
                }

                SafeModeUnregisterAction();

            } else {

                pExcludeDrive(curDrive, MSG_DRIVE_INACCESSIBLE_SUBGROUP);
            }

            if (*g_CancelFlagPtr) {
                rSuccess = FALSE;
                DEBUGMSG((DBG_VERBOSE, "Cancel flag is set. Accessible drives not initialized."));
                break;
            }
        }
    }

    return rSuccess;
}


BOOL
InitAccessibleDrives (
    VOID
    )
/*++

Routine Description:

    Init accessible drives is responsible for building the list of
    accessible drives and for determining the amount of free space
    on them.

Arguments:

    None.

Return Value:

    TRUE if initialization succeeded, FALSE otherwise.

--*/

{

    BOOL rSuccess = TRUE;

    //
    // Zero out the accessible drive structure.
    //
    ZeroMemory(&g_AccessibleDrives, sizeof(ACCESSIBLE_DRIVES));


    //
    // Initialize our pool memory.
    //
    g_DrivePool = PoolMemInitNamedPool ("Drive Pool");

    //
    // Disable tracking on this pool.
    //
    PoolMemDisableTracking (g_DrivePool);


    //
    //
    // Build the exclusion list.
    //
    if (!pBuildInitialExclusionsList()) {
        rSuccess = FALSE;
        LOG ((LOG_ERROR, (PCSTR)MSG_ERROR_UNEXPECTED_ACCESSIBLE_DRIVES));
    }

    //
    // Get the list of accessible drives.
    //
    else if(!pGetAccessibleDrives()) {
        rSuccess = FALSE;
        LOG ((LOG_ERROR,(PCSTR)MSG_ERROR_UNEXPECTED_ACCESSIBLE_DRIVES));

    } else if(g_AccessibleDrives.Count == 0) {

        //
        // If there are no accessible drives, then, we fail, except that we will allow
        // the NOFEAR option to disable this--in the checked build.
        //
#ifdef DEBUG
        if (!g_ConfigOptions.NoFear) {
#endif DEBUG

            rSuccess = FALSE;
#ifdef DEBUG
        }
#endif
        LOG ((LOG_ERROR, (PCSTR)MSG_NO_ACCESSIBLE_DRIVES_POPUP));
    }

#ifdef DEBUG
    //
    // Dump the accessible drive list to the log if this is the debug version.
    //
    else {
        ACCESSIBLE_DRIVE_ENUM e;
        if (GetFirstAccessibleDrive(&e)) {
            do {
                DEBUGMSG((
                    DBG_ACCESSIBLE_DRIVES,
                    "Drive %s has %I64u free space. %s",
                    e->Drive,
                    e->UsableSpace,
                    ((DWORD) (toupper(*(e->Drive)) - TEXT('A')) == *g_LocalSourceDrive) ? "This is the LS drive." : ""
                    ));
            } while (GetNextAccessibleDrive(&e));
        }
    }
#endif
    return rSuccess;
}



VOID
CleanUpAccessibleDrives (
    VOID
    )
/*++

Routine Description:

    CleanUpAccessibleDrives is a simple clean up routine.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Nothing to do except clean up our pool memory.
    //
    if (g_DrivePool) {
        PoolMemDestroyPool(g_DrivePool);
    }

    FreeStringResource (g_NotEnoughSpaceMessage);
    g_NotEnoughSpaceMessage = NULL;
}

/*++

Routine Description:

    GetFirstAccessibleDriveEx and GetNextAccessibleDrive are the two enumerator routines for the
    list of accessible drives.


Arguments:

    AccessibleDriveEnum - Recieves an updated ACCESSIBLE_DRIVE_ENUM structure containing the
                          information for the current drive in the enumeration.

Return Value:

    TRUE if the enumeration operation succeeded (i.e. there are more drives to enumerate)
    FALSE otherwise.

--*/
BOOL
GetFirstAccessibleDriveEx (
    OUT PACCESSIBLE_DRIVE_ENUM AccessibleDriveEnum,
    IN  BOOL SystemDriveOnly
    )

{
    *AccessibleDriveEnum = g_AccessibleDrives.Head;
    if (!*AccessibleDriveEnum) {
        return FALSE;
    }

    (*AccessibleDriveEnum)->EnumSystemDriveOnly = SystemDriveOnly;
    if (!SystemDriveOnly || (*AccessibleDriveEnum)->SystemDrive) {
        return TRUE;
    }
    return GetNextAccessibleDrive (AccessibleDriveEnum);
}


BOOL
GetNextAccessibleDrive (
    IN OUT PACCESSIBLE_DRIVE_ENUM AccessibleDriveEnum
    )
{
    BOOL bEnumSystemDriveOnly;
    while (*AccessibleDriveEnum) {
        bEnumSystemDriveOnly = (*AccessibleDriveEnum)->EnumSystemDriveOnly;
        *AccessibleDriveEnum = (*AccessibleDriveEnum) -> Next;
        if (*AccessibleDriveEnum) {
            (*AccessibleDriveEnum)->EnumSystemDriveOnly = bEnumSystemDriveOnly;
            if (!bEnumSystemDriveOnly || (*AccessibleDriveEnum)->SystemDrive) {
                break;
            }
        }
    }

    return *AccessibleDriveEnum != NULL;
}


BOOL
IsDriveAccessible (
    IN PCTSTR DriveString
    )
/*++

Routine Description:

    IsDriveAccessible tests wether the provided drive is in the accessible list. Note that
    only the first three characters of the DriveString will be used to determine if the
    drive is accessible so a complete path can be passed into this routine. (Thus determining
    wether that path is on an accessible drive.)


Arguments:

    DriveString - Contains the root path of the drive in question. May contain extra information
                  also, Only the first three characters are relevant.

Return Value:

    TRUE if the drive is in the accessible drives list, FALSE otherwise.

--*/
{
    ACCESSIBLE_DRIVE_ENUM e;

    return pFindDrive(DriveString,&e);
}


UINT
QueryClusterSize (
    IN      PCTSTR DriveString
    )
/*++

Routine Description:

    QueryClusterSize returns the cluster size for a particular drive.

Arguments:

    DriveString - Contains the root path of the drive in question. May contain extra information
                  also, Only the first three characters are relevant.

Return Value:

    a UINT value representing the cluster size for this drive.

--*/
{
    UINT cSize = 0;
    ACCESSIBLE_DRIVE_ENUM e;

    if (pFindDrive(DriveString,&e)) {
        cSize = e -> ClusterSize;
    }
    ELSE_DEBUGMSG((DBG_ACCESSIBLE_DRIVES,"QueryClusterSize: %s is not in the list of accessible drives.",DriveString));

    return cSize;
}


LONGLONG
QuerySpace (
    IN PCTSTR DriveString
    )
/*++

Routine Description:

    QuerySpace returns the number of bytes available on a particular drive. Note that this
    number may be different than that returned by a call to GetDiskFreeSpace.

    The value returned by this function will include any space committed by setup but not
    actually used yet.


Arguments:

    DriveString - Contains the root path of the drive in question. May contain extra information
                  also, Only the first three characters are relevant.

Return Value:

    a LONGLONG value representing the number of bytes available for use. It will return 0 if asked
    to QuerySpace for a non-accessible drive.

--*/
{
    LONGLONG rSpace = 0l;
    ACCESSIBLE_DRIVE_ENUM e;

    if (pFindDrive(DriveString,&e)) {
        rSpace = e -> UsableSpace;
    }
    ELSE_DEBUGMSG((DBG_ACCESSIBLE_DRIVES,"QuerySpace: %s is not in the list of accessible drives.",DriveString));

    return rSpace;
}




BOOL
FreeSpace (
    IN PCTSTR DriveString,
    IN LONGLONG SpaceToUse
    )

/*++

Routine Description:

    The FreeSpace function allows the caller to tag some number of bytes on a drive as free even
    though they do not plan to free that space immediately. The number of bytes thus tagged will
    be added to the amount available on that drive.


Arguments:

    DriveString - Contains the root path of the drive in question. May contain extra information
                  also, Only the first three characters are relevant.

    SpaceToUse  - Contains the number of bytes to tag for use.

Return Value:

    TRUE if the space was successfully tagged, FALSE otherwise. The function will return FALSE if
    asked to tag space on a non-accessible drive.

--*/
{

    BOOL rSuccess = TRUE;
    ACCESSIBLE_DRIVE_ENUM e;

    if (pFindDrive(DriveString,&e)) {

        e -> UsableSpace += pRoundToNearestCluster (SpaceToUse, e -> ClusterSize);
        e->MaxUsableSpace = max (e->MaxUsableSpace, e -> UsableSpace);
    }
    else {
        rSuccess = FALSE;
        DEBUGMSG((DBG_ACCESSIBLE_DRIVES,"UseSpace: %s is not in the list of accessible drives.",DriveString));
    }

    return rSuccess;
}



BOOL
UseSpace (
    IN PCTSTR   DriveString,
    IN LONGLONG SpaceToUse
    )

/*++

Routine Description:

    The UseSpace function allows the caller to tag some number of bytes on a drive for use even
    though they do not plan to use that space immediately. The number of bytes thus tagged will
    be subtracted from the amount available on that drive.


Arguments:

    DriveString - Contains the root path of the drive in question. May contain extra information
                  also, Only the first three characters are relevant.

    SpaceToUse  - Contains the number of bytes to tag for use.

Return Value:

    TRUE if the space was successfully tagged, FALSE otherwise. The function will return FALSE if
    asked to tag space on a non-accessible drive or on an accessible drive that does not have
    enough space remaining.

--*/

{

    BOOL rSuccess = TRUE;
    ACCESSIBLE_DRIVE_ENUM e;

    if (pFindDrive(DriveString,&e)) {

        if (SpaceToUse > e -> UsableSpace) {

            rSuccess = FALSE;
            DEBUGMSG((
                DBG_ACCESSIBLE_DRIVES,
                "UseSpace: Not Enough space on drive %s to handle request. Need %u bytes, have %u bytes.",
                DriveString,
                (UINT) SpaceToUse,
                (UINT) e->UsableSpace
                ));
        }

        e -> UsableSpace -= pRoundToNearestCluster (SpaceToUse, e -> ClusterSize);


    }
    else {
        rSuccess = FALSE;
        DEBUGMSG((DBG_ACCESSIBLE_DRIVES,"UseSpace: %s is not in the list of accessible drives.",DriveString));
    }


    return rSuccess;
}


PCTSTR
FindSpace (
    IN LONGLONG SpaceNeeded
    )
/*++

Routine Description:

    FindSpace will attempt to find a drive with enough space to hold the requested number of bytes
    using a 'FirstFit' algorithm -- It will search sequentially through the list of drives
    returning the first such drive with enough space.


Arguments:

    SpaceNeeded - Contains the number of bytes required.

Return Value:

    NULL if no accessible drive has enough space remaining, otherwise a buffer containing the
    root directory of a drive that can handle the request.

--*/
{
    PCTSTR rDrive = NULL;
    ACCESSIBLE_DRIVE_ENUM e;

    if (GetFirstAccessibleDrive(&e)) {
        do {
            if (e->UsableSpace >= SpaceNeeded) {
                rDrive = e->Drive;
                break;
            }
        } while (GetNextAccessibleDrive(&e));
    }

    return rDrive;
}


VOID
OutOfSpaceMessage (
    VOID
    )
/*++

Routine Description:

    This routine Logs a generic OutOfSpace message. A caller should use this message only if
    there is no other message that would convey more information.


Arguments:

    None.

Return Value:

    None.

--*/

{
    LOG ((LOG_ERROR, (PCSTR)MSG_ERROR_OUT_OF_DISK_SPACE));
}


BOOL
OurSetDriveType (
    IN      UINT Drive,
    IN      UINT DriveType
    )
{
    INT localDrive;

    localDrive = Drive - 'A';
    if ((localDrive >= 0) && (localDrive < MAX_NUM_DRIVES)) {
        g_DriveTypes [localDrive] = DriveType;
        return TRUE;
    }
    return FALSE;
}


UINT
OurGetDriveType (
    IN      UINT Drive
    )
{
    INT localDrive;

    localDrive = Drive - 'A';
    if ((localDrive >= 0) && (localDrive < MAX_NUM_DRIVES)) {
        return g_DriveTypes [localDrive];
    }
    return 0;
}


VOID
pGenerateLackOfSpaceMessage (
    IN      BOOL AddToReport
    )
{
    TCHAR mbString[20];
    TCHAR lsSpaceString[20];
    TCHAR altMbString[20];
    TCHAR backupMbString[20];
    TCHAR drive[20];
    BOOL lsOnWinDirDrive;
    UINT driveCount = 0;
    ACCESSIBLE_DRIVE_ENUM drives;
    UINT msgId;
    PCTSTR args[5];
    PCTSTR group;
    PCTSTR message;

    //
    // The user does not have enough space to continue. Let him know about it.
    //
    wsprintf (mbString, TEXT("%d"), (g_OriginalDiskSpace + (QuerySpace (g_WinDir) * -1)) / (1024*1024));
    wsprintf (lsSpaceString, TEXT("%d"), *g_LocalSourceSpace / (1024*1024));
    wsprintf (altMbString, TEXT("%d"), ((QuerySpace (g_WinDir) * -1) - *g_LocalSourceSpace + g_OriginalDiskSpace) / (1024*1024));
    wsprintf (backupMbString, TEXT("%d"), g_SpaceNeededForSlowBackup.LowPart / (1024*1024));

    g_NotEnoughDiskSpace = TRUE;

    drive[0] = (TCHAR) _totupper ((CHARTYPE) g_WinDir[0]);
    drive[1] = TEXT(':');
    drive[2] = TEXT('\\');
    drive[3] = 0;

    args[0] = drive;
    args[1] = mbString;
    args[2] = lsSpaceString;
    args[3] = altMbString;
    args[4] = backupMbString;

    lsOnWinDirDrive = ((DWORD)(toupper(*g_WinDir) - TEXT('A'))) == *g_LocalSourceDrive;

    if (GetFirstAccessibleDrive (&drives)) {
        do {
            driveCount++;
        } while (GetNextAccessibleDrive (&drives));
    }

    //
    // If the local source is still stuck on the windir drive, that means we couldn't find a
    // drive where it would fit. If the user has more than one drive, and it would make a difference,
    // let them know that they can copy
    //
    if (lsOnWinDirDrive && driveCount > 1) {
        if ((QuerySpace (g_WinDir) * -1) < *g_LocalSourceSpace) {
            if (g_ConfigOptions.EnableBackup != TRISTATE_NO && (UNATTENDED() || REPORTONLY()) && 
                g_ConfigOptions.PathForBackup && g_ConfigOptions.PathForBackup[0]) {
                msgId = MSG_NOT_ENOUGH_DISK_SPACE_WITH_LOCALSOURCE_AND_BACKUP;
            } else {
                msgId = MSG_NOT_ENOUGH_DISK_SPACE_WITH_LOCALSOURCE;
            }
        } else {
            if (g_ConfigOptions.EnableBackup != TRISTATE_NO && (UNATTENDED() || REPORTONLY()) && 
                g_ConfigOptions.PathForBackup && g_ConfigOptions.PathForBackup[0]) {
                msgId = MSG_NOT_ENOUGH_DISK_SPACE_WITH_LOCALSOURCE_AND_WINDIR_AND_BACKUP;
            } else {
                msgId = MSG_NOT_ENOUGH_DISK_SPACE_WITH_LOCALSOURCE_AND_WINDIR;
            }
        }
    } else {
        if (g_ConfigOptions.EnableBackup != TRISTATE_NO && (UNATTENDED() || REPORTONLY()) && 
            g_ConfigOptions.PathForBackup && g_ConfigOptions.PathForBackup[0]) {
            msgId = MSG_NOT_ENOUGH_DISK_SPACE_WITH_BACKUP;
        } else {
            msgId = MSG_NOT_ENOUGH_DISK_SPACE;
        }
    }

    //
    // Add to upgrade report.
    //

    FreeStringResource (g_NotEnoughSpaceMessage);
    g_NotEnoughSpaceMessage = ParseMessageID (msgId, args);

    if (AddToReport) {
        group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_NOT_ENOUGH_DISKSPACE_SUBGROUP, NULL);
        if (group && g_NotEnoughSpaceMessage) {
            MsgMgr_ObjectMsg_Add (TEXT("*DiskSpace"), group, g_NotEnoughSpaceMessage);
        }
        FreeText (group);
    }

    return;
}

VOID
pDetermineSpaceUsagePreReport (
    VOID
    )
{
    LONGLONG bytes;
    ALL_FILEOPS_ENUM e;
    HANDLE h;
    PTSTR p;
    BOOL enoughSpace = TRUE;
    TCHAR drive[20];
    LONG totalSpaceSaved = 0;
    WIN32_FIND_DATA fd;
    ACCESSIBLE_DRIVE_ENUM drives;
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    ULARGE_INTEGER FreeClusters = {0, 0};
    ULARGE_INTEGER TotalClusters = {0, 0};
    UINT driveCount = 0;
    BOOL lsOnWinDirDrive = FALSE;
    DWORD count = 0;
    PCTSTR fileString;
    ACCESSIBLE_DRIVE_ENUM driveAccessibleEnum;
    UINT backupImageSpace = 0;
    PCTSTR backupImagePath = NULL;
    PCTSTR args[3];
    PCTSTR group;
    PCTSTR message;

    g_NotEnoughDiskSpace = FALSE;

    //
    // First, take out the amount of space that the ~ls directory will use.
    //
    drive[0] = ((CHAR) *g_LocalSourceDrive) + TEXT('A');
    drive[1] = TEXT(':');
    drive[2] = TEXT('\\');
    drive[3] = 0;

    DEBUGMSG ((DBG_VERBOSE, "Using space for ~ls"));
    UseSpace (drive, *g_LocalSourceSpace);

    TickProgressBar ();

    //
    // Compute size of files to be deleted that aren't being moved.
    //
    if (EnumFirstFileOp (&e, OPERATION_FILE_DELETE, NULL)) {

        do {

            h = FindFirstFile (e.Path, &fd);


            if (h == INVALID_HANDLE_VALUE) {
                DEBUGMSG((DBG_WARNING, "DetermineSpaceUsage: Could not open %s. (%u)", e.Path, GetLastError()));
                continue;
            }

            bytes = ((LONGLONG) fd.nFileSizeHigh << 32) | (LONGLONG) fd.nFileSizeLow;

            FindClose (h);

            totalSpaceSaved += (LONG) bytes;

            FreeSpace (e.Path, bytes);

            count++;
            if (!(count % 128)) {
                TickProgressBar ();
            }
        } while (EnumNextFileOp (&e));
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "No files marked for deletion!"));

    //
    // Add in the space that the windir will grow by.
    // (This information was gathered earlier by winnt32.)
    //
    DEBUGMSG ((DBG_VERBOSE, "Using space for windir"));
    UseSpace (g_WinDir, *g_WinDirSpace);

    StringCopy (drive, g_WinDir);
    p = _tcschr (drive, TEXT('\\'));
    if (p) {
        p = _tcsinc(p);
        *p = 0;
    }

    //
    // Add in the backup image size
    //
    
    if(UNATTENDED() || REPORTONLY()){
        if (g_ConfigOptions.EnableBackup != TRISTATE_NO && 
            g_ConfigOptions.PathForBackup && g_ConfigOptions.PathForBackup[0]) {
            backupImagePath = g_ConfigOptions.PathForBackup;

            backupImageSpace = g_SpaceNeededForSlowBackup.LowPart;
            MYASSERT (backupImageSpace);

            DEBUGMSG ((DBG_VERBOSE, "Using space for backup"));
            UseSpace (backupImagePath, backupImageSpace);
        }
    }

    lsOnWinDirDrive = ((DWORD)(toupper(*g_WinDir) - TEXT('A'))) == *g_LocalSourceDrive;

    //
    // Check to see if we can move the ~ls if there isn't enough space.
    //

    enoughSpace = QuerySpace (g_WinDir) > 0;

    if (!enoughSpace && lsOnWinDirDrive) {

        DEBUGMSG ((DBG_VERBOSE, "Trying to find new home for ~ls"));

        if (GetFirstAccessibleDrive (&drives)) {

            do {

                driveCount++;

                //
                // If it isn't the windir drive, and it has enough space, use it!
                //
                if (QuerySpace (drives->Drive) > *g_LocalSourceSpace) {

                    *g_LocalSourceDrive = (DWORD) (toupper(*drives->Drive) - TEXT('A'));
                    FreeSpace (g_WinDir, *g_LocalSourceSpace);
                    UseSpace (drives->Drive, *g_LocalSourceSpace);

                    enoughSpace = QuerySpace (g_WinDir) > 0;

                    DEBUGMSG ((DBG_WARNING, "Moving the local source drive from %c to %c.", *g_WinDir, *drives->Drive));
                    break;
                }

            } while (GetNextAccessibleDrive (&drives));
        }
    }

    //
    // Undo the space reserved for the backup image. The upcoming
    // wizard pages will update space use.
    //

    if (backupImagePath) {
        DEBUGMSG ((DBG_VERBOSE, "Removing backup space"));
        FreeSpace (backupImagePath, backupImageSpace);
        enoughSpace = QuerySpace (g_WinDir) > 0;
    }

    //
    // Get the amount of diskspace currently used (real use) on the drive.
    // we'll need this to figure out how much the user has cleaned up.
    //
    if (GetDiskFreeSpaceNew (
            drive,
            &SectorsPerCluster,
            &BytesPerSector,
            &FreeClusters,
            &TotalClusters
            )) {

        //
        // Initialize our count of the usable space for this drive.
        //
        g_OriginalDiskSpace =
            (LONGLONG) SectorsPerCluster * (LONGLONG) BytesPerSector * FreeClusters.QuadPart;
    }


    //
    // We should have a fairly accurate description of the space needed by NT at this time.
    //
    if (!enoughSpace) {

        pGenerateLackOfSpaceMessage (TRUE);

    }

    if (pFindDrive(g_WinDir, &driveAccessibleEnum)) {
        g_SpaceNeededForUpgrade.QuadPart = driveAccessibleEnum->MaxUsableSpace - driveAccessibleEnum->UsableSpace;
    }

    //
    // This is a good place to add the "not enough ram" message if necessary.
    //
    if (*g_RamNeeded && *g_RamAvailable) {

        TCHAR mbAvail[20];
        TCHAR mbNeeded[20];
        TCHAR mbMore[20];

        wsprintf (mbAvail, TEXT("%d"), *g_RamAvailable);
        wsprintf (mbNeeded, TEXT("%d"), *g_RamNeeded);
        wsprintf (mbMore, TEXT("%d"), *g_RamNeeded - *g_RamAvailable);

        args[0] = mbNeeded;
        args[1] = mbAvail;
        args[2] = mbMore;

        group = BuildMessageGroup (MSG_BLOCKING_ITEMS_ROOT, MSG_NOT_ENOUGH_RAM_SUBGROUP, NULL);
        message = ParseMessageID (MSG_NOT_ENOUGH_RAM, args);

        if (message && group) {
            MsgMgr_ObjectMsg_Add (TEXT("*Ram"), group, message);
        }

        FreeText (group);
        FreeStringResource (message);
    }

    return;
}


VOID
DetermineSpaceUsagePostReport (
    VOID
    )
{
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    ULARGE_INTEGER FreeClusters = {0, 0};
    ULARGE_INTEGER TotalClusters = {0, 0};
    LONGLONG curSpace;
    TCHAR drive[20];
    PTSTR p;


    StringCopy (drive, g_WinDir);
    p = _tcschr (drive, TEXT('\\'));
    if (p) {
        p = _tcsinc(p);
        *p = 0;
    }
    //
    // Get the amount of diskspace currently used (real use) on the drive.
    // we'll need this to figure out how much the user has cleaned up.
    //
    if (g_NotEnoughDiskSpace &&
        GetDiskFreeSpaceNew (
            drive,
            &SectorsPerCluster,
            &BytesPerSector,
            &FreeClusters,
            &TotalClusters
            ))  {

        curSpace = (LONGLONG) SectorsPerCluster * (LONGLONG) BytesPerSector * FreeClusters.QuadPart;


        //
        // Mark the amount freed up as freed.
        //
        FreeSpace (g_WinDir, curSpace - g_OriginalDiskSpace);
        g_OriginalDiskSpace = curSpace;

    }

    if (QuerySpace (g_WinDir) > 0) {

        //
        // User freed up enough disk space.
        //
        g_NotEnoughDiskSpace = FALSE;

    } else {

        pGenerateLackOfSpaceMessage (FALSE);
    }
}

PCTSTR
GetNotEnoughSpaceMessage (
    VOID
    )
{

    return g_NotEnoughSpaceMessage;
}



BOOL
GetUninstallMetrics (
     OUT PINT OutCompressionFactor,         OPTIONAL
     OUT PINT OutBootCabImagePadding,       OPTIONAL
     OUT PINT OutBackupDiskPadding          OPTIONAL
     )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR parametersName[] = {
            S_COMPRESSIONFACTOR,
            S_BOOTCABIMAGEPADDING,
            S_BACKUPDISKSPACEPADDING
            };
    PINT parametersValue[] = {OutCompressionFactor, OutBootCabImagePadding, OutBackupDiskPadding};
    BOOL result = FALSE;
    PCTSTR data;
    INT i;

    MYASSERT (g_Win95UpgInf != INVALID_HANDLE_VALUE);

    //
    // Read all of the disk space metrics from win95upg.inf
    //
    for (i = 0 ; i < ARRAYSIZE(parametersName) ; i++) {

        if(!parametersValue[i]){
            continue;
        }

        *(parametersValue[i]) = 0;

        if (InfFindFirstLine (g_Win95UpgInf, S_UNINSTALL_DISKSPACEESTIMATION, parametersName[i], &is)) {
            data = InfGetStringField (&is, 1);

            if (data) {
                *(parametersValue[i]) = _ttoi(data);
                result = TRUE;
            }
        }
    }

    InfCleanUpInfStruct (&is);

    return result;
}

DWORD
ComputeBackupLayout (
    IN DWORD Request
    )
{
    PCTSTR fileString;
    INT compressionFactor;                          // % of compression * 100
    INT bootCabImagePadding;
    ULARGE_INTEGER spaceNeededForFastBackupClusterAligned;


    if (Request == REQUEST_QUERYTICKS) {
        if (g_ConfigOptions.EnableBackup == TRISTATE_NO) {
            return 0;
        }

        return TICKS_BACKUP_LAYOUT_OUTPUT;
    }

    if (g_ConfigOptions.EnableBackup == TRISTATE_NO) {
        return ERROR_SUCCESS;
    }

    //
    // Create the backup file lists. The output will provide disk
    // space info for use by DetermineSpaceUse.
    //

    fileString = JoinPaths (g_TempDir, TEXT("uninstall"));
    CreateDirectory (fileString, NULL);

    GetUninstallMetrics (&compressionFactor, &bootCabImagePadding, NULL);

    spaceNeededForFastBackupClusterAligned.QuadPart = 0;

    WriteBackupFilesA (
        TRUE,
        g_TempDir,
        &g_SpaceNeededForSlowBackup,
        &g_SpaceNeededForFastBackup,
        compressionFactor,
        bootCabImagePadding,
        NULL,
        &spaceNeededForFastBackupClusterAligned
        );

    spaceNeededForFastBackupClusterAligned.QuadPart >>= 20;
    spaceNeededForFastBackupClusterAligned.LowPart += 1;
    MemDbSetValueEx (
        MEMDB_CATEGORY_STATE,
        MEMDB_ITEM_ROLLBACK_SPACE,
        NULL,
        NULL,
        spaceNeededForFastBackupClusterAligned.LowPart,
        NULL
        );

    DEBUGMSG ((DBG_VERBOSE, "Space aligned by cluster needed for fast backup: %u MB", spaceNeededForFastBackupClusterAligned.LowPart));
    LOG ((LOG_INFORMATION, "Win95UpgDiskSpace: Space needed for upgrade without backup: %uMB", g_SpaceNeededForUpgrade.QuadPart>>20));
    LOG ((LOG_INFORMATION, "Win95UpgDiskSpace: Space needed for backup with compression: %uMB", g_SpaceNeededForSlowBackup.QuadPart>>20));
    LOG ((LOG_INFORMATION, "Win95UpgDiskSpace: Space needed for backup without compression: %uMB", g_SpaceNeededForFastBackup.QuadPart>>20));

    FreePathString (fileString);

    return ERROR_SUCCESS;
}


DWORD
DetermineSpaceUsage (
    IN DWORD Request
    )
{
    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_SPACECHECK;
    }

    pDetermineSpaceUsagePreReport();

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\nicepath.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    nicepath.c

Abstract:

    This module is responsable for building an MemDb category holding paths. For each path there is
    a message id associated (the value of the key). We use this message ID to have a good looking
    report for links that have some problems.

Author:

    Calin Negreanu (calinn) 01-May-1998

Revision History:

--*/

#include "pch.h"

/*++

Macro Expansion List Description:

  NICE_PATHS lists a list of paths that we can translate for user in something nicer. For example Start Menu will
  be translated in something like "In your start menu" and so on.

Line Syntax:

   DEFMAC(Key, MessageId, IsShellFolder)

Arguments:

   Key           - This is sort of key to get the message ID. If IsShellFolder is TRUE then this is the ValueName from ShellFolders key.
                   If IsShellFolder is false then this is a well known path like Program Files.

   MessageId     - This is the string that should replace the path that is identified by the Key.

   IsShellFolder - This is a boolean value that specifies if Key is a ValueName from ShellFolders key or a well known path

Variables Generated From List:

   g_NicePaths

For accessing the array there are the following functions:

   AddShellFolder
   InitGlobalPaths

--*/

PTSTR g_RunKeyDir = NULL;

//
// Declare the macro list of action functions
//
#define NICE_PATHS        \
        DEFMAC("Desktop",               MSG_NICE_PATH_DESKTOP,              TRUE )                \
        DEFMAC("Programs",              MSG_NICE_PATH_PROGRAMS,             TRUE )                \
        DEFMAC("Start Menu",            MSG_NICE_PATH_START_MENU,           TRUE )                \
        DEFMAC("StartUp",               MSG_NICE_PATH_START_UP,             TRUE )                \
        DEFMAC("SendTo",                MSG_NICE_PATH_SEND_TO,              TRUE )                \
        DEFMAC("Favorites",             MSG_NICE_PATH_FAVORITES,            TRUE )                \
        DEFMAC("Recent",                MSG_NICE_PATH_RECENT,               TRUE )                \
        DEFMAC("Templates",             MSG_NICE_PATH_TEMPLATES,            TRUE )                \
        DEFMAC(&g_WinDir,               MSG_NICE_PATH_WIN_DIR,              FALSE)                \
        DEFMAC(&g_ProgramFilesDir,      MSG_NICE_PATH_PROGRAM_FILES,        FALSE)                \
        DEFMAC(&g_SystemDir,            MSG_NICE_PATH_SYSTEM_DIR,           FALSE)                \
        DEFMAC(&g_RunKeyDir,            MSG_NICE_PATH_RUN_KEY,              FALSE)                \

typedef struct {
    PVOID Key;
    DWORD MessageId;
    BOOL  IsShellFolder;
} NICE_PATH_STRUCT, *PNICE_PATH_STRUCT;

//
// Declare a global array of functions and name identifiers for action functions
//
#define DEFMAC(key,id,test) {key, id, test},
static NICE_PATH_STRUCT g_NicePaths[] = {
                              NICE_PATHS
                              {NULL, 0, FALSE}
                              };
#undef DEFMAC


VOID
InitGlobalPaths (
    VOID
    )
{
    PNICE_PATH_STRUCT p;
    TCHAR key [MEMDB_MAX];
    USHORT priority = 1;

    g_RunKeyDir = DuplicatePathString (S_RUNKEYFOLDER, 0);

    p = g_NicePaths;
    while (p->Key != NULL) {
        if (!p->IsShellFolder) {
            MemDbBuildKey (key, MEMDB_CATEGORY_NICE_PATHS, (*(PCTSTR *)(p->Key)), NULL, NULL);
            MemDbSetValueAndFlags (key, p->MessageId, priority, 0);
        }
        p ++;
        priority ++;
    }
    FreePathString (g_RunKeyDir);
    g_RunKeyDir = NULL;
}

BOOL
AddShellFolder (
    PCTSTR ValueName,
    PCTSTR FolderName
    )
{
    PNICE_PATH_STRUCT p;
    TCHAR key [MEMDB_MAX];
    USHORT priority = 1;

    p = g_NicePaths;
    while (p->Key != NULL) {
        if ((p->IsShellFolder) &&
            (StringIMatch (ValueName, (PCTSTR)p->Key))
            ) {
            MemDbBuildKey (key, MEMDB_CATEGORY_NICE_PATHS, FolderName, NULL, NULL);
            MemDbSetValueAndFlags (key, p->MessageId, priority, 0);
            return TRUE;
        }
        p ++;
        priority ++;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\olereg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    olereg.c

Abstract:

    Code to perform OLE registry suppression based on list of
    GUIDs in win95upg.inf.

    OLE suppression is accomplished by the following algorithm:

        1. Determine all GUIDs that are Win9x-specific, load in
           list of manually-suppressed GUIDs.  Save this list
           to memdb.

        2. Scan registry for GUID settings, then suppress all
           linkage to the GUID (the ProgID, Interface, etc).
           Use memdb to suppress each registry key/value.

        3. Suppress all shell linkage to suppressed objects
           including file associations and desktop links.

        4. Do a sanity check on the unsuppressed objects in
           the checked build

Author:

    Jim Schmidt (jimschm) 20-Mar-1997

Revision History:

    jimschm     23-Sep-1998 Updated for new fileops code
    jimschm     28-Jan-1998 Added hack for ActiveSetup key
    jimschm     05-May-1997 Added new auto-suppression of non-OLE
                            shell links

--*/

#include "pch.h"
#include "sysmigp.h"
#include "progbar.h"
#include "oleregp.h"
#include "regops.h"

#define S_EXPLORER_SHELLEXECUTEHOOKS                TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellExecuteHooks")
#define S_EXPLORER_CSSFILTERS                       TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CSSFilters")
#define S_EXPLORER_DESKTOP_NAMESPACE                TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace")
#define S_EXPLORER_FILETYPESPROPERTYSHEETHOOK       TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileTypesPropertySheetHook")
#define S_EXPLORER_FINDEXTENSIONS                   TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FindExtensions")
#define S_EXPLORER_MYCOMPUTER_NAMESPACE             TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace")
#define S_EXPLORER_NETWORKNEIGHBORHOOD_NAMESPACE    TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\NetworkNeighborhood\\NameSpace")
#define S_EXPLORER_NEWSHORTCUTHANDLERS              TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\NewShortcutHandlers")
#define S_EXPLORER_REMOTECOMPUTER_NAMESPACE         TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RemoteComputer\\NameSpace")
#define S_EXPLORER_SHELLICONOVERLAYIDENTIFIERS      TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers")
#define S_EXPLORER_VOLUMECACHES                     TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches")
#define S_ACTIVESETUP                               TEXT("HKLM\\Software\\Microsoft\\Active Setup\\Installed Components")
#define S_EXTSHELLVIEWS                             TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\ExtShellViews")
#define S_SHELLEXTENSIONS_APPROVED                  TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved")
#define S_SHELLSERVICEOBJECTDELAYLOAD               TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad ")


static TCHAR g_DefaultIcon[] = TEXT("DefaultIcon");

#define DBG_OLEREG "OLE Reg"

//
// Strings for AutoSuppress
//

TCHAR g_InprocHandler[] = TEXT("InprocHandler");
TCHAR g_InprocHandler32[] = TEXT("InprocHandler32");
TCHAR g_InprocServer[] = TEXT("InprocServer");
TCHAR g_InprocServer32[] = TEXT("InprocServer32");
TCHAR g_LocalServer[] = TEXT("LocalServer");
TCHAR g_LocalServer32[] = TEXT("LocalServer32");

PCTSTR g_FileRefKeys[] = {
    g_InprocHandler,
    g_InprocHandler32,
    g_InprocServer,
    g_InprocServer32,
    g_LocalServer,
    g_LocalServer32,
    NULL
};

static POOLHANDLE g_OlePool;

DWORD
OleReg_GetProgressMax (
    VOID
    )

/*++

Routine Description:

  Estimates the amount of ticks needed to complete OLE registry processing.

Arguments:

  none

Return Value:

  The number of ticks, equal to the number of ticks added with a delta in
  SuppressOleGuids.

--*/

{
    if (REPORTONLY()) {
        return 0;
    }

    return TICKS_OLEREG;
}


BOOL
pIgnoreGuid (
    IN      PCTSTR GuidStr
    )
{
    INFCONTEXT ic;

    MYASSERT (IsGuid (GuidStr, TRUE));

    if (IsReportObjectHandled (GuidStr)) {
        DEBUGMSG ((DBG_OLEREG, "%s is a handled GUID, will not be suppressed", GuidStr));
        return TRUE;
    }

    if (SetupFindFirstLine (g_Win95UpgInf, S_FORCED_GUIDS, GuidStr, &ic)) {
        DEBUGMSG ((DBG_OLEREG, "%s is a forced GUID, will not be suppressed", GuidStr));
        return TRUE;
    }

    return FALSE;
}


BOOL
pSuppressOleGuids (
    VOID
    )

/*++

Routine Description:

  Processes the [Suppressed GUIDs] section of win95upg.inf and auto-suppresses
  OLE objects and GUIDs.  The inf-based approach allows an OLE object and
  all of its linkage to be suppressed.  The auto-suppress approach allows
  suppression of OLE objects and linkage when the implementation binary
  is removed from the system.

Arguments:

  none

Return Value:

  TRUE if suppression was successful, or FALSE if an error occurred.  Call
  GetLastError to retrieve the error code.

--*/

{
    BOOL Result = FALSE;
    DWORD Ticks;

    if (REPORTONLY()) {
        return TRUE;
    }

    g_OlePool = PoolMemInitNamedPool ("OLE Reg");
    if (!g_OlePool) {
        return FALSE;
    }

    Ticks = GetTickCount();

    __try {
        ProgressBar_SetComponentById (MSG_OLEREG);

        //
        // Suppress all GUIDs from [Suppressed GUIDs] section of win95upg.inf:
        //
        //    HKLM\SOFTWARE\Classes\CLSID\<GUID>
        //    HKLM\SOFTWARE\Classes\Interface\<GUID>
        //    HKLM\SOFTWARE\Classes\<ProgID>
        //    HKLM\SOFTWARE\Classes\<VersionIndependentProgID>
        //
        // Suppress any GUID that has a TreatAs key that points to GUID
        //

        if (!pProcessGuidSuppressList()) {
            __leave;
        }

        TickProgressBar ();

        //
        // Scan ProgIDs in HKCR for reference to suppressed GUID
        //

        if (!pProcessProgIdSuppression()) {
            __leave;
        }

        TickProgressBar ();

        //
        // Scan HKCR for file extensions that need to be suppressed
        //

        if (!pProcessFileExtensionSuppression()) {
            __leave;
        }
        TickProgressBar ();

        //
        // Scan Explorer registry for references to suppressed GUIDs
        //

        if (!pProcessExplorerSuppression()) {
            __leave;
        }
        TickProgressBar ();

        //
        // Delete all links requiring incompatible OLE objects
        //

        if (!pSuppressLinksToSuppressedGuids()) {
            __leave;
        }
        TickProgressBar ();

        //
        // Preserve all files needed by DefaultIcon
        //

        if (!pDefaultIconPreservation()) {
            __leave;
        }
        TickProgressBar ();

        //
        // Preserve all INFs needed by ActiveSetup
        //

        if (!pActiveSetupProcessing ()) {
            __leave;
        }
        TickProgressBar ();

    #ifdef DEBUG
        // Checked build sanity check
        pProcessOleWarnings();
        TickProgressBar ();
    #endif

        ProgressBar_SetComponent (NULL);

        Result = TRUE;
    }

    __finally {
        PoolMemDestroyPool (g_OlePool);
    }

    Ticks = GetTickCount() - Ticks;
    g_ProgressBarTime += Ticks * 2;

    return Result;
}


DWORD
SuppressOleGuids (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return OleReg_GetProgressMax ();
    case REQUEST_RUN:
        if (!pSuppressOleGuids ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in SuppressOleGuids"));
    }
    return 0;
}


BOOL
pProcessGuidSuppressList (
    VOID
    )

/*++

Routine Description:

  Processes [Suppressed GUIDs] and auto-suppression.  Any OLE object that
  is listed in Suppressed GUIDs and exists on the machine is suppressed.
  Any OLE object that requires a suppressed object is auto-suppressed.
  Any OLE object that has a TreatAs entry to a suppressed object is
  suppressed.

  This routine performs all GUID suppression and must run first.

  ("Auto-suppress" refers to the ability to suppress related OLE objects
  that are not listed to be suppressed in win95upg.inf.)

Arguments:

  none

Return Value:

  TRUE if suppression was successful, or FALSE if an error occurred.

--*/

{
    HASHTABLE StrTab;
    LONG rc;
    REGKEY_ENUM e;
    HKEY GuidKey;
    PCTSTR Data;
    TCHAR Node[MEMDB_MAX];
    DWORD Count = 0;

    //
    // Suppress all GUIDs from [Suppressed GUIDs] section of win95upg.inf:
    //
    //    HKLM\SOFTWARE\Classes\CLSID\<GUID>
    //    HKLM\SOFTWARE\Classes\Interface\<GUID>
    //

    StrTab = HtAlloc();
    if (!StrTab) {
        LOG ((LOG_ERROR, "pProcessGuidSuppressList: Cannot create string table"));
        return FALSE;
    }

    pProcessAutoSuppress (StrTab);

    __try {
        //
        // Fill string table of all GUIDs
        //

        pFillHashTableWithKeyNames (StrTab, g_Win95UpgInf, S_SUPPRESSED_GUIDS);

        //
        // Search HKCR\CLSID for each GUID
        //

        if (EnumFirstRegKeyStr (&e, TEXT("HKCR\\CLSID"))) {
            do {
                //
                // Determine if item is suppressed:
                //
                //  - it is on the list in [Suppressed GUIDs] of win95upg.inf
                //  - it is in the GUIDS category of memdb (from TreatAs)
                //

                //
                // First, determine if it is in [Suppressed GUIDs] or from
                // auto suppression.
                //

                rc = (LONG) HtFindString (StrTab, e.SubKeyName);

                if (!rc) {
                    MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, e.SubKeyName, NULL, NULL);
                    if (MemDbGetValue (Node, NULL)) {
                        rc = 0;
                    } else {
                        rc = -1;
                    }
                }

                if (rc != -1) {
                    pSuppressGuidInClsId (e.SubKeyName);
                }

                //
                // If not suppressed, check for TreatAs, and if TreatAs is found,
                // put TreatAs GUID in unsuppressed mapping.  This is how we handle
                // the case where a GUID that is not normally suppressed, but has a
                // TreatAs member that points to a suppressed GUID will be suppressed
                // as well.
                //

                else {
                    GuidKey = OpenRegKey (e.KeyHandle, e.SubKeyName);

                    if (GuidKey) {
                        Data = (PCTSTR) GetRegKeyData (GuidKey, TEXT("TreatAs"));

                        if (Data) {
                            //
                            // Determine if TreatAs GUID is suppressed, and if it
                            // is, suppress this GUID, otherwise put it on the
                            // unsuppressed TreatAs list.
                            //

                            MemDbBuildKey (
                                Node,
                                MEMDB_CATEGORY_GUIDS,
                                Data,
                                NULL,
                                NULL
                                );

                            if (MemDbGetValue (Node, NULL)) {
                                pSuppressGuidInClsId (e.SubKeyName);
                            } else {
                                pAddUnsuppressedTreatAsGuid (Data, e.SubKeyName);
                            }

                            MemFree (g_hHeap, 0, Data);
                        }

                        CloseRegKey (GuidKey);
                    }
                }
                Count++;
                if (!(Count % 128)) {
                    TickProgressBar ();
                }
            } while (EnumNextRegKey (&e));
        }
    }

    __finally {
        //
        // Clean up string table and memdb
        //

        HtFree (StrTab);
        pRemoveUnsuppressedTreatAsGuids();
    }

    return TRUE;
}


BOOL
pSuppressLinksToSuppressedGuids (
    VOID
    )

/*++

Routine Description:

  After the GUID suppression list has been made, we scan all the links that
  have GUIDs in their command line arguments to find ones that need to be
  removed.

Arguments:

  none

Return Value:

  TRUE if all links were processed, or FALSE if an error occurred.

--*/

{
    MEMDB_ENUM e, e2;
    TCHAR Node[MEMDB_MAX];

    if (MemDbEnumItems (&e, MEMDB_CATEGORY_LINK_GUIDS)) {
        do {
            //
            // Is this GUID suppressed?
            //

            MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, e.szName);
            if (MemDbGetValue (Node, NULL)) {
                //
                // Yes -- enumerate all sequencers and delete the associated links
                //

                if (MemDbGetValueEx (&e2, MEMDB_CATEGORY_LINK_GUIDS, e.szName, NULL)) {
                    do {
                        if (MemDbBuildKeyFromOffset (e2.dwValue, Node, 1, NULL)) {
                            //
                            // Delete all the operations for the file in Node
                            //
                            RemoveAllOperationsFromPath (Node);

                            //
                            // Now mark file for text mode delete
                            //
                            MarkFileForDelete (Node);

                            DEBUGMSG ((
                                DBG_OLEREG,
                                "Link %s points to an incompatible OLE object; deleting.",
                                Node
                                ));
                        }
                    } while (MemDbEnumNextValue (&e2));
                }
            }
        } while (MemDbEnumNextValue (&e));

        //
        // No longer needed -- recover space in memdb
        //

        MemDbDeleteTree (MEMDB_CATEGORY_LINK_GUIDS);
        MemDbDeleteTree (MEMDB_CATEGORY_LINK_STRINGS);
    }

    return TRUE;
}


BOOL
pProcessFileExtensionSuppression (
    VOID
    )

/*++

Routine Description:

  Suppresses any file extension that depends on a suppressed OLE object.
  The GUID suppression must be complete before this routine is called.

Arguments:

  none

Return Value:

  TRUE if suppression was successful, or FALSE if an error occurred.

--*/

{
    REGKEY_ENUM e;
    PCTSTR Data;
    TCHAR MemDbKey[MEMDB_MAX];
    DWORD value;
    BOOL Suppress;

    //
    // Suppresss any file extension that points to suppressed ProgID
    //

    if (EnumFirstRegKey (&e, HKEY_CLASSES_ROOT)) {
        do {
            if (_tcsnextc (e.SubKeyName) != TEXT('.')) {
                continue;
            }

            Suppress = FALSE;

            Data = (PCTSTR) GetRegKeyData (e.KeyHandle, e.SubKeyName);
            if (Data) {

                MemDbBuildKey (MemDbKey, MEMDB_CATEGORY_PROGIDS, NULL, NULL, Data);
                if (MemDbGetValue (MemDbKey, &value) &&
                    (value == PROGID_SUPPRESSED)
                    ) {
                    //
                    // This extension points to a suppressed ProgID key, so
                    // suppress it.
                    //

                    Suppress = TRUE;

                } else {

                    //
                    // Check for this special case: the extension is for a CLSID,
                    // not for a ProgId.
                    //

                    if (StringIMatchCharCount (Data, TEXT("CLSID\\"), 6)) {

                        if (pIsGuidSuppressed (Data + 6)) {
                            Suppress = TRUE;
                        }
                    }
                }

                MemFree (g_hHeap, 0, Data);

            }

            if (!Suppress) {

                //
                // This tests GUIDs AND suppresses the extension if necessary
                //

                pIsShellExKeySuppressed (
                    e.KeyHandle,
                    e.SubKeyName,
                    TEXT("ShellEx")
                    );
            }

            if (Suppress) {
                MemDbBuildKey (
                    MemDbKey,
                    MEMDB_CATEGORY_HKLM,
                    TEXT("SOFTWARE\\Classes"),
                    NULL,
                    e.SubKeyName
                    );

                Suppress95RegSetting (MemDbKey, NULL);
            }

        } while (EnumNextRegKey (&e));
    }

    return TRUE;
}

#define MEMDB_CATEGORY_TMP_SUPPRESS     TEXT("TmpSuppress")

BOOL
pIsCLSIDSuppressed (
    IN      HKEY ParentKey,
    IN      PCTSTR ParentKeyName,
    IN      PCTSTR SubKeyName
    )
{
    HKEY ClsIdKey;
    PCTSTR Data;
    BOOL result = FALSE;

    ClsIdKey = OpenRegKey (ParentKey, SubKeyName);

    if (ClsIdKey) {

        Data = GetRegKeyData (ClsIdKey, S_EMPTY);
        if (Data) {
            result = pIsGuidSuppressed (Data);
            DEBUGMSG_IF ((result, DBG_OLEREG, "ProgID %s has incompatible CLSID %s", ParentKeyName, Data));
            MemFree (g_hHeap, 0, Data);
        }
        CloseRegKey (ClsIdKey);
    }
    return result;
}

VOID
pMarkProgIdAsLostDefault (
    IN      PCTSTR ProgIdName
    )
{
    if (ProgIdName) {
        MemDbSetValueEx (MEMDB_CATEGORY_PROGIDS, ProgIdName, NULL, NULL, PROGID_LOSTDEFAULT, NULL);
    }
}


BOOL
pIsShellKeySuppressed (
    IN      HKEY ParentKey,
    IN      PCTSTR ParentKeyName,
    IN      PCTSTR SubKeyName
    )
{
    REGKEY_ENUM e;
    DWORD Processed, Suppressed;
    HKEY ShellKey;
    TCHAR key [MEMDB_MAX];
    PCTSTR Data;
    BOOL defaultKey = TRUE;
    PCTSTR defaultCommand = NULL;
    BOOL IsvCmdLine = FALSE;

    ShellKey = OpenRegKey (ParentKey, SubKeyName);

    Processed = Suppressed = 0;

    if (ShellKey) {

        Data = (PCTSTR) GetRegKeyData (ShellKey, S_EMPTY);
        if (Data) {
            defaultCommand = DuplicatePathString (Data, 0);
            defaultKey = FALSE;
            MemFree (g_hHeap, 0, Data);
        } else {
            defaultKey = TRUE;
        }
        if (EnumFirstRegKey (&e, ShellKey)) {
            do {
                Processed ++;

                if (defaultCommand) {
                    defaultKey = StringIMatch (e.SubKeyName, defaultCommand);
                }

                MemDbBuildKey (key, e.SubKeyName, TEXT("command"), NULL, NULL);
                Data = (PCTSTR) GetRegKeyData (ShellKey, key);


                if (Data) {
                    if (pIsCmdLineBadEx (Data, &IsvCmdLine)) {
                        DEBUGMSG ((
                            DBG_OLEREG,
                            "ProgID %s has incompatible shell command: shell\\%s\\command[] = %s",
                            ParentKeyName,
                            e.SubKeyName,
                            Data));
                        MemDbSetValueEx (
                            MEMDB_CATEGORY_TMP_SUPPRESS,
                            ParentKeyName,
                            SubKeyName,
                            e.SubKeyName,
                            0,
                            NULL);
                        if (defaultKey) {
                            pMarkProgIdAsLostDefault (ParentKeyName);
                        }
                        Suppressed ++;
                    }
                    else if (IsvCmdLine) {
                        //
                        // Keep this setting.
                        //
                        MemDbBuildKey (key, MEMDB_CATEGORY_HKLM TEXT("\\SOFTWARE\\Classes"), ParentKeyName, SubKeyName, e.SubKeyName);
                        SuppressNtRegSetting (key, NULL);
                    }
                    MemFree (g_hHeap, 0, Data);
                }
                defaultKey = FALSE;
            } while (EnumNextRegKey (&e));
        }
        if (defaultCommand) {
            FreePathString (defaultCommand);
        }
        CloseRegKey (ShellKey);
    }
    if (Processed && (Processed == Suppressed)) {
        MemDbBuildKey (key, MEMDB_CATEGORY_TMP_SUPPRESS, ParentKeyName, SubKeyName, NULL);
        MemDbDeleteTree (key);
        MemDbSetValue (key, 0);
        return TRUE;
    }
    return FALSE;
}

BOOL
pIsProtocolKeySuppressed (
    IN      HKEY ParentKey,
    IN      PCTSTR ParentKeyName,
    IN      PCTSTR SubKeyName
    )
{
    REGKEY_ENUM e;
    DWORD Processed, Suppressed;
    HKEY ProtocolKey;
    TCHAR key [MEMDB_MAX];
    PCTSTR Data;

    ProtocolKey = OpenRegKey (ParentKey, SubKeyName);

    Processed = Suppressed = 0;

    if (ProtocolKey) {

        if (EnumFirstRegKey (&e, ProtocolKey)) {
            do {
                Processed ++;
                MemDbBuildKey (key, e.SubKeyName, TEXT("server"), NULL, NULL);
                Data = (PCTSTR) GetRegKeyData (ProtocolKey, key);

                if (Data) {
                    if (pIsCmdLineBad (Data)) {
                        DEBUGMSG ((
                            DBG_OLEREG,
                            "ProgID %s has incompatible protocol command: protocol\\%s\\server[] = %s",
                            ParentKeyName,
                            e.SubKeyName,
                            Data));
                        MemDbSetValueEx (
                            MEMDB_CATEGORY_TMP_SUPPRESS,
                            ParentKeyName,
                            SubKeyName,
                            e.SubKeyName,
                            0,
                            NULL);
                        Suppressed ++;
                    }
                    MemFree (g_hHeap, 0, Data);
                }
            } while (EnumNextRegKey (&e));
        }
        CloseRegKey (ProtocolKey);
    }
    if (Processed && (Processed == Suppressed)) {
        MemDbBuildKey (key, MEMDB_CATEGORY_TMP_SUPPRESS, ParentKeyName, SubKeyName, NULL);
        MemDbDeleteTree (key);
        MemDbSetValue (key, 0);
        return TRUE;
    }
    return FALSE;
}

BOOL
pIsExtensionsKeySuppressed (
    IN      HKEY ParentKey,
    IN      PCTSTR ParentKeyName,
    IN      PCTSTR SubKeyName
    )
{
    REGKEY_ENUM e;
    REGVALUE_ENUM ev;
    DWORD Processed, Suppressed;
    HKEY ExtensionsKey;
    TCHAR key [MEMDB_MAX];
    PCTSTR Data;

    ExtensionsKey = OpenRegKey (ParentKey, SubKeyName);

    Processed = Suppressed = 0;

    if (ExtensionsKey) {

        if (EnumFirstRegKey (&e, ExtensionsKey)) {
            do {
                Processed ++;
                Data = (PCTSTR) GetRegKeyData (ExtensionsKey, e.SubKeyName);

                if (Data) {
                    if (pIsGuidSuppressed (Data)) {
                        DEBUGMSG ((DBG_OLEREG, "ProgID %s has incompatible extensions key %s", ParentKeyName, e.SubKeyName));
                        MemDbSetValueEx (
                            MEMDB_CATEGORY_TMP_SUPPRESS,
                            ParentKeyName,
                            SubKeyName,
                            e.SubKeyName,
                            0,
                            NULL);
                        Suppressed ++;
                    }
                    MemFree (g_hHeap, 0, Data);
                }
            } while (EnumNextRegKey (&e));
        }
        if (EnumFirstRegValue (&ev, ExtensionsKey)) {
            do {
                Processed ++;
                if (ev.Type == REG_SZ) {

                    Data = (PCTSTR) GetRegValueData (ExtensionsKey, ev.ValueName);

                    if (Data) {
                        if (pIsGuidSuppressed (Data)) {
                            DEBUGMSG ((DBG_OLEREG, "ProgID %s has incompatible extensions key %s", ParentKeyName, ev.ValueName));
                            MemDbBuildKey (key, MEMDB_CATEGORY_TMP_SUPPRESS, ParentKeyName, SubKeyName, NULL);
                            Data = CreateEncodedRegistryString (key, ev.ValueName);
                            MemDbSetValue (Data, 0);
                            FreePathString (Data);
                      