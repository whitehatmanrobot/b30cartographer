=============================


#if defined(UMODE) || defined(USERMODE_DRIVER)

#define OpenPlotFile(pFileName) CreateFile((LPCTSTR)pFileName,      \
                                           GENERIC_READ,            \
                                           FILE_SHARE_READ,         \
                                           NULL,                    \
                                           OPEN_EXISTING,           \
                                           FILE_ATTRIBUTE_NORMAL,   \
                                           NULL)

#define ClosePlotFile(h)        CloseHandle(h)
#define ReadPlotFile(h,p,c,pc)  ReadFile((h),(p),(c),(pc),NULL)


#else

typedef struct _PLOTFILE {
    HANDLE  hModule;
    LPBYTE  pbBeg;
    LPBYTE  pbEnd;
    LPBYTE  pbCur;
    } PLOTFILE, *PPLOTFILE;


HANDLE
OpenPlotFile(
    LPWSTR  pFileName
    );

BOOL
ClosePlotFile(
    HANDLE  hPlotFile
    );

BOOL
ReadPlotFile(
    HANDLE  hPlotFile,
    LPVOID  pBuf,
    DWORD   cToRead,
    LPDWORD pcRead
    );

#endif

//===========================================================================
// Devmode.c and halftone.c
//===========================================================================

BOOL
ValidateColorAdj(
    PCOLORADJUSTMENT    pca
    );


LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

#if defined(UMODE) || defined(USERMODE_DRIVER)

#include <winspool.h>
#include <commctrl.h>
#include <winddiui.h>

// Copy DEVMODE to an output buffer before return to the
// caller of DrvDocumentPropertySheets

BOOL
ConvertDevmodeOut(
    PDEVMODE pdmSrc,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

typedef struct {

    WORD    dmDriverVersion;    // current driver version
    WORD    dmDriverExtra;      // size of current version private devmode
    WORD    dmDriverVersion351; // 3.51 driver version
    WORD    dmDriverExtra351;   // size of 3.51 version private devmode

} DRIVER_VERSION_INFO, *PDRIVER_VERSION_INFO;

#define CDM_RESULT_FALSE        0
#define CDM_RESULT_TRUE         1
#define CDM_RESULT_NOT_HANDLED  2

INT
CommonDrvConvertDevmode(
    PWSTR    pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode,
    PDRIVER_VERSION_INFO pDriverVersions
    );

#endif


//===========================================================================
// PlotDBG.c - debug output support
//===========================================================================


#if DBG

VOID
cdecl
PlotDbgPrint(
    LPSTR   pszFormat,
    ...
    );

VOID
PlotDbgType(
    INT    Type
    );

VOID
_PlotAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    UINT    LineNo,
    DWORD_PTR   Exp,
    BOOL    Stop
    );

extern BOOL DoPlotWarn;


#define DBGP(x)             (PlotDbgPrint x)

#if 1

#define DEFINE_DBGVAR(x)    DWORD DBG_PLOTFILENAME=(x)
#define PLOTDBG(x,y)        if (x&DBG_PLOTFILENAME){PlotDbgType(0);DBGP(y);}

#else

#define DEFINE_DBGVAR(x)
#define PLOTDBG(x,y)        DBGP(y)

#endif  // DBG_PLOTFILENAME

#define PLOTDBGBLK(x)       x;
#define PLOTWARN(x)         if (DoPlotWarn) { PlotDbgType(1);DBGP(x); }
#define PLOTERR(x)          PlotDbgType(-1);DBGP(x)
#define PLOTRIP(x)          PLOTERR(x); DebugBreak()
#define PLOTASSERT(b,x,e,i)     \
            if (!(e)) { _PlotAssert(x,#e,__FILE__,(UINT)__LINE__,(DWORD_PTR)i,b); }

#else   // DBG

#define PLOTDBGBLK(x)
#define DEFINE_DBGVAR(x)
#define PLOTDBG(x,y)
#define PLOTWARN(x)
#define PLOTERR(x)
#define PLOTRIP(x)
#define PLOTASSERT(b,x,e,i)

#endif  // DBG





#endif  // _PLOTLIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\lib\plotdbg.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    plotdbg.c


Abstract:

    This module contains all plotter's debugging functions


Author:

    15-Nov-1993 Mon 17:57:24 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#if DBG

BOOL    DoPlotWarn = FALSE;



VOID
cdecl
PlotDbgPrint(
    LPSTR   pszFormat,
    ...
    )

/*++

Routine Description:

    This fucntion output the debug informat to the debugger


Arguments:

    pszFormat   - format string

    ...         - variable data


Return Value:


    VOID

Author:

    15-Nov-1993 Mon 17:57:59 created  -by-  DC


Revision History:


--*/

{
    va_list         vaList;

#if defined(UMODE) || defined(USERMODE_DRIVER)

    static WCHAR    wOutBuf[768];
    static WCHAR    wFormatBuf[256];

    //
    // We assume that UNICODE flag is turn on for the compilation, bug the
    // format string passed to here is ASCII version, so we need to convert
    // it to LPWSTR before the wvsprintf()
    //

    va_start(vaList, pszFormat);
    MultiByteToWideChar(CP_ACP, 0, pszFormat, -1, wFormatBuf, 256);
    wvsprintf(wOutBuf, wFormatBuf, vaList);
    va_end(vaList);

    OutputDebugString((LPCTSTR)wOutBuf);
    OutputDebugString(TEXT("\n"));

#else

    va_start(vaList, pszFormat);
    EngDebugPrint("PLOT",pszFormat,vaList);
    va_end(vaList);

#endif
}




VOID
PlotDbgType(
    INT    Type
    )

/*++

Routine Description:

    this function output the ERROR/WARNING message


Arguments:

    Type

Return Value:


Author:

    15-Nov-1993 Mon 22:53:01 created  -by-  DC


Revision History:


--*/

{
    extern  TCHAR   DebugDLLName[];

#if defined(UMODE) || defined(USERMODE_DRIVER)

    if (Type) {

        OutputDebugString((Type < 0) ? TEXT("ERROR: ") : TEXT("WARNING: "));
    }

    OutputDebugString(DebugDLLName);
    OutputDebugString(TEXT("!"));

#else

    PlotDbgPrint("%s: %ws!\n",
                 (Type < 0) ? "ERROR" : "WARNING",
                 DebugDLLName);
#endif
}




VOID
_PlotAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    UINT    LineNo,
    DWORD_PTR   Exp,
    BOOL    Stop
    )

/*++

Routine Description:

    This function output assertion message and false expression to the debugger
    then break into the debugger


Arguments:

    pMsg        - Message to displayed

    pFlaseExp   - false expression

    pFilename   - plotter source filename

    LineNo      - line number of the flase expression

Return Value:

    VOID


Author:

    15-Nov-1993 Mon 18:47:30 created  -by-  DC


Revision History:


--*/

{
    PlotDbgPrint("\n");

    if ((pMsg) && (*pMsg)) {

        PlotDbgPrint(pMsg, Exp);
    }

    PlotDbgPrint("Assertion failed (%hs) in %hs line %u",
                                        pFalseExp, pFilename, LineNo);

    if (Stop) {

        DebugBreak();
    }
}



#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\lib\plotdm.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    plotdm.c


Abstract:

    This module contain functions which validate/set default the devmode and
    extented devmode (PLOTDEVMODE)


Author:

    15-Nov-1993 Mon 14:09:27 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

    15-Dec-1993 Wed 21:08:49 updated  -by-  DC
        Add the default FILL_TRUETYPE flag stuff

    02-Feb-1994 Wed 01:04:21 updated  -by-  DC
        Change IsMetricMode() to IsA4PaperDefault(), this function right now
        will call RegOpenKey(), RegQueryValueEx() and RegCloseKey() to the
        control panel\International rather then using GetLocaleInfoW().
        The reason is if we call GetLocaleInfoW() then the registry key will
        keep opened by the API functions and since the WinSrv will never unload
        the driver, then the registry key will never get close, this has bad
        consquence which it never allowed user to save its updated profile at
        logoff time if this driver is used.

--*/


#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgDevMode

#define DBG_DEFDEVMODE      0x00000001
#define DBG_CURFORM         0x00000002
#define DBG_DEFPAPER        0x00000004
#define DBG_A4DEFAULT       0x00000008
#define DBG_ROTPAPER        0x00000010
#define DBG_INTERSECTRECTL  0x00000020
#define DBG_SHOWDEVMODE     0x00000040

DEFINE_DBGVAR(0);

//
// Depends on what we have to do what we have to do
//

#if defined(UMODE) || defined(USERMODE_DRIVER)
    #define HAS_GETREGDATA      1
#else
    #define HAS_GETREGDATA      0
#endif  // UMODE



//
// This is our default PLOTDEVMODE, we will update following fields
//
//  dmDeviceName    - Real device name passed in
//  dmFormName      - Letter if USA and A4 if NOT USA
//  dmPaperSize     - DMPAPER_LETTER/DMPAPER_A4
//  dmColor         - COLOR printer = DMCOLOR_COLOR else DMCOLOR_MONOCHROME
//

#define A4_FORM_NAME    _DefPlotDM.dm.dmDeviceName
#define A4_FORM_CX      _DefPlotDM.dm.dmPelsWidth
#define A4_FORM_CY      _DefPlotDM.dm.dmPelsHeight

#define DM_PAPER_CUSTOM (DM_PAPER_WL | DM_PAPERSIZE)


static const PLOTDEVMODE _DefPlotDM = {

        {
            TEXT("A4"),                 // dmDeviceName - filled later
            DM_SPECVERSION,             // dmSpecVersion
            DRIVER_VERSION,             // dmDriverVersion
            sizeof(DEVMODE),            // dmSize
            PLOTDM_PRIV_SIZE,           // dmDriverExtra

            DM_ORIENTATION       |
                DM_PAPERSIZE     |
                // DM_PAPERLENGTH   |
                // DM_PAPERWIDTH    |
                DM_SCALE         |
                DM_COPIES        |
                // DM_DEFAULTSOURCE |   // Reserved one, must zero
                DM_PRINTQUALITY  |
                DM_COLOR         |
                // DM_DUPLEX        |
                // DM_YRESOLUTION   |
                // DM_TTOPTION      |
                // DM_COLLATE       |
                DM_FORMNAME,

            DMORIENT_PORTRAIT,          // dmOrientation
            DMPAPER_LETTER,             // dmPaperSize
            2794,                       // dmPaperLength
            2159,                       // dmPaperWidth
            100,                        // dmScale
            1,                          // dmCopies
            0,                          // dmDefaultSource  - RESERVED = 0
            DMRES_HIGH,                 // dmPrintQuality
            DMCOLOR_COLOR,              // dmColor
            DMDUP_SIMPLEX,              // dmDuplex
            0,                          // dmYResolution
            0,                          // dmTTOption
            DMCOLLATE_FALSE,            // dmCollate
            TEXT("Letter"),             // dmFormName - depends on country
            0,                          // dmUnusedPadding   - DISPLAY ONLY
            0,                          // dmBitsPerPel      - DISPLAY ONLY
            2100,                       // dmPelsWidth       - DISPLAY ONLY
            2970,                       // dmPelsHeight      - DISPLAY ONLY
            0,                          // dmDisplayFlags    - DISPLAY ONLY
            0                           // dmDisplayFrequency- DISPLAY ONLY
        },

        PLOTDM_PRIV_ID,                 // PrivID
        PLOTDM_PRIV_VER,                // PrivVer
        PDMF_FILL_TRUETYPE,             // default advanced dialog box

        {
            sizeof(COLORADJUSTMENT),    // caSize
            0,                          // caFlags
            ILLUMINANT_DEVICE_DEFAULT,  // caIlluminantIndex
            10000,                      // caRedGamma
            10000,                      // caGreenGamma
            10000,                      // caBlueGamma
            REFERENCE_BLACK_MIN,        // caReferenceBlack
            REFERENCE_WHITE_MAX,        // caReferenceWhite
            0,                          // caContrast
            0,                          // caBrightness
            0,                          // caColorfulness
            0                           // caRedGreenTint
        }
    };



#define DEFAULT_COUNTRY             CTRY_UNITED_STATES


#if HAS_GETREGDATA

static const WCHAR  wszCountryKey[]   = L"Control Panel\\International";
static const WCHAR  wszCountryValue[] = L"iCountry";

#endif



BOOL
IsA4PaperDefault(
    VOID
    )

/*++

Routine Description:

    This function determine if the machine user is using the letter or A4
    paper as default based on the country code

Arguments:

    NONE


Return Value:

    BOOL true if the country default paper is A4, else LETTER

Author:

    23-Nov-1993 Tue 17:50:25 created  -by-  DC

    02-Feb-1994 Wed 03:01:12 updated  -by-  DC
        re-written so that we do open registry for the international data
        ourself, and we will make sure we close the all the keys opened by
        this function, so the system can unload the registry when the user
        log off.

Revision History:


--*/

{
#if HAS_GETREGDATA

    HKEY    hKey;
    LONG    CountryCode = DEFAULT_COUNTRY;
    WCHAR   wszStr[16];


    if (RegOpenKey(HKEY_CURRENT_USER, wszCountryKey, &hKey) == ERROR_SUCCESS) {

        DWORD   Type   = REG_SZ;
        DWORD   RetVal = sizeof(wszStr);

        if (RegQueryValueEx(hKey,
                            (LPTSTR)wszCountryValue,
                            NULL,
                            &Type,
                            (LPBYTE)wszStr,
                            &RetVal) == ERROR_SUCCESS) {

            LPWSTR  pwStop;

            PLOTDBG(DBG_A4DEFAULT, ("IsA4PaperDefault: Country = %s", wszStr));

            CountryCode = wcstoul(wszStr, &pwStop, 10);

        } else {

            PLOTERR(("IsA4PaperDefault: RegQueryValue '%s' FAILED", wszCountryValue));
        }

        RegCloseKey(hKey);

    } else {

        PLOTERR(("IsA4PaperDefault: RegOpenKey '%s' FAILED", wszCountryKey));
    }

    if ((CountryCode == CTRY_UNITED_STATES)             ||
        (CountryCode == CTRY_CANADA)                    ||
        ((CountryCode >= 50) && (CountryCode < 60))     ||
        ((CountryCode >= 500) && (CountryCode < 600))) {

        PLOTDBG(DBG_A4DEFAULT, ("IsA4PaperDefault = No, Use 'LETTER'"));

        return(FALSE);

    } else {

        PLOTDBG(DBG_A4DEFAULT, ("IsA4PaperDefault = Yes"));

        return(TRUE);
    }

#else

    //
    // Use letter size now
    //

    return(FALSE);

#endif  // HAS_GETREGDATA
}




BOOL
IntersectMargin(
    PRECTL  prclDest,
    PRECTL  prclSrc
    )

/*++

Routine Description:

    This function intersect two RECTL data structures which specified margins.

Arguments:

    prclDest    - pointer to the destination RECTL data structure, the result
                  is written back to here

    prclSrc     - pointer to the source RECTL data structure to be intersect
                  with the destination RECTL

Return Value:

    TRUE if source and destination has difference otherwise it return FALSE
    to indicate that two rects are same


Author:

    17-Dec-1993 Fri 14:41:29 updated  -by-  DC
        Add prclDif and compare it correctly

    29-Nov-1993 Mon 20:00:45 created  -by-  DC


Revision History:


--*/

{
#define plSrc   ((PLONG)prclSrc)
#define plDest  ((PLONG)prclDest)

    BOOL    IsDif = FALSE;


    if (prclSrc != prclDest) {

        INT Loop = 4;

        while (Loop--) {

            //
            // We return the one has larger margins
            //

            if (*plSrc > *plDest) {

                IsDif   = TRUE;
                *plDest = *plSrc;
            }

            ++plSrc;
            ++plDest;
        }
    }

    return(IsDif);

#undef plSrc
#undef plDest
}




BOOL
IntersectRECTL(
    PRECTL  prclDest,
    PRECTL  prclSrc
    )

/*++

Routine Description:

    This function intersect two RECTL data structures which specified imageable
    areas.

Arguments:

    prclDest    - pointer to the destination RECTL data structure, the result
                  is written back to here

    prclSrc     - pointer to the source RECTL data structure to be intersect
                  with the destination RECTL

Return Value:

    TRUE if destination is not empty, FALSE if final destination is empty

Author:

    20-Dec-1993 Mon 14:08:02 updated  -by-  DC
        Change return value's meaning as if intersection is not empty

    17-Dec-1993 Fri 14:41:10 updated  -by-  DC
        Add prclDif and compare it correctly

    29-Nov-1993 Mon 19:02:01 created  -by-  DC


Revision History:


--*/

{
    BOOL    IsNULL = FALSE;


    if (prclSrc != prclDest) {

        //
        // For left/top we will set to whichever is larger.
        //

        if (prclDest->left < prclSrc->left) {

            prclDest->left = prclSrc->left;
        }

        if (prclDest->top < prclSrc->top) {

            prclDest->top = prclSrc->top;
        }

        //
        // For right/bottom we will set to whichever is smaller
        //

        if (prclDest->right > prclSrc->right) {

            prclDest->right = prclSrc->right;
        }

        if (prclDest->bottom > prclSrc->bottom) {

            prclDest->bottom = prclSrc->bottom;
        }
    }

    PLOTDBG(DBG_INTERSECTRECTL, ("IntersectRECTL: Dest = (%ld x %ld)",
            prclDest->right-prclDest->left, prclDest->bottom-prclDest->top));

    return((prclDest->right > prclDest->left) &&
           (prclDest->bottom > prclDest->top));
}





BOOL
RotatePaper(
    PSIZEL  pSize,
    PRECTL  pImageArea,
    UINT    RotateMode
    )

/*++

Routine Description:

    This function rotate a paper left 90 degree, right 90 degree or 180 degree
    depends on the RotateMode passed

Arguments:

    pSize       - Pointer to the size of the paper to be rotated

    pImageArea  - Pointer to the RECTL of Imageable area

    RotateMode  - Must be one of RM_L90, RM_R90, RM_180

Return Value:

    No return value, but the pSize, and pImageArea pointed to location will
    be updated.

Author:

    16-Dec-1993 Thu 09:18:33 created  -by-  DC


Revision History:


--*/

{
    SIZEL   Size;
    RECTL   Margin;

    //
    // To be sucessfully rotate the paper to the left 90 degree we must know
    // all four sides margin before we can do anything
    //

    Size          = *pSize;
    Margin.left   = pImageArea->left;
    Margin.top    = pImageArea->top;
    Margin.right  = Size.cx - pImageArea->right;
    Margin.bottom = Size.cy - pImageArea->bottom;

    PLOTASSERT(0, "RotatePaper: cx size too small (%ld)",
                        (Size.cx - Margin.left - Margin.right) > 0, Size.cx);
    PLOTASSERT(0, "RotatePaper: cy size too small (%ld)",
                        (Size.cy - Margin.top - Margin.bottom) > 0, Size.cy);
    PLOTDBG(DBG_ROTPAPER,
            ("RotatePaper(%ld) FROM (%ld x %ld), (%ld, %ld)-(%ld, %ld)",
                        (LONG)RotateMode,
                        pSize->cx, pSize->cy,
                        pImageArea->left,   pImageArea->top,
                        pImageArea->right,  pImageArea->bottom));

    //
    // Now we can pick the right margin/corner for the rotation
    //
    //         cx        Rotate Left 90     Rotate Right 90
    //      +-------+
    //      |   T   |         cy                 cy
    //      |       |    +------------+     +------------+
    //     c|       |    |     R      |     |     L      |
    //     y|       |   c|            |    c|            |
    //      |L     R|   x|            |    x|            |
    //      |       |    |T          B|     |B          T|
    //      |       |    |            |     |            |
    //      |       |    |     L      |     |     R      |
    //      |   B   |    +------------+     +------------+
    //      +-------+
    //

    switch (RotateMode) {

    case RM_L90:

        pSize->cx          = Size.cy;
        pSize->cy          = Size.cx;
        pImageArea->left   = Margin.top;
        pImageArea->top    = Margin.right;
        pImageArea->right  = Size.cy - Margin.bottom;
        pImageArea->bottom = Size.cx - Margin.left;
        break;

    case RM_R90:

        pSize->cx          = Size.cy;
        pSize->cy          = Size.cx;
        pImageArea->left   = Margin.bottom;
        pImageArea->top    = Margin.left;
        pImageArea->right  = Size.cy - Margin.top;
        pImageArea->bottom = Size.cx - Margin.right;
        break;

    case RM_180:

        pImageArea->top    = Margin.bottom;
        pImageArea->bottom = Size.cy - Margin.top;
        break;

    default:

        PLOTERR(("RotatePaper(%ld): Invalid RotateMode passed", RotateMode));
        return(FALSE);
    }

    PLOTDBG(DBG_ROTPAPER,
            ("RotatePaper(%ld) - TO (%ld x %ld), (%ld, %ld)-(%ld, %ld)",
                        (LONG)RotateMode,
                        pSize->cx, pSize->cy,
                        pImageArea->left,   pImageArea->top,
                        pImageArea->right,  pImageArea->bottom));

    return(TRUE);
}





SHORT
GetDefaultPaper(
    PPAPERINFO  pPaperInfo
    )

/*++

Routine Description:

    This function compute the default paper name, size.

Arguments:

    pPaperInfo  - Point to the paper info which will be fill by this function

Return Value:

    It return a SHORT value which specified the standard paper index in as
    DMPAPER_xxx

Author:

    03-Dec-1993 Fri 13:13:42 created  -by-  DC


Revision History:


--*/

{
    SHORT   dmPaperSize;


    pPaperInfo->ImageArea.left =
    pPaperInfo->ImageArea.top  = 0;

    if (IsA4PaperDefault()) {

        dmPaperSize                  = (SHORT)DMPAPER_A4;
        pPaperInfo->Size.cx          =
        pPaperInfo->ImageArea.right  = DMTOSPL(A4_FORM_CX);
        pPaperInfo->Size.cy          =
        pPaperInfo->ImageArea.bottom = DMTOSPL(A4_FORM_CY);

        wcscpy(pPaperInfo->Name, A4_FORM_NAME);

        PLOTDBG(DBG_DEFPAPER, ("Pick 'A4' paper as default"));

    } else {

        dmPaperSize         = (SHORT)DMPAPER_LETTER;
        pPaperInfo->Size.cx = (LONG)_DefPlotDM.dm.dmPaperWidth;
        pPaperInfo->Size.cy = (LONG)_DefPlotDM.dm.dmPaperLength;

        dmPaperSize                  = (SHORT)DMPAPER_LETTER;
        pPaperInfo->Size.cx          =
        pPaperInfo->ImageArea.right  = DMTOSPL(_DefPlotDM.dm.dmPaperWidth);
        pPaperInfo->Size.cy          =
        pPaperInfo->ImageArea.bottom = DMTOSPL(_DefPlotDM.dm.dmPaperLength);

        wcscpy(pPaperInfo->Name, _DefPlotDM.dm.dmFormName);

        PLOTDBG(DBG_DEFPAPER, ("Pick 'Letter' paper as default"));
    }

    PLOTDBG(DBG_DEFPAPER, ("SetDefaultPaper: '%ls' (%ld x %ld)",
                pPaperInfo->Name, pPaperInfo->Size.cx, pPaperInfo->Size.cy));

    return(dmPaperSize);
}




VOID
GetDefaultPlotterForm(
    PPLOTGPC    pPlotGPC,
    PPAPERINFO  pPaperInfo
    )

/*++

Routine Description:

    This function set the default loaded paper on the plotter to the first
    form data list in the PCD data file

Arguments:

    pPlotGPC    - Pointer to the GPC data

    pPaperInfo  - Pointer to the paper info to be returned


Return Value:

    TRUE if sucessful, false if failed

Author:

    03-Feb-1994 Thu 11:37:37 created  -by-  DC


Revision History:


--*/

{
    PFORMSRC    pFS;


    if ((pFS = (PFORMSRC)pPlotGPC->Forms.pData) &&
        (pPlotGPC->Forms.Count)) {

        str2Wstr(pPaperInfo->Name, pFS->Name);

        pPaperInfo->Size             = pFS->Size;
        pPaperInfo->ImageArea.left   = pFS->Margin.left;
        pPaperInfo->ImageArea.top    = pFS->Margin.top;
        pPaperInfo->ImageArea.right  = pFS->Size.cx - pFS->Margin.right;
        pPaperInfo->ImageArea.bottom = pFS->Size.cy - pFS->Margin.bottom;

    } else {

        PLOTERR(("GetDefaultPlotterForm: No FORM DATA in PCD, used country default"));

        GetDefaultPaper(pPaperInfo);
    }
}



VOID
SetDefaultDMForm(
    PPLOTDEVMODE    pPlotDM,
    PFORMSIZE       pCurForm
    )

/*++

Routine Description:

    This function set the default form for the PLOTDEVMODE, these includes
    dmPaperSize, dmPaperWidth, dmPaperLength, dmFormName and set pCurForm
    if pointer is not NULL

Arguments:

    pPlotDM     - Pointer to the PLOTDEVMODE data structure

    pCurForm    - pointer to the FORMSIZE data structure to store current
                  default form set by this function

Return Value:

    VOID


Author:

    01-Dec-1993 Wed 13:44:31 created  -by-  DC


Revision History:


--*/

{
    PAPERINFO   PaperInfo;


    pPlotDM->dm.dmFields      &= ~DM_PAPER_FIELDS;
    pPlotDM->dm.dmFields      |= (DM_FORMNAME | DM_PAPERSIZE);
    pPlotDM->dm.dmPaperSize    = GetDefaultPaper(&PaperInfo);
    pPlotDM->dm.dmPaperWidth   = SPLTODM(PaperInfo.Size.cx);
    pPlotDM->dm.dmPaperLength  = SPLTODM(PaperInfo.Size.cy);

    wcscpy((LPWSTR)pPlotDM->dm.dmFormName, PaperInfo.Name);

    if (pCurForm) {

        pCurForm->Size      = PaperInfo.Size;
        pCurForm->ImageArea = PaperInfo.ImageArea;
    }
}





VOID
SetDefaultPLOTDM(
    HANDLE          hPrinter,
    PPLOTGPC        pPlotGPC,
    LPWSTR          pwDeviceName,
    PPLOTDEVMODE    pPlotDM,
    PFORMSIZE       pCurForm
    )

/*++

Routine Description:

    This function set the default devmode based on the current pPlotGPC

Arguments:

    hPrinter        - Handle to the printer

    pPlotGPC        - our loaded/verified GPC data.

    pwDeviceName    - the device name passed in

    pPlotDM         - Pointer to our ExtDevMode

    pCurForm        - Pointer to the FORMSIZE data structure which will be
                      updated if the pointer is not NULL, the final result of
                      the form size/imagable area selected by the user will
                      be written to here. the form name will be in
                      pPlotDM->dmFormName.

Return Value:

    VOID


Author:

    14-Dec-1993 Tue 20:21:48 updated  -by-  DC
        Update the dmScale based on maximum the device can support

    06-Dec-1993 Mon 12:49:52 updated  -by-  DC
        make sure we turn off the DM_xxx bits if one of those is not valid or
        supported in current plotter

    16-Nov-1993 Tue 13:49:27 created  -by-  DC


Revision History:


--*/

{
    WCHAR   DeviceName[CCHDEVICENAME];


    if (pwDeviceName) {

        _WCPYSTR(DeviceName, pwDeviceName, CCHDEVICENAME);

        //
        // Make sure the PlotGPC's device name is ssync with the pDeviceName
        // passed
        //

        WStr2Str(pPlotGPC->DeviceName, DeviceName);

        PLOTDBG(DBG_DEFDEVMODE, ("PlotGPC DeviceName=%hs\npwDeviceName=%ls",
                            pPlotGPC->DeviceName, pwDeviceName));

    } else {

        PLOTERR(("No DeviceName passed, using GPC's '%hs'",
                                                    pPlotGPC->DeviceName));

        str2Wstr(DeviceName, pPlotGPC->DeviceName);
    }

    //
    // Make a default copy first then copy device name down
    //

    CopyMemory(pPlotDM, &_DefPlotDM, sizeof(PLOTDEVMODE));

    WCPYFIELDNAME(pPlotDM->dm.dmDeviceName, DeviceName);

    //
    // We must turn off the DM_xxx bits in dmFields if we do not support it,
    // look at default fields we copy down then update it
    //

    if (pPlotGPC->MaxScale) {

        if ((WORD)pPlotDM->dm.dmScale > pPlotGPC->MaxScale) {

            pPlotDM->dm.dmScale = (SHORT)pPlotGPC->MaxScale;
        }

    } else {

        pPlotDM->dm.dmFields &= ~DM_SCALE;
    }

    if (pPlotGPC->MaxCopies <= 1) {

        pPlotDM->dm.dmFields &= ~DM_COPIES;
    }

    if (!(pPlotGPC->MaxQuality)) {

        pPlotDM->dm.dmFields &= ~DM_PRINTQUALITY;
    }

    //
    // DEFAULT 50% quality for byte align plotter (DJ 600) to do ROP right
    //

    if (pPlotGPC->Flags & PLOTF_RASTERBYTEALIGN) {

        pPlotDM->dm.dmPrintQuality = DMRES_LOW;

        PLOTWARN(("SetDefaultPLOTDM: HACK Default Qaulity = DMRES_LOW"));
    }

    if (!(pPlotGPC->Flags & PLOTF_COLOR)) {

        if (pPlotGPC->Flags & PLOTF_RASTER) {

            pPlotDM->dm.dmFields &= ~DM_COLOR;
            pPlotDM->dm.dmColor   = DMCOLOR_MONOCHROME;

        } else {

            PLOTASSERT(0,
                       "SetDefaultPLOTDM: The Pen Ploter CANNOT be MONO.",
                       (pPlotGPC->Flags & PLOTF_COLOR), 0);

            pPlotGPC->Flags |= PLOTF_COLOR;
        }
    }

    //
    // Set default form name based on the country
    //

    SetDefaultDMForm(pPlotDM, pCurForm);

}





DWORD
MergePLOTDM(
    HANDLE          hPrinter,
    PPLOTGPC        pPlotGPC,
    PPLOTDEVMODE    pPlotDMFrom,
    PPLOTDEVMODE    pPlotDMTo,
    PFORMSIZE       pCurForm
    )

/*++

Routine Description:

    This function merge and validate the pPlotDMTo from pPlotDMFrom. The
    PlotDMOut must valid


Arguments:

    hPrinter        - Handle to the printer to be checked

    pPlotGPC        - The plotter's GPC data loaded from the file

    pPlotDMFrom     - pointer to the input PLOTDEVMODE data structure, if can
                      be NULL

    pPlotDMTo       - Pointer to the output PLOTDEVMODE data structure, if
                      pPlotDMFrom is NULL then a default PLOTDEVMODE is
                      returned

    pCurForm        - Pointer to the FORMSIZE data structure which will be
                      updated if the pointer is not NULL, the final result of
                      the form size/imagable area selected by the user will
                      be written to here. the form name will be in
                      pPlotDM->dmFormName.

Return Value:

    the return value is a DWORD dmField error code which specified dmFields
    are invalid (DM_xxxxx in wingdi.h) if the return value has any DM_INV_xxx
    bits set then it should raised an error to the user.

    if return value is 0 then function sucessful


Author:

    25-Oct-1994 Tue 13:32:18 created  -by-  DC


Revision History:


--*/

{
    PLOTDEVMODE     PlotDMIn;
    ENUMFORMPARAM   EFP;
    DWORD           dmErrFields = 0;
    SIZEL           PaperSize;

    //
    // First: set the default PLOTDEVMODE for the output then from there
    //        validate/settting from input devmode, if pwDeviceName passed as
    //        NULL then it assume that pPlotDMTo alreay set and validated
    //
    // If we have invalid input devmode then this it is
    //

    if ((!pPlotDMFrom) || (!pPlotDMTo) || (!pPlotGPC)) {

        return(0);
    }

    //
    // Do some conversion here if necessary, first, copy the output one
    //

    CopyMemory(&PlotDMIn, pPlotDMTo, sizeof(PLOTDEVMODE));
    ConvertDevmode((PDEVMODE) pPlotDMFrom, (PDEVMODE) &PlotDMIn);


    PLOTDBG(DBG_SHOWDEVMODE,
                ("--------------- Input DEVMODE Setting -------------------"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmDeviceName = %ls",
                (DWORD_PTR)PlotDMIn.dm.dmDeviceName));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmSpecVersion = %04lx",
                (DWORD)PlotDMIn.dm.dmSpecVersion));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmDriverVersion = %04lx",
                (DWORD)PlotDMIn.dm.dmDriverVersion));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmSize = %0ld (%ld)",
                (DWORD)PlotDMIn.dm.dmSize, sizeof(DEVMODE)));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmDriverExtra = %ld (%ld)",
                (DWORD)PlotDMIn.dm.dmDriverExtra, PLOTDM_PRIV_SIZE));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmFields = %08lx",
                (DWORD)PlotDMIn.dm.dmFields));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmOrientation = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmOrientation,
                (PlotDMIn.dm.dmFields & DM_ORIENTATION) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmPaperSize = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmPaperSize,
                (PlotDMIn.dm.dmFields & DM_PAPERSIZE) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmPaperLength = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmPaperLength,
                (PlotDMIn.dm.dmFields & DM_PAPERLENGTH) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmPaperWidth = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmPaperWidth,
                (PlotDMIn.dm.dmFields & DM_PAPERWIDTH) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmScale = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmScale,
                (PlotDMIn.dm.dmFields & DM_SCALE) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmCopies = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmCopies,
                (PlotDMIn.dm.dmFields & DM_COPIES) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmPrintQuality = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmPrintQuality,
                (PlotDMIn.dm.dmFields & DM_PRINTQUALITY) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmColor = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmColor,
                (PlotDMIn.dm.dmFields & DM_COLOR) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmFormName = %ls (%hs)",
                (DWORD_PTR)PlotDMIn.dm.dmFormName,
                (PlotDMIn.dm.dmFields & DM_FORMNAME) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: Fill Truetype Font = %hs",
                (PlotDMIn.Flags & PDMF_FILL_TRUETYPE) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: Plot On the Fly = %hs",
                (PlotDMIn.Flags & PDMF_PLOT_ON_THE_FLY) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("---------------------------------------------------------"));

    //
    // Statring checking the dmFields, *** REMEMBER: The orientation must
    // check before the checking the paper/form
    //

    if (PlotDMIn.dm.dmFields & DM_ORIENTATION) {

        switch (PlotDMIn.dm.dmOrientation) {

        case DMORIENT_PORTRAIT:
        case DMORIENT_LANDSCAPE:

            pPlotDMTo->dm.dmOrientation  = PlotDMIn.dm.dmOrientation;
            pPlotDMTo->dm.dmFields      |= DM_ORIENTATION;
            break;

        default:

            PLOTERR(("ValidatePLOTDM: Invalid dmOrientation = %ld",
                                            (LONG)PlotDMIn.dm.dmOrientation));
            dmErrFields |= DM_ORIENTATION;
            break;
        }
    }

    //
    // Validate form name so we have correct data, assume error first
    //

    dmErrFields |= (DWORD)(PlotDMIn.dm.dmFields & DM_PAPER_FIELDS);

    if (((PlotDMIn.dm.dmFields & DM_PAPER_CUSTOM) == DM_PAPER_CUSTOM)   &&
        ((PlotDMIn.dm.dmPaperSize == DMPAPER_USER)                      ||
         (PlotDMIn.dm.dmPaperSize == 0))                                &&
        (PaperSize.cx = DMTOSPL(PlotDMIn.dm.dmPaperWidth))              &&
        (PaperSize.cy = DMTOSPL(PlotDMIn.dm.dmPaperLength))             &&
        (PaperSize.cx >= MIN_SPL_FORM_CX)                                   &&
        (PaperSize.cy >= MIN_SPL_FORM_CY)                                   &&
        (((PaperSize.cx <= pPlotGPC->DeviceSize.cx)              &&
          (PaperSize.cy <= pPlotGPC->DeviceSize.cy))        ||
         ((PaperSize.cy <= pPlotGPC->DeviceSize.cx)              &&
          (PaperSize.cx <= pPlotGPC->DeviceSize.cy)))) {

        //
        // First choice, this is what the caller wants, we need to validate
        // for this device, since the size may be larger then device can
        // handle
        //

        pPlotDMTo->dm.dmPaperWidth   = PlotDMIn.dm.dmPaperWidth;
        pPlotDMTo->dm.dmPaperLength  = PlotDMIn.dm.dmPaperLength;
        pPlotDMTo->dm.dmFields      &= ~DM_PAPER_FIELDS;
        pPlotDMTo->dm.dmFields      |= DM_PAPER_CUSTOM;
        pPlotDMTo->dm.dmPaperSize    = DMPAPER_USER;
        pPlotDMTo->dm.dmFormName[0]  = L'\0';

        if (pCurForm) {

            //
            // This one is full imageable area as the widht/height
            //

            pCurForm->ImageArea.left =
            pCurForm->ImageArea.top  = 0;

            pCurForm->Size.cx          =
            pCurForm->ImageArea.right  = PaperSize.cx;
            pCurForm->Size.cy          =
            pCurForm->ImageArea.bottom = PaperSize.cy;
        }

        dmErrFields &= ~DM_PAPER_FIELDS;    // Fine, no error

        PLOTDBG(DBG_CURFORM,("ValidateSetPLOTDM: FORM=USER <%ld> (%ld x %ld)",
                    PlotDMIn.dm.dmPaperSize, PaperSize.cx, PaperSize.cy));

    } else if ((PlotDMIn.dm.dmFields & (DM_PAPERSIZE | DM_FORMNAME))    &&
               (EFP.pPlotDM = pPlotDMTo)                                    &&
               (EFP.pPlotGPC = pPlotGPC)                                    &&
               (PlotEnumForms(hPrinter, NULL, &EFP))) {

        FORM_INFO_1 *pFI1;
        SHORT       PaperSize;
        BOOL        Found = FALSE;

        //
        // Firstable check PaperSize index and if not found then check formname
        //

        if ((PlotDMIn.dm.dmFields & DM_PAPERSIZE)                       &&
            ((PaperSize = PlotDMIn.dm.dmPaperSize) >= DMPAPER_FIRST)    &&
            (PaperSize <= (SHORT)EFP.Count)                                 &&
            (pFI1 = EFP.pFI1Base + (PaperSize - DMPAPER_FIRST))             &&
            (pFI1->Flags & FI1F_VALID_SIZE)) {

            //
            // Whu..., this guy really pick a right index
            //

            Found = TRUE;

            PLOTDBG(DBG_CURFORM,("ValidateSetPLOTDM: Fount dmPaperSize=%ld",
                                    PlotDMIn.dm.dmPaperSize));

        } else if (PlotDMIn.dm.dmFields & DM_FORMNAME) {

            //
            // Now go through all the formname trouble
            //

            pFI1      = EFP.pFI1Base;
            PaperSize = DMPAPER_FIRST;

            while (EFP.Count--) {

                if ((pFI1->Flags & FI1F_VALID_SIZE) &&
                    (!wcscmp(pFI1->pName, PlotDMIn.dm.dmFormName))) {

                    PLOTDBG(DBG_CURFORM,("ValidateSetPLOTDM: Found dmFormName=%s",
                                            PlotDMIn.dm.dmFormName));

                    Found = TRUE;

                    break;
                }

                ++PaperSize;
                ++pFI1;
            }
        }

        if (Found) {

            pPlotDMTo->dm.dmFields      &= ~DM_PAPER_FIELDS;
            pPlotDMTo->dm.dmFields      |= (DM_FORMNAME | DM_PAPERSIZE);
            pPlotDMTo->dm.dmPaperSize    = PaperSize;
            pPlotDMTo->dm.dmPaperWidth   = SPLTODM(pFI1->Size.cx);
            pPlotDMTo->dm.dmPaperLength  = SPLTODM(pFI1->Size.cy);

            WCPYFIELDNAME(pPlotDMTo->dm.dmFormName, pFI1->pName);

            PLOTDBG(DBG_CURFORM,("FI1 [%ld]: (%ld x %ld), (%ld, %ld)-(%ld, %ld)",
                        (LONG)pPlotDMTo->dm.dmPaperSize,
                        pFI1->Size.cx, pFI1->Size.cy,
                        pFI1->ImageableArea.left,  pFI1->ImageableArea.top,
                        pFI1->ImageableArea.right, pFI1->ImageableArea.bottom));

            if (pCurForm) {

                pCurForm->Size      = pFI1->Size;
                pCurForm->ImageArea = pFI1->ImageableArea;
            }

            dmErrFields &= ~DM_PAPER_FIELDS;    // Fine, no error
        }

        //
        // Free up the memory used
        //

        LocalFree((HLOCAL)EFP.pFI1Base);
    }

    if ((PlotDMIn.dm.dmFields & DM_SCALE) &&
        (pPlotGPC->MaxScale)) {

        if ((PlotDMIn.dm.dmScale > 0) &&
            ((WORD)PlotDMIn.dm.dmScale <= pPlotGPC->MaxScale)) {

            pPlotDMTo->dm.dmScale   = PlotDMIn.dm.dmScale;
            pPlotDMTo->dm.dmFields |= DM_SCALE;

        } else {

            PLOTERR(("ValidatePLOTDM: Invalid dmScale = %ld [%ld]",
                    (LONG)PlotDMIn.dm.dmScale, (LONG)pPlotGPC->MaxScale));
            dmErrFields |= DM_SCALE;
        }
    }

    if (PlotDMIn.dm.dmFields & DM_COPIES) {

        if ((PlotDMIn.dm.dmCopies > 0) &&
            ((LONG)PlotDMIn.dm.dmCopies <= (LONG)pPlotGPC->MaxCopies)) {

            pPlotDMTo->dm.dmCopies  = PlotDMIn.dm.dmCopies;
            pPlotDMTo->dm.dmFields |= DM_COPIES;

        } else {

            PLOTERR(("ValidatePLOTDM: Invalid dmCopies = %ld [%ld]",
                    (LONG)PlotDMIn.dm.dmCopies, (LONG)pPlotGPC->MaxCopies));
            dmErrFields |= DM_COPIES;
        }
    }

    if (PlotDMIn.dm.dmFields & DM_PRINTQUALITY) {

        dmErrFields |= DM_PRINTQUALITY;     // assume error, proven otherwise

        if (pPlotGPC->MaxQuality) {

            switch (PlotDMIn.dm.dmPrintQuality) {

            case DMRES_DRAFT:
            case DMRES_LOW:
            case DMRES_MEDIUM:
            case DMRES_HIGH:

                dmErrFields                   &= ~DM_PRINTQUALITY;
                pPlotDMTo->dm.dmPrintQuality  = PlotDMIn.dm.dmPrintQuality;
                pPlotDMTo->dm.dmFields       |= DM_PRINTQUALITY;
                break;
            }
        }

        if (dmErrFields & DM_PRINTQUALITY) {

            PLOTERR(("ValidatePLOTDM: Invalid dmPrintQuality = %ld [%ld]",
                                        (LONG)PlotDMIn.dm.dmPrintQuality,
                                        (LONG)pPlotGPC->MaxQuality));
        }
    }

    if (PlotDMIn.dm.dmFields & DM_COLOR) {

        dmErrFields |= DM_COLOR;            // assume error, proven otherwise

        if (pPlotGPC->Flags & PLOTF_COLOR) {

            switch (PlotDMIn.dm.dmColor) {

            case DMCOLOR_MONOCHROME:

                if (!(pPlotGPC->Flags & PLOTF_RASTER)) {

                    PLOTERR(("ValidatePLOTDM: Cannot Set Pen Plotter to MONO"));
                    break;
                }

            case DMCOLOR_COLOR:

                pPlotDMTo->dm.dmColor   = PlotDMIn.dm.dmColor;
                pPlotDMTo->dm.dmFields |= DM_COLOR;
                dmErrFields             &= ~DM_COLOR;
                break;
            }

        } else if (PlotDMIn.dm.dmColor == DMCOLOR_MONOCHROME) {

            dmErrFields &= ~DM_COLOR;
        }

        if (dmErrFields & DM_COLOR) {

            PLOTERR(("ValidatePLOTDM: Invalid dmColor = %ld [%hs]",
                    (LONG)PlotDMIn.dm.dmColor,
                    (pPlotGPC->Flags & PLOTF_COLOR) ? "COLOR" : "MONO"));
        }
    }

    //
    // Any other dmFields we just skip because we do not have that caps, now
    // check if they have correct EXTDEVMODE stuff
    //

    if ((PlotDMIn.dm.dmDriverExtra == PLOTDM_PRIV_SIZE) &&
        (PlotDMIn.PrivID == PLOTDM_PRIV_ID)             &&
        (PlotDMIn.PrivVer == PLOTDM_PRIV_VER)) {

        pPlotDMTo->Flags = (DWORD)(PlotDMIn.Flags & PDMF_ALL_BITS);
        pPlotDMTo->ca    = PlotDMIn.ca;

        if (pPlotGPC->Flags & PLOTF_RASTER) {

            pPlotDMTo->Flags |= PDMF_FILL_TRUETYPE;

        } else {

            //
            // Non raster device does not have plot on the fly mode
            //

            pPlotDMTo->Flags &= ~PDMF_PLOT_ON_THE_FLY;
        }

        if (!ValidateColorAdj(&(pPlotDMTo->ca))) {

            dmErrFields |= DM_INV_PLOTPRIVATE;

            PLOTERR(("ValidatePLOTDM: Invalid coloradjusment data"));
        }
    }

    return(dmErrFields);

}




DWORD
ValidateSetPLOTDM(
    HANDLE          hPrinter,
    PPLOTGPC        pPlotGPC,
    LPWSTR          pwDeviceName,
    PPLOTDEVMODE    pPlotDMIn,
    PPLOTDEVMODE    pPlotDMOut,
    PFORMSIZE       pCurForm
    )

/*++

Routine Description:

    This function set and validate the pPlotDMOut from pPlotDMIn
    (if not null and valid)

Arguments:

    hPrinter        - Handle to the printer to be checked

    pPlotGPC        - The plotter's GPC data loaded from the file

    pwDeviceName    - Device Name to be put into dmDeviceName, if NULL then
                      the device name is set from pPlotGPC->DeviceName

    pPlotDMIn       - pointer to the input PLOTDEVMODE data structure, if can
                      be NULL

    pPlotDMOut      - Pointer to the output PLOTDEVMODE data structure, if
                      pPlotDMIn is NULL then a default PLOTDEVMODE is returned

    pCurForm        - Pointer to the FORMSIZE data structure which will be
                      updated if the pointer is not NULL, the final result of
                      the form size/imagable area selected by the user will
                      be written to here. the form name will be in
                      pPlotDM->dmFormName.

Return Value:

    the return value is a DWORD dmField error code which specified dmFields
    are invalid (DM_xxxxx in wingdi.h) if the return value has any DM_INV_xxx
    bits set then it should raised an error to the user.

    if return value is 0 then function sucessful

Author:

    23-Nov-1993 Tue 10:08:50 created  -by-  DC

    15-Dec-1993 Wed 21:27:52 updated  -by-  DC
        Fixed bug which compare dmPaperWidth/Length to MIN_SPL_FORM_CX

    18-Dec-1993 Sat 03:57:24 updated  -by-  DC
        Fixed bug which reset dmFields when we checking DM_PAPERxxx and
        DM_FORMNAME, this turn off DM_ORIENTATION fields which let the
        orientation setting never stick.

        Also change how this fucntion set the paper fields, this function now
        only set DM_FORMNAME upon returned if the dmPaperSize getting larger
        then DMPAPER_LAST, otherwise it set DM_FORMNAME | DM_PAPERSIZE

    12-Apr-1994 Tue 15:07:24 updated  -by-  DC
        Make smaller spec version printable

    25-Oct-1994 Tue 13:41:03 updated  -by-  DC
        Change to have default as current Printer Properties setting first,


Revision History:


--*/

{
    DWORD   dmErrFields = 0;


    PLOTASSERT(1, "ValidatePLOTDM: NULL pPlotDMOut", pPlotDMOut, 0);
    PLOTASSERT(1, "ValidatePLOTDM: NULL pPlotGPC", pPlotGPC, 0);

    if ((pPlotDMOut) || (pPlotGPC)) {

        PPRINTER_INFO_2 pPrinter2 = NULL;
        DWORD           cbNeed;
        DWORD           cbRet;


        //
        // First: set the default PLOTDEVMODE for the output then from there
        //        validate/settting from input devmode, if pwDeviceName passed
        //        as NULL then it assume that pPlotDMOut alreay set and
        //        validated
        //

        if (pwDeviceName) {

            SetDefaultPLOTDM(hPrinter,
                             pPlotGPC,
                             pwDeviceName,
                             pPlotDMOut,
                             pCurForm);

            PLOTDBG(DBG_DEFDEVMODE,
                    ("ValidateSetPLOTDM: Set Default PLOTDM DeviceName=%ls", pwDeviceName));
        }

        //
        // Now see if we can get the current printman devmode setting as default
        //

        cbNeed =
        cbRet  = 0;

        if ((!xGetPrinter(hPrinter, 2, NULL, 0, &cbNeed))                   &&
            (xGetLastError() == ERROR_INSUFFICIENT_BUFFER)                  &&
            (pPrinter2 = LocalAlloc(LMEM_FIXED, cbNeed))                    &&
            (xGetPrinter(hPrinter, 2, (LPBYTE)pPrinter2, cbNeed, &cbRet))   &&
            (cbNeed == cbRet)                                               &&
            (pPrinter2->pDevMode)) {

            PLOTDBG(DBG_DEFDEVMODE, ("ValidateSetPLOTDM: Got the PrintMan DEVMODE"));

            dmErrFields = MergePLOTDM(hPrinter,
                                      pPlotGPC,
                                      (PPLOTDEVMODE)pPrinter2->pDevMode,
                                      pPlotDMOut,
                                      pCurForm);

        } else {

            PLOTWARN(("ValidateSetPLOTDM: CANNOT get the PrintMan's DEVMODE"));
            PLOTWARN(("pPrinter2=%08lx, pDevMode=%08lx, cbNeed=%ld, cbRet=%ld, LastErr=%ld",
                        pPrinter2, (pPrinter2) ? pPrinter2->pDevMode : 0,
                        cbNeed, cbRet, xGetLastError()));
        }

        if (pPrinter2) {

            LocalFree((HLOCAL)pPrinter2);
        }

        //
        // Now the pPlotDMOut is validated, merge it with user's request
        //

        if (pPlotDMIn) {

            dmErrFields = MergePLOTDM(hPrinter,
                                      pPlotGPC,
                                      pPlotDMIn,
                                      pPlotDMOut,
                                      pCurForm);
        }
    }

    return(dmErrFields);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\lib\regdata.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    regdata.c


Abstract:

    This module contains all registry data save/retrieve function for the
    printer properties


Author:

    30-Nov-1993 Tue 00:17:47 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgRegData

#define DBG_GETREGDATA      0x00000001
#define DBG_SETREGDATA      0x00000002

DEFINE_DBGVAR(0);


//
// Local definition
//

typedef struct _PLOTREGKEY {
        LPWSTR  pwKey;
        DWORD   Size;
        } PLOTREGKEY, *PPLOTREGKEY;

PLOTREGKEY  PlotRegKey[] = {

        { L"ColorInfo",     sizeof(COLORINFO)   },
        { L"DevPelsDPI",    sizeof(DWORD)       },
        { L"HTPatternSize", sizeof(DWORD)       },
        { L"InstalledForm", sizeof(PAPERINFO)   },
        { L"PtrPropData",   sizeof(PPDATA)      },
        { L"IndexPenData",  sizeof(BYTE)        },
        { L"PenData",       sizeof(PENDATA)     }
    };


#define MAX_PEN_DIGITS      6


LPWSTR
GetPenDataKey(
    LPWSTR  pwBuf,
    WORD    PenNum
    )

/*++

Routine Description:

    This fucntion composed the PenData%ld string as wsprintf does


Arguments:

    pwBuf   - Where data to be stored

    PenNum  - Pen number to be appended


Return Value:

    VOID


Author:

    24-Oct-1995 Tue 15:06:17 created  -by-  DC


Revision History:


--*/

{
    LPWSTR  pwSrc;
    LPWSTR  pwDst;
    WCHAR   wNumBuf[MAX_PEN_DIGITS + 1];

    //
    // Fristable copy the string
    //

    pwSrc = PlotRegKey[PRKI_PENDATA1].pwKey;
    pwDst = pwBuf;

    while (*pwDst++ = *pwSrc++);

    //
    // We need to back one, since we also copy the NULL
    //

    --pwDst;

    //
    // conver the number to string, remember the 0 case and always end with
    // a NULL
    //

    pwSrc  = &wNumBuf[MAX_PEN_DIGITS];
    *pwSrc = (WCHAR)0;

    do {

        *(--pwSrc)  = (WCHAR)((PenNum % 10) + L'0');

    } while (PenNum /= 10);

    //
    // Copy the number string now
    //

    while (*pwDst++ = *pwSrc++);

    return(pwBuf);
}



BOOL
GetPlotRegData(
    HANDLE  hPrinter,
    LPBYTE  pData,
    DWORD   RegIdx
    )

/*++

Routine Description:

    This function retrieve from registry to the pData

Arguments:

    hPrinter    - Handle to the printer interested

    pData       - Pointer to the data area buffer, it must large enough

    RegIdx      - One of the PRKI_xxxx in LOWORD(Index), HIWORD(Index)
                  specified total count for the PENDATA set


Return Value:

    TRUE if sucessful, FALSE if failed,


Author:

    06-Dec-1993 Mon 22:22:47 created  -by-  DC

    10-Dec-1993 Fri 01:13:14 updated  -by-  DC
        Fixed nesty problem in spooler of GetPrinterData which if we passed
        a pbData and cb but if it cannot get any data then it will clear all
        our buffer, this is not we expected (we expected it just return error
        rather clear our buffer).  Now we do extended test before we really
        go get the data. The other problem is, if we set pbData = NULL then
        spooler always have excption happened even we pass &cb as NULL also.


Revision History:


--*/

{
    PPLOTREGKEY pPRK;
    LONG        lRet;
    DWORD       cb;
    DWORD       Type;
    WCHAR       wBuf[32];
    PLOTREGKEY  PRK;
    UINT        Index;


    Index = LOWORD(RegIdx);

    PLOTASSERT(0, "GetPlotRegData: Invalid PRKI_xxx Index %ld",
                                Index <= PRKI_LAST, Index);


    if (Index >= PRKI_PENDATA1) {

        UINT    cPenData;

        if ((cPenData = (UINT)HIWORD(RegIdx)) >= MAX_PENPLOTTER_PENS) {

            PLOTERR(("GetPlotRegData: cPenData too big %ld (Max=%ld)",
                                    cPenData, MAX_PENPLOTTER_PENS));

            cPenData = MAX_PENPLOTTER_PENS;
        }

        PRK.pwKey = GetPenDataKey(wBuf, (WORD)(Index - PRKI_PENDATA1 + 1));
        PRK.Size  = (DWORD)sizeof(PENDATA) * (DWORD)cPenData;
        pPRK      = &PRK;

    } else {

        pPRK = (PPLOTREGKEY)&PlotRegKey[Index];
    }

    //
    // We must do following sequence or if an error occurred then the pData
    // will be filled with ZEROs
    //
    //  1. Set Type/cb to invalid value
    //  1. query the type/size of the keyword, (if more data available)
    //  2. and If size is exact as we want
    //  3. and if the type is as we want (REG_BINARY)
    //  4. assume data valid then query it
    //

    Type = 0xffffffff;
    cb   = 0;

    if ((lRet = xGetPrinterData(hPrinter,
                               pPRK->pwKey,
                               &Type,
                               (LPBYTE)pData,
                               0,
                               &cb)) != ERROR_MORE_DATA) {

        if (lRet == ERROR_FILE_NOT_FOUND) {

            PLOTWARN(("GetPlotRegData: GetPrinterData(%ls) not found",
                     pPRK->pwKey));

        } else {

            PLOTERR(("GetPlotRegData: 1st GetPrinterData(%ls) failed, Error=%ld",
                                pPRK->pwKey, lRet));
        }

    } else if (cb != pPRK->Size) {

        PLOTERR(("GetPlotRegData: GetPrinterData(%ls) Size != %ld (%ld)",
                    pPRK->pwKey, pPRK->Size, cb));

    } else if (Type != REG_BINARY) {

        PLOTERR(("GetPlotRegData: GetPrinterData(%ls) Type != REG_BINARY (%ld)",
                    pPRK->pwKey, Type));

    } else if ((lRet = xGetPrinterData(hPrinter,
                                      pPRK->pwKey,
                                      &Type,
                                      (LPBYTE)pData,
                                      pPRK->Size,
                                      &cb)) == NO_ERROR) {

        PLOTDBG(DBG_GETREGDATA, ("READ '%ws' REG Data: Type=%ld, %ld bytes",
                                        pPRK->pwKey, Type, cb));
        return(TRUE);

    } else {

        PLOTERR(("GetPlotRegData: 2nd GetPrinterData(%ls) failed, Error=%ld",
                                    pPRK->pwKey, lRet));
    }

    return(FALSE);
}



BOOL
UpdateFromRegistry(
    HANDLE      hPrinter,
    PCOLORINFO  pColorInfo,
    LPDWORD     pDevPelsDPI,
    LPDWORD     pHTPatSize,
    PPAPERINFO  pCurPaper,
    PPPDATA     pPPData,
    LPBYTE      pIdxPlotData,
    DWORD       cPenData,
    PPENDATA    pPenData
    )

/*++

Routine Description:

    This function take hPrinter and read the printer properties from the
    registry, if sucessful then it update to the pointer supplied

Arguments:

    hPrinter        - The printer it interested

    pColorInfo      - Pointer to the COLORINFO data structure

    pDevPelsDPI     - Pointer to the DWORD for Device Pels per INCH

    pHTPatSize      - Poineer to the DWORD for halftone patterns size

    pCurPaper       - Pointer to the PAPERINFO data structure for update

    pPPData         - Pointer to the PPDATA data structure

    pIdxPlotData    - Pointer to the BYTE which have current PlotData index

    cPenData        - count of PENDATA to be updated

    pPenData        - Pointer to the PENDATA data structure


Return Value:

    return TRUE if it read sucessful from the registry else FALSE, for each of
    the data pointer passed it will try to read from registry, if a NULL
    pointer is passed then that registry is skipped.

    if falied, the pCurPaper will be set to default

Author:

    30-Nov-1993 Tue 14:54:33 created  -by-  DC

    02-Feb-1994 Wed 01:40:07 updated  -by-  DC
        Fixed &pDevPelsDPI, &pHTPatSize typo to pDevPelsDPI, pHTPatSize.

    19-May-1994 Thu 18:09:06 updated  -by-  DC
        Do not save back if something go wrong


Revision History:


--*/

{
    BOOL    Ok = TRUE;
    BYTE    bData;


    //
    // In turn get each of the data from registry, the GetPlotRegData will
    // not update the data if read failed
    //

    if (pColorInfo) {

        if (!GetPlotRegData(hPrinter, (LPBYTE)pColorInfo, PRKI_CI)) {

            Ok = FALSE;
        }
    }

    if (pDevPelsDPI) {

        if (!GetPlotRegData(hPrinter, (LPBYTE)pDevPelsDPI, PRKI_DEVPELSDPI)) {

            Ok = FALSE;
        }
    }

    if (pHTPatSize) {

        if (!GetPlotRegData(hPrinter, (LPBYTE)pHTPatSize, PRKI_HTPATSIZE)) {

            Ok = FALSE;
        }
    }

    if (pCurPaper) {

        if (!GetPlotRegData(hPrinter, (LPBYTE)pCurPaper, PRKI_FORM)) {

            Ok = FALSE;
        }
    }

    if (pPPData) {

        if (!GetPlotRegData(hPrinter, (LPBYTE)pPPData, PRKI_PPDATA)) {

            Ok = FALSE;
        }

        pPPData->Flags &= PPF_ALL_BITS;
    }

    if (pIdxPlotData) {

        if ((!GetPlotRegData(hPrinter, &bData, PRKI_PENDATA_IDX)) ||
            (bData >= PRK_MAX_PENDATA_SET)) {

            bData = 0;
            Ok    = FALSE;
        }

        *pIdxPlotData = bData;
    }

    if ((cPenData) && (pPenData)) {

        WORD    IdxPen;

        //
        // First is get the current pendata selection index
        //

        if ((IdxPen = LOWORD(cPenData)) >= PRK_MAX_PENDATA_SET) {

            if (!pIdxPlotData) {

                if ((!GetPlotRegData(hPrinter, &bData, PRKI_PENDATA_IDX)) ||
                    (bData >= PRK_MAX_PENDATA_SET)) {

                    bData = 0;
                }
            }

            IdxPen = (WORD)bData;
        }

        cPenData = MAKELONG(IdxPen + PRKI_PENDATA1, HIWORD(cPenData));

        if (!GetPlotRegData(hPrinter, (LPBYTE)pPenData, cPenData)) {

            Ok = FALSE;
        }
    }

    return(Ok);
}


#ifdef UMODE


BOOL
SetPlotRegData(
    HANDLE  hPrinter,
    LPBYTE  pData,
    DWORD   RegIdx
    )

/*++

Routine Description:

    This function save pData to to the registry

Arguments:

    hPrinter    - Handle to the printer interested

    pData       - Pointer to the data area buffer, it must large enough

    RegIdx      - One of the PRKI_xxxx in LOWORD(Index), HIWORD(Index)
                  specified total count for the PENDATA set

Return Value:

    TRUE if sucessful, FALSE if failed,

Author:

    06-Dec-1993 Mon 22:25:55 created  -by-  DC


Revision History:


--*/

{
    PPLOTREGKEY pPRK;
    WCHAR       wBuf[32];
    PLOTREGKEY  PRK;
    UINT        Index;


    Index = (UINT)LOWORD(RegIdx);

    PLOTASSERT(0, "SetPlotRegData: Invalid PRKI_xxx Index %ld",
                                Index <= PRKI_LAST, Index);

    if (Index >= PRKI_PENDATA1) {

        UINT    cPenData;

        if ((cPenData = (UINT)HIWORD(RegIdx)) >= MAX_PENPLOTTER_PENS) {

            PLOTERR(("GetPlotRegData: cPenData too big %ld (Max=%ld)",
                                    cPenData, MAX_PENPLOTTER_PENS));

            cPenData = MAX_PENPLOTTER_PENS;
        }

        PRK.pwKey = GetPenDataKey(wBuf, (WORD)(Index - PRKI_PENDATA1 + 1));
        PRK.Size  = (DWORD)sizeof(PENDATA) * (DWORD)cPenData;
        pPRK      = &PRK;

    } else {

        pPRK = (PPLOTREGKEY)&PlotRegKey[Index];
    }

    if (xSetPrinterData(hPrinter,
                        pPRK->pwKey,
                        REG_BINARY,
                        pData,
                        pPRK->Size) != NO_ERROR) {

        PLOTERR(("SetPlotRegData: SetPrinterData(%ls [%ld]) failed",
                                                pPRK->pwKey, pPRK->Size));
        return(FALSE);

    } else {

        PLOTDBG(DBG_SETREGDATA, ("SAVE '%ws' registry data", pPRK->pwKey));
        return(TRUE);
    }
}


BOOL
SaveToRegistry(
    HANDLE      hPrinter,
    PCOLORINFO  pColorInfo,
    LPDWORD     pDevPelsDPI,
    LPDWORD     pHTPatSize,
    PPAPERINFO  pCurPaper,
    PPPDATA     pPPData,
    LPBYTE      pIdxPlotData,
    DWORD       cPenData,
    PPENDATA    pPenData
    )

/*++

Routine Description:

    This function take hPrinter and read the printer properties from the
    registry, if sucessful then it update to the pointer supplied

Arguments:

    hPrinter        - The printer it interested

    pColorInfo      - Pointer to the COLORINFO data structure

    pDevPelsDPI     - Pointer to the DWORD for Device Pels per INCH

    pHTPatSize      - Poineer to the DWORD for halftone patterns size

    pCurPaper       - Pointer to the PAPERINFO data structure for update

    pPPData         - Pointer to the PPDATA data structure

    pIdxPlotData    - Pointer to the DWORD which have current PlotData index

    cPenData        - count of PENDATA to be updated

    pPenData        - Pointer to the PENDATA data structure


Return Value:

    return TRUE if it read sucessful from the registry else FALSE, for each of
    the data pointer passed it will try to read from registry, if a NULL
    pointer is passed then that registry is skipped.

    if falied, the pCurPaper will be set to default

Author:

    30-Nov-1993 Tue 14:54:33 created  -by-  DC


Revision History:


--*/

{
    BOOL    Ok = TRUE;


    //
    // In turn get each of the data from registry.
    //

    if (pColorInfo) {

        if (!SetPlotRegData(hPrinter, (LPBYTE)pColorInfo, PRKI_CI)) {

            Ok = FALSE;
        }
    }

    if (pDevPelsDPI) {

        if (!SetPlotRegData(hPrinter, (LPBYTE)pDevPelsDPI, PRKI_DEVPELSDPI)) {

            Ok = FALSE;
        }
    }

    if (pHTPatSize) {

        if (!SetPlotRegData(hPrinter, (LPBYTE)pHTPatSize, PRKI_HTPATSIZE)) {

            Ok = FALSE;
        }
    }

    if (pCurPaper) {

        if (!SetPlotRegData(hPrinter, (LPBYTE)pCurPaper, PRKI_FORM)) {

            Ok = FALSE;
        }
    }

    if (pPPData) {

        pPPData->NotUsed = 0;

        if (!SetPlotRegData(hPrinter, (LPBYTE)pPPData, PRKI_PPDATA)) {

            Ok = FALSE;
        }
    }

    if (pIdxPlotData) {

        if (*pIdxPlotData >= PRK_MAX_PENDATA_SET) {

            *pIdxPlotData = 0;
            Ok            = FALSE;
        }

        if (!SetPlotRegData(hPrinter, pIdxPlotData, PRKI_PENDATA_IDX)) {

            Ok = FALSE;
        }
    }

    if ((cPenData) && (pPenData)) {

        WORD    IdxPen;

        //
        // First is get the current pendata selection index
        //

        if ((IdxPen = LOWORD(cPenData)) >= PRK_MAX_PENDATA_SET) {

            IdxPen = (WORD)((pIdxPlotData) ? *pIdxPlotData : 0);
        }

        cPenData = MAKELONG(IdxPen + PRKI_PENDATA1, HIWORD(cPenData));

        if (!SetPlotRegData(hPrinter, (LPBYTE)pPenData, cPenData)) {

            Ok = FALSE;
        }
    }

    return(Ok);
}


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\lib\readgpc.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    readgpc.c


Abstract:

    This module contain functions to read the PLOTGPC data file


Author:

    15-Nov-1993 Mon 10:00:01 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

extern DEVHTINFO    DefDevHTInfo;



BOOL
ValidateFormSrc(
    PGPCVARSIZE pFormGPC,
    SIZEL       DeviceSize,
    BOOL        DevRollFeed
    )

/*++

Routine Description:

    This function validate if FORMSRC has valid filed in it

Arguments:

    pFormGPC    - pointer to the GPCVARSIZE for the form data.

    DeviceSize  - Device size to check against,

    DevRollFeed - TRUE if device can do roll feed


Return Value:

    BOOL return value, the fields already verified and corrected.


Author:

    15-Nov-1993 Mon 10:34:29 created  -by-  DC


Revision History:


--*/

{
    PFORMSRC    pFS;
    LONG        cy;
    UINT        Count;
    BOOL        InvalidFS;
    BOOL        Ok = TRUE;



    pFS   = (PFORMSRC)pFormGPC->pData;
    Count = (UINT)pFormGPC->Count;

    while (Count--) {

        InvalidFS = FALSE;

        //
        // Make sure that imageable area is less or eqaul to the size
        //

        if (pFS->Size.cy) {

            if (pFS->Size.cy < MIN_PLOTGPC_FORM_CY) {

                //
                // Make it as variable length paper
                //

                PLOTERR(("Invalid Form CY, make it as variable length (%ld)",
                                                                pFS->Size.cy));

                pFS->Size.cy = 0;
            }
        }

        if (!(cy = pFS->Size.cy)) {

            cy = DeviceSize.cy;
        }

        if (((pFS->Size.cx <= DeviceSize.cx) &&
             (pFS->Size.cy <= cy))              ||
            ((pFS->Size.cy <= DeviceSize.cx) &&
             (pFS->Size.cx <= cy))) {

            NULL;

        } else {

            PLOTERR(("Invalid Form Size, too big for device to handle"));
            InvalidFS = TRUE;
        }

        if ((pFS->Size.cy) &&
            ((pFS->Size.cy - pFS->Margin.top - pFS->Margin.bottom) <
                                                        MIN_PLOTGPC_FORM_CY)) {

            PLOTERR(("Invalid Form CY or top/bottom margins"));

            InvalidFS = TRUE;
        }

        if ((pFS->Size.cx < MIN_PLOTGPC_FORM_CX)                            ||
            ((pFS->Size.cx - pFS->Margin.left - pFS->Margin.right) <
                                                    MIN_PLOTGPC_FORM_CX)) {

            PLOTERR(("Invalid Form CX or left/right margins"));

            InvalidFS = TRUE;
        }

        if ((!DevRollFeed) && (pFS->Size.cy == 0)) {

            InvalidFS = TRUE;
            PLOTERR(("The device cannot handle roll paper %hs", pFS->Name));
        }


        if (InvalidFS) {

            PLOTERR(("ValidateFormSrc: invalid form data, (removed it)"));

            Ok = FALSE;

            if (Count) {

                CopyMemory(pFS, pFS + 1, sizeof(FORMSRC));
            }

            pFormGPC->Count -= 1;

        } else {

            //
            // Make sure ansi ascii end with a NULL
            //

            pFS->Name[sizeof(pFS->Name) - 1] = '\0';

            ++pFS;
        }
    }

    if (!pFormGPC->Count) {

        PLOTERR(("ValidateFormSrc: NO form are valid, count = 0"));

        ZeroMemory(pFormGPC, sizeof(GPCVARSIZE));
    }

    return(Ok);
}




DWORD
PickDefaultHTPatSize(
    WORD    xDPI,
    WORD    yDPI,
    BOOL    HTFormat8BPP
    )

/*++

Routine Description:

    This function return default halftone pattern size used for a particular
    device resolution

Arguments:

    xDPI            - Device LOGPIXELS X

    yDPI            - Device LOGPIXELS Y

    8BitHalftone    - If a 8-bit halftone will be used


Return Value:

    DWORD   HT_PATSIZE_xxxx


Author:

    29-Jun-1993 Tue 14:46:49 created  -by-  DC


Revision History:


--*/

{
    DWORD    HTPatSize;

    //
    // use the smaller resolution as the pattern guide
    //

    if (xDPI > yDPI) {

        xDPI = yDPI;
    }

    if (xDPI >= 2400) {

        HTPatSize = HT_PATSIZE_16x16_M;

    } else if (xDPI >= 1800) {

        HTPatSize = HT_PATSIZE_14x14_M;

    } else if (xDPI >= 1200) {

        HTPatSize = HT_PATSIZE_12x12_M;

    } else if (xDPI >= 900) {

        HTPatSize = HT_PATSIZE_10x10_M;

    } else if (xDPI >= 400) {

        HTPatSize = HT_PATSIZE_8x8_M;

    } else if (xDPI >= 180) {

        HTPatSize = HT_PATSIZE_6x6_M;

    } else {

        HTPatSize = HT_PATSIZE_4x4_M;
    }

    if (HTFormat8BPP) {

        HTPatSize -= 2;
    }

    return(HTPatSize);
}





BOOL
ValidatePlotGPC(
    PPLOTGPC    pPlotGPC
    )

/*++

Routine Description:

    This function validate a PLOTGPC data structure


Arguments:

    pPlotGPC


Return Value:

    BOOL

Author:

    15-Feb-1994 Tue 22:49:40 updated  -by-  DC
        Update the pen plotter validation for the bitmap font and color

    15-Nov-1993 Mon 10:11:58 created  -by-  DC


Revision History:

    02-Apr-1995 Sun 11:23:46 updated  -by-  DC
        Update the COLORINFO checking so it will make to NT3.51's default
        and not compute the devpels on the spot.

--*/

{
    if ((pPlotGPC->ID != PLOTGPC_ID)            ||
        (pPlotGPC->cjThis != sizeof(PLOTGPC))) {

        PLOTERR(("ValidatePlotGPC: invalid PLOTGPC data (ID/Size)"));
        return(FALSE);
    }

    pPlotGPC->DeviceName[sizeof(pPlotGPC->DeviceName) - 1]  = '\0';
    pPlotGPC->Flags                                        &= PLOTF_ALL_FLAGS;

    //
    // Validate device size and its margin
    //

    if (pPlotGPC->DeviceSize.cx - (pPlotGPC->DeviceMargin.left +
                        pPlotGPC->DeviceMargin.right) < MIN_PLOTGPC_FORM_CX) {

        PLOTERR(("Invalid Device CX (%ld) set to default",
                                                    pPlotGPC->DeviceSize.cx));

        pPlotGPC->DeviceSize.cx = pPlotGPC->DeviceMargin.left +
                                  pPlotGPC->DeviceMargin.right +
                                  MIN_PLOTGPC_FORM_CX;
    }

    if (pPlotGPC->DeviceSize.cy < MIN_PLOTGPC_FORM_CY) {

        PLOTERR(("Invalid Device CY (%ld) default to 50' long",
                                                    pPlotGPC->DeviceSize.cx));

        pPlotGPC->DeviceSize.cy = 15240000;
    }

    if (pPlotGPC->DeviceSize.cy - (pPlotGPC->DeviceMargin.top +
                        pPlotGPC->DeviceMargin.bottom) < MIN_PLOTGPC_FORM_CY) {

        PLOTERR(("Invalid Device CY (%ld) set to default",
                                                    pPlotGPC->DeviceSize.cy));

        pPlotGPC->DeviceSize.cx = pPlotGPC->DeviceMargin.top +
                                  pPlotGPC->DeviceMargin.bottom +
                                  MIN_PLOTGPC_FORM_CY;
    }

    //
    // For now we must have 1:1 ratio
    //

    if (pPlotGPC->PlotXDPI != pPlotGPC->PlotYDPI) {

        pPlotGPC->PlotYDPI = pPlotGPC->PlotXDPI;
    }

    if (pPlotGPC->RasterXDPI != pPlotGPC->RasterYDPI) {

        pPlotGPC->RasterYDPI = pPlotGPC->RasterXDPI;
    }

    if (pPlotGPC->ROPLevel > ROP_LEVEL_MAX) {

        pPlotGPC->ROPLevel = ROP_LEVEL_MAX;
    }

    if (pPlotGPC->MaxScale > MAX_SCALE_MAX) {

        pPlotGPC->MaxScale = MAX_SCALE_MAX;
    }

    if ((!(pPlotGPC->Flags & PLOTF_RASTER)) &&
        (pPlotGPC->MaxPens > MAX_PENPLOTTER_PENS)) {

        pPlotGPC->MaxPens = MAX_PENPLOTTER_PENS;
    }

    if (pPlotGPC->MaxPolygonPts < 3) {      // minimum 3 points to make up a
                                            // region
        pPlotGPC->MaxPolygonPts = 0;
    }

    if (pPlotGPC->MaxQuality > MAX_QUALITY_MAX) {

        pPlotGPC->MaxQuality = MAX_QUALITY_MAX;
    }

    if (pPlotGPC->Flags & PLOTF_PAPERTRAY) {

        if ((pPlotGPC->PaperTraySize.cx != pPlotGPC->DeviceSize.cx) &&
            (pPlotGPC->PaperTraySize.cy != pPlotGPC->DeviceSize.cx)) {

            PLOTERR(("Invalid PaperTraySize (%ld x %ld), Make it as DeviceSize",
                                                    pPlotGPC->PaperTraySize.cx,
                                                    pPlotGPC->PaperTraySize.cy));

            pPlotGPC->PaperTraySize.cx = pPlotGPC->DeviceSize.cx;
            pPlotGPC->PaperTraySize.cy = pPlotGPC->DeviceSize.cy;
        }

    } else {

        pPlotGPC->PaperTraySize.cx  =
        pPlotGPC->PaperTraySize.cy  = 0;
    }

    if (!pPlotGPC->ci.Cyan.Y) {

        //
        // This is NT3.51 default
        //

        pPlotGPC->ci            = DefDevHTInfo.ColorInfo;
        pPlotGPC->DevicePelsDPI = 0;

    } else if ((pPlotGPC->DevicePelsDPI < 30) ||
               (pPlotGPC->DevicePelsDPI > pPlotGPC->RasterXDPI)) {

        pPlotGPC->DevicePelsDPI = 0;
    }

    if (pPlotGPC->HTPatternSize > HT_PATSIZE_16x16_M) {

        pPlotGPC->HTPatternSize = PickDefaultHTPatSize(pPlotGPC->RasterXDPI,
                                                       pPlotGPC->RasterYDPI,
                                                       FALSE);
    }

    if ((pPlotGPC->InitString.Count != 1)   ||
        (!pPlotGPC->InitString.SizeEach)    ||
        (!pPlotGPC->InitString.pData)) {

        ZeroMemory(&(pPlotGPC->InitString), sizeof(GPCVARSIZE));
    }

    if ((pPlotGPC->Forms.Count)                       &&
        (pPlotGPC->Forms.SizeEach == sizeof(FORMSRC)) &&
        (pPlotGPC->Forms.pData)) {

        ValidateFormSrc(&(pPlotGPC->Forms),
                        pPlotGPC->DeviceSize,
                        (pPlotGPC->Flags & PLOTF_ROLLFEED));

    } else {

        ZeroMemory(&(pPlotGPC->Forms), sizeof(GPCVARSIZE));
    }

    if (!(pPlotGPC->Flags & PLOTF_RASTER)) {

        //
        // PEN PLOTTER MUST COLOR and NO_BMP_FONT
        //

        pPlotGPC->Flags |= (PLOTF_NO_BMP_FONT | PLOTF_COLOR);
    }

    if ((!(pPlotGPC->Flags & PLOTF_RASTER))             &&
        (pPlotGPC->Pens.Count)                          &&
        (pPlotGPC->Pens.SizeEach == sizeof(PENDATA))    &&
        (pPlotGPC->Pens.pData)) {

        UINT        i;
        PPENDATA    pPD;


        pPD = (PPENDATA)pPlotGPC->Pens.pData;

        for (i = 0; i < (UINT)pPlotGPC->MaxPens; i++, pPD++) {

            if (pPD->ColorIdx > PC_IDX_LAST) {

                PLOTERR(("Invalid ColorIndex (%ld), set to default",
                                                            pPD->ColorIdx));

                pPD->ColorIdx = PC_IDX_FIRST;
            }
        }

    } else {

        ZeroMemory(&(pPlotGPC->Pens), sizeof(GPCVARSIZE));
    }

    return(TRUE);
}

VOID
CopyPlotGPCFromPCD(
    PPLOTGPC     pPlotGPC,
    PPLOTGPC_PCD pPlotGPC_PCD
    )

/*++

Routine Description:

    This function copies a PLOTGPC_PCD structure into a PLOTGPC structure.

Arguments:

    pPlotGPC     - destination
    pPlotGPC_PCD - source

Return Value:

    None 

Author:

    1 Feb 2000, Manu Thambi 

Revision History:

--*/

{
    // All the datatypes upto InitString are the same in both the structures.
    CopyMemory(pPlotGPC, 
               pPlotGPC_PCD, 
               (LPBYTE)&(pPlotGPC_PCD->InitString) - (LPBYTE)pPlotGPC_PCD);
    
    // We replace sizeof(PLOTGPC_PCD) with sizeof(PLOTGPC)
    pPlotGPC->cjThis = sizeof(PLOTGPC);

    pPlotGPC->InitString.Count     = pPlotGPC_PCD->InitString.Count;
    pPlotGPC->InitString.SizeEach  = pPlotGPC_PCD->InitString.SizeEach;
    if (pPlotGPC_PCD->InitString.pData) {
        pPlotGPC->InitString.pData = (LPVOID)(pPlotGPC_PCD->InitString.pData
                                                 + (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD)));
    } else {
        pPlotGPC->InitString.pData = NULL;
    }

    pPlotGPC->Forms.Count          = pPlotGPC_PCD->Forms.Count;
    pPlotGPC->Forms.SizeEach       = pPlotGPC_PCD->Forms.SizeEach;
    if (pPlotGPC_PCD->Forms.pData) {
        pPlotGPC->Forms.pData      = (LPVOID)(pPlotGPC_PCD->Forms.pData
                                                 + (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD)));
    } else {
        pPlotGPC->Forms.pData      = NULL;
    }

    pPlotGPC->Pens.Count           = pPlotGPC_PCD->Pens.Count;
    pPlotGPC->Pens.SizeEach        = pPlotGPC_PCD->Pens.SizeEach;
    if (pPlotGPC_PCD->Pens.pData) {
        pPlotGPC->Pens.pData       = (LPVOID)(pPlotGPC_PCD->Pens.pData
                                                 + (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD)));
    } else {
        pPlotGPC->Pens.pData       = NULL;
    }
}




PPLOTGPC
ReadPlotGPCFromFile(
    PWSTR   pwsDataFile
    )

/*++

Routine Description:

    This function open/read the PlotGPC data file and validate them also


Arguments:

    pwsDataFile - a pointer to full qualify path for the data file name

Return Value:

    BOOL - to indicate state


Author:

    15-Nov-1993 Mon 10:01:17 created  -by-  DC


Revision History:


--*/

{
    HANDLE        hFile;
    DWORD         dwSize;
    PLOTGPC_PCD   PlotGPC_PCD;
    BOOL          bSuccess = TRUE;
    PPLOTGPC      pPlotGPC = NULL;

    if ((hFile = OpenPlotFile(pwsDataFile)) == (HANDLE)INVALID_HANDLE_VALUE) {

        PLOTERR(("ReadPlotGPCFromFile: Open data file failed"));
        return(NULL);
    }

    if ((ReadPlotFile(hFile, &PlotGPC_PCD, sizeof(PLOTGPC_PCD), &dwSize)) &&
        (dwSize == sizeof(PLOTGPC_PCD))) {

        if ((PlotGPC_PCD.ID != PLOTGPC_ID)           ||
            (PlotGPC_PCD.cjThis != sizeof(PLOTGPC_PCD))) {

            bSuccess = FALSE;
            PLOTERR(("ReadPlotGPCFromFile: invalid data file"));
        }

    } else {

        bSuccess = FALSE;
        PLOTERR(("ReadPlotGPCFromFile: Read data file failed"));
    }

    //
    // if we have pPlotGPC_PCD == NULL then an error ocurred
    //

    if (bSuccess) {

        dwSize = PlotGPC_PCD.SizeExtra + sizeof(PLOTGPC);

        if (pPlotGPC = (PPLOTGPC)LocalAlloc(LPTR, dwSize)) {

            CopyPlotGPCFromPCD(pPlotGPC, &PlotGPC_PCD);

            if ((PlotGPC_PCD.SizeExtra)                                 &&
                (ReadPlotFile(hFile,
                              (LPBYTE)pPlotGPC + sizeof(PLOTGPC),
                              PlotGPC_PCD.SizeExtra,
                              &dwSize))                             &&
                (dwSize == PlotGPC_PCD.SizeExtra)) {

                if ((pPlotGPC->InitString.Count == 1) &&
                    (pPlotGPC->InitString.SizeEach)   &&
                    (pPlotGPC->InitString.pData)) {

                    (LPBYTE)pPlotGPC->InitString.pData += (ULONG_PTR)pPlotGPC;

                } else {

                    ZeroMemory(&(pPlotGPC->InitString), sizeof(GPCVARSIZE));
                }

                if ((pPlotGPC->Forms.Count)                       &&
                    (pPlotGPC->Forms.SizeEach == sizeof(FORMSRC)) &&
                    (pPlotGPC->Forms.pData)) {

                    (LPBYTE)pPlotGPC->Forms.pData += (ULONG_PTR)pPlotGPC;

                } else {

                    ZeroMemory(&(pPlotGPC->Forms), sizeof(GPCVARSIZE));
                }

                if ((pPlotGPC->Pens.Count)                          &&
                    (pPlotGPC->Pens.SizeEach == sizeof(PENDATA))    &&
                    (pPlotGPC->Pens.pData)) {

                    (LPBYTE)pPlotGPC->Pens.pData += (ULONG_PTR)pPlotGPC;

                } else {

                    ZeroMemory(&(pPlotGPC->Pens), sizeof(GPCVARSIZE));
                }

            } else {

                //
                // Failed to read, free the memory and return NULL
                //

                LocalFree((HLOCAL)pPlotGPC);
                pPlotGPC = NULL;

                PLOTERR(("ReadPlotGPCFromFile: read variable size data failed"));
            }

        } else {

            PLOTERR(("ReadPlotGPCFromFile: allocate memory (%lu bytes) failed",
                                             dwSize));
        }
    }

    ClosePlotFile(hFile);

    if (pPlotGPC) {

        ValidatePlotGPC(pPlotGPC);
    }

    return(pPlotGPC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\lib\sources.inc ===
SOURCES=..\plotdbg.c    \
        ..\readgpc.c    \
        ..\widechar.c   \
        ..\file.c       \
        ..\forms.c      \
        ..\regdata.c    \
        ..\plotdm.c     \
        ..\drvinfo.c    \
        ..\cachegpc.c   \
        ..\devmode.c    \
        ..\halftone.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\lib\widechar.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    widechar.c


Abstract:

    This module contains all NLS unicode / ansi translation code


Author:

    18-Nov-1993 Thu 08:21:37 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop



LPWSTR
str2Wstr(
    LPWSTR  pwStr,
    LPSTR   pbStr
    )

/*++

Routine Description:

    This function copy a ansi string to the equvlent of unicode string which
    also include the NULL teiminator

Arguments:

    pwStr   - Point to the unicode string location, it must have the size of
              (strlen(pstr) + 1) * sizeof(WCHAR)

    pbStr   - a null teiminated string

Return Value:

    pwcs

Author:

    18-Nov-1993 Thu 08:36:00 created  -by-  DC


Revision History:


--*/

{
    UINT    cb;

    cb = (UINT)(strlen(pbStr) + 1);

    AnsiToUniCode(pbStr, pwStr, cb);

    return(pwStr);
}



LPWSTR
str2MemWstr(
    LPSTR   pbStr
    )

/*++

Routine Description:

    This function copy a ansi string to the equvlent of unicode string which
    also include the NULL teiminator, it will allocate just enough memory
    to copy for the unicode from the passed or using LocalAlloc()

Arguments:

    pbStr    - a null teiminated string

Return Value:

    LPWSTR if sucessful and NULL if failed

Author:

    18-Nov-1993 Thu 08:36:00 created  -by-  DC


Revision History:


--*/

{
    UINT    cb;
    LPWSTR  pwStr;


    cb = (UINT)(strlen(pbStr) + 1);

    if (pwStr = (LPWSTR)LocalAlloc(LMEM_FIXED, cb * sizeof(WCHAR))) {

        AnsiToUniCode(pbStr, pwStr, cb);
    }

    return(pwStr);
}





LPWSTR
Wstr2Mem(
    LPWSTR  pwStr
    )

/*++

Routine Description:

    This function allocated enough memory to store the pwStr.

Arguments:

    pwStr   - Point to the unicode string location.


Return Value:

    LPWSTR if sucessful allocated the memory else NULL


Author:

    18-Nov-1993 Thu 08:51:14 created  -by-  DC


Revision History:


--*/

{
    UINT    cb;
    LPWSTR  pwStrMem;


    cb = (UINT)((wcslen(pwStr) + 1) * sizeof(WCHAR));

    if (pwStrMem =  (LPWSTR)LocalAlloc(LMEM_FIXED, cb)) {

        CopyMemory(pwStrMem, pwStr, cb);
    }

    return(pwStrMem);
}





LPSTR
WStr2Str(
    LPSTR   pbStr,
    LPWSTR  pwStr
    )

/*++

Routine Description:

    This function convert a UNICODE string to the ANSI string, assume that
    pbStr has same character count memory as pwStr

Arguments:

    pbStr   - Point to the ANSI string which has size of wcslen(pwStr) + 1

    pwStr   - Point to the UNICODE string


Return Value:


    pbStr


Author:

    06-Dec-1993 Mon 13:06:12 created  -by-  DC


Revision History:


--*/

{

    UINT    cch;

    cch = (UINT)wcslen(pwStr) + 1;

    UniCodeToAnsi(pbStr, pwStr, cch);

    return(pbStr);
}



LPSTR
Wstr2Memstr(
    LPWSTR  pwStr
    )

/*++

Routine Description:

    This function copy a UNICODE string to the equvlent of ANSI string which
    also include the NULL teiminator, it will allocate just enough memory
    to copy for the unicode from the passed or using LocalAlloc()

Arguments:

    pwStr   - a null teiminated unicode string

Return Value:

    LPWSTR if sucessful and NULL if failed

Author:

    18-Nov-1993 Thu 08:36:00 created  -by-  DC


Revision History:


--*/

{
    UINT    cch;
    LPSTR   pbStr;


    cch = (UINT)(wcslen(pwStr) + 1);

    if (pbStr = (LPSTR)LocalAlloc(LMEM_FIXED, cch)) {

        UniCodeToAnsi(pbStr, pwStr, cch);
    }

    return(pbStr);
}



LPSTR
str2Mem(
    LPSTR   pbStr
    )

/*++

Routine Description:

    This function allocated enough memory to store the pwStr.

Arguments:

    pbStr   - Point to the ANSI string location.


Return Value:

    LPWSTR if sucessful allocated the memory else NULL


Author:

    18-Nov-1993 Thu 08:51:14 created  -by-  DC


Revision History:


--*/

{
    UINT    cb;
    LPSTR   pbStrMem;


    cb = (UINT)(strlen(pbStr) + 1);

    if (pbStrMem = (LPSTR)LocalAlloc(LMEM_FIXED, cb)) {

        CopyMemory(pbStrMem, pbStr, cb);
    }

    return(pbStrMem);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\bitblt.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    bitblt.c


Abstract:

    This module contains functions which implement bitmap handling for the
    plotter driver.

Author:

    19:15 on Mon 15 Apr 1991    -by-    SC
        Created it

    15-Nov-1993 Mon 19:24:36 updated  -by-  DC
        fixed, clean up

    18-Dec-1993 Sat 10:52:07 updated  -by-  DC
        Move some functions from bitbltp.c and move others to htblt.c and
        bitmap.c.   This file mainly has DrvXXXXX() which related to the
        bitblt or drawing.

    27-Jan-1994 Thu 23:41:23 updated  -by-  DC
        Revised bitblt so it will handle better ROP3/Rop4 support, also it
        will check the PCD file's ROP caps

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


#define DBG_PLOTFILENAME    DbgBitBlt


#define DBG_COPYBITS            0x00000001
#define DBG_BITBLT              0x00000002
#define DBG_DRVPAINT            0x00000004
#define DBG_DRVFILLPATH         0x00000008
#define DBG_DRVSTROKEANDFILL    0x00000010
#define DBG_MIXTOROP4           0x00000020
#define DBG_TEMPSRC             0x00000040
#define DBG_STRETCHBLT          0x00000080
#define DBG_BANDINGHTBLT        0x00000100
#define DBG_DOFILL              0x00000200
#define DBG_CSI                 0x00000400


DEFINE_DBGVAR(0);


//
// This is the default BANDING size (2MB) for the DrvStretchBlt()
//

#if DBG

LPSTR   pCSIName[] = { "SRC", "PAT", "TMP" };


DWORD   MAX_STRETCH_BLT_SIZE = (2 * 1024 * 1024);
#else
#define MAX_STRETCH_BLT_SIZE    (2 * 1024 * 1024)
#endif

//
// This table converts MIX-1 to ROP3 value
//
static BYTE amixToRop4[] = {
         0x00,             // R2_BLACK             0
         0x05,             // R2_NOTMERGEPEN      DPon
         0x0a,             // R2_MASKNOTPEN       DPna
         0x0f,             // R2_NOTCOPYPEN       PN
         0x50,             // R2_MASKPENNOT       PDna
         0x55,             // R2_NOT              Dn
         0x5a,             // R2_XORPEN           DPx
         0x5f,             // R2_NOTMASKPEN       DPan
         0xa0,             // R2_MASKPEN          DPa
         0xa5,             // R2_NOTXORPEN        DPxn
         0xaa,             // R2_NOP              D
         0xaf,             // R2_MERGENOTPEN      DPno
         0xf0,             // R2_COPYPEN          P
         0xf5,             // R2_MERGEPENNOT      PDno
         0xfa,             // R2_MERGEPEN         DPo
         0xff,             // R2_WHITE             1
};

extern const POINTL ptlZeroOrigin;





ROP4
MixToRop4(
   MIX  mix
   )

/*++

Routine Description:

    This function converts a MIX value to a ROP4 value

Arguments:

    mix      - MIX value to convert, this is defined in wingdi.h and represents
               one of 16 different ROP2 values
Return Value:

    ROP4     - the converted value


Author:

    18-Dec-1993 Sat 09:34:06 created  -by-  JB


Revision History:


--*/
{
   ROP4 rop4Return;

   //
   // Now pack the two new values by looking up the correct rop codes in our
   // table.
   //


   rop4Return =  amixToRop4[((mix & 0xff) - 1)];

   rop4Return |= ( amixToRop4[((( mix >> 8) & 0xff ) - 1 )] << 8 );


   PLOTDBG(DBG_MIXTOROP4, ("MixToRop4 before %x after %x", (int) mix,(int) rop4Return));

   return(rop4Return);
}





BOOL
BandingHTBlt(
    PPDEV           pPDev,
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    PRECTL          prclDst,
    PRECTL          prclSrc,
    PPOINTL         pptlMask,
    WORD            HTRop3,
    BOOL            InvertMask
    )

/*++

Routine Description:

    This is our internal version of StretchBlt() which always does halftoning
    and banding if the destination bitmap is too large. Since the target
    surface can pottentially be 3 feet by 3 feet, we don't want to
    have a bitmap created that large because of memory requirements. So
    we review the memory requirements and if they are too large we simply
    band, by setting a clip region that moves down the page via a loop. This
    effectively has the halftoning engine simply working on much smaller
    more manageable bitmaps, and we end up sending out virtually the same
    number of bytes.

Arguments:

    pPDev       - Pointer to our PDEV

    psoDst      - This is a pointer to a SURFOBJ.    It identifies the surface
                  on which to draw.

    psoSrc      - This SURFOBJ defines the source for the Blt operation.  The
                  driver must call GDI Services to find out if this is a device
                  managed  surface or a bitmap managed by GDI.

    psoMask     - This optional surface provides a mask for the source.  It is
                  defined by a logic map, i.e. a bitmap with one bit per pel.

                  The mask is used to limit the area of the source that is
                  copied.  When a mask is provided there is an implicit rop4 of
                  0xCCAA, which means that the source should be copied wherever
                  the mask is 1, but the destination should be left alone
                  wherever the mask is 0.

                  When this argument is NULL there is an implicit rop4 of
                  0xCCCC, which means that the source should be copied
                  everywhere in the source rectangle.

                  The mask will always be large enough to contain the source
                  rectangle, tiling does not need to be done.

    pco         - This is a pointer to a CLIPOBJ.    GDI Services are provided
                  to enumerate the clipping region as a set of rectangles or
                  trapezoids. This limits the area of the destination that will
                  be modified.

                  Whenever possible, GDI will simplify the clipping involved.
                  However, unlike DrvBitBlt, DrvStretchBlt may be called with a
                  single clipping rectangle.  This is necessary to prevent
                  roundoff errors in clipping the output.

    pxlo        - This is a pointer to an XLATEOBJ.  It tells how color indices
                  should be translated between the source and target surfaces.

                  The XLATEOBJ can also be queried to find the RGB color for
                  any source index.  A high quality stretching Blt will need
                  to interpolate colors in some cases.

    pca         - This is a pointer to COLORADJUSTMENT structure, if NULL it
                  specifies that appiclation did not set any color adjustment
                  for this DC, and it is up to the driver to provide a default
                  adjustment

    pptlBrushOrg- Pointer to the POINT structure which specifies the location
                  where the halftone brush should alignment to, if this pointer
                  is NULL, then we assume that (0, 0) is the brush origin.

    prclDst     - This RECTL defines the area in the coordinate system of the
                  destination surface that should be modified.

                  The rectangle is defined by two points.    These points are
                  not well ordered, i.e. the coordinates of the second point
                  are not necessarily larger than those of the first point.
                  The rectangle they describe does not include the lower and
                  right edges.  DrvStretchBlt will never be called with an
                  empty destination rectangle.

                  DrvStretchBlt can do inversions in both x and y, this happens
                  when the destination rectangle is not well ordered.

    prclSrc     - This RECTL defines the area in the coordinate system of the
                  source surface that will be copied.  The rectangle is defined
                  by two points, and will map onto the rectangle defined by
                  prclDst.  The points of the source rectangle are well
                  ordered.  DrvStretch will never be given an empty source
                  rectangle.

                  Note that the mapping to be done is defined by prclSrc and
                  prclDsst. To be precise, the given points in prclDst and
                  prclSrc lie on integer coordinates, which we consider to
                  correspond to pel centers.  A rectangle defined by two such
                  points should be considered a geometric rectangle with two
                  vertices whose coordinates are the given points, but with 0.5
                  subtracted from each coordinate.  (The POINTLs should just be
                  considered a shorthand notation for specifying these
                  fractional coordinate vertices.)  Note thate the edges of any
                  such rectangle never intersect a pel, but go around a set of
                  pels.  Note also that the pels that are inside the rectangle
                  are just what you would expect for a "bottom-right exclusive"
                  rectangle.  The mapping to be done by DrvStretchBlt will map
                  the geometric source rectangle exactly onto the geometric
                  destination rectangle.

    pptlMask    - This POINTL specifies which pel in the given mask corresponds
                  to the upper left pel in the source rectangle.  Ignore this
                  argument if there is no mask.

    HTRop3      - HIBYTE(HTRop3) when psoMask is not NULL and
                  LOBYTE(HTRop3) when psoMask is NULL

    InvertMask  - TRUE if the mask must be inverted


Return Value:


    TRUE if sucessful FALSE if failed

Author:

    07-Mar-1994 Mon 12:52:41 created  -by-  DC

Revision History:

    16-Mar-1994 Wed 15:20:42 updated  -by-  DC
        Updated for banding the mask so it will works correcly for the engine
        problem.

    04-May-1994 Wed 11:27:39 updated  -by-  DC
        Make rotate type (landscape mode) banding from right to left rather
        than top to bottom

    29-Nov-1995 Wed 13:00:30 updated  -by-  DC
        Mark not reentratable for the same PDEV, this is signal that called to
        the EngStretchBlt(HALFTONE) is failing for some reason


--*/

{
    CLIPOBJ *pcoNew;
    CLIPOBJ coSave;
    RECTL   rclMask;
    RECTL   rclBounds;
    DWORD   MaskRop3;
    UINT    Loop;
    BOOL    DoRotate;
    BOOL    Ok;



    if (!IS_RASTER(pPDev)) {

        PLOTDBG(DBG_BANDINGHTBLT, ("BandingHTBlt: Pen Plotter: IGNORE and return OK"));
        return(TRUE);
    }

    if (pPDev->pPlotGPC->ROPLevel < ROP_LEVEL_1) {

        PLOTDBG(DBG_BITBLT, ("BandingHTBlt: RopLevel < 1, Cannot Do it"));
        return(TRUE);
    }

    if (pPDev->Flags & PDEVF_IN_BANDHTBLT) {

        //
        // Something is wrong here
        //

        PLOTERR(("BandingHTBlt: Recursive is not allowed, FAILED"));
        return(FALSE);
    }

    //
    // Turn on the flag now
    //

    pPDev->Flags |= PDEVF_IN_BANDHTBLT;

    if ((!pca) || (pca->caFlags & ~(CA_NEGATIVE | CA_LOG_FILTER))) {

        //
        // If we have a NULL or invalid flag then use the default one
        //

        PLOTASSERT(0, "DrvStretchBlt: INVALID ColorAdjustment Flags=%04lx, USE DEFAULT",
                   ((pca) && (pca->caFlags & ~(CA_NEGATIVE | CA_LOG_FILTER))),
                   (pca) ? pca->caFlags : 0);

        pca = &(pPDev->PlotDM.ca);
    }

    if (!pptlBrushOrg) {

        pptlBrushOrg = (PPOINTL)&(ptlZeroOrigin);
    }

    if (pPDev->PlotDM.Flags & PDMF_PLOT_ON_THE_FLY) {

        if (psoMask) {

            PLOTWARN(("BandingHTBlt: PosterMode -> Ignored MASK"));
            psoMask = NULL;
        }
    }

    if (psoMask) {

        //
        // If we have a source mask then we will first do (S|D)=0xEE or
        // (~S|D)=0xBB to white out the mask area then use (S&D)=0x88 to AND
        // in the halftoned bitmap. This is done to simulate the desired ROP
        // since the target device can't handle this on its own.
        //

        rclMask.left   = pptlMask->x;
        rclMask.top    = pptlMask->y;
        rclMask.right  = rclMask.left + (prclSrc->right - prclSrc->left);
        rclMask.bottom = rclMask.top +  (prclSrc->bottom - prclSrc->top);
        HTRop3         = (WORD)HIBYTE(HTRop3);
        MaskRop3       = (DWORD)((InvertMask) ? 0xBB : 0xEE);
        Loop           = 2;

        //
        // We must call this function to set up the xlate table correctly
        //

        IsHTCompatibleSurfObj(pPDev,
                              psoMask,
                              NULL,
                              ISHTF_ALTFMT | ISHTF_HTXB | ISHTF_DSTPRIM_OK);

    } else {

        HTRop3   = (WORD)LOBYTE(HTRop3);
        Loop     = 1;
    }

    if (!HTRop3) {

        HTRop3 = 0xCC;
    }

    //
    // Now look at how we can modify the clipping rect, in case we need
    // to band.
    //

    if (pco) {

        //
        // Save the original clipping object so we can restore it before exiting
        //

        pcoNew = NULL;
        coSave = *pco;

    } else {

        PLOTDBG(DBG_BANDINGHTBLT, ("BandingHTBlt: Create NEW EMPTY pco"));

        if (!(pcoNew = pco = EngCreateClip())) {

            PLOTERR(("BandingHTBlt: EngCreateClip() FAILED, got NO CLIP"));

            pPDev->Flags &= ~PDEVF_IN_BANDHTBLT;
            return(FALSE);
        }

        pco->iDComplexity = DC_TRIVIAL;
    }

    PLOTDBG(DBG_BANDINGHTBLT, ("BandingHTBlt: The pco->iDComplexity=%ld",
                                pco->iDComplexity));

    if (pco->iDComplexity == DC_TRIVIAL) {

        //
        // Since it is trivial, we just draw the whole destination
        //

        pco->iDComplexity = DC_RECT;
        pco->rclBounds    = *prclDst;
    }

    //
    // Now make sure our bounds will not go outside of the surface
    //

    rclBounds.left    =
    rclBounds.top     = 0;
    rclBounds.right   = psoDst->sizlBitmap.cx;
    rclBounds.bottom  = psoDst->sizlBitmap.cy;

    if (IntersectRECTL(&rclBounds, &(pco->rclBounds))) {

        PLOTDBG(DBG_BANDINGHTBLT,
                ("BandingHTBlt: rclBounds=(%ld, %ld)-(%ld, %ld), %ld x %ld, ROP=%02lx",
                    rclBounds.left, rclBounds.top,
                    rclBounds.right, rclBounds.bottom,
                    rclBounds.right - rclBounds.left,
                    rclBounds.bottom - rclBounds.top, (DWORD)HTRop3));

    } else {

        PLOTDBG(DBG_BANDINGHTBLT, ("BandingHTBlt: rclBounds=NULL, NOTHING TO DO"));
        Loop = 0;
    }

    //
    // Now let's band it through
    //

    DoRotate = (BOOL)(pPDev->PlotForm.BmpRotMode == BMP_ROT_RIGHT_90);
    Ok       = TRUE;

    while ((Ok) && (Loop--) && (!PLOT_CANCEL_JOB(pPDev))) {

        RECTL   rclDst;
        SIZEL   szlDst;
        LONG    cScan;
        DWORD   BmpFormat;
        DWORD   OHTFlags;

        //
        // When Loop = 1 then we are doing the MASK
        // When Loop = 0 then we are doing the SOURCE
        //
        // We will band only MAX_STRETCH_BLT_SIZE at once
        //

        rclDst    = *prclDst;
        szlDst.cx = rclDst.right - rclDst.left;
        szlDst.cy = rclDst.bottom - rclDst.top;
        BmpFormat = (DWORD)((Loop) ? BMF_1BPP : HTBMPFORMAT(pPDev));

        cScan = (LONG)(MAX_STRETCH_BLT_SIZE /
                           GetBmpDelta(BmpFormat, (DoRotate) ? szlDst.cy :
                                                               szlDst.cx));


        //
        // We always want at least 8 scan lines and also a multiple of 8.
        //


        if (!cScan) {

            cScan = 8;

        } else if (cScan & 0x07) {

            cScan = (LONG)((cScan + 7) & ~(DWORD)0x07);
        }


        PLOTDBG(DBG_BANDINGHTBLT, ("BandingHTBlt: cScan=%ld, Total=%ld",
                                cScan, (DoRotate) ? szlDst.cx : szlDst.cy));

        OHTFlags = 0;

        while ((Ok)                             &&
               (!PLOT_CANCEL_JOB(pPDev))        &&
               (rclDst.top < prclDst->bottom)   &&
               (rclDst.right > prclDst->left)) {

            if (DoRotate) {

                if ((rclDst.left = rclDst.right - cScan) < prclDst->left) {

                    rclDst.left = prclDst->left;
                }

            } else {

                if ((rclDst.bottom = rclDst.top + cScan) > prclDst->bottom) {

                    rclDst.bottom = prclDst->bottom;
                }
            }

            pco->rclBounds = rclBounds;

            if (IntersectRECTL(&(pco->rclBounds), &rclDst)) {

                PLOTDBG(DBG_BANDINGHTBLT,
                        ("BandingHTBlt: Banding RECTL=(%ld, %ld)-(%ld, %ld), %ld x %ld",
                            pco->rclBounds.left, pco->rclBounds.top,
                            pco->rclBounds.right, pco->rclBounds.bottom,
                            pco->rclBounds.right - pco->rclBounds.left,
                            pco->rclBounds.bottom - pco->rclBounds.top));

                if (Loop) {

                    SURFOBJ *psoNew;
                    HBITMAP hNewBmp;
                    RECTL   rclNew;

                    //
                    // We have a mask, so create a 1BPP bitmap, and stretch it
                    // to the new destination size, then output it using
                    // MaskRop3
                    //

                    Ok = FALSE;

                    PLOTDBG(DBG_CSI, ("BandingHTBlt: CreateBitmapSURFOBJ(MASK)"));

                    if (psoNew = CreateBitmapSURFOBJ(pPDev,
                                                     &hNewBmp,
                                                     pco->rclBounds.right -
                                                        pco->rclBounds.left,
                                                     pco->rclBounds.bottom -
                                                        pco->rclBounds.top,
                                                     BMF_1BPP,
                                                     NULL)) {

                        rclNew.left   = prclDst->left - pco->rclBounds.left;
                        rclNew.top    = prclDst->top - pco->rclBounds.top;
                        rclNew.right  = rclNew.left + szlDst.cx;
                        rclNew.bottom = rclNew.top + szlDst.cy;

                        PLOTDBG(DBG_BANDINGHTBLT,
                                ("BandingHTBlt: Banding MASK RECTL=(%ld, %ld)-(%ld, %ld), %ld x %ld",
                                rclNew.left, rclNew.top,
                                rclNew.right, rclNew.bottom,
                                psoNew->sizlBitmap.cx,
                                psoNew->sizlBitmap.cy));

                        if (EngStretchBlt(psoNew,           // psoDst
                                          psoMask,          // psoSrc
                                          NULL,             // psoMask,
                                          NULL,             // pco
                                          NULL,             // pxlo
                                          NULL,             // pca
                                          pptlBrushOrg,     // pptlHTOrg
                                          &rclNew,          // prclDst
                                          &rclMask,         // prclSrc
                                          NULL,             // pptlMask
                                          BLACKONWHITE)) {


                            if (!(Ok = OutputHTBitmap(pPDev,
                                                      psoNew,
                                                      NULL,
                                                      (PPOINTL)&rclDst,
                                                      NULL,
                                                      MaskRop3,
                                                      &OHTFlags))) {

                                PLOTERR(("BandingHTBlt: OutputHTBitmap(M|D) FAILED"));
                            }

                        } else {

                            PLOTERR(("BandingHTBlt: EngStretchBlt(MASK B/W) FAILED"));
                        }

                        //
                        // Delete this band of the mask bitmap
                        //

                        EngUnlockSurface(psoNew);

                        PLOTDBG(DBG_CSI, ("BandingHTBlt: EngDeleteSuface(MASK)"));

                        if (!EngDeleteSurface((HSURF)hNewBmp)) {

                            PLOTERR(("PLOTTER: BandingHTBlt, EngDeleteSurface(%p) FAILED",
                                        (DWORD_PTR)hNewBmp));
                        }

                    } else {

                        PLOTERR(("BandingHTBlt: Create MASK SURFOBJ (%ld x %ld) failed",
                                    pco->rclBounds.right - pco->rclBounds.left,
                                    pco->rclBounds.bottom - pco->rclBounds.top));
                    }

                } else {


                    //
                    // We must pass the psoMask/pptlMask so the haltone
                    // operations will not overwrite the non masked
                    // area (erasing it).
                    //

                    pPDev->Rop3CopyBits = HTRop3;

                    if (!(Ok = EngStretchBlt(psoDst,        // psoDst
                                             psoSrc,        // psoSrc
                                             psoMask,       // psoMask,
                                             pco,           // pco
                                             pxlo,          // pxlo
                                             pca,           // pca
                                             pptlBrushOrg,  // pptlHTOrg
                                             prclDst,       // prclDst
                                             prclSrc,       // prclSrc
                                             pptlMask,      // pptlMask
                                             HALFTONE))) {

                        PLOTERR(("BandingHTBlt: EngStretchBlt(Halftone:S&D) FAILED"));
                    }
                }
            }

            if (DoRotate) {

                rclDst.right = rclDst.left;

            } else {

                rclDst.top = rclDst.bottom;
            }
        }


        //
        // We must do this in order to exit HPGL/2 mode. This is because the
        // next call for the source will go through EngStrecthBlt(HALFTONE)
        // which will re-enter RTL mode again.
        //

        if (OHTFlags & OHTF_MASK) {

            OHTFlags |= OHTF_EXIT_TO_HPGL2;

            OutputHTBitmap(pPDev, NULL, NULL, NULL, NULL, 0xAA, &OHTFlags);
        }
    }

    if (pcoNew) {

        EngDeleteClip(pcoNew);

    } else {

        *pco = coSave;
    }

    pPDev->Flags &= ~PDEVF_IN_BANDHTBLT;

    return(Ok);
}




BOOL
DoFill(
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PPOINTL     pptlSrc,
    BRUSHOBJ    *pbo,
    PPOINTL     pptlBrush,
    ROP4        Rop4
    )

/*++

Routine Description:

    This function fills a RECT area with a brush and takes clipping into
    consideration

Arguments:

    psoDst      - Destination surface obj

    psoSrc      - source surface obj

    pco         - Clip obj

    pxlo        - translate obj

    prclDst     - destination rect area

    pptlSrc     - point where source starts

    pbo         - Brush obj to fill with

    pptlBrush   - Brush alignment origin

    Rop4        - ROP4 to use

Return Value:

    TRUE if ok, FALSE if failed


Author:

    Created - v-jimbr

    18-Dec-1993 Sat 09:34:06 created  -by-  DC
        Clean up formal argumeneted, commented

    15-Jan-1994 Sat 01:41:48 updated  -by-  DC
        added rclDst to DoFill() in case pco is NULL

    10-Mar-1994 Thu 00:35:06 updated  -by-  DC
        Fixed so when we call DoPolygon it will take prclDst (if not NULL)
        into account by intersect it with the rclBounds in the pco first

    25-Mar-1994 update -by- JB
        Modified function to enumerate clipping region if destination
        rectangle exists.

Revision History:


--*/

{
    PPDEV   pPDev;
    RECTL   rclDst;


    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DoFill: Invalid pPDev in psoDst"));
        return(FALSE);
    }

    //
    // Here we have to see if the clip obj is trivial or non existant, in which
    // case we pass this directly to fill rect.
    //

    if ((!pco)                          ||
        (pco->iDComplexity == DC_RECT)  ||
        (pco->iDComplexity == DC_TRIVIAL)) {

        if ((pco) && (pco->iDComplexity == DC_RECT)) {

            PLOTDBG(DBG_DOFILL,
              ("DoFill: pco = RECT %s", (prclDst) ? ", WITH dest rect" : "" ));

            //
            // First grab the destination as the bounding rect since,
            // we have a RECT clipping region
            //

            rclDst = pco->rclBounds;

            //
            // Now if we also had a destination rect passed in as well,
            // intersect down to the final rect
            //

            if (prclDst) {

                if ( !IntersectRECTL(&rclDst, prclDst)) {

                   return( TRUE );

                }
            }

            //
            // And finally point to the new rect for the fill
            //

            prclDst = &rclDst;

        } else if (!prclDst) {


            PLOTWARN(
              ("DoFill: No destination rectange and NULL or TRIVIAL pco!"));

            //
            // We don't have any clipping so fill the target rect
            //

            rclDst.left   =
            rclDst.top    = 0;
            rclDst.right  = psoDst->sizlBitmap.cx;
            rclDst.bottom = psoDst->sizlBitmap.cy;
            prclDst       = &rclDst;
        }

        return(DoRect(pPDev,
                      prclDst,
                      pbo,
                      NULL,
                      pptlBrush,
                      Rop4,
                      NULL,
                      FPOLY_FILL));

    } else {

        BOOL        Ok = TRUE;
        BOOL        bMore;
        HTENUMRCL   EnumRects;
        PRECTL      pCurClipRect;

        //
        // We have complex clipping but we also have a destination rect to
        // fill, this means we have to enum the clipping region as rects
        // so we can intersect each one with the target rect..
        //

        PLOTDBG(DBG_DOFILL,
                 ("DoFill: pco = COMPLEX %s", (prclDst) ? ", WITH dest rect" : "" ));

        if (prclDst) {


            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
            bMore = TRUE;

            do {

                //
                // See if the job has been aborted
                //

                if (PLOT_CANCEL_JOB(pPDev)) {

                    break;
                }

                //
                // Grab the next batch of rectangles
                //

                if (bMore) {

                    bMore = CLIPOBJ_bEnum(pco, sizeof(EnumRects), (ULONG *)&EnumRects);
                }


                //
                /// Set up for enuming the clip rectangles
                //

                pCurClipRect = (PRECTL)&EnumRects.rcl[0];


                while ((Ok) && (EnumRects.c--)) {

                    rclDst = *pCurClipRect;

                    //
                    // Make sure we have something left to fill after the
                    // intersect
                    //

                    if( IntersectRECTL(&rclDst, prclDst) ) {

                        Ok = DoRect( pPDev,
                                     &rclDst,
                                     pbo,
                                     NULL,
                                     pptlBrush,
                                     Rop4,
                                     NULL,
                                     FPOLY_FILL );

                    }
                    pCurClipRect++;
                }


            } while ( bMore );


        } else {


            Ok = DoPolygon(pPDev,
                           NULL,
                           pco,
                           NULL,
                           pptlBrush,
                           pbo,
                           NULL,
                           Rop4,
                           NULL,
                           FPOLY_FILL);


       }

       return(Ok);
    }
}




BOOL
DrvPaint(
    SURFOBJ     *psoDst,
    CLIPOBJ     *pco,
    BRUSHOBJ    *pbo,
    PPOINTL     pptlBrushOrg,
    MIX         Mix
    )

/*++

Routine Description:

    This function is the most basic drawing function in the driver. As graphic
    calls get failed, the NT graphics engine will reduce those other calls
    (if we fail them) down to DrvPaint. We cannot fail DrvPaint as the engine
    has nowhere else to go.

Arguments:

    Per DDI Spec.


Return Value:

    TRUE of OK, FALSE if falied

Author:

    Created by v-jimbr

    18-Dec-1993 Sat 09:27:29 updated  -by-  DC
        Updated, commented, change to correct formal header

    15-Jan-1994 Sat 00:38:41 updated  -by-  DC
        Re-arranged and call DrvBitBlt() if can do a damm thing.


Revision History:


--*/

{
    PPDEV       pPDev;
    RECTL       rclDst;
    DWORD       Rop4;

    //
    // get our PDEV from the SURFOBJ
    //

    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DrvPaint: Invalid pPDev in pso"));
        return(FALSE);
    }

    PLOTASSERT(0, "DrvPaint: WARNING: pco [%08lx] is NULL or DC_TRIVIAL???",
                (pco) && (pco->iDComplexity != DC_TRIVIAL), pco);

    if ((pco)                               &&
        (pco->iDComplexity == DC_TRIVIAL)   &&
        (pco->iFComplexity == FC_RECT)) {

        PLOTWARN(("DrvPaint: <pco> DC_TRIVIAL but NOT FC_RECT, make DC_RECT ??? (%ld,%ld)-(%ld,%ld)",
                    pco->rclBounds.left,
                    pco->rclBounds.top,
                    pco->rclBounds.right,
                    pco->rclBounds.bottom));

        pco->iDComplexity = DC_RECT;
    }

    //
    // Make sure we don't pass a NULL rect.
    //

    if ((pco) && (pco->iDComplexity != DC_TRIVIAL)) {

        rclDst = pco->rclBounds;

    } else {

        rclDst.left   =
        rclDst.top    = 0;
        rclDst.right  = psoDst->sizlBitmap.cx;
        rclDst.bottom = psoDst->sizlBitmap.cy;
    }

    Rop4 = MixToRop4(Mix);

    //
    // If we can actually draw the passed object with device brushes (etc)
    // then do it now. Otherwise, we will have to simulate it via DrvBitBlt
    //

    if (GetColor(pPDev, pbo, NULL, NULL, Rop4) > 0) {

        PLOTDBG(DBG_DRVPAINT, ("DrvPAINT: Calling DoFill()"));

        return(DoFill(psoDst,               // psoDst
                      NULL,                 // psoSrc
                      pco,                  // pco
                      NULL,                 // pxlo
                      NULL,                 // prclDest only fill based on pco
                      NULL,                 // prclSrc
                      pbo,                  // pbo
                      pptlBrushOrg,         // pptlBrushOrg
                      Rop4));               // Rop4

    } else {

        PLOTDBG(DBG_DRVPAINT, ("DrvPAINT: Can't do it Calling DrvBitBlt()"));

        return(DrvBitBlt(psoDst,            // psoDst
                         NULL,              // psoSrc
                         NULL,              // psoMask
                         pco,               // pco
                         NULL,              // pxlo
                         &rclDst,           // prclDst
                         (PPOINTL)&rclDst,  // pptlSrc
                         NULL,              // pptlMask
                         pbo,               // pbo,
                         pptlBrushOrg,      // pptlBrushOrg,
                         Rop4));            // Rop4
    }
}





BOOL
DrvFillPath(
    SURFOBJ     *pso,
    PATHOBJ     *ppo,
    CLIPOBJ     *pco,
    BRUSHOBJ    *pbo,
    POINTL      *pptlBrushOrg,
    MIX         Mix,
    FLONG       flOptions
    )

/*++

Routine Description:

    This function will take a PATHOBJ as a parameter and fill in
    the closed region with the specified brush.

Arguments:

    Per DDI spec.


Return Value:

    TRUE if ok, FALSE if error

Author:

    18-Dec-1993 Sat 09:27:29 created  -by-  DC
        Updated, commented


    Created by v-jimbr

Revision History:


--*/

{
    PPDEV    pPDev;
    ULONG    ulOptions;
    ROP4     rop4;
    BOOL     bRetVal;



    //
    // Convert the mix to a rop since we  use it more than once
    //

    rop4 = MixToRop4(Mix);

    PLOTDBG(DBG_DRVFILLPATH, ("DrvFillPath: Mix = %x, Rop4 = %x", Mix, rop4));

    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvFillPath: Invalid pPDev in pso"));
        return(FALSE);
    }


    //
    // Get color will tell us if the requested op can be done in HPGL2 mode
    // if it cant, we have to simulate via DrvBitBlt
    //

    if (GetColor(pPDev, pbo, NULL, NULL, rop4) > 0 ) {

       ulOptions = FPOLY_FILL;

       if (flOptions & FP_WINDINGMODE) {

          //
          // Set the flag to notify the generic path code about the fill type
          //

          ulOptions |= FPOLY_WINDING;
       }

       bRetVal = DoPolygon(pPDev,
                           NULL,
                           pco,
                           ppo,
                           pptlBrushOrg,
                           pbo,
                           NULL,
                           rop4,
                           NULL,
                           ulOptions);
    } else {

       bRetVal = FALSE;

       PLOTDBG(DBG_DRVFILLPATH, ("DrvFillPath: Failing because GetColor <= 0 "));

    }

    return( bRetVal );
}





BOOL
DrvStrokeAndFillPath(
    SURFOBJ     *pso,
    PATHOBJ     *ppo,
    CLIPOBJ     *pco,
    XFORMOBJ    *pxo,
    BRUSHOBJ    *pboStroke,
    LINEATTRS   *plineattrs,
    BRUSHOBJ    *pboFill,
    POINTL      *pptlBrushOrg,
    MIX         MixFill,
    FLONG       flOptions
    )

/*++

Routine Description:

    This function will take a PATHOBJ as a parameter, fill in
    the closed region with the FILL brush, and stroke the path with
    the STROKE brush.


Arguments:

    Per DDI

Return Value:

    TRUE if ok, FALSE if error


Author:

    18-Dec-1993 Sat 09:27:29 created  -by-  DC
        Updated, commented


    Created by v-jimbr


Revision History:


--*/

{
    PPDEV       pPDev;
    ULONG       ulOptions;
    BOOL        bRetVal;
    ROP4        rop4;


    //
    // Convert the mix to a rop since we  use it more than once
    //

    rop4 = MixToRop4(MixFill);


    PLOTDBG(DBG_DRVSTROKEANDFILL, ("DrvStrokeAndFillPath: Mix = %x, Rop4 = %x", MixFill, rop4));

    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvStrokeAndFillPath: Invalid pPDev in pso"));
        return(FALSE);
    }




    if (GetColor(pPDev, pboFill, NULL, NULL, rop4) > 0 ) {


       ulOptions = FPOLY_STROKE | FPOLY_FILL;

       if (flOptions & FP_WINDINGMODE) {

          ulOptions |= FPOLY_WINDING;
       }

       bRetVal = DoPolygon(pPDev,
                           NULL,
                           pco,
                           ppo,
                           pptlBrushOrg,
                           pboFill,
                           pboStroke,
                           rop4,
                           plineattrs,
                           ulOptions);
    } else {


       bRetVal = FALSE;

       PLOTDBG(DBG_DRVSTROKEANDFILL,
                ("DrvStrokeAndFillPath: Failing because GetColor is <= 0",
                MixFill, rop4));

    }

    return(bRetVal);
}




BOOL
DrvCopyBits(
   SURFOBJ  *psoDst,
   SURFOBJ  *psoSrc,
   CLIPOBJ  *pco,
   XLATEOBJ *pxlo,
   RECTL    *prclDst,
   POINTL   *pptlSrc
   )

/*++

Routine Description:

    Convert between two bitmap formats

Arguments:

    Per Engine spec.

Return Value:

    BOOLEAN


Author:

    11-Feb-1993 Thu 21:00:43 created  -by-  DC

    09-Feb-1994 Wed 16:49:17 updated  -by-  DC
        Adding rclHTBlt to have psoHTBlt correctly tiled, also check if the
        pco is passed.

    19-Jan-1994 Wed 14:28:45 updated  -by-  DC
        Adding hack to handle EngStretchBlt() to our own temp surfobj

    06-Jan-1994 Thu 04:34:37 updated  -by-  DC
        Make sure we do not do this for pen plotter

    01-Mar-1994 Tue 10:51:58 updated  -by-  DC
        Make the call to BandingHTBlt() rather to EngStretchBlt()


Revision History:


--*/

{
    SURFOBJ *psoHTBlt;
    PPDEV   pPDev;
    RECTL   rclDst;


    //
    // Copy down the destination rectangle
    //

    rclDst = *prclDst;

    PLOTDBG(DBG_COPYBITS, ("DrvCopyBits: Dst=(%ld, %ld)-(%ld-%ld) [%ld x %ld]",
                rclDst.left, rclDst.top, rclDst.right, rclDst.bottom,
                rclDst.right - rclDst.left,
                rclDst.bottom - rclDst.top));

    //
    // The DrvCopyBits() function lets applicatiosn convert between bitmap and
    // device formats.
    //
    // BUT... for our plotter device we cannot read the printer surface
    //        bitmap back, so tell the caller that we cannot do it if they
    //        really called us with that sort of request.
    //

    if (psoSrc->iType != STYPE_BITMAP) {

        DWORD   Color = 0xFFFFFF;

        PLOTASSERT(1, "DrvCopyBits: psoSrc->iType not STYPE_DEVICE",
                    psoSrc->iType == STYPE_DEVICE, psoSrc->iType);

        //
        // Someone tried to copy from a non-bitmap surface, ie STYPE_DEVICE
        //

        if (pxlo) {

            Color = XLATEOBJ_iXlate(pxlo, Color);
        }

        //
        // If we doing XOR then we want to have all area = 0 first
        //

        if (!(pPDev = SURFOBJ_GETPDEV(psoSrc))) {

            PLOTERR(("DrvCopyBits: invalid pPDev"));
            return(FALSE);
        }

        if (pPDev->Rop3CopyBits == 0x66) {

            PLOTWARN(("DrvCopyBits: Rop3CopyBits = 0x66, Color = 0x0"));
            Color = 0;
        }

        PLOTWARN(("DrvCopyBits: Cannot copy from DEVICE, Do EngErase=(%ld,%ld)-(%ld, %ld), COLOR=%08lx)",
                rclDst.left, rclDst.top, rclDst.right, rclDst.bottom, Color));

        return(EngEraseSurface(psoDst, prclDst, Color));
    }

    if (psoDst->iType != STYPE_DEVICE) {

        //
        // Someone tried to copy to bitmap surface, ie STYPE_BITMAP
        //

        PLOTWARN(("DrvCopyBits: Cannot copy to NON-DEVICE destination"));

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DrvCopyBits: invalid pPDev"));
        return(FALSE);
    }

    //
    // If this is us calling ourselves during bitmap handling do it now.
    //

    if (psoHTBlt = pPDev->psoHTBlt) {

        PLOTDBG(DBG_TEMPSRC, ("DrvCopyBits: psoHTBlt=%ld x %ld, psoSrc=%ld x %ld, pptlSrc=(%ld, %ld)",
                    psoHTBlt->sizlBitmap.cx, psoHTBlt->sizlBitmap.cy,
                    psoSrc->sizlBitmap.cx, psoSrc->sizlBitmap.cy,
                    pptlSrc->x, pptlSrc->y));

        PLOTDBG(DBG_TEMPSRC, ("DrvCopyBits: szlHTBlt=(%ld, %ld)-(%ld, %ld) = %ld x %ld",
                        pPDev->rclHTBlt.left,  pPDev->rclHTBlt.top,
                        pPDev->rclHTBlt.right, pPDev->rclHTBlt.bottom,
                        pPDev->rclHTBlt.right - pPDev->rclHTBlt.left,
                        pPDev->rclHTBlt.bottom - pPDev->rclHTBlt.top));

        PLOTASSERT(1, "DrvCopyBits: psoHTBlt Type != psoSrc Type",
                    psoHTBlt->iType == psoSrc->iType, 0);

        PLOTASSERT(0, "DrvCopyBits: ??? pptlSrc [%08lx] != (0, 0)",
                    (pptlSrc->x == 0) && (pptlSrc->y == 0), pptlSrc);

        if ((!pco) || (pco->iDComplexity == DC_TRIVIAL)) {

            PLOTASSERT(1, "DrvCopyBits: psoHTBlt Size < psoSrc Size",
                    (psoHTBlt->sizlBitmap.cx >= psoSrc->sizlBitmap.cx) &&
                    (psoHTBlt->sizlBitmap.cy >= psoSrc->sizlBitmap.cy), 0);

            PLOTASSERT(1, "DrvCopyBits: rclHTBlt > psoHTBlt size",
                    (pPDev->rclHTBlt.left   <= psoHTBlt->sizlBitmap.cx) &&
                    (pPDev->rclHTBlt.right  <= psoHTBlt->sizlBitmap.cx) &&
                    (pPDev->rclHTBlt.top    <= psoHTBlt->sizlBitmap.cy) &&
                    (pPDev->rclHTBlt.bottom <= psoHTBlt->sizlBitmap.cy),
                    0);

            PLOTASSERT(1, "DrvCopyBits: pPDev->rclHTBlt Size != psoSrc Size",
                ((pPDev->rclHTBlt.right - pPDev->rclHTBlt.left) ==
                                                    psoSrc->sizlBitmap.cx) &&
                ((pPDev->rclHTBlt.bottom - pPDev->rclHTBlt.top) ==
                                                    psoSrc->sizlBitmap.cy),
                0);

        } else if (pco->iDComplexity == DC_RECT) {

            PLOTWARN(("DrvCopyBits: **** MAY BE EngStretchBlt(HALFTONE) FAILED but we got EngStretchBlt(COLORONCOLOR) instead"));

            PLOTASSERT(1, "DrvCopyBits: rclHTBlt != pco->rclBounds, pco=%08lx",
                ((pPDev->rclHTBlt.right - pPDev->rclHTBlt.left) ==
                 (pco->rclBounds.right - pco->rclBounds.left)) &&
                ((pPDev->rclHTBlt.bottom - pPDev->rclHTBlt.top) ==
                 (pco->rclBounds.bottom - pco->rclBounds.top)), pco);

        } else {

            PLOTASSERT(1, "DrvCopyBits: <psoHTBlt>, pco [%08lx] is Complex.",
                       pco->iDComplexity != DC_COMPLEX, pco);
        }

        if (!EngCopyBits(psoHTBlt,              // psoDst
                         psoSrc,                // psoSrc
                         pco,                   // pco
                         NULL,                  // pxlo
                         &(pPDev->rclHTBlt),    // prclDst
                         pptlSrc)) {            // pptlSrc

            PLOTERR(("DrvCopyBits: EngCopyBits(psoHTBlt, psoSrc) Failed"));
        }

        return(TRUE);
    }

    if (!IS_RASTER(pPDev)) {

        PLOTDBG(DBG_COPYBITS, ("DrvCopyBits: Pen Plotter: IGNORE and return OK"));
        return(TRUE);
    }

    //
    // First validate everything to see if this one is the halftoned result
    // or is compatible with halftoned result, otherwise we will call
    // EngStretchBlt(HALFTONE) halftone the sources then it will eventually
    // come back to this function to output the halftoned result.
    //

    if (IsHTCompatibleSurfObj(pPDev,
                              psoSrc,
                              pxlo,
                              ISHTF_ALTFMT | ISHTF_HTXB | ISHTF_DSTPRIM_OK)) {

        DWORD   Rop;

        if (!(Rop = (DWORD)(pPDev->Rop3CopyBits & 0xFF))) {

            Rop = 0xCC;
        }

        PLOTDBG(DBG_COPYBITS, ("DrvCopyBits: HTCompatible: Rop=%08lx", Rop));

        pPDev->Rop3CopyBits = 0xCC;     // RESET!!!

        return(OutputHTBitmap(pPDev,
                              psoSrc,
                              pco,
                              (PPOINTL)&rclDst,
                              NULL,
                              Rop,
                              NULL));

    } else {

        RECTL   rclSrc;


        rclSrc.left   = pptlSrc->x;
        rclSrc.top    = pptlSrc->y;
        rclSrc.right  = rclSrc.left + (rclDst.right - rclDst.left);
        rclSrc.bottom = rclSrc.top  + (rclDst.bottom - rclDst.top);

        //
        // Validate that we only BLT the available source size
        //

        if ((rclSrc.right > psoSrc->sizlBitmap.cx) ||
            (rclSrc.bottom > psoSrc->sizlBitmap.cy)) {

            PLOTWARN(("DrvCopyBits: Engine passed SOURCE != DEST size, CLIP IT"));

            rclSrc.right  = psoSrc->sizlBitmap.cx;
            rclSrc.bottom = psoSrc->sizlBitmap.cy;

            rclDst.right  = (LONG)(rclSrc.right - rclSrc.left + rclDst.left);
            rclDst.bottom = (LONG)(rclSrc.bottom - rclSrc.top + rclDst.top);
        }

        PLOTDBG(DBG_COPYBITS, ("DrvCopyBits CALLING BandingHTBlt()"));

        return(BandingHTBlt(pPDev,          // pPDev
                            psoDst,         // psoDst
                            psoSrc,         // psoSrc
                            NULL,           // psoMask,
                            pco,            // pco
                            pxlo,           // pxlo
                            NULL,           // pca
                            NULL,           // pptlHTOrg
                            &rclDst,        // prclDst
                            &rclSrc,        // prclSrc
                            NULL,           // pptlMask
                            0xCCCC,         // HTRop3
                            FALSE));        // InvertMask
    }

}




BOOL
DrvStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    PRECTL          prclDst,
    PRECTL          prclSrc,
    PPOINTL         pptlMask,
    ULONG           iMode
    )

/*++

Routine Description:

    This function halftones a source rectangle and optionally can invert
    the source and handle a mask.

    It also provides, StretchBlt capabilities between Device managed and
    GDI managed surfaces. We want the driver to be able to write on GDI
    managed bitmaps, especially when doing halftoning. This allows the same
    algorithm to be used for both GDI and device surfaces.

    This function is optional in drivers, it can return FALSE if it does
    not know how to handle the work.

Arguments:

    psoDst      - This is a pointer to a SURFOBJ.    It identifies the surface
                  on which to draw.

    psoSrc      - This SURFOBJ defines the source for the Blt operation.  The
                  driver must call GDI Services to find out if this is a device
                  managed  surface or a bitmap managed by GDI.

    psoMask     - This optional surface provides a mask for the source.  It is
                  defined by a logic map, i.e. a bitmap with one bit per pel.

                  The mask is used to limit the area of the source that is
                  copied.  When a mask is provided there is an implicit rop4 of
                  0xCCAA, which means that the source should be copied wherever
                  the mask is 1, but the destination should be left alone
                  wherever the mask is 0.

                  When this argument is NULL there is an implicit rop4 of
                  0xCCCC, which means that the source should be copied
                  everywhere in the source rectangle.

                  The mask will always be large enough to contain the source
                  rectangle, tiling does not need to be done.

    pco         - This is a pointer to a CLIPOBJ.    GDI Services are provided
                  to enumerate the clipping region as a set of rectangles or
                  trapezoids. This limits the area of the destination that will
                  be modified.

                  Whenever possible, GDI will simplify the clipping involved.
                  However, unlike DrvBitBlt, DrvStretchBlt may be called with a
                  single clipping rectangle.  This is necessary to prevent
                  roundoff errors in clipping the output.

    pxlo        - This is a pointer to an XLATEOBJ.  It tells how color indices
                  should be translated between the source and target surfaces.

                  The XLATEOBJ can also be queried to find the RGB color for
                  any source index.  A high quality stretching Blt will need
                  to interpolate colors in some cases.

    pca         - This is a pointer to COLORADJUSTMENT structure, if NULL it
                  specified that appiclation did not set any color adjustment
                  for this DC, and is up to the driver to provide default
                  adjustment

    pptlBrushOrg- Pointer to the POINT structure to specified the location
                  where halftone brush should alignment to, if this pointer is
                  NULL then it assume that (0, 0) as origin of the brush

    prclDst     - This RECTL defines the area in the coordinate system of the
                  destination surface that can be modified.

                  The rectangle is defined by two points.    These points are
                  not well ordered, i.e. the coordinates of the second point
                  are not necessarily larger than those of the first point.
                  The rectangle they describe does not include the lower and
                  right edges.  DrvStretchBlt will never be called with an
                  empty destination rectangle.

                  DrvStretchBlt can do inversions in both x and y, this happens
                  when the destination rectangle is not well ordered.

    prclSrc     - This RECTL defines the area in the coordinate system of the
                  source surface that will be copied.  The rectangle is defined
                  by two points, and will map onto the rectangle defined by
                  prclDst.  The points of the source rectangle are well
                  ordered.  DrvStretch will never be given an empty source
                  rectangle.

                  Note that the mapping to be done is defined by prclSrc and
                  prclDsst. To be precise, the given points in prclDst and
                  prclSrc lie on integer coordinates, which we consider to
                  correspond to pel centers.  A rectangle defined by two such
                  points should be considered a geometric rectangle with two
                  vertices whose coordinates are the given points, but with 0.5
                  subtracted from each coordinate.  (The POINTLs should just be
                  considered a shorthand notation for specifying these
                  fractional coordinate vertices.)  Note thate the edges of any
                  such rectangle never intersect a pel, but go around a set of
                  pels.  Note also that the pels that are inside the rectangle
                  are just what you would expect for a "bottom-right exclusive"
                  rectangle.  The mapping to be done by DrvStretchBlt will map
                  the geometric source rectangle exactly onto the geometric
                  destination rectangle.

    pptlMask    - This POINTL specifies which pel in the given mask corresponds
                  to the upper left pel in the source rectangle.  Ignore this
                  argument if there is no given mask.


    iMode       - This defines how source pels should be combined to get output
                  pels. The methods SB_OR, SB_AND, and SB_IGNORE are all simple
                  and fast.  They provide compatibility for old applications,
                  but don't produce the best looking results for color surfaces.


                  SB_OR         On a shrinking Blt the pels should be combined
                                with an OR operation.  On a stretching Blt pels
                                should be replicated.

                  SB_AND        On a shrinking Blt the pels should be combined
                                with an AND operation.  On a stretching Blt
                                pels should be replicated.

                  SB_IGNORE     On a shrinking Blt enough pels should be
                                ignored so that pels don't need to be combined.
                                On a stretching Blt pels should be replicated.

                  SB_BLEND      RGB colors of output pels should be a linear
                                blending of the RGB colors of the pels that get
                                mapped onto them.

                  SB_HALFTONE   The driver may use groups of pels in the output
                                surface to best approximate the color or gray
                                level of the input.

                  For this function we will ignored this parameter and always
                  output the SB_HALFTONE result

Return Value:


    TRUE if sucessful FALSE if failed

Author:

    11-Feb-1993 Thu 19:52:29 created  -by-  DC

    06-Jan-1994 Thu 04:34:37 updated  -by-  DC
        Make sure we do not do this for pen plotter

    23-Feb-1994 Wed 11:02:45 updated  -by-  DC
        Re-write and take banding the bitmap into account

    01-Mar-1994 Tue 10:55:03 updated  -by-  DC
        spawan out to a separate function and Make call to BandingHTBlt()

Revision History:


--*/

{
    PPDEV   pPDev;

    UNREFERENCED_PARAMETER(iMode);          // we always do HALFTONE

    //
    // get the pointer to our DEVDATA structure and make sure it is ours.
    //

    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DrvStretchBlt: invalid pPDev"));
        return(FALSE);
    }

    return(BandingHTBlt(pPDev,          // pPDev
                        psoDst,         // psoDst
                        psoSrc,         // psoSrc
                        psoMask,        // psoMask,
                        pco,            // pco
                        pxlo,           // pxlo
                        pca,            // pca
                        pptlBrushOrg,   // pptlHTOrg
                        prclDst,        // prclDst
                        prclSrc,        // prclSrc
                        pptlMask,       // pptlMask
                        0x88CC,         // HTRo3
                        FALSE));        // InvertMask
}





BOOL
DrvBitBlt(
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMask,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PPOINTL     pptlSrc,
    PPOINTL     pptlMask,
    BRUSHOBJ    *pbo,
    PPOINTL     pptlBrushOrg,
    ROP4        Rop4
    )

/*++

Routine Description:

    Provides general Blt capabilities to device managed surfaces.  The Blt
    might be from an Engine managed bitmap.  In that case, the bitmap is
    one of the standard format bitmaps.    The driver will never be asked
    to Blt to an Engine managed surface.

    This function is required if any drawing is done to device managed
    surfaces.  The basic functionality required is:

      1    Blt from any standard format bitmap or device surface to a device
           surface,

      2    with any ROP,

      3    optionally masked,

      4    with color index translation,

      5    with arbitrary clipping.

    Engine services allow the clipping to be reduced to a series of clip
    rectangles.    A translation vector is provided to assist in color index
    translation for palettes.

    This is a large and complex function.  It represents most of the work
    in writing a driver for a raster display device that does not have
    a standard format frame buffer.  The Microsoft VGA driver provides
    example code that supports the basic function completely for a planar
    device.

    NOTE: Plotters do not support copying from device bitmaps. Nor can they
          perform raster operations on bitmaps.  Therefore, it is not possible
          to support ROPs which interact with the destination (ie inverting
          the destination).  The driver will do its best to map these ROPs
          into ROPs utilizing functions on the Source or Pattern.

          This driver supports the bitblt cases indicated below:

          Device -> Memory  No
          Device -> Device  No
          Memory -> Memory  No
          Memory -> Device  Yes
          Brush  -> Memory  No
          Brush  -> Device  Yes


Arguments:


    psoDest         - This is a pointer to a device managed SURFOBJ.  It
                      identifies the surface on which to draw.

    psoSrc          - If the rop requires it, this SURFOBJ defines the source
                      for the Blt operation.  The driver must call the Engine
                      Services to find out if this is a device managed surface
                      or a bitmap managed by the Engine.

    psoMask         - This optional surface provides another input for the
                      Rop4.  It is defined by a logic map, i.e. a bitmap with
                      one bit per pel.  The mask is typically used to limit the
                      area of the destination that should be modified.  This
                      masking is accomplished by a Rop4 whose lower byte is AA,
                      leaving the destination unaffected when the mask is 0.

                      This mask, like a brush, may be of any size and is
                      assumed to tile to cover the destination of the Blt.  If
                      this argument is NULL and a mask is required by the Rop4,
                      the implicit mask in the brush will be used.

    pco             - This is a pointer to a CLIPOBJ.    Engine Services are
                      provided to enumerate the clipping region as a set of
                      rectangles or trapezoids.  This limits the area of the
                      destination that will be modified.  Whenever possible,
                      the Graphics Engine will simplify the clipping involved.
                      For example, BitBlt will never be called with exactly one
                      clipping rectangle.    The Engine will have clipped the
                      destination rectangle before calling, so that no clipping
                      needs to be considered.

    pxlo            - This is a pointer to an XLATEOBJ.  It tells how color
                      indices should be translated between the source and
                      target surfaces.

                      If the source surface is palette managed, then its colors
                      are represented by indices into a list of RGB colors.
                      In this case, the XLATEOBJ can be queried to get a
                      translate vector that will allow the device driver to
                      quickly translate any source index into a color index for
                      the destination.

                      The situation is more complicated when the source is, for
                      example, RGB but the destination is palette managed.  In
                      this case a closest match to each source RGB must be
                      found in the destination palette.  The XLATEOBJ provides
                      a service routine to do this matching.  (The device
                      driver is allowed to do the matching itself when the
                      target palette is the default device palette.)

    prclDst         - This RECTL defines the area in the coordinate system of
                      the destination surface that will be modified.  The
                      rectangle is defined as two points, upper left and lower
                      right.  The lower and right edges of this rectangle are
                      not part of the Blt, i.e. the rectangle is lower right
                      exclusive.  vBitBlt will never be called with an empty
                      destination rectangle, and the two points of the
                      rectangle will always be well ordered.

    pptlSrc         - This POINTL defines the upper left corner of the source
                      rectangle, if there is a source.  Ignore this argument
                      if there is no source.

    pptlMask        - This POINTL defines which pel in the mask corresponds to
                      the upper left corner of the destination rectangle.
                      Ignore this argument if no mask is provided with psoMask.

    pdbrush         - This is a pointer to the device's realization of the
                      brush to be used in the Blt.  The pattern for the Blt is
                      defined by this brush.  Ignore this argument if the Rop4
                      does not require a pattern.

    pptlBrushOrg    - This is a pointer to a POINTL which defines the origin of
                      the brush.  The upper left pel of the brush is aligned
                      here and the brush repeats according to its dimensions.
                      Ignore this argument if the Rop4 does not require a
                      pattern.

    Rop4            - This raster operation defines how the mask, pattern,
                      source, and destination pels should be combined to
                      determine an output pel to be written on the destination
                      surface.

                      This is a quaternary raster operation, which is a natural
                      extension of the usual ternary rop3.  There are 16
                      relevant bits in the Rop4,  these are like the 8 defining
                      bits of a rop3.  (We ignore the other bits of the rop3,
                      which are redundant.)    The simplest way to implement a
                      Rop4 is to consider its two bytes separately.  The lower
                      byte specifies a rop3 that should be computed wherever
                      the mask is 0.  The high byte specifies a rop3 that
                      should then be computed and applied wherever the mask
                      is 1.


Return Value:

    TRUE if sucessfule FALSE otherwise


Author:

    04-Dec-1990     -by-     KS
        Wrote it.

    27-Mar-1992 Fri 00:08:43 updated  -by-  DC
        1) Remove 'pco' parameter and replaced it with prclClipBound parameter,
           since pco is never referenced, prclClipBound is used for the
           halftone.
        2) Add another parameter to do NOTSRCCOPY

    11-Feb-1993 Thu 21:29:15 updated  -by-  DC
        Modified so that it call DrvStretchBlt(HALFTONE) when it can.

    18-Dec-1993 Sat 09:08:16 updated  -by-  DC
        Clean up for plotter driver

    06-Jan-1994 Thu 04:34:37 updated  -by-  DC
        Make sure we do not do this for pen plotter

    15-Jan-1994 Sat 04:02:22 updated  -by-  DC
        Re-write

    17-Mar-1994 Thu 22:36:42 updated  -by-  DC
        Changed it so we only use PATTERN=psoMask if the ROP4 do not required
        PATTERNs and a MASK is required


Revision History:


--*/

{
    PPDEV       pPDev;
    DWORD       Rop3FG;
    DWORD       Rop3BG;
    RECTL       rclSrc;
    RECTL       rclPat;
    UINT        i;
    BOOL        Ok = TRUE;


    //
    // if the source is NULL it must be a fill, so call the fill code,
    //

    PLOTDBG(DBG_BITBLT, ("DrvBitBlt: ROP4  = %08lx", Rop4));

    PLOTASSERT(1, "DrvBitBlt: Invalid ROP code = %08lx",
                                            (Rop4 & 0xffff0000) == 0, Rop4);

    //
    // get the pointer to our DEVDATA structure and make sure it is ours.
    //

    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DrvBithBlt: invalid pPDev"));
        return(FALSE);
    }

    if (IS_RASTER(pPDev)) {

        i = (UINT)pPDev->pPlotGPC->ROPLevel;

    } else {

        PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Pen Plotter: TRY ROP_LEVEL_0"));

        i = ROP_LEVEL_0;
    }

    Rop3BG = (DWORD)ROP4_BG_ROP(Rop4);
    Rop3FG = (DWORD)ROP4_FG_ROP(Rop4);

    switch (i) {

    case ROP_LEVEL_0:

        //
        // For RopLevel 0, or Pen Plotter we will only process the pattern
        // which is compatible with our device
        //

        if (ROP3_NEED_PAT(Rop3FG)) {

            PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Device ROP_LEVEL_0, NEED PAT"));

            if (GetColor(pPDev, pbo, NULL, NULL, Rop3FG) <= 0) {

                PLOTWARN(("DrvBitBlt: NOT Device Comptible PAT"));
                return(TRUE);
            }

            PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Device ROP_LEVEL_0, TRY COMPATIBLE PAT"));

        } else {

            PLOTWARN(("DrvBitBlt: Device ROP_LEVEL_0, CANNOT Do RASTER BLT"));
            return(TRUE);
        }

        //
        // Make it PAT Copy
        //

        Rop4   = 0xF0F0;
        Rop3BG =
        Rop3FG = 0xF0;

        break;

    case ROP_LEVEL_1:

        //
        // Can only do ROP1 SRC COPY/NOT SRCCOPY
        //

        PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Device ROP_LEVEL_1, Rop4=%08lx", Rop4));

        switch(Rop4 = ROP4_FG_ROP(Rop4)) {

        case 0xAA:
        case 0xCC:
        case 0x33:

            break;

        default:

            PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Make ROP4 = 0xCC"));

            Rop4 = 0xCC;
            break;
        }

        Rop4 |= (Rop4 << 8);
        break;


    case ROP_LEVEL_2:
    case ROP_LEVEL_3:

        break;

    default:

        PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Device RopLevel=%ld, do nothing",
                                (DWORD)pPDev->pPlotGPC->ROPLevel));
        return(TRUE);
    }

    //
    // Do DrvStrethcBlt (HALFTONE) first if we can. Since there is no way
    // for us to read back the device surface we can only try our best
    // to simulate the requested drawing operation.
    //

    if (pptlSrc) {

        rclSrc.left = pptlSrc->x;
        rclSrc.top  = pptlSrc->y;

    } else {

        rclSrc.left =
        rclSrc.top  = 0;
    }

    rclSrc.right  = rclSrc.left + (prclDst->right - prclDst->left);
    rclSrc.bottom = rclSrc.top  + (prclDst->bottom - prclDst->top);

    switch (Rop4) {

    case 0xAAAA:    //  D

        return(TRUE);

    case 0xAACC:
    case 0xCCAA:
    case 0xAA33:
    case 0x33AA:

        //
        // If we have ~S (NOT SOURCE) then we want to make the non-mask area
        // black , we do this using S^D (0x66).
        //

        if ((Rop4 == 0xAA33) || (Rop4 == 0x33AA)) {

            Rop4 = 0x6666;

        } else {

            Rop4 = 0x8888;
        }

        return(BandingHTBlt(pPDev,                      // pPDev
                            psoDst,                     // psoDst
                            psoSrc,                     // psoSrc
                            psoMask,                    // psoMask,
                            pco,                        // pco
                            pxlo,                       // pxlo
                            NULL,                       // pca
                            pptlBrushOrg,               // pptlHTOrg
                            prclDst,                    // prclDst
                            &rclSrc,                    // prclSrc
                            pptlMask,                   // pptlMask
                            (WORD)Rop4,                 // HTRo3
                            Rop3FG == 0xAA));          // InvertMask

    case 0x3333:    // ~S
    case 0xCCCC:    //  S

        //
        // We will output the bitmap directly to the surface if the following
        // conditions are all met
        //
        //  1. SRC = STYPE_BITMAP
        //  2. Format is compatible with HT
        //

        if ((psoSrc->iType == STYPE_BITMAP) &&
            (IsHTCompatibleSurfObj(pPDev,
                                   psoSrc,
                                   pxlo,
                                   ISHTF_ALTFMT     |
                                    ISHTF_HTXB      |
                                    ISHTF_DSTPRIM_OK))) {

            return(OutputHTBitmap(pPDev,
                                  psoSrc,
                                  pco,
                                  (PPOINTL)prclDst,
                                  &rclSrc,
                                  Rop4 & 0xFF,
                                  NULL));

        } else {

            //
            // Call BandingHTBlt(Rop4) to do the job
            //

            return(BandingHTBlt(pPDev,                  // pPDev
                                psoDst,                 // psoDst
                                psoSrc,                 // psoSrc
                                NULL,                   // psoMask,
                                pco,                    // pco
                                pxlo,                   // pxlo
                                NULL,                   // pca
                                pptlBrushOrg,           // pptlHTOrg
                                prclDst,                // prclDst
                                &rclSrc,                // prclSrc
                                NULL,                   // pptlMask
                                (WORD)Rop4,             // HTRo3
                                FALSE));                // InvertMask
        }

        break;

    default:

        if ((Rop3BG != Rop3FG)          &&          // NEED MASK?
            (!ROP3_NEED_DST(Rop3BG))    &&
            (!ROP3_NEED_DST(Rop3FG))) {

            PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Not required DEST, Calling  EngBitBlt()"));

            if (!(Ok = EngBitBlt(psoDst,            // psoDst
                                 psoSrc,            // psoSrc
                                 psoMask,           // psoMask
                                 pco,               // pco
                                 pxlo,              // pxlo
                                 prclDst,           // prclDst
                                 pptlSrc,           // pptlSrc
                                 pptlMask,          // pptlMask
                                 pbo,               // pbo
                                 pptlBrushOrg,      // pptlBrushOrg ZERO
                                 Rop4))) {

                PLOTERR(("DrvBitBlt: EngBitBlt(%04lx) FAILED", Rop4));
            }

        } else {

            CLONESO CloneSO[CSI_TOTAL];

            //
            // Clear all the clone surface memory
            //

            ZeroMemory(CloneSO, sizeof(CloneSO));

            //
            // We will using psoMask as Pattern ONLY IF
            //
            //  1. ROP4 required a MASK
            //  2. Forground NOT required a PATTERN
            //  3. Background NOT reauired a PATTERN
            //

            if ((Rop3BG != Rop3FG)          &&
                (!ROP3_NEED_PAT(Rop3BG))    &&
                (!ROP3_NEED_PAT(Rop3FG))) {

                //
                // We will condense the ROP4 to a ROP3 and use the psoMAsk
                // as the Pattern. We must make sure the pptlBrushOrg is NULL
                // so we DON'T align rclPat on the destination.
                //

                Rop3FG = (Rop3BG & 0xF0) | (Rop3FG & 0x0F);
                Rop3BG = 0xAA;

                PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Rop4=%04lx, Pattern=psoMask=%08lx, Rop3=%02lx/%02lx",
                                                Rop4, psoMask, Rop3BG, Rop3FG));

                rclPat.left   = pptlMask->x;
                rclPat.top    = pptlMask->y;
                rclPat.right  = rclPat.left + (rclSrc.right - rclSrc.left);
                rclPat.bottom = rclPat.top + (rclSrc.bottom - rclSrc.top);
                pptlBrushOrg  = NULL;

            } else {

                //
                // We will NOT do the background operation for now
                //

                if (Rop3FG == 0xAA) {

                    Rop3FG = Rop3BG;

                } else {

                    Rop3BG = Rop3FG;
                }

                //
                // We have a real pattern so make sure we aligned rclPat on
                // the destination correctly by passing a valid pptlBrushOrg,
                // NOTE: The rclPat will be setup by CloneBitBltSURFOBJ()
                //

                psoMask = NULL;

                if (!pptlBrushOrg) {

                    pptlBrushOrg = (PPOINTL)&ptlZeroOrigin;
                }
            }

            if (!(Ok = CloneBitBltSURFOBJ(pPDev,
                                          psoDst,
                                          psoSrc,
                                          psoMask,
                                          pxlo,
                                          prclDst,
                                          &rclSrc,
                                          &rclPat,
                                          pbo,
                                          CloneSO,
                                          Rop3BG,
                                          Rop3FG))) {

                PLOTDBG(DBG_BITBLT, ("DrvBitBlt: CloneBitbltSURFOBJ: failed"));
            }

            if (CloneSO[CSI_SRC].pso) {

                psoSrc = CloneSO[CSI_SRC].pso;
                pxlo   = NULL;
            }

            //
            // Only do background if BG != FG, and BG != DEST
            //

            if ((Ok) && (Rop3BG != Rop3FG) && (Rop3BG != 0xAA)) {

                if (!(Ok = DoRop3(pPDev,
                                  psoDst,
                                  psoSrc,
                                  CloneSO[CSI_PAT].pso,
                                  CloneSO[CSI_TMP].pso,
                                  pco,
                                  pxlo,
                                  prclDst,
                                  &rclSrc,
                                  &rclPat,
                                  pptlBrushOrg,
                                  pbo,
                                  Rop3BG))) {

                    PLOTERR(("DrvBitBlt(Rop3BG=%02lx) FAILED", Rop3BG));
                }
            }

            if ((Ok) && (Rop3FG != 0xAA)) {

                if (!(Ok = DoRop3(pPDev,
                                  psoDst,
                                  psoSrc,
                                  CloneSO[CSI_PAT].pso,
                                  CloneSO[CSI_TMP].pso,
                                  pco,
                                  pxlo,
                                  prclDst,
                                  &rclSrc,
                                  &rclPat,
                                  pptlBrushOrg,
                                  pbo,
                                  Rop3FG))) {

                    PLOTERR(("DrvBitBlt(Rop3FG=%02lx) FAILED", Rop3FG));
                }
            }

            //
            // Release all cloned objects
            //

            for (i = 0; i < CSI_TOTAL; i++) {

                if (CloneSO[i].pso) {

                    PLOTDBG(DBG_CSI, ("DrvBitBlt: EngUnlockSuface(%hs)", pCSIName[i]));

                    EngUnlockSurface(CloneSO[i].pso);
                }

                if (CloneSO[i].hBmp) {

                    PLOTDBG(DBG_CSI, ("DrvBitBlt: EngDeleteSurface(%hs)", pCSIName[i]));

                    if (!EngDeleteSurface((HSURF)CloneSO[i].hBmp)) {

                        PLOTERR(("PLOTTER: DrvBitBlt, EngDeleteSurface(%ld:%p) FAILED",
                                            (DWORD)i, (DWORD_PTR)CloneSO[i].hBmp));
                    }
                }
            }
        }

        break;
    }

    return(Ok);
}



ULONG
DrvDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )

/*++

Routine Description:

    This is the hooked brush creation function, it asks CreateHalftoneBrush()
    to do the actual work (By returning DCR_HALFTONE).


Arguments:

    dhpdev      - DHPDEV passed, it is our pDEV

    iMode       - Not used

    rgbColor    - Solid rgb color to be used

    pulDither   - buffer to put the halftone brush.

Return Value:

    BOOLEAN

Author:

    02-May-1995 Tue 10:34:10 created  -by-  DC


Revision History:



--*/

{
    UNREFERENCED_PARAMETER(dhpdev);
    UNREFERENCED_PARAMETER(iMode);
    UNREFERENCED_PARAMETER(rgbColor);
    UNREFERENCED_PARAMETER(pulDither);

    return(DCR_HALFTONE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\brush.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    brush.h


Abstract:

    This module contains brush definitions and prototypes for module brush.c


Author:

    27-Jan-1994 Thu 21:05:01 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTBRUSH_
#define _PLOTBRUSH_


VOID
ResetDBCache(
    PPDEV   pPDev
    );


LONG
FindDBCache(
    PPDEV   pPDev,
    WORD    DBUniq
    );

BOOL
CopyUserPatBGR(
    PPDEV       pPDev,
    SURFOBJ     *psoPat,
    XLATEOBJ    *pxlo,
    LPBYTE      pBGRBmp
    );

VOID
GetMinHTSize(
    PPDEV   pPDev,
    SIZEL   *pszlPat
    );


#endif  // _PLOTBRUSH_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\bitblt.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    bitblt.h


Abstract:

    This module contains all #defines and protypes for the bitblt.c module.


Author:

    18-Nov-1993 Thu 05:24:42 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTBITBLT_
#define _PLOTBITBLT_


ROP4
MixToRop4(
   MIX  mix
   );


BOOL
BandingHTBlt(
    PPDEV           pPDev,
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    PRECTL          prclDst,
    PRECTL          prclSrc,
    PPOINTL         pptlMask,
    WORD            HTRop3,
    BOOL            InvertMask
    );

BOOL
DoFill(
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PPOINTL     pptlSrc,
    BRUSHOBJ    *pbo,
    PPOINTL     pptlBrush,
    ROP4        Rop4
    );


#endif  // _PLOTBITBLT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\brush.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    brush.c


Abstract:

    This module implements the code to realize brushes. BRUSHOBJS, are
    representations of logical objects. These objects are created in the
    win32 world and eventually need to be converted (or realized) to
    something that makes sense in the target device. This is done by realizing
    a brush. We look at the logical representation of the brush, then based
    on physical device characteristics, do the best job we can of simulating
    it on the target device. This conversion is done once, and the result
    is stored in the structure that represents the REALIZED brush. This
    is optimal since brushes tend to get re-used, and REALIZING them
    once, keeps us from having to execute the code every time a brush is used.


Author:

    19:15 on Mon 15 Apr 1991    -by-    SC
        Created it

    15-Nov-1993 Mon 19:29:07 updated  -by-  DC
        clean up / fixed

    27-Jan-1994 Thu 23:39:34 updated  -by-  DC
        Add fill type cache. which we do not have to send FT if same one
        already on the plotter


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgBrush

#define DBG_RBRUSH          0x00000001
#define DBG_HATCHTYPE       0x00000002
#define DBG_SHOWSTDPAT      0x00000004
#define DBG_COPYUSERPATBGR  0x00000008
#define DBG_MINHTSIZE       0x00000010
#define DBG_FINDDBCACHE     0x00000020


DEFINE_DBGVAR(0);

//
// The pHSFillType's #d is the line spacing param
//
// for hatch brushes, we want the lines to be .01" thick and .0666666666667"
// this is 15 LPI according to DC. That is, .254mm thick and 2.54mm apart.
// for now, assume the pen is the correct thickness (.3 is right) to figure
// out the separation, in device coordinates, we do 2.54 mm * (device units /
// mm), or  (254 * resolution / 100) where resolution is in device units /
// milimeter.
//

#define PATLINESPACE(pPDev) FXTODEVL(pPDev,LTOFX(pPDev->lCurResolution+7)/15)

static const BYTE   CellSizePrims[10][4] = {

                                { 2, 0, 0, 0 },     //  2x 2
                                { 2, 2, 0, 0 },     //  4x 4
                                { 2, 3, 0, 0 },     //  6x 6
                                { 2, 2, 2, 0 },     //  8x 8
                                { 2, 5, 0, 0 },     // 10x10
                                { 2, 2, 3, 0 },     // 12x12
                                { 2, 7, 0, 0 },     // 14x14
                                { 2, 2, 2, 2 },     // 16x16
                                { 91,0, 0, 0 },     // 91x91
                                { 91,0, 0, 0 }      // 91x91
                              };



VOID
ResetDBCache(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function clears the Device brush cach mechanism.


Arguments:

    pPDev   - Pointer to our PDEV


Return Value:

    VOID


Author:

    27-Jan-1994 Thu 20:30:35 created  -by-  DC


Revision History:


--*/

{
    PDBCACHE    pDBCache;
    UINT        i;


    pDBCache = (PDBCACHE)&pPDev->DBCache[0];


    for (i = RF_MAX_IDX; i; i--, pDBCache++) {

        pDBCache->RFIndex = (WORD)i;
        pDBCache->DBUniq  = 0;
    }
}




LONG
FindDBCache(
    PPDEV   pPDev,
    WORD    DBUniq
    )

/*++

Routine Description:

    This function finds the RF Index number, if not there then it will add it
    to the cache.


Arguments:

    pPDev   - Pointer to our PDEV

    DBUniq  - Uniq number to be search for


Return Value:

    LONG value >0 found and RetVal is the RFIndex
               <0 NOT Found and -RetVal is the new RFIndex


Author:

    27-Jan-1994 Thu 20:32:12 created  -by-  DC


Revision History:


--*/

{
    PDBCACHE    pDBCache;
    DBCACHE     DBCache;
    LONG        RetVal;
    UINT        i;


    PLOTASSERT(1, "FindDevBrushCache: DBUniq is 0", DBUniq, 0);

    pDBCache = (PDBCACHE)&pPDev->DBCache[0];

    for (i = 0; i < RF_MAX_IDX; i++, pDBCache++) {

        if (pDBCache->DBUniq == DBUniq) {

            break;
        }
    }

    if (i < RF_MAX_IDX) {

        DBCache = *pDBCache;
        RetVal  = (LONG)DBCache.RFIndex;

        PLOTDBG(DBG_FINDDBCACHE, ("FindDBCache: Found Uniq=%lu, RFIdx=%ld",
                                (DWORD)DBCache.DBUniq, (DWORD)DBCache.RFIndex));

    } else {

        //
        // Since we did not find the pattern in the cache, we will add it
        // to the beggining and move the rest of the entries down the list.
        // We need to remember the last one.
        //

        pDBCache       = (PDBCACHE)&pPDev->DBCache[i = (RF_MAX_IDX - 1)];
        DBCache        = *pDBCache;
        DBCache.DBUniq = DBUniq;
        RetVal         = -(LONG)DBCache.RFIndex;

        PLOTDBG(DBG_FINDDBCACHE, ("FindDBCache: NOT Found, NEW DBCache: Uniq=%lu, RFIdx=%ld",
                                (DWORD)DBCache.DBUniq, (DWORD)DBCache.RFIndex));
    }

    PLOTASSERT(1, "FindDBCache: Invalid RFIndex=%ld in the cache",
                (DBCache.RFIndex > 0) && (DBCache.RFIndex <= RF_MAX_IDX),
                (DWORD)DBCache.RFIndex);

    //
    // Move everything down by one slot, so the first one is the most
    // recently used.
    //

    while (i--) {

        *pDBCache = *(pDBCache - 1);
        --pDBCache;
    }

    //
    // Save the current cach back and return the RF index.
    //

    *pDBCache = DBCache;

    return(RetVal);
}





BOOL
CopyUserPatBGR(
    PPDEV       pPDev,
    SURFOBJ     *psoPat,
    XLATEOBJ    *pxlo,
    LPBYTE      pBGRBmp
    )

/*++

Routine Description:

    This function take a pattern surface and converts it to a form suitable,
    for downloading to the target device. The target device in this case,
    expects a pattern made up of different pens that define the color of each
    individual pixel. This conversion is done by first creating a
    BitmapSurface (24 bpp) of the passed in size, then EngBitBliting, the
    passed surface (that defines the pattern) into that 24 bpp surface, and
    finally copying the color data into the passed buffer.


Arguments:

    pPDev   - Pointer to our PDEV

    psoSrc  - source surface object

    pxlo    - translate object

    pBGRBmp - Pointer a 8x8 palette location for the bitmap


Return Value:

    TRUE if sucessful, FALSE if failed

Author:

    18-Jan-1994 Tue 03:20:10 created  -by-  DC


Revision History:


--*/

{
    SURFOBJ *pso24;
    HBITMAP hBmp24;


    if (pso24 = CreateBitmapSURFOBJ(pPDev,
                                    &hBmp24,
                                    psoPat->sizlBitmap.cx,
                                    psoPat->sizlBitmap.cy,
                                    BMF_24BPP,
                                    NULL)) {
        LPBYTE  pbSrc;
        RECTL   rclDst;
        DWORD   SizeBGRPerScan;
        BOOL    Ok;


        rclDst.left   =
        rclDst.top    = 0;
        rclDst.right  = pso24->sizlBitmap.cx;
        rclDst.bottom = pso24->sizlBitmap.cy;

        if (!(Ok = EngBitBlt(pso24,             // psoDst
                             psoPat,            // psoSrc
                             NULL,              // psoMask
                             NULL,              // pco
                             pxlo,              // pxlo
                             &rclDst,           // prclDst
                             (PPOINTL)&rclDst,  // pptlSrc
                             NULL,              // pptlMask
                             NULL,              // pbo
                             NULL,              // pptlBrushOrg
                             0xCCCC))) {

            PLOTERR(("CopyUserPatBGR: EngBitBlt() FALIED"));
            return(FALSE);
        }

        SizeBGRPerScan = (DWORD)(pso24->sizlBitmap.cx * 3);
        pbSrc          = (LPBYTE)pso24->pvScan0;

        PLOTDBG(DBG_COPYUSERPATBGR, ("CopyUserPatBGR: PerScan=%ld [%ld], cy=%ld",
                        SizeBGRPerScan, pso24->lDelta, rclDst.bottom));

        while (rclDst.bottom--) {

            CopyMemory(pBGRBmp, pbSrc, SizeBGRPerScan);

            pBGRBmp += SizeBGRPerScan;
            pbSrc   += pso24->lDelta;
        }

        if (pso24)  {

            EngUnlockSurface(pso24);
        }

        if (hBmp24) {

            EngDeleteSurface((HSURF)hBmp24);
        }

        return(Ok);

    } else {

        PLOTERR(("CopyUserPatBGR: CANNOT Create 24BPP for UserPat"));
        return(FALSE);
    }
}



VOID
GetMinHTSize(
    PPDEV   pPDev,
    SIZEL   *pszlPat
    )

/*++

Routine Description:

    This function computes and returns the minimum pattern size in pszlPat for
    a halftone tile-able pattern size. This is required in order to tile a
    repeating pattern correctly when filling an object. If the original
    brush wasn't useable, we create a composite of that original bitmap, by
    halftoning into a surface. In order for the result to be tile-able,
    we must take into account the different Cell/Patter sizes for our
    halftone data.

Arguments:

    pPDev   - Point to our PDEV

    pszlPat - Points to a SIZEL structure for the original pattern size


Return Value:

    VOID


Author:

    26-Jan-1994 Wed 10:10:15 created  -by-  DC


Revision History:


--*/

{
    LPBYTE  pCellPrims;
    LPBYTE  pPrims;
    LONG    Prim;
    SIZEL   szlPat;
    LONG    CellSize;
    UINT    i;


    szlPat     = *pszlPat;
    CellSize   = (LONG)HTPATSIZE(pPDev);
    pCellPrims = (LPBYTE)&CellSizePrims[(CellSize >> 1) - 1][0];

    if (!(CellSize % szlPat.cx)) {

        szlPat.cx = CellSize;

    } else if (szlPat.cx % CellSize) {

        //
        // Since it's not an exact fit, calculate the correct number now.
        //

        i      = 4;
        pPrims = pCellPrims;

        while ((i--) && (Prim = (LONG)*pPrims++)) {

            if (!(szlPat.cx % Prim)) {

                szlPat.cx /= Prim;
            }
        }

        szlPat.cx *= CellSize;
    }

    if (!(CellSize % szlPat.cy)) {

        szlPat.cy = CellSize;

    } else if (szlPat.cy % CellSize) {

        //
        // Since it's not an exact fit, calculate the correct number now.
        //

        i      = 4;
        pPrims = pCellPrims;

        while ((i--) && (Prim = (LONG)*pPrims++)) {

            if (!(szlPat.cy % Prim)) {

                szlPat.cy /= Prim;
            }
        }

        szlPat.cy *= CellSize;
    }

    PLOTDBG(DBG_MINHTSIZE, ("GetMinHTSize: PatSize=%ld x %ld, HTSize=%ld x %ld, MinSize=%ld x %ld",
                        pszlPat->cx, pszlPat->cy, CellSize, CellSize,
                        szlPat.cx, szlPat.cy));

    *pszlPat = szlPat;
}




BOOL
DrvRealizeBrush(
    BRUSHOBJ    *pbo,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoPattern,
    SURFOBJ     *psoMask,
    XLATEOBJ    *pxlo,
    ULONG       iHatch
    )

/*++

Routine Description:

    DrvRealizeBrush requests the driver to realize a specified brush for a
    specified surface. NT's GDI will usually realize a brush before using it.
    Realing a brush allows our driver to take a logical representation of
    a brush, and convert it to something that makes sense in the target device.
    By having the NT GDI realize the brush, in essence allows us to cache the
    physical representation of the brush, for future use.

Arguments:

    pbo         - Points to the BRUSHOBJ which is to be realized. All the other
                  parameters, except for psoDst, can be queried from this
                  object. Parameter specifications are provided as an
                  optimization. This parameter is best used only as a parameter
                  for BRUSHOBJ_pvAllocRBrush, which allocates the memory for
                  the realized brush.

    psoDst      - Points to the surface for which the brush is to be realized.
                  This surface could be the physical surface for the device,
                  a device format bitmap, or a standard format bitmap.

    psoPattern  - Points to the surface that describes the pattern for the
                  brush. For a raster device, this always represents a bitmap.
                  For a vector device, this is always one of the pattern
                  surfaces returned by DrvEnablePDEV.

    psoMask     - Points to a transparency mask for the brush. This is a one
                  bit per pixel bitmap that has the same extent as the pattern.
                  A mask of zero means the pixel is considered a background
                  pixel for the brush. (In transparent background mode, the
                  background pixels are unaffected in a fill.) Pen Plotters can
                  ignore this parameter because they never draw background
                  information.

    pxlo        - Points to an XLATEOBJ that tells how to interpret the colors
                  in the pattern. An XLATEOBJXxx service routine can be called
                  to translate the colors to device color indexes. Vector
                  devices should translate color zero through the XLATEOBJ to
                  get the foreground color for the brush.

    iHatch      - If this is less than HS_API_MAX, then it indicates that
                  psoPattern is one of the hatch brushes returned by
                  DrvEnablePDEV, such as HS_HORIZONTAL.

Return Value:

    DrvRealizeBrush returns TRUE if the brush was successfully realized.
    Otherwise, FALSE is returned and an error code is logged.


Author:

    09-Feb-1994 Wed 10:04:17 updated  -by-  DC
        Put the CloneSURFOBJToHT() back for all psoPatterns, (this was to
        prevent GDI go into GP), now we will raised a bug against it.

    13-Jan-1994 Thu 23:12:40 updated  -by-  DC
        Totally re-write so that we will cached the psoPattern always

    01-Dec-1993 Wed 17:27:19 updated  -by-  DC
        clean up, and re-write to generate the standard brush string.

Revision History:


--*/

{
    PPDEV   pPDev;


    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DrvRealizeBrush has invalid pPDev"));
        return(FALSE);
    }

    //
    // We don't check if iHatch is valid or not at this poin.
    // We should always get a psoPattern that either points to the user
    // defined pattern or to the standard monochrome pattern.
    //

    if ((psoPattern) &&
        (psoPattern->iType == STYPE_BITMAP)) {

        PDEVBRUSH   pBrush;
        SURFOBJ     *psoHT;
        HBITMAP     hBmp;
        SIZEL       szlPat;
        SIZEL       szlHT;
        RECTL       rclHT;
        LONG        Size;
        DWORD       OffBGR;
        BOOL        RetOk;

        //
        // leave room for the color table. then allocate the new device brush
        //

        PLOTDBG(DBG_RBRUSH, ("DrvRealizeBrush: psoPat=%08lx [%ld], psoMask=%08lx, iHatch=%ld",
                    psoPattern, psoPattern->iBitmapFormat, psoMask, iHatch));

        PLOTDBG(DBG_RBRUSH, ("psoPattern size = %ld x %ld",
                                    (LONG)psoPattern->sizlBitmap.cx,
                                    (LONG)psoPattern->sizlBitmap.cy));

#if DBG
        if ((DBG_PLOTFILENAME & DBG_SHOWSTDPAT) &&
            ((psoPattern->iBitmapFormat == BMF_1BPP) ||
             (iHatch < HS_DDI_MAX))) {

            LPBYTE  pbSrc;
            LPBYTE  pbCur;
            LONG    x;
            LONG    y;
            BYTE    bData;
            BYTE    Mask;
            BYTE    Buf[128];


            //
            // Debug code that allows the pattern to be displayed with
            // ASCII codes on the debug terminal. This was very helpful
            // during development.
            //

            pbSrc = psoPattern->pvScan0;

            for (y = 0; y < psoPattern->sizlBitmap.cy; y++) {

                pbCur  = pbSrc;
                pbSrc += psoPattern->lDelta;
                Mask   = 0x0;
                Size   = 0;

                for (x = 0; x < psoPattern->sizlBitmap.cx; x++) {

                    if (!(Mask >>= 1)) {

                        Mask  = 0x80;
                        bData = *pbCur++;
                    }

                    Buf[Size++] = (BYTE)((bData & Mask) ? 0xdb : 0xb0);
                }

                Buf[Size] = '\0';

                DBGP((Buf));
            }
        }
#endif

        //
        // For pen plotter, we need to remember this one as well.
        //

        szlHT  =
        szlPat = psoPattern->sizlBitmap;

        PLOTDBG(DBG_RBRUSH,
                ("DrvRealizeBrush: BG=%08lx, FG=%08lx",
                    (DWORD)XLATEOBJ_iXlate(pxlo, 1),
                    (DWORD)XLATEOBJ_iXlate(pxlo, 0)));

        if (IS_RASTER(pPDev)) {

            //
            // For raster plotters, we will clone the surface and halftone
            // the orignal pattern into a halftone bitmap which itself is
            // tile-able. This allows us to use our color reduction code,
            // to make the pattern look good.
            //

            if ((iHatch >= HS_DDI_MAX) &&
                (!IsHTCompatibleSurfObj(pPDev,
                                        psoPattern,
                                        pxlo,
                                        ISHTF_ALTFMT | ISHTF_DSTPRIM_OK))) {

                GetMinHTSize(pPDev, &szlHT);
            }

            rclHT.left   =
            rclHT.top    = 0;
            rclHT.right  = szlHT.cx;
            rclHT.bottom = szlHT.cy;

            PLOTDBG(DBG_RBRUSH,
                    ("DrvRealizeBrush: PatSize=%ld x %ld, HT=%ld x %ld",
                        szlPat.cx, szlPat.cy, szlHT.cx, szlHT.cy));

            //
            // Go generate the bits for the pattern.
            //

            if (psoHT = CloneSURFOBJToHT(pPDev,         // pPDev,
                                         psoDst,        // psoDst,
                                         psoPattern,    // psoSrc,
                                         pxlo,          // pxlo,
                                         &hBmp,         // hBmp,
                                         &rclHT,        // prclDst,
                                         NULL)) {       // prclSrc,

                RetOk = TRUE;

            } else {

                PLOTDBG(DBG_RBRUSH, ("DrvRealizeBrush: Clone PATTERN FAILED"));
                return(FALSE);
            }

        } else {

            //
            // For Pen type plotter we will never do a standard pattern in the
            // memory (compatible DC). For user defined patterns we will
            // only hatch '\' with background color and a '/' with foreground
            // color with double standard line spacing. This is the best we
            // can hope for on a pen plotter.
            //

            RetOk = TRUE;
            psoHT = psoPattern;
            hBmp  = NULL;
        }

        if (RetOk) {

            //
            // Now Allocate device brush, remember we will only allocate the
            // minimum size.
            //

            Size = (LONG)psoHT->cjBits - (LONG)sizeof(pBrush->BmpBits);

            if (Size < 0) {

                Size = sizeof(DEVBRUSH);

            } else {

                Size += sizeof(DEVBRUSH);
            }

            //
            // Following are the user defined pattern sizes which can be handled
            // internally by HPGL2. This is only for raster plotters. Pen
            // plotters will have a cross hatch to show an emulation of the
            // pattern.
            //

            if ((iHatch >= HS_DDI_MAX)  &&
                (IS_RASTER(pPDev))      &&
                ((szlPat.cx == 8)   ||
                 (szlPat.cx == 16)  ||
                 (szlPat.cx == 32)  ||
                 (szlPat.cx == 64))     &&
                ((szlPat.cy == 8)   ||
                 (szlPat.cy == 16)  ||
                 (szlPat.cy == 32)  ||
                 (szlPat.cy == 64))) {

                //
                // Adding the size which stored the BGR format of the pattern
                //

                OffBGR  = Size;
                Size   += (psoPattern->sizlBitmap.cx * 3) *
                          psoPattern->sizlBitmap.cy;

            } else {

                OffBGR = 0;
            }

            PLOTDBG(DBG_RBRUSH, ("DrvRealizeBrush: AllocDEVBRUSH(Bmp=%ld,BGR=%ld), TOT=%ld",
                                psoHT->cjBits, Size - OffBGR, Size));

            //
            // Now ask the NT graphics engine to allocate the device
            // brush memory for us. This is done, so NT knows how to discard
            // the memory when it is no longer needed (The brush getting
            // destroyed).
            //

            if (pBrush = (PDEVBRUSH)BRUSHOBJ_pvAllocRbrush(pbo, Size)) {

                //
                // Set up either standard pattern or user defined pattern
                // HPGL/2 FT command string pointer and parameters.
                //

                pBrush->psoMask       = psoMask;
                pBrush->PatIndex      = (WORD)iHatch;
                pBrush->Uniq          = (WORD)(pPDev->DevBrushUniq += 1);
                pBrush->LineSpacing   = (LONG)PATLINESPACE(pPDev);
                pBrush->ColorFG       = (DWORD)XLATEOBJ_iXlate(pxlo, 1);
                pBrush->ColorBG       = (DWORD)XLATEOBJ_iXlate(pxlo, 0);
                pBrush->sizlBitmap    = psoHT->sizlBitmap;
                pBrush->ScanLineDelta = psoHT->lDelta;
                pBrush->BmpFormat     = (WORD)psoHT->iBitmapFormat;
                pBrush->BmpFlags      = (WORD)psoHT->fjBitmap;
                pBrush->pbgr24        = NULL;
                pBrush->cxbgr24       =
                pBrush->cybgr24       = 0;

                PLOTDBG(DBG_RBRUSH, ("DrvRealizeBrush: DevBrush's Uniq = %ld",
                                            pBrush->Uniq));

                //
                // Check to see if the cache is wrapping and handle it.
                //

                if (pBrush->Uniq == 0) {

                    ResetDBCache(pPDev);

                    pBrush->Uniq        =
                    pPDev->DevBrushUniq = 1;

                    PLOTDBG(DBG_RBRUSH, ("DrvRealizeBrush: Reset DB Cache, (Uniq WRAP)"));
                }

                //
                // Is it a user defined pattern.
                //

                if (iHatch >= HS_DDI_MAX) {

                    //
                    // Check to see if the brush could be downloaded to the
                    // target device as an HPGL2 brush. If this is the case
                    // save that information.
                    //

                    if (OffBGR) {

                        pBrush->pbgr24  = (LPBYTE)pBrush + OffBGR;
                        pBrush->cxbgr24 = (WORD)psoPattern->sizlBitmap.cx;
                        pBrush->cybgr24 = (WORD)psoPattern->sizlBitmap.cy;

                        ZeroMemory(pBrush->pbgr24, Size - OffBGR);

                        CopyUserPatBGR(pPDev, psoPattern, pxlo, pBrush->pbgr24);

                    } else if (!IS_RASTER(pPDev)) {

                        //
                        // If we are not talking to a RASTER plotter, not much
                        // we can do here. Trigger the simulation.
                        //

                        pBrush->pbgr24 = (LPBYTE)-1;
                    }
                }

                //
                // Copy down the halftoned bits if any.
                //

                if (psoHT->cjBits) {

                    CopyMemory((LPBYTE)pBrush->BmpBits,
                               (LPBYTE)psoHT->pvBits,
                               psoHT->cjBits);
                }

                //
                // Now record the realized brush pointer in the BRUSHOBJ.
                //

                pbo->pvRbrush = (LPVOID)pBrush;

            } else {

                PLOTERR(("DrvRealizeBrush: brush allocation failed"));

                RetOk = FALSE;
            }

        } else {

            PLOTERR(("DrvRealizeBrush: Cloning the psoPattern failed!"));
            RetOk = FALSE;
        }

        if (psoHT != psoPattern) {

            EngUnlockSurface(psoHT);
        }

        if (hBmp) {

            EngDeleteSurface((HSURF)hBmp);
        }

        return(RetOk);

    } else {

        PLOTASSERT(0, "The psoPattern is not a bitmap (psoPattern= %08lx)",
                (psoPattern) &&
                (psoPattern->iType == STYPE_BITMAP), psoPattern);

        return(FALSE);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\compress.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    compress.c


Abstract:

    This module contains all data compression functions which analyze source
    scan line data and determines which compressin method (if any) is best to
    send the RTL data to the target device with a minimum number of bytes.

Author:

    18-Feb-1994 Fri 09:50:08 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgCompress

#define DBG_TIFF            0x00000001
#define DBG_DELTA           0x00000002
#define DBG_COMPRESS        0x00000004
#define DBG_OUTRTLSCAN      0x00000008
#define DBG_FLUSHADAPTBUF   0x00000010
#define DBG_ENTERRTLSCANS   0x00000020
#define DBG_DELTA_OFFSET0   0x00000040
#define DBG_NO_DELTA        0x40000000
#define DBG_NO_TIFF         0x80000000

DEFINE_DBGVAR(0);


#define TIFF_MIN_REPEATS            3
#define TIFF_MAX_REPEATS            128
#define TIFF_MAX_LITERAL            128
#define DELTA_MAX_ONE_REPLACE       8
#define DELTA_MAX_1ST_OFFSET        31
#define MIN_BLOCK_MODE_SIZE         8

//
// The MAX_ADAPT_SIZE is used to leave room for SET_ADAPT_CONTROL
//

#if (OUTPUT_BUFFER_SIZE >= (1024 * 32))
    #define MAX_ADAPT_SIZE              ((1024 * 32) - 16)
#else
    #define MAX_ADAPT_SIZE              (OUTPUT_BUFFER_SIZE - 16)
#endif


#define ADAPT_METHOD_ZERO           4
#define ADAPT_METHOD_DUP            5

#define SIZE_ADAPT_CONTROL          3

#define SET_ADAPT_CONTROL(pPDev, m, c)                                      \
{                                                                           \
    BYTE    bAdaptCtrl[4];                                                  \
                                                                            \
    bAdaptCtrl[0] = (BYTE)(m);                                              \
    bAdaptCtrl[1] = (BYTE)(((c) >> 8) & 0xFF);                              \
    bAdaptCtrl[2] = (BYTE)(((c)     ) & 0xFF);                              \
    OutputBytes(pPDev, bAdaptCtrl, 3);                                      \
}



BOOL
FlushAdaptBuf(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans,
    BOOL        FlushEmptyDup
    )

/*++

Routine Description:

    This function flushes the adaptive encoding buffer mode.

Arguments:

    pPDev           - Pointer to our PDEV

    pRTLScans       - Pointer to the RTLSCANS data structure

    FlushEmptyDup   - TRUE if cEmptyDup need to be flush out also


Return Value:

    TRUE if OK,

Author:

    09-Mar-1994 Wed 20:32:31 created  -by-  DC


Revision History:


--*/

{
    DWORD   Count;
    WORD    cEmptyDup;
    BOOL    Ok = TRUE;


    Count = pPDev->cbBufferBytes;

    if (cEmptyDup = (FlushEmptyDup) ? pRTLScans->cEmptyDup : 0) {

        Count += SIZE_ADAPT_CONTROL;
    }

    if (Count) {

        DWORD   cbBufferBytes;
        BYTE    TmpBuf[32];


        PLOTDBG(DBG_FLUSHADAPTBUF, ("FlushAdaptBuf: Flush total %ld byte block",
                                Count));

        //
        // SAVE the OutputBuffer for this temporary header
        //

        CopyMemory(TmpBuf, pPDev->pOutBuffer, sizeof(TmpBuf));

        cbBufferBytes        = pPDev->cbBufferBytes;
        pPDev->cbBufferBytes = 0;

        //
        // Now output the header
        //

        OutputBytes(pPDev, "\033*b", 3);

        if (!pRTLScans->cAdaptBlk) {

            pRTLScans->cAdaptBlk++;
            OutputBytes(pPDev, "5m", 2);
        }

        OutputFormatStr(pPDev, "#dW", Count);

        //
        // FLUSH OUTPUT BUFFER AND RESTORE BACK the OutputBuffer for this
        // temporary header
        //

        PLOTDBG(DBG_FLUSHADAPTBUF, ("FlushAdaptBuf: Flush TmpBuf[%ld] bytes of HEADER",
                                pPDev->cbBufferBytes));

        FlushOutBuffer(pPDev);

        CopyMemory(pPDev->pOutBuffer, TmpBuf, sizeof(TmpBuf));
        pPDev->cbBufferBytes = cbBufferBytes;

        if (cEmptyDup) {

            PLOTDBG(DBG_FLUSHADAPTBUF, ("FlushAdaptBuf: Add %ld EmptyDup [%ld]",
                            (DWORD)cEmptyDup, (DWORD)pRTLScans->AdaptMethod));

            SET_ADAPT_CONTROL(pPDev, pRTLScans->AdaptMethod, cEmptyDup);

            pRTLScans->cEmptyDup = 0;
        }

        Ok = FlushOutBuffer(pPDev);

        //
        // After the block been sent the seed row is back to zero
        //

        ZeroMemory(pRTLScans->pbSeedRows[0],
                   (DWORD)pRTLScans->cxBytes * (DWORD)pRTLScans->Planes);
    }

    return(Ok);
}




VOID
ExitRTLScans(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans
    )
/*++

Routine Description:

    This function completes processing of the SCANS data.

Arguments:

    pPDev       - Pointer to our PDEV

    pRTLScans   - Pointer to the RTLSCANS data structure to be initialized

Return Value:

    TRUE if sucessful, FALSE if failed

Author:

    22-Feb-1994 Tue 12:14:17 created  -by-  DC


Revision History:


--*/

{
    if (pRTLScans->CompressMode == COMPRESS_MODE_ADAPT) {

        FlushAdaptBuf(pPDev, pRTLScans, TRUE);
    }

    if (pRTLScans->pbCompress) {

        LocalFree(pRTLScans->pbCompress);
    }

    ZeroMemory(pRTLScans, sizeof(RTLSCANS));
}



VOID
EnterRTLScans(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans,
    DWORD       cx,
    DWORD       cy,
    BOOL        MonoBmp
    )

/*++

Routine Description:


    This function initializes the RTLSCANS structure and determines which
    compression of the available compressions is best.

Arguments:

    pPDev       - Pointer to our PDEV

    pRTLScans   - Pointer to the RTLSCANS data structure to be initialized

    cx          - Width of pixel per scans

    cy          - Height of pixel data

    MonoBmp     - True if a monochrome bitmap.

Return Value:

    TRUE if sucessful, FALSE if failed

Author:

    22-Feb-1994 Tue 12:14:17 created  -by-  DC

    11-Mar-1994 Fri 19:23:34 updated  -by-  DC
        Only flush the output buffer if we are really in ADAPTIVE mode


Revision History:


--*/

{
    RTLSCANS    RTLScans;
    DWORD       AllocSize;
    DWORD       MinBlkSize;


    RTLScans.Flags           = (RTLScans.cScans = cy) ? RTLSF_MORE_SCAN : 0;
    RTLScans.pbCompress      =
    RTLScans.pbSeedRows[0]   =
    RTLScans.pbSeedRows[1]   =
    RTLScans.pbSeedRows[2]   = NULL;
    RTLScans.cEmptyDup       = 0;
    RTLScans.AdaptMethod     = 0xFF;
    RTLScans.cAdaptBlk       = 0;
    RTLScans.cxBytes         = (DWORD)((cx + 7) >> 3);
    RTLScans.CompressMode    = COMPRESS_MODE_ROW;
    RTLScans.MaxAdaptBufSize = MAX_ADAPT_SIZE;

    if (!(RTLScans.Mask = (BYTE)(~(0xFF >> (cx & 0x07))))) {

        //
        // Exact at byte boundary
        //

        RTLScans.Mask = 0xFF;
    }

    MinBlkSize = 8;

    if (MonoBmp) {

        RTLScans.Planes = 1;
        AllocSize       = (DWORD)(RTLScans.cxBytes << 1);

        if (RTLMONOENCODE_5(pPDev)) {

            PLOTDBG(DBG_ENTERRTLSCANS, ("EnterRTLScans: Using Adaptive Mode Compression"));

            RTLScans.CompressMode = COMPRESS_MODE_ADAPT;
            MinBlkSize            = 4;
        }

    } else {

        RTLScans.Planes = 3;
        AllocSize       = (DWORD)(RTLScans.cxBytes << 2);
    }

    if ((RTLScans.cxBytes <= MinBlkSize)   ||
        (!(RTLScans.pbCompress = (LPBYTE)LocalAlloc(LPTR, AllocSize)))) {

        BYTE    Buf[4];

        RTLScans.CompressMode = COMPRESS_MODE_BLOCK;

        OutputFormatStr(pPDev,
                        "\033*b4m#dW",
                        4 + (RTLScans.cxBytes * RTLScans.Planes * cy));

        Buf[0] = (BYTE)((cx >> 24) & 0xFF);
        Buf[1] = (BYTE)((cx >> 16) & 0xFF);
        Buf[2] = (BYTE)((cx >>  8) & 0xFF);
        Buf[3] = (BYTE)((cx      ) & 0xFF);

        OutputBytes(pPDev, Buf, 4);

    } else if (RTLScans.CompressMode == COMPRESS_MODE_ADAPT) {

        //
        // We first need to flush the current output buffer in order to make
        // room for the Adaptive method
        //

        FlushOutBuffer(pPDev);
    }

    if (RTLScans.pbCompress) {

        RTLScans.pbSeedRows[0] = RTLScans.pbCompress + RTLScans.cxBytes;

        if (!MonoBmp) {

            RTLScans.pbSeedRows[1] = RTLScans.pbSeedRows[0] + RTLScans.cxBytes;
            RTLScans.pbSeedRows[2] = RTLScans.pbSeedRows[1] + RTLScans.cxBytes;
        }
    }

    *pRTLScans = RTLScans;
}



LONG
CompressToDelta(
    LPBYTE  pbSrc,
    LPBYTE  pbSeedRow,
    LPBYTE  pbDst,
    LONG    Size
    )

/*++

Routine Description:

    This function compresses the input scan data with delta encoding, by
    determining the differences from the current seed row.

Arguments:

    pbSrc       - Pointer to the source to be compressed

    pbSeedRow   - Pointer to the previous seed row

    pbDst       - Pointer to the compress buffer

    Size        - Size of the pointers


Return Value:

    LONG    - the compress buffer size

    >0      - Size of the buffer
    =0      - The data is same as previouse line
    <0      - Size is larger than the Size passed

Author:

    22-Feb-1994 Tue 14:41:18 created  -by-  DC


Revision History:


--*/

{
    LPBYTE  pbDstBeg;
    LPBYTE  pbDstEnd;
    LPBYTE  pbTmp;
    LONG    cSrcBytes;
    LONG    Offset;
    UINT    cReplace;
    BOOL    DoReplace;


#if DBG
    if (DBG_PLOTFILENAME & DBG_NO_DELTA) {

        return(-Size);
    }
#endif

    cSrcBytes = Size;
    pbDstBeg  = pbDst;
    pbDstEnd  = pbDst + Size;
    cReplace  = 0;
    pbTmp     = pbSrc;


    while (cSrcBytes--) {

        //
        // We need to do byte replacement now
        //

        if (*pbSrc != *pbSeedRow) {

            if (++cReplace == 1) {

                //
                // The pbTmp is the next byte to the last replacement byte.
                // After we find the first difference, between the seed row
                // and the current row pbTmp becomes the first byte of the
                // source data that is different than the seed.
                //

                Offset = (LONG)(pbSrc - pbTmp);
                pbTmp  = pbSrc;
            }

            DoReplace = (BOOL)((cReplace >= DELTA_MAX_ONE_REPLACE) ||
                               (!cSrcBytes));

        } else {

            DoReplace = (BOOL)cReplace;
        }

        if (DoReplace) {

            //
            // At the very least we need one command byte and a replace count
            // byte.
            //


            if ((LONG)(pbDstEnd - pbDst) <= (LONG)cReplace) {

                PLOTDBG(DBG_DELTA, ("CompressToDelta: 1ST_OFF: Dest Size is larger, give up"));

                return(-Size);
            }

            PLOTDBG(DBG_DELTA, ("CompressToDelta: Replace=%ld, Offset=%ld",
                        (DWORD)cReplace, (DWORD)Offset));


            //
            // Set commmand byte to replacement count
            //

            *pbDst = (BYTE)((cReplace - 1) << 5);

            //
            // Add in the offset to the same destination byte
            //

            if (Offset < DELTA_MAX_1ST_OFFSET) {

                *pbDst++ |= (BYTE)Offset;

            } else {

                //
                // We need to send more than one offset, NOTE: We must
                // send an extra 0 if the offset is equal to 31 or 255
                //

                *pbDst++ |= (BYTE)DELTA_MAX_1ST_OFFSET;
                Offset   -= DELTA_MAX_1ST_OFFSET;

                do {

                    if (!Offset) {

                        PLOTDBG(DBG_DELTA_OFFSET0,
                                ("CompressToDelta: Extra 0 offset SENT"));
                    }

                    if (pbDst >= pbDstEnd) {

                        PLOTDBG(DBG_DELTA, ("CompressToDelta: Dest Size is larger, give up"));

                        return(-Size);
                    }

                    *pbDst++ = (BYTE)((Offset >= 255) ? 255 : Offset);

                } while ((Offset -= 255) >= 0);
            }

            //
            // Now copy down the replacement bytes, if we mess up then this
            // pb1stDiff will be NULL
            //

            CopyMemory(pbDst, pbTmp, cReplace);

            pbDst    += cReplace;
            pbTmp    += cReplace;
            cReplace  = 0;
        }

        //
        // Advanced source/seed row pointers
        //

        ++pbSrc;
        ++pbSeedRow;
    }

    PLOTDBG(DBG_DELTA, ("CompressToDelta: Compress from %ld to %ld, save=%ld",
                        Size, (DWORD)(pbDst - pbDstBeg),
                        Size - (DWORD)(pbDst - pbDstBeg)));


    return((LONG)(pbDst - pbDstBeg));
}





LONG
CompressToTIFF(
    LPBYTE  pbSrc,
    LPBYTE  pbDst,
    LONG    Size
    )

/*++

Routine Description:


    This function takes the source data and compresses it into the TIFF
    packbits format into the destination buffer pbDst.

    The TIFF packbits compression format consists of a CONTROL byte followed
    by the BYTE data. The CONTROL byte has the following range.

    -1 to -127  = The data byte followed by the control byte is repeated
                  ( -(Control Byte) + 1 ) times.

    0 to 127    = There are 1 to 128 literal bytes following the CONTROL byte.
                  The count is = (Control Byte + 1)

    -128        = NOP

Arguments:

    pbSrc   - The source data to be compressed

    pbDst   - The compressed TIFF packbits format data

    Size    - Count of the data in the source and destination

Return Value:

    >0  - Compress sucessful and return value is the total bytes in pbDst
    =0  - All bytes are zero nothing to be compressed.
    <0  - Compress data is larger than the source, compression failed and
          pbDst has no valid data.

Author:

    18-Feb-1994 Fri 09:54:47 created  -by-  DC

    24-Feb-1994 Thu 10:43:01 updated  -by-  DC
        Changed the logic so when multiple MAX repeats count is sent and last
        repeat chunck is less than TIFF_MIN_REPEATS then we will treat that as
        literal to save more space


Revision History:


--*/

{
    LPBYTE  pbSrcBeg;
    LPBYTE  pbSrcEnd;
    LPBYTE  pbDstBeg;
    LPBYTE  pbDstEnd;
    LPBYTE  pbLastRepeat;
    LPBYTE  pbTmp;
    LONG    RepeatCount;
    LONG    LiteralCount;
    LONG    CurSize;
    BYTE    LastSrc;

#if DBG
    if (DBG_PLOTFILENAME & DBG_NO_TIFF) {

        return(-Size);
    }
#endif


    pbSrcBeg     = pbSrc;
    pbSrcEnd     = pbSrc + Size;
    pbDstBeg     = pbDst;
    pbDstEnd     = pbDst + Size;
    pbLastRepeat = pbSrc;

    while (pbSrcBeg < pbSrcEnd) {

        pbTmp   = pbSrcBeg;
        LastSrc = *pbTmp++;

        while ((pbTmp < pbSrcEnd) &&
               (*pbTmp == LastSrc)) {

            ++pbTmp;
        }

        if (((RepeatCount = (LONG)(pbTmp - pbSrcBeg)) >= TIFF_MIN_REPEATS) ||
            (pbTmp >= pbSrcEnd)) {

            //
            // Check to see if we are repeating ZERO's to the end of the
            // scan line, if such is the case. Simply mark the line as
            // autofill ZERO to the end, and exit.
            //

            LiteralCount = (LONG)(pbSrcBeg - pbLastRepeat);

            if ((pbTmp >= pbSrcEnd) &&
                (RepeatCount)       &&
                (LastSrc == 0)) {

                if (RepeatCount == Size) {

                    PLOTDBG(DBG_TIFF,
                            ("CompressToTIFF: All data = 0, size=%ld", Size));

                    return(0);
                }

                PLOTDBG(DBG_TIFF,
                        ("CompressToTIFF: Last Chunck of Repeats (%ld) is Zeros, Skip it",
                        RepeatCount));

                RepeatCount = 0;

            } else if (RepeatCount < TIFF_MIN_REPEATS) {

                //
                // If we have repeating data, but not enough to make it
                // worthwhile to encode, then treat the data as literal and
                // don't compress.

                LiteralCount += RepeatCount;
                RepeatCount   = 0;
            }

            PLOTDBG(DBG_TIFF, ("CompressToTIFF: Literal=%ld, Repeats=%ld",
                                                    LiteralCount, RepeatCount));

            //
            // Setting literal count
            //

            while (LiteralCount) {

                if ((CurSize = LiteralCount) > TIFF_MAX_LITERAL) {

                    CurSize = TIFF_MAX_LITERAL;
                }

                if ((pbDstEnd - pbDst) <= CurSize) {

                    PLOTDBG(DBG_TIFF,
                            ("CompressToTIFF: [LITERAL] Dest Size is larger, give up"));
                    return(-Size);
                }

                //
                // Set literal control bytes from 0-127
                //

                *pbDst++ = (BYTE)(CurSize - 1);

                CopyMemory(pbDst, pbLastRepeat, CurSize);

                pbDst        += CurSize;
                pbLastRepeat += CurSize;
                LiteralCount -= CurSize;
            }

            //
            // Setting repeat count if any
            //

            while (RepeatCount) {

                if ((CurSize = RepeatCount) > TIFF_MAX_REPEATS) {

                    CurSize = TIFF_MAX_REPEATS;
                }

                if ((pbDstEnd - pbDst) < 2) {

                    PLOTDBG(DBG_TIFF,
                            ("CompressToTIFF: [REPEATS] Dest Size is larger, give up"));
                    return(-Size);
                }

                //
                // Set Repeat Control bytes from -1 to -127
                //

                *pbDst++ = (BYTE)(1 - CurSize);
                *pbDst++ = (BYTE)LastSrc;

                //
                // If we have more than TIFF_MAX_REPEATS then we want to make
                // sure we used the most efficient method to send.  If we have
                // remaining repeated bytes less than TIFF_MIN_REPEATS then
                // we want to skip those bytes and use literal for the next run
                // since that is more efficient.
                //

                if ((RepeatCount -= CurSize) < TIFF_MIN_REPEATS) {

                    PLOTDBG(DBG_TIFF,
                            ("CompressToTIFF: Replaced Last REPEATS (%ld) for LITERAL",
                                                RepeatCount));

                    pbTmp       -= RepeatCount;
                    RepeatCount  = 0;
                }
            }

            pbLastRepeat = pbTmp;
        }

        pbSrcBeg = pbTmp;
    }

    PLOTDBG(DBG_TIFF, ("CompressToTIFF: Compress from %ld to %ld, save=%ld",
                        Size, (DWORD)(pbDst - pbDstBeg),
                        Size - (DWORD)(pbDst - pbDstBeg)));

    return((LONG)(pbDst - pbDstBeg));
}




LONG
RTLCompression(
    LPBYTE  pbSrc,
    LPBYTE  pbSeedRow,
    LPBYTE  pbDst,
    LONG    Size,
    LPBYTE  pCompressMode
    )

/*++

Routine Description:

    This function determines which RTL compression method results in the
    least number of bytes to send to the target device and uses that method.

Arguments:

    pbSrc           - pointer to the source scan

    pbSeedRow       - Pointer to the seed row for the current source scan

    pbDst           - Pointer to the compressed result will be stored

    Size            - size in bytes for pbSrc/pbSeedRow/pbDst

    pCompressMode   - Pointer to current compression mode, it will ALWAYS be
                      updated to a new compression mode upon return


Return Value:

    >0  - Use *pCompressMode returned and output that many bytes
    =0  - Use *pCompressMode returned and output ZERO byte
    <0  - Use *pCompressMode returned and output original source and size

Author:

    25-Feb-1994 Fri 12:49:29 created  -by-  DC


Revision History:


--*/

{
    LONG    cDelta;
    LONG    cTiff;
    LONG    RetSize;
    BYTE    CompressMode;


    if ((cDelta = CompressToDelta(pbSrc, pbSeedRow, pbDst, Size)) == 0) {

        //
        // Exact duplicate of the previous row, and seed row remained the same
        //

        PLOTDBG(DBG_COMPRESS, ("RTLCompression: Duplicate the ROW"));

        *pCompressMode = (BYTE)COMPRESS_MODE_DELTA;
        return(0);
    }

    if ((cTiff = CompressToTIFF(pbSrc, pbDst, Size)) == 0) {

        //
        // Since a '*0W' for the delta means repeat last row so we must change
        // to other mode, but we just want reset seed rows to all zeros
        //

        PLOTDBG(DBG_COMPRESS, ("RTLCompression: Row is all ZEROs"));

        if (*pCompressMode == (BYTE)COMPRESS_MODE_DELTA) {

            *pCompressMode = (BYTE)COMPRESS_MODE_ROW;
        }

        ZeroMemory(pbSeedRow, Size);
        return(0);
    }

    if (cTiff < 0) {

        if (cDelta < 0) {

            PLOTDBG(DBG_COMPRESS, ("RTLCompression: Using COMPRESS_MODE_ROW"));

            CompressMode = (BYTE)COMPRESS_MODE_ROW;
            RetSize      = -Size;

        } else {

            CompressMode = (BYTE)COMPRESS_MODE_DELTA;
        }

    } else {

        //
        // If we are here, cTiff is greater than zero
        //

        CompressMode = (BYTE)(((cDelta < 0) || (cTiff <= cDelta)) ?
                                    COMPRESS_MODE_TIFF : COMPRESS_MODE_DELTA);
    }

    if ((*pCompressMode = CompressMode) == COMPRESS_MODE_DELTA) {

        //
        // We must redo the DELTA again, since pbDst was destroyed by the
        // TIFF compression
        //

        PLOTDBG(DBG_COMPRESS, ("RTLCompression: Using COMPRESS_MODE_DELTA"));

        RetSize = CompressToDelta(pbSrc, pbSeedRow, pbDst, Size);

    } else if (CompressMode == COMPRESS_MODE_TIFF) {

        PLOTDBG(DBG_COMPRESS, ("RTLCompression: Using COMPRESS_MODE_TIFF"));

        RetSize = cTiff;
    }

    //
    // We need to have current source (Original SIZE) as the new seed row
    //

    CopyMemory(pbSeedRow, pbSrc, Size);

    return(RetSize);
}




BOOL
AdaptCompression(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans,
    LPBYTE      pbSrc,
    LPBYTE      pbSeedRow,
    LPBYTE      pbDst,
    LONG        Size
    )

/*++

Routine Description:

    This function implements adaptive compression, which allows the mixing
    of different compression types in a higher level compression mode that
    is defined ahead of time.

Arguments:

    pPDev           - Pointer to our PDEV

    pRTLScans       - Pointer to the RTLSCANS data structure

    pbSrc           - pointer to the source scan

    pbSeedRow       - Pointer to the seed row for the current source scan

    pbDst           - Pointer to the compressed result will be stored

    Size            - size in bytes for pbSrc/pbSeedRow/pbDst


Return Value:

    >0  - Use *pCompressMode returned and output that many bytes
    =0  - Use *pCompressMode returned and output ZERO byte
    <0  - Use *pCompressMode returned and output original source and size

Author:

    25-Feb-1994 Fri 12:49:29 created  -by-  DC


Revision History:


--*/

{
    LPBYTE  pbOrgDst;
    LONG    Count;
    BOOL    Ok;
    BYTE    AdaptMethod;


    pbOrgDst    = pbDst;
    AdaptMethod = COMPRESS_MODE_ROW;

    if (Count = RTLCompression(pbSrc, pbSeedRow, pbDst, Size, &AdaptMethod)) {

        if (Count < 0) {

            pbDst = pbSrc;
            Count = -Count;
        }

    } else {

        AdaptMethod = (AdaptMethod == COMPRESS_MODE_DELTA) ? ADAPT_METHOD_DUP :
                                                             ADAPT_METHOD_ZERO;
    }

    if ((Ok = (BOOL)(pRTLScans->cEmptyDup == 0xFFFF))   ||
        ((pPDev->cbBufferBytes + Count) > MAX_ADAPT_SIZE)) {

        if (!(Ok = FlushAdaptBuf(pPDev, pRTLScans, Ok))) {

            return(FALSE);
        }

        //
        // Because the Seed ROW was reset to zero, we must recalculate it.
        //

        if (Count = RTLCompression(pbSrc,
                                   pbSeedRow,
                                   pbOrgDst,
                                   Size,
                                   &AdaptMethod)) {

            if (Count < 0) {

                pbDst = pbSrc;
                Count = -Count;
            }

        } else {

            AdaptMethod = (AdaptMethod == COMPRESS_MODE_DELTA) ?
                                        ADAPT_METHOD_DUP : ADAPT_METHOD_ZERO;
        }

    } else {

        Ok = TRUE;
    }


    //
    // If we are switching compression modes, do it now.
    //

    if (AdaptMethod != pRTLScans->AdaptMethod) {

        if (pRTLScans->cEmptyDup) {

            SET_ADAPT_CONTROL(pPDev,
                              pRTLScans->AdaptMethod,
                              pRTLScans->cEmptyDup);

            pRTLScans->cEmptyDup = 0;
        }

        pRTLScans->AdaptMethod = AdaptMethod;
    }

    if (Count) {

        SET_ADAPT_CONTROL(pPDev, pRTLScans->AdaptMethod, Count);
        OutputBytes(pPDev, pbDst, Count);

    } else {

        ++(pRTLScans->cEmptyDup);
    }

    return(Ok);
}




BOOL
OutputRTLScans(
    PPDEV       pPDev,
    LPBYTE      pbPlane1,
    LPBYTE      pbPlane2,
    LPBYTE      pbPlane3,
    PRTLSCANS   pRTLScans
    )

/*++

Routine Description:

    This function will output one scan line of RTL data and compress it if
    it can.

Arguments:

    pPDev           - Pointer to our PDEV

    pbPlane1        - First plane of scan data

    pbPlane2        - 2nd plane of scan data

    pbPlane3        - 3rd plane of scan data

    pRTLScans       - Pointer to the RTLSCANS data structure

Return Value:

    BOOLEAN


Author:

    18-Feb-1994 Fri 15:52:42 created  -by-  DC

    21-Feb-1994 Mon 13:20:00 updated  -by-  DC
        Make if output faster in scan line output

    16-Mar-1994 Wed 15:38:23 updated  -by-  DC
        Update so the source mask so it is restored after mask

Revision History:


--*/

{
    LPBYTE      pbCurScan;
    LPBYTE      pbCompress;
    LPBYTE      pbScans[3];
    RTLSCANS    RTLScans;
    LONG        Count;
    UINT        i;
    BYTE        EndGrafCH;
    static BYTE BegGrafCmd[] = { 0x1B, '*', 'b' };


    if (PLOT_CANCEL_JOB(pPDev)) {

        PLOTWARN(("OutputRTLScans: JOB CANCELD. exit NOW"));

        pRTLScans->Flags &= ~RTLSF_MORE_SCAN;
        return(TRUE);
    }


    //
    // If we are at the last scan line, turn the flag off so we are forced to
    // exit.
    //

    if (!(--pRTLScans->cScans)) {

        pRTLScans->Flags &= ~RTLSF_MORE_SCAN;
    }

    RTLScans             = *pRTLScans;
    Count                = (LONG)(RTLScans.cxBytes - 1);
    *(pbPlane1 + Count) &= RTLScans.Mask;

    if ((i = (UINT)RTLScans.Planes) > 1) {

        *(pbPlane2 + Count) &= RTLScans.Mask;
        *(pbPlane3 + Count) &= RTLScans.Mask;
        pbScans[2]           = pbPlane1;
        pbScans[1]           = pbPlane2;
        pbScans[0]           = pbPlane3;

    } else {

        pbScans[0] = pbPlane1;
    }

    while (i--) {

        EndGrafCH = (i) ? 'V' : 'W';
        pbCurScan = pbScans[i];

        if (RTLScans.CompressMode == COMPRESS_MODE_BLOCK) {

            OutputBytes(pPDev, pbCurScan, RTLScans.cxBytes);

        } else if (RTLScans.CompressMode == COMPRESS_MODE_ADAPT) {

            AdaptCompression(pPDev,
                             pRTLScans,
                             pbCurScan,
                             RTLScans.pbSeedRows[i],
                             RTLScans.pbCompress,
                             RTLScans.cxBytes);

        } else {

            if ((Count = RTLCompression(pbCurScan,
                                        RTLScans.pbSeedRows[i],
                                        pbCompress = RTLScans.pbCompress,
                                        RTLScans.cxBytes,
                                        &(pRTLScans->CompressMode))) < 0) {

                pbCompress = pbCurScan;
                Count      = RTLScans.cxBytes;
            }

            //
            // Now output graphic header
            //

            OutputBytes(pPDev, BegGrafCmd, sizeof(BegGrafCmd));


            //
            // If we changed compression modes then send the command out
            // and record the change.
            //

            if (pRTLScans->CompressMode != RTLScans.CompressMode) {

                PLOTDBG(DBG_OUTRTLSCAN, ("OutputRTLScan: Switch CompressMode from %ld to %ld",
                                (DWORD)RTLScans.CompressMode,
                                (DWORD)pRTLScans->CompressMode));

                RTLScans.CompressMode = pRTLScans->CompressMode;

                OutputFormatStr(pPDev, "#dm", (LONG)RTLScans.CompressMode);
            }

            OutputLONGParams(pPDev, &Count, 1, 'd');
            OutputBytes(pPDev, &EndGrafCH, 1);

            if (Count) {

                OutputBytes(pPDev, pbCompress, Count);
            }
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\compress.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    compress.h


Abstract:

    This module contains #defines and prototypes for the compress.c module.


Author:

    18-Feb-1994 Fri 09:50:29 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _COMPRESS_
#define _COMPRESS_

#define COMPRESS_MODE_NONE      (DWORD)0xFFFFFFFF
#define COMPRESS_MODE_ROW       0
#define COMPRESS_MODE_RUNLENGTH 1
#define COMPRESS_MODE_TIFF      2
#define COMPRESS_MODE_DELTA     3
#define COMPRESS_MODE_BLOCK     4
#define COMPRESS_MODE_ADAPT     5


#define RTLSF_MORE_SCAN         0x01


typedef struct _RTLSCANS {
    LPBYTE  pbCompress;
    LPBYTE  pbSeedRows[3];
    DWORD   MaxAdaptBufSize;
    WORD    cEmptyDup;
    BYTE    AdaptMethod;
    BYTE    cAdaptBlk;
    DWORD   cxBytes;
    DWORD   cScans;
    BYTE    Flags;
    BYTE    Planes;
    BYTE    Mask;
    BYTE    CompressMode;
    } RTLSCANS, FAR *PRTLSCANS;


//
// The function protypes
//

VOID
ExitRTLScans(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans
    );

VOID
EnterRTLScans(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans,
    DWORD       cx,
    DWORD       cy,
    BOOL        MonoBmp
    );

LONG
CompressToDelta(
    LPBYTE  pbSrc,
    LPBYTE  pbSeedRow,
    LPBYTE  pbDst,
    LONG    Size
    );

LONG
CompressToTIFF(
    LPBYTE  pbSrc,
    LPBYTE  pbDst,
    LONG    Size
    );

LONG
RTLCompression(
    LPBYTE  pbSrc,
    LPBYTE  pbSeedRow,
    LPBYTE  pbDst,
    LONG    Size,
    LPBYTE  pCompressMode
    );

BOOL
OutputRTLScans(
    PPDEV       pPDev,
    LPBYTE      pbPlane1,
    LPBYTE      pbPlane2,
    LPBYTE      pbPlane3,
    PRTLSCANS   pRTLScans
    );


#endif  // _COMPRESS_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\enable.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    enable.h


Abstract:

    This module contains local #defines used by enable.c


Author:

    12-Nov-1993 Fri 10:27:07 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTENABLE_
#define _PLOTENABLE_



#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\escape.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    escape.h


Abstract:

    This module contains prototype and #defines for escape.c


Author:

    18-Nov-1993 Thu 04:49:28 created  -by-  JB


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTESCAPE_
#define _PLOTESCAPE_


BOOL
DrvStartPage(
    SURFOBJ *pso
    );



#endif  // _PLOTESCAPE_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\enable.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    enable.c


Abstract:

    This module contains the Plotter driver's Enable and Disable functions
    and related routines.

    The functions dealing with driver initialization are as follows:

        DrvEnableDriver()
        DrvEnablePDEV()
        DrvResetPDEV()
        DrvCompletePDEV()
        DrvEnableSurface()
        DrvDisableSurface()
        DrvDisablePDEV()
        DrvDisableDriver()

Author:

    12-Nov-1993 Fri 10:16:36 updated  -by-  DC
        Move all #define related only to this function to here

    15-Nov-1993 Mon 19:31:34 updated  -by-  DC
        clean up / debugging information

    05-Jan-1994 Wed 22:50:28 updated  -by-  DC
        Move ColorMap's RGB pen color to local so that we only need array
        reference, it defined PenRGBColor as DWORD from RGB() macro

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgEnable

#define DBG_ENABLEDRV       0x00000001
#define DBG_DISABLEDRV      0x00000002
#define DBG_ENABLEPDEV      0x00000004
#define DBG_COMPLETEPDEV    0x00000008
#define DBG_DISABLEPDEV     0x00000010
#define DBG_ENABLESURF      0x00000020
#define DBG_DISABLESURF     0x00000040
#define DBG_GDICAPS         0x00000080
#define DBG_DEVCAPS         0x00000100
#define DBG_PENPAL          0x00000200
#define DBG_BAND            0x00000400
#define DBG_DLLINIT         0x00000800


DEFINE_DBGVAR(0);

#if DBG
TCHAR   DebugDLLName[] = TEXT("PLOTTER");
#endif

#define FIXUP_PLOTGPC_PDATA(pd,ps,v)                                        \
    if (ps->v) {pd->v=(LPVOID)((LPBYTE)pd+((LPBYTE)(ps->v)-(LPBYTE)ps));}

//
// Local funtion prototypes.
//

BOOL
CommonStartPDEV(
    PDEV        *pPDev,
    DEVMODEW    *pPlotDMIn,
    ULONG       cPatterns,
    HSURF       *phsurfPatterns,
    ULONG       cjDevCaps,
    ULONG       *pDevCaps,
    ULONG       cjDevInfo,
    DEVINFO     *pDevInfo
    );



//
// Define the table with the hooked function pointers. This table is passed
// back to the NT graphic engine at DrvEnableDriver time. From then on GDI
// will call our driver via these supplied hook procs.
//


static const DRVFN DrvFuncTable[] = {

        {  INDEX_DrvDisableDriver,       (PFN)DrvDisableDriver      },
        {  INDEX_DrvEnablePDEV,          (PFN)DrvEnablePDEV         },
        {  INDEX_DrvResetPDEV,           (PFN)DrvResetPDEV          },
        {  INDEX_DrvCompletePDEV,        (PFN)DrvCompletePDEV       },
        {  INDEX_DrvDisablePDEV,         (PFN)DrvDisablePDEV        },
        {  INDEX_DrvEnableSurface,       (PFN)DrvEnableSurface      },
        {  INDEX_DrvDisableSurface,      (PFN)DrvDisableSurface     },

        // {  INDEX_DrvQueryFont,           (PFN)DrvQueryFont          },
        // {  INDEX_DrvQueryFontTree,       (PFN)DrvQueryFontTree      },
        // {  INDEX_DrvQueryFontData,       (PFN)DrvQueryFontData      },

        {  INDEX_DrvStrokePath,          (PFN)DrvStrokePath         },
        {  INDEX_DrvStrokeAndFillPath,   (PFN)DrvStrokeAndFillPath  },
        {  INDEX_DrvFillPath,            (PFN)DrvFillPath           },
        {  INDEX_DrvRealizeBrush,        (PFN)DrvRealizeBrush       },
        {  INDEX_DrvBitBlt,              (PFN)DrvBitBlt             },
        {  INDEX_DrvStretchBlt,          (PFN)DrvStretchBlt         },
        {  INDEX_DrvCopyBits,            (PFN)DrvCopyBits           },

        {  INDEX_DrvPaint,               (PFN)DrvPaint              },
        {  INDEX_DrvGetGlyphMode,        (PFN)DrvGetGlyphMode       },
        {  INDEX_DrvTextOut,             (PFN)DrvTextOut            },
        {  INDEX_DrvSendPage,            (PFN)DrvSendPage           },
        {  INDEX_DrvStartPage,           (PFN)DrvStartPage          },
        {  INDEX_DrvStartDoc,            (PFN)DrvStartDoc           },
        {  INDEX_DrvEndDoc,              (PFN)DrvEndDoc             },

        {  INDEX_DrvEscape,              (PFN)DrvEscape             },
    };

#define TOTAL_DRVFUNC   (sizeof(DrvFuncTable)/sizeof(DrvFuncTable[0]))

#ifdef USERMODE_DRIVER


HINSTANCE   ghInstance;

BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


BOOL
DrvQueryDriverInfo(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    )

/*++

Routine Description:

    Query driver information

Arguments:

    dwMode - Specify the information being queried
    pBuffer - Points to output buffer
    cbBuf - Size of output buffer in bytes
    pcbNeeded - Return the expected size of output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    switch (dwMode)
    {
    case DRVQUERY_USERMODE:

        PLOTASSERT(1, "DrvQueryDriverInfo: pcbNeeded [%08lx] is NULL", pcbNeeded != NULL, pcbNeeded);
        *pcbNeeded = sizeof(DWORD);

        if (pBuffer == NULL || cbBuf < sizeof(DWORD))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PDWORD) pBuffer) = TRUE;
        return TRUE;

    default:

        PLOTERR(("Unknown dwMode in DrvQueryDriverInfo: %d\n", dwMode));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}

#endif // USERMODE_DRIVER



BOOL
DrvEnableDriver(
    ULONG           iEngineVersion,
    ULONG           cb,
    DRVENABLEDATA   *pded
    )

/*++

Routine Description:

    Requests the driver to fill in a structure containing recognized functions
    and other control information.  One time initialization, such as semaphore
    allocation may be performed,  but no device activity should happen.  That
    is done when DrvEnablePDEV is called.  This function is the only way the
    engine can determine what functions we supply to it.

Arguments:

    iEngineVersion  - The engine version which we run under

    cb              - total bytes in pded

    pded            - Pointer to the DRVENABLEDATA data structure


Return Value:

    TRUE if sucssfully FALSE otherwise


Author:

    01-Dec-1993 Wed 02:03:20 created  -by-  DC

    03-Mar-1994 Thu 10:04:30 updated  -by-  DC
        Adding EngineVersion check to make sure ourself can run correctly.


Revision History:


--*/

{
    PLOTDBG(DBG_ENABLEDRV, ("DrvEnableDriver: EngineVersion=%08lx, Request=%08lx",
                                    iEngineVersion, DDI_DRIVER_VERSION_NT4));

    //
    // Verify the Engine version is at least what we know we can work with.
    // If its older, error out now, as we don't know what may happen.
    //

    if (iEngineVersion < DDI_DRIVER_VERSION_NT4) {

        PLOTRIP(("DrvEnableDriver: EARLIER VERSION: EngineVersion(%08lx) < Request(%08lx)",
                                    iEngineVersion, DDI_DRIVER_VERSION_NT4));

        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return(FALSE);
    }

    //
    // cb is a count of the number of bytes available in pded.  It is not
    // clear that there is any significant use of the engine version number.
    // Returns TRUE if successfully enabled,  otherwise FALSE.
    //
    // iEngineVersion is the engine version while DDI_DRIVER_VERSION is the
    // driver version. So, unless we re-compile the driver and get a new
    // version of driver, we can only stick with our version.
    //

    if (cb < sizeof(DRVENABLEDATA)) {

        SetLastError(ERROR_INVALID_PARAMETER);

        PLOTRIP(("DrvEnableDriver: cb=%ld, should be %ld\n",
                                                cb, sizeof(DRVENABLEDATA)));
        return(FALSE);
    }

    pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    //
    // Fill in the driver table returned to the engine.  This table is used
    // by GDI to call the rest of our functinos.
    //

    pded->c      = TOTAL_DRVFUNC;
    pded->pdrvfn = (DRVFN *)DrvFuncTable;

    //
    // Initialize the GPC cache
    //

    InitCachedData();

    return(TRUE);
}





VOID
DrvDisableDriver(
    VOID
    )

/*++

Routine Description:

    Called just before the engine unloads the driver.  Main purpose is
    to allow freeing of any resources obtained during the DrvEnableDriver()
    call.

Arguments:

    NONE

Return Value:

    VOID

Author:

    01-Dec-1993 Wed 02:02:18 created  -by-  DC

    01-Feb-1994 Tue 22:03:03 updated  -by-  DC
        Make sure we unload the cache.


Revision History:


--*/

{
    DestroyCachedData();

    PLOTDBG(DBG_DISABLEDRV, ("DrvDisableDriver: Done!!"));
}




VOID
FreeAllocMem(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function frees all the memory allocated during the lifetime of the
    PDEV.


Arguments:

    pPDev   - Our instance data


Return Value:

    VOID


Author:

    24-Oct-1995 Tue 16:28:35 created  -by-  DC


Revision History:


--*/

{
    //
    // Free any memory allocated during PDEV initialization.
    //

    if (pPDev) {

        PDRVHTINFO  pDrvHTInfo;

        if (pPDev->hPalDefault) {

            EngDeletePalette(pPDev->hPalDefault);
            pPDev->hPalDefault = NULL;
        }

        if (pDrvHTInfo = (PDRVHTINFO)(pPDev->pvDrvHTData)) {

            if (pDrvHTInfo->pHTXB) {

                LocalFree((HLOCAL)pDrvHTInfo->pHTXB);
                pDrvHTInfo->pHTXB = NULL;
            }

            pPDev->pvDrvHTData = NULL;
        }

        if (pPDev->pPenCache) {

            LocalFree((HLOCAL)pPDev->pPenCache);
            pPDev->pPenCache = NULL;
        }

        if (pPDev->pTransPosTable) {

            LocalFree((HLOCAL)pPDev->pTransPosTable);
            pPDev->pTransPosTable = NULL;
        }

        FreeOutBuffer(pPDev);

        LocalFree((HLOCAL)pPDev);
    }
}



DHPDEV
DrvEnablePDEV(
    DEVMODEW    *pPlotDMIn,
    PWSTR       pwszLogAddr,
    ULONG       cPatterns,
    HSURF       *phsurfPatterns,
    ULONG       cjDevCaps,
    ULONG       *pDevCaps,
    ULONG       cjDevInfo,
    DEVINFO     *pDevInfo,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver
    )

/*++

Routine Description:

    Function called to let the driver create the data structures
    needed to support the device,  and also to tell the engine
    about its capabilities.  This is the stage where we find out
    exactly which device we are dealing with,  and so we need to
    find out its capabilities.

Arguments:

    pPlotDMIn       - Pointer to the DEVMODE data structure

    pwszLogAddr     - pointer to the output location, (ie. LPT1

    cPatterns       - Count of pattern to be set in phsurfPatterns

    phsurfPatterns  - pointer to the standard pattern HSURF array

    cjDevCaps       - total size of pDevCaps pointed to.

    pDevCaps        - pointer to the device cap DWORDs

    cjDevInfo       - total size of pDevInfo pointed to

    pDevInfo        - pointer to the DEVINFO data structure

    hdev            - Handle to the logical device from the engine

    pwszDeviceName  - pointer to the plotter device name

    hDriver         - handle to this driver


Return Value:

    DHPDEV  if sucessful, NULL if failed


Author:

    15-Dec-1993 Wed 21:04:40 updated  -by-  DC
        Add cached mechanism for the PLOTGPC

    14-Dec-1993 Tue 20:22:26 updated  -by-  DC
        Update how the pen plotter data should work

    23-Nov-1993 Tue 19:48:08 updated  -by-  DC
        Clean up and using new devmode.c in ..\lib directory

    17:30 on Mon  1 Apr 1991    -by-    SC
        Took skeletal code from RASDD printer driver

    16-Jul-1996 Tue 13:59:15 updated  -by-  DC
        Fix up the pData in the PLOTGPC/GPCVARSIZE structure, since the
        pointer is based on the cached GPC not the clone copy of it


Revision History:


--*/

{
    PPDEV       pPDev = NULL;
    PPLOTGPC    pPlotGPC;
    LPWSTR      pwszDataFile = NULL;

#ifdef USERMODE_DRIVER

    PDRIVER_INFO_2 pDriverInfo = NULL;
    DWORD       dwBytesNeeded;

#endif


    UNREFERENCED_PARAMETER(pwszLogAddr);

    #ifndef USERMODE_DRIVER

    pwszDataFile = EngGetPrinterDataFileName(hdev);

    #else

    if (!GetPrinterDriver(hDriver, NULL, 2, NULL, 0, &dwBytesNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pDriverInfo = (PDRIVER_INFO_2)LocalAlloc(LPTR, dwBytesNeeded)) &&
        GetPrinterDriver(hDriver, NULL, 2, (LPBYTE)pDriverInfo, dwBytesNeeded, &dwBytesNeeded))
    {
        pwszDataFile = pDriverInfo->pDataFile;
    }

    #endif  // !USERMODE_DRIVER

    if (!pwszDataFile) {

        PLOTRIP(("DrvEnablePDEV: pwszDataFile is NULL"));

    } else if (!(pPlotGPC = GetCachedPlotGPC(pwszDataFile))) {

        PLOTRIP(("DrvEnablePDEV: GetCachedPlotGPC(%ws) failed", pwszDataFile));

    } else if (!(pPDev = (PPDEV)LocalAlloc(LPTR,
                                           sizeof(PDEV) + sizeof(DRVHTINFO) +
                                                    pPlotGPC->cjThis +
                                                    pPlotGPC->SizeExtra))) {

        //
        // Free the cached pPlotGPC before we leave
        //

        UnGetCachedPlotGPC(pPlotGPC);

        PLOTRIP(("DrvEnablePDEV: LocalAlloc(PDEV + DRVHTINFO + pPlotGPC) failed."));

    } else {

        PLOTDBG(DBG_ENABLEPDEV,("EnablePDEV: PlotGPC data file=%ws",
                                                            pwszDataFile));

        //
        // If we got the PDEV set the ID for later checking, also set the
        // hPrinter so we can use it later
        //

        pPDev->pvDrvHTData = (LPVOID)((LPBYTE)pPDev + sizeof(PDEV));
        pPDev->hPrinter    = hDriver;
        pPDev->SizePDEV    = sizeof(PDEV);
        pPDev->PDEVBegID   = PDEV_BEG_ID;
        pPDev->PDEVEndID   = PDEV_END_ID;

        //
        // We will get the PLOTGPC from the cach, the pPlotGPC is
        // allocated by the ReadPlotGPCFromFile() using LocalAlloc().
        //
        // *** NOW we will Clone the cached pPlotGPC then un-cached it
        //

        pPDev->pPlotGPC = (PPLOTGPC)((LPBYTE)pPDev + sizeof (PDEV) +
                                                            sizeof(DRVHTINFO));

        CopyMemory(pPDev->pPlotGPC,
                   pPlotGPC,
                   pPlotGPC->cjThis + pPlotGPC->SizeExtra);

        //
        // 16-Jul-1996 Tue 13:59:15 updated  -by-  DC
        //  Fix up the pData in the PLOTGPC/GPCVARSIZE structure, since the
        //  pointer is based on the cached GPC not the clone copy of it
        //

        FIXUP_PLOTGPC_PDATA(pPDev->pPlotGPC, pPlotGPC, InitString.pData);
        FIXUP_PLOTGPC_PDATA(pPDev->pPlotGPC, pPlotGPC, Forms.pData);
        FIXUP_PLOTGPC_PDATA(pPDev->pPlotGPC, pPlotGPC, Pens.pData);

        UnGetCachedPlotGPC(pPlotGPC);

        //
        // Now, depending on if its a pen/raster device, we will update
        // the pen data.
        //

        PLOTASSERT(1, "Raster Plotter should not have PEN data [%08lx]",
                        ((pPDev->pPlotGPC->Flags & PLOTF_RASTER) &&
                         (pPDev->pPlotGPC->Pens.pData == NULL))     ||
                        ((!(pPDev->pPlotGPC->Flags & PLOTF_RASTER)) &&
                         (pPDev->pPlotGPC->Pens.pData != NULL)),
                         pPDev->pPlotGPC->Pens.pData);

        //
        // Read the data from the registry which defines device settings.
        // The user may have modified the paper type loaded etc.
        //

        GetDefaultPlotterForm(pPDev->pPlotGPC, &(pPDev->CurPaper));

        //
        // Set the default Flags in case we did not update from the registry
        //

        pPDev->PPData.Flags = PPF_AUTO_ROTATE     |
                              PPF_SMALLER_FORM    |
                              PPF_MANUAL_FEED_CX;

        if (IS_RASTER(pPDev)) {

            //
            // Raster devices do not need pen data
            //

            UpdateFromRegistry(hDriver,
                               &(pPDev->pPlotGPC->ci),
                               &(pPDev->pPlotGPC->DevicePelsDPI),
                               &(pPDev->pPlotGPC->HTPatternSize),
                               &(pPDev->CurPaper),
                               &(pPDev->PPData),
                               NULL,
                               0,
                               NULL);

        } else {

            //
            // The Pen plotter does not need ColorInfo, DevicePelsDPI and
            // HTPatternSize
            //

            UpdateFromRegistry(hDriver,
                               NULL,
                               NULL,
                               NULL,
                               &(pPDev->CurPaper),
                               &(pPDev->PPData),
                               NULL,
                               MAKELONG(0xFFFF, pPDev->pPlotGPC->MaxPens),
                               (PPENDATA)pPDev->pPlotGPC->Pens.pData);
        }

        //
        // common code for DrvEnablePDEV and DrvResetPDEV
        // we must first copy the device name to the pPDev->PlotDM
        // then call the common code.
        //

        WCPYFIELDNAME(pPDev->PlotDM.dm.dmDeviceName, pwszDeviceName);

        if (!CommonStartPDEV(pPDev,
                             pPlotDMIn,
                             cPatterns,
                             phsurfPatterns,
                             cjDevCaps,
                             pDevCaps,
                             cjDevInfo,
                             pDevInfo)) {

            FreeAllocMem(pPDev);
            pPDev = NULL;

        }
    }

#ifdef USERMODE_DRIVER

    if (pDriverInfo) {

       LocalFree((HLOCAL)pDriverInfo);
    }

#endif // USERMODE_DRIVER

    return((DHPDEV)pPDev);
}




BOOL
DrvResetPDEV(
    DHPDEV      dhpdevOld,
    DHPDEV      dhpdevNew
    )

/*++

Routine Description:

   Called when an application wishes to change the output style in the
   midst of a job.  Typically this would be to change from portrait to
   landscape or vice versa.  Any other sensible change is permitted.

Arguments:

    dhpdevOld   - the OLD pPDev which we returned in DrvEnablePDEV

    dhpdevNew   - the NEW pPDev which we returned in DrvEnablePDEV


Return Value:


    BOOLEAN


Author:

    23-Nov-1993 Tue 20:07:45 updated  -by-  DC
        totaly re-write

    17:30 on Mon  1 Apr 1991    -by-   SC
        Took skeletal code from RASDD printer driver





Revision History:


--*/

{
#define pPDevOld    ((PDEV *) dhpdevOld)
#define pPDevNew    ((PDEV *) dhpdevNew)

    //
    // Make sure we got the correct pPlotDMin for this pPDev
    //

    if ((pPDevOld->PlotDM.dm.dmDriverVersion !=
                                pPDevNew->PlotDM.dm.dmDriverVersion) ||
        (wcscmp((LPWSTR)pPDevOld->PlotDM.dm.dmDeviceName,
                (LPWSTR)pPDevNew->PlotDM.dm.dmDeviceName))) {

        PLOTERR(("DrvResetPDEV: Incompatible PLOTDEVMODE"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // We have nothing to carry over from old to new
    //

    return(TRUE);


#undef pPDevNew
#undef pPDevOld
}



VOID
DrvCompletePDEV(
    DHPDEV  dhpdev,
    HDEV    hpdev
    )

/*++

Routine Description:

    Called when the engine has completed installation of the physical
    device.  Basically it provides the connection between the
    engine's hpdev and ours.  Some functions require us to pass in
    the engines's hpdev,  so we save it now in our pdev so that we
    can get to it later.

Arguments:

    dhpdev  - Returned from dhpdevCreatePDEV

    hpdev   - Engine's corresponding handle


Return Value:

    VOID


Author:

    01-Dec-1993 Wed 01:56:58 created  -by-  DC


Revision History:


--*/

{
    //
    // Simply record the value in the PDEV we have allocated.
    //

    ((PPDEV)dhpdev)->hpdev = hpdev;

    PLOTDBG(DBG_COMPLETEPDEV, ("CompletePDEV: Done!"));
}



VOID
DrvDisablePDEV(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    Called when the engine has finished with this PDEV.  Basically we throw
    away all connections etc. then free the memory.

Arguments:

    dhpdev  - OUR handle to the pdev

Return Value:

    VOID


Author:

    01-Dec-1993 Wed 01:55:43 created  -by-  DC


Revision History:


--*/

{
#define pPDev  ((PDEV *) dhpdev)

    //
    // Undo all that has been done with the PDEV.  Basically this means
    // freeing the memory we consumed.
    //

    FreeAllocMem(pPDev);

    PLOTDBG(DBG_DISABLEPDEV, ("DrvDisablePDEV: FreeAllocMem() completes"));

#undef pPDev
}




HSURF
DrvEnableSurface(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    Function to create the physical drawing surface for the pdev
    that was created earlier.  Since we don't really have a bitmap surface,
    all we do here is allocate the output buffer. This is typical for a
    Device Managed Surface. After this call completes succesfully, GDI can
    start drawing on our surface.



Arguments:

    dhpdev  - OUR handle to the pdev

Return Value:

    HSURF for the surface we created


Author:

    01-Dec-1993 Wed 01:47:36 created  -by-  DC

    10-Dec-1993 Fri 16:36:37 updated  -by-  DC
        Move PlotCreatePalette() to here to prevent GP

    16-Dec-1993 Thu 12:16:11 updated  -by-  DC
        Move PlotCreatePalette() out to SendPageHeader() in output.c so that
        we do not sending some PC commands which has no effects.

    06-Jan-1994 Thu 04:12:37 updated  -by-  DC
        Re-arrange the code sequence.
        Adding Error codes so it will failed the call if engine said so.

Revision History:


--*/

{
#define  pPDev ((PPDEV)dhpdev)

    PDRVHTINFO  pDrvHTInfo;
    SIZEL       SurfSize;


    pDrvHTInfo = (PDRVHTINFO)(pPDev->pvDrvHTData);

    //
    // Make sure we delete this xlate table before we process the new
    // surface
    //

    if (pDrvHTInfo->pHTXB) {

        LocalFree((HLOCAL)pDrvHTInfo->pHTXB);
        pDrvHTInfo->pHTXB = NULL;
    }

    pDrvHTInfo->Flags       = 0;
    pDrvHTInfo->PalXlate[0] = 0xff;
    pDrvHTInfo->HTPalXor    = HTPALXOR_SRCCOPY;

    //
    // Since output is expected to follow this call,  allocate storage for the
    // output buffer.  This used to be statically allocated within the PDEV but
    // now we can save that space for INFO type DCs, since CreateIC won't
    // actually end up calling DrvEnableSurface.
    //

    if (!AllocOutBuffer(pPDev)) {

        PLOTERR(("DrvEnableSurface: AllocOutBuffer() failed"));

        return(NULL);
    }

    //
    // For now pass in my PDev pointer as the dhsurf value.  If we actually
    // need to pass back an hsurf to the engine later, We can use this value
    // as a pointer to the hsurf value stored in our PDev.
    //

    SurfSize.cx  = pPDev->HorzRes;
    SurfSize.cy  = pPDev->VertRes;

    if (!(pPDev->hsurf = EngCreateDeviceSurface((DHSURF)pPDev, SurfSize,
                         IS_RASTER(pPDev) ? BMF_24BPP : BMF_4BPP))) {
        PLOTERR(("DrvEnableSurface: EngCreateDeviceSurface() failed"));
        return(NULL);
    }

    //
    //
    // Now we need to associate the newly created surface with the already
    // created PDEV. In this function, we inform the NT graphics engine,
    // which functions our driver supports.
    //

    if (!EngAssociateSurface(pPDev->hsurf,
                             (HDEV)pPDev->hpdev,
                             HOOK_BITBLT                |
                                 HOOK_STRETCHBLT        |
                                 HOOK_COPYBITS          |
                                 HOOK_STROKEPATH        |
                                 HOOK_FILLPATH          |
                                 HOOK_STROKEANDFILLPATH |
                                 HOOK_PAINT             |
                                 HOOK_TEXTOUT)) {

        PLOTERR(("DrvEnableSurface: EngAssociateSurface() failed"));

        DrvDisableSurface((DHPDEV)pPDev->hpdev);
        EngDeleteSurface(pPDev->hsurf);

        return(NULL);
    }

    return(pPDev->hsurf);

#undef pPDev
}



VOID
DrvDisableSurface(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    The drawing surface is no longer required,  so we can delete any
    memory we allocated in conjunction with it.

Arguments:

    dhpdev  - our pPDev


Return Value:

    VOID


Author:

    01-Dec-1993 Wed 01:45:39 created  -by-  DC


Revision History:


--*/

{
#define  pPDev ((PPDEV)dhpdev)

    if (pPDev->hsurf) {

        EngDeleteSurface(pPDev->hsurf);
    }

#undef pPDev
}




DWORD
hypot(
    DWORD   x,
    DWORD   y
    )

/*++

Routine Description:

    Returns the length of the hypotenous of a xRight triangle whose sides
    are passed in as the parameters.

Arguments:

    x   - x side of the triangle

    y   - y size of the triangle

Return Value:

    hypotenous


Author:

    13:54 on Tue 02 Feb 1993    -by-    LH
        Re-instated from Win 3.1,  for compatability.

    01-Dec-1993 Wed 01:10:55 updated  -by-  DC
        update to DWORD

Revision History:


--*/

{
    DWORD   hypo;
    DWORD   Delta;
    DWORD   Target;

    //
    // Finds the hypoteneous of a xRight triangle with legs equal to x and y.
    // Assumes x, y, hypo are integers. Use sq(x) + sq(y) = sq(hypo);
    // Start with MAX(x, y), use sq(x + 1) = sq(x) + 2x + 1 to incrementally
    // get to the target hypotenouse.
    //

    hypo    = max(x, y);
    Target  = min(x, y);
    Target *= Target;

    for (Delta = 0; Delta < Target; hypo++) {

        Delta += (DWORD)((hypo << 1) + 1);
    }

    return(hypo);
}




VOID
FillDeviceCaps(
    PPDEV   pPDev,
    GDIINFO *pGDIInfo
    )

/*++

Routine Description:

    Set up the device caps for this particular plotter.  Some fields require
    calculations based on device resolution, etc.

    We simply fill the GDIINFO structure passed to us.  The calling
    function will take care of copying the information into the
    Graphics Engine's buffer.


Arguments:

    pPDev       - Pointer to the PDEV data structure

    pGDIInfo    - Pointer to the GDIINFO data structure to be filled in


Return Value:

    VOID


Author:

    24-Nov-1993 Wed 22:38:10 updated  -by-  DC
        Re-write, and using CurForm to replace the pform and PAPER_DIM

    23-Dec-1993 Thu 21:56:20 updated  -by-  DC
        Make halftone bitmap surface also look at dmColor which set by the
        user if it want to print grey scale or device is not color

    07-Feb-1994 Mon 20:37:13 updated  -by-  DC
        When is DMCOLOR_COLOR the ulNumColors return to the engine will be
        MaxPens which specified in the PCD file not 8


Revision History:


--*/

{
    PDRVHTINFO  pDrvHTInfo;
    LONG        Scale;


    //
    // we will always start from clean state
    //

    ZeroMemory(pGDIInfo, sizeof(GDIINFO));

    //
    // Get pDrvHTInfo data pointer and set the basic version information
    //

    pDrvHTInfo             = (PDRVHTINFO)pPDev->pvDrvHTData;
    pGDIInfo->ulVersion    = DRIVER_VERSION;
    pGDIInfo->ulTechnology = (IS_RASTER(pPDev) ? DT_RASPRINTER : DT_PLOTTER);

    //
    // We have pPDev->PlotForm updated during the ValidateSetPLOTDM() call, so
    // use it, we need to look into the dmScale to see if we need to scale
    // all of the values.
    //

    Scale                = (LONG)pPDev->PlotDM.dm.dmScale;
    pGDIInfo->ulHorzSize = pPDev->PlotForm.LogExt.cx / (Scale * 10);
    pGDIInfo->ulVertSize = pPDev->PlotForm.LogExt.cy / (Scale * 10);
    pPDev->HorzRes       =
    pGDIInfo->ulHorzRes  = SPLTOENGUNITS(pPDev, pPDev->PlotForm.LogExt.cx);
    pPDev->VertRes       =
    pGDIInfo->ulVertRes  = SPLTOENGUNITS(pPDev, pPDev->PlotForm.LogExt.cy);

    PLOTDBG(DBG_GDICAPS, ("GDICAPS: H/V Size=%d x %d, H/V Res=%ld x %ld",
                            pGDIInfo->ulHorzSize, pGDIInfo->ulVertSize,
                            pGDIInfo->ulHorzRes, pGDIInfo->ulVertRes));

    pGDIInfo->szlPhysSize.cx  = SPLTOENGUNITS(pPDev,pPDev->PlotForm.LogSize.cx);
    pGDIInfo->szlPhysSize.cy  = SPLTOENGUNITS(pPDev,pPDev->PlotForm.LogSize.cy);
    pGDIInfo->ptlPhysOffset.x = SPLTOENGUNITS(pPDev,pPDev->PlotForm.PhyOrg.x);
    pGDIInfo->ptlPhysOffset.y = SPLTOENGUNITS(pPDev,pPDev->PlotForm.PhyOrg.y);

    PLOTDBG(DBG_GDICAPS, ("GDICAPS: PhySize= %d x %d, PhyOff=(%ld, %ld)",
                pGDIInfo->szlPhysSize.cx, pGDIInfo->szlPhysSize.cy,
                pGDIInfo->ptlPhysOffset.x, pGDIInfo->ptlPhysOffset.y));

    //
    // Assume the device has a 1:1 aspect ratio
    //

    pGDIInfo->ulLogPixelsX =
    pGDIInfo->ulLogPixelsY = (pPDev->lCurResolution * Scale / 100);

    PLOTDBG(DBG_GDICAPS, ("GDICAPS: LogPixelsX/Y = %d x %d",
                pGDIInfo->ulLogPixelsX, pGDIInfo->ulLogPixelsY));

    pGDIInfo->ulAspectX    =
    pGDIInfo->ulAspectY    = pPDev->lCurResolution;
    pGDIInfo->ulAspectXY   = hypot(pGDIInfo->ulAspectX, pGDIInfo->ulAspectY);


    pGDIInfo->ciDevice        = pPDev->pPlotGPC->ci;
    pGDIInfo->ulDevicePelsDPI = (DWORD)pPDev->pPlotGPC->DevicePelsDPI *
                                (DWORD)Scale / (DWORD)100;
    pGDIInfo->ulHTPatternSize = pPDev->pPlotGPC->HTPatternSize;
    pGDIInfo->flHTFlags       = HT_FLAG_HAS_BLACK_DYE;
    pGDIInfo->ulPrimaryOrder  = PRIMARY_ORDER_CBA;

    PLOTDBG(DBG_GDICAPS, ("GDICAPS: HTPatSize=%ld, DevPelsDPI=%ld, PrimaryOrder=%ld",
                    pGDIInfo->ulHTPatternSize, pGDIInfo->ulDevicePelsDPI,
                    pGDIInfo->ulPrimaryOrder));

    //
    // If the device is a color device, then set up the Halftoning info now.
    //

    if (pPDev->PlotDM.dm.dmColor == DMCOLOR_COLOR) {

        //
        // Do this only if we really want to do color in R/G/B not C/M/Y
        //

        PLOTDBG(DBG_DEVCAPS, ("FillDeviceCaps: Doing Color Output"));

        pDrvHTInfo->HTPalCount     = 8;
        pDrvHTInfo->HTBmpFormat    = (BYTE)BMF_4BPP;
        pDrvHTInfo->AltBmpFormat   = (BYTE)BMF_1BPP;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_4BPP;

    } else {

        pDrvHTInfo->HTPalCount     = 2;
        pDrvHTInfo->HTBmpFormat    = (BYTE)BMF_1BPP;
        pDrvHTInfo->AltBmpFormat   = (BYTE)0xff;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_1BPP;

        //
        // Using this flag will give us a good benefit, the flag notifies gdi
        // and halftone eng. that the output from halftone will be
        // 0=white and 1=black
        // as opposed to the typical 0=black, 1=white, so that at 99% of time
        // we do not have to flip the B/W buffer except if CopyBits is from the
        // calling app.
        //
        // pGDIInfo->flHTFlags |= HT_FLAG_OUTPUT_CMY;
        //

        PLOTDBG(DBG_DEVCAPS, ("FillDeviceCaps: Doing GREY SCALE (%hs) Output",
            (pGDIInfo->flHTFlags & HT_FLAG_OUTPUT_CMY) ? "CMY: 0=W, 1=K" :
                                                         "RGB: 0=K, 1=W"));
    }

    pGDIInfo->ulNumColors   = pPDev->pPlotGPC->MaxPens;
    pDrvHTInfo->Flags       = 0;
    pDrvHTInfo->PalXlate[0] = 0xff;
    pDrvHTInfo->HTPalXor    = HTPALXOR_SRCCOPY;

    pGDIInfo->cBitsPixel = 24;
    pGDIInfo->cPlanes    = 1;

    //
    // Some other information the Engine expects us to fill in.
    //

    pGDIInfo->ulDACRed     = 0;
    pGDIInfo->ulDACGreen   = 0;
    pGDIInfo->ulDACBlue    = 0;
    pGDIInfo->flRaster     = 0;
    pGDIInfo->flTextCaps   = 0;
    pGDIInfo->xStyleStep   = 1;
    pGDIInfo->yStyleStep   = 1;
    pGDIInfo->denStyleStep = PLOT_STYLE_STEP(pPDev);

}





BOOL
FillDevInfo(
    PPDEV   pPDev,
    DEVINFO *pDevInfo
    )

/*++

Routine Description:

    Set up the device info for this particular plotter.  Some fields
    require calculations based on device resolution, etc.

    We simply fill the DevInfo structure passed to us.  The calling
    function will take care of copying the information into the
    Graphics Engine's buffer.


Arguments:

    pPDev           - pointer to the PDEV data structure

    pDevInfo        - pointer to the DEVINFO to be filled


Return Value:

    TRUE if sucessful FALSE otherwise


Author:

    01-Dec-1993 Wed 00:46:00 created  -by-  DC

    10-Dec-1993 Fri 16:37:06 updated  -by-  DC
        Temp. disable and move the PlotCreatePalette to EnableSurf call

    17-Dec-1993 Fri 16:37:06 updated  -by-  JB
        Move PlotCreatePalette to StartDoc time

    05-Jan-1994 Wed 22:54:21 updated  -by-  DC
        Move PenColor Reference to this file and reference that directly as
        DWORD generate by RGB() marco

    14-Jan-1994 Fri 15:35:02 updated  -by-  DC
        Remove HTPatternSize param

    23-Feb-1994 Wed 13:02:09 updated  -by-  DC
        Make sure we return GCAPS_HALFTONE so that we will get DrvStretchBlt()
        callback

Revision History:


--*/

{

    //
    // Start with a clean slate.
    //

    ZeroMemory(pDevInfo, sizeof(DEVINFO));

    //
    // fill in the graphics capabilities flags we know we can handle at
    // the very least.
    //

    pDevInfo->flGraphicsCaps = GCAPS_ALTERNATEFILL  |
                               GCAPS_HORIZSTRIKE    |
                               GCAPS_VERTSTRIKE     |
                               GCAPS_VECTORFONT;

    //
    // If RGB mode is on for color handling then text can be opaque
    //

    if (IS_RASTER(pPDev)) {

        pDevInfo->flGraphicsCaps |= GCAPS_HALFTONE;

        if (IS_COLOR(pPDev)) {

            pDevInfo->flGraphicsCaps |= GCAPS_OPAQUERECT;
        }
    }

    //
    // Check and set the BEZIER capability of the device....
    //

    if (IS_BEZIER(pPDev)) {

        pDevInfo->flGraphicsCaps |= GCAPS_BEZIERS;
    }

    if (IS_WINDINGFILL(pPDev)) {

        pDevInfo->flGraphicsCaps |= GCAPS_WINDINGFILL;
    }

    //
    // We don't process DrvDitherColor (perhaps later?), so set the size of
    // the Dither Brush to 0 to indicate this to the engine. THIS IS IN THE
    // SPEC FOR DrvDitherBrush () function.
    //

    pDevInfo->cxDither = 0;
    pDevInfo->cyDither = 0;

    //
    // the following line is set by PH. According to PH, we need
    // to have 16 colors. We cannot only have 9 colors (for pen plotter).
    //
    //
    // 01-Dec-1993 Wed 01:31:16 updated  -by-  DC
    //  The reason that engine need 16 colors is it optimized by using bit 3
    //  as duplicate bit (used only bit 0/1/2) and bit 3 always mask off, so
    //  that engine can do faster comparsion
    //

    //
    // If its a raster device, tell the engine that we are a 24 bit color
    // device. This way we get the max resolution for bitmaps and brushes
    // and can reducedown as required.
    //

    if (IS_RASTER(pPDev)) {

        pDevInfo->iDitherFormat = BMF_24BPP;

    } else {

        pDevInfo->iDitherFormat = BMF_4BPP;
    }

    if (pPDev->hPalDefault) {

        EngDeletePalette(pPDev->hPalDefault);
        pPDev->hPalDefault = NULL;
    }

    //
    // Create the Pen palette based only on the total number of pens the
    // device can handle.
    //

    if (IS_RASTER(pPDev)) {

        //
        // This is a raster device, we will always make it a 24-bit device so
        // the engine will pass back max color info and we can dither/halftone
        // as we see fit. If we don't do this, the Engine will reduce bitmaps
        // to our color space before passing the bitmaps onto us.
        //

        if (!(pDevInfo->hpalDefault =
                                EngCreatePalette(PAL_BGR, 0, 0, 0, 0, 0))) {

            //
            // The create failed so raise an error
            //

            PLOTERR(("FillDevInfo: EngCreatePalette(PAL_BGR) failed."));
            return(FALSE);
        }

    } else {

        DWORD       DevColor[MAX_PENPLOTTER_PENS + 2];
        PDWORD      pdwCur;
        PPENDATA    pPenData;
        PALENTRY    PalEntry;
        UINT        cPens;

        extern PALENTRY PlotPenPal[];


        PLOTASSERT(1, "Too many pens defined for pen plotter (%ld)",
                      (pPDev->pPlotGPC->Pens.Count <= MAX_PENPLOTTER_PENS),
                      pPDev->pPlotGPC->Pens.Count);

        //
        // Get the start of where to fill colors
        //

        pdwCur = &DevColor[0];

        //
        // 1st Entry is always WHITE
        //

        *pdwCur++ = RGB(255, 255, 255);

        //
        //  Now go into a loop loading up the rest of the colors
        //

        PLOTDBG(DBG_PENPAL, ("Pen Palette #%02ld = 255:255:255", 0));

        for (cPens = 1, pPenData = (PPENDATA)pPDev->pPlotGPC->Pens.pData;
             cPens <= (UINT)pPDev->pPlotGPC->Pens.Count;
             pPenData++) {

            //
            // Place the RGB value into the palette
            //

            PalEntry  = PlotPenPal[pPenData->ColorIdx];
            *pdwCur++ = RGB(PalEntry.R, PalEntry.G, PalEntry.B);

            PLOTDBG(DBG_PENPAL, ("Pen Palette #%02ld = %03ld:%03ld:%03ld",
                        cPens,
                        (LONG)PalEntry.R, (LONG)PalEntry.G, (LONG)PalEntry.B));

            //
            // Track total number of pens defined
            //

            ++cPens;
        }

        //
        // Last Pen is BRIGHT YELLOW WHITE, this is done so that a non-white
        // will map to this pen, in order to effect painting on the device.
        // Otherwise, if a non-white pen, gets mapped to white, nothing
        // would get rendered on the surface.
        //

        *pdwCur++ = RGB(255, 255, 254);
        cPens++;

        PLOTDBG(DBG_PENPAL, ("Pen Palette #%02ld = 255:255:254", cPens - 1));

        //
        // Now create the engine palette
        //

        if (!(pDevInfo->hpalDefault = EngCreatePalette(PAL_INDEXED,
                                                       cPens,
                                                       DevColor,
                                                       0,
                                                       0,
                                                       0))) {
            //
            // The create failed so raise an error
            //

            PLOTERR(("FillDevInfo: EngCreatePalette(PAL_INDEXED=%ld) failed.",
                                                                        cPens));
            return(FALSE);
        }
    }

    //
    // Save the created palette / later we need to destroy it.
    //

    pPDev->hPalDefault = pDevInfo->hpalDefault;

    return(TRUE);
}




BOOL
CommonStartPDEV(
    PDEV        *pPDev,
    DEVMODEW    *pPlotDMIn,
    ULONG       cPatterns,
    HSURF       *phsurfPatterns,
    ULONG       cjDevCaps,
    ULONG       *pDevCaps,
    ULONG       cjDevInfo,
    DEVINFO     *pDevInfo
    )

/*++

Routine Description:

    Function to perform the PDEV initialization.  This is common to
    DrvEnablePDEV and DrvResetPDEV.  The individual functions
    do whatever is required before calling into here.

Arguments:

    pPDev           - the pPDev which we returned in DrvEnablePDEV

    pPlotDMIn       - Pointer to the DEVMODE data structure

    cPatterns       - Count of patterns to be set in phsurfPatterns

    phsurfPatterns  - pointer to the standard pattern HSURF array

    cjDevCaps       - total size of pDevCaps pointed to.

    pDevCaps        - pointer to the device cap DWORDs

    cjDevInfo       - total size of pDevInfo pointed to

    pDevInfo        - pointer to the DEVINFO data structure


Return Value:

    BOOLEAN


Author:

    23-Nov-1993 Tue 20:13:10 created  -by-  DC
        Re-write

    05-Jan-1994 Wed 23:34:18 updated  -by-  DC
        Make PlotXDPI for the Pen Plotter rather than PLOTTER_UNITS_DPI

    06-Jan-1994 Thu 13:10:11 updated  -by-  DC
        Change RasterDPI always be the resoluton reports back to the engine

Revision History:


--*/

{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    DWORD   dmErrBits;


    //
    // Validate the DEVMODE structure passed in by the user, If OK, set the
    // appropriate fields in the PDEV, the validateSetPlotDM() will always
    // return a valid PLOTDEVMODE so we just use it. Any valid DM info will
    // merged into the final DEVMODE
    //

    if (dmErrBits = ValidateSetPLOTDM(pPDev->hPrinter,
                                      pPDev->pPlotGPC,
                                      pPDev->PlotDM.dm.dmDeviceName,
                                      (PPLOTDEVMODE)pPlotDMIn,
                                      &(pPDev->PlotDM),
                                      &(pPDev->CurForm))) {

        PLOTWARN(("CommonStartPDEV: ValidateSetPLOTDM() ErrBits=%08lx",
                                                            dmErrBits));
    }

    //
    // fill in our PDEV structure...
    //
    // The RasterDPI will be used for raster printer resolution, for pen
    // plotters this is the GPC's ideal resolution.
    //

    pPDev->lCurResolution = (LONG)pPDev->pPlotGPC->RasterXDPI;

    PLOTDBG(DBG_GDICAPS, ("CURRENT Resolution = %ld", pPDev->lCurResolution));

    SetPlotForm(&(pPDev->PlotForm),
                pPDev->pPlotGPC,
                &(pPDev->CurPaper),
                &(pPDev->CurForm),
                &(pPDev->PlotDM),
                &(pPDev->PPData));

    //
    // fill in the device capabilities in GDIINFO data structure for the engine
    //

    if ((cjDevCaps) && (pDevCaps)) {

        FillDeviceCaps(pPDev, &GdiInfo);
        CopyMemory(pDevCaps, &GdiInfo, min(cjDevCaps, sizeof(GDIINFO)));
    }

    //
    // Fill in DevInfo data structrue
    //

    if ((cjDevInfo) && (pDevInfo)) {

        if (!FillDevInfo(pPDev, &DevInfo)) {

            return(FALSE);
        }

        CopyMemory(pDevInfo, &DevInfo, min(cjDevInfo, sizeof(DEVINFO)));
    }

    //
    // Set it to NULL so that the engine can create halftone one for us
    //

    if ((cPatterns) && (phsurfPatterns)) {

        ZeroMemory(phsurfPatterns, sizeof(HSURF) * cPatterns);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\htblt.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    htblt.c


Abstract:

    This module contains all halftone bitblt functions.


Author:

    26-Mar-1992 Thu 23:54:07 updated  -by-  DC
        1) add the prclBound parameter to the bDoClipObj()
        2) Remove 'pco' parameter and replaced it with prclClipBound parameter,
           since pco is never referenced, prclClipBound is used for the
           halftone.
        3) Add another parameter to do NOTSRCCOPY

    11-Feb-1993 Thu 21:32:07 updated  -by-  DC
        Major re-write to have DrvStretchBlt(), DrvCopyBits) do the right
        things.

    15-Nov-1993 Mon 19:28:03 updated  -by-  DC
        clean up/debugging information

    06-Dec-1993 Mon 19:28:03 updated  -by-  JB
        Made all bitblt go through HandleComplexBitmap.

    18-Dec-1993 Sat 08:52:56 updated  -by-  DC
        Move halftone related stuff to htblt.c

    18-Mar-1994 Fri 14:00:14 updated  -by-  DC
        Adding PLOTF_RTL_NO_DPI_XY, PLOTF_RTLMONO_NO_CID and
        PLOTF_RTLMONO_FIXPAL flags


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgHTBlt

#define DBG_HTBLT           0x00000001
#define DBG_ISHTBITS        0x00000002
#define DBG_HTXB            0x00000004
#define DBG_OUTHTBMP        0x00000008
#define DBG_HTBLT_SKIP      0x00000010
#define DBG_TILEBLT         0x00000020
#define DBG_CREATESURFOBJ   0x00000040
#define DBG_BMPDELTA        0x00000080
#define DBG_CLONESURFOBJ    0x00000100
#define DBG_CLONEMASK       0x00000200
#define DBG_HTBLT_CLR       0x00000400

DEFINE_DBGVAR(0);


//
// This is the local structure used in this module only
//

#define SEND_PLOTCMDS(pPDev,pcmd)   OutputBytes(pPDev,(pcmd)+1,(LONG)*(pcmd))
#define COPY_PLOTCMDS(cmd,ps,s)     CopyMemory(&cmd[cmd[0]+1],ps,s); cmd[0]+=s
#define INIT_PLOTCMDS(cmd)          cmd[0]=0
#define CHECK_PLOTCMDS(cmd)                                             \
{                                                                       \
    cmd[cmd[0]+1]=0; PLOTASSERT(1,"Command buffer MUST > %ld bytes",    \
    cmd[0]<sizeof(cmd),sizeof(cmd));                                    \
}

#define DELETE_SURFOBJ(pso, phBmp)                                      \
{                                                                       \
    if (pso)      { EngUnlockSurface(pso); pso=NULL;                  } \
    if (*(phBmp)) { EngDeleteSurface((HSURF)*(phBmp)); *(phBmp)=NULL; } \
}


typedef struct _RTLCLRCONFIG {
    BYTE    ColorModel;
    BYTE    EncodingMode;
    BYTE    BitsPerIndex;
    BYTE    BitsPerR;
    BYTE    BitsPerG;
    BYTE    BitsPerB;
    } RTLCLRCONFIG, FAR *PRTLCLRCONFIG;


const POINTL ptlZeroOrigin = {0,0};

static const OUTHTBMPFUNC HTBmpFuncTable[] = { Output1bppHTBmp,
                                               Output1bppRotateHTBmp,
                                               Output4bppHTBmp,
                                               Output4bppRotateHTBmp };



#if DBG
static const LPSTR pszHTBmpFunc[] = { "Output1bppHTBmp",
                                      "Output1bppRotateHTBmp",
                                      "Output4bppHTBmp",
                                      "Output4bppRotateHTBmp" };
#endif

#define DEF_MONOPALIDX_0        0xFFFFFF
#define DEF_MONOPALIDX_1        0x000000
#define DEVTODECI(pPdev, x)     DIVRNDUP((x) * 720, (pPDev)->lCurResolution)
#define MAX_HP_Y_MOVE           32767


static BYTE     StartGraf[]  = "\033*r#ds1A";
static BYTE     EndGraf[]    = "\033*rC";
static BYTE     XMoveDECI[]  = "\033&a0h#dH";
static BYTE     YMoveDECI[]  = "\033*b#dY";
static BYTE     YMoveDPI[]   = "\033*p#pY";
static BYTE     XYMoveDPI[]  = "\033*p#px#pY";
static BYTE     SetRGBCmd[]  = "\033*v#da#db#dc#dI";
static DWORD    DefWKPal[]   = { 0x00FFFFFF, 0x00000000 };


//
// ROP2 used for devices that require  BYTE ALIGNMENT of RTL data
//

#define HPBHF_nD_LAST       0x01
#define HPBHF_nS            0x02
#define HPBHF_1_FIRST       0x40
#define HPBHF_PAD_1         0x80

typedef struct  _HPBAHACK {
    BYTE    Rop3RTL;
    BYTE    Flags;
    } HPBAHACK, *PHPBAHACK;

//
// 0x00: 0          [INV] 0xff: 1
// 0x55: ~D         [INV] 0xaa: D
// 0x33: ~S         [INV] 0xcc: S
// 0x11: ~(D | S)   [INV] 0xee: D | S
// 0x22: D & ~S     [INV] 0xdd: S | ~D
// 0x44: S & ~D     [INV] 0xbb: D | ~S
// 0x66: D ^ S      [INV] 0x99: ~(D ^ S)
// 0x77: ~(D & S)   [INV] 0x88: D & S
//
//
// 1. HPBHF_PAD_1   - TRUE if we are not doing AND operation
// 2. HPBHF_nS      - If we have to manually flip the source
// 3. HPBHF_nD_LAST - If we have to invert the source in HPGL2 afterward
//
//
// Rop2 0x00, 0x05, 0x0A and 0x0F should not come to OutputHTBitmap
//

//
// This table tells us how to simulate certain ROPS by combining rops that
// the target device is known to support. Some times we end up having to
// send the bitmap more than once, but it does end up coming out correctly.
//
static HPBAHACK HPBAHack[] = {

    { 0xAA, 0                                                      }, // 0       0x00
    { 0xEE,                 HPBHF_PAD_1 |            HPBHF_nD_LAST }, // SoD_n   0x01
    { 0x88,                               HPBHF_nS                 }, // nS_aD   0x02
    { 0xEE, HPBHF_1_FIRST | HPBHF_PAD_1 | HPBHF_nS                 }, // nS      0x03
    { 0xEE,                 HPBHF_PAD_1 | HPBHF_nS | HPBHF_nD_LAST }, // nS_oD_n 0x04
    { 0xAA,                                          HPBHF_nD_LAST }, // nD      0x05
    { 0x66,                 HPBHF_PAD_1                            }, // SxD     0x06
    { 0x88,                                          HPBHF_nD_LAST }, // SaD_n   0x07
    { 0x88,                                                        }, // SaD     0x08
    { 0x66,                 HPBHF_PAD_1 |            HPBHF_nD_LAST }, // SxD_n   0x09
    { 0xAA,                 0                                      }, // D       0x0A
    { 0xEE,                 HPBHF_PAD_1 | HPBHF_nS                 }, // nS_oD   0x0B
    { 0xEE, HPBHF_1_FIRST | HPBHF_PAD_1                            }, // S       0x0C
    { 0x88,                               HPBHF_nS | HPBHF_nD_LAST }, // nS_aD_n 0x0D
    { 0xEE,                 HPBHF_PAD_1                            }, // SoD     0x0E
    { 0xAA, 0                                                      }  // 1       0x0F
};


//
// To make it print correctly in poster mode for the BYTE ALIGNED plotters
// we assume paper is white and do a SRC AND DST
//

#define ROP3_BYTEALIGN_POSTER   0x88



extern PALENTRY HTPal[];






BOOL
IsHTCompatibleSurfObj(
    PPDEV       pPDev,
    SURFOBJ     *pso,
    XLATEOBJ    *pxlo,
    DWORD       Flags
    )
/*++

Routine Description:

    This function determines if the surface object is compatible with the
    plotter halftone output format.

Arguments:

    pPDev       - Pointer to the PPDEV data structure to determine what
                  type of postscript output for current device

    pso         - engine SURFOBJ to be examine

    pxlo        - engine XLATEOBJ for source -> postscript translation

    Flags       - specified ISHTF_xxxx

Return Value:

    BOOLEAN true if the pso is compatible with halftone output format, if
    return value is true, the pDrvHTInfo->pHTXB is a valid traslation from
    indices to 3 planes

Author:

    11-Feb-1993 Thu 18:49:55 created  -by-  DC

    16-Mar-1994 Wed 14:24:04 updated  -by-  DC
        Change it so if pxlo is NULL then the xlate will be match the pso
        format


Revision History:


--*/

{
    LPPALETTEENTRY  pPal;
    PDRVHTINFO      pDrvHTInfo;
    PALETTEENTRY    SrcPal[18];
    PPALENTRY       pPalEntry;
    HTXB            PalNibble[HTPAL_XLATE_COUNT];
    ULONG           HTPalXor;
    UINT            i;
    HTXB            htXB;
    BOOL            GenHTXB = FALSE;
    BOOL            RetVal;
    BYTE            PalXlate[HTPAL_XLATE_COUNT];
    UINT            AltFmt;
    UINT            BmpFormat;
    UINT            cPal;


    if (!(pDrvHTInfo = (PDRVHTINFO)(pPDev->pvDrvHTData))) {

        PLOTERR(("IsHTCompatibleSurfObj: pDrvHTInfo = NULL?"));
        return(FALSE);
    }

    PLOTDBG(DBG_ISHTBITS, ("IsHTCompatibleSurfObj: Type=%ld, BMF=%ld",
                                (DWORD)pso->iType, (DWORD)pso->iBitmapFormat));

    //
    // Make sure these fields' value are valid before the translation is
    // created:
    //
    //  1. pso->iBitmapFormat is one of 1BPP or 4BPP depending on current
    //     PLOT's surface
    //  2. pxlo is non null
    //  3. pxlo->fXlate is XO_TABLE
    //  4. pxlo->cPal is less than or equal to the halftone palette count
    //  5. pxlo->pulXlate is valid
    //  6. source color table is within the range of the halftone palette
    //
    //  If your device uses an indexed palette then you must call
    //  XLATEOBJ_cGetPalette() to get the source palette and make sure that the
    //  count returned is within your device's range, if we are a 24-bit device
    //  then you can just get the source palette our from pxlo->pulxlate which
    //  has the entire source palette for the bitmap
    //

    RetVal = FALSE;
    AltFmt = (UINT)((Flags & ISHTF_ALTFMT) ? pDrvHTInfo->AltBmpFormat : 0xFFFF);

    if ((pso->iType == STYPE_BITMAP)                        &&
        (BmpFormat = (UINT)pso->iBitmapFormat)              &&
        ((BmpFormat == (UINT)pDrvHTInfo->HTBmpFormat)   ||
         (BmpFormat == AltFmt))) {

        HTPalXor             = pDrvHTInfo->HTPalXor;
        pDrvHTInfo->HTPalXor = HTPALXOR_SRCCOPY;

        if (pxlo) {

            if (BmpFormat == BMF_4BPP) {

                i = (UINT)((Flags & ISHTF_HTXB) ? 8 : 16);

            } else {

                i = 2;
            }

            cPal = XLATEOBJ_cGetPalette(pxlo,
                                        XO_SRCPALETTE,
                                        sizeof(SrcPal) / sizeof(PALETTEENTRY),
                                        (ULONG *)&SrcPal);

            PLOTDBG(DBG_ISHTBITS, ("pxlo: flXlate=%08lx, SrcType=%ld, DstType=%ld, cPal=%ld",
                    (DWORD)pxlo->flXlate,
                    (DWORD)pxlo->iSrcType,
                    (DWORD)pxlo->iDstType, cPal));

            if ((cPal) && (cPal <= i)) {

                PLOTDBG(DBG_ISHTBITS,
                        ("IsHTCompatibleSurfObj: HTPalXor=%08lx", HTPalXor));

                RetVal = TRUE;

                for (i = 0, pPal = SrcPal; i < cPal; i++, pPal++ ) {

                    HTXB_R(htXB)  = pPal->peRed;
                    HTXB_G(htXB)  = pPal->peGreen;
                    HTXB_B(htXB)  = pPal->peBlue;
                    htXB.dw      ^= HTPalXor;

                    if (((HTXB_R(htXB) != PAL_MAX_I) &&
                         (HTXB_R(htXB) != PAL_MIN_I))   ||
                        ((HTXB_G(htXB) != PAL_MAX_I) &&
                         (HTXB_G(htXB) != PAL_MIN_I))   ||
                        ((HTXB_B(htXB) != PAL_MAX_I) &&
                         (HTXB_B(htXB) != PAL_MIN_I))) {

                        PLOTDBG(DBG_ISHTBITS,
                                ("SrcPal has NON 0xff/0x00 intensity, NOT HTPalette"));
                        return(FALSE);
                    }

                    PalXlate[i]  =
                    HTXB_I(htXB) = (BYTE)((HTXB_R(htXB) & 0x01) |
                                          (HTXB_G(htXB) & 0x02) |
                                          (HTXB_B(htXB) & 0x04));
                    PalNibble[i] = htXB;

                    if (pDrvHTInfo->PalXlate[i] != HTXB_I(htXB)) {

                        GenHTXB = TRUE;
                    }

                    PLOTDBG(DBG_HTXB,
                            ("%d - %02x:%02x:%02x, Idx=%d, PalXlate=%d",
                            i,
                            (BYTE)HTXB_R(htXB),
                            (BYTE)HTXB_G(htXB),
                            (BYTE)HTXB_B(htXB),
                            (INT)PalXlate[i],
                            (INT)pDrvHTInfo->PalXlate[i]));
                }

                if (BmpFormat == (UINT)BMF_1BPP) {

                    //
                    // For 1 BPP, if the DSTPRIM_OK is set and the destination
                    // is 4BPP then we will deem the surfaces compatible
                    //

                    if ((Flags & ISHTF_DSTPRIM_OK)      &&
                        ((pDrvHTInfo->HTBmpFormat == BMF_4BPP)   ||
                         (AltFmt == BMF_4BPP))) {

                        NULL;

                    } else if (((PalXlate[0] != 0) && (PalXlate[0] != 7)) ||
                               ((PalXlate[1] != 0) && (PalXlate[1] != 7))) {

                        RetVal = FALSE;
                        PLOTDBG(DBG_HTXB, ("NON-BLACK/WHITE MONO BITMAP, NOT HTPalette"));
                    }
                }
            }

        } else {

            //
            // If the pxlo is NULL and the FORMAT is the same, we assume an
            // identity translation. Otherwise we fail.
            //

            PLOTDBG(DBG_HTXB, ("pxlo=NULL, Xlate to same as BmpFormat=%ld",
                                                            (DWORD)BmpFormat));

            RetVal = TRUE;

            if (BmpFormat == BMF_4BPP) {

                cPal      = 8;
                pPalEntry = HTPal;

            } else {

                cPal      = 2;
                pPalEntry = (PPALENTRY)SrcPal;

                CopyMemory(pPalEntry + 0, &HTPal[0], sizeof(PALENTRY));
                CopyMemory(pPalEntry + 1, &HTPal[7], sizeof(PALENTRY));
            }

            for (i = 0; i < cPal; i++, pPalEntry++) {

                HTXB_R(htXB)  = pPalEntry->R;
                HTXB_G(htXB)  = pPalEntry->G;
                HTXB_B(htXB)  = pPalEntry->B;
                htXB.dw      ^= HTPalXor;
                PalXlate[i]   =
                HTXB_I(htXB)  = (BYTE)((HTXB_R(htXB) & 0x01) |
                                       (HTXB_G(htXB) & 0x02) |
                                       (HTXB_B(htXB) & 0x04));
                PalNibble[i]  = htXB;

                if (pDrvHTInfo->PalXlate[i] != HTXB_I(htXB)) {

                    GenHTXB = TRUE;
                }
            }
        }

        if (!RetVal) {

            PLOTDBG(DBG_HTXB, ("**** IsHTCompatibleSurfObj = NO ****"));
            return(FALSE);
        }

        if ((Flags & ISHTF_HTXB) && (GenHTXB)) {

            //
            // Copy down the pal xlate
            //

            PLOTDBG(DBG_HTXB, (" --- Copy XLATE TABLE ---"));

            CopyMemory(pDrvHTInfo->PalXlate, PalXlate, sizeof(PalXlate));

            //
            // We only really generate 4bpp to 3 planes if the destination
            // format is BMF_4BPP
            //

            if (BmpFormat == (UINT)BMF_1BPP) {

                pDrvHTInfo->RTLPal[0].Pal = HTPal[PalXlate[0]];
                pDrvHTInfo->RTLPal[1].Pal = HTPal[PalXlate[1]];

                PLOTDBG(DBG_HTXB, ("IsHTCompatibleSurfObj: MONO 1BPP: 0=%02lx:%02lx:%02lx, 1=%02lx:%02lx:%02lx",
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.R,
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.G,
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.B,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.R,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.G,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.B));

            } else if (BmpFormat == (UINT)BMF_4BPP) {

                PHTXB   pTmpHTXB;
                UINT    h;
                UINT    l;
                DWORD   HighNibble;


                PLOTDBG(DBG_HTXB, ("--- Generate 4bpp --> 3 planes xlate ---"));

                if (!(pDrvHTInfo->pHTXB)) {

                    PLOTDBG(DBG_HTXB, ("IsHTCompatibleSurfObj: Allocate pHTXB=%ld",
                                                            HTXB_TABLE_SIZE));

                    if (!(pDrvHTInfo->pHTXB =
                                (PHTXB)LocalAlloc(LPTR, HTXB_TABLE_SIZE))) {

                        PLOTRIP(("IsHTCompatibleSurfObj: LocalAlloc(HTXB_TABLE_SIZE) failed"));
                        return(FALSE);
                    }
                }

                pDrvHTInfo->RTLPal[0].Pal = HTPal[0];
                pDrvHTInfo->RTLPal[1].Pal = HTPal[1];

                PLOTDBG(DBG_HTXB, ("IsHTCompatibleSurfObj: COLOR 4BPP: 0=%02lx:%02lx:%02lx, 1=%02lx:%02lx:%02lx",
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.R,
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.G,
                            (DWORD)pDrvHTInfo->RTLPal[0].Pal.B,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.R,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.G,
                            (DWORD)pDrvHTInfo->RTLPal[1].Pal.B));

                //
                // Generate 4bpp to 3 planes xlate table
                //

                for (h = 0, pTmpHTXB = pDrvHTInfo->pHTXB;
                     h < HTXB_H_NIBBLE_MAX;
                     h++, pTmpHTXB += HTXB_L_NIBBLE_DUP) {

                    HighNibble = (DWORD)(PalNibble[h].dw & 0xaaaaaaaaL);

                    for (l = 0; l < HTXB_L_NIBBLE_MAX; l++, pTmpHTXB++) {

                        pTmpHTXB->dw = (DWORD)((HighNibble) |
                                               (PalNibble[l].dw & 0x55555555L));
                    }

                    //
                    // Duplicate low nibble high order bit, 8 of them
                    //

                    CopyMemory(pTmpHTXB,
                               pTmpHTXB - HTXB_L_NIBBLE_MAX,
                               sizeof(HTXB) * HTXB_L_NIBBLE_DUP);
                }

                //
                // Copy high nibble duplication, 128 of them
                //

                CopyMemory(pTmpHTXB,
                           pDrvHTInfo->pHTXB,
                           sizeof(HTXB) * HTXB_H_NIBBLE_DUP);
            }
        }
    }

    PLOTDBG(DBG_HTXB, ("*** IsHTCompatibleSurfObj = %hs ***", (RetVal) ? "TRUE" : "FALSE"));

    return(RetVal);
}




DWORD
ExitToHPGL2Mode(
    PPDEV   pPDev,
    LPBYTE  pHPGL2ModeCmds,
    LPDWORD pOHTFlags,
    DWORD   OHTFlags
    )

/*++

Routine Description:

    This function will exit to HPGL2 Mode


Arguments:

    pPDev           - Pointer to the PDEV

    pHTGL2ModeCmds  - Pointer to our internal command to switch to HPGL2

    OHTFlags        - Current OHTFlags

Return Value:

    New OHTFlags


Author:

    10-Feb-1994 Thu 12:51:14 created  -by-  DC


Revision History:


--*/

{
    if (OHTFlags & OHTF_IN_RTLMODE) {

        if (OHTFlags & OHTF_SET_TR1) {

            //
            // Send STM command here
            //

            OutputString(pPDev, "\033*v1N");
        }

        SEND_PLOTCMDS(pPDev, pHPGL2ModeCmds);

        OHTFlags &= ~OHTF_IN_RTLMODE;

        PLOTDBG(DBG_HTBLT, ("*** BackTo HPGL/2: %ld=[%hs]",
                                (DWORD)*pHPGL2ModeCmds, pHPGL2ModeCmds + 1));
    }

    //
    // If we need to clear clip window do it now
    //

    if (OHTFlags & OHTF_CLIPWINDOW) {

        ClearClipWindow(pPDev);

        OHTFlags &= ~OHTF_CLIPWINDOW;

        PLOTDBG(DBG_HTBLT, ("OutputHTBitmap: ClearClipWindow"));
    }

    if (OHTFlags & OHTF_SET_TR1) {

        OutputString(pPDev, "TR0;");
    }

    OHTFlags = 0;

    if (pOHTFlags) {

        *pOHTFlags = OHTFlags;
    }

    return(OHTFlags);
}




VOID
MoveRelativeY(
    PPDEV   pPDev,
    LONG    Y
    )

/*++

Routine Description:

    Move relative Y positiion by batch for devices that have y coordinate
    move limitations.

Arguments:

    pPDev   - Pointer to our PDEV

    Y       - Relative amount to move

Return Value:

    VOID


Author:

    13-Apr-1994 Wed 14:38:18 created  -by-  DC


Revision History:


--*/

{
    LPSTR   pMove;
    LONG    SendY;
    BOOL    Negative;


    pMove = (LPSTR)(RTL_NO_DPI_XY(pPDev) ? YMoveDECI : YMoveDPI);

    if (Negative = (Y < 0)) {

        Y = -Y;
    }

    while (Y) {

        if ((SendY = Y) > MAX_HP_Y_MOVE) {

            SendY = MAX_HP_Y_MOVE;
        }

        OutputFormatStr(pPDev, pMove, (Negative) ? -SendY : SendY);

        Y -= SendY;
    }
}





BOOL
OutputHTBitmap(
    PPDEV   pPDev,
    SURFOBJ *psoHT,
    CLIPOBJ *pco,
    PPOINTL pptlDest,
    PRECTL  prclSrc,
    DWORD   Rop3,
    LPDWORD pOHTFlags
    )
/*++

Routine Description:

    This function will handle complex type of region bitmaps

Arguments:

    pPDev       - Pointer to the PDEV

    psoHI       - the surface object of the halftone bitmap to be output

    pco         - a clip object associated with psoHT

    pptlDest    - pointer to the starting destination point

    prclSrc     - pointer to the source bitmap rectangle area to be copied
                  to the destination, if this is NULL then a whole psoHT will
                  be copied to the destination

    Rop3        - a Rop3 to send for the source

    pOHTFlags   - Pointer to the DWORD containing the current OHTF_xxxx, if this
                  pointer is NULL then this function will enter RTL mode first
                  and exit to HPGL2 mode when it returns,  if this pointer is
                  specified then the pOHTFlags will be used and at return the
                  current OHTFlags will be written to the location pointed to
                  by pOHTFlags




Return Value:

    TRUE if sucessful, FALSE if failure


Author:

    04-Nov-1993 Thu 15:30:13 updated  -by-  JB

    24-Dec-1993 Fri 05:21:57 updated  -by-  DC
        Total re-write so that take all the bitmap orientations and enum
        rects works correctly. this is the major bitmap function entry point
        it will call appropriate bitmap function to redner the final output.

        The other things is we need to check if switch between HPGL/2 and RTL
        can be more efficient.   Make sure we can eaiser to adapate to rotate
        the bitmap to the left if necessary.

        Correct LogExt.cx useage, we must do SPLTOENGUNITS first

    29-Dec-1993 Wed 10:59:41 updated  -by-  DC
        Change bMore=CLIPOBJ_bEnum sequence,
        Change PLOTDBGBLK() macro by adding automatical semi in macro

    13-Jan-1994 Thu 14:09:51 updated  -by-  DC
        add prclSrc

    14-Jan-1994 Fri 21:03:26 updated  -by-  DC
        add Rop3


    16-Jan-1994 Thu 14:09:51 updated  -by-  JB
        Change OutputHTBitmap to take Rop4 to send to plotter.

    08-Feb-1994 Tue 15:54:24 updated  -by-  DC
        Make sure we do nothing if source is not visible

    21-Mar-1994 Mon 14:20:18 updated  -by-  DC
        Allocate extra 2 bytes for the scan/rot buffer in case if we must do
        byte aligned.  And if we need to do byte aligned thing then always
        move the HCAPS to the byte boundary first

    13-Apr-1994 Wed 14:59:56 updated  -by-  DC
        1. Batch the Relative Y move to have 32767 limitation problem solved.
        2. GrayScale/gamma correct the input BITMAP color

    20-Aug-1994 Sat 21:37:37 updated  -by-  DC
        Add the bitmap offset location from the FORM imageable area, otherwise
        our bitmap will have different offset then the HPGL/2 drawing commands

Revision History:

    22-Oct-1999 Fri 12:17:21 updated  -by-  Daniel Chou (danielc)
        Return FALSE right away if a job canceled, since this function can
        take very long time to finished.


--*/

{
#define pDrvHTInfo  ((PDRVHTINFO)pPDev->pvDrvHTData)


    PRECTL          prcl;
    OUTHTBMPFUNC    HTBmpFunc;
    HTBMPINFO       HTBmpInfo;
    HTENUMRCL       HTEnumRCL;
    RTLCLRCONFIG    RTLClrConfig;
    RECTL           rclSrc;
    RECTL           rclDest;
    POINTL          CursorPos;
    POINTL          BmpOffset;
    SIZEL           Size;
    HPBAHACK        CurHPBAHack;
    LONG            cxLogExt;
    LONG            TempY;
    DWORD           OHTFlags;
    DWORD           PlotFlags;
    BOOL            More;
    BOOL            RetVal;
    BOOL            BmpRotate;
    BOOL            FirstEnumRCL = TRUE;
    UINT            i;
    BYTE            HPGL2ModeCmds[16];
    BYTE            RTLModeCmds[32];



    if (PLOT_CANCEL_JOB(pPDev)) {

        return(FALSE);
    }

    PlotFlags = GET_PLOTFLAGS(pPDev);
    OHTFlags  = (DWORD)((pOHTFlags) ? (*pOHTFlags & OHTF_MASK) : 0);

    //
    // Set up exit HPGL/2 and enter RTL mode commands
    //

    INIT_PLOTCMDS(HPGL2ModeCmds);

    if (PF_PUSHPAL(PlotFlags)) {

        COPY_PLOTCMDS(HPGL2ModeCmds, "\033*p1P", 5);
    }

    COPY_PLOTCMDS(HPGL2ModeCmds, "\033%0B", 4);
    CHECK_PLOTCMDS(HPGL2ModeCmds);

    if (OHTFlags & OHTF_EXIT_TO_HPGL2) {

        PLOTDBG(DBG_HTBLT, ("OutputHTBitmap: Force Exit to HPGL2 Mode"));

        ExitToHPGL2Mode(pPDev, HPGL2ModeCmds, pOHTFlags, OHTFlags);
        return(TRUE);
    }

    //
    // Make sure the caller is right about this,
    // so check to see which formats we can handle.
    //

    PLOTASSERT(1, "OutputHTBitmap: Invalid Bitmap Format %ld passed",
                (psoHT->iBitmapFormat ==
                            pDrvHTInfo->HTBmpFormat) ||
                (psoHT->iBitmapFormat ==
                            pDrvHTInfo->AltBmpFormat),
                psoHT->iBitmapFormat);

    //
    // First set some basic information in HTBmpInfo
    //

    HTBmpInfo.pPDev = pPDev;
    HTBmpInfo.Flags = 0;
    HTBmpInfo.Delta = psoHT->lDelta;

    //
    // We will set color format for the HPGL/2 Plotter to the same one as
    // the bitmap format passed, this will allow us to use the 1bpp output
    // function for the 4bpp surfaces
    //

    RTLClrConfig.ColorModel   = 0;
    RTLClrConfig.EncodingMode = 0;

    //
    // cxLogExt = the output bitmap function index number
    // Size.cx  = Count of mono scan lines needed for each pixel line, and
    //            final count of scan buffer needed
    // Size.cy  = count of rotation buffer needed (Must be DWORD aligned)
    //

    if (psoHT->iBitmapFormat == BMF_1BPP) {

        cxLogExt                  = 0;
        Size.cx                   = 1;
        RTLClrConfig.BitsPerIndex = 1;

    } else {

        //
        // 4 bits per pel, 3 planes that is
        //

        cxLogExt                  = 2;
        Size.cx                   = 3;
        RTLClrConfig.BitsPerIndex = 3;
    }

    RTLClrConfig.BitsPerR =
    RTLClrConfig.BitsPerG =
    RTLClrConfig.BitsPerB = 8;

    //
    // We have almost everything setup, now check how to send to the output
    // bitmap function, get the full destination size first
    //
    //
    //************************************************************************
    // The Following RTL switching, config color command and other related
    // commands MUST be sent in this order
    //************************************************************************"

    //
    // 1: Initialize the enter RTL command buffer
    //

    INIT_PLOTCMDS(RTLModeCmds);

    //
    // 2. commands to go into RTL mode, and back to HPGL/2 mode, the mode
    //    switching assumes that the current positions are retained.
    //

    COPY_PLOTCMDS(RTLModeCmds, "\033%0A", 4);

    //
    // 3. Push/Pop the HPGL/2 palette commands if this is required (PCD file)
    //

    if (PF_PUSHPAL(PlotFlags)) {

        COPY_PLOTCMDS(RTLModeCmds, "\033*p0P", 5);
    }

    //
    // 4. Color configuration commands and exit back to HPGL/2 command
    //

    if ((RTLClrConfig.BitsPerIndex != 1) ||
        (!PF_RTLMONO_NO_CID(PlotFlags))) {

        //
        // We only do this if we are COLOR or if we must send CID when mono
        // device
        //

        COPY_PLOTCMDS(RTLModeCmds, "\033*v6W", 5);
        COPY_PLOTCMDS(RTLModeCmds, &RTLClrConfig, 6);
    }


    CHECK_PLOTCMDS(RTLModeCmds);

    //
    // Now Check the source
    //

    rclSrc.left   =
    rclSrc.top    = 0;
    rclSrc.right  = psoHT->sizlBitmap.cx;
    rclSrc.bottom = psoHT->sizlBitmap.cy;

    if (prclSrc) {

        PLOTASSERT(1, "OutputHTBitmap: Invalid prclSrc [%08lx] passed",
                ((prclSrc->left   >= 0)                         &&
                 (prclSrc->top    >= 0)                         &&
                 (prclSrc->right  <= psoHT->sizlBitmap.cx)      &&
                 (prclSrc->bottom <= psoHT->sizlBitmap.cy)      &&
                 (prclSrc->left   <= prclSrc->right)            &&
                 (prclSrc->top    <= prclSrc->bottom)), prclSrc);

        if (!IntersectRECTL(&rclSrc, prclSrc)) {

            PLOTWARN(("OutputHTBitmap: EMPTY SRC Passed, Done!"));
            ExitToHPGL2Mode(pPDev, HPGL2ModeCmds, pOHTFlags, OHTFlags);
            return(TRUE);
        }
    }

    if (BmpRotate = (pPDev->PlotForm.BmpRotMode != BMP_ROT_NONE)) {

        //
        // We must allocate rotation buffer and it must be DWORD aligned.
        //

        Size.cx *= ((psoHT->sizlBitmap.cy + 23) >> 3);

        if (psoHT->iBitmapFormat == BMF_1BPP) {

            //
            // We also have to take into acount the fact that pixels can start
            // anywhere in the first byte, causing us to allocate and extra byte
            // for the shift.
            //


            Size.cy = (LONG)((psoHT->sizlBitmap.cy + 23) >> 3);
            Size.cy = (LONG)(DW_ALIGN(Size.cy) << 3);

        } else {

            Size.cy = (LONG)((psoHT->sizlBitmap.cy + 3) >> 1);
            Size.cy = (LONG)(DW_ALIGN(Size.cy) << 1);
        }

        ++cxLogExt;

    } else {

        //
        // For a non-rotated 4BPP bitmap, we need an extra buffer to
        // ensure the final 4bpp bitmap is DWORD aligned. This will speed up
        // the 4bpp to 3 plane translation.
        //

        Size.cy  = (LONG)((psoHT->sizlBitmap.cx + 23) >> 3);
        Size.cx *= Size.cy;

        if (psoHT->iBitmapFormat == BMF_4BPP) {

            //
            // Make sure the we allocate a rotation buffer for alignment
            // purposes
            //

            Size.cy = (LONG)((psoHT->sizlBitmap.cx + 3) << 1);
            Size.cy = (LONG)DW_ALIGN(Size.cy);

        } else {

            //
            // BMF_1BPP will be left/right shifted on a per byte basis on
            // the fly.
            //

            Size.cy = 0;
        }
    }

    HTBmpFunc = HTBmpFuncTable[cxLogExt];

    //
    // Make sure the first buffer is DWORD aligned, otherwise the next
    // buffer (pRotBuf) will not start on a DWORD boundary.
    //

    Size.cx = DW_ALIGN(Size.cx);

    PLOTDBGBLK(HTBmpInfo.cScanBuf = Size.cx;
               HTBmpInfo.cRotBuf  = Size.cy)

    PLOTDBG(DBG_OUTHTBMP, ("OutputHTBitmap: [%hs] - ScanBuf=%ld, RotBuf=%ld",
                            pszHTBmpFunc[cxLogExt], Size.cx, Size.cy));

    //
    // Allocate scan buffer and rotation temp buffer if needed
    //

    if (!(HTBmpInfo.pScanBuf = (LPBYTE)LocalAlloc(LPTR, Size.cx + Size.cy))) {

        PLOTERR(("OutputHTBmp: LocalAlloc(%ld) Failed, cx=%ld, cy=%ld",
                Size.cx + Size.cy, Size.cx, Size.cy));

        ExitToHPGL2Mode(pPDev, HPGL2ModeCmds, pOHTFlags, OHTFlags);
        return(FALSE);
    }

    HTBmpInfo.pRotBuf = (Size.cy) ? (HTBmpInfo.pScanBuf + Size.cx) : NULL;

    //
    // Set up local variables for the command mode and other one time variables
    //

    cxLogExt = SPLTOENGUNITS(pPDev, pPDev->PlotForm.LogExt.cx);

    //
    // Now set up the rclDest for the bitmap we will output to. And set More to
    // false, which means one RECT.
    //

    rclDest.left   = pptlDest->x;
    rclDest.top    = pptlDest->y;
    rclDest.right  = rclDest.left + (rclSrc.right - rclSrc.left);
    rclDest.bottom = rclDest.top  + (rclSrc.bottom - rclSrc.top);


    //
    // The following variables are essential for the default assumptions.
    //
    //  1. RetVal       = TRUE if no clip rect we return OK
    //  2. More         = FALSE default as current HTEnumRCL.c and rectl
    //                    without calling CLIPOBJ_bEnum()
    //  3. HTEnumRCL.c  = 1 to have only one default HTEnumRCL.rcl
    //

    RetVal         = TRUE;
    More           = FALSE;
    HTEnumRCL.c    = 1;

    if ((!pco) || (pco->iDComplexity == DC_TRIVIAL)) {

        //
        // The whole output destination rectangle is visible
        //

        PLOTDBG(DBG_OUTHTBMP, ("OutputHTBitmap: pco=%hs",
                                            (pco) ? "DC_TRIVIAL" : "NULL"));

        HTEnumRCL.rcl[0] = rclDest;

    } else if (pco->iDComplexity == DC_RECT) {

        //
        // The visible area is one rectangle so intersect with the destination
        //

        PLOTDBG(DBG_OUTHTBMP, ("OutputHTBitmap: pco=DC_RECT"));

        HTEnumRCL.rcl[0] = pco->rclBounds;

    } else {

        //
        // We have a complex clipping region to be computed, call engine to start
        // enumerating the rectangles and set More = TRUE so we can get the first
        // batch of rectangles.
        //

        PLOTDBG(DBG_OUTHTBMP, ("OutputHTBitmap: pco=DC_COMPLEX, EnumRects now"));

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        More = TRUE;
    }

    Rop3 &= 0xFF;

    PLOTASSERT(1, "OutputHTBitmap: The Rop required PATTERN? [%04lx]",
                        !ROP3_NEED_PAT(Rop3), Rop3);

    if (PF_BYTEALIGN(PlotFlags)) {

        if (pPDev->PlotDM.Flags & PDMF_PLOT_ON_THE_FLY) {

            PLOTWARN(("OutputHTBitmap: ByteAlign/Poster Mode Rop3 0x%02lx -> 0x%02lx",
                        Rop3, ROP3_BYTEALIGN_POSTER));
            Rop3 = ROP3_BYTEALIGN_POSTER;
        }

        OHTFlags    &= ~OHTF_SET_TR1;
        CurHPBAHack  = HPBAHack[Rop3 & 0x0F];

        if (CurHPBAHack.Flags & HPBHF_nS) {

            HTBmpInfo.Flags |= HTBIF_FLIP_MONOBITS;
        }

        if (CurHPBAHack.Flags & HPBHF_PAD_1) {

            HTBmpInfo.Flags |= HTBIF_BA_PAD_1;
        }

        PLOTDBG(DBG_HTBLT, ("OutpputHTBitmap: BA HACK: Rop3=%02lx -> %02lx, Flags=%04lx",
                        (DWORD)Rop3,
                        (DWORD)CurHPBAHack.Rop3RTL,
                        (DWORD)CurHPBAHack.Flags));

    } else {

        CurHPBAHack.Rop3RTL   = (BYTE)Rop3;
        CurHPBAHack.Flags     = 0;
    }

    //
    // To have correct image area located for the bitmap, we must offset all
    // bitmaps with these amounts
    //

    BmpOffset.x = SPLTOENGUNITS(pPDev, pPDev->PlotForm.BmpOffset.x);
    BmpOffset.y = SPLTOENGUNITS(pPDev, pPDev->PlotForm.BmpOffset.y);

    //
    // We have 'More' and HTEnumRCL structure set, now go through each clipping
    // rectangle and call the halftone output fucntion to do the real work
    //

    do {

        //
        // If More is true then we need to get the next batch of rectangles.
        //

        if (More) {

            More = CLIPOBJ_bEnum(pco, sizeof(HTEnumRCL), (ULONG *)&HTEnumRCL);
        }

        //
        // prcl will point to the first enumerated rectangle.
        //

        prcl = (PRECTL)&HTEnumRCL.rcl[0];

        while (HTEnumRCL.c--) {

            if (PLOT_CANCEL_JOB(pPDev)) {

                RetVal =
                More   = FALSE;
                break;
            }

            //
            // Only do this rectangle area if it is visible
            //

            HTBmpInfo.rclBmp = *prcl;

            if (IntersectRECTL(&(HTBmpInfo.rclBmp), &rclDest)) {

                //
                // For the very first time, we want to switch to PP1
                //

                if (FirstEnumRCL) {

                    SetPixelPlacement(pPDev, SPP_MODE_EDGE);
                    FirstEnumRCL = FALSE;
                }

                //
                // Now compute useable information to be passed to the output
                // halftoned bitmap function
                //

                HTBmpInfo.OffBmp.x  = rclSrc.left +
                                      (HTBmpInfo.rclBmp.left - rclDest.left);
                HTBmpInfo.OffBmp.y  = rclSrc.top +
                                      (HTBmpInfo.rclBmp.top - rclDest.top);
                HTBmpInfo.szlBmp.cx = HTBmpInfo.rclBmp.right -
                                      HTBmpInfo.rclBmp.left;
                HTBmpInfo.szlBmp.cy = HTBmpInfo.rclBmp.bottom -
                                      HTBmpInfo.rclBmp.top;
                HTBmpInfo.pScan0    = (LPBYTE)psoHT->pvScan0 +
                                      (HTBmpInfo.OffBmp.y * HTBmpInfo.Delta);

                PLOTDBG(DBG_HTBLT, ("OutputHTBitmap: rclBmp=(%ld, %ld)-(%ld, %ld) [%ld x %ld] Off=(%ld, %ld)",
                            HTBmpInfo.rclBmp.left, HTBmpInfo.rclBmp.top,
                            HTBmpInfo.rclBmp.right, HTBmpInfo.rclBmp.bottom,
                            HTBmpInfo.szlBmp.cx, HTBmpInfo.szlBmp.cy,
                            HTBmpInfo.OffBmp.x, HTBmpInfo.OffBmp.y));

                //
                // Now set the correct cursor position based on the rotation
                //

                if (BmpRotate) {

                    Size.cx     = HTBmpInfo.szlBmp.cy;
                    Size.cy     = HTBmpInfo.szlBmp.cx;
                    CursorPos.x = HTBmpInfo.rclBmp.top;
                    CursorPos.y = cxLogExt - HTBmpInfo.rclBmp.right;

                } else {

                    Size        = HTBmpInfo.szlBmp;
                    CursorPos.x = HTBmpInfo.rclBmp.left;
                    CursorPos.y = HTBmpInfo.rclBmp.top;
                }

                //
                // Add in the bitmap offset location from the imageable area
                //

                CursorPos.x += BmpOffset.x;
                CursorPos.y += BmpOffset.y;

                //
                // If we need to BYTE align, then make the X cursor position
                // byte aligned first
                //

                if (PF_BYTEALIGN(PlotFlags)) {

                    if (i = (UINT)(CursorPos.x & 0x07)) {

                        //
                        // We really need to byte aligne x and we also have to
                        // increase the source width to accomodate the changes
                        //

                        PLOTDBG(DBG_HTBLT,
                                ("OutputHTBitmap: NEED BYTE ALIGN X: %ld -> %ld, SRC WIDTH: %ld -> %ld",
                                    CursorPos.x, CursorPos.x - i,
                                    Size.cx, Size.cx + i));

                        Size.cx     += i;
                        CursorPos.x -= i;
                    }

                    Size.cx = (LONG)((Size.cx + 7) & ~(DWORD)7);
                }

                PLOTDBG(DBG_HTBLT,
                        ("OutputHTBitmap: ABS CAP: (%ld, %ld) --> (%ld, %ld), RELATIVE=(%ld, %ld)",
                                pPDev->ptlRTLCAP.x, pPDev->ptlRTLCAP.y,
                                CursorPos.x, CursorPos.y,
                                CursorPos.x - pPDev->ptlRTLCAP.x,
                                CursorPos.y - pPDev->ptlRTLCAP.y));

                if (!(OHTFlags & OHTF_DONE_ROPTR1)) {

                    if (OHTFlags & OHTF_IN_RTLMODE) {

                        SEND_PLOTCMDS(pPDev, HPGL2ModeCmds);

                        OHTFlags &= ~OHTF_IN_RTLMODE;

                        PLOTDBG(DBG_HTBLT, ("*** Enter HPGL/2: %ld=[%hs]",
                                    (DWORD)HPGL2ModeCmds[0], &HPGL2ModeCmds[1]));
                    }

                    SetRopMode(pPDev,
                               (CurHPBAHack.Flags & HPBHF_1_FIRST) ?
                                    0x88 : CurHPBAHack.Rop3RTL);

                    if (OHTFlags & OHTF_SET_TR1) {

                        OutputString(pPDev, "TR1;");
                    }
                }

                //
                // Entering RTL mode if not already so
                //

                if (!(OHTFlags & OHTF_IN_RTLMODE)) {

                    PLOTDBG(DBG_HTBLT, ("*** Enter RTL: %ld=[%hs]",
                                    (DWORD)RTLModeCmds[0], &RTLModeCmds[1]));

                    SEND_PLOTCMDS(pPDev, RTLModeCmds);

                    if (OHTFlags & OHTF_SET_TR1) {

                        //
                        // Send STM command here
                        //

                        OutputString(pPDev, "\033*v0N");
                    }

                    if (CurHPBAHack.Flags & HPBHF_nS) {

                        HTBmpInfo.Flags |= HTBIF_FLIP_MONOBITS;

                    } else {

                        HTBmpInfo.Flags &= ~HTBIF_FLIP_MONOBITS;
                    }

                    //
                    // If bitmap is monochrome then make sure we set the
                    // palette correctly only if we can set it
                    //

                    if ((RTLClrConfig.BitsPerIndex == 1) &&
                        (!(OHTFlags & OHTF_DONE_ROPTR1))) {

                        PALDW   RTLPal;
                        BOOL    FlipMono = FALSE;

                        for (i = 0; i < 2; i++) {

                            RTLPal.dw = pDrvHTInfo->RTLPal[i].dw;

                            //
                            // Convert the color through gamma/gray scale
                            //

                            GetFinalColor(pPDev, &(RTLPal.Pal));

                            if (RTLPal.dw != DefWKPal[i]) {

                                if (PF_RTLMONO_FIXPAL(PlotFlags)) {

                                    FlipMono = TRUE;

                                } else {

                                    OutputFormatStr(pPDev,
                                                    SetRGBCmd,
                                                    (DWORD)RTLPal.Pal.R,
                                                    (DWORD)RTLPal.Pal.G,
                                                    (DWORD)RTLPal.Pal.B,
                                                    i);

                                    PLOTDBG(DBG_HTBLT_CLR,
                                            ("OutputHTBitmap: Change RTLPal[%ld]=%02lx:%02lx:%02lx",
                                                    (DWORD)i,
                                                    (DWORD)RTLPal.Pal.R,
                                                    (DWORD)RTLPal.Pal.G,
                                                    (DWORD)RTLPal.Pal.B));
                                }
                            }
                        }

                        if (FlipMono) {

                            HTBmpInfo.Flags ^= HTBIF_FLIP_MONOBITS;

                            PLOTDBG(DBG_HTBLT_CLR, ("OutputHTBitmap: Flip MONO Bits"));
                        }
                    }
                }

                OHTFlags |= (OHTF_IN_RTLMODE | OHTF_DONE_ROPTR1);

                TempY = CursorPos.y - pPDev->ptlRTLCAP.y;

                if (PF_RTL_NO_DPI_XY(PlotFlags)) {


                    //
                    // We will move X in absolute movements (not relative)
                    // by always outputing position 0 to flush out the device
                    // X CAP then move absolute to final X position. We will
                    // us relative movement for the Y coordinate.
                    //

                    OutputFormatStr(pPDev,
                                    XMoveDECI,
                                    DEVTODECI(pPDev, CursorPos.x));

                } else {

                    if ((TempY <= MAX_HP_Y_MOVE) &&
                        (TempY >= -MAX_HP_Y_MOVE)) {

                        OutputFormatStr(pPDev,
                                        XYMoveDPI,
                                        CursorPos.x - pPDev->ptlRTLCAP.x,
                                        TempY);
                        TempY = 0;

                    } else {

                        OutputFormatStr(pPDev,
                                        XYMoveDPI,
                                        CursorPos.x - pPDev->ptlRTLCAP.x,
                                        0);
                    }
                }

                MoveRelativeY(pPDev, TempY);

                //
                // Update new cursor position after the RTL commands, the
                // CursorPos and pPDev->ptlRTLCAPS always are ABSOLUTE
                // coordinates but we will send the RTL RELATIVE
                // command to position the bitmap.
                //

                pPDev->ptlRTLCAP.x = CursorPos.x;
                pPDev->ptlRTLCAP.y = CursorPos.y + Size.cy;

                //
                // Output Start Graphic commands
                //


                OutputFormatStr(pPDev, StartGraf, Size.cx);

                //
                // Fill One first if we are simulating rops the device can't
                // handle
                //

                if (CurHPBAHack.Flags & HPBHF_1_FIRST) {

                    FillRect1bppBmp(&HTBmpInfo, 0xFF, FALSE, BmpRotate);

                    OutputBytes(HTBmpInfo.pPDev, EndGraf, sizeof(EndGraf));

                    if (CurHPBAHack.Rop3RTL != 0xAA) {

                        SEND_PLOTCMDS(pPDev, HPGL2ModeCmds);
                        SetRopMode(pPDev, CurHPBAHack.Rop3RTL);
                        SEND_PLOTCMDS(pPDev, RTLModeCmds);

                        MoveRelativeY(pPDev, -Size.cy);
                        OutputFormatStr(pPDev, StartGraf, Size.cx);
                    }
                }

                //
                // Now call the functions to really output the bitmap
                //

                if (CurHPBAHack.Rop3RTL != 0xAA) {

                    if (RetVal = HTBmpFunc(&HTBmpInfo)) {

                        //
                        // If output is ok then send End Graphic command now
                        //

                        OutputBytes(HTBmpInfo.pPDev, EndGraf, sizeof(EndGraf));

                    } else {

                        PLOTERR(("OutputHTBitmap: HTBmpFunc = FALSE (failed)"));

                        More = FALSE;
                        break;
                    }
                }

                if (CurHPBAHack.Flags & HPBHF_nD_LAST) {

                    SEND_PLOTCMDS(pPDev, HPGL2ModeCmds);
                    SetRopMode(pPDev, 0x66);
                    SEND_PLOTCMDS(pPDev, RTLModeCmds);

                    if ((CurHPBAHack.Flags & HPBHF_1_FIRST) ||
                        (CurHPBAHack.Rop3RTL != 0xAA)) {

                        MoveRelativeY(pPDev, -Size.cy);
                        OutputFormatStr(pPDev, StartGraf, Size.cx);

                        OHTFlags |= OHTF_IN_RTLMODE;
                    }

                    FillRect1bppBmp(&HTBmpInfo, 0x00, TRUE, BmpRotate);
                    OutputBytes(HTBmpInfo.pPDev, EndGraf, sizeof(EndGraf));

                }

                if (PF_BYTEALIGN(PlotFlags)) {

                    OHTFlags &= ~OHTF_DONE_ROPTR1;
                }

            } else {

                PLOTDBG(DBG_HTBLT_SKIP, ("OutputHTBitmap: INVISIBLE rcl=(%ld, %ld)-(%ld, %ld)",
                            prcl->left, prcl->top, prcl->right, prcl->bottom));
            }

            prcl++;
        }

    } while (More);

    //
    // Finally return to HPGL/2 mode
    //

    if ((!RetVal) || (!pOHTFlags)) {

        ExitToHPGL2Mode(pPDev, HPGL2ModeCmds, pOHTFlags, OHTFlags);

    }

    if (pOHTFlags) {

        *pOHTFlags = OHTFlags;
    }

    //
    // Get rid of any resources we allocated
    //

    LocalFree((HLOCAL)HTBmpInfo.pScanBuf);

    return(RetVal);


#undef pDrvHTInfo
}




LONG
GetBmpDelta(
    DWORD   SurfaceFormat,
    DWORD   cx
    )

/*++

Routine Description:


    This function calculates the total bytes needed in order to advance a
    scan line based on the bitmap format and alignment.

Arguments:

    SurfaceFormat   - Surface format of the bitmap, this must be one of the
                      standard formats which are defined as BMF_xxx

    cx              - Total Pels per scan line in the bitmap.

Return Value:

    The return value is the total bytes in one scan line if it is greater than
    zero


Author:

    19-Jan-1994 Wed 16:19:39 created  -by-  DC


Revision History:



--*/

{
    DWORD   Delta = cx;

    switch (SurfaceFormat) {

    case BMF_32BPP:

        Delta <<= 5;
        break;

    case BMF_24BPP:

        Delta *= 24;
        break;

    case BMF_16BPP:

        Delta <<= 4;
        break;

    case BMF_8BPP:

        Delta <<= 3;
        break;

    case BMF_4BPP:

        Delta <<= 2;
        break;

    case BMF_1BPP:

        break;

    default:

        PLOTERR(("GetBmpDelta: Invalid BMF_xxx format = %ld", SurfaceFormat));
        break;
    }

    Delta = (DWORD)DW_ALIGN((Delta + 7) >> 3);

    PLOTDBG(DBG_BMPDELTA, ("Format=%ld, cx=%ld, Delta=%ld",
                                            SurfaceFormat, cx, Delta));

    return((LONG)Delta);
}




SURFOBJ *
CreateBitmapSURFOBJ(
    PPDEV   pPDev,
    HBITMAP *phBmp,
    LONG    cxSize,
    LONG    cySize,
    DWORD   Format,
    LPVOID  pvBits
    )

/*++

Routine Description:

    This function creates a bitmap and locks the bitmap to return a SURFOBJ

Arguments:

    pPDev   - Pointer to our PDEV

    phBmp   - Pointer the HBITMAP location to be returned for the bitmap

    cxSize  - CX size of bitmap to be created

    cySize  - CY size of bitmap to be created

    Format  - one of BMF_xxx bitmap format to be created

    pvBits  - the buffer to be used

Return Value:

    SURFOBJ if sucessful, NULL if failed


Author:

    19-Jan-1994 Wed 16:31:50 created  -by-  DC


Revision History:


--*/

{
    SURFOBJ *pso = NULL;
    SIZEL   szlBmp;


    szlBmp.cx = cxSize;
    szlBmp.cy = cySize;

    PLOTDBG(DBG_CREATESURFOBJ, ("CreateBitmapSURFOBJ: Format=%ld, Size=%ld x %ld",
                                                Format, cxSize, cySize));

    if (*phBmp = EngCreateBitmap(szlBmp,
                                 GetBmpDelta(Format, cxSize),
                                 Format,
                                 BMF_TOPDOWN | BMF_NOZEROINIT,
                                 pvBits)) {

        if (EngAssociateSurface((HSURF)*phBmp, (HDEV)pPDev->hpdev, 0)) {

            if (pso = EngLockSurface((HSURF)*phBmp)) {

                //
                // Sucessful lock down, return it
                //

                return(pso);

            } else {

                PLOTERR(("CreateBmpSurfObj: EngLockSruface(hBmp) failed!"));
            }

        } else {

            PLOTERR(("CreateBmpSurfObj: EngAssociateSurface() failed!"));
        }

    } else {

        PLOTERR(("CreateBMPSurfObj: FAILED to create Bitmap Format=%ld, %ld x %ld",
                                        Format, cxSize, cySize));
    }

    DELETE_SURFOBJ(pso, phBmp);

    return(NULL);
}





BOOL
PatBmpTileBlt(
    SURFOBJ *psoDst,
    SURFOBJ *psoPat,
    PRECTL  prclPat,
    PPOINTL pptlPatOrg
    )

/*++

Routine Description:

    This funtion tiles the source RECTL area over the destination RECTL area.
    The source/destination must be in the same format, and the color translation
    must be an Identity.

Arguments:

    psoDst      - destination surfobj

    psoPat      - source surfobj must be BITMAP

    pptlPatOrg  - The starting origin for the source


Return Value:

    BOOL to indicate operation status


Author:

    19-Jan-1994 Wed 15:44:57 created  -by-  DC


Revision History:


--*/

{
    SIZEL   szlPat;
    RECTL   rclPat;
    RECTL   rclDst;
    RECTL   rclCur;


    PLOTASSERT(1, "TileBlt: psoPat type [%ld] is not a bitmap",
                        psoPat->iType == STYPE_BITMAP, (LONG)psoPat->iType);
    PLOTASSERT(1, "TileBlt: psoDst type [%ld] is not a bitmap",
                        psoDst->iType == STYPE_BITMAP, (LONG)psoDst->iType);
    PLOTASSERT(1, "TileBit: Bitmap Format for psoPat != psoDst [%ld]",
                        psoDst->iBitmapFormat == psoPat->iBitmapFormat,
                        psoDst->iBitmapFormat);

    //
    // Validate and clip the source
    //

    rclPat.left   =
    rclPat.top    = 0;
    rclPat.right  = psoPat->sizlBitmap.cx;
    rclPat.bottom = psoPat->sizlBitmap.cy;

    if (prclPat) {

        if (!IntersectRECTL(&rclPat, prclPat)) {

            PLOTDBG(DBG_TILEBLT, ("PatBmpTileBlt: Pattern rectangle is empty"));
            return(TRUE);
        }
    }

    szlPat.cx = rclPat.right - rclPat.left;
    szlPat.cy = rclPat.bottom - rclPat.top;

    //
    // Validate and clip the destination
    //

    rclDst.right  = psoDst->sizlBitmap.cx;
    rclDst.bottom = psoDst->sizlBitmap.cy;

    if (pptlPatOrg) {

        rclDst.left = -(pptlPatOrg->x % szlPat.cx);
        rclDst.top  = -(pptlPatOrg->y % szlPat.cy);

    } else {

        rclDst.left =
        rclDst.top  = 0;
    }

    //
    // Start to tile it, rclCur is the current RECTL on the destination
    //

    rclCur.top    =
    rclCur.bottom = rclDst.top;

    while (rclCur.top < rclDst.bottom) {

        //
        // Check the Current Bottom, clip it if necessary
        //

        if ((rclCur.bottom += szlPat.cy) > rclDst.bottom) {

            rclCur.bottom = rclDst.bottom;
        }

        rclCur.left  =
        rclCur.right = rclDst.left;

        while (rclCur.left < rclDst.right) {

            //
            // Check the Current right, clip it if necessary
            //

            if ((rclCur.right += szlPat.cx) > rclDst.right) {

                rclCur.right = rclDst.right;
            }

            if (!EngCopyBits(psoDst,                // psoDst
                             psoPat,                // psoPat
                             NULL,                  // pco
                             NULL,                  // pxlo
                             &rclCur,               // prclDst
                             (PPOINTL)&rclPat)) {   // pptlPat

                PLOTERR(("TileBlt: EngCopyBits(DST=(%ld,%ld)-(%ld,%ld), SRC=(%ld,%ld) FAIELD!",
                                    rclCur.left, rclCur.top,
                                    rclCur.right, rclCur.bottom,
                                    rclPat.left, rclPat.top));
                return(FALSE);
            }

            rclCur.left = rclCur.right;
        }

        rclCur.top = rclCur.bottom;
    }

    return(TRUE);
}




BOOL
HalftoneBlt(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoHTBlt,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PPOINTL     pptlHTOrigin,
    BOOL        DoStretchBlt
    )

/*++

Routine Description:


Arguments:

    pPDev           - Pointer to our PDEV

    psoDst          - destination surfobj

    psoHTBlt        - the final halftoned result will be stored, must be a
                      4/1 halftoned bitmap format

    psoSrc          - source surfobj must be BITMAP

    pxlo            - xlate object from source to the plotter device

    prclDest        - rectangle area for the destination

    prclSrc         - rectangle area to be halftoned from the source, if NULL
                      then full source size is used

    pptlHTOrigin    - the halftone origin, if NULL then (0,0) is assumed

    StretchBlt      - if TRUE then a stretch from rclSrc to rclDst otherwise
                      a tiling is done


Return Value:

    BOOL to indicate operation status


Author:

    19-Jan-1994 Wed 15:44:57 created  -by-  DC


Revision History:


--*/

{
    SIZEL   szlSrc;
    RECTL   rclSrc;
    RECTL   rclDst;
    RECTL   rclCur;
    RECTL   rclHTBlt;


    if (PLOT_CANCEL_JOB(pPDev)) {

        return(FALSE);
    }

    PLOTASSERT(1, "HalftoneBlt: psoSrc type [%ld] is not a bitmap",
                        psoSrc->iType == STYPE_BITMAP, (LONG)psoSrc->iType);
    PLOTASSERT(1, "HalftoneBlt: psoHTBlt type [%ld] is not a bitmap",
                        psoHTBlt->iType == STYPE_BITMAP, (LONG)psoHTBlt->iType);

    if (pPDev->psoHTBlt) {

        PLOTERR(("HalftoneBlt: EngStretchBlt(HALFTONE) RECURSIVE CALLS NOT ALLOWED!"));
        return(FALSE);
    }

    pPDev->psoHTBlt = psoHTBlt;

    if (prclSrc) {

        rclSrc = *prclSrc;

    } else {

        rclSrc.left   =
        rclSrc.top    = 0;
        rclSrc.right  = psoSrc->sizlBitmap.cx;
        rclSrc.bottom = psoSrc->sizlBitmap.cy;
    }

    if (prclDst) {

        rclDst = *prclDst;

    } else {

        rclDst.left   =
        rclDst.top    = 0;
        rclDst.right  = psoHTBlt->sizlBitmap.cx;
        rclDst.bottom = psoHTBlt->sizlBitmap.cy;
    }

    if (!pptlHTOrigin) {

        pptlHTOrigin = (PPOINTL)&ptlZeroOrigin;
    }

    if (DoStretchBlt) {

        szlSrc.cx = rclDst.right - rclDst.left;
        szlSrc.cy = rclDst.bottom - rclDst.top;

    } else {

        szlSrc.cx = rclSrc.right - rclSrc.left;
        szlSrc.cy = rclSrc.bottom - rclSrc.top;
    }

    PLOTDBG(DBG_HTBLT, ("HalftoneBlt: %hs BLT, (%ld,%ld)-(%ld,%ld), SRC=%ldx%ld",
                    (DoStretchBlt) ? "STRETCH" : "TILE",
                    rclDst.left, rclDst.top, rclDst.right,rclDst.bottom,
                    szlSrc.cx, szlSrc.cy));

    //
    // Start to tile it, rclCur is current RECTL on the destination
    //

    rclHTBlt.top  = 0;
    rclCur.top    =
    rclCur.bottom = rclDst.top;

    while (rclCur.top < rclDst.bottom) {

        //
        // Check the Current Bottom, clip it if necessary
        //

        if ((rclCur.bottom += szlSrc.cy) > rclDst.bottom) {

            rclCur.bottom = rclDst.bottom;
        }

        rclHTBlt.bottom = rclHTBlt.top + (rclCur.bottom - rclCur.top);

        rclHTBlt.left   = 0;
        rclCur.left     =
        rclCur.right    = rclDst.left;

        while (rclCur.left < rclDst.right) {

            //
            // Check the Current right, clip it if necessary
            //

            if ((rclCur.right += szlSrc.cx) > rclDst.right) {

                rclCur.right = rclDst.right;
            }

            //
            // Set it for the tiling rectangle in psoHTBlt
            //

            rclHTBlt.right = rclHTBlt.left + (rclCur.right - rclCur.left);

            PLOTDBG(DBG_HTBLT, ("HalftoneBlt: TILE (%ld,%ld)-(%ld,%ld)->(%ld,%ld)-(%ld,%ld)=%ld x %ld",
                            rclCur.left, rclCur.top, rclCur.right, rclCur.bottom,
                            rclHTBlt.left, rclHTBlt.top,
                            rclHTBlt.right, rclHTBlt.bottom,
                            rclCur.right - rclCur.left,
                            rclCur.bottom - rclCur.top));

            //
            // Set it before the call for the DrvCopyBits()
            //

            pPDev->rclHTBlt = rclHTBlt;

            if (!EngStretchBlt(psoDst,              // Dest
                               psoSrc,              // SRC
                               NULL,                // MASK
                               NULL,                // CLIPOBJ
                               pxlo,                // XLATEOBJ
                               NULL,                // COLORADJUSTMENT
                               pptlHTOrigin,        // BRUSH ORG
                               &rclCur,             // DEST RECT
                               &rclSrc,             // SRC RECT
                               NULL,                // MASK POINT
                               HALFTONE)) {         // HALFTONE MODE

                PLOTERR(("HalftoneeBlt: EngStretchBits(DST=(%ld,%ld)-(%ld,%ld), SRC=(%ld,%ld) FAIELD!",
                                    rclCur.left, rclCur.top,
                                    rclCur.right, rclCur.bottom,
                                    rclSrc.left, rclSrc.top));

                pPDev->psoHTBlt = NULL;
                return(FALSE);
            }

            rclHTBlt.left = rclHTBlt.right;
            rclCur.left   = rclCur.right;
        }

        rclHTBlt.top = rclHTBlt.bottom;
        rclCur.top   = rclCur.bottom;
    }

    pPDev->psoHTBlt = NULL;

    return(TRUE);
}




SURFOBJ *
CreateSolidColorSURFOBJ(
    PPDEV   pPDev,
    SURFOBJ *psoDst,
    HBITMAP *phBmp,
    DWORD   SolidColor
    )

/*++

Routine Description:

    This function creates a SOLID color bitmap surfobj which can be used to
    blt around.

Arguments:

    pPDev       - Pointer to our PDEV

    phBmp       - Pointer the HBITMAP location to be returned for the bitmap

    SolidColor  - Solid color


Return Value:

    SURFOBJ if sucessful, NULL if failed

Author:

    19-Jan-1994 Wed 16:35:54 created  -by-  DC


Revision History:


--*/

{
    SURFOBJ *psoHT    = NULL;
    HBITMAP hBmpSolid = NULL;
    SURFOBJ *psoSolid;


    //
    // First create a 24-bit source color bitmap
    //

    if (psoSolid = CreateBitmapSURFOBJ(pPDev,
                                       &hBmpSolid,
                                       1,
                                       1,
                                       BMF_24BPP,
                                       NULL)) {

        LPBYTE      pbgr        = (LPBYTE)psoSolid->pvScan0;
        PPALENTRY   pPal        = (PPALENTRY)&SolidColor;
        DWORD       HTCellSize  = (DWORD)HTPATSIZE(pPDev);

        *pbgr++ = pPal->R;
        *pbgr++ = pPal->G;
        *pbgr++ = pPal->B;

        //
        // Create a compatible halftone surface with size of halftone cell
        //

        if (psoHT = CreateBitmapSURFOBJ(pPDev,
                                        phBmp,
                                        HTCellSize,
                                        HTCellSize,
                                        (DWORD)HTBMPFORMAT(pPDev),
                                        NULL)) {

            //
            // Now halftone blt it
            //

            if (!HalftoneBlt(pPDev,         // pPDev
                             psoDst,        // psoDst
                             psoHT,         // psoHTBlt
                             psoSolid,      // psoSrc
                             NULL,          // pxlo,
                             NULL,          // prclDst
                             NULL,          // prclSrc
                             NULL,          // pptlHTOrigin
                             TRUE)) {       // DoStretchBlt

                PLOTERR(("CreateSolidColorSURFOBJ: HalftoneBlt(STRETCH) Failed"));

                DELETE_SURFOBJ(psoHT, phBmp);
            }

        } else {

            PLOTERR(("CreateSolidColorSURFOBJ: Create 24BPP SOURCE failed"));
        }

    } else {

        PLOTERR(("CreateSolidColorSURFOBJ: Create 24BPP SOURCE failed"));
    }

    DELETE_SURFOBJ(psoSolid, &hBmpSolid);

    return(psoHT);
}





SURFOBJ *
CloneBrushSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    HBITMAP     *phBmp,
    BRUSHOBJ    *pbo
    )

/*++

Routine Description:

    This function clones the surface object passed in


Arguments:

    pPDev   - Points to our PPDEV

    psoDst  - the surface object for the plotter

    phBmp   - Pointer to stored hBbitmap created for the cloned surface

    pbo     - BRUSHOBJ to be cloned


Return Value:

    pointer to the cloned surface object, NULL if failure


Author:

    09-Feb-1994 Wed 13:04:46 updated  -by-  DC
        Make it assert and handle it when things not supposed happened.

    04-Jan-1994 Tue 12:11:23 created  -by-  DC


Revision History:


--*/

{
    //
    // Ceate a Solid color brush if so, NOTE: All brush patterns created
    // here have brush origin at (0,0) we will align the brush origin
    // when we actually do the ROPs
    //

    if (!IS_RASTER(pPDev)) {

        return(FALSE);
    }

    if (pbo->iSolidColor & 0xFF000000) {

        PDEVBRUSH   pDevBrush = (PDEVBRUSH)pbo->pvRbrush;

        if ((pDevBrush) || (pDevBrush = BRUSHOBJ_pvGetRbrush(pbo))) {

            return(CreateBitmapSURFOBJ(pPDev,
                                       phBmp,
                                       pDevBrush->sizlBitmap.cx,
                                       pDevBrush->sizlBitmap.cy,
                                       pDevBrush->BmpFormat,
                                       pDevBrush->BmpBits));

        } else {

            return(FALSE);
        }

    } else {

        return(CreateSolidColorSURFOBJ(pPDev,
                                       psoDst,
                                       phBmp,
                                       pbo->iSolidColor));
    }
}




SURFOBJ *
CloneSURFOBJToHT(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo,
    HBITMAP     *phBmp,
    PRECTL      prclDst,
    PRECTL      prclSrc
    )
/*++

Routine Description:

    This function clones the surface object passed in


Arguments:

    pPDev           - Pointer to our PPDEV

    psoDst          - the surface object for the plotter, if psoDst is NULL
                      then only the bitmapp will be created

    psoSrc          - The surface object to be cloned

    pxlo            - XLATE object to be used from source to plotter surfobj

    phBmp           - Pointer to stored hBbitmap created for the cloned surface

    prclDst         - rectangle rectangle size/location to be cloned

    prclSrc         - source rectangle size/location to be cloned

Return Value:

    pointer to the cloned surface object, NULL if failed.

    if this function is sucessful it will MODIFY the prclSrc to reflect cloned
    surface object


Author:

    04-Jan-1994 Tue 12:11:23 created  -by-  DC


Revision History:


--*/

{
    SURFOBJ *psoHT;
    RECTL   rclDst;
    RECTL   rclSrc;
    POINTL  ptlHTOrigin;


    rclSrc.left   =
    rclSrc.top    = 0;
    rclSrc.right  = psoSrc->sizlBitmap.cx;
    rclSrc.bottom = psoSrc->sizlBitmap.cy;

    if (prclSrc) {

        if (!IntersectRECTL(&rclSrc, prclSrc)) {

            PLOTDBG(DBG_CLONESURFOBJ, ("CloneSURFOBJToHT: Source rectangle is empty"));
            return(NULL);
        }
    }

    PLOTDBG(DBG_CLONESURFOBJ, ("CloneSURFOBJToHT: rclSrc=(%ld, %ld)-(%ld,%ld) = %ld x %ld",
                    rclSrc.left, rclSrc.top,
                    rclSrc.right, rclSrc.bottom,
                    rclSrc.right - rclSrc.left,
                    rclSrc.bottom - rclSrc.top));

    rclDst.left   =
    rclDst.top    = 0;
    rclDst.right  = psoDst->sizlBitmap.cx;
    rclDst.bottom = psoDst->sizlBitmap.cy;

    if (prclDst) {

        if (!IntersectRECTL(&rclDst, prclDst)) {

            PLOTDBG(DBG_CLONESURFOBJ, ("CloneSURFOBJToHT: Source rectangle is empty"));
            return(NULL);
        }
    }

    PLOTDBG(DBG_CLONESURFOBJ, ("CloneSURFOBJToHT: rclDst=(%ld, %ld)-(%ld,%ld) = %ld x %ld",
                    rclDst.left, rclDst.top,
                    rclDst.right, rclDst.bottom,
                    rclDst.right - rclDst.left,
                    rclDst.bottom - rclDst.top));

    if (psoHT = CreateBitmapSURFOBJ(pPDev,
                                    phBmp,
                                    rclDst.right -= rclDst.left,
                                    rclDst.bottom -= rclDst.top,
                                    HTBMPFORMAT(pPDev),
                                    NULL)) {

        //
        // Halftone and tile the source to the destination
        //

        ptlHTOrigin.x = rclDst.left;
        ptlHTOrigin.y = rclDst.top;

        if (prclSrc) {

            if ((rclDst.left = prclSrc->left) > 0) {

                rclDst.left = 0;
            }

            if ((rclDst.top = prclSrc->top) > 0) {

                rclDst.top = 0;
            }

            //
            // Modify the source to reflect the cloned source
            //

            *prclSrc = rclDst;
        }


        if (psoDst) {

            if (!HalftoneBlt(pPDev,
                             psoDst,
                             psoHT,
                             psoSrc,
                             pxlo,
                             &rclDst,
                             &rclSrc,
                             &ptlHTOrigin,
                             FALSE)) {

                PLOTERR(("CloneSURFOBJToHT: HalftoneBlt(TILE) Failed"));

                DELETE_SURFOBJ(psoHT, phBmp);
            }
        }

    } else {

        PLOTERR(("CreateSolidColorSURFOBJ: Create Halftone SURFOBJ failed"));
    }

    return(psoHT);
}



SURFOBJ *
CloneMaskSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoMask,
    HBITMAP     *phBmp,
    PRECTL      prclMask
    )
/*++

Routine Description:

    This function clones the mask surface object passed in


Arguments:

    pPDev           - Pointer to our PPDEV

    psoMask         - The mask surface object to be cloned

    phBmp           - Pointer to stored hBbitmap created for the cloned surface

    prclMask        - Mask source rectangle size/location to be cloned

Return Value:

    pointer to the cloned surface object or original passed in psoMask, NULL if
    failed.

    if this function is sucessful it will MODIFY the prclMask to reflect cloned
    surface object


Author:

    04-Jan-1994 Tue 12:11:23 created  -by-  DC


Revision History:


--*/

{
    SURFOBJ *psoHT;
    RECTL   rclMask;
    DWORD   cxMask;
    DWORD   cyMask;
    DWORD   xLoop;


    if (PLOT_CANCEL_JOB(pPDev)) {

        return(FALSE);
    }

    PLOTASSERT(1, "CloneMaskSURFOBJ: psoMask=%08lx is not 1BPP",
                        (psoMask)   &&
                        (psoMask->iType == STYPE_BITMAP) &&
                        (psoMask->iBitmapFormat == BMF_1BPP), psoMask);

    PLOTDBG(DBG_CLONEMASK, ("CloneMaskSURFOBJ: prclMask=(%ld, %ld)-(%ld,%ld) = %ld x %ld",
                    prclMask->left, prclMask->top,
                    prclMask->right, prclMask->bottom,
                    prclMask->right - prclMask->left,
                    prclMask->bottom - prclMask->top));

    rclMask.left   =
    rclMask.top    = 0;
    rclMask.right  = psoMask->sizlBitmap.cx;
    rclMask.bottom = psoMask->sizlBitmap.cy;

    if (!IntersectRECTL(&rclMask, prclMask)) {

        PLOTDBG(DBG_CLONEMASK, ("CloneMaskSURFOBJ: Mask rectangle is empty"));
        return(NULL);
    }

    cxMask = rclMask.right - rclMask.left;
    cyMask = rclMask.bottom - rclMask.top;

    PLOTDBG(DBG_CLONEMASK, ("CloneMaskSURFOBJ: rclMask=(%ld, %ld)-(%ld,%ld) = %ld x %ld",
                    rclMask.left, rclMask.top,
                    rclMask.right, rclMask.bottom,
                    rclMask.right - rclMask.left,
                    rclMask.bottom - rclMask.top));

    if (psoHT = CreateBitmapSURFOBJ(pPDev,
                                    phBmp,
                                    cxMask,
                                    cyMask,
                                    HTBMPFORMAT(pPDev),
                                    NULL)) {
        //
        // Update prclMask
        //

        prclMask->left   =
        prclMask->top    = 0;
        prclMask->right  = cxMask;
        prclMask->bottom = cyMask;

        if (psoHT->iBitmapFormat == BMF_1BPP) {

            //
            // !Remember: Our BMF_1BPP 0=BLACK, 1=WHITE
            //

            if (!EngBitBlt(psoHT,                   // psoDst
                           psoMask,                 // psoSrc
                           NULL,                    // psoMask
                           NULL,                    // pco
                           NULL,                    // pxlo
                           prclMask,                // prclDst
                           (PPOINTL)&rclMask,       // pptlSrc
                           NULL,                    // pptlMask
                           NULL,                    // pbo
                           (PPOINTL)&ptlZeroOrigin, // pptlBrushOrg ZERO
                           0x3333)) {               // NOTSRCCOPY

                PLOTERR(("DrvBitBlt: EngBitBlt(Mask 0x3333) FAILED"));
            }

        } else {

            BYTE    SrcMaskBeg;
            BYTE    SrcMask;
            BYTE    DstMask;
            BYTE    bSrc;
            BYTE    bDst;
            LPBYTE  pbSrcBeg;
            LPBYTE  pbDstBeg;
            LPBYTE  pbSrc;
            LPBYTE  pbDst;


            PLOTASSERT(1, "CloneMaskSURFOBJ: Cloned Mask psoHT=%08lx is not 4BPP",
                        (psoHT->iBitmapFormat == BMF_4BPP), psoHT);

            //
            // get the starting location of the original 1BPP mask
            //

            pbSrcBeg   = (LPBYTE)psoMask->pvScan0 +
                         (rclMask.top * psoMask->lDelta) +
                         (rclMask.left >> 3);
            SrcMaskBeg = (BYTE)(0x80 >> (rclMask.left & 0x07));
            pbDstBeg   = psoHT->pvScan0;

            while (cyMask--) {

                xLoop     = cxMask;
                pbSrc     = pbSrcBeg;
                pbSrcBeg += psoMask->lDelta;
                pbDst     = pbDstBeg;
                pbDstBeg += psoHT->lDelta;
                SrcMask   = SrcMaskBeg;
                DstMask   = 0xF0;
                bSrc      = *pbSrc++;
                bDst      = 0xFF;

                while (xLoop--) {

                    if (!SrcMask) {

                        SrcMask = 0x80;
                        bSrc    = *pbSrc++;
                    }

                    if (bSrc & SrcMask) {

                        bDst ^= DstMask;
                    }

                    SrcMask >>= 1;

                    if ((DstMask ^= 0xFF) == 0xF0) {

                        *pbDst++ = bDst;
                        bDst     = 0xFF;
                    }
                }
            }
        }

    } else {

        PLOTERR(("CloneMaskSURFOBJ: Create Mask SURFOBJ failed"));
    }

    return(psoHT);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\htblt.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    htblt.h


Abstract:

    This module contains definitions and prototypes for htblt.c


Author:
    18-Dec-1993 Sat 08:50:09 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

    10-Feb-1994 Thu 15:24:13 updated  -by-  DC
        Adding MonoPal[] to the DRVHTINFO


--*/


#ifndef _HTBLT_
#define _HTBLT_


typedef struct _FOURBYTES {
    BYTE    b1st;
    BYTE    b2nd;
    BYTE    b3rd;
    BYTE    b4th;
    } FOURBYTES, *PFOURBYTES, FAR *LPFOURBYTES;

typedef union _HTXB {
    FOURBYTES   b4;
    DWORD       dw;
    } HTXB, *PHTXB, FAR *LPHTXB;


#define HTXB_H_NIBBLE_MAX   8
#define HTXB_L_NIBBLE_MAX   8
#define HTXB_H_NIBBLE_DUP   128
#define HTXB_L_NIBBLE_DUP   8
#define HTXB_COUNT          (HTXB_H_NIBBLE_DUP * 2)
#define HTXB_TABLE_SIZE     (HTXB_COUNT * sizeof(HTXB))

#define HTPAL_XLATE_COUNT   8

#define HTPALXOR_NOTSRCCOPY (DWORD)0xffffffff
#define HTPALXOR_SRCCOPY    (DWORD)0x0


#define DHIF_IN_STRETCHBLT  0x01

typedef union _PALDW {
    DWORD       dw;
    PALENTRY    Pal;
    } PALDW;

typedef struct _DRVHTINFO {
    BYTE            Flags;
    BYTE            HTPalCount;
    BYTE            HTBmpFormat;
    BYTE            AltBmpFormat;
    DWORD           HTPalXor;
    PHTXB           pHTXB;
    PALDW           RTLPal[2];
    BYTE            PalXlate[HTPAL_XLATE_COUNT];
    } DRVHTINFO, *PDRVHTINFO;

#define PAL_MIN_I           0x00
#define PAL_MAX_I           0xff

#define HTXB_R(htxb)        htxb.b4.b1st
#define HTXB_G(htxb)        htxb.b4.b2nd
#define HTXB_B(htxb)        htxb.b4.b3rd
#define HTXB_I(htxb)        htxb.b4.b4th

#define RGB_BLACK           0x00000000
#define RGB_WHITE           0x00FFFFFF

#define P4B_TO_3P_DW(dwRet, pHTXB, pbData)                                  \
{                                                                           \
        (dwRet) = (DWORD)((pHTXB[*(pbData + 0)].dw & (DWORD)0xc0c0c0c0) |   \
                          (pHTXB[*(pbData + 1)].dw & (DWORD)0x30303030) |   \
                          (pHTXB[*(pbData + 2)].dw & (DWORD)0x0c0c0c0c) |   \
                          (pHTXB[*(pbData + 3)].dw & (DWORD)0x03030303));   \
        ++((LPDWORD)pbData);                                                        \
}


//
// When outputing halftoned bitmaps, the HTENUMRCLS structure can accomodate
// up to MAX_HTENUM_RECTLS when calling the engine.
//

#define MAX_HTENUM_RECTLS       8


typedef struct _HTENUMRCLS {
    DWORD   c;                      // count of rectangles enumerated
    RECTL   rcl[MAX_HTENUM_RECTLS]; // enumerated rectangles array
    } HTENUMRCL, *PHTENUMRCL;

//
// HTBMPINFO is passed to the halftone bitmap output function
//

#define HTBIF_FLIP_MONOBITS     0x00000001
#define HTBIF_BA_PAD_1          0x00000002

typedef struct _HTBMPINFO {
    PPDEV   pPDev;              // Our pPDev
    LPBYTE  pScan0;             // point to the first scan line of the bitmap
    LONG    Delta;              // count to be added to next scan line
    RECTL   rclBmp;             // visible area for the final output
    POINTL  OffBmp;             // x/y offset from the rclBmp.left
    SIZEL   szlBmp;             // size of visible rectangle
    LPBYTE  pScanBuf;           // pointer to scan buffer (may be RGB 3 scans)
    LPBYTE  pRotBuf;            // tempoprary rotation buffer if not null
    DWORD   Flags;              // HTBIF_xxxx
    PLOTDBGBLK(DWORD cScanBuf)  // debug check
    PLOTDBGBLK(DWORD cRotBuf)   // debug check
    } HTBMPINFO, FAR *PHTBMPINFO;

typedef BOOL (*OUTHTBMPFUNC)(PHTBMPINFO);

#define ISHTF_ALTFMT        0x0001
#define ISHTF_HTXB          0x0002
#define ISHTF_DSTPRIM_OK    0x0004



#define OHTF_IN_RTLMODE     0x00000001
#define OHTF_CLIPWINDOW     0x00000002
#define OHTF_SET_TR1        0x00000004
#define OHTF_DONE_ROPTR1    0x08000000
#define OHTF_EXIT_TO_HPGL2  0x80000000

#define OHTF_MASK           (OHTF_IN_RTLMODE        |   \
                             OHTF_CLIPWINDOW        |   \
                             OHTF_SET_TR1           |   \
                             OHTF_DONE_ROPTR1       |   \
                             OHTF_EXIT_TO_HPGL2)

//
// Functions prototype
//

BOOL
IsHTCompatibleSurfObj(
    PPDEV       pPDev,
    SURFOBJ     *pso,
    XLATEOBJ    *pxlo,
    DWORD       Flags
    );

BOOL
OutputHTBitmap(
    PPDEV   pPDev,
    SURFOBJ *psoHT,
    CLIPOBJ *pco,
    PPOINTL pptlDest,
    PRECTL  prclSrc,
    DWORD   Rop3,
    LPDWORD pOHTFlags
    );

LONG
GetBmpDelta(
    DWORD   SurfaceFormat,
    DWORD   cx
    );

SURFOBJ *
CreateBitmapSURFOBJ(
    PPDEV   pPDev,
    HBITMAP *phBmp,
    LONG    cxSize,
    LONG    cySize,
    DWORD   Format,
    LPVOID  pvBits
    );

BOOL
PatBmpTileBlt(
    SURFOBJ *psoDst,
    SURFOBJ *psoPat,
    PRECTL  prclPat,
    PPOINTL pptlPatOrg
    );

BOOL
HalftoneBlt(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoHTBlt,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PPOINTL     pptlHTOrigin,
    BOOL        DoStretchBlt
    );

SURFOBJ *
CreateSolidColorSURFOBJ(
    PPDEV   pPDev,
    SURFOBJ *psoDst,
    HBITMAP *phBmp,
    DWORD   SolidColor
    );

SURFOBJ *
CloneBrushSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    HBITMAP     *phBmp,
    BRUSHOBJ    *pbo
    );

SURFOBJ *
CloneSURFOBJToHT(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo,
    HBITMAP     *phBmp,
    PRECTL      prclDst,
    PRECTL      prclSrc
    );

SURFOBJ *
CloneMaskSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoMask,
    HBITMAP     *phBmp,
    PRECTL      prclMask
    );

#endif  // _HTBLT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\escape.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    escape.c


Abstract:

   This module contains the code to implement the DrvEscape() driver call


Author:

    15:30 on Mon 06 Dec 1993    -by-    JB
        Created it


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgEscape

#define DBG_DRVESCAPE         0x00000001


DEFINE_DBGVAR(0);



#define pbIn     ((BYTE *)pvIn)
#define pdwIn    ((DWORD *)pvIn)
#define pdwOut   ((DWORD *)pvOut)



ULONG
DrvEscape(
    SURFOBJ *pso,
    ULONG   iEsc,
    ULONG   cjIn,
    PVOID   pvIn,
    ULONG   cjOut,
    PVOID   pvOut
)

/*++

Routine Description:

    Performs the escape functions.  Currently,  only 3 are defined -
    one to query the escapes supported,  the other for raw data, and the
    last for setting the COPYCOUNT.


Arguments:

    pso     - The surface object interested

    iEsc    - The function requested

    cjIn    - Number of bytes in the following

    pvIn    - Location of input data

    cjOut   - Number of bytes in the following

    pvOut   - Location of output area


Return Value:

    ULONG depends on the escape


Author:

    05-Jul-1996 Fri 13:18:54 created  -by-  DC
        Re-write comment, and fix the PASSTHROUGH problem

Revision History:


--*/

{
    ULONG   ulRes;
    PPDEV   pPDev;
    DWORD   cbWritten;


    UNREFERENCED_PARAMETER( cjOut );
    UNREFERENCED_PARAMETER( pvOut );


    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvEscape: Invalid pPDev"));
        return(FALSE);
    }

    ulRes = 0;                 /*  Return failure,  by default */

    switch (iEsc) {

    case QUERYESCSUPPORT:

        PLOTDBG(DBG_DRVESCAPE, ("DrvEscape: in QUERYESCAPESUPPORT"));

        if ((cjIn == 4) && (pvIn)) {

            //
            // Data may be valid,  so check for supported function
            //

            switch (*pdwIn) {

            case QUERYESCSUPPORT:
            case PASSTHROUGH:

                ulRes = 1;                 /* ALWAYS supported */
                break;

            case SETCOPYCOUNT:

                //
                // if the target device actually allows us to tell it
                // how many copies to print of a document, then pass
                // that information back to the caller.
                //

                if (pPDev->pPlotGPC->MaxCopies > 1) {

                    ulRes = 1;
                }

                break;
            }
        }

        break;

    case PASSTHROUGH:

        PLOTDBG(DBG_DRVESCAPE, ("DrvEscape: in PASSTHROUGH"));

        //
        // 05-Jul-1996 Fri 12:59:31 updated  -by-  DC
        //
        // This simply passes the RAW data to the target device, untouched.
        //
        // Win 3.1 actually uses the first 2 bytes as a count of the number of
        // bytes that follow!  So we will check if cjIn represents more data
        // than the first WORD of pvIn
        //

        if (EngCheckAbort(pPDev->pso)) {

            //
            // Set the cancel DOC flag
            //

            pPDev->Flags |= PDEVF_CANCEL_JOB;

            PLOTERR(("DrvEscape(PASSTHROUGH): Job Canceled"));

        } else if ((cjIn <= sizeof(WORD)) || (pvIn == NULL)) {

            SetLastError(ERROR_INVALID_PARAMETER);

            PLOTERR(("DrvEscape(PASSTHROUGH): cjIn <= 2 or pvIn=NULL, nothing to output"));

        } else {

            union {
                WORD    wCount;
                BYTE    bCount[2];
            } u;

            u.bCount[0] = pbIn[0];
            u.bCount[1] = pbIn[1];
            cbWritten   = 0;

            if ((u.wCount == 0) ||
                ((cjIn - sizeof(WORD)) < (DWORD)u.wCount)) {

                PLOTERR(("DrvEscape(PASSTHROUGH): cjIn to small OR wCount is zero/too big"));

                SetLastError(ERROR_INVALID_DATA);

            } else if ((WritePrinter(pPDev->hPrinter,
                                        (LPVOID)(pbIn + 2),
                                        (DWORD)u.wCount,
                                        &cbWritten))    &&
                       ((DWORD)u.wCount == cbWritten)) {

                ulRes = (DWORD)u.wCount;

            } else {

                PLOTERR(("DrvEscape(PASSTHROUGH): WritePrinter() FAILED, cbWritten=%ld bytes",
                            cbWritten));
            }
        }

        break;

    case SETCOPYCOUNT:

        //
        // Input data is a DWORD count of copies
        //

        PLOTDBG(DBG_DRVESCAPE, ("DrvEscape: in SETCOPYCOUNT"));

        if ((pdwIn) && (*pdwIn)) {

            //
            // Load the value of current copies since we will, and Check that
            // is within the printers range,  and truncate if it is not.
            // The device information structure, tells us the maximum amount
            // of copies the device can generate on its own. We save this new
            // Copy amount inside of our current DEVMODE that we have stored,
            // as part of our PDEV. The copy count actually gets output
            // later to the target device.
            //

            pPDev->PlotDM.dm.dmCopies = (SHORT)*pdwIn;

            if ((WORD)pPDev->PlotDM.dm.dmCopies > pPDev->pPlotGPC->MaxCopies) {

               pPDev->PlotDM.dm.dmCopies = (SHORT)pPDev->pPlotGPC->MaxCopies;
            }

            if ((pdwOut) && (cjOut)) {

                cbWritten = (DWORD)pPDev->PlotDM.dm.dmCopies;

                CopyMemory(pdwOut,
                           &cbWritten,
                           (cjOut >= sizeof(DWORD)) ? sizeof(DWORD) : cjOut);
            }


            //
            // Success!
            //

            ulRes = 1;
        }

        break;

    default:

        PLOTERR(("DrvEscape: Unsupported Escape Code : %d\n", iEsc ));

        SetLastError(ERROR_INVALID_FUNCTION);
        break;
    }

    return(ulRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\htbmp1.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    htbmp1.c


Abstract:

    This module contains functions used to output halftoned 1BPP bitmaps
    to the target device. Rotation is also handled here.

Author:

    21-Dec-1993 Tue 21:35:56 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

    10-Feb-1994 Thu 16:52:55 updated  -by-  DC
        Remove pDrvHTInfo->PalXlate[] reference, all monochrome bitmap will
        be sent as index 0/1 color pal set before hand (in OutputHTBitmap)


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgHTBmp1

#define DBG_OUTPUT1BPP      0x00000001
#define DBG_OUTPUT1BPP_ROT  0x00000002
#define DBG_JOBCANCEL       0x00000004
#define DBG_SHOWSCAN        0x80000000

DEFINE_DBGVAR(0);



#define HTBIF_MONO_BA       (HTBIF_FLIP_MONOBITS | HTBIF_BA_PAD_1)




//
// Very useful macro for outputing scan line in a text representation to
// the debug output stream.
//

#define SHOW_SCAN                                                           \
{                                                                           \
    if (DBG_PLOTFILENAME & DBG_SHOWSCAN) {                                  \
                                                                            \
        LPBYTE  pbCur;                                                      \
        UINT    cx;                                                         \
        UINT    x;                                                          \
        UINT    Size;                                                       \
        BYTE    bData;                                                      \
        BYTE    Mask;                                                       \
        BYTE    Buf[128];                                                   \
                                                                            \
        pbCur = pbScanSrc;                                                  \
        Mask  = 0;                                                          \
                                                                            \
        if ((cx = RTLScans.cxBytes << 3) >= sizeof(Buf)) {                  \
                                                                            \
            cx = sizeof(Buf) - 1;                                           \
        }                                                                   \
                                                                            \
        for (Size = x = 0; x < cx; x++) {                                   \
                                                                            \
            if (!(Mask >>= 1)) {                                            \
                                                                            \
                Mask  = 0x80;                                               \
                bData = *pbCur++;                                           \
            }                                                               \
                                                                            \
            Buf[Size++] = (BYTE)((bData & Mask) ? 178 : 176);               \
        }                                                                   \
                                                                            \
        Buf[Size] = '\0';                                                   \
        DBGP((Buf));                                                        \
     }                                                                      \
}




//
// To Use OUT_ONE_1BPP_SCAN, the following variables must be set ahead of time
//
//  HTBmpInfo   - The whole structure with bitmap info set
//  cxDestBytes - Total size of destination scan line buffer per plane
//
//  This macro will directly return a FALSE if a CANCEL JOB is detected in
//  the PDEV
//
//  This function will only allowe the pbScanSrc passed = HTBmpInfo.pScanBuf
//
//  21-Mar-1994 Mon 17:00:21 updated  -by-  DC
//      If we shift to to the left then we will only load last source if
//      we have a valid last source line.
//


#define OUT_ONE_1BPP_SCAN                                                   \
{                                                                           \
    LPBYTE  pbTempS;                                                        \
                                                                            \
    if (LShift) {                                                           \
                                                                            \
        BYTE    b0;                                                         \
        INT     SL;                                                         \
        INT     SR;                                                         \
                                                                            \
        pbTempS = HTBmpInfo.pScanBuf;                                       \
        Loop    = RTLScans.cxBytes;                                         \
                                                                            \
        if ((SL = LShift) > 0) {                                            \
                                                                            \
            b0 = *pbScanSrc++;                                              \
            SR = 8 - SL;                                                    \
                                                                            \
            while (Loop--) {                                                \
                                                                            \
                *pbTempS = (b0 << SL);                                      \
                                                                            \
                if ((Loop) || (FullSrc)) {                                  \
                                                                            \
                    *pbTempS++ |= ((b0 = *pbScanSrc++) >> SR);              \
                }                                                           \
            }                                                               \
                                                                            \
        } else {                                                            \
                                                                            \
            SR = -SL;                                                       \
            SL = 8 - SR;                                                    \
            b0 = 0;                                                         \
                                                                            \
            while (Loop--) {                                                \
                                                                            \
                *pbTempS    = (b0 << SL);                                   \
                *pbTempS++ |= ((b0 = *pbScanSrc++) >> SR);                  \
            }                                                               \
        }                                                                   \
                                                                            \
        pbScanSrc = HTBmpInfo.pScanBuf;                                     \
    }                                                                       \
                                                                            \
    if (HTBmpInfo.Flags & HTBIF_FLIP_MONOBITS) {                            \
                                                                            \
        pbTempS = (LPBYTE)pbScanSrc;                                        \
        Loop    = RTLScans.cxBytes;                                         \
                                                                            \
        while (Loop--) {                                                    \
                                                                            \
            *pbTempS++ ^= 0xFF;                                             \
        }                                                                   \
    }                                                                       \
                                                                            \
    if (HTBmpInfo.Flags & HTBIF_BA_PAD_1) {                                 \
                                                                            \
        *(pbScanSrc          ) |= MaskBA[0];                                \
        *(pbScanSrc + MaskIdx) |= MaskBA[1];                                \
                                                                            \
    } else {                                                                \
                                                                            \
        *(pbScanSrc          ) &= MaskBA[0];                                \
        *(pbScanSrc + MaskIdx) &= MaskBA[1];                                \
    }                                                                       \
                                                                            \
    OutputRTLScans(HTBmpInfo.pPDev,                                         \
                   pbScanSrc,                                               \
                   NULL,                                                    \
                   NULL,                                                    \
                   &RTLScans);                                              \
}




BOOL
FillRect1bppBmp(
    PHTBMPINFO  pHTBmpInfo,
    BYTE        FillByte,
    BOOL        Pad1,
    BOOL        Rotate
    )

/*++

Routine Description:

    This function fills a 1BPP bitmap with the passed mode.

Arguments:

    pHTBmpInfo  - Pointer to the HTBMPINFO data structure set up for this
                  fuction to output the bitmap

    FillByte    - Byte to be filled

    Pad1        - TRUE if need to pad 1 bit else 0 bit

    Rotate      - TRUE if bitmap should be rotated

Return Value:

    TRUE if sucessful otherwise a FALSE is returned


Author:

    06-Apr-1994 Wed 14:34:28 created  -by-  DC
        For Fill the area 0,1 or inversion, so we will get away of some device
        600 byte alignment problem


Revision History:


--*/

{
    LPBYTE      pbScanSrc;
    HTBMPINFO   HTBmpInfo;
    RTLSCANS    RTLScans;
    DWORD       FullSrc;
    DWORD       Loop;
    INT         LShift;
    UINT        MaskIdx;
    BYTE        MaskBA[2];


    HTBmpInfo = *pHTBmpInfo;
    LShift    = 0;

    //
    // Mode <0: Invert Bits       (Pad 0 : XOR)
    //      =0: Fill All ZERO     (Pad 1 : AND)
    //      >0: Fill All Ones     (Pad 0 : OR)
    //

    if (Rotate) {

        HTBmpInfo.szlBmp.cx = pHTBmpInfo->szlBmp.cy;
        HTBmpInfo.szlBmp.cy = pHTBmpInfo->szlBmp.cx;
        FullSrc             = (DWORD)(HTBmpInfo.rclBmp.top & 0x07);

    } else {

        FullSrc = (DWORD)(HTBmpInfo.rclBmp.left & 0x07);
    }

    HTBmpInfo.Flags = (BYTE)((Pad1) ? HTBIF_BA_PAD_1 : 0);


    //
    // Some devices require that the scanlines produced be byte aligned,
    // not allowing us to simply position to the correct coordinate, and
    // output the scan line. Instead we must determine the nearest byte
    // aligned starting coordinate, and shift the resulting scan line
    // accordingly. Finally we must output the shifted scan line, in such
    // a way as to not affect the padding area (if possible).
    //

    if (NEED_BYTEALIGN(HTBmpInfo.pPDev)) {

        //
        // Now we must shift either left or right, depending on the rclBmp.left
        // location.
        //

        HTBmpInfo.szlBmp.cx += FullSrc;

        //
        // Determine the correct mask byte to use, so we only affect bits
        // in the original position (not ones we are forced to shift
        // to in order to overcome device positioning limitations.
        //

        MaskIdx   = (UINT)FullSrc;
        MaskBA[0] = (BYTE)((MaskIdx) ? ((0xFF >> MaskIdx) ^ 0xFF) : 0);

        if (MaskIdx = (INT)(HTBmpInfo.szlBmp.cx & 0x07)) {

            //
            // Increase cx so that it covers the last full byte, this way the
            // compression will not try to clear it
            //

            MaskBA[1]            = (BYTE)(0xFF >> MaskIdx);
            HTBmpInfo.szlBmp.cx += (8 - MaskIdx);

        } else {

            MaskBA[1] = 0;
        }

        if (HTBmpInfo.Flags & HTBIF_BA_PAD_1) {

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=1: OR %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));

        } else {

            MaskBA[0] ^= 0xFF;
            MaskBA[1] ^= 0xFF;

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=0: AND %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));
        }

    } else {

        HTBmpInfo.Flags &= ~(HTBIF_MONO_BA);
        MaskBA[0]        =
        MaskBA[1]        = 0xFF;
    }

    //
    // If we are shifting to the left then we might have SRC BYTES <= DST BYTES
    // so we need to make sure we do not read the extra byte.
    // This guarantees we will never OVERREAD the source.
    //

    EnterRTLScans(HTBmpInfo.pPDev,
                  &RTLScans,
                  HTBmpInfo.szlBmp.cx,
                  HTBmpInfo.szlBmp.cy,
                  TRUE);

    FullSrc = 0;
    MaskIdx = RTLScans.cxBytes - 1;

#if DBG
    if (DBG_PLOTFILENAME & DBG_SHOWSCAN) {

        DBGP(("\n\n"));
    }
#endif


    //
    // Stay in a loop processing the source till we are done.
    //

    while (RTLScans.Flags & RTLSF_MORE_SCAN) {

        FillMemory(pbScanSrc = HTBmpInfo.pScanBuf,
                   RTLScans.cxBytes,
                   FillByte);

        OUT_ONE_1BPP_SCAN;
#if DBG
        SHOW_SCAN;
#endif
    }

    ExitRTLScans(HTBmpInfo.pPDev, &RTLScans);

    return(TRUE);
}





BOOL
Output1bppHTBmp(
    PHTBMPINFO  pHTBmpInfo
    )

/*++

Routine Description:

    This function outputs a 1 bpp halftoned bitmap

Arguments:

    pHTBmpInfo  - Pointer to the HTBMPINFO data structure set up for this
                  fuction to output the bitmap

Return Value:

    TRUE if sucessful otherwise a FALSE is returned


Author:

    Created JB

    21-Dec-1993 Tue 16:05:08 Updated  -by-  DC
        Re-write to make it take HTBMPINFO

    23-Dec-1993 Thu 22:47:45 updated  -by-  DC
        We must check if the source bit 1 is BLACK, if not then we need to
        flip it

    25-Jan-1994 Tue 17:32:36 updated  -by-  DC
        Fixed dwFlipCount mis-computation from DW_ALIGN(cxDestBytes) to
        (DWORD)(DW_ALIGN(7cxDestBytes) >> 2);

    22-Feb-1994 Tue 14:54:42 updated  -by-  DC
        Using RTLScans data structure

    16-Mar-1994 Wed 16:54:59 updated  -by-  DC
        Updated so we do not copy to the temp. buffer anymore, the masking
        of last source byte problem in OutputRTLScans() will be smart enough
        to put the original byte back after the masking


Revision History:


--*/

{
    LPBYTE      pbScanSrc;
    HTBMPINFO   HTBmpInfo;
    RTLSCANS    RTLScans;
    DWORD       FullSrc;
    DWORD       Loop;
    INT         LShift;
    UINT        MaskIdx;
    BYTE        MaskBA[2];



    HTBmpInfo         = *pHTBmpInfo;
    HTBmpInfo.pScan0 += (HTBmpInfo.OffBmp.x >> 3);
    LShift            = (INT)(HTBmpInfo.OffBmp.x & 0x07);
    Loop              = (DWORD)((HTBmpInfo.szlBmp.cx + (LONG)LShift + 7) >> 3);

    if (NEED_BYTEALIGN(HTBmpInfo.pPDev)) {

        //
        // Based on some devices requiring byte aligned coordinates for
        // outputing graphics, we have to handle that situation now.
        // We do this by finding the closest byte aligned position,
        // then shifting, masking and padding to effect the corect pixels
        // on the target device.
        //


        FullSrc              = (INT)(HTBmpInfo.rclBmp.left & 0x07);
        HTBmpInfo.szlBmp.cx += FullSrc;
        LShift              -= FullSrc;

        //
        // Check and compute masking since we are handling the byte align
        // requirement of the target device.
        //

        MaskIdx   = (UINT)FullSrc;
        MaskBA[0] = (BYTE)((MaskIdx) ? ((0xFF >> MaskIdx) ^ 0xFF) : 0);

        if (MaskIdx = (INT)(HTBmpInfo.szlBmp.cx & 0x07)) {

            //
            // Increase cx so that it covers the last byte, this way the
            // compression will not try to clear it
            //

            MaskBA[1]            = (BYTE)(0xFF >> MaskIdx);
            HTBmpInfo.szlBmp.cx += (8 - MaskIdx);

        } else {

            MaskBA[1] = 0;
        }

        if (HTBmpInfo.Flags & HTBIF_BA_PAD_1) {

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=1: OR %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));

        } else {

            MaskBA[0] ^= 0xFF;
            MaskBA[1] ^= 0xFF;

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=0: AND %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));
        }

    } else {

        HTBmpInfo.Flags &= ~(HTBIF_MONO_BA);
        MaskBA[0]        =
        MaskBA[1]        = 0xFF;
    }

    PLOTDBG(DBG_OUTPUT1BPP, ("Output1bppHTBmp: LShift=%d", LShift));

    //
    // If we are shifting to the left then we might have SRC BYTES <= DST BYTES
    // so we need to make sure we do not read the extra byte.
    // This guarantees we will never OVERREAD the source.
    //

    EnterRTLScans(HTBmpInfo.pPDev,
                  &RTLScans,
                  HTBmpInfo.szlBmp.cx,
                  HTBmpInfo.szlBmp.cy,
                  TRUE);

    FullSrc = ((LShift > 0) && (Loop >= RTLScans.cxBytes)) ? 1 : 0;
    MaskIdx = RTLScans.cxBytes - 1;

#if DBG
    if (DBG_PLOTFILENAME & DBG_SHOWSCAN) {

        DBGP(("\n\n"));
    }
#endif

    while (RTLScans.Flags & RTLSF_MORE_SCAN) {

        if (LShift) {

            pbScanSrc = HTBmpInfo.pScan0;

        } else {

            //
            // Make copy if we do not shift it to temp buffer, so we always
            // output from temp buffer
            //

            CopyMemory(pbScanSrc = HTBmpInfo.pScanBuf,
                       HTBmpInfo.pScan0,
                       RTLScans.cxBytes);
        }

        HTBmpInfo.pScan0 += HTBmpInfo.Delta;

        OUT_ONE_1BPP_SCAN;
#if DBG
        SHOW_SCAN;
#endif
    }

    ExitRTLScans(HTBmpInfo.pPDev, &RTLScans);

    return(TRUE);
}





BOOL
Output1bppRotateHTBmp(
    PHTBMPINFO  pHTBmpInfo
    )

/*++

Routine Description:

    This function outputs a 1 bpp halftoned bitmap and rotates it to the left
    as illustrated

           cx               Org ---- +X -->
        +-------+           | @------------+
        |       |           | |            |
        | ***** |           | |  *         |
       c|   *   |             |  *        c|
       y|   *   |          +Y |  *******  y|
        |   *   |             |  *         |
        |   *   |           | |  *         |
        |   *   |           V |            |
        |   *   |             +------------+
        +-------+


Arguments:

    pHTBmpInfo  - Pointer to the HTBMPINFO data structure set up for this
                  function to output the bitmap

Return Value:

    TRUE if sucessful otherwise a FALSE is returned


Author:

    Created JB

    21-Dec-1993 Tue 16:05:08 Updated  -by-  DC
        Re-write to make it take HTBMPINFO

    23-Dec-1993 Thu 22:47:45 updated  -by-  DC
        We must check if the source bit 1 is BLACK, if not then we need to
        flip it, we will flip using DWORD mode and only do it at time we
        have transpos the buffer.

    25-Jan-1994 Tue 17:32:36 updated  -by-  DC
        Fixed dwFlipCount mis-computation from (TPInfo.cbDestScan << 1) to
        (TPInfo.cbDestScan >> 2)

    22-Feb-1994 Tue 14:54:42 updated  -by-  DC
        Using RTLScans data structure

Revision History:


--*/

{
    LPBYTE      pbCurScan;
    LPBYTE      pbScanSrc;
    HTBMPINFO   HTBmpInfo;
    RTLSCANS    RTLScans;
    TPINFO      TPInfo;
    DWORD       FullSrc;
    DWORD       EndX;
    DWORD       Loop;
    INT         LShift;
    UINT        MaskIdx;
    BYTE        MaskBA[2];



    //
    // EndX is the pixel we will start reading from in the X direction. We must
    // setup the varialbe before we call OUT_1BMP_SETUP, also set LShift to 0
    // because we will never left shift in this mode.
    //

    HTBmpInfo         = *pHTBmpInfo;
    EndX              = (DWORD)(HTBmpInfo.OffBmp.x + HTBmpInfo.szlBmp.cx - 1);
    HTBmpInfo.pScan0 += (EndX >> 3);
    LShift            = 0;
    FullSrc           =
    TPInfo.DestXStart = 0;
    TPInfo.cySrc      = HTBmpInfo.szlBmp.cy;


    //
    // Since we are having to rotate anyway, in this model, we will correctly
    // identify the x coordinate to be bytealigned, and have the correct
    // LShift amount after the rotation (taking into account). This way, we
    // don't have to addionally shift.
    //

    if (NEED_BYTEALIGN(HTBmpInfo.pPDev)) {

        //
        // In order for us to start at the correct offset, the TPInfo.DestXStart
        // will be set to the correct location. When we rotate to the right,
        // the original rclBmp.top is the left offset for the RTL coordinate in
        // the target device.
        //

        TPInfo.DestXStart    = (DWORD)(HTBmpInfo.rclBmp.top & 0x07);
        HTBmpInfo.szlBmp.cy += TPInfo.DestXStart;

        //
        // Create the correct mask for the byte aligned mode. This way,
        // we don't affect pixels that fall into the area we send data
        // to in order to take into account the byte aligned position change.
        //

        MaskIdx   = (UINT)TPInfo.DestXStart;
        MaskBA[0] = (BYTE)((MaskIdx) ? ((0xFF >> MaskIdx) ^ 0xFF) : 0);

        if (MaskIdx = (INT)(HTBmpInfo.szlBmp.cy & 0x07)) {

            //
            // Increase cx so that it cover the last full byte, this way the
            // compression in effect will not try to clear it
            //

            MaskBA[1]            = (BYTE)(0xFF >> MaskIdx);
            HTBmpInfo.szlBmp.cy += (8 - MaskIdx);

        } else {

            MaskBA[1] = 0;
        }

        if (HTBmpInfo.Flags & HTBIF_BA_PAD_1) {

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=1: OR %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));

        } else {

            MaskBA[0] ^= 0xFF;
            MaskBA[1] ^= 0xFF;

            PLOTDBG(DBG_OUTPUT1BPP,
                    ("Output1bppHTBmp: BYTE ALIGN: MaskBA=0: AND %02lx:%02lx",
                        MaskBA[0], MaskBA[1]));
        }

    } else {

        HTBmpInfo.Flags &= ~(HTBIF_MONO_BA);
        MaskBA[0]        =
        MaskBA[1]        = 0xFF;
    }

    EnterRTLScans(HTBmpInfo.pPDev,
                  &RTLScans,
                  HTBmpInfo.szlBmp.cy,
                  HTBmpInfo.szlBmp.cx,
                  TRUE);

    MaskIdx           = RTLScans.cxBytes - 1;
    TPInfo.pPDev      = HTBmpInfo.pPDev;
    TPInfo.pSrc       = HTBmpInfo.pScan0;
    TPInfo.pDest      = HTBmpInfo.pRotBuf;
    TPInfo.cbSrcScan  = HTBmpInfo.Delta;
    TPInfo.cbDestScan = DW_ALIGN(RTLScans.cxBytes);

    PLOTASSERT(1, "The RotBuf size is too small (%ld)",
                (DWORD)(TPInfo.cbDestScan << 3) <= HTBmpInfo.cRotBuf,
                                                    HTBmpInfo.cRotBuf);

    //
    // We will always do the first transpose and set the correct pbCurScan
    // first. We will make EndX the loop counter and increment it by one
    // first. We do this because we increment pbCurScan in the inner loop.
    // We use (6 - EndX++) based on the fact we are rotating 90 degrees to the
    // right. The first scan line is EndX == 7 , the second is at EndX == 6 and
    // so forth. We use 6, in order to go back one extra scan line so that the
    // inner loop will do pbCurScan += TPInfo.cbNextScan will cancel the effect
    // the first time around (since we incremented to accomodate). The EndX++
    // is needed for the same reason, since we do an EndX-- in the inner loop.
    //

    //
    // Win64 fix: Increase a pointer with a INT_PTR quantity.
    //
    EndX      &= 0x07;
    pbCurScan  = TPInfo.pDest + (INT_PTR)((6 - (INT_PTR)EndX++) * TPInfo.cbDestScan);

    TransPos1BPP(&TPInfo);

#if DBG
    if (DBG_PLOTFILENAME & DBG_SHOWSCAN) {

        DBGP(("\n\n"));
    }
#endif

    while (RTLScans.Flags & RTLSF_MORE_SCAN) {


        //
        // Do the transpose only if the source goes into the new byte position.
        // After the transpose (right 90 degrees) the TPInfo.pDest now points
        // to the first scan line and TPInfo.pDest + TPInfo.cbDestScan has the
        // 2nd scan line and so forth.
        //

        if (EndX--) {

            //
            // Still not finished the rotated buffer's scan line yet so
            // increment the pbScanSrc to the next scan line
            //

            pbCurScan += TPInfo.cbDestScan;

        } else {

            TransPos1BPP(&TPInfo);

            //
            // Point to the first scan line in the rotated direction by
            // computing correctly by the TRANSPOS function, even if we
            // rotated left.
            //

            EndX      = 7;
            pbCurScan = TPInfo.pDest;
        }

        //
        // Output one 1bpp scan line and handle shift control
        //

        pbScanSrc = pbCurScan;


        OUT_ONE_1BPP_SCAN;
#if DBG
        SHOW_SCAN;
#endif
    }

    ExitRTLScans(HTBmpInfo.pPDev, &RTLScans);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\htbmp1.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    htbmp1.h


Abstract:

    This module contains definitions and prototypes for htbmp1.c


Author:

    21-Dec-1993 Tue 21:33:43 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _HTBMP1BPP_
#define _HTBMP1BPP_


BOOL
FillRect1bppBmp(
    PHTBMPINFO  pHTBmpInfo,
    BYTE        FillByte,
    BOOL        Pad1,
    BOOL        Rotate
    );

BOOL
Output1bppHTBmp(
    PHTBMPINFO  pHTBmpInfo
    );

BOOL
Output1bppRotateHTBmp(
    PHTBMPINFO  pHTBmpInfo
    );



#endif  // _HTBMP1BPP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\htbmp4.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    htbmp4.c


Abstract:

    This module contains functions to output halftoned 4 bit per pel (4 BPP)
    bitmaps to the target device.


Author:

    21-Dec-1993 Tue 21:32:26 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgHTBmp4

#define DBG_OUTPUT4BPP      0x00000001
#define DBG_OUTPUT4BPP_ROT  0x00000002
#define DBG_JOBCANCEL       0x00000004

DEFINE_DBGVAR(0);



//
// To Use OUT_ONE_4BPP_SCAN, the following variables must be set before hand:
//
//  HTBmpInfo       - The whole structure copied down
//  pbScanSrc       - LPBYTE for getting the source scan line buffer
//  pbScanR0        - Red destination scan line buffer pointer
//  pbScanG0        - Green destination scan line buffer pointer
//  pbScanB0        - Blue destination scan line buffer pointer
//  RTLScans.cxBytes- Total size of destination scan line buffer per plane
//  pHTXB           - Computed HTXB xlate table in pPDev
//
//  This macro will always assume the pbScanSrc is DWORD aligned. This
//  makes the inner loop go faster since we only need to move the source once
//  for all raster planes.
//
//  This macro will directly return a FALSE if a CANCEL JOB is detected during
//  procesing.
//
//  This will output directly to RTL.
//
//

#define OUT_ONE_4BPP_SCAN                                                   \
{                                                                           \
    LPBYTE  pbScanR  = pbScanR0;                                            \
    LPBYTE  pbScanG  = pbScanG0;                                            \
    LPBYTE  pbScanB  = pbScanB0;                                            \
    DWORD   LoopHTXB = RTLScans.cxBytes;                                    \
    HTXB    htXB;                                                           \
                                                                            \
    while (LoopHTXB--) {                                                    \
                                                                            \
        P4B_TO_3P_DW(htXB.dw, pHTXB, pbScanSrc);                            \
                                                                            \
        *pbScanR++ = HTXB_R(htXB);                                          \
        *pbScanG++ = HTXB_G(htXB);                                          \
        *pbScanB++ = HTXB_B(htXB);                                          \
    }                                                                       \
                                                                            \
    OutputRTLScans(HTBmpInfo.pPDev,                                         \
                   pbScanR0,                                                \
                   pbScanG0,                                                \
                   pbScanB0,                                                \
                   &RTLScans);                                              \
}



BOOL
Output4bppHTBmp(
    PHTBMPINFO  pHTBmpInfo
    )

/*++

Routine Description:

    This function outputs a 4 bpp halftoned bitmap

Arguments:

    pHTBmpInfo  - Pointer to the HTBMPINFO data structure set up for this
                  fuction to output the bitmap

Return Value:

    TRUE if sucessful otherwise a FALSE is returned


Author:

    Created v-jimbr

    18-Jan-1994 Tue 16:05:08 Updated  -by-  JB
        Changed ASSERT to look at pHTBmpInfo instead of HTBmpInfo

    21-Dec-1993 Tue 16:05:08 Updated  -by-  DC
        Re-write to make it take HTBMPINFO

    16-Mar-1994 Wed 16:54:59 updated  -by-  DC
        Updated so we do not copy to the temp. buffer anymore, the masking
        of last source byte problem in OutputRTLScans() will be smart enough
        to put the original byte back after the masking

Revision History:


--*/

{
    LPBYTE      pbScanSrc;
    PHTXB       pHTXB;
    LPBYTE      pbScanR0;
    LPBYTE      pbScanG0;
    LPBYTE      pbScanB0;
    HTBMPINFO   HTBmpInfo;
    RTLSCANS    RTLScans;
    DWORD       LShiftCount;


    PLOTASSERT(1, "Output4bppHTBmp: No DWORD align buffer (pRotBuf)",
                                                        pHTBmpInfo->pRotBuf, 0);
    HTBmpInfo = *pHTBmpInfo;

    EnterRTLScans(HTBmpInfo.pPDev,
                  &RTLScans,
                  HTBmpInfo.szlBmp.cx,
                  HTBmpInfo.szlBmp.cy,
                  FALSE);

    pHTXB             = ((PDRVHTINFO)HTBmpInfo.pPDev->pvDrvHTData)->pHTXB;
    HTBmpInfo.pScan0 += (HTBmpInfo.OffBmp.x >> 1);
    pbScanR0          = HTBmpInfo.pScanBuf;
    pbScanG0          = pbScanR0 + RTLScans.cxBytes;
    pbScanB0          = pbScanG0 + RTLScans.cxBytes;

    PLOTASSERT(1, "The ScanBuf size is too small (%ld)",
                (RTLScans.cxBytes * 3) <= HTBmpInfo.cScanBuf, HTBmpInfo.cScanBuf);

    PLOTASSERT(1, "The RotBuf size is too small (%ld)",
                (DWORD)((HTBmpInfo.szlBmp.cx + 1) >> 1) <= HTBmpInfo.cRotBuf,
                                                        HTBmpInfo.cRotBuf);

    if (HTBmpInfo.OffBmp.x & 0x01) {

        //
        // We must shift one nibble to the left now
        //

        LShiftCount = (DWORD)HTBmpInfo.szlBmp.cx;

        PLOTDBG(DBG_OUTPUT4BPP,
                ("Output4bppHTBmp: Must SHIFT LEFT 1 NIBBLE To align"));

    } else {

        LShiftCount = 0;
    }

    //
    // We must be very careful not to read past the end of the source buffer.
    // This could happen if we pbScanSrc is not DWORD aligned, since this
    // will cause the last conversion macro to load all 4 bytes. To resolve
    // this we can either copy the source buffer to a DWORD aligned temporary
    // location, or handle the last incomplete DWORD differently. This only
    // occurs when the bitmap is NOT rotated, and (pbScanSrc & 0x03).
    //

    while (RTLScans.Flags & RTLSF_MORE_SCAN) {

        //
        // This is the final source for this scan line
        //

        if (LShiftCount) {

            LPBYTE  pbTmp;
            DWORD   PairCount;
            BYTE    b0;
            BYTE    b1;


            pbTmp     = HTBmpInfo.pScan0;
            b1        = *pbTmp;
            pbScanSrc = HTBmpInfo.pRotBuf;
            PairCount = LShiftCount;

            while (PairCount > 1) {

                b0            = b1;
                b1            = *pbTmp++;
                *pbScanSrc++  = (BYTE)((b0 << 4) | (b1 >> 4));
                PairCount    -= 2;
            }

            if (PairCount) {

                //
                // If we have the last nibble to do then make it 0xF0 nibble,
                // so we only look at the bits of interest.
                //

                *pbScanSrc = (BYTE)(b1 << 4);
            }

            //
            // Reset this pointer back to the final shifted source buffer
            //

            pbScanSrc = HTBmpInfo.pRotBuf;

        } else {

            pbScanSrc = HTBmpInfo.pScan0;
        }

        //
        // Output one 4 bpp scan line (3 planes)
        //

        OUT_ONE_4BPP_SCAN;

        //
        // advance source bitmap buffer pointer to next scan line
        //

        HTBmpInfo.pScan0 += HTBmpInfo.Delta;
    }

    //
    // The caller will send END GRAPHIC command if we return TRUE, thus
    // completing the RTL graphic command.
    //

    ExitRTLScans(HTBmpInfo.pPDev, &RTLScans);

    return(TRUE);
}





BOOL
Output4bppRotateHTBmp(
    PHTBMPINFO  pHTBmpInfo
    )

/*++

Routine Description:

    This function outputs a 4 bpp halftoned bitmap and rotates it to the left
    as illustrated

           cx               Org ---- +X -->
        +-------+           | @------------+
        |       |           | |            |
        | ***** |           | |  *         |
       c|   *   |             |  *        c|
       y|   *   |          +Y |  *******  y|
        |   *   |             |  *         |
        |   *   |           | |  *         |
        |   *   |           V |            |
        |   *   |             +------------+
        +-------+


Arguments:

    pHTBmpInfo  - Pointer to the HTBMPINFO data structure set up for this
                  fuction to output the bitmap

Return Value:

    TRUE if sucessful otherwise a FALSE is returned


Author:

    21-Dec-1993 Tue 16:05:08 Updated  -by-  DC
        Re-write to make it take an HTBMPINFO structure.

    Created v-jimbr


Revision History:


--*/

{
    LPBYTE      pbScanSrc;
    LPBYTE      pb2ndScan;
    PHTXB       pHTXB;
    LPBYTE      pbScanR0;
    LPBYTE      pbScanG0;
    LPBYTE      pbScanB0;
    HTBMPINFO   HTBmpInfo;
    RTLSCANS    RTLScans;
    TPINFO      TPInfo;
    DWORD       EndX;


    //
    // The EndX is the pixel we will start reading in the X direction, we must
    // setup the variable correctly before we call OUT_4BPP_SETUP.
    //

    HTBmpInfo = *pHTBmpInfo;

    EnterRTLScans(HTBmpInfo.pPDev,
                  &RTLScans,
                  HTBmpInfo.szlBmp.cy,
                  HTBmpInfo.szlBmp.cx,
                  FALSE);

    pHTXB             = ((PDRVHTINFO)HTBmpInfo.pPDev->pvDrvHTData)->pHTXB;
    EndX              = (DWORD)(HTBmpInfo.OffBmp.x + HTBmpInfo.szlBmp.cx - 1);
    HTBmpInfo.pScan0 += (EndX >> 1);
    pbScanR0          = HTBmpInfo.pScanBuf;
    pbScanG0          = pbScanR0 + RTLScans.cxBytes;
    pbScanB0          = pbScanG0 + RTLScans.cxBytes;

    PLOTASSERT(1, "The ScanBuf size is too small (%ld)",
                (RTLScans.cxBytes * 3) <= HTBmpInfo.cScanBuf, HTBmpInfo.cScanBuf);

    //
    // after the transpose of the source bitmap into two scanlines the rotated
    // buffer will always start from the high nibble, we will never have
    // an odd src X position.
    // We assume rotation is always to the right 90 degree
    //

    TPInfo.pPDev      = HTBmpInfo.pPDev;
    TPInfo.pSrc       = HTBmpInfo.pScan0;
    TPInfo.pDest      = HTBmpInfo.pRotBuf;
    TPInfo.cbSrcScan  = HTBmpInfo.Delta;
    TPInfo.cbDestScan = (LONG)((HTBmpInfo.szlBmp.cy + 1) >> 1);
    TPInfo.cbDestScan = (LONG)DW_ALIGN(TPInfo.cbDestScan);
    TPInfo.cySrc      = HTBmpInfo.szlBmp.cy;
    TPInfo.DestXStart = 0;

    PLOTASSERT(1, "The RotBuf size is too small (%ld)",
                (DWORD)(TPInfo.cbDestScan << 1) <= HTBmpInfo.cRotBuf,
                                                   HTBmpInfo.cRotBuf);

    //
    // Compute the 2nd scan pointer once, rather than every time in the
    // loop.
    //

    pb2ndScan = TPInfo.pDest + TPInfo.cbDestScan;


    //
    // If we are in an even position do the first transpose once, outside the
    // loop, so we don't have to check this state for ever pass through the
    // loop. If we do the transpose, TPInfo.pSrc, will be decremented by one,
    // and pointing to the correct position.
    //

    if (!(EndX &= 0x01)) {

        TransPos4BPP(&TPInfo);
    }


    while (RTLScans.Flags & RTLSF_MORE_SCAN) {

        //
        // Do the transpose, only if the source goes into the new byte position.
        // After the transpose (right 90 degrees) the TPInfo.pDest will point
        // to the first scan line and TPInfo.pDest + TPInfo.cbDestScan will be
        // the second scan line.
        //


        if (EndX ^= 0x01) {

            pbScanSrc = pb2ndScan;

        } else {

            TransPos4BPP(&TPInfo);

            //
            // Point to the first scan line in the rotated direction. This
            // will be computed correctly by the TRANSPOSE function, even
            // if we rotated left.
            //

            pbScanSrc = TPInfo.pDest;
        }

        //
        // Output one 4bpp scan line (in 3 plane format)
        //

        OUT_ONE_4BPP_SCAN;
    }

    //
    // The caller will send the END GRAPHIC command if we return TRUE, thus
    // completing the RTL graphic command.
    //

    ExitRTLScans(HTBmpInfo.pPDev, &RTLScans);

    return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\htbmp4.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    htbmp4.h


Abstract:

    This module contains prototypes and definitions for htbmp4.c


Author:

    21-Dec-1993 Tue 21:33:43 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _HTBMP4BPP_
#define _HTBMP4BPP_


BOOL
Output4bppHTBmp(
    PHTBMPINFO  pHTBmpInfo
    );

BOOL
Output4bppRotateHTBmp(
    PHTBMPINFO  pHTBmpInfo
    );



#endif  // _HTBMP4BPP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\page.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    page.h


Abstract:

    This module contains prototype and #defines for page.c


Author:

    18-Nov-1993 Thu 04:49:28 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTPAGE_
#define _PLOTPAGE_


BOOL
DrvStartPage(
    SURFOBJ *pso
    );

BOOL
DrvSendPage(
    SURFOBJ *pso
    );

BOOL
DrvStartDoc(
    SURFOBJ *pso,
    PWSTR   pwDocName,
    DWORD   JobId
    );

BOOL
DrvEndDoc(
    SURFOBJ *pso,
    FLONG   Flags
    );


#endif  // _PLOTPAGE_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\output.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    output.h


Abstract:

    This module contains exported definitions for the output.c module


Author:

    16-Nov-1993 Tue 04:16:47 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _PLOTOUTPUT_
#define _PLOTOUTPUT_



#define OUTPUT_BUFFER_SIZE      (32 * 1024)

#define HS_FT_USER_DEFINED      (HS_DDI_MAX + 1)

#define PLOT_LT_UNDEFINED       0
#define PLOT_LT_SOLID           1
#define PLOT_LT_USERDEFINED     2


#define SETLINETYPESOLID(pPDev)                                 \
{                                                               \
    if ((pPDev)->LastLineType != PLOT_LT_SOLID) {               \
                                                                \
        (pPDev)->LastLineType = PLOT_LT_SOLID;                  \
        OutputString(pPDev, "LT");                              \
    }                                                           \
}

#define SPP_MODE_CENTER         0x00
#define SPP_MODE_EDGE           0x01
#define SPP_MODE_MASK           0x01
#define SPP_FORCE_SET           0x80


LONG
BestMatchNonWhitePen(
    PPDEV   pPDev,
    LONG    R,
    LONG    G,
    LONG    B
    );

VOID
GetFinalColor(
    PPDEV       pPDev,
    PPALENTRY   pPalEntry
    );

LONG
FindCachedPen(
    PPDEV       pPDev,
    PPALENTRY   pPalEntry
    );

BOOL
PlotCreatePalette(
    PPDEV   pPDev
    );

UINT
AllocOutBuffer(
    PPDEV   pPDev
    );

VOID
FreeOutBuffer(
    PPDEV   pPDev
    );

BOOL
FlushOutBuffer(
    PPDEV   pPDev
    );

LONG
OutputBytes(
    PPDEV   pPDev,
    LPBYTE  pBuf,
    LONG    cBuf
    );

LONG
OutputString(
    PPDEV   pPDev,
    LPSTR   pszStr
    );

LONG
LONGToASCII(
    LONG    Number,
    LPSTR   pStr16,
    BYTE    NumType
    );

LONG
OutputXYParams(
    PPDEV   pPDev,
    PPOINTL pPtXY,
    PPOINTL pPtOffset,
    PPOINTL pPtCurPos,
    UINT    cPoints,
    UINT    MaxCurPosSkips,
    BYTE    NumType
    );

LONG
OutputLONGParams(
    PPDEV   pPDev,
    PLONG   pNumbers,
    UINT    cNumber,
    BYTE    NumType
    );

LONG
cdecl
OutputFormatStrDELI(
    PPDEV   pPDev,
    CHAR    NumFormatChar,
    LPSTR   pszFormat,
    ...
    );

LONG
cdecl
OutputFormatStr(
    PPDEV   pPDev,
    LPSTR   pszFormat,
    ...
    );

BOOL
OutputCommaSep(
    PPDEV   pPDev
    );

VOID
ClearClipWindow(
    PPDEV pPDev
    );

VOID
SetClipWindow(
    PPDEV   pPDev,
    PRECTL  pClipRectl
    );

VOID
SetPixelPlacement(
    PPDEV   pPDev,
    UINT    SetMode
    );

BOOL
SetRopMode(
    PPDEV   pPDev,
    DWORD   Rop
    );

BOOL
SetHSFillType(
    PPDEV   pPDev,
    DWORD   HSFillTypeIndex,
    LONG    lParam
    );

BOOL
SendPageHeader(
    PPDEV   pPDev
    );

BOOL
SendPageTrailer(
    PPDEV   pPDev
    );



#endif  // _PLOTOUTPUT_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\path.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    path.c


Abstract:

    This module contains Functions related to drawing paths. The main stroke
    drawing entry poing DrvStrokePath, is implemented in this module.


    See also textout.c, bitblt.c:  These two have copies of almost all the
    DrvStrokePath() code.


Author:

    17:30 on Wed 03 Apr 1991    -by-    SC
        Created it

    8/18/92  AP
        I have pretty much rewritten most of this.  Some of the original
        code is left in, mainly to point out things that need to be added.

    15-Nov-1993 Mon 19:40:18 updated  -by-  DC
        clean up / debugging information

    30-Nov-1993 Tue 22:32:12 updated  -by-  DC
        style clean up, updated


    01-Feb-1994              updated  -by-  JB
        Added the ability to stroke styled lines through a complex
        clipping object

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPath

#define DBG_STROKEPATH      0x00000001
#define DBG_SELECTCOLOR     0x00000002
#define DBG_STROKECLIPLINES 0x00000004
#define DBG_MOVEPEN         0x00000008


DEFINE_DBGVAR(0);




BOOL
DoStrokePathByEnumingClipLines(
    PPDEV       pPDev,
    SURFOBJ     *pso,
    CLIPOBJ     *pco,
    PATHOBJ     *ppo,
    PPOINTL     pptlBrushOrg,
    BRUSHOBJ    *pbo,
    ROP4        rop4,
    LINEATTRS   *plineattrs
    )

/*++

Routine Description:

    Strokes a path through a complex clipping region by utilizing the
    engine helper functions. This is done because there is no way to
    fail a DrvStrokePath and have it come back in any simpler format by
    the NT graphics engine. In general, we can fail DrvXXX calls and the
    NT graphic engine will simply the object to draw, then call back into
    the driver. Stroking a path however cannot be simplified any more, so
    the best we can hope for is having the PATHOBJ converted to straight
    line segments (removing BEZIERS if present). We then must stroke the
    path ourselves, using the provided EngXXX helpers.
    Since helper functions exist that allow us to to enumerate the
    portions of a path as CLIPLINE segments that fall within the
    clipping region, we do that here, thus stroking the segments that lie
    inside of the passed CLIPOBJ.


Arguments:

    pPDev            Pointer to the current PDEV

    pso              SURFOBJ to write to

    pco              CLIPOBJ to use when enuming paths

    ppo              PATHOBJ to stroke through clip path

    pptlBrushOrg     BRUSH origin

    pbo              BRUSH to stroke with

    rop4             ROP4 to use

    plineattrs       LINEATTRS structure that describes the styling for the line



Return Value:

    TRUE if sucessful FALSE if failed, If the path we are asked to stroke
          contains BEZIERS, this function will fail in order to allow the
          Engine to break the path down to line segments.

Author:


    2/01/94  JB

Revision History:


--*/

{
    PLOT_CLIPLINE   PlotClipLine;
    CLIPLINE        *pCurClipLine;
    RUN             *pCurRun;
    POINTFIX        ptsfx[2];
    POINTL          ptlCur;
    FIX             iStartInFX;
    FIX             iStopInFX;
    LONG            dx;
    LONG            dy;
    LONG            i;
    BOOL            bMore;
    BOOL            bXordered;
    BOOL            bFlipX;
    BOOL            bFlipY;


    //
    // First check for Beziers and if we have them fail the call since we
    // want straight line segments to stroke, with the appropriate style
    //

    if (ppo->fl & PO_BEZIERS) {

        PLOTDBG(DBG_STROKECLIPLINES,
                ("DoStrokePathByEnumingClipLines:Path had BEZ returning FALSE"));
        return(FALSE);
    }

    PLOTASSERT(1, "DoStrokeByEnumingClipLines: NO CLIPOBJ %p",
                  (pco != NULL) ,
                  (LONG_PTR)pco);

    PLOTASSERT(1, "DoStrokeByEnumingClipLines: CLIPOBJ is TRIVIAL (%lx)",
                  (pco->iDComplexity != DC_TRIVIAL) ,
                  (LONG)pco->iDComplexity );

    //
    // Send out the line attributes , so the residue will be calculated
    // correctly
    //

    DoSetupOfStrokeAttributes(pPDev, pptlBrushOrg, pbo, rop4, NULL);

    //
    // Initiate enumeration of the CLIPLINES by calling the Engine helper
    //

    PATHOBJ_vEnumStartClipLines(ppo, pco, pso, plineattrs);

    //
    // Start a loop to enum through all the available CLIPLINE structures
    //

    pCurClipLine = (CLIPLINE *)&PlotClipLine;

    do {

        //
        // Get the first batch of CLIPLINE structures then go to work on them
        //

        bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(PlotClipLine), pCurClipLine);

        //
        // Calculate dx and dy in order to determine if the line is Xordered or
        // Yordered this is needed because of the way the engine passes us RUNS
        // if dx > dy then the line is said to be Xordered and thus any given
        // RUN iStart and iStop values is a projection on the x axis. Given this
        // informatino we can calculate the adjoining Y coordinate and draw the
        // line appropriately.
        //

        dx = pCurClipLine->ptfxB.x - pCurClipLine->ptfxA.x;
        dy = pCurClipLine->ptfxB.y - pCurClipLine->ptfxA.y;



        if ( bFlipX = (dx < 0 )) {

            dx = -dx;
        }

        if ( bFlipY = (dy < 0 )) {

            dy = -dy;
        }


        //
        // Now calculate if the line is x ordered or y ordered
        //

        bXordered = (dx >= dy);

        PLOTDBG(DBG_STROKECLIPLINES,
                   ("DoStrokePathByEnumingClipLines:Compute ClipLine runs=%u, xordered %d",
                   pCurClipLine->c, bXordered ));

        //
        // Enum through all the given RUNS drawing with the pen down between any
        // iStart and iStop value in each RUN
        //

        for (i = 0, pCurRun = &(pCurClipLine->arun[0]);
             i < (LONG)pCurClipLine->c;
             i++, pCurRun++) {


            //
            // The value of iStart and iStop are always positive!! so
            // we must handle it ourselves, so the correct thing happens
            //

            iStartInFX = LTOFX(pCurRun->iStart);
            iStopInFX  = LTOFX(pCurRun->iStop);


            if (bFlipX ) {

                ptsfx[0].x = -iStartInFX;
                ptsfx[1].x = -iStopInFX;

            } else {

                ptsfx[0].x = iStartInFX;
                ptsfx[1].x = iStopInFX;
            }

            if (bFlipY ) {

                ptsfx[0].y = -iStartInFX;
                ptsfx[1].y = -iStopInFX;

            } else {

                ptsfx[0].y = iStartInFX;
                ptsfx[1].y = iStopInFX;
            }


            //
            // We must output the correct line attributes structure with the
            // correct calculated residue in order for this to work correctly
            //

            HandleLineAttributes(pPDev,
                                 plineattrs,
                                 &pCurClipLine->lStyleState,
                                 pCurRun->iStart);



            //
            // The calculations for the opposing coordinate varies based on the
            // ordering of the line. If the line is Xordered we calculate the
            // Y value, if itsYordered we calculate the X value. We do this
            // in order to determine the correct target coordinate. Since the
            // RUN is given to us as START and STOP, we must manually determine
            // what coordinate this represents inside the device coordinate
            // space. If the RUN is xordered, the x-coordinate is correct, and
            // the y-coordinate must be projected based on the ratio.
            //

            if (bXordered) {

                ptsfx[0].x +=  pCurClipLine->ptfxA.x;
                ptsfx[0].y =   MulDiv( ptsfx[0].y, dy, dx) +
                                                        pCurClipLine->ptfxA.y;
                ptsfx[1].x +=  pCurClipLine->ptfxA.x;
                ptsfx[1].y =   MulDiv( ptsfx[1].y, dy, dx) +
                                                        pCurClipLine->ptfxA.y;

            } else {

                ptsfx[0].x =   MulDiv(ptsfx[0].x, dx, dy) +
                                                        pCurClipLine->ptfxA.x;
                ptsfx[0].y +=  pCurClipLine->ptfxA.y;
                ptsfx[1].x =   MulDiv(ptsfx[1].x, dx, dy) +
                                                        pCurClipLine->ptfxA.x;
                ptsfx[1].y +=  pCurClipLine->ptfxA.y;
            }


            //
            // Do PE with pen up first, in order to move to the starting
            // position.
            //

            OutputString(pPDev, "PE<");

            if (!i) {

                //
                // If we are at first point then output that now.
                //

                ptlCur.x =
                ptlCur.y = 0;

                OutputString(pPDev, "=");
            }


            //
            // Stroke the segment with the pen down.
            //

            OutputXYParams(pPDev,
                           (PPOINTL)ptsfx,
                           (PPOINTL)NULL,
                           (PPOINTL)&ptlCur,
                           (UINT)2,
                           (UINT)1,
                           'F');

            OutputString(pPDev, ";");
        }

    } while (bMore);  // While we need to enum again..

    return(TRUE);
}




BOOL
DrvStrokePath(
    SURFOBJ     *pso,
    PATHOBJ     *ppo,
    CLIPOBJ     *pco,
    XFORMOBJ    *pxo,
    BRUSHOBJ    *pbo,
    PPOINTL     pptlBrushOrg,
    LINEATTRS   *plineattrs,
    MIX         Mix
    )

/*++

Routine Description:

    The driver's function for the StrokePath

Arguments:

    same as EngStrokePath


Return Value:

    TRUE if sucessful FALSE if failed


Author:

    8/18/92 -- t-alip
      Rewrote it.

    30-Nov-1993 Tue 22:21:51 updated  -by-  JB
        updated by DC

    04-Aug-1994 Thu 20:00:23 updated  -by-  DC
        bug# 22348



Revision History:

    31-Jan-1994 Tue 22:21:51 updated  -by-  JB
         Fixed dopolygon to pass in ROP4 not just MIX

--*/

{
    PPDEV   pPDev;
    BOOL    bRetVal;

    UNREFERENCED_PARAMETER(pxo);



    PLOTDBG(DBG_STROKEPATH, ("DrvStrokePath: Mix = %x", Mix));

    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvStrokePath: Invalid pPDev"));
        return(FALSE);
    }

    if (!(bRetVal = DoPolygon(pPDev,
                              NULL,
                              pco,
                              ppo,
                              pptlBrushOrg,
                              NULL,
                              pbo,
                              MixToRop4(Mix),
                              plineattrs,
                              FPOLY_STROKE) )) {

       //
       // Since DoPolygon failed, it can only be because we had both a complex
       // clip and a pathobj, so the thing to here is do the stroke via another
       // method using some of the engine helpers.
       //
       // We will also failed when STYLE LINE + DC_RECT when raster plotter is
       // used
       //

       bRetVal = DoStrokePathByEnumingClipLines( pPDev,
                                                 pso,
                                                 pco,
                                                 ppo,
                                                 pptlBrushOrg,
                                                 pbo,
                                                 MixToRop4(Mix),
                                                 plineattrs);




    }

    return(bRetVal);
}



BOOL
MovePen(
    PPDEV       pPDev,
    PPOINTFIX   pPtNewPos,
    PPOINTL     pPtDevPos
    )

/*++

Routine Description:

   This function sends the HPGL code for the requested pen.


Arguments:

    pPDev       - Pointer to the PDEV data structure

    pPtNewPos   - The location pen will move to, this is in 28.4 fix notation

    pPtDevPos   - The new device coordinate device position


Return Value:

    TRUE if sucessful FALSE otherwise


Author:

    1:04 on Tue 7 Nov 1989     -by-    MO
      Added this commentary, and area fill optimization code.

    30-Nov-1993 Tue 22:05:32 updated  -by-  DC
        Update, commented and clean up style

    16-Feb-1994 Wed 17:10:54 updated  -by-  DC
        Re-write to get rid of the physical position

Revision History:


--*/

{
    POINTL  ptDevPos;


    ptDevPos.x = FXTODEVL(pPDev, pPtNewPos->x);
    ptDevPos.y = FXTODEVL(pPDev, pPtNewPos->y);

    if (pPtDevPos) {

        *pPtDevPos = ptDevPos;
    }

    PLOTDBG( DBG_MOVEPEN,
             ("MovePen: Moving Absolute to FIX = [X=%d,%d] Device = [X=%d, Y=%d]",
             pPtNewPos->x,
             pPtNewPos->y,
             ptDevPos.x,
             ptDevPos.y ));


    return(OutputFormatStr(pPDev, "PE<=#D#D;", ptDevPos.x, ptDevPos.y));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\output.c ===
/*++


Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    output.c


Abstract:

    This module contains common plotter output functions to the spooler and
    printer.


Author:


    15-Nov-1993 Mon 19:36:04 updatee  -by-  DC
        clean up / update / re-write / debugging information

    30-Nov-1993 Tue 19:47:16 updated  -by-  DC
        update coordinate system during send_page

    21-Dec-1993 Tue 15:49:10 updated  -by-  DC
        organizied, and restructre pen cache, remove SendDefaultPalette()

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgOutput

#define DBG_SENDTRAILER     0x00000001
#define DBG_FLUSHBUF        0x00000002
#define DBG_FINDCACHEDPEN   0x00000004
#define DBG_CREATEPAL       0x00000008
#define DBG_FILLTYPE        0x00000010
#define DBG_PENUM           0x00000020
#define DBG_GETFINALCOLOR   0x00000040
#define DBG_SETCLIPWINDOW   0x00000080
#define DBG_OUTPUTXYPARMS   0x00000100
#define DBG_PAGE_HEADER     0x00000200
#define DBG_BESTPEN         0x00000400
#define DBG_BESTPEN_ALL     0x00000800


DEFINE_DBGVAR(0);

#define MIN_POSTER_SIZE     (1024L * 1024L * 12L)

#if DBG

static LPSTR    pHSFillTypeName[] = {

            "HS_HORIZONTAL",
            "HS_VERTICAL",
            "HS_FDIAGONAL",
            "HS_BDIAGONAL",
            "HS_CROSS",
            "HS_DIAGCROSS",
            "HS_SOLIDCLR",
            "HS_FT_USER_DEFINED"
        };

#endif

//
// Local #defines and data structures only used in this file
//
// Define, GDI fill types and the HPGL2 code used to simulate them
//

static const LPSTR  pHSFillType[] = {

            "3,#d,0",           // HS_HORIZONTAL       0    /* ----- */
            "3,#d,90",          // HS_VERTICAL         1    /* ||||| */
            "3,#d,135",         // HS_FDIAGONAL        2    /* \\\\\ */
            "3,#d,45",          // HS_BDIAGONAL        3    /* ///// */
            "4,#d,0",           // HS_CROSS            4    /* +++++ */
            "4,#d,45",          // HS_DIAGCROSS        5    /* xxxxx */
            "" ,                // HS_SOLIDCLR         6
            "11,#d",            // HS_FT_USER_DEFINED  7
        };

//
// HTPal tells the engine what formats we support for halftoning
//
// ulHTOutputFormat  = HT_FORMAT_4BPP
// ulPrimaryOrder    = PRIMARY_ORDER_CBA
// flHTFlags        &= ~HT_FLAG_OUTPUT_CMY
//

PALENTRY   HTPal[] = {

    //
    //       B     G     R     F
    //-----------------------------
        { 0x00, 0x00, 0x00, 0x00 },     // 0:K
        { 0x00, 0x00, 0xFF, 0x00 },     // 1:R
        { 0x00, 0xFF, 0x00, 0x00 },     // 2:G
        { 0x00, 0xFF, 0xFF, 0x00 },     // 3:Y
        { 0xFF, 0x00, 0x00, 0x00 },     // 4:B
        { 0xFF, 0x00, 0xFF, 0x00 },     // 5:M
        { 0xFF, 0xFF, 0x00, 0x00 },     // 6:C
        { 0xFF, 0xFF, 0xFF, 0x00 }      // 7:W
    };


//
// Define the RGB colors for the pen indices.  see inc\plotgpc.h for color
// assignment for the each PC_IDX_XXXX
//


PALENTRY    PlotPenPal[PC_IDX_TOTAL] = {

    //
    //      B   G   R  F
    //------------------------------------------
        { 255,255,255, 0 },     // PC_IDX_WHITE
        {   0,  0,  0, 0 },     // PC_IDX_BLACK
        {   0,  0,255, 0 },     // PC_IDX_RED
        {   0,255,  0, 0 },     // PC_IDX_GREEN
        {   0,255,255, 0 },     // PC_IDX_YELLOW
        { 255,  0,  0, 0 },     // PC_IDX_BLUE
        { 255,  0,255, 0 },     // PC_IDX_MAGENTA
        { 255,255,  0, 0 },     // PC_IDX_CYAN
        {   0,128,255, 0 },     // PC_IDX_ORANGE
        {   0,192,255, 0 },     // PC_IDX_BROWN
        { 255,  0,128, 0 }      // PC_IDX_VIOLET
    };

#define PE_BASE_BITS            6
#define PE_BASE_NUM             (DWORD)(1 << PE_BASE_BITS)
#define PE_TERM_ADDER           ((PE_BASE_NUM * 3) - 1)


#define DEF_FORMATSTR_CHAR      '#'
#define TOTAL_LOCKED_PENS       COUNT_ARRAY(HTPal)
#define PEF_CACHE_LOCKED        0x01


typedef struct _PENENTRY {
    WORD        Next;
    WORD        PenNumber;
    PALENTRY    PalEntry;
    } PENENTRY, FAR *PPENENTRY;

#define PCF_HAS_LOCKED_PENS     0x01

typedef struct _PENCACHE {
    WORD        Head;
    BYTE        Flags;
    BYTE        peFlags;
    WORD        CurCount;
    WORD        MaxCount;
    PENENTRY    PenEntries[1];
    } PENCACHE, FAR *PPENCACHE;

#define INTENSITY(r,g,b)        (BYTE)(((WORD)((r) * 30) +      \
                                        (WORD)((g) * 59) +      \
                                        (WORD)((b) * 11)) / 100)

#define SAME_PPALENTRY(p1,p2)   (((p1)->R == (p2)->R) &&        \
                                 ((p1)->G == (p2)->G) &&        \
                                 ((p1)->B == (p2)->B))



BYTE    HPRGBGamma2p0[] = {

              0,  //   0
             16,  //   1
             23,  //   2
             28,  //   3
             32,  //   4
             36,  //   5
             39,  //   6
             42,  //   7
             45,  //   8
             48,  //   9
             50,  //  10
             53,  //  11
             55,  //  12
             58,  //  13
             60,  //  14
             62,  //  15
             64,  //  16
             66,  //  17
             68,  //  18
             70,  //  19
             71,  //  20
             73,  //  21
             75,  //  22
             77,  //  23
             78,  //  24
             80,  //  25
             81,  //  26
             83,  //  27
             84,  //  28
             86,  //  29
             87,  //  30
             89,  //  31
             90,  //  32
             92,  //  33
             93,  //  34
             94,  //  35
             96,  //  36
             97,  //  37
             98,  //  38
            100,  //  39
            101,  //  40
            102,  //  41
            103,  //  42
            105,  //  43
            106,  //  44
            107,  //  45
            108,  //  46
            109,  //  47
            111,  //  48
            112,  //  49
            113,  //  50
            114,  //  51
            115,  //  52
            116,  //  53
            117,  //  54
            118,  //  55
            119,  //  56
            121,  //  57
            122,  //  58
            123,  //  59
            124,  //  60
            125,  //  61
            126,  //  62
            127,  //  63
            128,  //  64
            129,  //  65
            130,  //  66
            131,  //  67
            132,  //  68
            133,  //  69
            134,  //  70
            135,  //  71
            135,  //  72
            136,  //  73
            137,  //  74
            138,  //  75
            139,  //  76
            140,  //  77
            141,  //  78
            142,  //  79
            143,  //  80
            144,  //  81
            145,  //  82
            145,  //  83
            146,  //  84
            147,  //  85
            148,  //  86
            149,  //  87
            150,  //  88
            151,  //  89
            151,  //  90
            152,  //  91
            153,  //  92
            154,  //  93
            155,  //  94
            156,  //  95
            156,  //  96
            157,  //  97
            158,  //  98
            159,  //  99
            160,  // 100
            160,  // 101
            161,  // 102
            162,  // 103
            163,  // 104
            164,  // 105
            164,  // 106
            165,  // 107
            166,  // 108
            167,  // 109
            167,  // 110
            168,  // 111
            169,  // 112
            170,  // 113
            170,  // 114
            171,  // 115
            172,  // 116
            173,  // 117
            173,  // 118
            174,  // 119
            175,  // 120
            176,  // 121
            176,  // 122
            177,  // 123
            178,  // 124
            179,  // 125
            179,  // 126
            180,  // 127
            181,  // 128
            181,  // 129
            182,  // 130
            183,  // 131
            183,  // 132
            184,  // 133
            185,  // 134
            186,  // 135
            186,  // 136
            187,  // 137
            188,  // 138
            188,  // 139
            189,  // 140
            190,  // 141
            190,  // 142
            191,  // 143
            192,  // 144
            192,  // 145
            193,  // 146
            194,  // 147
            194,  // 148
            195,  // 149
            196,  // 150
            196,  // 151
            197,  // 152
            198,  // 153
            198,  // 154
            199,  // 155
            199,  // 156
            200,  // 157
            201,  // 158
            201,  // 159
            202,  // 160
            203,  // 161
            203,  // 162
            204,  // 163
            204,  // 164
            205,  // 165
            206,  // 166
            206,  // 167
            207,  // 168
            208,  // 169
            208,  // 170
            209,  // 171
            209,  // 172
            210,  // 173
            211,  // 174
            211,  // 175
            212,  // 176
            212,  // 177
            213,  // 178
            214,  // 179
            214,  // 180
            215,  // 181
            215,  // 182
            216,  // 183
            217,  // 184
            217,  // 185
            218,  // 186
            218,  // 187
            219,  // 188
            220,  // 189
            220,  // 190
            221,  // 191
            221,  // 192
            222,  // 193
            222,  // 194
            223,  // 195
            224,  // 196
            224,  // 197
            225,  // 198
            225,  // 199
            226,  // 200
            226,  // 201
            227,  // 202
            228,  // 203
            228,  // 204
            229,  // 205
            229,  // 206
            230,  // 207
            230,  // 208
            231,  // 209
            231,  // 210
            232,  // 211
            233,  // 212
            233,  // 213
            234,  // 214
            234,  // 215
            235,  // 216
            235,  // 217
            236,  // 218
            236,  // 219
            237,  // 220
            237,  // 221
            238,  // 222
            238,  // 223
            239,  // 224
            240,  // 225
            240,  // 226
            241,  // 227
            241,  // 228
            242,  // 229
            242,  // 230
            243,  // 231
            243,  // 232
            244,  // 233
            244,  // 234
            245,  // 235
            245,  // 236
            246,  // 237
            246,  // 238
            247,  // 239
            247,  // 240
            248,  // 241
            248,  // 242
            249,  // 243
            249,  // 244
            250,  // 245
            250,  // 246
            251,  // 247
            251,  // 248
            252,  // 249
            252,  // 250
            253,  // 251
            253,  // 252
            254,  // 253
            254,  // 254
            255   // 255
        };




LONG
BestMatchNonWhitePen(
    PPDEV   pPDev,
    LONG    R,
    LONG    G,
    LONG    B
    )

/*++

Routine Description:

    This functions locates the best match of a current pen given an RGB color.

Arguments:

    pPDev       - Pointer to our PDEV

    R           - Red color

    G           - Green color

    B           - Blue color

Return Value:

    LONG        - Pen Index, this function assumes 0 is always white and 1
                  up to the max are the rest of the pens.
Author:

    08-Feb-1994 Tue 00:23:36 created  -by-  DC

    23-Jun-1994 Thu 14:00:00 updated  -by-  DC
        Updated for non-white pen match

Revision History:


--*/

{
    PPENDATA    pPenData;
    PALENTRY    PenPalEntry;
    LONG        LeastDiff;
    WORD        ColorIdx;
    UINT        Count;
    UINT        RetIdx;
    UINT        i;

    PLOTDBGBLK(PALENTRY RetPal)



    if (IS_RASTER(pPDev)) {

        PLOTASSERT(0, "BestMatchNonWhitePen: This is not PEN plotter",
                !IS_RASTER(pPDev), 0);

        return(0);
    }

    if (!(pPenData = (PPENDATA)pPDev->pPlotGPC->Pens.pData)) {

        PLOTWARN(("BestMatchNonWhitePen: pPlotGPC->Pens.pData=NULL"));

        return(0);
    }

    if (!(Count = (UINT)pPDev->pPlotGPC->Pens.Count)) {

        PLOTWARN(("BestMatchNonWhitePen: pPlotGPC->Pens.Count=0"));
        return(0);
    }

    PLOTDBGBLK(RetPal.R = 255)
    PLOTDBGBLK(RetPal.G = 255)
    PLOTDBGBLK(RetPal.B = 255)

    RetIdx    = 0;
    LeastDiff = (3 * (256 * 256));

    for (i = 1; i < Count; i++, pPenData++) {

        if (((ColorIdx = pPenData->ColorIdx) < PC_IDX_TOTAL)    &&
            (ColorIdx != PC_IDX_WHITE)) {

            LONG    Temp;
            LONG    Diff;


            PenPalEntry = PlotPenPal[ColorIdx];

            Temp        = R - (LONG)((DWORD)PenPalEntry.R);
            Diff        = Temp * Temp;

            Temp        = G - (LONG)((DWORD)PenPalEntry.G);
            Diff       += Temp * Temp;

            Temp        = B - (LONG)((DWORD)PenPalEntry.B);
            Diff       += Temp * Temp;

            PLOTDBG(DBG_BESTPEN_ALL,
                    ("BestMatchNonWhitePen: %2ld: (%03ld:%03ld:%03ld) DIF=%ld",
                        i, (DWORD)PenPalEntry.R, (DWORD)PenPalEntry.G,
                        (DWORD)PenPalEntry.B, Diff));

            if (Diff < LeastDiff) {

                RetIdx = i;

                PLOTDBGBLK(RetPal = PenPalEntry)

                if (!(LeastDiff = Diff)) {

                    //
                    // We have exact match
                    //

                    break;
                }
            }
        }
    }

    if (!RetIdx) {

        PLOTWARN(("BestMatchNonWhitePen: Cannot find one make it WHITE"));
    }

    PLOTDBG(DBG_BESTPEN,
            ("BestMatchNonWhitePen: RGB=%02lx:%02lx:%02lx [%ld/%ld]=%02lx:%02lx:%02lx",
            R, G, B,
            (LONG)RetIdx, (LONG)pPDev->pPlotGPC->Pens.Count,
            (LONG)RetPal.R,
            (LONG)RetPal.G,
            (LONG)RetPal.B));

    return((LONG)RetIdx);
}




VOID
GetFinalColor(
    PPDEV       pPDev,
    PPALENTRY   pPalEntry
    )

/*++

Routine Description:

    This function modifies the input RGB color based on Grayscale and GAMMA

Arguments:

    pPDev       - Our PDEV

    pPalEntry   - Pointer to the PALENTRY of interest


Return Value:

    VOID but pPalEntry will be modified


Author:

    12-Apr-1994 Tue 14:03:37 created  -by-  DC


Revision History:


--*/

{
    PALENTRY    PalEntry = *pPalEntry;


    //
    // Do Gamma correction first
    //

    PalEntry.R = HPRGBGamma2p0[PalEntry.R];
    PalEntry.G = HPRGBGamma2p0[PalEntry.G];
    PalEntry.B = HPRGBGamma2p0[PalEntry.B];

    //
    // If were in GRAYSCALE mode we need to convert the color to grayscale
    //

    if (pPDev->PlotDM.dm.dmColor != DMCOLOR_COLOR) {

        PalEntry.R =
        PalEntry.G =
        PalEntry.B = (BYTE)INTENSITY(PalEntry.R, PalEntry.G, PalEntry.B);
    }

    PLOTDBG(DBG_GETFINALCOLOR,
            ("GetFinalColor: %hs RGB=%03ld:%03ld:%03ld -> Gamma=%03ld:%03ld:%03ld",
            (pPDev->PlotDM.dm.dmColor != DMCOLOR_COLOR) ? "MONO" : "COLOR",
            (DWORD)pPalEntry->R, (DWORD)pPalEntry->G, (DWORD)pPalEntry->B,
            (DWORD)PalEntry.R, (DWORD)PalEntry.G, (DWORD)PalEntry.B));

    //
    // Save it back and return
    //

    *pPalEntry = PalEntry;
}




LONG
FindCachedPen(
    PPDEV       pPDev,
    PPALENTRY   pPalEntry
    )

/*++

Routine Description:

    This function searhes the PenCache and returns the pen number if it is
    found. If it is not found, it will add the new pen to the cache and
    delete one if needed. Finally it returns the pen back to the caller.

Arguments:

    pPDev       - Pointer to the device PDEV

    pPalEntry   - Pointer to the PALENTRY for the specified RGB to locate.

Return Value:

    DWORD - a Pen number, if an error occurred  0 is returned

Author:

    21-Dec-1993 Tue 12:42:31 updated  -by-  DC
        re-write to make it as one pass search and adding. and commented

    30-Nov-1993 Tue 23:19:04 created  -by-  JB


Revision History:


--*/

{
    PPENCACHE   pPenCache;
    PPENENTRY   pPenStart;
    PPENENTRY   pCurPen;
    PPENENTRY   pPrevPen;
    PPENENTRY   pPrevDelPen;
    PALENTRY    PalEntry;
    LONG        Count;


    PLOTASSERT(1, "FindCahcedPen: The pPalEntry = NULL", pPalEntry, 0);


    if (!IS_RASTER(pPDev)) {

        //
        // Since this is the index type of palette, the PalEntry should be
        // also passed as index in the BGR's B component
        //

        Count = (LONG)RGB(pPalEntry->B, pPalEntry->G, pPalEntry->R);

        PLOTDBG(DBG_FINDCACHEDPEN, ("FindCachedPen: PEN PLOTTER=%ld", Count));

        if (Count > (LONG)((DWORD)pPDev->pPlotGPC->Pens.Count)) {

            PLOTERR(("FindCachedPen: INVALID Pen Color Index = %ld, Set to 1",
                    Count));

            Count = 1;
        }

        return(Count);
    }

    //
    // If we dont have a pen cache, nothing we can do but return an error.
    //

    if (!(pPenCache = (PPENCACHE)pPDev->pPenCache)) {

        PLOTERR(("FindCahcedPen: The pPenCache=NULL?"));
        return(0);
    }

    //
    // Make sure we set the flag correctly, the current PENENTRY flag is
    // located in peFlags field
    //

    PalEntry       = *pPalEntry;
    PalEntry.Flags = pPenCache->peFlags;

    //
    // Convert to final color through gamma/gray scale
    //

    GetFinalColor(pPDev, &PalEntry);

    pPenStart   = &(pPenCache->PenEntries[0]);
    pCurPen     = pPenStart + pPenCache->Head;
    pPrevPen    =
    pPrevDelPen = NULL;
    Count       = (LONG)pPenCache->CurCount;

    while (Count--) {

        if (SAME_PPALENTRY(&(pCurPen->PalEntry), &PalEntry)) {

            PLOTDBG(DBG_FINDCACHEDPEN,
                    ("FindCachedPen: Found Pen #%ld=%02lx:%02lx:%02lx, Linkes=%ld",
                            (DWORD)pCurPen->PenNumber,
                            (DWORD)PalEntry.R,
                            (DWORD)PalEntry.G,
                            (DWORD)PalEntry.B,
                            (DWORD)(pPenCache->CurCount - Count)));

            //
            // Found the color for that pen, exit this loop since we are done.
            //

            break;
        }

        //
        // Keep track of a pen that makes sense to delete in case we need
        // to delete an entry in order to add the new one that is not found.
        // If the entry was used for something longer term, it would be locked
        // and thus would not be a candidate for removal.
        //

        if (!(pCurPen->PalEntry.Flags & PEF_CACHE_LOCKED)) {

            //
            // If this pen is not locked then it must ok to delete if we need to
            //

            pPrevDelPen = pPrevPen;
        }

        pPrevPen = pCurPen;
        pCurPen  = pPenStart + pCurPen->Next;
    }

    //
    // If Count != -1 then we must have found a match, so we are done.
    //

    if (Count == -1) {

        //
        // We did not find the pen, so add it to the cache, remember if the
        // cache is full we must delete the last UNLOCKED entry
        //

        if (pPenCache->CurCount >= pPenCache->MaxCount) {

            //
            // Now delete the last un-locked entry, and add the new item to
            // that deleted entry
            //

            if (!(pPrevPen = pPrevDelPen)) {

                //
                // This is very strange, the last unlocked is the head?, this
                // is only possible if we have MaxCount = TOTAL_LOCKED_PENS + 1
                //

                PLOTDBG(DBG_FINDCACHEDPEN, ("FindCachedPen: ??? Last unlocked pen is Linked List Head"));

                pCurPen = pPenStart + pPenCache->Head;

            } else {

                pCurPen = pPenStart + pPrevPen->Next;
            }

            PLOTASSERT(1, "Pen #%ld is a LOCKED pen",
                        !(pCurPen->PalEntry.Flags & PEF_CACHE_LOCKED),
                        (DWORD)pCurPen->PenNumber);

            PLOTDBG(DBG_FINDCACHEDPEN,
                    ("FindCachedPen: REPLACE Pen #%ld=%02lx:%02lx:%02lx -> %02lx:%02lx:%02lx [%ld]",
                        (DWORD)pCurPen->PenNumber,
                        (DWORD)pCurPen->PalEntry.R, (DWORD)pCurPen->PalEntry.G,
                        (DWORD)pCurPen->PalEntry.B,
                        (DWORD)PalEntry.R, (DWORD)PalEntry.G, (DWORD)PalEntry.B,
                        (DWORD)(pCurPen - pPenStart)));
        } else {

            //
            // Increment the cached pen count
            //

            ++(pPenCache->CurCount);

            PLOTDBG(DBG_FINDCACHEDPEN,
                    ("FindCachedPen: ADD New Pen #%ld=%02lx:%02lx:%02lx [%ld/%ld]",
                        (DWORD)pCurPen->PenNumber,
                        (DWORD)PalEntry.R, (DWORD)PalEntry.G, (DWORD)PalEntry.B,
                        pPenCache->CurCount, pPenCache->MaxCount));
        }

        //
        // set the pen color in the cache and output the commands to the
        // plotter to add or change the current pen color setting
        //

        pCurPen->PalEntry = PalEntry;

        OutputFormatStr(pPDev, "PC#d,#d,#d,#d;", (LONG)pCurPen->PenNumber,
                        (LONG)PalEntry.R, (LONG)PalEntry.G, (LONG)PalEntry.B);
    }

    //
    // Now move the pCurPen to the head of the linked list
    //

    if (pPrevPen) {

        //
        // Only move the current pen to the link list head if not already so
        //

        PLOTDBG(DBG_FINDCACHEDPEN,
                ("FindCachedPen: MOVE Pen #%ld to Linked List Head [%ld --> %ld]",
                                (DWORD)pCurPen->PenNumber,
                                (DWORD)pPenCache->Head,
                                (DWORD)(pCurPen - pPenStart)));

        pPrevPen->Next  = pCurPen->Next;
        pCurPen->Next   = pPenCache->Head;
        pPenCache->Head = (WORD)(pCurPen - pPenStart);
    }

    return(pCurPen->PenNumber);
}




BOOL
PlotCreatePalette(
    PPDEV   pPDev
    )

/*++

Routine Description:


    This function creates a pen cache. It initializes the cache accordingly

Arguments:

    pPDev   - Pointer to the PDEV

Return Value:


    BOOL to indicate operation


Author:

    30-Nov-1993 Tue 23:23:17 created  -by-  DC

    21-Dec-1993 Tue 12:40:30 updated  -by-  DC
        Simplify version re-write

    23-Dec-1993 Thu 20:16:52 updated  -by-  DC
        Add NP number of pens command back to be able to use HPGL/2 palette


Revision History:


--*/

{
    if (!pPDev->pPlotGPC->MaxPens) {

        PLOTWARN(("PlotCreatePalette: Device MaxPens = 0"));

    } else if (IS_RASTER(pPDev)) {

        PPENCACHE   pPenCache;
        PPENENTRY   pPenEntry;
        DWORD       dw;
        UINT        Index;

        //
        // If this is the first time around then go ahead and alloc the memory
        // for our pen pallete cache. If the memory is already allocated then
        // we don't need to worry about it.
        //

        PLOTASSERT(1, "PlotCreatePalette: device has too few pens [%ld] available",
                        pPDev->pPlotGPC->MaxPens > TOTAL_LOCKED_PENS,
                        (DWORD)pPDev->pPlotGPC->MaxPens);

        dw = (DWORD)(sizeof(PENCACHE) +
                     sizeof(PENENTRY) * (pPDev->pPlotGPC->MaxPens - 1));

        if (pPDev->pPenCache == NULL) {

            PLOTDBG(DBG_CREATEPAL, ("PlotCreatePalette: Create NEW Palette"));

            pPDev->pPenCache = (LPVOID)LocalAlloc(LPTR, dw);

        } else {

            PLOTDBG(DBG_CREATEPAL, ("PlotCreatePalette: Re-Initialized Palette"));
        }

        if (pPenCache = (PPENCACHE)pPDev->pPenCache) {

            //
            // 1. Clear everything to zero
            // 2. Set MaxCount to the amount specified in the GPC
            // 3. Initialize the whole linked list as a linear list with
            //    the pen number set
            // 4. Make last index link to 0xffff to prevent us from using it
            //

            ZeroMemory(pPenCache, dw);

            pPenCache->MaxCount = (WORD)pPDev->pPlotGPC->MaxPens;

            for (Index = 0, pPenEntry = &(pPenCache->PenEntries[0]);
                 Index < (UINT)pPenCache->MaxCount;
                 Index++, pPenEntry++) {

                pPenEntry->Next      = (WORD)(Index + 1);
                pPenEntry->PenNumber = (WORD)Index;
            }

            pPenCache->PenEntries[pPenCache->MaxCount-1].Next = (WORD)0xffff;

            //
            // Before we add any pen palette we will establish the size of the
            // HPGL/2 Pen palette, and reset every pen back to our
            // standard which is used by gdi and the halftone Eng. (= 0.26mm wide)
            //

            OutputFormatStr(pPDev, "NP#d", (LONG)pPenCache->MaxCount);


            //
            // Now, add the entries we know we must keep around and make sure
            // they get locked.
            //

            PLOTDBG(DBG_CREATEPAL,
                    ("PlotCreatePalette: add all %ld standard locked pens",
                                                            TOTAL_LOCKED_PENS));

            pPenCache->peFlags = PEF_CACHE_LOCKED;

            for (Index = 0; Index < (LONG)TOTAL_LOCKED_PENS; Index++) {

                FindCachedPen(pPDev, (PPALENTRY)&HTPal[Index]);
            }


            //
            // Now set the flag telling us the cache contains locked pens, and
            // unlock the cache.
            //

            pPenCache->Flags   |= PCF_HAS_LOCKED_PENS;
            pPenCache->peFlags  = 0;

        } else {

            PLOTERR(("PlotCreatePalette: LocalAlloc(PENCACHE=%ld) failed", dw));
            return(FALSE);
        }

    } else {

        pPDev->BrightestPen = BestMatchNonWhitePen(pPDev, 255, 255, 255);

        PLOTDBG(DBG_CREATEPAL,
                ("PlotCreatePalette: Pen Plotter's Closest NON-WHITE PEN Index=ld",
                pPDev->BrightestPen));
    }

    return(TRUE);
}




UINT
AllocOutBuffer(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function allocates a buffer to be used for caching output data
    specific to this job. This keeps us from making calls to EngWritePrinter
    with very small amounts of data.

Arguments:

    pPDev   - Pointer to our pdev


Return Value:

    UINT count of how many bytes were allocated. If the buffer was already
    allocated, return the size. If an error occured (allocating memory)
    return 0.

Author:

    16-Nov-1993 Tue 07:39:46 created  -by-  DC


Revision History:


--*/

{
    if ((!(pPDev->pOutBuffer)) &&
        (!(pPDev->pOutBuffer = (LPBYTE)LocalAlloc(LPTR,
                                                  OUTPUT_BUFFER_SIZE + 16)))) {

        PLOTERR(("CreateOutputBuffer: LocalAlloc(OutBuffer=%ld) failed",
                                                        OUTPUT_BUFFER_SIZE));
        return(0);
    }

    pPDev->cbBufferBytes = 0;

    return(OUTPUT_BUFFER_SIZE);
}




VOID
FreeOutBuffer(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function frees the allocated output buffer

Arguments:

    pPDev   - pointer to the PDEV


Return Value:

    VOID


Author:

    16-Nov-1993 Tue 07:46:16 created  -by-  DC


Revision History:


--*/

{
    if (pPDev->pOutBuffer) {

        LocalFree((HLOCAL)pPDev->pOutBuffer);
        pPDev->pOutBuffer = NULL;
    }

    pPDev->cbBufferBytes = 0;
}





BOOL
FlushOutBuffer(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function flushes the current contents of the output buffer by writing
    the contents to the target device via EngWritePrinter.

Arguments:

    pPDev   - Pointer to the PDEV


Return Value:

    BOOL to indicate the result (TRUE == success)


Author:

    16-Nov-1993 Tue 09:56:27 created  -by-  DC


Revision History:

    14-Sep-1999 Tue 17:36:08 updated  -by-  Daniel Chou (danielc)
        Remove Checking for EngAbort(), this check in user mode will somehow
        return true at end of job and cause all output got cut off.

--*/

{
    if (PLOT_CANCEL_JOB(pPDev)) {

       return(FALSE);
    }

    if (pPDev->cbBufferBytes) {

        DWORD cbWritten;


        if (pPDev->cbBufferBytes > OUTPUT_BUFFER_SIZE) {

            PLOTASSERT(1, "OutputBytes: pPDev->cbBufferBytes (%ld) OVERRUN",
                        pPDev->cbBufferBytes <= OUTPUT_BUFFER_SIZE,
                        pPDev->cbBufferBytes);

            pPDev->cbBufferBytes  = OUTPUT_BUFFER_SIZE;
            pPDev->Flags         |= PDEVF_CANCEL_JOB;

            return(FALSE);
        }

        //
        // We need to be concerned with the job getting cancelled from
        // either the app or the spooler.
        // If the job is cancelled from the client app and we were printing
        // direct then EngCheckAbort() should return true.
        // If the job was cancelled from the spooler (ie printman) then
        // the write printer will fail.
        // Anywhere we do prolonged processing we need to look and verify
        // we break out of any loop if the job is cancelled. Currently
        // we do this in OutputBitmapSection, DoPolygon, DoRectFill, and
        // DrvTextOut when we are enuming our STROBJ glyphs
        //

        if ((!WritePrinter(pPDev->hPrinter,
                              pPDev->pOutBuffer,
                              pPDev->cbBufferBytes,
                              &cbWritten)) ||
            (cbWritten != pPDev->cbBufferBytes)) {

            //
            // Set the cancel flag in our pdev;
            //

            PLOTDBG(DBG_FLUSHBUF, ("FlushOutBuffer: WritePrinter() failure"));

            pPDev->Flags |= PDEVF_CANCEL_JOB;
            return(FALSE);
        }
#if 0
        if (EngCheckAbort(pPDev->pso)) {

            PLOTDBG(DBG_FLUSHBUF, ("FlushOutBuffer: EngCheckAbort return TRUE"));

            pPDev->Flags |= PDEVF_CANCEL_JOB;
            return(FALSE);
        }
#endif
        //
        // Reset to zero for clearing the buffer
        //

        pPDev->cbBufferBytes = 0;
    }

    return(TRUE);
}





LONG
OutputBytes(
    PPDEV   pPDev,
    LPBYTE  pBuf,
    LONG    cBuf
    )

/*++

Routine Description:

    This function output cBuf bytes from pBuf, by copying them into the
    output buffer (and flushing if required).

Arguments:

    pPDev   - Pointer to the PDEV

    pBuf    - Pointer to the buffer location

    cBuf    - Size of the buffer in bytes

Return Value:

    LONG    size of the buffer output, if < 0 then error occurred


Author:

    16-Nov-1993 Tue 08:18:41 created  -by-  DC

    07-Dec-1993 Tue 17:21:53 updated  -by-  DC
        re-write, so it do bulk copy rather than byte by byte

Revision History:


--*/

{
    LPBYTE  pOrgBuf = pBuf;
    LONG    cSize;


    while (cBuf > 0) {

        if (PLOT_CANCEL_JOB(pPDev)) {

            return(-1);
        }

        if (pPDev->cbBufferBytes >= OUTPUT_BUFFER_SIZE) {

            if (!FlushOutBuffer(pPDev)) {

                return(-1);
            }
        }

        if ((cSize = OUTPUT_BUFFER_SIZE - pPDev->cbBufferBytes) > cBuf) {

            cSize = cBuf;
        }

        CopyMemory(pPDev->pOutBuffer + pPDev->cbBufferBytes, pBuf, cSize);

        pPDev->cbBufferBytes += cSize;
        pBuf                 += cSize;
        cBuf                 -= cSize;
    }

    return((LONG)(pBuf - pOrgBuf));
}




LONG
OutputString(
    PPDEV   pPDev,
    LPSTR   pszStr
    )

/*++

Routine Description:


    This function outputs a null terminated string to the destination buffer

Arguments:

    pPDev   - Pointer to the PDEV

    pszStr  - Pointer to the NULL terminated string


Return Value:

    LONG    size of the string output, if < 0 then error occurred

Author:

    16-Nov-1993 Tue 08:20:55 created  -by-  DC

    07-Dec-1993 Tue 17:21:37 updated  -by-  DC
        re-write to call OutputBytes()

Revision History:


--*/

{
    return(OutputBytes(pPDev, pszStr, strlen(pszStr)));
}





LONG
LONGToASCII(
    LONG    Number,
    LPSTR   pStr16,
    BYTE    NumType
    )

/*++

Routine Description:

    This function convert a LONG number to ANSI ASCII

Arguments:

    Number  - 32-bit LONG number

    pStr16  - minimum 12 bytes to store the converted result


Return Value:

    LONG    - size of number string returned


Author:

    16-Nov-1993 Tue 08:24:07 created  -by-  DC

    16-Feb-1994 Wed 10:50:55 updated  -by-  DC
        Updated so upper case character treated as polyline encoded mode

Revision History:


--*/

{
    LPSTR   pOrgStr = pStr16;
    LPSTR   pNumStr;
    BYTE    NumStr[16];         // maximum for LONG are 1 sign + 10 digits


    if ((NumType >= 'A') && (NumType <= 'Z')) {

        //
        // Polyline encoded number
        //

        PLOTDBG(DBG_PENUM,  ("LONGToASCII: Convert PE Number %ld, Base=%ld",
                                    Number, PE_BASE_NUM));

        if (Number < 0) {

            Number = 1 - Number - Number;

        } else {

            Number += Number;
        }

        while (Number >= PE_BASE_NUM) {

            *pStr16++   = (BYTE)(63 + (Number & (PE_BASE_NUM - 1)));
            Number    >>= PE_BASE_BITS;
        }

        *pStr16++ = (BYTE)(PE_TERM_ADDER + Number);

        PLOTDBG(DBG_PENUM, ("LONGToASCII: LAST DIGIT: Number=%ld, [%02lx]",
                                Number, Number + PE_TERM_ADDER));


    } else {

        if (Number < 0) {

            Number    = -Number;
            *pStr16++ = '-';
        }

        pNumStr = NumStr;

        do {

            *pNumStr++ =  (CHAR)((Number % 10) + '0');

        } while (Number /= 10);

        //
        // Now reverse the digits
        //

        while (pNumStr > NumStr) {

            *pStr16++ = *(--pNumStr);
        }
    }

    *pStr16 = '\0';                 // null teriminated

    return((UINT)(pStr16 - pOrgStr));
}



LONG
OutputXYParams(
    PPDEV   pPDev,
    PPOINTL pPtXY,
    PPOINTL pPtOffset,
    PPOINTL pPtCurPos,
    UINT    cPoints,
    UINT    MaxCurPosSkips,
    BYTE    NumType
    )

/*++

Routine Description:

    This function outputs long numbers, and inserts a ',' between numbers
    (other than the last number)

Arguments:

    pPDev           - Pointer to the PDEV

    pPtXY           - Pointer to the array of POINTL data structure for the XY pair

    pPtOffset       - Points to the POINTL Offset to be add to the pPtXY, NULL if
                      no offset need to be added

    pPtCurPos       - Points to the POINTL Current position in <<DEVICE>>
                      coordinates to be substracted, this is used to output XY pair as
                      relative model, if the pointer is NULL then absolute model is
                      used, if the pointer is passed and return sucessful then the
                      final XY position is written back to this POINTL

    cPoints         - count of total pPtXY pairs need to be output

    MaxCurPosSkips  - How many points before the current position will be
                      updated

    NumType         - one of 'l', 'L', 'F', 'f', 'p', 'P', 'D', 'd'

Return Value:

    if sucessful it return the total number of bytes sent to the destination,
    if negative an error occurred

Author:

    17-Feb-1994 Thu 10:13:09 created  -by-  DC


Revision History:


--*/

{
    LONG    Size = 0;
    POINTL  ptNow;
    POINTL  ptTmp;
    POINTL  ptOffset;
    POINTL  ptCurPos;
    UINT    XCount;
    UINT    YCount;
    UINT    XIdxStart;
    UINT    CurPosSkips;
    BOOL    NeedComma;
    BYTE    XBuf[16];
    BYTE    YBuf[16];


    NeedComma = (BOOL)((NumType >= 'a') && (NumType <= 'z'));

    if (pPtOffset) {

        ptOffset = *pPtOffset;

    } else {

        ptOffset.x =
        ptOffset.y = 0;
    }

    XIdxStart = 0;

    if (pPtCurPos) {

        ptCurPos = *pPtCurPos;

    } else if (!NeedComma) {

        XBuf[0]   = '=';
        XIdxStart = 1;
    }

    CurPosSkips = MaxCurPosSkips;

    while (cPoints--) {

        ptNow.x = pPtXY->x + ptOffset.x;
        ptNow.y = pPtXY->y + ptOffset.y;

        ++pPtXY;

        XCount = XIdxStart;
        YCount = 0;

        switch (NumType) {

        case 'L':
        case 'l':

            ptNow.x = LTODEVL(pPDev, ptNow.x);
            ptNow.y = LTODEVL(pPDev, ptNow.y);
            break;

        case 'F':
        case 'f':

            ptNow.x = FXTODEVL(pPDev, ptNow.x);
            ptNow.y = FXTODEVL(pPDev, ptNow.y);
            break;

        case 'D':
        case 'd':

            break;

        case 'P':
        case 'p':

            if (ptNow.x >= 0) {

                XBuf[XCount++] = '+';
            }

            if (ptNow.y >= 0) {

                YBuf[YCount++] = '+';
            }

            break;

        default:

            PLOTASSERT(1,"OutputXYParams: Invalid Format type '%c'",0,NumType);
            return(-2);
        }

        if (pPtCurPos) {

            ptTmp    = ptNow;
            ptNow.x -= ptCurPos.x;
            ptNow.y -= ptCurPos.y;

            if (!(--CurPosSkips)) {

                ptCurPos    = ptTmp;
                CurPosSkips = MaxCurPosSkips;
            }

            if ((ptNow.x == 0) && (ptNow.y == 0) && (MaxCurPosSkips == 1)) {

                //
                // We do not need to move to the same position here
                //

                PLOTDBG(DBG_OUTPUTXYPARMS, ("OutputXYParms: ABS=(%ld, %ld), REL=(%ld, %ld) --- SKIP",
                            ptTmp.x, ptTmp.y, ptNow.x, ptNow.y));

                continue;

            } else {


                PLOTDBG(DBG_OUTPUTXYPARMS, ("OutputXYParms: ABS=(%ld, %ld), REL=(%ld, %ld)",
                        ptTmp.x, ptTmp.y, ptNow.x, ptNow.y));
            }

        } else {

            PLOTDBG(DBG_OUTPUTXYPARMS, ("OutputXYParms: ABS=(%ld, %ld)",
                        ptNow.x, ptNow.y));
        }


        XCount += LONGToASCII(ptNow.x, &XBuf[XCount], NumType);
        YCount += LONGToASCII(ptNow.y, &YBuf[YCount], NumType);

        if (NeedComma) {

            XBuf[XCount++] = ',';

            if (cPoints) {

                YBuf[YCount++] = ',';
            }
        }

        if ((OutputBytes(pPDev, XBuf, XCount) < 0)  ||
            (OutputBytes(pPDev, YBuf, YCount) < 0)) {

            return(-1);
        }

        Size += (XCount + YCount);
    }


    //
    // return back the new current position.
    //

    if (pPtCurPos) {

        *pPtCurPos = ptCurPos;
    }

    return(Size);
}




LONG
OutputLONGParams(
    PPDEV   pPDev,
    PLONG   pNumbers,
    UINT    cNumber,
    BYTE    NumType
    )

/*++

Routine Description:

    This functions outputs LONG numbers and inserts a ',' between all but the
    last numbers.

Arguments:

    pPDev       - Pointer to the PDEV

    pNumbers    - Point to the LONG arrary of numbers

    cNumber     - Total number to be output

    NumType     - one of 'l', 'L', 'F', 'f', 'p', 'P', 'D', 'd'

Return Value:

    The return value is the total number of bytes sent to the destination.
    If negative an error occurred.

Author:

    16-Nov-1993 Tue 09:37:32 created  -by-  DC

    16-Feb-1994 Wed 10:49:16 updated  -by-  DC
        Updated to add upper case of format char as in polyline encoded mode

Revision History:


--*/

{
    LONG    Size = 0;
    LONG    Count;
    LONG    Num;
    BOOL    NeedComma;
    BYTE    NumBuf[16];


    NeedComma = (BOOL)((NumType >= 'a') && (NumType <= 'z'));

    while (cNumber--) {

        Num   = *pNumbers++;
        Count = 0;

        switch (NumType) {

        case 'L':
        case 'l':

            Num = LTODEVL(pPDev, Num);
            break;

        case 'F':
        case 'f':

            Num = FXTODEVL(pPDev, Num);
            break;

        case 'D':
        case 'd':

            break;

        case 'P':
        case 'p':

            if (Num >= 0) {

                NumBuf[Count++] = '+';
            }

            break;

        default:

            PLOTASSERT(1,"OutputLONGParams: Invalid Format type '%c'",0,NumType);
            return(-2);
        }

        Count += LONGToASCII(Num, &NumBuf[Count], NumType);

        if ((NeedComma) && (cNumber)) {

            NumBuf[Count++] = ',';
        }

        if (OutputBytes(pPDev, NumBuf, Count) < 0) {

            return(-1);
        }

        Size += Count;
    }

    return(Size);
}

//
// The following #define code is used by the OutputFormatStrDELI() and
// OutputFormatStr() functions, it was easier to maintain this way
//
//  16-Feb-1994 Wed 10:50:24 updated  -by-  DC
//      Updated to add upper case of format char as in polyline encoded mode
//


#define DO_FORMATSTR(pPDev, NumFormatChar, pszFormat)                       \
{                                                                           \
    LPSTR   pLast;                                                          \
    va_list vaList;                                                         \
    LONG    Num;                                                            \
    LONG    Size;                                                           \
    LONG    Count;                                                          \
    BYTE    bCur;                                                           \
    BYTE    NumBuf[16];                                                     \
                                                                            \
    va_start(vaList, pszFormat);                                            \
                                                                            \
    Size  = 0;                                                              \
    pLast = pszFormat;                                                      \
                                                                            \
    while (bCur = *pszFormat++) {                                           \
                                                                            \
        if (bCur == NumFormatChar) {                                        \
                                                                            \
            if (Count = (LONG)(pszFormat - pLast - 1)) {                    \
                                                                            \
                Size += Count;                                              \
                                                                            \
                if (OutputBytes(pPDev, pLast, Count) < 0) {                 \
                                                                            \
                    return(-1);                                             \
                }                                                           \
            }                                                               \
                                                                            \
            Num    = va_arg(vaList, LONG);                                  \
            Count  = 0;                                                     \
                                                                            \
            switch (bCur = *pszFormat++) {                                  \
                                                                            \
            case 'L':                                                       \
            case 'l':                                                       \
                                                                            \
                Num = LTODEVL(pPDev, Num);                                  \
                break;                                                      \
                                                                            \
            case 'F':                                                       \
            case 'f':                                                       \
                                                                            \
                Num = FXTODEVL(pPDev, Num);                                 \
                break;                                                      \
                                                                            \
            case 'D':                                                       \
            case 'd':                                                       \
                                                                            \
                break;                                                      \
                                                                            \
            case 'P':                                                       \
            case 'p':                                                       \
                                                                            \
                if (Num >= 0) {                                             \
                                                                            \
                    NumBuf[Count++] = '+';                                  \
                }                                                           \
                                                                            \
                break;                                                      \
                                                                            \
            default:                                                        \
                                                                            \
                PLOTASSERT(1,"Invalid Format type '%c'",0,*(pszFormat-1));  \
                return(-2);                                                 \
            }                                                               \
                                                                            \
            Count += LONGToASCII(Num, &NumBuf[Count], bCur);                \
            Size  += Count;                                                 \
            pLast  = pszFormat;                                             \
                                                                            \
            if (OutputBytes(pPDev, NumBuf, Count) < 0) {                    \
                                                                            \
                return(-1);                                                 \
            }                                                               \
        }                                                                   \
    }                                                                       \
                                                                            \
    if (Count = (LONG)(pszFormat - pLast - 1)) {                            \
                                                                            \
        Size += Count;                                                      \
                                                                            \
        if (OutputBytes(pPDev, pLast, Count) < 0) {                         \
                                                                            \
            return(-1);                                                     \
        }                                                                   \
    }                                                                       \
                                                                            \
    va_end(vaList);                                                         \
                                                                            \
    return(Size);                                                           \
}



LONG
cdecl
OutputFormatStrDELI(
    PPDEV   pPDev,
    CHAR    NumFormatChar,
    LPSTR   pszFormat,
    ...
    )

/*++

Routine Description:

    This function outputs a string and optionally replaces '#' with LONG numbers
    passed on the stack

Arguments:

    pPDev           - Pointer to the PDEV

    NumFormatChar   - the character in the pszFormat string will be replaced
                      by LONG numbers on the stack

    pszFormat       - a ASCII string, only 'NumFormatChar' will be replaced
                      with a 32-bit LONG number on the stack

Return Value:

    LONG size of the string write to the output buffer, a negative number
    indicates an error


Author:

    16-Nov-1993 Tue 07:56:18 created  -by-  DC


Revision History:


--*/

{
    DO_FORMATSTR(pPDev, NumFormatChar, pszFormat);
}




LONG
cdecl
OutputFormatStr(
    PPDEV   pPDev,
    LPSTR   pszFormat,
    ...
    )

/*++

Routine Description:

    This function outputs the passed stack variables with the default format.

Arguments:

    pPDev       - Pointer to the PDEV

    pszFormat   - a ASCII string, only '#' will be replaced with a 32-bit
                  LONG number on the stack

Return Value:

    LONG size of the string written to the output buffer, a negative number
    siginals an error


Author:

    16-Nov-1993 Tue 07:56:18 created  -by-  DC


Revision History:


--*/

{
    DO_FORMATSTR(pPDev, DEF_FORMATSTR_CHAR, pszFormat);
}




BOOL
OutputCommaSep(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This funtion outputs a ',' (comma ) to the destination

Arguments:

    pPDev   - Pointer to the PDEV


Return Value:

    BOOL


Author:

    16-Nov-1993 Tue 10:46:42 created  -by-  DC


Revision History:


--*/

{
    return(OutputString(pPDev, ",") == 1);
}




VOID
ClearClipWindow(
    PPDEV pPDev
    )

/*++

Routine Description:

    This function clears the input window (plotter CLIP RECT) in the
    target device using the correct HPGL2 command.

Arguments:

    pPDev   - Pointer to the PDEV data structure

Return Value:

    VOID


Author:

    30-Nov-1993 Tue 19:56:09 updated  -by-  DC
        style clean up, commented

Revision History:


--*/

{
    if (pPDev->Flags & PDEVF_HAS_CLIPRECT) {

        pPDev->Flags &= ~PDEVF_HAS_CLIPRECT;
        OutputString(pPDev, "IW;");
    }
}



VOID
SetClipWindow(
    PPDEV   pPDev,
    PRECTL  pClipRectl
    )

/*++

Routine Description:

    This function sets the device clip rect to prevent objects drawn outside
    the rect from appearing on the target surface. The target device is doing
    the actual clipping in this case.

Arguments:

    pPDev       - Pointer to the PDEV data structure

    pClipRectl  - Pointer to the RECTL data structure which defines the clipping
                  rect to set inside the target device in engine units.

Return Value:

    VOID


Author:

    30-Nov-1993 Tue 19:56:45 created  -by-  DC
        style clean up, commented


Revision History:


--*/

{

    POINTL      ptlPlot;
    SIZEL       szlRect;
    RECTL       rclCurClip;


    ptlPlot.x  = LTODEVL(pPDev, pClipRectl->left);
    ptlPlot.y  = LTODEVL(pPDev, pClipRectl->top );
    szlRect.cx = LTODEVL(pPDev, pClipRectl->right)  - ptlPlot.x;
    szlRect.cy = LTODEVL(pPDev, pClipRectl->bottom ) - ptlPlot.y;

    if ((szlRect.cx) && (szlRect.cy)) {

        //
        // Here we try to be intelligent about sending down coordinates thate
        // are too small and would adversly affect the target device.
        //

        if (szlRect.cx < (LONG)pPDev->MinLToDevL) {

            PLOTWARN(("SetClipWindow: cxRect=%ld < MIN=%ld, Make it as MIN",
                            szlRect.cx, (LONG)pPDev->MinLToDevL));

            szlRect.cx = (LONG)pPDev->MinLToDevL ;
        }

        if (szlRect.cy < (LONG)pPDev->MinLToDevL) {

            PLOTWARN(("SetClipWindow: cyRect=%ld < MIN=%ld, Make it as MIN",
                            szlRect.cy, (LONG)pPDev->MinLToDevL));

            szlRect.cy = (LONG)pPDev->MinLToDevL ;
        }

    } else {

        PLOTWARN(( "SetClipWindow: Clipping out EVERYTHING...."));
    }

    rclCurClip.right  = (rclCurClip.left = ptlPlot.x) + szlRect.cx;
    rclCurClip.bottom = (rclCurClip.top = ptlPlot.y) + szlRect.cy;

    if ((pPDev->Flags & PDEVF_HAS_CLIPRECT)             &&
        (pPDev->rclCurClip.left   == rclCurClip.left)   &&
        (pPDev->rclCurClip.top    == rclCurClip.top)    &&
        (pPDev->rclCurClip.right  == rclCurClip.right)  &&
        (pPDev->rclCurClip.bottom == rclCurClip.bottom)) {

        PLOTDBG(DBG_SETCLIPWINDOW, ("SetClipWindow: PP%ld, (%ld, %ld)-(%d, %ld) *CACHED*",
                pPDev->Flags & PDEVF_PP_CENTER ? 0 : 1,
                rclCurClip.left, rclCurClip.top,
                rclCurClip.right, rclCurClip.bottom));

    } else {

        PLOTDBG(DBG_SETCLIPWINDOW, ("SetClipWindow: PP%ld, (%ld, %ld)-(%d, %ld)",
                pPDev->Flags & PDEVF_PP_CENTER ? 0 : 1,
                rclCurClip.left, rclCurClip.top,
                rclCurClip.right, rclCurClip.bottom));

        pPDev->rclCurClip  = rclCurClip;
        pPDev->Flags      |= PDEVF_HAS_CLIPRECT;

        if (pPDev->Flags & PDEVF_PP_CENTER) {

            --rclCurClip.right;
            --rclCurClip.bottom;
        }

        OutputFormatStr(pPDev,
                        "IW#d,#d,#d,#d",
                        rclCurClip.left,            // LL x
                        rclCurClip.bottom,          // LL y
                        rclCurClip.right,           // UR x
                        rclCurClip.top);            // UR y
    }
}




VOID
SetPixelPlacement(
    PPDEV   pPDev,
    UINT    SetMode
    )

/*++

Routine Description:

    This function sets the pixel placement to the center or edge. This
    defines if a pixel is drawn at the intersection of the vertical and
    horizontal coordinates, or on the edge.


Arguments:

    pPDev   - Pointer to the PDEV data structure

    SetMode - SPP_MODE_CENTER (Intersection of pixel GRID) or
              SPP_MODE_EDGE (non intersection of the pixel GRID)

              SPP_FORCE_SET, force to reset regardless of the current cached mode

Return Value:

    VOID


Author:

    25-Jan-1996 Thu 13:33:15 created  -by-  DC


Revision History:


--*/

{
    UINT    CurMode;


    CurMode = (pPDev->Flags & PDEVF_PP_CENTER) ? SPP_MODE_CENTER :
                                                 SPP_MODE_EDGE;

    if ((SetMode & SPP_FORCE_SET) ||
        ((SetMode & SPP_MODE_MASK) != CurMode)) {

        //
        // Set it now
        //

        if ((SetMode & SPP_MODE_MASK) == SPP_MODE_CENTER) {

            pPDev->Flags |= PDEVF_PP_CENTER;
            OutputString(pPDev, "PP0");

        } else {

            pPDev->Flags &= ~PDEVF_PP_CENTER;
            OutputString(pPDev, "PP1");
        }

        if (pPDev->Flags & PDEVF_HAS_CLIPRECT) {

            RECTL   rclCurClip = pPDev->rclCurClip;

            //
            // Make sure we really reset the clipping rectangle
            //

            --(pPDev->rclCurClip.left);

            SetClipWindow(pPDev, &rclCurClip);
        }
    }
}



BOOL
SetRopMode(
    PPDEV   pPDev,
    DWORD   Rop
    )

/*++

Routine Description:

    This function sends the Rop3 mode to the plotter if it is different than
    the current setting.


Arguments:

    pPDev   - Pointer to the PDEV

    Rop     - a Rop3 code


Return Value:

    TRUE/FALSE


Author:

    27-Jan-1994 Thu 18:55:54 created  -by-  DC


Revision History:


--*/

{
    if (pPDev->LastDevROP != (WORD)(Rop &= 0xFF)) {

        pPDev->LastDevROP = (WORD)Rop;

        if (Rop == 0xCC) {

            return(OutputFormatStr(pPDev, "MC0;"));

        } else {

            return(OutputFormatStr(pPDev, "MC1,#d;", (LONG)Rop));
        }
    }

    return(TRUE);
}




BOOL
SetHSFillType(
    PPDEV   pPDev,
    DWORD   HSFillTypeIndex,
    LONG    lParam
    )

/*++

Routine Description:

    This function set the fill type on the plotter only if not already so


Arguments:

    pPDev           - Pointer to our PDEV

    HSFillTypeIdx   - a index to pHSFillType, if invalid or out of range then
                      a solid color HS_SOLIDCLR is assumed

    lParam          - a Long parameter to be sent with FT

Return Value:

    TRUE/FALSE


Author:

    27-Jan-1994 Thu 19:00:21 created  -by-  DC


Revision History:


--*/

{
    WORD    Index;


    PLOTASSERT(1, "SetFillType: Invalid HSFillTypeIndex=%ld passed, set to SOLID",
                    HSFillTypeIndex <= HS_FT_USER_DEFINED, HSFillTypeIndex);


    if (HSFillTypeIndex > HS_FT_USER_DEFINED) {

        HSFillTypeIndex = HS_DDI_MAX;
    }

    if ((Index = (WORD)HSFillTypeIndex) == (WORD)HS_FT_USER_DEFINED) {

        if ((lParam < 0) || (lParam > RF_MAX_IDX)) {

            PLOTASSERT(1, "SetFillType: User defined ID [%ld] invalid, make it 1",
                            (lParam > 0) && (lParam <= RF_MAX_IDX), lParam);

            lParam = 1;
        }

        Index += (WORD)lParam;
    }

    if (Index != pPDev->LastFillTypeIndex) {

        PLOTDBG(DBG_FILLTYPE, ("SetFillType: Change %hs (%ld) -> %hs (%ld)",
                    (pPDev->LastFillTypeIndex > HS_FT_USER_DEFINED) ?
                        pHSFillTypeName[HS_FT_USER_DEFINED] :
                        pHSFillTypeName[pPDev->LastFillTypeIndex],
                    (pPDev->LastFillTypeIndex > HS_FT_USER_DEFINED) ?
                        pPDev->LastFillTypeIndex - HS_FT_USER_DEFINED :
                        lParam,
                    (Index > HS_FT_USER_DEFINED) ?
                        pHSFillTypeName[HS_FT_USER_DEFINED] :
                        pHSFillTypeName[Index],
                    (Index > HS_FT_USER_DEFINED) ?
                        Index - HS_FT_USER_DEFINED : lParam));

        pPDev->LastFillTypeIndex = Index;

        if ((!OutputString(pPDev, "FT")) ||
            (!OutputFormatStr(pPDev, pHSFillType[HSFillTypeIndex], lParam))) {

            return(FALSE);
        }

    } else {

        PLOTDBG(DBG_FILLTYPE, ("SetFillType: HSFillType is SAME = %hs",
                                (Index > HS_FT_USER_DEFINED) ?
                                    pHSFillTypeName[HS_FT_USER_DEFINED] :
                                    pHSFillTypeName[Index]));
    }

    return(TRUE);
}




BOOL
SendPageHeader(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function sends the initialization data to the device for each new
    page. Correct coordinate system and scaling is set.

Arguments:


    pPDev   - Pointer to the PDEV data structure for the page


Return Value:

    BOOL

Author:

    30-Nov-1993 Tue 19:53:13 updated  -by-  DC
        Re-write and update to correct system for the NT

    29-Nov-1993 Mon 23:55:43 updated  -by-  DC
        Re-write

    24-Nov-1993 Wed 22:38:10 updated  -by-  DC
        Using CurForm to replace the pform and PAPER_DIM

    06-Jan-1994 Thu 00:21:17 updated  -by-  DC
        Update for SPLTOPLOTUNITS() macro

    15-Feb-1994 Tue 09:59:34 updated  -by-  DC
        Set physical position and anchor corner after command is sent

    18-Mar-1994 Fri 12:58:24 updated  -by-  DC
        add ptlRTLCAP to zero at Page Reset

    24-May-1994 Tue 00:59:17 updated  -by-  DC
        SC command should range from 0 to DEVSIZE - 1

Revision History:


--*/

{
    PPLOTGPC    pPlotGPC;
    LONG        xMin;
    LONG        xMax;
    LONG        yMin;
    LONG        yMax;


    //
    // Compute minimum required pel size in PLOTDPI from RASTER DPI
    //
    // pPDev->MinLToDevL = (WORD)DIVRNDUP(__PLOT_DPI, _CURR_DPI);
    //

    pPDev->MinLToDevL = (WORD)LTODEVL(pPDev, 1);

    PLOTDBG(DBG_PAGE_HEADER,
            ("SendPageHeader: MinLToDevL=LTODEVL(1)=%ld", pPDev->MinLToDevL));

    //
    // Speedy access
    //

    pPlotGPC = pPDev->pPlotGPC;

    //
    // First, output the Init string that the pPlotGPC has. The PCD file is
    // responsible for all initialization upto and including the IN command.
    //

    if ((pPlotGPC->InitString.pData) &&
        (pPlotGPC->InitString.SizeEach)) {

        OutputBytes(pPDev,
                    (LPBYTE)pPlotGPC->InitString.pData,
                    (LONG)pPlotGPC->InitString.SizeEach);
    }

    //
    // DMRES_DRAFT         (-1)
    // DMRES_LOW           (-2)
    // DMRES_MEDIUM        (-3)
    // DMRES_HIGH          (-4)
    //
    // Assume BEST quality
    //

    xMax = 100;

    switch (pPDev->PlotDM.dm.dmPrintQuality) {

    case DMRES_DRAFT:

        xMax = 0;
        break;

    case DMRES_HIGH:

        xMax = 100;
        break;

    default:

        switch (pPlotGPC->MaxQuality) {

        case 2:

            xMax = 0;
            break;

        case 3:

            xMax = 50;
            break;

        default:

            xMax = 34;
            break;
        }

        if (pPDev->PlotDM.dm.dmPrintQuality == DMRES_MEDIUM) {

            xMax = 100 - xMax;
        }

        break;
    }

    OutputFormatStr(pPDev, "QL#d", xMax);

    //
    // PS: This command tells the target device what the hard clip limits should
    //     be. The target device will adjust the command we send if its beyond
    //     the real hard clip limits. Always send CY (lenght) first then CX
    //     (width)
    //
    // RO: Only sent to rotate the target device coordinate system if the
    //     PlotForm.Flags is set accordinly. This is because HPGL2 always
    //     assumes the LONGER side sent using the PS command is X in the
    //     standard coordinate system. Because of this behavior we may have
    //     to swap X and Y in order to correct the coordinate system.
    //
    // IP: This command defines where the users's unit origin and extent is.
    //     We set this so that the origin and extend is exactly the printable
    //     rectangle related to the HARD CLIP LIMITS (not the paper/form size)
    //
    // SC: This defines the user unit scaling. Currently we are 1:1 but use
    //     this command to flip the X or Y origin so we have the same
    //     coordinate system as GDI.
    //
    // ALL PlotForm UNITS are in 1/1000mm or Windows NT spooler forms units.
    //
    //
    // If we support transparent mode we want to make sure its off to begin
    // with, because the driver assumes its off.
    //

    if (IS_TRANSPARENT(pPDev)) {

        OutputString( pPDev, "TR0;");

    }

    OutputFormatStr(pPDev, "ROPS#d,#d",
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.PlotSize.cy),
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.PlotSize.cx));

    PLOTDBG(DBG_PAGE_HEADER, ("SendPageHeader: ROPS%ld,%ld%hs",
                SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.PlotSize.cy),
                SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.PlotSize.cx),
                (pPDev->PlotForm.Flags & PFF_ROT_COORD_L90) ? "RO90" : ""));

    if (pPDev->PlotForm.Flags & PFF_ROT_COORD_L90) {

        OutputString(pPDev, "RO90");
    }

    //
    // Compute the scaling amount and direction, if FLIP_X_COORD or a
    // FLIP_Y_COORD flags are set then we need to flip the scale in X or Y
    // direction.
    //

#if 1
    xMin =
    xMax = pPDev->HorzRes - 1;
    yMin =
    yMax = pPDev->VertRes - 1;
#else
    xMin =
    xMax = SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogExt.cx) - 1;
    yMin =
    yMax = SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogExt.cy) - 1;
#endif

    if (pPDev->PlotForm.Flags & PFF_FLIP_X_COORD) {

        xMax = 0;

    } else {

        xMin = 0;
    }

    if (pPDev->PlotForm.Flags & PFF_FLIP_Y_COORD) {

        yMax = 0;

    } else {

        yMin = 0;
    }

    //
    // IP   - to set the p1/p2
    // SC   - to scale it (only used to flip the HPGL/2 coordinate)
    // AC   - anchor point to default (0, 0)
    //

    OutputFormatStr(pPDev, "IP#d,#d,#d,#dSC#d,#d,#d,#dAC",
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogOrg.x),
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogOrg.y),
                        SPLTOPLOTUNITS(pPlotGPC,
                                       (pPDev->PlotForm.LogOrg.x +
                                            pPDev->PlotForm.LogExt.cx)) - 1,
                        SPLTOPLOTUNITS(pPlotGPC,
                                       (pPDev->PlotForm.LogOrg.y +
                                            pPDev->PlotForm.LogExt.cy)) - 1,
                        xMin, xMax, yMin, yMax);

    PLOTDBG(DBG_PAGE_HEADER, ("SendPageHeader: IP%ld,%ld,%ld,%ldSC%ld,%ld,%ld,%ldAC",
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogOrg.x),
                        SPLTOPLOTUNITS(pPlotGPC, pPDev->PlotForm.LogOrg.y),
                        SPLTOPLOTUNITS(pPlotGPC,
                                       (pPDev->PlotForm.LogOrg.x +
                                            pPDev->PlotForm.LogExt.cx)) - 1,
                        SPLTOPLOTUNITS(pPlotGPC,
                                       (pPDev->PlotForm.LogOrg.y +
                                            pPDev->PlotForm.LogExt.cy)) - 1,
                        xMin, xMax, yMin, yMax));
    //
    // Set RTL CAP back to zero, this is true after a EscE is sent
    //

    pPDev->ptlRTLCAP.x       =
    pPDev->ptlRTLCAP.y       =
    pPDev->ptlAnchorCorner.x =
    pPDev->ptlAnchorCorner.y = 0;
    pPDev->PenWidth.Integer  =
    pPDev->PenWidth.Decimal  = 0;

    //
    // Reset pen position to (0,0)
    //

    OutputString(pPDev, "PA0,0");

    if ((IS_COLOR(pPDev)) && (IS_RASTER(pPDev))) {

        //
        // !!!Work around some color device limitations in order to make
        // TR/ROP function correctly.
        //

        OutputString(pPDev, "PC1,255,0,0PC2,255,255,255SP1PD99,0SP2PD0,0PU");
    }

    //
    // Create the pallete, this will send out the pens as needed
    //

    if (!PlotCreatePalette(pPDev)) {

        PLOTERR(("DrvEnableSurface: PlotCreatePalette() failed."));
        return(FALSE);
    }

    //
    // Reset PW to 0
    //

    OutputString(pPDev, "WU0PW0");

    if (IS_RASTER(pPDev)) {


        //
        // If we are in poster mode, set up for it now.
        //

        if (pPDev->PlotDM.Flags & PDMF_PLOT_ON_THE_FLY) {

            xMin = SPLTOENGUNITS(pPDev, pPDev->PlotForm.PlotSize.cx);
            yMin = SPLTOENGUNITS(pPDev, pPDev->PlotForm.PlotSize.cy);

            xMax = GetBmpDelta(HTBMPFORMAT(pPDev), xMin);
            yMax = xMax * yMin;

            PLOTDBG(DBG_PAGE_HEADER,
                    ("SendPageHeader: ** POSTER MODE *** Scan=%ld bytes x cy (%ld) = %ld bytes",
                    xMax, yMin, yMax));

            if (yMax <= MIN_POSTER_SIZE) {

                pPDev->PlotDM.Flags &= ~PDMF_PLOT_ON_THE_FLY;

                PLOTDBG(DBG_PAGE_HEADER,
                        ("SendPageHeader: Size <= %ld bytes, Turn OFF Poster Mode",
                        MIN_POSTER_SIZE));
            }
        }

        OutputFormatStr(pPDev,
                        ";\033%0A\033*t#dR\033*v1N\033&a#dN\033%0B",
                        pPDev->pPlotGPC->RasterXDPI,
                        (pPDev->PlotDM.Flags & PDMF_PLOT_ON_THE_FLY) ? 1 : 0);
    }


    //
    // Whole surface can be drawn to
    //

    ClearClipWindow(pPDev);
    SetPixelPlacement(pPDev, SPP_FORCE_SET | SPP_MODE_EDGE);

    return(TRUE);
}



BOOL
SendPageTrailer(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function does any end of page commands, takes multiple copies into
    account, and ejects the page.

Arguments:

    pPDev   - Pointer to PDEV data structure

Return Value:

    TRUE if sucessful FALSE if failed.

Author:

    15-Feb-1994 Tue 09:56:58 updated  -by-  DC
        I move the physical position setting to the SendPageHeader

    30-Nov-1993 Tue 21:42:21 updated  -by-  DC
        clean up style, commented, Updated


Revision History:


--*/

{
    //
    // Store the pen back to the carousel and advance full page
    //

    OutputString(pPDev, "PUSPPG;");

    //
    // Check to see if were doing multiple copies and send them if we are
    //

    if (pPDev->PlotDM.dm.dmCopies > 1) {

        OutputFormatStr(pPDev, "RP#d;", (LONG)pPDev->PlotDM.dm.dmCopies - 1);
    }

    //
    // Flush the output buffer.
    //

    return(FlushOutBuffer(pPDev));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\path.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    path.h


Abstract:

    This module contains prototype and #defines for path.c


Author:

    18-Nov-1993 Thu 04:42:22 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _PLOTPATH_
#define _PLOTPATH_


typedef struct {
   CLIPLINE clipLine;
   RUN      runbuff[50];
} PLOT_CLIPLINE, *PPLOT_CLIPLINE;


BOOL
MovePen(
    PPDEV       pPDev,
    PPOINTFIX   pPtNewPos,
    PPOINTL     pPtDevPos
    );


BOOL
DoStrokePathByEnumingClipLines(
    PPDEV       pPDev,
    SURFOBJ     *pso,
    CLIPOBJ     *pco,
    PATHOBJ     *ppo,
    PPOINTL     pptlBrushOrg,
    BRUSHOBJ    *pbo,
    ROP4        rop4,
    LINEATTRS   *plineattrs
    );

#endif  // _PLOTPATH_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\pdevinfo.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    pdevinfo.h


Abstract:

    This module contains prototypes for pdevinfo.c


Author:

    30-Nov-1993 Tue 20:37:51 created  -by-  DC

    07-Dec-1993 Tue 00:21:25 updated  -by-  JB
        change dhsurf to dhpdev in SURFOBJ_GETPDEV

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

   Dec 06 1993, v-jimbr       Fixed to grab pdev from dhpdev instead of dhsurf

--*/


#ifndef _PDEVINFO_
#define _PDEVINFO_


PPDEV
ValidatePDEVFromSurfObj(
    SURFOBJ *
    );

#define SURFOBJ_GETPDEV(pso)    ValidatePDEVFromSurfObj(pso)


#endif  // _PDEVINFO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\page.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    page.c

Abstract:

    This module has the code that implements job boundary states. The bulk of
    the processing is in DrvStartPage and DrvSendPage.

Author:

    15:30 on Thu 04 Apr 1991    -by-    SC
        Took skeletal code from RASDD

    15-Nov-1993 Mon 19:39:03 updated  -by-  DC
        clean up / fixed / debugging information

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPage

#define DBG_STARTPAGE       0x00000001
#define DBG_SENDPAGE        0x00000002
#define DBG_STARTDOC        0x00000004
#define DBG_ENDDOC          0x00000008

DEFINE_DBGVAR(0);




BOOL
DrvStartPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Function called by NT GDI, to initiate a new page. This function gets
    called first. Before any drawing functions get called for the page.
    This function, should reset the page in the target device, so all
    drawing starts on a clean page. This is also used to sync up our
    internal representation of cached info, in order to send out the
    correct data for the first drawing objects. Things like current position,
    current color, etc.

Arguments:

    pso - Pointer to the SURFOBJ which belong to this driver


Return Value:

    TRUE if sucessful FALSE otherwise

Author:

    15-Feb-1994 Tue 09:58:26 updated  -by-  DC
        Move PhysPosition and AnchorCorner to the SendPageHeader where the
        commmand is sent.

    30-Nov-1993 Tue 23:08:12 created  -by-  DC


Revision History:


--*/

{
    PPDEV   pPDev;


    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvStartPage: invalid pPDev"));
        return(FALSE);
    }

    //
    // initialize some PDEV values for the current plotter state
    // this will force the correct items to get selected in the
    // target device, since these variables are set to undefined states.
    //

    pPDev->CurPenSelected    = -1;
    pPDev->LastDevROP        = 0xFFFF;
    pPDev->Rop3CopyBits      = 0xCC;
    pPDev->LastFillTypeIndex = 0xFFFF;
    pPDev->LastLineType      = PLOT_LT_UNDEFINED;
    pPDev->DevBrushUniq      = 0;

    ResetDBCache(pPDev);

    return(SendPageHeader(pPDev));
}




BOOL
DrvSendPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Called when the drawing has completed for the current page. We now
    send out the necessary codes to image and output the page on the
    target device.

Arguments:

    pso - Pointer to the SURFOBJ which belong to this driver


Return Value:

    TRUE if sucessful FALSE otherwise

Author:

    30-Nov-1993 Tue 21:34:53 created  -by-  DC


Revision History:


--*/

{
    PPDEV   pPDev;


    //
    // Since all the commands that rendered the page have already been
    // sent to the target device, all that is left is to inform the
    // target device to eject the page. With some devices this may cause
    // all the drawing commands that were stored to be executed now.
    //

    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvSendPage: invalid pPDev"));
        return(FALSE);
    }

    if (pso->iType == STYPE_DEVICE) {

        return(SendPageTrailer(pPDev));

    } else {

        PLOTRIP(("DrvSendPage: Invalid surface type %ld passed???",
                                    (LONG)pso->iType));
        return(FALSE);
    }
}




BOOL
DrvStartDoc(
    SURFOBJ *pso,
    PWSTR   pwDocName,
    DWORD   JobId
    )

/*++

Routine Description:

    This function is called once at the begining of a job. Not much processing
    for the current driver.

Arguments:

    pso         - Pointer to the SURFOBJ which belong to this driver

    pwDocName   - Pointer to the document name to be started

    JobID       - Job's ID


Return Value:

    BOOL

Author:

    16-Nov-1993 Tue 01:55:15 updated  -by-  DC
        re-write

    08-Feb-1994 Tue 13:51:59 updated  -by-  DC
        Move to StartPage for now


Revision History:


--*/

{
    PPDEV   pPDev;


    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvStartDoc: invalid pPDev"));
        return(FALSE);
    }


    PLOTDBG(DBG_STARTDOC,("DrvStartDoc: DocName = %s", pwDocName));


    return(TRUE);
}




BOOL
DrvEndDoc(
    SURFOBJ *pso,
    FLONG   Flags
    )

/*++

Routine Description:

    This function get called to signify the end of a document. Currently
    we don't do any processing here. However if there was any code that
    should be executed only once at the end of a job, this would be the
    place to put it.


Arguments:

    pso     - Pointer to the SURFOBJ for the device

    Flags   - if ED_ABORTDOC bit is set then the document has been aborted


Return Value:


    BOOLLEAN to specified if function sucessful


Author:

    30-Nov-1993 Tue 21:16:48 created  -by-  DC


Revision History:


--*/

{
    PPDEV   pPDev;


    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvEndDoc: invalid pPDev"));
        return(FALSE);
    }

    PLOTDBG(DBG_ENDDOC,("DrvEndDoc called with Flags = %08lx", Flags));

    return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\pencolor.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    pencolor.h


Abstract:

    This module contains defines for pencolor.c


Author:

    15-Jan-1994 Sat 04:50:57 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PENCOLOR_
#define _PENCOLOR_


LONG
GetColor(
    PPDEV       pPdev,
    BRUSHOBJ    *pbo,
    LPDWORD     pColorFG,
    PDEVBRUSH   *ppDevBrush,
    ROP4        Rop4
    );


VOID
SelectColor(
    PPDEV       pPDev,
    DWORD       Color,
    INTDECIW    PenWidth
    );

#endif  // _PENCOLOR_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\pdevinfo.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    pdevinfo.c


Abstract:

    This module contains functions to get / validate the PDEV data structure.
    This structure, is initialized by the driver at DrvEnablePDEV time. The
    handle (or pointer) to is passed to most of the drivers DrvXXX exported
    functions. This is how a driver maintains state, about various items
    of interest in the rendering process.


Author:

    30-Nov-1993 Tue 20:37:26 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPDEVInfo

#define DBG_VALIDATE_PDEV   0x00000001


DEFINE_DBGVAR(0);





PPDEV
ValidatePDEVFromSurfObj(
    SURFOBJ    *pso
    )

/*++

Routine Description:

    This function validates the PDEV to see if it belong to this driver and
    checks to see if it is still usable. It also moves the passed SURFOBJ
    in the data structure which is needed for the driver to occasionally call
    EngCheckAbort, to see if the job has been cancelled.


Arguments:

    pPDev   - Pointer to the PDEV data structure to be validate

Return Value:

    return the passed in PDEV pointer if sucessful, return NULL if failed,
    if it return NULL it will also log the INVALID_HANDLE error code


Author:

    30-Nov-1993 Tue 20:39:12 created  -by-  DC


Revision History:


--*/

{
    PPDEV pPDev;


    pPDev = ((PPDEV)(((SURFOBJ *)pso)->dhpdev));


    if (pPDev) {

        //
        // Look for start marker, size of the data structure, and end marker.
        //

        if (pPDev->PDEVBegID == PDEV_BEG_ID) {

            if (pPDev->SizePDEV == sizeof(PDEV)) {

                if (pPDev->PDEVEndID == PDEV_END_ID) {

                    //
                    // Okay its valid so record the surfobj so we can call
                    // EngCheckAbort() in our output functions
                    //

                    pPDev->pso = pso;

                    //
                    // Check to see if the app or the spooler has canceled
                    // the job, if it has set our cancel bit and fail this
                    // call.
                    //

                    if (EngCheckAbort(pso)) {
                       pPDev->Flags |= PDEVF_CANCEL_JOB;
                       PLOTDBG(DBG_VALIDATE_PDEV,
                                 ("ValidatePDEV: EngCheckAbort returns TRUE"));
                       return(NULL);
                    }

                    return(pPDev);

                } else {

                    PLOTRIP(("ValidatePDEV: Invalid PDEV End ID (%08lx)",
                                                            pPDev->PDEVEndID));
                }

            } else {

                PLOTRIP(("ValidatePDEV: Invalid PDEV size (%ld)",
                                                        pPDev->SizePDEV));
            }

        } else {

            PLOTRIP(("ValidatePDEV: Invalid PDEV Begin ID (%08lx)",
                                        pPDev->PDEVBegID));
        }

    } else {

        PLOTRIP(("ValidatePDEV: NULL pPDev"));
    }

    SetLastError(ERROR_INVALID_HANDLE);
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\pencolor.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    pencolor.c


Abstract:

    This module contains functions to allow you to get the color of a passed
    brush, as well as select the current color to draw with in the target
    device.

Author:

    15-Jan-1994 Sat 04:49:41 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPenColor

#define DBG_GETCLR          0x00000001
#define DBG_SELECTCOLOR     0x00000002

DEFINE_DBGVAR(0);





LONG
GetColor(
    PPDEV       pPDev,
    BRUSHOBJ    *pbo,
    LPDWORD     pColorFG,
    PDEVBRUSH   *ppDevBrush,
    ROP4        Rop4
    )

/*++

Routine Description:

    Realize the brush color and return the color


Arguments:

    pPDev       - Pointer to our DEV

    pbo         - Engine brush object

    pColorFG    - pointer to the ULONG to received forground color, NULL if
                  not needed

    ppDevBrush  - Pointer to the location to received brush, NULL if not
                  needed

    Rop4        - Rop4 to be used, this function looks at this in order to
                  determine if the brush can be used with the HPGL2 cmds or
                  that the brush will have to be simulated.

Return Value:

    LONG    > 0     The Brush is compatible with device format (Fill command)
            = 0     Failed
            < 0     The brush must send to device via a bitblt

Author:

    13-Jan-1994 Thu 20:18:49 created  -by-  DC

    15-Jan-1994 Sat 06:58:56 updated  -by-  DC
        Change parameters and return value

    16-May-1994 Mon 15:59:45 updated  -by-  DC
        Adding PDEV

Revision History:


--*/

{
    PDEVBRUSH   pDevBrush = NULL;
    LONG        RetVal    = 1;
    DWORD       SolidColor = 0xFFFFFF;
    DWORD       RopBG;
    DWORD       RopFG;


    //
    // Get the ROP for the foureground and background. This information is
    // used to determine if the brush has to be simulated, or can be
    // used with selectable pens in the target device.

    RopBG = ROP4_BG_ROP(Rop4);
    RopFG = ROP4_FG_ROP(Rop4);

    //
    // Get the current color and select the appropriate pen, this should
    // ONLY be a solid color as we don't support stroking with arbitrary
    // brushes.
    //

    if (pbo) {

        //
        // get the brush realization, and select a pen.
        // If the BRUSHOBJ's iSolidColor field is a valid color, then
        // we must do a solid fill with that pen.  Otherwise, we must
        // check the realization of the brush to do a pattern fill.
        //
        // To return a Fillable pattern by DoFill, one of the following conditions
        // must be true and in this sequence
        //
        //  1. SOLID COLOR
        //  2. STANDARD PATTERN
        //  3. Device compatible bitmap
        //

        if ((SolidColor = (DWORD)pbo->iSolidColor) == CLR_INVALID) {

            PLOTDBG(DBG_GETCLR, ("iSolodColor == CLR_INVALID, pBrush=%08lx",
                                                                pbo->pvRbrush));

            //
            // This is a pattern brush, but we will just use its
            // foreground color.
            //

            if ((pDevBrush = (PDEVBRUSH)pbo->pvRbrush) ||
                (pDevBrush = BRUSHOBJ_pvGetRbrush(pbo))) {


                //
                // Grab the foreground color and use it.
                //

                SolidColor = pDevBrush->ColorFG;


                if ((pDevBrush->PatIndex < HS_DDI_MAX) ||
                    (pDevBrush->pbgr24)) {

                    ;

                } else {

                    PLOTDBG(DBG_GETCLR, ("GETColor: NOT DEVICE_PAT"));

                    RetVal = -1;
                }

            } else {

                RetVal = 0;
                PLOTDBG(DBG_GETCLR, ("GetColor(): couldn't realize brush!"));
            }

        } else {

            PLOTDBG(DBG_GETCLR,
                    ("GETColor: is a SOLID COLOR=%08lx", pbo->iSolidColor));
        }

    } else if ((RopFG == 0x00) || (RopBG == 0x00)) {

        if (IS_RASTER(pPDev)) {

            SolidColor = 0x0;

        } else {

            //
            // If we are not a raster device (which supports overprint)
            // match the best non-white pen, in order to fill with.
            //

            SolidColor = (DWORD)BestMatchNonWhitePen(pPDev, 0, 0, 0);

            PLOTDBG(DBG_GETCLR,
                    ("GETColor: pbo=NULL, BLACK Pen Idx=%ld", SolidColor));

        }
    }

    if ((!IS_RASTER(pPDev)) && (SolidColor == 0x00FFFFFF)) {

        SolidColor = WHITE_INDEX;

        PLOTDBG(DBG_GETCLR,
                ("GETColor: Pen plotter using WHITE COLOR Idx=%ld", SolidColor));
    }

    if (pColorFG) {

        *pColorFG = SolidColor;
    }

    if (ppDevBrush) {

        *ppDevBrush = pDevBrush;
    }

    return(RetVal);
}





VOID
SelectColor(
    PPDEV       pPDev,
    DWORD       Color,
    INTDECIW    PenWidth
    )

/*++

Routine Description:

    This function is responsible for handling the mechanism of supporting RGB
    colors on plotters that support this. This is done by using a preset pallete
    position that the engine does not know about, and constantly update it with
    the correct color.

Arguments:

    pPDev       - Pointer to the PDEV data structure

    Color       - Color to be selected

    PenWidth    - INTDECIW data structrue to specified the pen width

Return Value:

    VOID


Author:

    30-Nov-1993 Tue 22:15:12 created  -by-  DC

    12-Apr-1994 Tue 14:35:44 updated  -by-  DC
        Update to take pen plotter into account and take care the error cases

Revision History:


--*/

{

    PLOTASSERT(1, "SelectColor: Invalid RGB Color [%08lx] for Raster DEVICE",
                Color != CLR_INVALID, Color);

    if (Color == CLR_INVALID) {

        //
        // Make it white
        //

        Color = (DWORD)(IS_RASTER(pPDev) ? 0x00FFFFFF : WHITE_INDEX);
    }

    if (IS_RASTER(pPDev)) {

        Color = (DWORD)FindCachedPen(pPDev, (PPALENTRY)&Color);

    } else {

        if (Color > (DWORD)pPDev->pPlotGPC->Pens.Count) {

            Color = (DWORD)pPDev->BrightestPen;

            PLOTDBG(DBG_SELECTCOLOR,
                    ("SelectColor: !!! Match to Closest WHITE PEN=%ld", Color));

            PLOTASSERT(1, "SelectColor: Invalid Pen Index [%08ld] for PEN DEVICE",
                        (Color <= (DWORD)pPDev->pPlotGPC->Pens.Count), Color);

            if (Color > (DWORD)pPDev->pPlotGPC->Pens.Count) {

                Color = WHITE_INDEX;
            }
        }
    }

    //
    // Verify were not selecting the current pen
    //

    if (Color != (DWORD)pPDev->CurPenSelected) {

        PLOTDBG(DBG_SELECTCOLOR,
                ("SelectColor: Current Pen [%ld] != new PEN [%ld]",
                                            pPDev->CurPenSelected, Color));

        OutputFormatStr(pPDev,"SP#d", (LONG)Color);
        pPDev->CurPenSelected = (LONG)Color;

    } else {

        PLOTDBG(DBG_SELECTCOLOR,
                ("SelectColor: Current Pen == new PEN [%ld]", Color));
    }

    //
    // Set the correct pen width in the target device. This will change
    // the pen width for all pens.
    //

    if ((PenWidth.Integer != pPDev->PenWidth.Integer) ||
        (PenWidth.Decimal != pPDev->PenWidth.Decimal)) {

        //
        // Now send the optimal pen width number command to the target device.
        //

        OutputString(pPDev, "PW");

        if ((PenWidth.Integer) || (PenWidth.Decimal == 0)) {

            //
            // This will make the following cases
            //
            // 1. 0.0 ---> 0
            // 2. 3.2 ---> 3
            // 3. 3.0 ---> 3

            OutputFormatStr(pPDev, "#d", PenWidth.Integer);
        }

        if (PenWidth.Decimal) {

            //
            // Do all DECI part as .xx
            //

            OutputFormatStr(pPDev, ".#d", PenWidth.Decimal);
        }

        PLOTDBG(DBG_SELECTCOLOR,
                ("SelectColor: PEN WIDTH Change from %ld.%ldmm to %ld.%ldmm",
                (DWORD)pPDev->PenWidth.Integer, (DWORD)pPDev->PenWidth.Decimal,
                (DWORD)PenWidth.Integer, (DWORD)PenWidth.Decimal));

        //
        // Update the pen width cache
        //

        pPDev->PenWidth = PenWidth;


    } else {

        PLOTDBG(DBG_SELECTCOLOR, ("SelectColor: PEN WIDTH is SAME = %ld.%ld",
                                        PenWidth.Integer, PenWidth.Decimal));
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\plotform.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    plotform.h


Abstract:

    This module contains prototypes for the plotform.c


Author:

    30-Nov-1993 Tue 20:32:06 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _PLOTFORM_
#define _PLOTFORM_


BOOL
SetPlotForm(
    PPLOTFORM       pPlotForm,
    PPLOTGPC        pPlotGPC,
    PPAPERINFO      pCurPaper,
    PFORMSIZE       pCurForm,
    PPLOTDEVMODE    pPlotDM,
    PPPDATA         pPPData
    );

#endif  // _PLOTFORM_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\plotters.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    plotters.h


Abstract:

    This module contains basic plotter infomation to be includes by most of
    the source file

    This module contains the bulk of the plotter driver defines. It is included
    by most modules.

Author:

    18-Nov-1993 Thu 01:25:51 created  -by-  DC/v-jimbr
        Wrote for the Windows NT Daytona.

    07-Dec-1993 Tue 01:14:40 updated  -by-  DC
        another round of clean up, adding new PDEV stuff

    21-Dec-1993 Tue 10:58:03 updated  -by-  DC
        Change PLOTFORM's flags
        Replaced PAL_BGR_ENTRY with PALENTRY and moved all pen cached stuff to
        local output.c

    06-Jan-1994 Thu 00:05:56 updated  -by-  DC
        remove PLOTTER_UNIT_DPI and used pPlotGPC->PlotXDPI in GPC,
        change PDEV's wCurPenSelected to CurPenSelected (WORD to LONG) to have
        DWORD aligned for next field in the structure.

    14-Jan-1994 Fri 20:24:12 updated  -by-  DC
        Change DEVBRUSH

    19-Jan-1994 Wed 14:28:45 updated  -by-  DC
        Adding hack to handle EngStretchBlt() to our own temp surfobj

    27-Jan-1994 Thu 23:38:48 updated  -by-  DC
        Add DBCACHE structure, modify PDEV to handle cached fill type and
        cached User defined pattern

    03-Mar-1994 Thu 09:40:36 updated  -by-  DC
        Remove dead stufff which confused, adding minimum required DDI version
        for this plotter driver to run

    18-Mar-1994 Fri 12:58:24 updated  -by-  DC
        Adding ptlRTLCAP in PDEV to catch the RTL relative position problem
        Adding PLOTF_RTL_NO_DPI_XY, PLOTF_RTLMONO_NO_CID and
        PLOTF_RTLMONO_FIXPAL flags

    12-Apr-1994 Tue 14:14:15 updated  -by-  DC
        Changed DIVRNDUP from +0.5 round up to round to next smallest integer

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]

    13-Apr-1994 Wed 14:29:57 updated  -by-  DC

        FXTOL(x) is assumed to be (X >> 4) (Defined by WINDDI.H)
        LTOFX(x) is (X << 4)

        IF WINDDI.H changes that definition then we must change LTOFX and
        FXTOL2(x)

Revision History:


--*/

#ifndef _PLOTTER_MAIN_HEADER_
#define _PLOTTER_MAIN_HEADER_

#define DRIVER_VERSION      0x0500

#define COUNT_ARRAY(x)      (sizeof((x)) / sizeof((x)[0]))
#define ABS(Value)          ((Value) > 0 ? (Value) : (-(Value)))
#define DW_ALIGN(x)         (((DWORD)(x) + 3) & ~(DWORD)3)


//
// In order to have the style units mean something we break them up
// into units that are 1/25 of an inch.
//
#define PLOT_STYLE_STEP(p) ((p)->lCurResolution / 25)

//
// Define where WHITE is when the plotter driver is a Pallete device
//
#define WHITE_INDEX         0


//
// The PALENTRY is the correct RGB order for the plotter driver, if any changes
// need to be made to the order then only this structure needs to be changed.
//
// CURRENTLY it is in Blue/Green/Red order, for accessing bits in the BGR format
// instead of RGB
//

typedef struct PALENTRY {
    BYTE    B;
    BYTE    G;
    BYTE    R;
    BYTE    Flags;
    } PALENTRY, FAR *PPALENTRY;


#define PFF_ROT_COORD_L90       0x0001
#define PFF_FLIP_X_COORD        0x0002
#define PFF_FLIP_Y_COORD        0x0004

#define BMP_ROT_NONE            0
#define BMP_ROT_RIGHT_90        1


typedef struct _PLOTFORM {
    WORD    Flags;              // PFF_xxxx flags;
    BYTE    BmpRotMode;         // BMP_ROT_xxx
    BYTE    NotUsed;            // not used
    SIZEL   PlotSize;           // Hard Clip Limit SIZE Size for PS cmd
    POINTL  PhyOrg;             // Physical origin from PlotSize origin
    SIZEL   LogSize;            // Logical Paper Size in 1/1000mm unit
    POINTL  LogOrg;             // Logical left/top margin in 1/1000mm unit
    SIZEL   LogExt;             // Printable area in 1/1000mm unit
    POINTL  BmpOffset;          // Bitmap Offset location
    } PLOTFORM, FAR *PPLOTFORM;


//
// Define the PDEV that this driver uses.
//

#define PDEV_BEG_ID             'tolP'
#define PDEV_END_ID             'VEDP'

#define RF_MAX_IDX              8

typedef struct _DBCACHE {
    WORD    RFIndex;            // RF command index 1-RF_MAX_IDX
    WORD    DBUniq;             // unique for cache
    } DBCACHE, FAR *PDBCACHE;


typedef struct _INTDECIW {
    WORD    Integer;
    WORD    Decimal;
    } INTDECIW, *PINTDECIW;

#define PW_HATCH_INT    0
#define PW_HATCH_DECI   26


typedef struct _PDEV {
    DWORD           PDEVBegID;          // Check if we got the right one

    DWORD           SizePDEV;           // pdev size to be checked against
    DWORD           Flags;              // PDEVF_xxx
    HDEV            hpdev;              // Engines handle to this structure
    HSURF           hsurf;              // Engine's handle to drawing surface
    HPALETTE        hPalDefault;        // default palette for pdev
    SURFOBJ         *pso;               // Current surface
    HANDLE          hPrinter;           // handle to the current pdev printer
    SURFOBJ         *psoHTBlt;          // temporary blt surfobj
    RECTL           rclHTBlt;           // location for curreent psoHTBlt
    PPLOTGPC        pPlotGPC;           // plotter characterization data
    LPBYTE          pOutBuffer;         // output buffer location
    DWORD           cbBufferBytes;      // current count of bytes in output buffer
    PLOTDEVMODE     PlotDM;             // plotter extended devmode structure
    FORMSIZE        CurForm;            // Current user requested form
    PAPERINFO       CurPaper;           // current loaded paper
    PPDATA          PPData;             // PrinterProperties data PPDATA
    PLOTFORM        PlotForm;           // computed current selected form
    LONG            lCurResolution;     // The current resolution.
    LONG            VertRes;            // Printable page height, pels
    LONG            HorzRes;            // Printable page width, pels
    POINTL          ptlAnchorCorner;    // current brush origin.
    POINTL          ptlRTLCAP;          // Current RTL CAP
    RECTL           rclCurClip;         // current clipping rectangle
    LPVOID          pTransPosTable;     // bitmap rotation xlate table
    LPVOID          pvDrvHTData;        // device's halftone info
    LPVOID          pPenCache;          // Pointer to the device pen cache
    LONG            BrightestPen;       // brightest pen for pen plotter
    LONG            CurPenSelected;     // Tracks the pen currently in plotter
    WORD            LastDevROP;         // Current MERGE (ROP2) sent to plotter
    WORD            Rop3CopyBits;       // Rop3 used in DrvCopyBits()
    WORD            LastFillTypeIndex;  // last filltype (FT) index sent
    WORD            LastLineType;       // Last line type used (LT)
    WORD            MinLToDevL;         // Min RasDPI->PlotDPI Transform unit
    WORD            DevBrushUniq;       // uniq number for DEVBRUSH cache
    INTDECIW        PenWidth;           // pen width variable cache
    DBCACHE         DBCache[RF_MAX_IDX];// DevBrush cache

    DWORD           PDEVEndID;          // ending block ID checking
    } PDEV, *PPDEV;


//
// Following are the flags for pPDev->Flags
//

#define PDEVF_CANCEL_JOB            0x80000000
#define PDEVF_IN_BANDHTBLT          0x00000001
#define PDEVF_PP_CENTER             0x00000002
#define PDEVF_HAS_CLIPRECT          0x00000004


#define PLOT_CANCEL_JOB(pPDev)      (pPDev->Flags & PDEVF_CANCEL_JOB)

//
// Following are the flags definitions for the GPC data
//

#define GET_PLOTFLAGS(pPDev)            (DWORD)(pPDev->pPlotGPC->Flags)
#define PF_RASTER(PlotFlags)            (PlotFlags & PLOTF_RASTER)
#define PF_COLOR(PlotFlags)             (PlotFlags & PLOTF_COLOR)
#define PF_BEZIER(PlotFlags)            (PlotFlags & PLOTF_BEZIER)
#define PF_TRANSPARENT(PlotFlags)       (PlotFlags & PLOTF_TRANSPARENT)
#define PF_WINDINGFILL(PlotFlags)       (PlotFlags & PLOTF_WINDINGFILL)
#define PF_ROLLFEED(PlotFlags)          (PlotFlags & PLOTF_ROLLFEED)
#define PF_PAPERTRAY(PlotFlags)         (PlotFlags & PLOTF_PAPERTRAY)
#define PF_BYTEALIGN(PlotFlags)         (PlotFlags & PLOTF_RASTERBYTEALIGN)
#define PF_PUSHPAL(PlotFlags)           (PlotFlags & PLOTF_PUSHPOPPAL)
#define PF_NO_BMP_FONT(PlotFlags)       (PlotFlags & PLOTF_NO_BMP_FONT)
#define PF_RTLMONOENCODE_5(PlotFlags)   (PlotFlags & PLOTF_RTLMONOENCODE_5)
#define PF_RTL_NO_DPI_XY(PlotFlags)     (PlotFlags & PLOTF_RTL_NO_DPI_XY)
#define PF_RTLMONO_NO_CID(PlotFlags)    (PlotFlags & PLOTF_RTLMONO_NO_CID)
#define PF_RTLMONO_FIXPAL(PlotFlags)    (PlotFlags & PLOTF_RTLMONO_FIXPAL)


#define IS_RASTER(pPDev)        (pPDev->pPlotGPC->Flags&PLOTF_RASTER)
#define IS_COLOR(pPDev)         (pPDev->pPlotGPC->Flags&PLOTF_COLOR)
#define IS_BEZIER(pPDev)        (pPDev->pPlotGPC->Flags&PLOTF_BEZIER)
#define IS_TRANSPARENT(pPDev)   (pPDev->pPlotGPC->Flags&PLOTF_TRANSPARENT)
#define IS_WINDINGFILL(pPDev)   (pPDev->pPlotGPC->Flags&PLOTF_WINDINGFILL)
#define IS_ROLLFEED(pPDev)      (pPDev->pPlotGPC->Flags&PLOTF_ROLLFEED)
#define HAS_PAPERTRAY(pPDev)    (pPDev->pPlotGPC->Flags&PLOTF_PAPERTRAY)
#define NEED_BYTEALIGN(pPDev)   (pPDev->pPlotGPC->Flags&PLOTF_RASTERBYTEALIGN)
#define NEED_PUSHPAL(pPDev)     (pPDev->pPlotGPC->Flags&PLOTF_PUSHPOPPAL)
#define NO_BMP_FONT(pPDev)      (pPDev->pPlotGPC->Flags&PLOTF_NO_BMP_FONT)
#define RTLMONOENCODE_5(pPDev)  (pPDev->pPlotGPC->Flags&PLOTF_RTLMONOENCODE_5)
#define RTL_NO_DPI_XY(pPDev)    (pPDev->pPlotGPC->Flags&PLOTF_RTL_NO_DPI_XY)
#define RTLMONO_NO_CID(pPDev)   (pPDev->pPlotGPC->Flags&PLOTF_RTLMONO_NO_CID)
#define RTLMONO_FIXPAL(pPDev)   (pPDev->pPlotGPC->Flags&PLOTF_RTLMONO_FIXPAL)



#define HTPATSIZE(pPDev)    (((pPDev->pPlotGPC->HTPatternSize>>1)+1)<<1)
#define HTBMPFORMAT(pPDev)  (((PDRVHTINFO)(pPDev->pvDrvHTData))->HTBmpFormat)


#define DB_INV_PATIDX           0xFFFF

//
// This structure defines our realization of a logical brush. Since GDI
// asks us to construct this, GDI keeps giving it back to us
//

typedef struct _DEVBRUSH {
    SURFOBJ     *psoMask;           // the mask for the pattern
    WORD        PatIndex;           // Pattern Index (iHatch HS_xxxx)
    WORD        Uniq;               // Uniq number for DEVBRUSH
    LONG        LineSpacing;        // Brush line spacing
    DWORD       ColorFG;            // foreground color of the brush
    DWORD       ColorBG;            // background color of the brush
    SIZEL       sizlBitmap;         // sizeof the bitmap
    LONG        ScanLineDelta;      // Number of bytes to move per scanline
    WORD        BmpFormat;          // format of the bitmap
    WORD        BmpFlags;           // Flags in surfobj
    LPBYTE      pbgr24;             // 24bpp BGR bitmap for user pattern
    WORD        cxbgr24;            // cx Size of the BGR
    WORD        cybgr24;            // cy Size of the BGR
    BYTE        BmpBits[32];        // pattern bitmap. (min 8x8 of 4bpp)
    } DEVBRUSH, *PDEVBRUSH;


//
// data_structure used in GenPolyGon()
//

typedef struct _POLYGONDATA {
    PPDEV       pPDev;
    SURFOBJ     *pso;               // only required in GenPolygonPath()
    PATHOBJ     *ppo;
    CLIPOBJ     *pco;
    DEVBRUSH    *pBrush;
    PPOINTL     pptlBrushOrg;
    RECTL       *prectl;
    short       iType;              // only required in GenPolygon()
    MIX         mixMode;
    BRUSHOBJ    *pBrushToUse;
    } POLYGONDATA, *PPOLYGONDATA;


//
// Conversion type of things
//

#define DIVROUND(x,y)                   (((LONG)(x)+(LONG)((y)>>1))/(LONG)(y))
#define DIVRNDUP(x,y)                   (((LONG)(x)+(LONG)((y)-1))/(LONG)(y))
#define __PLOT_DPI                      (LONG)pPDev->pPlotGPC->PlotXDPI
#define _PLOT_DPI                       (LONG)pPlotGPC->PlotXDPI
#define _CURR_DPI                       (LONG)pPDev->lCurResolution

#define LTOFX(x)                        ((x)<<4)

#define DMTOSPL(dm)                     ((LONG)(dm) * 100L)
#define SPLTODM(spl)                    (SHORT)DIVROUND(spl, 100)
#define MMTODM(mm)                      ((LONG)(mm) * 10L)

#define DMTOENGUNITS(pPDev, dm)         DIVROUND((dm)*_CURR_DPI, 254)
#define DMTOPLOTUNITS(pPlotGPC, dm)     DIVROUND((dm)*_PLOT_DPI, 254)

#define MMTOENGUNITS(pPDev, mm)         DMTOENGUNITS(pPDev, MMTODM(mm))
#define MMTOPLOTUNITS(pPlotGPC, mm)     DMTOPLOTUNITS(pPlotGPC, MMTODM(mm))

#define SPLTOENGUNITS(pPDev, spl)       DIVROUND((spl/100)*_CURR_DPI, 254)
#define SPLTOPLOTUNITS(pPlotGPC, spl)   DIVROUND((spl/100)*_PLOT_DPI, 254)

//
// Change to using Raster DPI as user unit
//
// #define ENGTODEV(pPDev, x)              DIVROUND((x)*__PLOT_DPI, _CURR_DPI)
//

#define ENGTODEV(pPDev, x)              (x)
#define FXTODEVL(pPDev, x)              ENGTODEV(pPDev, FXTOLROUND(x))
#define LTODEVL(pPDev, x)               ENGTODEV(pPDev, x)

//
// Minimum type of form supported
//

#define MIN_SPL_FORM_CX             MIN_PLOTGPC_FORM_CX
#define MIN_SPL_FORM_CY             MIN_PLOTGPC_FORM_CY
#define MIN_DM_FORM_CX              SPLTODM(MIN_SPL_FORM_CX)
#define MIN_DM_FORM_CY              SPLTODM(MIN_SPL_FORM_CY)


//
// Finally include this one in order to validate the PDEV
//

#include "pdevinfo.h"


#endif  // _PLOTTER_MAIN_HEADER_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\plotform.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    plotform.c


Abstract:

    This module contains functions to set the correct HPGL/2 plotter
    coordinate system


Author:

    30-Nov-1993 Tue 20:31:28 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPlotForm


#define DBG_PLOTFORM        0x00000001
#define DBG_FORMSIZE        0x00000002
#define DBG_INTERNAL_ROT    0x00000004
#define DBG_PF              0x00000008


DEFINE_DBGVAR(0);



#if DBG

LPSTR   pBmpRotMode[] = { "----- NONE -----",
                          "BMP_ROT_RIGHT_90" };

#endif




BOOL
SetPlotForm(
    PPLOTFORM       pPlotForm,
    PPLOTGPC        pPlotGPC,
    PPAPERINFO      pCurPaper,
    PFORMSIZE       pCurForm,
    PPLOTDEVMODE    pPlotDM,
    PPPDATA         pPPData
    )

/*++

Routine Description:

    This function computes the current FORM based on the printed margin. Auto
    rotation, landscape and other attributes are taken into account. The
    result is put into a PLOTFORM data structure located in our PDEV. This
    information is used to report data to GDI, as well as compute the HPGL2
    parameters for sizing the target surface.

Arguments:

    pPlotForm   - Pointer to the PLOTFROM data structure which will be updated

    pPlotGPC    - Pointer to the PLOTGPC data structure

    pCurPaper   - Pointer to the PAPERINFO for the paper loaded

    pCurForm    - Pointer to the FORMSIZE for the requested form

    pPlotDM     - Pointer to the validated PLOTDEVMODE data structure

    pPPData     - Pointer to the PPDATA structure

Return Value:

    TRUE if sucessful, FALSE if failed

Author:

    29-Nov-1993 Mon 13:58:09 created  -by-  DC

    17-Dec-1993 Fri 23:09:38 updated  -by-  DC
        Re-write so that we will look at CurPaper rather than pCurForm when
        setting the PSSize, p1/p2 stuff, it also rotate the pCurPaper if
        GPC/user said that the paper should loaded side way

    20-Dec-1993 Mon 12:59:38 updated  -by-  DC
        correct PFF_xxxx flag setting so we always rotate the bitmap to the
        left 90 degree

    23-Dec-1993 Thu 20:35:57 updated  -by-  DC
        Fixed roll paper clipping problem, change behavior, if we have roll
        paper installed then the it will make hard clip limit as big as user
        specified form size.

    24-Dec-1993 Fri 12:20:02 updated  -by-  DC
        Re-plot again, this is become really paint just try to understand what
        HP plotter design problems

    06-Jan-1994 Thu 00:22:45 updated  -by-  DC
        Update SPLTOPLOTUNITS() macro

    07-Feb-1996 Wed 15:46:06 updated  -by-  DC
        Change it so that it always using the current devmode form and then
        clip it to the device size.


Revision History:


    This assumes that the user inserted the paper with width of the form
    first,


    LEGEND:

     +     = Original paper corners
     *     = Original plotter origin and its X/Y coordinate
     @     = the rotated origin using 'RO' command, intended to rotate the X/Y
             axis to the correct orientation for the window system
     #     = Final plotter origin and its X/Y coordinate
     p1,p2 = final P1/P2 which will be used by the plotter driver
     cx,cy = Original paper width/height


     The following explaines how HPGL/2 loads the paper/form and
     assigns the default coordinate system to it, it also shows which way the
     paper is moving,  the illustration to the right is when we need to
     rotate the printing direction and coordinate system when user selects
     the non-conforming X/Y coordinate system as opposed to the HPGL/2 default.


    =======================================================================
    LENGTH >= WIDTH (CY >= CX) case
    =======================================================================

      Portrait Paper      Rotate             Change Origin
      Default             Left 90            Negative Y

    p2   cx                  cx    p1            cx
     +---------+         +---------+         +---------+
     |         |         | <------@|         |         |
     |         |         |    X   ||         |        ^|
     | |      ^|         | |      ||         | |      ||
    c| M      ||  RO90  c| M      ||   IP   c| M      ||
    y| o      || =====> y| o      ||  ====> y| o      ||
     | v      ||         | v     Y||         | v     Y||
     | e     X||         | e      ||         | e      ||
     | |      ||         | |      ||         | |      ||
     | V      ||         | V      ||         | V      ||
     |     Y  ||         |        V|         |     X  ||
     | <------*|         |         |         | <------#|
     +---------+         +---------+         +---------+
               p1       p2

         |
       IP|
         |
         V


      Change Origin
      Negative X

         cx
     +---------+
     | <------#|
     |    Y   ||
     | |      ||
    c| M      ||
    y| o      ||
     | v     X||
     | e      ||
     | |      ||
     | V      ||
     |        V|
     |         |
     +---------+

    =======================================================================
    LENGTH < WIDTH (CY < CX) case
    =======================================================================

     Landscape                  Rotate Left 90           Change Origin
     Paper Default                                       Negative X

           cx        p2        p2       cx                       cx
     +---------------+          +---------------+        +---------------+
     |               |          |               |        |     <--------#|
     |^            | |          | |            ^|        | |       Y    ||
    c||            M |         c| M            ||       c| M            ||
    y||            o |         y| o            ||       y| o            ||
     ||            v |   RO90   | v           X||  IP    | v           X||
     ||Y           e |  =====>  | e            || ====>  | e            ||
     ||            | |          | |            ||        | |            ||
     ||   X        V |          | V       Y    ||        | V            V|
     |*-------->     |          |     <--------@|        |               |
     +---------------+          +---------------+        +---------------+
    p1                                      p1

           |
         IP|
           |
           V

      Change Origin
      Negative X

             cx
     +---------------+
     |               |
     | |            ^|
    c| M            ||
    y| o            ||
     | v           Y||
     | e            ||
     | |            ||
     | V       X    ||
     |     <--------#|
     +---------------+


--*/

{
    PLOTFORM    PF;
    FORMSIZE    DevForm;
    FORMSIZE    ReqForm;
    RECTL       rclDev;
    RECTL       rclLog;
    SIZEL       DeviceSize;
    LONG        lTemp;
    BOOL        DoRotate;


    PLOTDBG(DBG_PF, ("\n************* SetPlotForm *************\n"));

    //
    // We default using DeviceSize to check against the requested paper
    //

    DeviceSize = pPlotGPC->DeviceSize;
    rclDev     = pPlotGPC->DeviceMargin;
    DoRotate   = FALSE;

    //
    // Assume we using the current form from the devmode
    //

    DevForm =
    ReqForm = *pCurForm;

    PLOTDBG(DBG_PF, ("DeviceSize: %ld x %ld,  L=%ld, T=%ld, R=%ld, B=%ld",
                    DeviceSize.cx, DeviceSize.cy,
                    rclDev.left, rclDev.top, rclDev.right, rclDev.bottom));
    PLOTDBG(DBG_PF, ("ReqForm: <%s>",
                    pPlotDM->dm.dmFormName, ReqForm.Size.cx, ReqForm.Size.cy));
    PLOTDBG(DBG_PF, ("ReqForm: %ld x %ld,  L=%ld, T=%ld, R=%ld, B=%ld  [%ld x %ld]",
                    ReqForm.Size.cx, ReqForm.Size.cy,
                    ReqForm.ImageArea.left, ReqForm.ImageArea.top,
                    ReqForm.ImageArea.right, ReqForm.ImageArea.bottom,
                    ReqForm.ImageArea.right - ReqForm.ImageArea.left,
                    ReqForm.ImageArea.bottom - ReqForm.ImageArea.top));

    if (pCurPaper->Size.cy == 0) {

        //
        // ROLL PAPER CASE
        //
        // If we have roll paper installed, we must determine the projection
        // of the current form on the roll paper in order to get the size
        // to come out correctly.
        //

        DevForm.Size.cx = pCurPaper->Size.cx;
        DevForm.Size.cy = DeviceSize.cy;

        PLOTDBG(DBG_PF,(">>ROLL FEED<< RollPaper = %ld x %ld, <RESET rclDev to ALL ZEROs>",
                        DevForm.Size.cx, DevForm.Size.cy));

    } else if ((pPlotGPC->Flags & PLOTF_PAPERTRAY) &&
               ((DevForm.Size.cx == DeviceSize.cx) ||
                (DevForm.Size.cy == DeviceSize.cx))) {

        //
        // PAPER TRAY CASE: We need to make the DeviceSize equal to the DevForm
        // so that the margin will be correctly computed
        //

        DoRotate = (BOOL)(DevForm.Size.cx != DeviceSize.cx);

        PLOTDBG(DBG_PF,(">>PAPER TRAY<<  Rotate Paper = %hs",
                                            (DoRotate) ? "YES" : "NO"));


    } else {

        PLOTASSERT(0, "SetPlotForm: Not supposed MANUAL feed the PAPER TRAY type PLOTTER",
                   !(pPlotGPC->Flags & PLOTF_PAPERTRAY), pPlotGPC->Flags);

        PLOTDBG(DBG_PF,(">>MANUAL FEED<<"));

        //
        // MANUAL FEED CASE, this is the way paper is physically loaded, only
        // problem is if the paper is smaller than device can handle then we
        // really don't know where they inserted the paper.
        //

        DoRotate = (BOOL)(!(pPPData->Flags & PPF_MANUAL_FEED_CX));

        PLOTDBG(DBG_PF,("The MANUAL FEED paper Inserted %hs side first.",
                    (DoRotate) ? "Length CY" : "Width CX"));
    }

    if (DoRotate) {

        SWAP(DevForm.Size.cx, DevForm.Size.cy, lTemp);

        PLOTDBG(DBG_PF, ("### Rotated DevForm to %ld x %ld ###",
                        DevForm.Size.cx, DevForm.Size.cy));
    }

    //
    // Make sure largest requested form can be installed on the plotter
    //

    if (DevForm.Size.cx > DeviceSize.cx) {

        PLOTDBG(DBG_PF, ("WIDTH: DevForm (%ld) > DeviceSize (%ld). CORRECT IT",
                    DevForm.Size.cx, DeviceSize.cx));

        DevForm.Size.cx = DeviceSize.cx;
    }

    if (DevForm.Size.cy > DeviceSize.cy) {

        PLOTDBG(DBG_PF, ("HEIGHT: DevForm (%ld) > DeviceSize (%ld). CORRECT IT",
                    DevForm.Size.cy, DeviceSize.cy));

        DevForm.Size.cy = DeviceSize.cy;
    }

    //
    // Figure out how to fit this requested form onto loaded device form
    //

    DoRotate = FALSE;

    if ((DevForm.Size.cx >= ReqForm.Size.cx) &&
        (DevForm.Size.cy >= ReqForm.Size.cy)) {

        //
        // Can print without doing any rotation, but check for paper saver,
        // the paper saver is only possible if:
        //
        //  1) Is a Roll paper,
        //  2) User approves
        //  3) ReqForm length > width
        //  4) DevForm width >= ReqForm length
        //

        if ((pCurPaper->Size.cy == 0)               &&
            (pPPData->Flags & PPF_AUTO_ROTATE)      &&
            (ReqForm.Size.cy >  ReqForm.Size.cx)    &&
            (DevForm.Size.cx >= ReqForm.Size.cy)) {

            PLOTDBG(DBG_PF, ("ROLL PAPER SAVER: Doing AUTO_ROTATE"));

            DoRotate = !DoRotate;
        }

    } else if ((DevForm.Size.cx >= ReqForm.Size.cy) &&
               (DevForm.Size.cy >= ReqForm.Size.cx)) {

        //
        // Can print but we have to rotate the form ourselves
        //

        PLOTDBG(DBG_PF, ("INTERNAL ROTATE to fit Requseted FROM into device"));

        DoRotate = !DoRotate;

    } else {

        //
        // CANNOT print the requested form, so clip the form requested
        //

        PLOTDBG(DBG_PF, (">>>>> ReqForm is TOO BIG to FIT, Need to CLIP IT <<<<<"));

        ReqForm.Size = DevForm.Size;
    }

    if (DoRotate) {

        DoRotate = (BOOL)(pPlotDM->dm.dmOrientation != DMORIENT_LANDSCAPE);

        //
        // If we need to rotate one more time back to the same position for
        // the logical paper size then we must rotate to the left first, this
        // is because ALL our ORIGIN x,y are either at the front of the plotter
        // or at the front panel side of the plotter
        //

        RotatePaper(&(ReqForm.Size),
                    &(ReqForm.ImageArea),
                    (DoRotate) ? RM_L90 : RM_R90);

        PLOTDBG(DBG_PF, ("INTERNAL Rotated ReqForm: %ld x %ld, L=%ld, T=%ld, R=%ld, B=%ld  [%ld x %ld]",
                    ReqForm.Size.cx, ReqForm.Size.cy,
                    ReqForm.ImageArea.left, ReqForm.ImageArea.top,
                    ReqForm.ImageArea.right, ReqForm.ImageArea.bottom,
                    ReqForm.ImageArea.right - ReqForm.ImageArea.left,
                    ReqForm.ImageArea.bottom - ReqForm.ImageArea.top));

    } else {

        DoRotate = (BOOL)(pPlotDM->dm.dmOrientation == DMORIENT_LANDSCAPE);
    }

    //
    // Now the ReqForm is guaranteed to fit into the device paper. Find out how
    // it fits into the printable area and set the hardware margins appropriately.
    //

    DevForm.Size             = ReqForm.Size;
    DevForm.ImageArea.left   = rclDev.left;
    DevForm.ImageArea.top    = rclDev.top;
    DevForm.ImageArea.right  = DevForm.Size.cx - rclDev.right;
    DevForm.ImageArea.bottom = DevForm.Size.cy - rclDev.bottom;

    //
    // Intersect the requested form imageable area with the DevForm imageable area
    //

    IntersectRECTL(&(ReqForm.ImageArea), &(DevForm.ImageArea));

    //
    // Now figure out the offset from the logical margin to the physical margin
    //

    rclLog.left   = ReqForm.ImageArea.left - DevForm.ImageArea.left;
    rclLog.top    = ReqForm.ImageArea.top - DevForm.ImageArea.top;
    rclLog.right  = DevForm.ImageArea.right -  ReqForm.ImageArea.right;
    rclLog.bottom = DevForm.ImageArea.bottom -  ReqForm.ImageArea.bottom;

    //
    // Rotate the requested form if necessary
    //

    if (DoRotate) {

        RotatePaper(&(ReqForm.Size), &(ReqForm.ImageArea), RM_R90);

        //
        // Now we can pick the right margin/corner for the rotation
        //
        //         cx        Rotate Left 90     Rotate Right 90
        //      +-------+
        //      |   T   |         cy                 cy
        //      |       |    +------------+     +------------+
        //     c|       |    |     R      |     |     L      |
        //     y|       |   c|            |    c|            |
        //      |L     R|   x|            |    x|            |
        //      |       |    |T          B|     |B          T|
        //      |       |    |            |     |            |
        //      |       |    |     L      |     |     R      |
        //      |   B   |    +------------+     +------------+
        //      +-------+
        //

        PLOTDBG(DBG_PF, ("ROTATED RIGHT ReqForm: %ld x %ld, L=%ld, T=%ld, R=%ld, B=%ld  [%ld x %ld]",
                    ReqForm.Size.cx, ReqForm.Size.cy,
                    ReqForm.ImageArea.left, ReqForm.ImageArea.top,
                    ReqForm.ImageArea.right, ReqForm.ImageArea.bottom,
                    ReqForm.ImageArea.right - ReqForm.ImageArea.left,
                    ReqForm.ImageArea.bottom - ReqForm.ImageArea.top));
    }

    PLOTDBG(DBG_PF, ("FINAL DevForm: %ld x %ld, L=%ld, T=%ld, R=%ld, B=%ld  [%ld x %ld]",
                    DevForm.Size.cx, DevForm.Size.cy,
                    DevForm.ImageArea.left, DevForm.ImageArea.top,
                    DevForm.ImageArea.right, DevForm.ImageArea.bottom,
                    DevForm.ImageArea.right - DevForm.ImageArea.left,
                    DevForm.ImageArea.bottom - DevForm.ImageArea.top));
    PLOTDBG(DBG_PF, ("FINAL ReqForm: %ld x %ld, L=%ld, T=%ld, R=%ld, B=%ld  [%ld x %ld]",
                    ReqForm.Size.cx, ReqForm.Size.cy,
                    ReqForm.ImageArea.left, ReqForm.ImageArea.top,
                    ReqForm.ImageArea.right, ReqForm.ImageArea.bottom,
                    ReqForm.ImageArea.right - ReqForm.ImageArea.left,
                    ReqForm.ImageArea.bottom - ReqForm.ImageArea.top));
    PLOTDBG(DBG_PF, ("rclLog: L=%ld, T=%ld, R=%ld, B=%ld",
                    rclLog.left, rclLog.top, rclLog.right, rclLog.bottom));

    //
    // Set fields in PLOTFORM
    //

    PF.Flags       = 0;
    PF.BmpRotMode  = BMP_ROT_NONE;
    PF.NotUsed     = 0;
    PF.PlotSize.cx = DevForm.ImageArea.right - DevForm.ImageArea.left;
    PF.PlotSize.cy = DevForm.ImageArea.bottom - DevForm.ImageArea.top;
    PF.PhyOrg.x    = ReqForm.ImageArea.left;
    PF.PhyOrg.y    = ReqForm.ImageArea.top;
    PF.LogSize     = ReqForm.Size;
    PF.LogExt.cx   = ReqForm.ImageArea.right - ReqForm.ImageArea.left;
    PF.LogExt.cy   = ReqForm.ImageArea.bottom - ReqForm.ImageArea.top;
    PF.BmpOffset.x = rclLog.left;
    PF.BmpOffset.y = rclLog.top;

    if (PF.PlotSize.cy >= PF.PlotSize.cx) {

        PLOTDBG(DBG_FORMSIZE,(">>>>> Plot SIze: CY >= CX (%ld: VERTICAL%hs) <<<<<",
                    (DoRotate) ? 1 : 2,
                    (DoRotate) ? " + ROTATE" : ""));

        //
        // The Standard HPGL/2 coordinate Y direction in in reverse, the scale
        // is from Max Y to 0.
        //

        if (DoRotate) {

            //
            //   Portrait Paper     Scale Coord X
            //   Default            Negative X
            //
            // p2   cx                  cx
            //  +---------+         +---------+
            //  |         |         | <------#|
            //  |         |         |    Y   ||
            //  | |      ^|         | |      ||
            // c| M      ||        c| M      ||
            // y| o      || ====>  y| o      ||
            //  | v      ||         | v     X||
            //  | e     X||         | e      ||
            //  | |      ||         | |      ||
            //  | V      ||         | V      ||
            //  |     Y  ||         |        V|
            //  | <------*|         |         |
            //  +---------+         +---------+
            //            p1
            //

            PF.Flags      |= PFF_FLIP_X_COORD;
            PF.BmpRotMode  = BMP_ROT_RIGHT_90;
            PF.LogOrg.x    = rclLog.top;
            PF.LogOrg.y    = rclLog.left;

        } else {

            //
            //   Portrait Paper      Rotate            Scale Coord Y
            //   Default             Left 90           Negative Y
            //
            // p2   cx                  cx    p1           cx
            //  +---------+         +---------+        +---------+
            //  |         |         | <------@|        |         |
            //  |         |         |    X   ||        |        ^|
            //  | |      ^|         | |      ||        | |      ||
            // c| M      ||  RO90  c| M      ||       c| M      ||
            // y| o      || =====> y| o      || ====> y| o      ||
            //  | v      ||         | v     Y||        | v     Y||
            //  | e     X||         | e      ||        | e      ||
            //  | |      ||         | |      ||        | |      ||
            //  | V      ||         | V      ||        | V      ||
            //  |     Y  ||         |        V|        |     X  ||
            //  | <------*|         |         |        | <------#|
            //  +---------+         +---------+        +---------+
            //            p1       p2
            //

            PF.Flags    |= (PFF_ROT_COORD_L90 | PFF_FLIP_Y_COORD);
            PF.LogOrg.x  = rclLog.left;
            PF.LogOrg.y  = rclLog.bottom;
        }

    } else {

        PLOTDBG(DBG_FORMSIZE,(">>>>> SetPlotForm: CY < CX (%ld: HORIZONTAL%hs) <<<<<",
                    (DoRotate) ? 3 : 4,
                    (DoRotate) ? " + ROTATE" : ""));

        //
        // The Standard HPGL/2 coordinate X direction in in reverse, the scale
        // is from Max X to 0
        //

        if (DoRotate) {

            //
            //  DoRotate                Rotate Left 90         Scale Coord X
            //  Paper Default                                  Negative X
            //
            //        cx       p2      p2      cx                     cx
            //  +---------------+       +---------------+     +---------------+
            //  |               |       |               |     |     <--------#|
            //  |^            | |       | |            ^|     | |       Y    ||
            // c||            M |      c| M            ||    c| M            ||
            // y||            o |      y| o            ||    y| o            ||
            //  ||            v | RO90  | v           X||     | v           X||
            //  ||Y           e |=====> | e            || ==> | e            ||
            //  ||            | |       | |            ||     | |            ||
            //  ||   X        V |       | V       Y    ||     | V            V|
            //  |*-------->     |       |     <--------@|     |               |
            //  +---------------+       +---------------+     +---------------+
            // p1                                      p1
            //

            PF.Flags      |= (PFF_ROT_COORD_L90 | PFF_FLIP_X_COORD);
            PF.BmpRotMode  = BMP_ROT_RIGHT_90;
            PF.LogOrg.x    = rclLog.top;
            PF.LogOrg.y    = rclLog.left;

        } else {

            //
            //  DoRotate                   Scale Coord X
            //  Paper Default              Negative X
            //
            //        cx       p2                cx
            //  +----------------+         +-----------------+
            //  |                |         |                 |
            //  |^             | |         | |              ^|
            // c||             M |        c| M              ||
            // y||             o |        y| o              ||
            //  ||             v |  ====>  | v             Y||
            //  ||Y            e |         | e              ||
            //  ||             | |         | |              ||
            //  ||   X         V |         | V         X    ||
            //  |*-------->      |         |       <--------#|
            //  +----------------+         +-----------------+
            // p1
            //

            PF.Flags    |= PFF_FLIP_X_COORD;
            PF.LogOrg.x  = rclLog.right;
            PF.LogOrg.y  = rclLog.top;
        }
    }

    PLOTDBG(DBG_PF, ("FINAL LogOrg: (%ld, %ld),  PhyOrg=(%ld, %ld)",
                    PF.LogOrg.x, PF.LogOrg.y, PF.PhyOrg.x, PF.PhyOrg.y));

    //
    // Save result and output some information
    //

    *pPlotForm = PF;

    PLOTDBG(DBG_PLOTFORM,("******************************************************"));
    PLOTDBG(DBG_PLOTFORM,("******* SetPlotForm: ****** %hs --> %hs ******\n",
                        (pPlotDM->dm.dmOrientation == DMORIENT_LANDSCAPE) ?
                                                    "LANDSCAPE" : "PORTRAIT",
                                    (DoRotate) ? "LANDSCAPE" : "PORTRAIT"));
    PLOTDBG(DBG_PLOTFORM,("        Flags =%hs%hs%hs",
            (PF.Flags & PFF_ROT_COORD_L90) ? " <ROT_COORD_L90> " : "",
            (PF.Flags & PFF_FLIP_X_COORD)  ? " <FLIP_X_COORD> " : "",
            (PF.Flags & PFF_FLIP_Y_COORD)  ? " <FLIP_Y_COORD> " : ""));
    PLOTDBG(DBG_PLOTFORM,("   BmpRotMode = %hs", pBmpRotMode[PF.BmpRotMode]));
    PLOTDBG(DBG_PLOTFORM,("     PlotSize = (%7ld x%7ld) [%5ld x%6ld]",
            PF.PlotSize.cx, PF.PlotSize.cy,
            SPLTOPLOTUNITS(pPlotGPC, PF.PlotSize.cx),
            SPLTOPLOTUNITS(pPlotGPC, PF.PlotSize.cy)));
    PLOTDBG(DBG_PLOTFORM,("PhyOrg/Offset = (%7ld,%8ld) [%5ld,%7ld] ",
            PF.PhyOrg.x, PF.PhyOrg.y,
            SPLTOPLOTUNITS(pPlotGPC, PF.PhyOrg.x),
            SPLTOPLOTUNITS(pPlotGPC, PF.PhyOrg.y)));
    PLOTDBG(DBG_PLOTFORM,("      LogSize = (%7ld x%7ld) [%5ld x%6ld]",
            PF.LogSize.cx, PF.LogSize.cy,
            SPLTOPLOTUNITS(pPlotGPC, PF.LogSize.cx),
            SPLTOPLOTUNITS(pPlotGPC, PF.LogSize.cy)));
    PLOTDBG(DBG_PLOTFORM,("    LogOrg/p1 = (%7ld,%8ld) [%5ld,%7ld]",
            PF.LogOrg.x, PF.LogOrg.y,
            SPLTOPLOTUNITS(pPlotGPC, PF.LogOrg.x),
            SPLTOPLOTUNITS(pPlotGPC, PF.LogOrg.y)));
    PLOTDBG(DBG_PLOTFORM,("       LogExt = (%7ld,%8ld) [%5ld,%7ld]\n",
            PF.LogExt.cx, PF.LogExt.cy,
            SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cx),
            SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cy)));
    PLOTDBG(DBG_PLOTFORM,("    BmpOffset = (%7ld,%8ld) [%5ld,%7ld]",
            PF.BmpOffset.x, PF.BmpOffset.y,
            SPLTOPLOTUNITS(pPlotGPC, PF.BmpOffset.x),
            SPLTOPLOTUNITS(pPlotGPC, PF.BmpOffset.y)));
    PLOTDBG(DBG_PLOTFORM,
            ("Commands=PS%ld,%ld;%hsIP%ld,%ld,%ld,%ld;SC%ld,%ld,%ld,%ld\n",
            SPLTOPLOTUNITS(pPlotGPC, PF.PlotSize.cy),
            SPLTOPLOTUNITS(pPlotGPC, PF.PlotSize.cx),
            (PF.Flags & PFF_ROT_COORD_L90) ? "RO90;" : "",
            SPLTOPLOTUNITS(pPlotGPC, PF.LogOrg.x),
            SPLTOPLOTUNITS(pPlotGPC, PF.LogOrg.y),
            SPLTOPLOTUNITS(pPlotGPC, (PF.LogOrg.x + PF.LogExt.cx)) - 1,
            SPLTOPLOTUNITS(pPlotGPC, (PF.LogOrg.y + PF.LogExt.cy)) - 1,
            (PF.Flags & PFF_FLIP_X_COORD) ?
                    SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cx) - 1 : 0,
            (PF.Flags & PFF_FLIP_X_COORD) ?
                    0 : SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cx) - 1,
            (PF.Flags & PFF_FLIP_Y_COORD) ?
                    SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cy) - 1 : 0,
            (PF.Flags & PFF_FLIP_Y_COORD) ?
                    0 : SPLTOPLOTUNITS(pPlotGPC, PF.LogExt.cy) - 1));

    return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\polygon.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    polygon.h


Abstract:

    This module contains all #defines for the polygon.c module.


Author:

    18-Nov-1993 Thu 05:21:19 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _PLOTPOLYGON_
#define _PLOTPOLYGON_


//
// Define flags for the DoPolygon and DoFillLogic functions
//
#define FPOLY_WINDING   0x00000001
#define FPOLY_STROKE    0x00000002
#define FPOLY_FILL      0x00000004
#define FPOLY_MASK      (FPOLY_WINDING | FPOLY_STROKE | FPOLY_FILL)


//
// The maximum number of points the HPGL2 language supports for a styled
// line
//
#define MAX_USER_POINTS   20

//
// Allow for extra points needed if we send down to plotter, break for
// starting style state compensation
//
#define MAX_STYLE_ENTRIES 18


BOOL
DoRect(
    PPDEV       pPDev,
    RECTL       *pRectl,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    POINTL      *pptlBrush,
    ROP4        rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    );

BOOL
DoFillByEnumingClipRects(
    PPDEV       pPDev,
    POINTL      *ppointlOffset,
    CLIPOBJ     *pco,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    ROP4        Rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    );

BOOL
PlotCheckForWhiteIfPenPlotter(
    PPDEV       pPDev,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        rop4,
    PULONG      pulFlags
    );

BOOL
DoPolygon(
    PPDEV       pPDev,
    POINTL      *ppointlOffset,
    CLIPOBJ     *pClipObj,
    PATHOBJ     *pPathObj,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    );

VOID
HandleLineAttributes(
    PPDEV       pPDev,
    LINEATTRS   *plineattrs,
    PLONG       pStyleToUse,
    LONG        lExtraStyle
    );

VOID
DoFillLogic(
    PPDEV       pPDev,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        Rop4,
    LINEATTRS   *plineattrs,
    SIZEL       *pszlRect,
    ULONG       ulFlags
    );

VOID
DoSetupOfStrokeAttributes(
    PPDEV       pPDev,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushStroke,
    ROP4        Rop4,
    LINEATTRS   *plineattrs
    );

LONG
DownloadUserDefinedPattern(
    PPDEV       pPDev,
    PDEVBRUSH   pBrush
    );




#endif  _PLOTPOLYGON_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\ropblt.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    ropblt.c


Abstract:

    This module contains code to deal with ROP3 codes


Author:

    07-Jan-1994 Fri 11:04:09 created  -by-  DC

    27-Jan-1994 Thu 23:42:09 updated  -by-  DC
        Bascially re-write the codes, make up our own ROP3 to ROP2s generator
        and mixer.  Cloning the surface object as necessary, some of ROP4 to
        ROP2 (Rop3ToSDMix[]) are hand twiks so that it can handle the one
        which we can not handle before (ie. multiple destinaiton usage cases)

    16-Mar-1994 Wed 11:21:45 updated  -by-  DC
        Update the DoMix2() so the SRC aligned to the destination only if the
        source is not psoMask


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgRopBlt

#define DBG_DOMIX2          0x00000001
#define DBG_CLONESO         0x00000002
#define DBG_ROP3            0x00000004
#define DBG_SPECIALROP      0x00000008

DEFINE_DBGVAR(0);



//****************************************************************************
// All ROP3/2 Related Local defines, structures which are only used in this
// file are located here
//****************************************************************************

#define MIX2_0                  0x00
#define MIX2_SoD_n              0x01
#define MIX2_nS_aD              0x02
#define MIX2_nS                 0x03
#define MIX2_nD_aS              0x04
#define MIX2_nD                 0x05
#define MIX2_SxD                0x06
#define MIX2_SaD_n              0x07
#define MIX2_SaD                0x08
#define MIX2_SxD_n              0x09
#define MIX2_D                  0x0A
#define MIX2_nS_oD              0x0B
#define MIX2_S                  0x0C
#define MIX2_nD_oS              0x0D
#define MIX2_SoD                0x0E
#define MIX2_1                  0x0F
#define MIX2_MASK               0x0F

#define MIXSD_SRC_DST           0x00
#define MIXSD_PAT_DST           0x10
#define MIXSD_SRC_PAT           0x20
#define MIXSD_TMP_DST           0x30
#define MIXSD_MASK              0x30

#define MIX2F_MUL_DST           0x80
#define MIX2F_MUL_SRC           0x40
#define MIX2F_NEED_TMP          0x20
#define MIX2F_COUNT_MASK        0x03

#define MAX_SD_MIXS             4
#define SDMIX_SHIFT_COUNT       6
#define GET_SDMIX_MIX2F(dw)     (BYTE)((dw) >> 24)
#define SET_SDMIX_MIX2F(dw,f)   (dw)|=((DWORD)(f) << 24)
#define GET_MIX2F_COUNT(f)      (((f)&0x3)+1)
#define SET_MIX2F_COUNT(f,c)    (f=(BYTE)((((c)-1)&0x3)|((f)&~0x3)))


//
// DWORD SDMix Bits meaning
//
//  Bit  0- 5:
//       6-11:
//      12-17:
//      18-23:  Each has 6 bits, lower 4 bits denote MIX2 operation code (one
//              of 16 MIX2_xxxx, and upper 2 bits is the MIXSD_xxxx which
//              indicate where the source/destination operands come from.
//
//  Bit 24-25:  2 bits indicate the total MIX2_xxx operation codes minus 1,
//              00=1, 01=2, 02=3, 03=4, maximum will be 4 Mix2 operations
//
//  Bit 26:     Not Used
//  Bit 27:     Not Used
//  Bit 28:     Not Used
//  Bit 29:     Flag MIX2F_NEED_TMP to indicate a temporary surface object is
//              needed to stored the PAT/SRC Mix2 operations.
//  Bit 30:     Flag MIX2F_MUL_SRC to indicate multiple source operations
//              are present in the Mix2s.
//  Bit 31:     Flag MIX2F_MUL_DST to indicate multiple destination operations
//              are present in the Mix2s.
//
// The Rop3ToSDMix[] is a DWORD array. each DWORD (SDMix) is defined
// above.  The Rop3ToSDMix[] only list the first 128 of the ROP3 code, the other
// 128 Rop3 codes (128-255) can be obtains by 'Rop3ToSDMix[Rop3 ^ 0xFF]' and
// the result of the Rop3 must be complemented.
//
// Since all Rop3/Rop2 codes are symmetric, we can complement the Rop3/Rop2
// result by complementing MIX2_xxxx (0->15, 1->14...,7->8).
//
// The [!x] in the Rop3ToSDMix[], indicates the following
//
//  !:  Indicates MIX2F_MUL_DST bit is set for the ROP
//  x:  Is the total number of MIX2_xxx operations
//


const DWORD Rop3ToSDMix[128] = {

        { 0x00000000 }, // [ 1]   0-0x00: 0
        { 0x21000C6E }, // [ 2]   1-0x01: ~(D | (P | S))
        { 0x21000E21 }, // [ 2]   2-0x02: D & ~(P | S)
        { 0x0100044C }, // [ 2]   3-0x03: ~(P | S)
        { 0x01000211 }, // [ 2]   4-0x04: S & ~(D | P)
        { 0x00000011 }, // [ 1]   5-0x05: ~(D | P)
        { 0x01000449 }, // [ 2]   6-0x06: ~(P | ~(D ^ S))
        { 0x01000448 }, // [ 2]   7-0x07: ~(P | (D & S))
        { 0x01000212 }, // [ 2]   8-0x08: S & (D & ~P)
        { 0x01000446 }, // [ 2]   9-0x09: ~(P | (D ^ S))
        { 0x00000012 }, // [ 1]  10-0x0a: D & ~P
        { 0x01000444 }, // [ 2]  11-0x0b: ~(P | (S & ~D))
        { 0x0100048C }, // [ 2]  12-0x0c: S & ~P
        { 0x01000442 }, // [ 2]  13-0x0d: ~(P | (D & ~S))
        { 0x01000441 }, // [ 2]  14-0x0e: ~(P | ~(D | S))
        { 0x00000013 }, // [ 1]  15-0x0f: ~P
        { 0x01000601 }, // [ 2]  16-0x10: P & ~(D | S)
        { 0x00000001 }, // [ 1]  17-0x11: ~(D | S)
        { 0x01000059 }, // [ 2]  18-0x12: ~(S | ~(D ^ P))
        { 0x01000058 }, // [ 2]  19-0x13: ~(S | (D & P))
        { 0x21000C69 }, // [ 2]  20-0x14: ~(D | ~(P ^ S))
        { 0x21000C68 }, // [ 2]  21-0x15: ~(D | (P & S))
        { 0x63586E27 }, // [ 4]  22-0x16: P ^ (S ^ (D & ~(P & S)))
        { 0x63278986 }, // [ 4]  23-0x17: ~(S ^ ((S ^ P) & (D ^ S)))
        { 0x22038996 }, // [ 3]  24-0x18: (S ^ P) & (P ^ D)
        { 0x62009E27 }, // [ 3]  25-0x19: ~(S ^ (D & ~(P & S)))
        { 0x22016FA8 }, // [ 3]  26-0x1a: P ^ (D | (S & P))
        { 0x62009E26 }, // [ 3]  27-0x1b: ~(S ^ (D & (P ^ S)))
        { 0x02016398 }, // [ 3]  28-0x1c: P ^ (S | (D & P))

//        { 0x81000216 }, // [!2]  29-0x1d: ~(D ^ (S & (P ^ D)))
        { 0x6203990E }, // [ 3]  29-0x1d: ~((S & ~P) ^ (S | D))

        { 0x0100058E }, // [ 2]  30-0x1e: P ^ (D | S)
        { 0x010005CE }, // [ 2]  31-0x1f: ~(P & (D | S))
        { 0x21000E22 }, // [ 2]  32-0x20: D & (P & ~S)
        { 0x01000056 }, // [ 2]  33-0x21: ~(S | (D ^ P))
        { 0x00000002 }, // [ 1]  34-0x22: D & ~S
        { 0x01000054 }, // [ 2]  35-0x23: ~(S | (P & ~D))
        { 0x62038986 }, // [ 3]  36-0x24: (S ^ P) & (D ^ S)
        { 0x22019E27 }, // [ 3]  37-0x25: ~(P ^ (D & ~(S & P)))
        { 0x62006FA8 }, // [ 3]  38-0x26: S ^ (D | (P & S))
        { 0x22019E26 }, // [ 3]  39-0x27: ~(P ^ (D & (S ^ P)))
        { 0x21000E26 }, // [ 2]  40-0x28: D & (P ^ S)
        { 0x63646FA8 }, // [ 4]  41-0x29: ~(P ^ (S ^ (D | (P & S))))
        { 0x21000E27 }, // [ 2]  42-0x2a: D & ~(P & S)
        { 0x63278996 }, // [ 4]  43-0x2b: ~(S ^ ((S ^ P) & (P ^ D)))
        { 0x0200660E }, // [ 3]  44-0x2c: S ^ (P & (D | S))
        { 0x01000642 }, // [ 2]  45-0x2d: ~(P ^ (D & ~S))
        { 0x02016396 }, // [ 3]  46-0x2e: P ^ (S | (D ^ P))
        { 0x010005CD }, // [ 2]  47-0x2f: ~(P & (S | ~D))
        { 0x0100050C }, // [ 2]  48-0x30: P & ~S
        { 0x01000052 }, // [ 2]  49-0x31: ~(S | (D & ~P))
        { 0x62006FAE }, // [ 3]  50-0x32: S ^ (D | (P | S))
        { 0x00000003 }, // [ 1]  51-0x33: ~S
        { 0x02006788 }, // [ 3]  52-0x34: S ^ (P | (D & S))
        { 0x02006789 }, // [ 3]  53-0x35: S ^ (P | ~(D ^ S))
        { 0x0100019E }, // [ 2]  54-0x36: S ^ (D | P)
        { 0x010001DE }, // [ 2]  55-0x37: ~(S & (D | P))
        { 0x0201621E }, // [ 3]  56-0x38: P ^ (S & (D | P))
        { 0x01000252 }, // [ 2]  57-0x39: ~(S ^ (D & ~P))
        { 0x02006786 }, // [ 3]  58-0x3a: S ^ (P | (D ^ S))
        { 0x010001DD }, // [ 2]  59-0x3b: ~(S & (P | ~D))
        { 0x0100058C }, // [ 2]  60-0x3c: P ^ S
        { 0x02006781 }, // [ 3]  61-0x3d: S ^ (P | ~(D | S))
        { 0x02006782 }, // [ 3]  62-0x3e: S ^ (P | (D & ~S))
        { 0x010005CC }, // [ 2]  63-0x3f: ~(P & S)
        { 0x01000604 }, // [ 2]  64-0x40: P & (S & ~D)
        { 0x21000C66 }, // [ 2]  65-0x41: ~(D | (P ^ S))
        { 0x81000196 }, // [!2]  66-0x42: ~((S ^ D) & (P ^ D))
        { 0x02009607 }, // [ 3]  67-0x43: ~(S ^ (P & ~(D & S)))
        { 0x00000004 }, // [ 1]  68-0x44: S & ~D
        { 0x21000C62 }, // [ 2]  69-0x45: ~(D | (P & ~S))
        { 0x81000398 }, // [!2]  70-0x46: ~(D ^ (S | (P & D)))
        { 0x02019216 }, // [ 3]  71-0x47: ~(P ^ (S & (D ^ P)))
        { 0x01000216 }, // [ 2]  72-0x48: S & (D ^ P)
        { 0x82019398 }, // [!3]  73-0x49: ~(P ^ (D ^ (S | (P & D))))
        { 0x8100060E }, // [!2]  74-0x4a: ~(D ^ (P & (S | D)))
        { 0x01000644 }, // [ 2]  75-0x4b: ~(P ^ (S & ~D))
        { 0x01000217 }, // [ 2]  76-0x4c: S & ~(D & P)
        { 0x6327E986 }, // [ 4]  77-0x4d: ~(S ^ ((S ^ P) | (D ^ S)))
        { 0x22016FA6 }, // [ 3]  78-0x4e: P ^ (D | (S ^ P))
        { 0x010005CB }, // [ 2]  79-0x4f: ~(P & (D | ~S))
        { 0x00000014 }, // [ 1]  80-0x50: P & ~D
        { 0x21000C64 }, // [ 2]  81-0x51: ~(D | (S & ~P))
        { 0x81000788 }, // [!2]  82-0x52: ~(D ^ (P | (S & D)))
        { 0x02009606 }, // [ 3]  83-0x53: ~(S ^ (P & (D ^ S)))
        { 0x21000C61 }, // [ 2]  84-0x54: ~(D | ~(P | S))
        { 0x00000005 }, // [ 1]  85-0x55: ~D
        { 0x21000DAE }, // [ 2]  86-0x56: D ^ (P | S)
        { 0x21000DEE }, // [ 2]  87-0x57: ~(D & (P | S))
        { 0x22016E2E }, // [ 3]  88-0x58: P ^ (D & (S | P))
        { 0x21000E64 }, // [ 2]  89-0x59: ~(D ^ (S & ~P))
        { 0x00000016 }, // [ 1]  90-0x5a: D ^ P
        { 0x22016FA1 }, // [ 3]  91-0x5b: P ^ (D | ~(S | P))

        { 0x220385EE }, // [ 3]  92-0x5c: (S | P) & ~(P & D)

            // { 0x81000786 }, // [!2]  92-0x5c: ~(D ^ (P | (S ^ D)))

        { 0x21000DEB }, // [ 2]  93-0x5d: ~(D & (P | ~S))
        { 0x22016FA4 }, // [ 3]  94-0x5e: P ^ (D | (S & ~P))
        { 0x00000017 }, // [ 1]  95-0x5f: ~(D & P)
        { 0x01000606 }, // [ 2]  96-0x60: P & (D ^ S)
        { 0x82006788 }, // [!3]  97-0x61: ~(D ^ (S ^ (P | (D & S))))
        { 0x8100021E }, // [!2]  98-0x62: ~(D ^ (S & (P | D)))
        { 0x01000254 }, // [ 2]  99-0x63: ~(S ^ (P & ~D))
        { 0x62006E2E }, // [ 3] 100-0x64: S ^ (D & (P | S))
        { 0x21000E62 }, // [ 2] 101-0x65: ~(D ^ (P & ~S))
        { 0x00000006 }, // [ 1] 102-0x66: D ^ S
        { 0x62006FA1 }, // [ 3] 103-0x67: S ^ (D | ~(P | S))
        { 0x63646FA1 }, // [ 4] 104-0x68: ~(P ^ (S ^ (D | ~(P | S))))
        { 0x21000E66 }, // [ 2] 105-0x69: ~(D ^ (P ^ S))
        { 0x21000DA8 }, // [ 2] 106-0x6a: D ^ (P & S)
        { 0x63646E2E }, // [ 4] 107-0x6b: ~(P ^ (S ^ (D & (P | S))))
        { 0x01000198 }, // [ 2] 108-0x6c: S ^ (D & P)
        { 0x8201921E }, // [!3] 109-0x6d: ~(P ^ (D ^ (S & (P | D))))
        { 0x62006E2B }, // [ 3] 110-0x6e: S ^ (D & (P | ~S))
        { 0x010005C9 }, // [ 2] 111-0x6f: ~(P & ~(D ^ S))
        { 0x01000607 }, // [ 2] 112-0x70: P & ~(D & S)
        { 0x82009196 }, // [!3] 113-0x71: ~(S ^ ((S ^ D) & (P ^ D)))
        { 0x62006FA6 }, // [ 3] 114-0x72: S ^ (D | (P ^ S))
        { 0x010001DB }, // [ 2] 115-0x73: ~(S & (D | ~P))
        { 0x81000396 }, // [!2] 116-0x74: ~(D ^ (S | (P ^ D)))
        { 0x21000DED }, // [ 2] 117-0x75: ~(D & (S | ~P))
        { 0x62006FA2 }, // [ 3] 118-0x76: S ^ (D | (P & ~S))
        { 0x00000007 }, // [ 1] 119-0x77: ~(D & S)
        { 0x01000588 }, // [ 2] 120-0x78: P ^ (D & S)
        { 0x8200660E }, // [!3] 121-0x79: ~(D ^ (S ^ (P & (D | S))))
        { 0x22016E2D }, // [ 3] 122-0x7a: P ^ (D & (S | ~P))
        { 0x010001D9 }, // [ 2] 123-0x7b: ~(S & ~(D ^ P))
        { 0x0200660B }, // [ 3] 124-0x7c: S ^ (P & (D | ~S))
        { 0x21000DE9 }, // [ 2] 125-0x7d: ~(D & ~(P ^ S))
        { 0x6203E986 }, // [ 3] 126-0x7e: (S ^ P) | (D ^ S)
        { 0x21000DE8 }  // [ 2] 127-0x7f: ~(D & (P & S))
    };

extern const POINTL ptlZeroOrigin;

//****************************************************************************
// END OF LOCAL DEFINES/STRUCTURE
//****************************************************************************




BOOL
CloneBitBltSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMask,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PRECTL      prclPat,
    BRUSHOBJ    *pbo,
    PCLONESO    pCloneSO,
    DWORD       RopBG,
    DWORD       RopFG
    )
/*++

Routine Description:

    This function will clone the source/pattern and/or create a temp
    source buffer if we need one

Arguments:

    pPDev       - Pointer to our PDEV

    psoDst      - Pointer to our surfae obj

    psoSrc      - Pointer to source surfae obj

    psoMask     - Pointer to the mask surface object if neeed to be used as pat

    pxlo        - translate object from source to destination

    prclDst     - Pointer to the destination rectangle area for the bitblt

    prclSrc     - Pointer to the source rectangle area

    prclPat     - pointer to the pattern rectangle area

    pbo         - Pointer to the pointer of brush object

    pCloneSO    - Pointer to the CLONSO[3] which stored the clone result

    RopBG       - Background rop3

    RopFG       - Foreground rop3

Return Value:

    BOOLEAN


Author:

    24-Jan-1994 Mon 15:58:27 created  -by-  DC


Revision History:


--*/

{
    DWORD   Index;
    INT     CompPat;
    BYTE    Flags;


    //
    // Invert Rop3 if we are out of data range (128-255) and then invert
    // the final result (by inverting last Mix2 Rop2 code (0-15), all Rop3/Rop2
    // codes are symmetric.
    //

    if ((Index = RopBG) >= 0x80) {

        Index ^= 0xFF;
    }

    Flags = GET_SDMIX_MIX2F(Rop3ToSDMix[Index]);

    if ((Index = RopFG) >= 0x80) {

        Index ^= 0xFF;
    }

    Flags |= GET_SDMIX_MIX2F(Rop3ToSDMix[Index]);

    //
    // Clone the PATTERN if necessary.
    //

    if ((ROP3_NEED_PAT(RopFG)) ||
        (ROP3_NEED_PAT(RopBG))) {

        //
        // Only Clone the MASK/PATTERN if it is required
        //

        PLOTDBG(DBG_CLONESO, ("CloneBitBltSURFOBJ: NEED PATTERN "));

        if (psoMask) {

            PLOTDBG(DBG_CLONESO, ("CloneBitBltSURFOBJ: Use psoMask as pattern"));

            if (!(pCloneSO[CSI_PAT].pso =
                                    CloneMaskSURFOBJ(pPDev,
                                                     psoMask,
                                                     &pCloneSO[CSI_PAT].hBmp,
                                                     prclPat))) {

                PLOTERR(("CloneBitBltSURFOBJ:: CloneMaskSURFOBJ(psoPat) failed"));
                return(FALSE);
            }

        } else {

            //
            // Firs get the DEVBRUSH out.
            //

            if (!(CompPat = (INT)GetColor(pPDev, pbo, NULL, NULL, RopBG))) {

                PLOTERR(("CloneBitBltSURFOBJ:: GetColor for DEVBRUSH failed"));
                return(FALSE);
            }

            //
            // If we do not have a device compatible pattern or if we have to
            // do a SRC/PAT memory operation then we need to clone the pattern
            //

            if ((CompPat < 0) || (Flags & MIX2F_NEED_TMP)) {

                if (!(pCloneSO[CSI_PAT].pso =
                                    CloneBrushSURFOBJ(pPDev,
                                                      psoDst,
                                                      &pCloneSO[CSI_PAT].hBmp,
                                                      pbo))) {

                    PLOTERR(("CloneBitBltSURFOBJ:: CloneBrushSURFOBJ(psoPat) failed"));
                    return(FALSE);
                }

                prclPat->left   =
                prclPat->top    = 0;
                prclPat->right  = pCloneSO[CSI_PAT].pso->sizlBitmap.cx;
                prclPat->bottom = pCloneSO[CSI_PAT].pso->sizlBitmap.cy;
            }
        }
    }

    //
    // Determine if we need to clone the source
    //

    if ((ROP3_NEED_SRC(RopFG) || ROP3_NEED_SRC(RopBG))) {

        if (IsHTCompatibleSurfObj(pPDev,
                                  psoSrc,
                                  pxlo,
                                  (Flags & MIX2F_NEED_TMP) ?
                                    0 : (ISHTF_ALTFMT | ISHTF_DSTPRIM_OK))) {

            PLOTDBG(DBG_CLONESO,
                    ("CloneBitBltSURFOBJ:: Compatible HT Format, SRC=%ld, DST=%ld [ALT=%ld]",
                            psoSrc->iBitmapFormat,
                            ((PDRVHTINFO)pPDev->pvDrvHTData)->HTBmpFormat,
                            ((PDRVHTINFO)pPDev->pvDrvHTData)->AltBmpFormat));

        } else {

            PLOTDBG(DBG_CLONESO, ("CloneBitBltSURFOBJ:: CLONING SOURCE"));

            if (!(pCloneSO[CSI_SRC].pso =
                                    CloneSURFOBJToHT(pPDev,
                                                     psoDst,
                                                     psoSrc,
                                                     pxlo,
                                                     &pCloneSO[CSI_SRC].hBmp,
                                                     prclDst,
                                                     prclSrc))) {

                PLOTDBG(DBG_CLONESO, ("CloneBitBltSURFOBJ:: CLONE Source FAILED"));
                return(FALSE);
            }
        }
    }

    //
    // Create a TEMP SURFOBJ for SRC/PAT memory operation if it is required
    //

    if (Flags & MIX2F_NEED_TMP) {

        PLOTDBG(DBG_CLONESO, ("CloneBitbltSURFOBJ: CLONE SRC_TMP (%ld x %ld)",
                            prclSrc->right - prclSrc->left,
                            prclSrc->bottom - prclSrc->top));

        if (!(pCloneSO[CSI_TMP].pso =
                            CreateBitmapSURFOBJ(pPDev,
                                                &pCloneSO[CSI_TMP].hBmp,
                                                prclSrc->right - prclSrc->left,
                                                prclSrc->bottom - prclSrc->top,
                                                HTBMPFORMAT(pPDev),
                                                NULL))) {

            PLOTDBG(DBG_CLONESO, ("CloneBitBltSURFOBJ:: CLONE SRC_TMP FAILED"));
            return(FALSE);
        }
    }

    return(TRUE);
}




BOOL
DoSpecialRop3(
    SURFOBJ *psoDst,
    CLIPOBJ *pco,
    PRECTL  prclDst,
    DWORD   Rop3
    )

/*++

Routine Description:

    This function does a white or black fil

Arguments:

    psoDst  - The device surface must be DEVICE

    pco     - Clipping object

    prclDst - RECTL area to be rop'ed

    Rop3    - a special Rop3, 0x00, 0xFF, 0x55, 0xAA


Return Value:


    BOOLEAN

Author:

    15-Jan-1994 Sat 07:38:55 created  -by-  DC


Revision History:


--*/

{
    BRUSHOBJ    bo;
    DEVBRUSH    DevBrush;


    PLOTASSERT(1, "DoSpecialRop3: Passed psoDst (%08lx) != STYPE_DEVICE",
                                        psoDst->iType == STYPE_DEVICE, psoDst);

    PLOTDBG(DBG_SPECIALROP, ("DoSpecialROP[%04lx] (%ld, %ld)-(%ld, %ld)=%ld x %ld",
                                        Rop3,
                                        prclDst->left, prclDst->top,
                                        prclDst->right, prclDst->bottom,
                                        prclDst->right - prclDst->left,
                                        prclDst->bottom - prclDst->top));


    bo.iSolidColor         = (DWORD)((Rop3) ? 0x000000000 : 0x00FFFFFF);
    bo.pvRbrush            = (LPVOID)&DevBrush;

    ZeroMemory(&DevBrush, sizeof(DevBrush));

    if (!DoFill(psoDst,                     // psoDst
                NULL,                       // psoSrc
                pco,                        // pco
                NULL,                       // pxlo
                prclDst,                    // prclDst
                NULL,                       // prclSrc
                &bo,                        // pbo
                (PPOINTL)&ptlZeroOrigin,    // pptlBrushOrg
                Rop3 | (Rop3 << 8))) {      // Rop4

        PLOTERR(("DoSpecialRop3: Rop3=%08lx Failed!!!", Rop3));
        return(FALSE);
    }

    return(TRUE);
}




BOOL
DoMix2(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PPOINTL     pptlSrcOrg,
    DWORD       Mix2
    )

/*++

Routine Description:

    This function is responsible for doing a device copy of a bitmap
    with/without tiling and activating the proper Rop2

Arguments:

    pPDev       - Pointer to the PDEV

    psoDst      - pointer to the destination surface object

    psoSrc      - pointer to the source surface object

    pco         - Pointer to the CLIPOBJ

    pxlo        - the translate object from the source to the destination

    prclDst     - the output destination rectangle area

    prclSrc     - the source rectangle area

    pptlSrcOrg  - brush origin for the source rectangle, if this is NULL then
                  prclSrc will not have to be aligned on the destination

    Mix2        - a rop2 mode 0 - 0x0F

Return Value:

    BOOLEAN

Author:

    08-Feb-1994 Tue 16:33:41 updated  -by-  DC
        fixed ptlSrcOrg problem, we need to modulate with source size before
        it get used.

    27-Jan-1994 Thu 23:45:46 updated  -by-  DC
        Re-write so that it can handle the tiling more efficient.

    13-Jan-1994 Sat 09:34:06 created  -by-  JB

Revision History:


--*/
{
    RECTL       rclSrc;
    RECTL       rclDst;
    POINTL      ptlSrcOrg;
    LONG        cxSrc;
    LONG        cySrc;
    DWORD       OHTFlags = 0;
    BOOL        MemMix2;


    //
    // The final ROP is either a ROP3 or a ROP4 (no mask) and it is always
    // a rop2 operation which deals with the source and destination
    //
    // First make it into a Rop3 representation of Rop2 (Mix2)
    //

    PLOTASSERT(1, "DoMix2: Passed INVALID psoSrc (%08lx) = STYPE_DEVICE",
                    (psoSrc) &&
                    (psoSrc->iType != STYPE_DEVICE), psoSrc);

    PLOTASSERT(1, "DoMix2: Unexpected Mix2 = %u, SHOULD NOT BE HERE",
                (Mix2 != MIX2_0) && (Mix2 != MIX2_1) &&
                (Mix2 != MIX2_D) && (Mix2 != MIX2_nD), Mix2);

    Mix2 &= 0x0F;
    Mix2 |= (DWORD)(Mix2 << 4);

    switch (Mix2) {

    case 0x00:  // 0
    case 0xFF:  // 1
    case 0x55:  // ~D

        DoSpecialRop3(psoDst, pco, prclDst, Mix2);

    case 0xAA:  // D

        return(TRUE);
    }

    if (MemMix2 = (BOOL)(psoDst->iType != STYPE_DEVICE)) {

        //
        // Now make it into Rop4 representation of Rop2 (Mix2)
        //

        Mix2 |= (Mix2 << 8);

    } else {

        if (!IsHTCompatibleSurfObj(pPDev,
                                   psoSrc,
                                   pxlo,
                                   ((pxlo) ? ISHTF_ALTFMT : 0)  |
                                        ISHTF_HTXB              |
                                        ISHTF_DSTPRIM_OK)) {

            PLOTERR(("DoMix2: The psoSrc is not HT compatible format (%08lx",
                                    psoSrc->iBitmapFormat));
            return(FALSE);
        }
    }

    cxSrc = prclSrc->right - prclSrc->left;
    cySrc = prclSrc->bottom - prclSrc->top;

    if (pptlSrcOrg) {

        ptlSrcOrg = *pptlSrcOrg;

        if ((ptlSrcOrg.x = (LONG)(prclDst->left - ptlSrcOrg.x) % cxSrc) < 0) {

            ptlSrcOrg.x += cxSrc;
        }

        if ((ptlSrcOrg.y = (LONG)(prclDst->top - ptlSrcOrg.y) % cySrc) < 0) {

            ptlSrcOrg.y += cySrc;
        }

        PLOTDBG(DBG_DOMIX2, ("DoMix2: ORG ptlSrcOrg=(%ld, %ld) -> (%ld, %ld)",
                    pptlSrcOrg->x, pptlSrcOrg->y, ptlSrcOrg.x, ptlSrcOrg.y));

    } else {

        ptlSrcOrg.x =
        ptlSrcOrg.y = 0;

        PLOTDBG(DBG_DOMIX2, ("DoMix2: >>> DO NOT NEED TO ALIGN SRC on DEST <<<"));
    }

    rclSrc.top    = prclSrc->top + ptlSrcOrg.y;
    rclSrc.bottom = prclSrc->bottom;
    rclDst.top    = prclDst->top;
    rclDst.bottom = rclDst.top + (rclSrc.bottom - rclSrc.top);

    PLOTDBG(DBG_DOMIX2, ("DoMix2: SrcFormat=%ld, DstFormat=%ld %hs",
                psoSrc->iBitmapFormat,
                psoDst->iBitmapFormat,
                (MemMix2) ? "[MemMix2]" : ""));

    PLOTDBG(DBG_DOMIX2, ("DoMix2: ORG: Dst=(%ld, %ld)-(%ld,%ld), Src=(%ld, %ld)-(%ld, %ld)",
                prclDst->left, prclDst->top,
                prclDst->right, prclDst->bottom,
                prclSrc->left, prclSrc->top,
                prclSrc->right, prclSrc->bottom));

    while (rclDst.top < prclDst->bottom) {

        //
        // check if the destination bottom is overhanging, clip it,
        //
        // NOTE: This could happen the first time.
        //

        if (rclDst.bottom > prclDst->bottom) {

            //
            // Clip the source/destination rectangle, because we may do
            // EngBitBlt() or OutputHTBitmap()
            //

            rclSrc.bottom -= (rclDst.bottom - prclDst->bottom);
            rclDst.bottom  = prclDst->bottom;
        }

        rclSrc.left  = prclSrc->left + ptlSrcOrg.x;
        rclSrc.right = prclSrc->right;
        rclDst.left  = prclDst->left;
        rclDst.right = rclDst.left + (rclSrc.right - rclSrc.left);

        while (rclDst.left < prclDst->right) {

            //
            // check if the destination right edge is overhanging, clip it if
            // necessary.
            //
            // NOTE: This could happen the first time.
            //

            if (rclDst.right > prclDst->right) {

                //
                // Clip the source/destination rectangle, because we may do a
                // EngBitBlt() or OutputHTBitmap()
                //

                rclSrc.right -= (rclDst.right - prclDst->right);
                rclDst.right  = prclDst->right;
            }

            PLOTDBG(DBG_DOMIX2, ("DoMix2: TILE: Dst=(%ld, %ld)-(%ld,%ld), Src=(%ld, %ld)-(%ld, %ld)",
                        rclDst.left, rclDst.top, rclDst.right, rclDst.bottom,
                        rclSrc.left, rclSrc.top, rclSrc.right, rclSrc.bottom));

            if (MemMix2) {

                //
                // In the memory version we don't have to worry about PCO so
                // just call EngBitBlt to do the work.
                //

                if (!(EngBitBlt(psoDst,                     // psoDst
                                psoSrc,                     // psoSrc
                                NULL,                       // psoMask
                                pco,                        // pco
                                NULL,                       // pxlo
                                &rclDst,                    // prclDst
                                (PPOINTL)&rclSrc,           // pptlSrc
                                NULL,                       // pptlMask
                                NULL,                       // pbo
                                (PPOINTL)&ptlZeroOrigin,    // pptlBrushOrg
                                Mix2))) {

                    PLOTERR(("DoMix2: EngBitBlt(MemMix2=%04lx) Failed!!!",Mix2));
                    return(FALSE);
                }

            } else {

                if (!OutputHTBitmap(pPDev,
                                    psoSrc,
                                    pco,
                                    (PPOINTL)&rclDst,
                                    &rclSrc,
                                    Mix2,
                                    &OHTFlags)) {

                    PLOTERR(("DoMix2: OutputHTBitmap() Failed!!!"));
                    return(FALSE);
                }
            }

            //
            // Reset <source left> to the original left margin and move the
            // destination right to the left for the next destination RECTL.
            //

            rclSrc.left   = prclSrc->left;
            rclDst.left   = rclDst.right;
            rclDst.right += cxSrc;
        }

        //
        // Reset <source top> to the original top margin and move the
        // destination bottom to the top, and set bottom for the next destination
        // RECTL.
        //

        rclSrc.top     = prclSrc->top;
        rclDst.top     = rclDst.bottom;
        rclDst.bottom += cySrc;
    }

    if (OHTFlags & OHTF_MASK) {

        OHTFlags |= OHTF_EXIT_TO_HPGL2;

        OutputHTBitmap(pPDev, psoSrc, NULL, NULL, NULL, 0xAA, &OHTFlags);
    }

    return(TRUE);
}




BOOL
DoRop3(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoPat,
    SURFOBJ     *psoTmp,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PRECTL      prclPat,
    PPOINTL     pptlPatOrg,
    BRUSHOBJ    *pbo,
    DWORD       Rop3
    )

/*++

Routine Description:

    This function performs ROP3 operations (one at a time)


Arguments:

    pPDev       - Pointer to the PDEV

    psoDst      - pointer to the destination surface object

    psoSrc      - pointer to the source surface object

    psoPat      - Pointer to the pattern surface object

    psoTmp      - pointer to the temp buffer surface object

    pco         - clip object

    prclDst     - pointer to the destination rectangle

    prclSrc     - pointer to the source rectangle

    prclPat     - pointer to the pattern rectangle

    pptlPatOrg  - Pointer to the brush origin, if this is NULL then its assumed
                  the pattern's prclPat does not have to be aligned on the
                  destination

    pbo         - a Brush object if we need to call DoFill()

    Rop3        - a ROP3 to be performed


Return Value:

    BOOL

Author:

    20-Jan-1994 Thu 02:36:00 created  -by-  DC

    27-Jan-1994 Thu 23:46:28 updated  -by-  DC
        Re-write to take other parameter, also move the cloning surface objects
        to the caller (ie. DrvBitBlt())

Revision History:


--*/

{
    RECTL   rclTmp;
    DWORD   SDMix;
    DWORD   Mix2;
    BYTE    Flags;
    UINT    Count;
    BOOL    InvertMix2;
    BOOL    Ok;


    PLOTDBG(DBG_ROP3, ("DoRop3: Rop3=%08lx", Rop3));

    switch (Rop3 &= 0xFF) {

    case 0x00:  // 0
    case 0xFF:  // 1
    case 0x55:  // ~D

        DoSpecialRop3(psoDst, pco, prclDst, Rop3);

    case 0xAA:  // D

        //
        // This is NOP
        //

        return(TRUE);
    }

    //
    // Invert Rop3 if we are out of the data range (128-255) and then invert
    // the final result (by inverting last Mix2 Rop2 code (0-15), all Rop3/Rop2
    // codes are symmetric.
    //

    if (Rop3 >= 0x80) {

        InvertMix2 = TRUE;
        SDMix      = (DWORD)Rop3ToSDMix[Rop3 ^ 0xFF];

        PLOTDBG(DBG_ROP3, ("DoRop3: Need Invert ROP"));

    } else {

        InvertMix2 = FALSE;
        SDMix      = (DWORD)Rop3ToSDMix[Rop3];
    }

    if (psoTmp) {

        rclTmp.left   =
        rclTmp.top    = 0;
        rclTmp.right  = psoTmp->sizlBitmap.cx;
        rclTmp.bottom = psoTmp->sizlBitmap.cy;
    }

    Flags = GET_SDMIX_MIX2F(SDMix);
    Count = (UINT)GET_MIX2F_COUNT(Flags);
    Ok    = TRUE;

    PLOTDBG(DBG_ROP3, ("SDMix=%08lx, Flags=%02x, Count=%u", SDMix, Flags, Count));

    if (Flags & MIX2F_MUL_DST) {

        PLOTWARN(("DoRop3: *** Rop3=%08lx Has Multiple DEST, Mix2s NOT complete ***", Rop3));
    }

    while ((Ok) && (Count--)) {

        Mix2 = (DWORD)(SDMix & MIX2_MASK);

        if ((!Count) && (InvertMix2)) {

            PLOTDBG(DBG_ROP3, ("DoRop3: Invert Last MIX2 %02lx -> %02lx",
                                        Mix2, Mix2 ^ MIX2_MASK));

            Mix2 ^= MIX2_MASK;
        }

        PLOTDBG(DBG_ROP3, ("DoRop3: SD=%02lx, Mix2=%02lx",
                                        SDMix & MIXSD_MASK, Mix2));

        switch (SDMix & MIXSD_MASK) {

        case MIXSD_SRC_DST:

            PLOTASSERT(1, "DoRop3: MIXSD_SRC_DST but psoSrc = NULL, Rop3=%08lx",
                                psoSrc, Rop3);

            Ok = DoMix2(pPDev,
                        psoDst,
                        psoSrc,
                        pco,
                        pxlo,
                        prclDst,
                        prclSrc,
                        NULL,
                        Mix2);

            break;

        case MIXSD_PAT_DST:

            if (psoPat) {

                Ok = DoMix2(pPDev,
                            psoDst,
                            psoPat,
                            pco,
                            NULL,
                            prclDst,
                            prclPat,
                            pptlPatOrg,
                            Mix2);

            } else {

                //
                // A compatible brush object is passed, use DoFill() to do
                // the actual work.
                //

                Mix2 += 1;
                Mix2  = MixToRop4(Mix2 | (Mix2 << 8));

                PLOTDBG(DBG_ROP3, ("DoRop3: DoFill[%04lx] (%ld, %ld)-(%ld, %ld)=%ld x %ld",
                                        Mix2, prclDst->left, prclDst->top,
                                        prclDst->right, prclDst->bottom,
                                        prclDst->right - prclDst->left,
                                        prclDst->bottom - prclDst->top));

                Ok = DoFill(psoDst,                 // psoDst
                            NULL,                   // psoSrc
                            pco,                    // pco
                            NULL,                   // pxlo
                            prclDst,                // prclDst
                            NULL,                   // prclSrc
                            pbo,                    // pbo
                            pptlPatOrg,             // pptlBrushOrg
                            Mix2);                  // Rop4
            }

            break;

        case MIXSD_SRC_PAT:

            PLOTASSERT(1, "DoRop3: MIXSD_SRC_PAT but psoSrc = NULL, Rop3=%08lx",
                                psoSrc, Rop3);
            PLOTASSERT(1, "DoRop3: MIXSD_SRC_PAT but psoPat = NULL, Rop3=%08lx",
                                psoPat, Rop3);
            PLOTASSERT(1, "DoRop3: MIXSD_SRC_PAT but psoTmp = NULL, Rop3=%08lx",
                                psoTmp, Rop3);

            //
            // Firs tile the pattern onto the temp buffer then do SRC/DST
            // using SRCCOPY = MIX2_S
            //

            if (pptlPatOrg) {

                //
                // This is a real pattern we have to tile and align it onto the
                // desination, but since psoTmp is 0,0 - cx,cy we must alter
                // the pptlPatOrg to make it align correctly.
                //

                pptlPatOrg->x -= prclDst->left;
                pptlPatOrg->y -= prclDst->top;
            }

            Ok = DoMix2(pPDev,
                        psoTmp,
                        psoPat,
                        NULL,
                        NULL,
                        &rclTmp,
                        prclPat,
                        pptlPatOrg,
                        MIX2_S);

            if (pptlPatOrg) {

                pptlPatOrg->x += prclDst->left;
                pptlPatOrg->y += prclDst->top;
            }

            //
            // Now We will do the MIX2 operation between SRC and PAT
            //

            if (Ok) {

                Ok = DoMix2(pPDev,
                            psoTmp,
                            psoSrc,
                            NULL,
                            NULL,
                            &rclTmp,
                            prclSrc,
                            NULL,
                            Mix2);
            }

            break;

        case MIXSD_TMP_DST:

            PLOTASSERT(1, "DoRop3: MIXSD_TMP_DST but psoTmp = NULL, Rop3=%08lx",
                                psoTmp, Rop3);

            //
            // Since we already aligned the pattern on the temp buffer
            // we can just do the mix2 without aligning it again.
            //

            Ok = DoMix2(pPDev,
                        psoDst,
                        psoTmp,
                        pco,
                        NULL,
                        prclDst,
                        &rclTmp,
                        NULL,
                        Mix2);

            break;
        }

        SDMix >>= SDMIX_SHIFT_COUNT;
    }

    if (!Ok) {

        PLOTERR(("DoRop3: FAILED in DoMix2() operations"));
    }

    return(Ok);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\precomp.h ===
#include <stddef.h>
#include <stdlib.h>
#include <windows.h>
#include <winddi.h>

#define _WINDEFP_NO_PDEVBRUSH
#include <winspool.h>
#include <plotgpc.h>
#include <plotdm.h>
#include <plotters.h>
#include <plotlib.h>
#include <string.h>

#include "enable.h"
#include "bitblt.h"
#include "pencolor.h"
#include "polygon.h"
#include "ropblt.h"
#include "output.h"
#include "htblt.h"
#include "plotform.h"
#include "escape.h"
#include "compress.h"
#include "htbmp1.h"
#include "htbmp4.h"
#include "transpos.h"
#include "brush.h"
#include "path.h"
#include "textout.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\polygon.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    polygon.c


Abstract:

    This module contains path forming code utilized by the rest of the
    driver. Path primitive functions (such as DrvStrokePath, DrvTextOut)
    use this code to generate and fill and stroke paths.
    Since this code is aware of all the combinations of complex paths and
    complex clipping regions and how to deal with them.

Author:

    15:30 on Wed 09 Mar 1993    -by-    KL
        Created it

    15-Nov-1993 Mon 19:42:05 updated  -by-  DC,V-JB
        clean up / fixed / add debugging information

    27-Jan-1994 Thu 23:40:57 updated  -by-  DC
        Add user defined pattern caching

    16-Mar-1994 Wed 11:21:02 updated  -by-  DC
        Add SetBrushOrigin() so we can align brush origins for filling
        correctly


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//
// General debug flags for module, see dbgread.txt for overview.
//

#define DBG_PLOTFILENAME    DbgPolygon

#define DBG_GENPOLYGON      0x00000001
#define DBG_GENPOLYPATH     0x00000002
#define DBG_BEZIER          0x00000004
#define DBG_DORECT          0x00000008
#define DBG_FILL_CLIP       0x00000010
#define DBG_CHECK_FOR_WHITE 0x00000020
#define DBG_USERPAT         0x00000040
#define DBG_FILL_LOGIC      0x00000080
#define DBG_HANDLELINEATTR  0x00000100

DEFINE_DBGVAR(0);

//
// Derive new rect by offsetting the source rect
//

#define POLY_GEN_RECTFIX(dest, src, offset) { dest.x = src->x + offset.x;   \
                                              dest.y = src->y + offset.y; }

//
// Build table with HPGL2 commands for cursor movement, and path construction.
//

static BYTE __ER[]    = { 'E', 'R'      };
static BYTE __RR[]    = { 'R', 'R'      };
static BYTE __EP[]    = { 'E', 'P'      };
static BYTE __FP[]    = { 'F', 'P'      };
static BYTE __PM0[]   = { 'P', 'M', '0' };
static BYTE __PM1[]   = { 'P', 'M', '1' };
static BYTE __PM2[]   = { 'P', 'M', '2' };
static BYTE __TR0[]   = { 'T', 'R', '0' };
static BYTE __TR1[]   = { 'T', 'R', '1' };
static BYTE __SEMI[]  = { ';'           };
static BYTE __1SEMI[] = { '1', ';'      };
static BYTE __BR[]    = { 'B', 'R'      };
static BYTE __BZ[]    = { 'B', 'Z'      };
static BYTE __PE[]    = { 'P', 'E'      };
static BYTE __PD[]    = { 'P', 'D'      };
static BYTE __COMMA[] = { ','           };


//
// Make MACROS for sending out command streams to device
//

#define SEND_ER(pPDev)      OutputBytes(pPDev, __ER    , sizeof(__ER   ) );
#define SEND_RR(pPDev)      OutputBytes(pPDev, __RR    , sizeof(__RR   ) );
#define SEND_EP(pPDev)      OutputBytes(pPDev, __EP    , sizeof(__EP   ) );
#define SEND_FP(pPDev)      OutputBytes(pPDev, __FP    , sizeof(__FP   ) );
#define SEND_PM0(pPDev)     OutputBytes(pPDev, __PM0   , sizeof(__PM0  ) );
#define SEND_PM1(pPDev)     OutputBytes(pPDev, __PM1   , sizeof(__PM1  ) );
#define SEND_PM2(pPDev)     OutputBytes(pPDev, __PM2   , sizeof(__PM2  ) );
#define SEND_TR0(pPDev)     OutputBytes(pPDev, __TR0   , sizeof(__TR0  ) );
#define SEND_TR1(pPDev)     OutputBytes(pPDev, __TR1   , sizeof(__TR1  ) );
#define SEND_SEMI(pPDev)    OutputBytes(pPDev, __SEMI  , sizeof(__SEMI ) );
#define SEND_1SEMI(pPDev)   OutputBytes(pPDev, __1SEMI , sizeof(__1SEMI) );
#define SEND_BR(pPDev)      OutputBytes(pPDev, __BR    , sizeof(__BR   ) );
#define SEND_BZ(pPDev)      OutputBytes(pPDev, __BZ    , sizeof(__BZ   ) );
#define SEND_PE(pPDev)      OutputBytes(pPDev, __PE    , sizeof(__PE   ) );
#define SEND_PD(pPDev)      OutputBytes(pPDev, __PD    , sizeof(__PD   ) );
#define SEND_COMMA(pPDev)   OutputBytes(pPDev, __COMMA , sizeof(__COMMA) );


#define TERM_PE_MODE(pPDev, Mode)                                           \
{                                                                           \
    if (Mode == 'PE') {                                                     \
                                                                            \
        SEND_SEMI(pPDev);                                                   \
        Mode = 0;                                                           \
    }                                                                       \
}

#define SWITCH_TO_PE(pPDev, Mode, PenIsDown)                                \
{                                                                           \
    if (Mode != 'PE') {                                                     \
                                                                            \
        SEND_PE(pPDev);                                                     \
        Mode      = 'PE';                                                   \
        PenIsDown = TRUE;                                                   \
    }                                                                       \
}


#define SWITCH_TO_BR(pPDev, Mode, PenIsDown)                                \
{                                                                           \
    TERM_PE_MODE(pPDev, Mode)                                               \
                                                                            \
    if (Mode != 'BR') {                                                     \
                                                                            \
        if (!PenIsDown) {                                                   \
                                                                            \
            SEND_PD(pPDev);                                                 \
            PenIsDown = TRUE;                                               \
        }                                                                   \
                                                                            \
        SEND_BR(pPDev);                                                     \
        Mode = 'BR';                                                        \
                                                                            \
    } else {                                                                \
                                                                            \
        SEND_COMMA(pPDev);                                                  \
    }                                                                       \
}


#define PLOT_IS_WHITE(pdev, ulCol)  (ulCol == WHITE_INDEX)
#define TOGGLE_DASH(x)              ((x) ? FALSE : TRUE)

#define ROP4_USE_DEST(Rop4)         ((Rop4 & 0x5555) != ((Rop4 & 0xAAAA) >> 1))
#define SET_PP_WITH_ROP4(pPDev, Rop4)                                       \
    SetPixelPlacement(pPDev, (ROP4_USE_DEST(Rop4)) ? SPP_MODE_EDGE :        \
                                                     SPP_MODE_CENTER)



VOID
SetBrushOrigin(
    PPDEV   pPDev,
    PPOINTL pptlBrushOrg
    )

/*++

Routine Description:

    This function sets the brush origin onto the device for the next brush
    fill. Brush origins are used in order for paths being filled to line up
    correctly. In this way, if many different paths are filled, the patterns
    will line up based on the pattern being repeated starting at the correct
    origin.


Arguments:

    pPDev           - Pointer to our PDEV

    pptlBrushOrg    - Pointer to the brush origin to be set


Return Value:

    VOID

Author:

    16-Mar-1994 Wed 10:56:46 created  -by-  DC


Revision History:


--*/

{
    POINTL  ptlAC;


    if (pptlBrushOrg) {

        ptlAC = *pptlBrushOrg;

    } else {

        ptlAC.x =
        ptlAC.y = 0;
    }


    //
    // Check to see if the origin is different, and if it is output the
    // new origin to the device.
    //

    if ((ptlAC.x != pPDev->ptlAnchorCorner.x) ||
        (ptlAC.y != pPDev->ptlAnchorCorner.y)) {

        OutputString(pPDev, "AC");

        if ((ptlAC.x) || (ptlAC.y)) {

            OutputLONGParams(pPDev, (PLONG)&ptlAC, 2, 'd');
        }

        //
        // Save the current setting
        //

        pPDev->ptlAnchorCorner = ptlAC;
    }
}




BOOL
DoRect(
    PPDEV       pPDev,
    RECTL       *pRectl,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    POINTL      *pptlBrush,
    ROP4        rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    )

/*++

Routine Description:

    This function will draw and optionally fill a rectangle. It uses seperate
    BRUSHOBJ's for the outline and interior of the rectangle. Since the stroke
    operation may include data for a styled line (dashes etc.) the LINEATTRS
    structure is included as well.

Arguments:

    pPDev           - Pointer to our PDEV

    pRectl          - rectangle area to fill

    pBrushFill      - Brush used to fill the rectangle

    pBrushStroke    - Brush used to stroke the rectangle

    pptlBrush       - brush origin

    rop4            - rop to be used

    plineattrs      - Pointer to the line attributes for a styled line

    ulFlags         - FPOLY_xxxx flags


Return Value:

    TRUE if sucessful and false if not


Author:

    15-Feb-1994 Tue 11:59:52 updated  -by-  DC
        We will do RR or RA now

    24-Mar-1994 Thu 19:37:05 updated  -by-  DC
        Do local MovePen and make sure we at least output ONE RASTER PEL

Revision History:


--*/

{
    POINTL      ptlPlot;
    SIZEL       szlRect;


    if (PLOT_CANCEL_JOB(pPDev)) {

        return(FALSE);
    }

    //
    // Check to see if we can short cut some of our work if its a pen plotter
    //

    if (PlotCheckForWhiteIfPenPlotter(pPDev,
                                      pBrushFill,
                                      pBrushStroke,
                                      rop4,
                                      &ulFlags))  {
        return(TRUE);
    }

    PLOTDBG(DBG_DORECT,
            ("DoRect: Passed In RECTL=(%ld, %ld)-(%ld, %ld)=%ld x %ld",
                pRectl->left,   pRectl->top,
                pRectl->right,  pRectl->bottom,
                pRectl->right -  pRectl->left,
                pRectl->bottom -  pRectl->top));

    ptlPlot.x  = LTODEVL(pPDev, pRectl->left);
    ptlPlot.y  = LTODEVL(pPDev, pRectl->top);
    szlRect.cx = LTODEVL(pPDev, pRectl->right)  - ptlPlot.x;
    szlRect.cy = LTODEVL(pPDev, pRectl->bottom) - ptlPlot.y;


    //
    // No need to fill an empty rectangle.
    //

    if ((szlRect.cx) && (szlRect.cy)) {

        SET_PP_WITH_ROP4(pPDev, rop4);

        //
        // If the rectangle is not of sufficient size to actually cause any
        // bits to appear on the target device, we grow the rectangle
        // to the correct amount. This is done because the target device
        // may after converting to physical units, decide there is no work to
        // do. In this case nothing would show up on the page at all. So we
        // opt to have at least a one pixel object show up.
        //

        if (szlRect.cx < (LONG)pPDev->MinLToDevL) {

            PLOTWARN(("DoRect: cxRect=%ld < MIN=%ld, Make it as MIN",
                            szlRect.cx, (LONG)pPDev->MinLToDevL));

            szlRect.cx = (LONG)pPDev->MinLToDevL;
        }

        if (szlRect.cy < (LONG)pPDev->MinLToDevL) {

            PLOTWARN(("DoRect: cyRect=%ld < MIN=%ld, Make it as MIN",
                            szlRect.cy, (LONG)pPDev->MinLToDevL));

            szlRect.cy = (LONG)pPDev->MinLToDevL;
        }

        //
        // Do the MOVE PEN.
        //

        OutputFormatStr(pPDev, "PE<=#D#D;", ptlPlot.x, ptlPlot.y);

        PLOTDBG(DBG_DORECT,
                ("DoRect: PLOTUNIT=%ld, MovePen=(%ld, %ld), RR=%ld x %ld",
                pPDev->pPlotGPC->PlotXDPI,
                ptlPlot.x, ptlPlot.y, szlRect.cx, szlRect.cy));

        //
        // Since all the parameters are set up correctly, call the core routine
        // for filling a rectangle.
        //

        DoFillLogic(pPDev,
                    pptlBrush,
                    pBrushFill,
                    pBrushStroke,
                    rop4,
                    plineattrs,
                    &szlRect,
                    ulFlags);

    } else {

        PLOTDBG(DBG_DORECT, ("DoRect: Pass a NULL Rectl, Do NOTHING"));
    }

    return(!PLOT_CANCEL_JOB(pPDev));
}



BOOL
DoFillByEnumingClipRects(
    PPDEV       pPDev,
    POINTL      *ppointlOffset,
    CLIPOBJ     *pco,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    ROP4        Rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    )

/*++

Routine Description:

    This function, fills a CLIPOBJ by enurating the CLIPOBJ as seperate
    rectangles and filling each of them in turn. This is typically done when
    the CLIPOBJ is comprised of so many path objects, that the path cannot
    be described in HPGL2 (overfilling the path buffer in the target device).


Arguments:

    pPDev           - Pointer to our PDEV

    ppointlOffset   - Extra offset to the output polygon

    pClipObj        - clip object

    pPointlBrushOrg - brush origin for the fill brush.

    pBrushFill      - Brush used to fill the rectangle

    Rop4            - rop to be used

    plineattrs      - Pointer to the line attributes for a styled line

    ulFlags         - FPOLY_xxxx flags


Return Value:

    BOOL    TRUE  - Function succeded
            FALSE - Function failed.

Author:

    28-Nov-1993 created  -by-  JB

    18-Dec-1993 Sat 10:35:24 updated  -by-  DC
        use PRECTL rather RECTL *, and use INT rater than int, removed compiler
        warning which has unreferenced local variable

    16-Feb-1994 Wed 16:12:53 updated  -by-  DC
        Re-structure and make it Polyline encoded

    09-Apr-1994 Sat 16:38:16 updated  -by-  DC
        Fixed the ptlCur++ twice typo which make us Do the RECT crazy.

Revision History:


--*/
{
    PRECTL      prclCur;
    POINTFIX    ptsFix[4];
    HTENUMRCL   EnumRects;
    POINTL      ptlCur;
    DWORD       MaxRects;
    DWORD       cRects;
    BOOL        bMore;
    BOOL        NeedSendPM0;



    PLOTDBG(DBG_FILL_CLIP,
            ("DoFillByEnumingRects: Maximum polygon points = %d",
                        pPDev->pPlotGPC->MaxPolygonPts));

    PLOTASSERT(1, "DoFillByEnumingRects: Minimum must be 5 points [%ld]",
                pPDev->pPlotGPC->MaxPolygonPts >= 5,
                pPDev->pPlotGPC->MaxPolygonPts);

    //
    // In this mode we will enter polygon mode and try to batch based on the
    // number of points the device can handle in its polygon buffer.
    //

    bMore       = FALSE;
    EnumRects.c = 1;

    if ((!pco) || (pco->iDComplexity == DC_TRIVIAL)) {

        PLOTASSERT(1, "DoFillByEnumingClipRects: Invalid pco TRIVIAL passed (%08lx)",
                    (pco) && (pco->iDComplexity != DC_TRIVIAL), pco);

        return(FALSE);

    } else if (pco->iDComplexity == DC_RECT) {

        //
        // The visible area is one rectangle intersect with the destinaiton
        //

        PLOTDBG(DBG_FILL_CLIP, ("DoFillByEnumingClipRects: pco=DC_RECT"));

        EnumRects.rcl[0] = pco->rclBounds;

    } else {

        //
        // We have complex clipping region to be computed, call engine to start
        // enumerate the rectangles and set More = TRUE so we can get the first
        // batch of rectangles.
        //

        PLOTDBG(DBG_FILL_CLIP, ("DoFillByEnumingClipRects: pco=DC_COMPLEX, EnumRects now"));

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        bMore = TRUE;
    }


    //
    // Calculate how many rects we can do at a time, based on how large of
    // a polygon buffer the target device can hold. Make sure that value
    // is at least 1.
    //

    if (!(MaxRects = (DWORD)pPDev->pPlotGPC->MaxPolygonPts / 7)) {

        MaxRects = 1;
    }

    cRects      = MaxRects;
    NeedSendPM0 = TRUE;

    do {


        //
        // If the job was cancelled, break out now. This is typically done
        // anytime the code enters some looping that may take a while.
        //

        if (PLOT_CANCEL_JOB(pPDev)) {

            return(FALSE);
        }

        //
        // If More is true then we need to get next batch of rectangles
        //

        if (bMore) {

            bMore = CLIPOBJ_bEnum(pco, sizeof(EnumRects), (ULONG *)&EnumRects);

            if (!EnumRects.c) {

                PLOTWARN(("DoFillByEnumingClipRects: MORE CLIPOBJ_bEnum BUT Count=0"));
            }
        }


        PLOTDBG( DBG_FILL_CLIP,
                ("DoFillByEnumingClipRects: Doing batch of %ld clip rects",
                EnumRects.c));


        //
        // prclCur will point to the first enumerated rectangle
        //

        prclCur = (PRECTL)&EnumRects.rcl[0];

        while (EnumRects.c--) {

            ptsFix[3].x = LTOFX(prclCur->left);
            ptsFix[3].y = LTOFX(prclCur->top);

            MovePen(pPDev, &ptsFix[3], &ptlCur);

            if (NeedSendPM0) {

                SEND_PM0(pPDev);

                NeedSendPM0 = FALSE;
            }

            ptsFix[0].x = LTOFX(prclCur->right);
            ptsFix[0].y = ptsFix[3].y;

            ptsFix[1].x = ptsFix[0].x;
            ptsFix[1].y = LTOFX(prclCur->bottom);;

            ptsFix[2].x = ptsFix[3].x;
            ptsFix[2].y = ptsFix[1].y;

            SEND_PE(pPDev);

            OutputXYParams(pPDev,
                           (PPOINTL)ptsFix,
                           (PPOINTL)NULL,
                           (PPOINTL)&ptlCur,
                           (UINT)4,
                           (UINT)1,
                           'F');


            PLOTDBG(DBG_FILL_CLIP,
               ("DoFillByEnumingRects: Rect = (%ld, %ld) - (%ld, %ld)",
                 FXTOL(ptsFix[3].x), FXTOL( ptsFix[3].y),
                 FXTOL(ptsFix[1].x), FXTOL( ptsFix[1].y) ));

#if DBG
            if ((FXTODEVL(pPdev, ptsFix[1].x - ptsFix[3].x) >= (1016 * 34)) ||
                (FXTODEVL(pPdev, ptsFix[1].y - ptsFix[3].y) >= (1016 * 34)))  {

                PLOTWARN(("DoFillByEnumingClipRect: *** BIG RECT (%ld x %ld) *****",
                            FXTODEVL( pPDev, ptsFix[1].x - ptsFix[3].x),
                            FXTODEVL( pPDev, ptsFix[1].y - ptsFix[3].y)));
            }
#endif

            SEND_SEMI(pPDev);
            SEND_PM1(pPDev);
            SEND_SEMI(pPDev);

            //
            // 5 points per RECT polygon, so if we hit the limit then batch
            // it out first. we also calling the DoFillLogic when we are at
            // the very last enumeration of clipping rectangle.
            //

            --cRects;
            ++prclCur;

            if ((!cRects)     ||
                ((!EnumRects.c) && (!bMore))) {

                PLOTDBG(DBG_FILL_CLIP,
                        ("DoFillByEnumingRects: Hit MaxPolyPts limit"));

                //
                // We have hit the limit so close the polygon and do the fill
                // logic then continue till were done
                //

                SEND_PM2(pPDev);
                SETLINETYPESOLID(pPDev);

                DoFillLogic(pPDev,
                            pPointlBrushOrg,
                            pBrushFill,
                            NULL,
                            Rop4,
                            plineattrs,
                            NULL,
                            ulFlags);

                //
                // Reset the count of points generated thus far, and set the
                // flag to init polygon mode
                //

                cRects      = MaxRects;
                NeedSendPM0 = TRUE;
            }
        }

    } while (bMore);

    if (cRects != MaxRects) {

        PLOTWARN(("DoFillByEnumingRects: Why are we here?? Send Last Batch of =%ld",
                    MaxRects - cRects));

        SEND_PM2(pPDev);
        SETLINETYPESOLID(pPDev);

        DoFillLogic(pPDev,
                    pPointlBrushOrg,
                    pBrushFill,
                    NULL,
                    Rop4,
                    plineattrs,
                    NULL,
                    ulFlags);
    }

    return(!PLOT_CANCEL_JOB(pPDev));
}




BOOL
PlotCheckForWhiteIfPenPlotter(
    PPDEV       pPDev,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        rop4,
    PULONG      pulFlags
    )

/*++

Routine Description:

    This function checks to see if we can safely ignore a drawing command
    if it will cause only white to get rendered. Although this is legal on
    a raster device (white fill over some other previously rendered object),
    it doesn't make sense on a pen plotter.

Arguments:

    pPDev           - Pointer to our PDEV

    pBrushFill      - Brush used to fill the rectangle

    pBrushStroke    - Brush used to stroke the rectangle

    rop4            - rop to be used

    pulFlags        - FPOLY_xxxx flags, may be reset.


Return Value:

    BOOL    TRUE  - Bypass future operations
            FALSE - Operation needs to be completed

Author:

    28-Nov-1993 created  -by-  James Bratsanos (v-jimbr)

    15-Jan-1994 Sat 04:57:55 updated  -by-  DC
        Change GetColor() and make it tab 5


Revision History:


--*/
{

    ULONG   StrokeColor;
    ULONG   FillColor;


    //
    // Initially we do a quick check if were a PEN plotter to get rid of
    // either filling or stroking white. If we are a raster device, we
    // support filling white, so we cannot ignore the call.
    //

    if (!IS_RASTER(pPDev)) {

        //
        // Check to see if filling is enabled and if it is undo the fill flag
        // if the fill color is white.
        //

        if (*pulFlags & FPOLY_FILL ) {

            //
            // Get the fill color so we can look at it and decide if its a NOOP
            // on pen plotters. If it is, undo the FILL flag.
            //

            GetColor(pPDev, pBrushFill, &FillColor, NULL, rop4);

            if (PLOT_IS_WHITE( pPDev, FillColor)) {

                *pulFlags &= ~FPOLY_FILL;
            }
        }


        if (*pulFlags & FPOLY_STROKE) {

            //
            // Get the Stroke color so we can look at it and decide it its a
            // NOOP on pen plotters. If it is, undo the STROKE flag.
            //

            GetColor(pPDev, pBrushStroke, &StrokeColor, NULL, rop4);

            if (PLOT_IS_WHITE(pPDev, StrokeColor)) {

               *pulFlags &= ~FPOLY_STROKE;
            }
        }

        if (!(*pulFlags & (FPOLY_STROKE | FPOLY_FILL))) {

            //
            // Nothing left to do so simply return success
            //

            PLOTDBG(DBG_CHECK_FOR_WHITE,
                     ("PlotCheckForWhiteIfPen: ALL WHITE detected"));
            return(TRUE);
        }

        PLOTDBG(DBG_CHECK_FOR_WHITE,
                 ("PlotCheckForWhiteIfPen: Painting required!"));
    }

    return(FALSE);
}



BOOL
DoPolygon(
    PPDEV       pPDev,
    POINTL      *ppointlOffset,
    CLIPOBJ     *pClipObj,
    PATHOBJ     *pPathObj,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        rop4,
    LINEATTRS   *plineattrs,
    ULONG       ulFlags
    )

/*++

Routine Description:

    This function is the core path handling function for the entire driver.
    The passed PATHOBJ and CLIPOBJ are looked at, and various logic is
    enabled to determine the correct sequence of events to get the target
    path filled. Since HPGL2 cannot handle complex clipping, this function
    must deal with the issue of having both a COMPLEX CLIPOBJ, and a
    COMPLEX PATHOBJ. When this function decides the work it needs to do
    is too complex, it fails this call, the NT graphics engine in turn will
    break down the work, most likely calling DrvPaint multiple times in
    order to get the object drawn.

Arguments:

    pPDev           - Pointer to our PDEV

    ppointlOffset   - Extra offset to the output polygon

    pClipObj        - clip object

    pPathObj        - The path object to be used

    pPointlBrushOrg - brush origin in the brush to be fill or stroke

    pBrushFill      - brush object to be used in the FILL

    pBrushStroke    - brush object to be used in the STROKE

    rop4            - Rop4 used in the fill

    plineattrs      - LINEATTRS for style lines stroke

    ulFlags         - polygon flags for stroke or fill


Return Value:

    BOOL    TRUE  - Function succeded
            FALSE - Function failed

Author:

    28-Nov-1993 created  -by-  James Bratsanos (v-jimbr)

    28-Jan-1994 Fri 00:58:25 updated  -by-  DC
        Style, commented, re-structure the loop and reduce code size.

    04-Aug-1994 Thu 20:00:23 updated  -by-  DC
        bug# 22348 which actually is a raster plotter firmware bug


Revision History:


--*/
{
    PRECTL      prclClip = NULL;
    POINTFIX    *pptfx;
    POINTFIX    ptOffsetFix;
    POINTFIX    ptStart;
    POINTL      ptlCur;
    PATHDATA    pd;
    DWORD       cptfx;
    DWORD       cptExtra;
    UINT        cCurPosSkips;
    WORD        PolyMode;
    BOOL        bPathCameFromClip = FALSE;
    BOOL        bStrokeOnTheFly    = FALSE;
    BOOL        bFirstSubPath;
    BOOL        bMore;
    BOOL        bRet;
    BOOL        PenIsDown;
    BYTE        NumType;


    //
    // Check to see if we can short cut some of our work if its a pen plotter
    //

    if (PlotCheckForWhiteIfPenPlotter(pPDev,
                                      pBrushFill,
                                      pBrushStroke,
                                      rop4,
                                      &ulFlags))  {
        return(TRUE);
    }

    //
    // There are a few different scenarios to deal with here when the
    // item in question is too complex and we need to fail. They are
    // catagorized as follows
    //
    //    1) The fill mode is unsupported, in which case we fail the call
    //       and it should come back in in a simpler format (DrvPaint)
    //
    //    2) We have a CLIPOBJ thats more complicated than a RECT and, a
    //       PATHOBJ, if we only have a clipobj we can enum it as a path
    //

    if ((ulFlags & FPOLY_WINDING) &&
        (!IS_WINDINGFILL(pPDev))) {

       //
       // The plotter cannot support WINDING Mode fills, all we can do
       // is fail the call and have it come back in a mode we can support
       //

       PLOTDBG(DBG_GENPOLYGON, ("DoPolygon: Can't do WINDING, return(FALSE)"));

       return(FALSE);
    }

    if (pClipObj != NULL) {

       //
       // We have a clipobj so decide what to do
       //

       if (pClipObj->iDComplexity == DC_COMPLEX) {

            //
            // Since the clipobj is complex we have two choices, either there is
            // no PATHOBJ, in which case we will enum the clipobj as a path, or
            // if there is a pathobj we must fail the call. HPGL2 doesn't
            // support COMPLEX clipping objects.
            //

            if (pPathObj != NULL) {

                //
                // We have a complex clip and a path? we cannot handle this so
                // fail the call, the NT graphics engine will simplify the
                // object by calling into other primitives (like DrvPaint).
                //

                PLOTDBG(DBG_GENPOLYGON,
                        ("DoPolygon: pco=COMPLEX, pPath != NULL, can handle, FALSE"));

                return(FALSE);
            }

            //
            // We have come this far, so we must have a CLIPOBJ that is complex
            // and we will go ahead and enum it as a path.
            //

            if ((pPathObj = CLIPOBJ_ppoGetPath(pClipObj)) == NULL) {

                PLOTRIP(("Engine path from clipobj returns NULL"));
                return(FALSE);
            }


            //
            // Record the fact that the PATHOBJ is really coming froma CLIPOBJ
            //

            bPathCameFromClip = TRUE;

       } else if (pClipObj->iDComplexity == DC_RECT) {

            //
            // We have a RECT CLIPOBJ, if we have no PATHOBJ we simply fill
            // the clipping rectangle. If we do have a PATHOBJ we need to set
            // the HPGL2 clip window before enumerating and filling the PATHOBJ.
            //

            if (pPathObj != NULL) {

                //
                // Some plotters have a firmware bug with clipping windows
                // when using styled lines that keep the styled lines from
                // being rendered, even though they fit inside the CLIPOBJ.
                //
                // We get around this limitation by failing this call. This in
                // turn will cause DoStrokePathByEnumingClipLines() to be used
                // instead.
                //

                if ((IS_RASTER(pPDev))                  &&
                    (ulFlags & FPOLY_STROKE)            &&
                    (plineattrs)                        &&
                    ((plineattrs->fl & LA_ALTERNATE)    ||
                     ((plineattrs->cstyle) &&
                      (plineattrs->pstyle)))) {

                    PLOTWARN(("DoPolygon: RASTER/Stroke/DC_RECT/PathObj/StyleLine: (Firmware BUG) FAILED and using EnumClipLine()"));

                    return(FALSE);
                }

                prclClip = &pClipObj->rclBounds;

            } else {

                //
                // Simply call the fill rect code and return, no more work
                // to do in this function.
                //

                return(DoRect(pPDev,
                              &pClipObj->rclBounds,
                              pBrushFill,
                              pBrushStroke,
                              pPointlBrushOrg,
                              rop4,
                              plineattrs,
                              ulFlags));

            }

        } else {

            //
            // CLIPOBJ is trivial so we simply ignore it and fill using the
            // passed PATHOBJ.
            //

            NULL;
        }

    } else {

        //
        // No CLIPOBJ so use the PATHOBJ passed in.
        //

        NULL;
    }

    //
    // Setup the offset coordinate data, in case were coming from
    // DrvTextOut. In this case there is an offset passed in that
    // must be applied to each point. This is used when the glyphs we
    // are painting, are actually interpreted as paths. In this case,
    // the paths are fixed based on the origin of the glyph. We must
    // add the current X/Y position in order to render the glyph in the
    // correct place on the page.
    //

    if (ppointlOffset) {

        ptOffsetFix.x = LTOFX(ppointlOffset->x);
        ptOffsetFix.y = LTOFX(ppointlOffset->y);

    } else {

        ptOffsetFix.x =
        ptOffsetFix.y = 0;
    }

    //
    // First we need to verify that we dont have more points than will fit
    // in our polygon buffer for this device. If this is the case we have two
    // choices. If the path did not come from a clip obj we fail this call,
    // if it did we handle this based on enuming the clipobj as rects and
    // filling. If we were also asked to stroke the PATHOBJ, we need to
    // enumerate the path yet another time.
    //

    cptfx = 0;
    cptExtra = 1;

    PATHOBJ_vEnumStart(pPathObj);

    do {

        bRet = PATHOBJ_bEnum(pPathObj, &pd);

        cptfx += pd.count;

        if ( pd.flags & PD_ENDSUBPATH ) {

            //
            // Count both the ENDSUBPATH and the PM1 as taking space...
            //

            cptExtra++;

            if (!(pd.flags & PD_CLOSEFIGURE)) {

                //
                // Since we were not asked to close the figure, we will generate
                // a move back to our starting point with the pen up, in order
                // eliminate problems with HPGL/2 closing the polygon for
                // us when we send the PM2

                cptExtra++;
            }
        }

    } while ((bRet) && (!PLOT_CANCEL_JOB(pPDev)));


    PLOTDBG(DBG_GENPOLYGON,
                ("DoPolygon: Total points = %d, Extra %d",
                cptfx, cptExtra ));

    //
    // We will only do this if we have any points to do, first set bRet to
    // true in case we were not asked to do anything.
    //

    bRet = TRUE;

    if (cptfx) {

        SET_PP_WITH_ROP4(pPDev, rop4);

        //
        // Now add in the extra points that account for the PM0 and PM1
        // since we have some REAL points in the path.
        //

        cptfx += cptExtra;


        if (cptfx > pPDev->pPlotGPC->MaxPolygonPts) {

            PLOTWARN(("DoPolygon: Too many polygon points = %ld > PCD=%ld",
                            cptfx, pPDev->pPlotGPC->MaxPolygonPts));

            if (bPathCameFromClip) {

                PLOTWARN(("DoPolygon: Using DoFillByEnumingClipRects()"));

                //
                // The path the engine created for us to enum must be freed.
                //

                EngDeletePath(pPathObj);

                //
                // Since the path is to complex to fill with native  HPLG2
                // path code, we must do it the slower way.
                //

                return(DoFillByEnumingClipRects(pPDev,
                                                ppointlOffset,
                                                pClipObj,
                                                pPointlBrushOrg,
                                                pBrushFill,
                                                rop4,
                                                plineattrs,
                                                ulFlags));

            } else {

                //
                // If were dealing with a REAL PATHOBJ and there are too many
                // points in the polygon, and were being asked to FILL, all
                // we can do is fail the call and have the NT graphics engine
                // simplify the object.
                //

                if (ulFlags & FPOLY_FILL) {

                    PLOTERR(("DoPolygon: Too many POINTS, return FALSE"));
                    return(FALSE);

                } else if (ulFlags & FPOLY_STROKE) {

                    //
                    // Since were stroking we can go ahead and do it on the
                    // fly. Rather than building up a POLYGON object in the
                    // target device and asking the device to stroke it, we
                    // simply set up the correct stroke attributes, and request
                    // each path component to be stroked individually.
                    //

                    PLOTDBG(DBG_GENPOLYGON, ("DoPolygon: Is stroking manually"));


                    //
                    // At this point were ONLY being asked to stroke so we simply
                    // setup up the stroke color and set a flag to keep us from
                    // going into polygon mode.
                    //

                    DoSetupOfStrokeAttributes( pPDev,
                                               pPointlBrushOrg,
                                               pBrushStroke,
                                               rop4,
                                               plineattrs );

                    bStrokeOnTheFly = TRUE;
                }
            }
        }

        //
        // At this point were sure to actually do some real RENDERING so set
        // the clip window in the target device.
        //

        if (prclClip) {

            PLOTDBG(DBG_GENPOLYGON,
            ("DoPolygon: Setting Clip Window to: (%ld, %ld)-(%ld, %ld)=%ld x %ld",
                    prclClip->left,   prclClip->top,
                    prclClip->right,  prclClip->bottom,
                    prclClip->right -  prclClip->left,
                    prclClip->bottom -  prclClip->top));


            SetClipWindow( pPDev, prclClip);
        }

        //
        // Now setup to enumerate the PATHOBJ and output the points.
        //

        PATHOBJ_vEnumStart(pPathObj);

        PenIsDown     = FALSE;
        PolyMode      = 0;
        bFirstSubPath = TRUE;

        do {

            //
            // Check to see if the print job has been cancelled.
            //

            if (PLOT_CANCEL_JOB(pPDev)) {

                bRet = FALSE;
                break;
            }

            bMore = PATHOBJ_bEnum(pPathObj, &pd);
            cptfx = pd.count;
            pptfx = pd.pptfx;

            //
            // Check the BEGINSUBPATH or if this is our first time here.
            //

            if ((pd.flags & PD_BEGINSUBPATH) || (bFirstSubPath)) {

                PLOTDBG(DBG_GENPOLYGON, ("DoPolygon: Getting PD_BEGINSUBPATH"));

                TERM_PE_MODE(pPDev, PolyMode);

                ptStart.x = pptfx->x + ptOffsetFix.x;
                ptStart.y = pptfx->y + ptOffsetFix.y;

                MovePen(pPDev, &ptStart, &ptlCur);
                PenIsDown = FALSE;

                pptfx++;
                cptfx--;

                if ((!bStrokeOnTheFly) && (bFirstSubPath)) {

                    SEND_PM0(pPDev);
                }

                bFirstSubPath = FALSE;
            }

            //
            // Now check if we are sending out Beziers.
            //

            if (pd.flags & PD_BEZIERS) {

                PLOTASSERT(1, "DoPolygon: PD_BEZIERS (count % 3) != 0 (%ld)",
                                                      (cptfx % 3) == 0, cptfx);

                SWITCH_TO_BR(pPDev, PolyMode, PenIsDown);

                NumType      = 'f';
                cCurPosSkips = 3;

            } else {

                SWITCH_TO_PE(pPDev, PolyMode, PenIsDown);

                NumType      = 'F';
                cCurPosSkips = 1;
            }

            PLOTDBG(DBG_GENPOLYGON, ("DoPolygon: OutputXYParam(%ld pts=%hs)",
                    cptfx, (pd.flags & PD_BEZIERS) ? "BEZIER" : "POLYGON"));

            OutputXYParams(pPDev,
                           (PPOINTL)pptfx,
                           (PPOINTL)&ptOffsetFix,
                           (PPOINTL)&ptlCur,
                           (UINT)cptfx,
                           (UINT)cCurPosSkips,
                           NumType);

            //
            // Check to see if we are ending the sub path.
            //

            if (pd.flags & PD_ENDSUBPATH) {

                PLOTDBG(DBG_GENPOLYGON,
                       ("DoPolygon: Getting PD_ENDSUBPATH   %hs",
                       (pd.flags & PD_CLOSEFIGURE) ? "PD_CLOSEFIGURE" : ""));

                //
                // If we are not closing the figure then move the pen to the
                // starting position so we do not have the plotter automatically
                // close the sub-path.
                //

                if (pd.flags & PD_CLOSEFIGURE) {

                    PLOTDBG(DBG_GENPOLYGON,
                            ("DoPolygon: OutputXYParam(1) to ptStart=(%ld, %ld)",
                                                ptStart.x, ptStart.y));

                    //
                    // We must not pass the ptOffsetFix, because we already
                    // added it into the ptStart at BEGSUBPATH.
                    //

                    SWITCH_TO_PE(pPDev, PolyMode, PenIsDown);

                    OutputXYParams(pPDev,
                                   (PPOINTL)&ptStart,
                                   (PPOINTL)NULL,
                                   (PPOINTL)&ptlCur,
                                   (UINT)1,
                                   (UINT)1,
                                   'F');
                }

                TERM_PE_MODE(pPDev, PolyMode);

                if (!(pd.flags & PD_CLOSEFIGURE)) {

                    MovePen(pPDev, &ptStart, &ptlCur);
                    PenIsDown = FALSE;
                }

                //
                // If we are not stroking on the fly, close the subpath.
                //

                if (!bStrokeOnTheFly) {

                    SEND_PM1(pPDev);
                }

            }

        } while (bMore);

        TERM_PE_MODE(pPDev, PolyMode);

        //
        // Now end polygon mode.
        //

        if ((bRet)                  &&
            (!bStrokeOnTheFly)      &&
            (!PLOT_CANCEL_JOB(pPDev))) {

            SEND_PM2(pPDev);
            SETLINETYPESOLID(pPDev);

            //
            // Now fill and/or stroke the current polygon.
            //

            DoFillLogic(pPDev,
                        pPointlBrushOrg,
                        pBrushFill,
                        pBrushStroke,
                        rop4,
                        plineattrs,
                        NULL,
                        ulFlags);
        }

        //
        // If we set a clip window, clear it.
        //

        if (prclClip) {

            ClearClipWindow(pPDev);
        }

    } else {

        PLOTDBG(DBG_GENPOLYGON, ("DoPolygon: PATHOBJ_bEnum=NO POINT"));
    }

    //
    // If the path was constructed from a complex clip object we need to
    // delete that path now.
    //

    if (bPathCameFromClip) {

       EngDeletePath(pPathObj);
    }

    return(bRet);
}





VOID
HandleLineAttributes(
    PPDEV       pPDev,
    LINEATTRS   *plineattrs,
    PLONG       pStyleToUse,
    LONG        lExtraStyle
    )

/*++

Routine Description:

    This function does any setup necessary to correctly handle stroking of
    a path. It does this by looking at the LINEATTRS structure passed in
    and setting up the HPGL2 plotter with the appropriate style info using
    HPGL2 styled line commands.

Arguments:

    pPDev           - Pointer to our PDEV

    plineattrs      - LINEATTRS for style lines stroke

    pStyleToUse     - The starting style offset to use, if this is NULL then
                      we use the starting member in plineatts.

    lExtraStyle     - Any extra style to use based on the current run

Return Value:

    VOID

Author:

    01-Feb-1994 created  -by-  James Bratsanos (v-jimbr)

Revision History:


--*/
{
    LONG        lTotLen = 0L;
    INT         i;
    LONG        lScaleVal;
    INT         iCount;
    PFLOAT_LONG pStartStyle;
    FLOAT_LONG  aAlternate[2];
    BOOL        bSolid = TRUE;
    LONG        lStyleState;
    PLONG       pArrayToUse;


    PLOTDBG( DBG_HANDLELINEATTR,
             ("HandleLineAttr: plineattrs = %hs",
             (plineattrs) ? "Exists" : "NULL" ));

    if (plineattrs) {

        PLOTASSERT(1,
                  "HandleLineAttrs: Getting a LA_GEOMETRIC and cannot handle %u",
                  (!(plineattrs->fl & LA_GEOMETRIC)),
                  plineattrs->fl);

        //
        // Set up the correct lStyleState to use, the passed one has precedence
        // over the one imbedded in the lineattributes structure.
        //

        if (pStyleToUse) {

            lStyleState = *pStyleToUse;

        } else {

            lStyleState = plineattrs->elStyleState.l;
        }

        if (plineattrs->fl & LA_ALTERNATE) {

            PLOTDBG( DBG_HANDLELINEATTR,
                    ("HandleLineAttr: plineattrs has LA_ALTERNATE bit set!"));
            //
            // This is a special case where every other pixel is on...
            //

            pStartStyle     = &aAlternate[0];
            iCount          = sizeof(aAlternate) / sizeof(aAlternate[0]);

            aAlternate[0].l = 1;
            aAlternate[1].l = 1;

        } else if ((plineattrs->cstyle != 0) &&
                   (plineattrs->pstyle != (PFLOAT_LONG)NULL)) {

           //
           // There is a user defined style passed in so set up for it
           //

            iCount      = plineattrs->cstyle;
            pStartStyle = plineattrs->pstyle;

            PLOTDBG(DBG_HANDLELINEATTR, ("HandleLineAttr: Count = %ld",
                                            plineattrs->cstyle));

        } else {

           //
           // This is a SOLID line, so simply set the number of points to 0
           //

           iCount = 0;
        }

        if (iCount) {

            PFLOAT_LONG pCurStyle;
            INT         idx;
            LONG        lTempValue;
            LONG        lValueToEnd;
            BOOL        bInDash;
            LONG        convArray[MAX_USER_POINTS];
            PLONG       pConverted;
            LONG        newArray[MAX_USER_POINTS+2];
            PLONG       pNewArray;


            PLOTASSERT(0,
                       "HandleLineAttributes: Getting more than 18 points (%ld)",
                       (iCount <= MAX_STYLE_ENTRIES) ,
                       iCount);

            //
            // Record our current DASH state, the line either starts with
            // a gap or a dash.
            //

            if (plineattrs->fl & LA_STARTGAP) {

                bInDash = FALSE;

            } else {

                bInDash = TRUE;
            }

            //
            // Since we know we can't handle more than 20 points sent to HPGL2
            // we limit it now to 18 in order to compensate for the up-to 2
            // additional points we may add later.
            //

            iCount = min(MAX_STYLE_ENTRIES, iCount);


            //
            // Get our scaling value, so we can convert style units to
            // our units.
            //

            lScaleVal = PLOT_STYLE_STEP(pPDev);


            //
            // Now convert to the new units, and store the result in the
            // new array. Also keep track of the total length of the style
            //

            for (i = 0, pConverted = &convArray[0], lTotLen = 0,
                                                pCurStyle = pStartStyle;
                 i < iCount ;
                 i++, pCurStyle++, pConverted++) {

                *pConverted = pCurStyle->l * lScaleVal;

                PLOTDBG( DBG_HANDLELINEATTR,
                         ("HandleLineAttr: Orig Array [%ld]= %ld becomes %ld",
                          i, pCurStyle->l, *pConverted ));

                lTotLen += *pConverted;
            }


            //
            // Now convert the passed style state and extra info into the
            // real final style state to use, we do this by taking the value of
            // interest which is packed into the HIWORD and LOWORD of
            // lstylestate based on the DDK definition, then we must add on
            // any additional distance (which may have come from enuming
            // a CLIPLINE structure).
            //

            lStyleState = (HIWORD(lStyleState) * PLOT_STYLE_STEP(pPDev) +
                           LOWORD(lStyleState) + lExtraStyle) % lTotLen ;

            PLOTDBG(DBG_HANDLELINEATTR,
                    ("HandleLineAttributes: Computed Style state = %ld, extra = %ld",
                    lStyleState, lExtraStyle));

            //
            // Set up our final pointer to the new array, since we may be done
            // based on the final computed stylestate being 0.
            //

            pNewArray = &newArray[0];


            if (lStyleState != 0) {

                lTempValue = 0;

                //
                // Since lStyleState has a value other than zero we must
                // construct a new style array to pass to HPGL2 that has been
                // rotated in order to take into account the style state.
                // the code below constructs the new array.
                //

                for (i=0, pConverted = &convArray[0];
                     i < iCount ;
                     i++, pConverted++) {

                    //
                    // At this point were looking for the entry which partially
                    // encompasses the style state derived. Based on this
                    // we can create a new array that is a transformation of the
                    // original array rotated the correct amount.
                    //

                    if (lStyleState  < lTempValue + *pConverted) {

                        //
                        // Here is the transition point.
                        //

                        *pNewArray++ = *pConverted - (lStyleState - lTempValue);

                        //
                        // Record the value that needs to be appended to the end
                        // of the array
                        //

                        lValueToEnd = lStyleState - lTempValue;


                        idx = i;

                        idx++;
                        pConverted++;

                        //
                        // Fill up the end
                        //

                        while (idx++ < iCount) {

                            *pNewArray++ = *pConverted++;
                        }

                        //
                        // Now fill up the beginning...
                        //

                        idx        = 0;
                        pConverted = &convArray[0];

                        //
                        // If there was an odd number we can add together
                        // the starting and ending one since they have the
                        // same state
                        //

                        if ((iCount % 2) == 1 ) {

                            pNewArray--;
                            *pNewArray += *pConverted++;

                            idx++;
                            pNewArray++;
                        }

                        while (idx++ < i) {

                            *pNewArray++ = *pConverted++;
                        }

                        *pNewArray++ = lValueToEnd;

                        break;
                    }

                    lTempValue += *pConverted;

                    bInDash = TOGGLE_DASH(bInDash);
                }

                pArrayToUse = &newArray[0];
                iCount = (INT)(pNewArray - &newArray[0]);

            } else {

                pArrayToUse = &convArray[0];
            }

            PLOTASSERT(0,
                       "HandleLineAttributes: Getting more than 20 points (%ld)",
                       (iCount <= MAX_USER_POINTS) ,
                       iCount);
            //
            // There is a style pattern so set up for it.
            //

            bSolid = FALSE;


            //
            // Begin the HPGL2 line command to define a custom style type
            //

            OutputString(pPDev, "UL1");

            //
            // If this flag is set, the first segment is a gap NOT a dash so
            // we trick HPGL2 into doing the right thing by having a zero
            // length dash in the begining.
            //

            if (!bInDash) {

               OutputString(pPDev, ",0");
            }

            //
            // Since we output the 0 len dash at the begining if the line
            // starts with a gap, the most additional points we send out
            // is decremented by 1.
            //

            iCount = min((bInDash ? MAX_USER_POINTS : MAX_USER_POINTS - 1) ,
                         iCount);

            //
            // Enum through the points in the style array, converting to our
            // Graphics units and send them to the plotter.
            //

            for (i = 0; i < iCount; i++, pArrayToUse++) {

                PLOTDBG(DBG_HANDLELINEATTR,
                         ("HandleLineAttr: New Array [%ld]= %ld",
                          i, *pArrayToUse));

                OutputFormatStr(pPDev, ",#l", *pArrayToUse);
            }

            //
            // Now output the linetype and specify the total lenght of the
            // pattern.
            //

            OutputFormatStr(pPDev, "LT1,#d,1",
                                ((lTotLen * 254) / pPDev->lCurResolution ) / 10 );

            //
            // Update our linetype in the pdev since we ALWAYS send out this
            // line type
            //

            pPDev->LastLineType = PLOT_LT_USERDEFINED;
        }
    }

    //
    // If it was SOLID just send out the SOLID (default command)
    //

    if (bSolid) {

        PLOTDBG(DBG_HANDLELINEATTR, ("HandleLineAttr: Line type is SOLID"));

        //
        // Send out the correct commands to the plotter
        //

        SETLINETYPESOLID(pPDev);
    }
}





VOID
DoFillLogic(
    PPDEV       pPDev,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushFill,
    BRUSHOBJ    *pBrushStroke,
    ROP4        Rop4,
    LINEATTRS   *plineattrs,
    SIZEL       *pszlRect,
    ULONG       ulFlags
    )

/*++

Routine Description:

    This routine has the core logic for filling and already established
    polygon, or a passed in segment.

Arguments:

    pPDev           - Pointer to our PDEV

    pptlBrushOrg    - Pointer to the brush origin to be set

    pBrushFill      - Brush used to fill the rectangle

    pBrushStroke    - Brush used to stroke the rectangle

    Rop4            - rop to be used

    plineattrs      - Pointer to the line attributes for a styled line

    pszlRect        - Pointer to a segment to stroke.

    ulFlags         - FPOLY_XXX, stroking and or filling flags.


Return Value:

    VOID

Author:

    30-Nov-1993 created  -by-  James Bratsanos (v-jimbr)

    15-Jan-1994 Sat 05:02:42 updated  -by-  DC
        Change GetColor() and tabify

    18-Jan-1994 Sat 05:02:42 updated  -by-  James Bratsanos (v-jimbr)

    16-Feb-1994 Wed 09:34:06 updated  -by-  DC
        Update for the rectangle polygon case to use RR/ER commands

Revision History:


--*/
{
    INTDECIW    PenWidth;


    if (PLOT_CANCEL_JOB(pPDev)) {

        return;
    }

    //
    // Since a polygon must already be defined this code simply
    // looks at the passed data and sends out the appropriate codes to
    // fill/stroke this polygon correctly.
    //

    PenWidth.Integer =
    PenWidth.Decimal = 0;


    if (ulFlags & FPOLY_FILL) {

        DEVBRUSH    *pDevFill;
        DWORD       FillForeColor;
        LONG        HSType;
        LONG        HSParam;
        BOOL        bSetTransparent = FALSE;


        //
        // If we are filling, get the current color taking the ROP into
        // acount.
        //

        if (!GetColor(pPDev, pBrushFill, &FillForeColor, &pDevFill, Rop4)) {

            PLOTERR(("DoFillLogic: GetColor()=FALSE"));
            return;
        }

        HSType  = -1;
        HSParam = (LONG)((pDevFill) ? pDevFill->LineSpacing : 0);

        //
        // If the plotter cannot support tranparent mode there is no need
        // to wory about backgrounds. we will only ever care about foreground.
        //

        if (((IS_TRANSPARENT(pPDev)) || (!IS_RASTER(pPDev))) &&
            (pDevFill)) {

            //
            // Determine if we are using a Pre-defined pattern to fill with.
            //

            switch(pDevFill->PatIndex) {

            case HS_HORIZONTAL:
            case HS_VERTICAL:
            case HS_BDIAGONAL:
            case HS_FDIAGONAL:
            case HS_CROSS:
            case HS_DIAGCROSS:

                PenWidth.Integer = PW_HATCH_INT;
                PenWidth.Decimal = PW_HATCH_DECI;
                bSetTransparent  = (BOOL)IS_TRANSPARENT(pPDev);

                if ((Rop4 & 0xFF00) != 0xAA00) {

                    if (IS_RASTER(pPDev)) {

                       //
                       // Send out the Background Rop.
                       //

                       SetRopMode(pPDev, ROP4_BG_ROP(Rop4));

                       PLOTDBG(DBG_FILL_LOGIC,
                               ("DoFillLogic: BCK = MC=%02lx", ROP4_BG_ROP(Rop4)));
                    }

                    //
                    // We need to select the background color fill then
                    // select the foreground color back... ONLY if it is
                    // non white.
                    //

                    if ((IS_RASTER(pPDev)) ||
                        (!PLOT_IS_WHITE(pPDev, pDevFill->ColorBG))) {

                        HSType = HS_DDI_MAX;
                    }
                }

                break;

            default:

                //
                // If we are a pen plotter and have a user defined pattern.
                // Do a horizontal hatch for background color and a vertical
                // hatch for the foreground color.
                //

                if ((!IS_RASTER(pPDev)) &&
                    (pDevFill->PatIndex >= HS_DDI_MAX)) {

                    PLOTWARN(("DoFillLogic: PEN+USER PAT, Do HS_FDIAGONAL for BG [%ld]",
                                    pDevFill->ColorBG));

                    HSParam <<= 1;

                    if (!PLOT_IS_WHITE(pPDev, pDevFill->ColorBG)) {

                        HSType = HS_FDIAGONAL;

                    } else {

                        PLOTWARN(("DoFillLogic: PEN+USER PAT, Skip WHITE COLOR"));
                    }
                }

                break;
            }
        }


        //
        // Check for a valid pre-defined hatch type and send out the commands.
        //

        if (HSType != -1) {

            PLOTDBG(DBG_FILL_LOGIC, ("DoFillLogic: Fill BGColor = %08lx", pDevFill->ColorBG));

            SelectColor(pPDev, pDevFill->ColorBG, PenWidth);

            SetHSFillType(pPDev, (DWORD)HSType, HSParam);

            SetBrushOrigin(pPDev, pPointlBrushOrg);

            if (pszlRect) {

                SEND_RR(pPDev);
                OutputLONGParams(pPDev, (PLONG)pszlRect, 2, 'd');
                pszlRect = NULL;

            } else {

                SEND_FP(pPDev);

                //
                // Fill with the correct winding mode.
                //

                if (ulFlags & FPOLY_WINDING) {

                    SEND_1SEMI(pPDev);
                }
            }
        }

        //
        // Send out the foreground ROP.
        //

        if (IS_RASTER(pPDev)) {

            SetRopMode(pPDev, ROP4_FG_ROP(Rop4));
        }

        //
        // Now select the foreground color.
        //

        SelectColor(pPDev, FillForeColor, PenWidth);

        if (bSetTransparent) {

            PLOTDBG(DBG_FILL_LOGIC, ("DoFillLogic: TRANSPARENT MODE"));

            //
            // Set up for transparent.
            //

            SEND_TR1(pPDev);
        }

        if (pDevFill) {

            //
            // If the pattern to fill with is user defined, the convert it
            // to a user defined pattern in HPGL2. A user defined pattern
            // is where the client code passed a bitmap in to GDI that
            // it expects to fill with (with tileing). If its a pen plotter,
            // this won't work, so simulate it with a diagonal fill.
            //

            if (pDevFill->PatIndex >= HS_DDI_MAX) {

                if (IS_RASTER(pPDev)) {

                    DownloadUserDefinedPattern(pPDev, pDevFill);

                } else {

                    PLOTWARN(("DoFillLogic: PEN+USER PAT, Do HS_BDIAGONAL for FG [%ld]",
                                    FillForeColor));

                    SetHSFillType(pPDev, HS_BDIAGONAL, HSParam);
                }

            } else {

                //
                // The pattern is a predefined one, so convert it to an HPGL2
                // pattern type.
                //

                SetHSFillType(pPDev, pDevFill->PatIndex, pDevFill->LineSpacing);
            }

            //
            // Set the brush origin.
            //

            SetBrushOrigin(pPDev, pPointlBrushOrg);

        } else {

            SetHSFillType(pPDev, HS_DDI_MAX, 0);
        }

        //
        // If we were passed a segment, paint it now.
        //

        if (pszlRect) {

            SEND_RR(pPDev);
            OutputLONGParams(pPDev, (PLONG)pszlRect, 2, 'd');
            pszlRect = NULL;

        } else {

            //
            // Execute the command to paint the existing path using the current
            // parameters.
            //

            SEND_FP(pPDev);

            if (ulFlags & FPOLY_WINDING) {

                SEND_1SEMI(pPDev);
            }
        }

        //
        // If we used tranparent mode put it back
        //

        if (bSetTransparent) {

            SEND_TR0(pPDev);
        }
    }

    if (ulFlags & FPOLY_STROKE) {

        DoSetupOfStrokeAttributes(pPDev,
                                  pPointlBrushOrg,
                                  pBrushStroke,
                                  Rop4,
                                  plineattrs);

        //
        // give the plotter the command to stroke the polygon outline!
        //

        if (pszlRect) {

            SEND_ER(pPDev);
            OutputLONGParams(pPDev, (PLONG)pszlRect, 2, 'd');

        } else {

            SEND_EP(pPDev);
        }
    }
}





VOID
DoSetupOfStrokeAttributes(
    PPDEV       pPDev,
    POINTL      *pPointlBrushOrg,
    BRUSHOBJ    *pBrushStroke,
    ROP4        Rop4,
    LINEATTRS   *plineattrs
    )

/*++

Routine Description:

    This routine sets up the plotter in order to correctly handle stroking,
    based on the passed brush and lineattributes structures.

Arguments:

    pPDev                Pointer to our current PDEV with state info about
                         driver

    pPointlBrushOrg      Brush origin

    pBrushStroke         BRUSHOBJ to stroke with (should only be solid color)

    Rop4                 The rop to use when stroking

    plineattrs           LINEATTRS structure with the specified line styles


Return Value:

    VOID

Author:

    01-Feb-1994 Tue 05:02:42 created  -by-  James Bratsanos (v-jimbr)

Revision History:


--*/
{
    INTDECIW    PenWidth;
    DWORD       StrokeColor;


    GetColor(pPDev, pBrushStroke, &StrokeColor, NULL, Rop4);

    PenWidth.Integer =
    PenWidth.Decimal = 0;

    SelectColor(pPDev, StrokeColor, PenWidth);

    //
    // Send out the foreground Rop, if we are RASTER
    //

    if (IS_RASTER(pPDev)) {

        SetRopMode(pPDev, ROP4_FG_ROP(Rop4));
    }

    //
    // Handle the line attributes
    //

    HandleLineAttributes(pPDev, plineattrs, NULL, 0);
}




LONG
DownloadUserDefinedPattern(
    PPDEV       pPDev,
    PDEVBRUSH   pBrush
    )

/*++

Routine Description:

    This function defines a user pattern to the HPGL2 device. This is used
    when a client application passes a bitmap to GDI to use for filling
    polygons.

Arguments:

    pPDev   - Pointer to the PDEV

    pBrush  - Pointer to the cached device brush


Return Value:

    INT to indicate a pattern number downloaed/defined

Author:

    09-Feb-1994 Wed 13:11:01 updated  -by-  DC
        Remove 4bpp/1bpp, it always must have pbgr24

    08-Feb-1994 Tue 01:49:53 updated  -by-  DC
        make PalEntry.B = *pbgr++ as first color, since the order we have
        is PALENTRY and first color is B in the structure.

    27-Jan-1994 Thu 21:20:30 updated  -by-  DC
        Add the RF cache codes

    14-Jan-1994 Fri 15:23:40 updated  -by-  DC
        Added assert for compatible device pattern
        Added so it will take device compatible pattern (8x8,16x16,32x32,64x64)

    13-Jan-1994 Thu 19:04:04 created  -by-  DC
        Re-write

    16-Feb-1994 Wed 11:00:19 updated  -by-  DC
        Change return value to return the HSFillType, and fixed the bugs which
        if we found the cached but we do not set the fill type again

    05-Aug-1994 Fri 18:35:45 updated  -by-  DC
        Bug# 22381, we do FindCachedPen() for during the pattern downloading
        and this causing the problem if the pen is not in the cache then we
        will send the PEN DEFINITION at middle of pattern downloading.  If this
        happened then downloading sequence is broken.  We fixes this by

            1) Cache the pen indices if we have enough memory
            2) Run through FindCachePen() for all the RGB colors in the pattern
            3) Download cached pen indices if we have memory OR run through
               FindCachedPen() again to download the pen indices

        This may still have problem if we have

            1) No pen indices caching memory
            2) more color in the pattern then the max pens in the device

        BUT if this happens then we have no choice but to have the wrong output.


Revision History:


--*/

{
    LONG    HSFillType;
    LONG    RFIndex;


    //
    // Firs we must find the RFIndex
    //
    //

    HSFillType = HS_FT_USER_DEFINED;

    if ((RFIndex = FindDBCache(pPDev, pBrush->Uniq)) < 0) {

        LPBYTE  pbgr24;


        RFIndex = -RFIndex;

        //
        // We must download new pattern to the plotter now, make it positive
        //

        if (pbgr24 = pBrush->pbgr24) {

            PALENTRY    PalEntry;
            LPWORD      pwIdx;
            UINT        Idx;
            UINT        Size;


            Size = (UINT)pBrush->cxbgr24 * (UINT)pBrush->cybgr24;

            PLOTDBG(DBG_USERPAT,
                    ("PlotGenUserDefinedPattern: DOWNLOAD %ld x %ld=%ld USER PAT #%ld",
                    (LONG)pBrush->cxbgr24, (LONG)pBrush->cybgr24, Size, RFIndex));

            if (!(pwIdx = (LPWORD)LocalAlloc(LPTR, Size * sizeof(WORD)))) {

                //
                // Do not have memory to do it, so forget it
                //

                PLOTWARN(("Download User defined pattern NO Memory so REAL TIME RUN"));
            }

            //
            // We must first get all the pens cached so we have the indices to
            // use, otherwise we will download the pen color when the pen color
            // is defined.
            //

            PalEntry.Flags = 0;

            for (Idx = 0; Idx < Size; Idx++) {

                WORD    PenIdx;


                PalEntry.B = *pbgr24++;
                PalEntry.G = *pbgr24++;
                PalEntry.R = *pbgr24++;

                PenIdx = (WORD)FindCachedPen(pPDev, &PalEntry);

                if (pwIdx) {

                    pwIdx[Idx] = PenIdx;
                }
            }

            //
            // Now output the download header/size first
            //

            OutputFormatStr(pPDev, "RF#d,#d,#d", RFIndex,
                            (LONG)pBrush->cxbgr24, (LONG)pBrush->cybgr24);

            //
            // If we cached the indices, then use them. Otherwise, find the
            // cache again.
            //

            if (pwIdx) {

                for (Idx = 0; Idx < Size; Idx++) {

                    OutputFormatStr(pPDev, ",#d", pwIdx[Idx]);
                }

                //
                // Free the indices memory if we have one.
                //

                LocalFree((HLOCAL)pwIdx);

            } else {

                //
                // We do not have cached indices, so run through again.
                //

                pbgr24 = pBrush->pbgr24;

                for (Idx = 0; Idx < Size; Idx++) {

                    PalEntry.B = *pbgr24++;
                    PalEntry.G = *pbgr24++;
                    PalEntry.R = *pbgr24++;

                    OutputFormatStr(pPDev, ",#d", FindCachedPen(pPDev, &PalEntry));
                }
            }

            SEND_SEMI(pPDev);

        } else {

            PLOTERR(("PlotGenUserDefinedPattern: NO pbgr24??, set SOLID"));

            HSFillType = HS_DDI_MAX;
            RFIndex    = 0;
        }

    } else {

        PLOTDBG(DBG_USERPAT,
                ("PlotGenUserDefinedPattern: We have CACHED RFIndex=%ld",
                RFIndex));
    }

    SetHSFillType(pPDev, (DWORD)HSFillType, RFIndex);

    return(RFIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\textout.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    textout.h


Abstract:

    This module contains all #defines and prototypes for the textout.c module.


Author:

    18-Nov-1993 Thu 05:18:40 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTTEXTOUT_
#define _PLOTTEXTOUT_







#endif  // _PLOTTEXTOUT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\ropblt.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    ropblt.h


Abstract:

    This module contains all raster operation codes, #defines and structures.


Author:

    07-Jan-1994 Fri 13:05:10 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _ROPBLT_
#define _ROPBLT_
//
// This table defines the Raster Operations. They are listed in RPN and
//
//    D = Destination surface
//    S = Source surface
//    P = Pattern
//    o = OR operator
//    a = AND operator
//    n = NOT operator
//    x = XOR operator
//
//*****************************************************************************
//  R A S T E R    O P E R A T I O N S
//*****************************************************************************
//
//
//    Dec Hex   Logical Operations          RPN notation    Common name
//  -----------------------------------------------------------------------
//      0-0x00  0                           0
//      1-0x01  ~(D | (P | S))              DPSoon
//      2-0x02  D & ~(P | S)                DPSona
//      3-0x03  ~(P | S)                    PSon
//      4-0x04  S & ~(D | P)                SDPona
//      5-0x05  ~(D | P)                    DPon
//      6-0x06  ~(P | ~(D ^ S))             PDSxnon
//      7-0x07  ~(P | (D & S))              PDSaon
//      8-0x08  S & (D & ~P)                SDPnaa
//      9-0x09  ~(P | (D ^ S))              PDSxon
//     10-0x0a  D & ~P                      DPna
//     11-0x0b  ~(P | (S & ~D))             PSDnaon
//     12-0x0c  S & ~P                      SPna
//     13-0x0d  ~(P | (D & ~S))             PDSnaon
//     14-0x0e  ~(P | ~(D | S))             PDSonon
//     15-0x0f  ~P                          Pn
//     16-0x10  P & ~(D | S)                PDSona
//     17-0x11  ~(D | S)                    DSon            NOTSRCERASE
//     18-0x12  ~(S | ~(D ^ P))             SDPxnon
//     19-0x13  ~(S | (D & P))              SDPaon
//     20-0x14  ~(D | ~(P ^ S))             DPSxnon
//     21-0x15  ~(D | (P & S))              DPSaon
//     22-0x16  P ^ (S ^ (D & ~(P & S)))    PSDPSanaxx
//     23-0x17  ~(S ^ ((S ^ P) & (D ^ S)))  SSPxDSxaxn
//     24-0x18  (S ^ P) & (P ^ D)           SPxPDxa
//     25-0x19  ~(S ^ (D & ~(P & S)))       SDPSanaxn
//     26-0x1a  P ^ (D | (S & P))           PDSPaox
//     27-0x1b  ~(S ^ (D & (P ^ S)))        SDPSxaxn
//     28-0x1c  P ^ (S | (D & P))           PSDPaox
//     29-0x1d  ~(D ^ (S & (P ^ D)))        DSPDxaxn
//     30-0x1e  P ^ (D | S)                 PDSox
//     31-0x1f  ~(P & (D | S))              PDSoan
//     32-0x20  D & (P & ~S)                DPSnaa
//     33-0x21  ~(S | (D ^ P))              SDPxon
//     34-0x22  D & ~S                      DSna
//     35-0x23  ~(S | (P & ~D))             SPDnaon
//     36-0x24  (S ^ P) & (D ^ S)           SPxDSxa
//     37-0x25  ~(P ^ (D & ~(S & P)))       PDSPanaxn
//     38-0x26  S ^ (D | (P & S))           SDPSaox
//     39-0x27  S ^ (D | ~(P ^ S))          SDPSxnox
//     40-0x28  D & (P ^ S)                 DPSxa
//     41-0x29  ~(P ^ (S ^ (D | (P & S))))  PSDPSaoxxn
//     42-0x2a  D & ~(P & S)                DPSana
//     43-0x2b  ~(S ^ ((S ^ P) & (P ^ D)))  SSPxPDxaxn
//     44-0x2c  S ^ (P & (D | S))           SPDSoax
//     45-0x2d  P ^ (S | ~D)                PSDnox
//     46-0x2e  P ^ (S | (D ^ P))           PSDPxox
//     47-0x2f  ~(P & (S | ~D))             PSDnoan
//     48-0x30  P & ~S                      PSna
//     49-0x31  ~(S | (D & ~P))             SDPnaon
//     50-0x32  S ^ (D | (P | S))           SDPSoox
//     51-0x33  ~S                          Sn              NOTSRCCOPY
//     52-0x34  S ^ (P | (D & S))           SPDSaox
//     53-0x35  S ^ (P | ~(D ^ S))          SPDSxnox
//     54-0x36  S ^ (D | P)                 SDPox
//     55-0x37  ~(S & (D | P))              SDPoan
//     56-0x38  P ^ (S & (D | P))           PSDPoax
//     57-0x39  S ^ (P | ~D)                SPDnox
//     58-0x3a  S ^ (P | (D ^ S))           SPDSxox
//     59-0x3b  ~(S & (P | ~D))             SPDnoan
//     60-0x3c  P ^ S                       PSx
//     61-0x3d  S ^ (P | ~(D | S))          SPDSonox
//     62-0x3e  S ^ (P | (D & ~S))          SPDSnaox
//     63-0x3f  ~(P & S)                    PSan
//     64-0x40  P & (S & ~D)                PSDnaa
//     65-0x41  ~(D | (P ^ S))              DPSxon
//     66-0x42  (S ^ D) & (P ^ D)           SDxPDxa
//     67-0x43  ~(S ^ (P & ~(D & S)))       SPDSanaxn
//     68-0x44  S & ~D                      SDna            SRCERASE
//     69-0x45  ~(D | (P & ~S))             DPSnaon
//     70-0x46  D ^ (S | (P & D))           DSPDaox
//     71-0x47  ~(P ^ (S & (D ^ P)))        PSDPxaxn
//     72-0x48  S & (D ^ P)                 SDPxa
//     73-0x49  ~(P ^ (D ^ (S | (P & D))))  PDSPDaoxxn
//     74-0x4a  D ^ (P & (S | D))           DPSDoax
//     75-0x4b  P ^ (D | ~S)                PDSnox
//     76-0x4c  S & ~(D & P)                SDPana
//     77-0x4d  ~(S ^ ((S ^ P) | (D ^ S)))  SSPxDSxoxn
//     78-0x4e  P ^ (D | (S ^ P))           PDSPxox
//     79-0x4f  ~(P & (D | ~S))             PDSnoan
//     80-0x50  P & ~D                      PDna
//     81-0x51  ~(D | (S & ~P))             DSPnaon
//     82-0x52  D ^ (P | (S & D))           DPSDaox
//     83-0x53  ~(S ^ (P & (D ^ S)))        SPDSxaxn
//     84-0x54  ~(D | ~(P | S))             DPSonon
//     85-0x55  ~D                          Dn              DSTINVERT
//     86-0x56  D ^ (P | S)                 DPSox
//     87-0x57  ~(D & (P | S))              DPSoan
//     88-0x58  P ^ (D & (S | P))           PDSPoax
//     89-0x59  D ^ (P | ~S)                DPSnox
//     90-0x5a  D ^ P                       DPx             PATINVERT
//     91-0x5b  D ^ (P | ~(S | D))          DPSDonox
//     92-0x5c  D ^ (P | (S ^ D))           DPSDxox
//     93-0x5d  ~(D & (P | ~S))             DPSnoan
//     94-0x5e  D ^ (P | (S & ~D))          DPSDnaox
//     95-0x5f  ~(D & P)                    DPan
//     96-0x60  P & (D ^ S)                 PDSxa
//     97-0x61  ~(D ^ (S ^ (P | (D & S))))  DSPDSaoxxn
//     98-0x62  D ^ (S & (P | D))           DSPDoax
//     99-0x63  S ^ (D | ~P)                SDPnox
//    100-0x64  S ^ (D & (P | S))           SDPSoax
//    101-0x65  D ^ (S | ~P)                DSPnox
//    102-0x66  D ^ S                       DSx             SRCINVERT
//    103-0x67  S ^ (D | ~(P | S))          SDPSonox
//    104-0x68  ~(D ^ (S ^ (P | ~(D | S)))) DSPDSonoxxn
//    105-0x69  ~(P ^ (D ^ S))              PDSxxn
//    106-0x6a  D ^ (P & S)                 DPSax
//    107-0x6b  ~(P ^ (S ^ (D & (P | S))))  PSDPSoaxxn
//    108-0x6c  S ^ (D & P)                 SDPax
//    109-0x6d  ~(P ^ (D ^ (S & (P | D))))  PDSPDoaxxn
//    110-0x6e  S ^ (D & (P | ~S))          SDPSnoax
//    111-0x6f  ~(P & ~(D ^ S))             PDSxnan
//    112-0x70  P & ~(D & S)                PDSana
//    113-0x71  ~(S ^ ((S ^ D) & (P ^ D)))  SSDxPDxaxn
//    114-0x72  S ^ (D | (P ^ S))           SDPSxox
//    115-0x73  ~(S & (D | ~P))             SDPnoan
//    116-0x74  D ^ (S | (P ^ D))           DSPDxox
//    117-0x75  ~(D & (S | ~P))             DSPnoan
//    118-0x76  S ^ (D | (P & ~S))          SDPSnaox
//    119-0x77  ~(D & S)                    DSan
//    120-0x78  P ^ (D & S)                 PDSax
//    121-0x79  ~(D ^ (S ^ (P & (D | S))))  DSPDSoaxxn
//    122-0x7a  D ^ (P & (S | ~D))          DPSDnoax
//    123-0x7b  ~(S & ~(D ^ P))             SDPxnan
//    124-0x7c  S ^ (P & (D | ~S))          SPDSnoax
//    125-0x7d  ~(D & ~(P ^ S))             DPSxnan
//    126-0x7e  (S ^ P) | (D ^ S)           SPxDSxo
//    127-0x7f  ~(D & (P & S))              DPSaan
//    128-0x80  D & (P & S)                 DPSaa
//    129-0x81  ~((S ^ P) | (D ^ S))        SPxDSxon
//    130-0x82  D & ~(P ^ S)                DPSxna
//    131-0x83  ~(S ^ (P & (D | ~S)))       SPDSnoaxn
//    132-0x84  S & ~(D ^ P)                SDPxna
//    133-0x85  ~(P ^ (D & (S | ~P)))       PDSPnoaxn
//    134-0x86  D ^ (S ^ (P & (D | S)))     DSPDSoaxx
//    135-0x87  ~(P ^ (D & S))              PDSaxn
//    136-0x88  D & S                       DSa             SRCAND
//    137-0x89  ~(S ^ (D | (P & ~S)))       SDPSnaoxn
//    138-0x8a  D & (S | ~P)                DSPnoa
//    139-0x8b  ~(D ^ (S | (P ^ D)))        DSPDxoxn
//    140-0x8c  S & (D | ~P)                SDPnoa
//    141-0x8d  ~(S ^ (D | (P ^ S)))        SDPSxoxn
//    142-0x8e  S ^ ((S ^ D) & (P ^ D))     SSDxPDxax
//    143-0x8f  ~(P & ~(D & S))             PDSanan
//    144-0x90  P & ~(D ^ S)                PDSxna
//    145-0x91  ~(S ^ (D & (P | ~S)))       SDPSnoaxn
//    146-0x92  D ^ (P ^ (S & (D | P)))     DPSDPoaxx
//    147-0x93  ~(S ^ (P & D))              SPDaxn
//    148-0x94  P ^ (S ^ (D & (P | S)))     PSDPSoaxx
//    149-0x95  ~(D ^ (P & S))              DPSaxn
//    150-0x96  D ^ (P ^ S)                 DPSxx
//    151-0x97  P ^ (S ^ (D | ~(P | S)))    PSDPSonoxx
//    152-0x98  ~(S ^ (D | ~(P | S)))       SDPSonoxn
//    153-0x99  ~(D ^ S)                    DSxn
//    154-0x9a  D ^ (P & ~S)                DPSnax
//    155-0x9b  ~(S ^ (D & (P | S)))        SDPSoaxn
//    156-0x9c  S ^ (P & ~D)                SPDnax
//    157-0x9d  ~(D ^ (S & (P | D)))        DSPDoaxn
//    158-0x9e  D ^ (S ^ (P | (D & S)))     DSPDSaoxx
//    159-0x9f  ~(P & (D ^ S))              PDSxan
//    160-0xa0  D & P                       DPa
//    161-0xa1  ~(P ^ (D | (S & ~P)))       PDSPnaoxn
//    162-0xa2  D & (P | ~S)                DPSnoa
//    163-0xa3  ~(D ^ (P | (S ^ D)))        DPSDxoxn
//    164-0xa4  ~(P ^ (D | ~(S | P)))       PDSPonoxn
//    165-0xa5  ~(P ^ D)                    PDxn
//    166-0xa6  D ^ (S & ~P)                DSPnax
//    167-0xa7  ~(P ^ (D & (S | P)))        PDSPoaxn
//    168-0xa8  D & (P | S)                 DPSoa
//    169-0xa9  ~(D ^ (P | S))              DPSoxn
//    170-0xaa  D                           D
//    171-0xab  D | ~(P | S)                DPSono
//    172-0xac  S ^ (P & (D ^ S))           SPDSxax
//    173-0xad  ~(D ^ (P | (S & D)))        DPSDaoxn
//    174-0xae  D | (S & ~P)                DSPnao
//    175-0xaf  D | ~P                      DPno
//    176-0xb0  P & (D | ~S)                PDSnoa
//    177-0xb1  ~(P ^ (D | (S ^ P)))        PDSPxoxn
//    178-0xb2  S ^ ((S ^ P) | (D ^ S))     SSPxDSxox
//    179-0xb3  ~(S & ~(D & P))             SDPanan
//    180-0xb4  P ^ (S & ~D)                PSDnax
//    181-0xb5  ~(D ^ (P & (S | D)))        DPSDoaxn
//    182-0xb6  D ^ (P ^ (S | (D & P)))     DPSDPaoxx
//    183-0xb7  ~(S & (D ^ P))              SDPxan
//    184-0xb8  P ^ (S & (D ^ P))           PSDPxax
//    185-0xb9  ~(D ^ (S | (P & D)))        DSPDaoxn
//    186-0xba  D | (P & ~S)                DPSnao
//    187-0xbb  D | ~S                      DSno            MERGEPAINT
//    188-0xbc  S ^ (P & ~(D & S))          SPDSanax
//    189-0xbd  ~((S ^ D) & (P ^ D))        SDxPDxan
//    190-0xbe  D | (P ^ S)                 DPSxo
//    191-0xbf  D | ~(P & S)                DPSano
//    192-0xc0  P & S                       PSa             MERGECOPY
//    193-0xc1  ~(S ^ (P | (D & ~S)))       SPDSnaoxn
//    194-0xc2  ~(S ^ (P | ~(D | S)))       SPDSonoxn
//    195-0xc3  ~(P ^ S)                    PSxn
//    196-0xc4  S & (P | ~D)                SPDnoa
//    197-0xc5  ~(S ^ (P | (D ^ S)))        SPDSxoxn
//    198-0xc6  S ^ (D & ~P)                SDPnax
//    199-0xc7  ~(P ^ (S & (D | P)))        PSDPoaxn
//    200-0xc8  S & (D | P)                 SDPoa
//    201-0xc9  ~(S ^ (P | D))              SPDoxn
//    202-0xca  D ^ (P & (S ^ D))           DPSDxax
//    203-0xcb  ~(S ^ (P | (D & S)))        SPDSaoxn
//    204-0xcc  S                           S               SRCCOPY
//    205-0xcd  S | ~(D | P)                SDPono
//    206-0xce  S | (D & ~P)                SDPnao
//    207-0xcf  S | ~P                      SPno
//    208-0xd0  P & (S | ~D)                PSDnoa
//    209-0xd1  ~(P ^ (S | (D ^ P)))        PSDPxoxn
//    210-0xd2  P ^ (D & ~S)                PDSnax
//    211-0xd3  ~(S ^ (P & (D | S)))        SPDSoaxn
//    212-0xd4  S ^ ((S ^ P) & (P ^ D))     SSPxPDxax
//    213-0xd5  ~(D & ~(P & S))             DPSanan
//    214-0xd6  P ^ (S ^ (D | (P & S)))     PSDPSaoxx
//    215-0xd7  ~(D & (P ^ S))              DPSxan
//    216-0xd8  P ^ (D & (S ^ P))           PDSPxax
//    217-0xd9  ~(S ^ (D | (P & S)))        SDPSaoxn
//    218-0xda  D ^ (P & ~(S & D))          DPSDanax
//    219-0xdb  ~((S ^ P) & (D ^ S))        SPxDSxan
//    220-0xdc  S | (P & ~D)                SPDnao
//    221-0xdd  S | ~D                      SDno
//    222-0xde  S | (D ^ P)                 SDPxo
//    223-0xdf  S | ~(D & P)                SDPano
//    224-0xe0  P & (D | S)                 PDSoa
//    225-0xe1  ~(P ^ (D | S))              PDSoxn
//    226-0xe2  D ^ (S & (P ^ D))           DSPDxax
//    227-0xe3  ~(P ^ (S | (D & P)))        PSDPaoxn
//    228-0xe4  S ^ (D & (P ^ S))           SDPSxax
//    229-0xe5  ~(P ^ (D | (S & P)))        PDSPaoxn
//    230-0xe6  S ^ (D & ~(P & S))          SDPSanax
//    231-0xe7  ~((S ^ P) & (P ^ D))        SPxPDxan
//    232-0xe8  S ^ ((S ^ P) & (D ^ S))     SSPxDSxax
//    233-0xe9  ~(D ^ (S ^ (P & ~(D & S)))) DSPDSanaxxn
//    234-0xea  D | (P & S)                 DPSao
//    235-0xeb  D | ~(P ^ S)                DPSxno
//    236-0xec  S | (D & P)                 SDPao
//    237-0xed  S | ~(D ^ P)                SDPxno
//    238-0xee  D | S                       DSo             SRCPAINT
//    239-0xef  S | (D | ~P)                SDPnoo
//    240-0xf0  P                           P               PATCOPY
//    241-0xf1  P | ~(D | S)                PDSono
//    242-0xf2  P | (D & ~S)                PDSnao
//    243-0xf3  P | ~S                      PSno
//    244-0xf4  P | (S & ~D)                PSDnao
//    245-0xf5  P | ~D                      PDno
//    246-0xf6  P | (D ^ S)                 PDSxo
//    247-0xf7  P | ~(D & S)                PDSano
//    248-0xf8  P | (D & S)                 PDSao
//    249-0xf9  P | ~(D ^ S)                PDSxno
//    250-0xfa  D | P                       DPo
//    251-0xfb  D | (P | ~S)                DPSnoo          PATPAINT
//    252-0xfc  P | S                       PSo
//    253-0xfd  P | (S | ~D)                PSDnoo
//    254-0xfe  D | (P | S)                 DPSoo
//    255-0xff  1                           1               WHITENESS
//
//
// ********* ALL ROP3/ROP2 CODES are SYMMETRIC ************
//
// Raster Operation Index required [NONE]
//
// 0x00: 0                           [INV] 0xff: 1
//
// Raster Operation Index required [DST ]
//
// 0x55: ~D                          [INV] 0xaa: D
//
// Raster Operation Index required [SRC ]
//
// 0x33: ~S                          [INV] 0xcc: S
//
// Raster Operation Index required [SRC DST ]
//
// 0x11: ~(D | S)                    [INV] 0xee: D | S
// 0x22: D & ~S                      [INV] 0xdd: S | ~D
// 0x44: S & ~D                      [INV] 0xbb: D | ~S
// 0x66: D ^ S                       [INV] 0x99: ~(D ^ S)
// 0x77: ~(D & S)                    [INV] 0x88: D & S
//
// Raster Operation Index required [PAT ]
//
// 0x0f: ~P                          [INV] 0xf0: P
//
// Raster Operation Index required [PAT DST ]
//
// 0x05: ~(D | P)                    [INV] 0xfa: D | P
// 0x0a: D & ~P                      [INV] 0xf5: P | ~D
// 0x50: P & ~D                      [INV] 0xaf: D | ~P
// 0x5a: D ^ P                       [INV] 0xa5: ~(P ^ D)
// 0x5f: ~(D & P)                    [INV] 0xa0: D & P
//
// Raster Operation Index required [PAT SRC ]
//
// 0x03: ~(P | S)                    [INV] 0xfc: P | S
// 0x0c: S & ~P                      [INV] 0xf3: P | ~S
// 0x30: P & ~S                      [INV] 0xcf: S | ~P
// 0x3c: P ^ S                       [INV] 0xc3: ~(P ^ S)
// 0x3f: ~(P & S)                    [INV] 0xc0: P & S
//
// Raster Operation Index required [PAT SRC DST ]
//
// 0x01: ~(D | (P | S))              [INV] 0xfe: D | (P | S)
// 0x02: D & ~(P | S)                [INV] 0xfd: P | (S | ~D)
// 0x04: S & ~(D | P)                [INV] 0xfb: D | (P | ~S)
// 0x06: ~(P | ~(D ^ S))             [INV] 0xf9: P | ~(D ^ S)
// 0x07: ~(P | (D & S))              [INV] 0xf8: P | (D & S)
// 0x08: S & (D & ~P)                [INV] 0xf7: P | ~(D & S)
// 0x09: ~(P | (D ^ S))              [INV] 0xf6: P | (D ^ S)
// 0x0b: ~(P | (S & ~D))             [INV] 0xf4: P | (S & ~D)
// 0x0d: ~(P | (D & ~S))             [INV] 0xf2: P | (D & ~S)
// 0x0e: ~(P | ~(D | S))             [INV] 0xf1: P | ~(D | S)
// 0x10: P & ~(D | S)                [INV] 0xef: S | (D | ~P)
// 0x12: ~(S | ~(D ^ P))             [INV] 0xed: S | ~(D ^ P)
// 0x13: ~(S | (D & P))              [INV] 0xec: S | (D & P)
// 0x14: ~(D | ~(P ^ S))             [INV] 0xeb: D | ~(P ^ S)
// 0x15: ~(D | (P & S))              [INV] 0xea: D | (P & S)
// 0x16: P ^ (S ^ (D & ~(P & S)))    [INV] 0xe9: ~(D ^ (S ^ (P & ~(D & S))))
// 0x17: ~(S ^ ((S ^ P) & (D ^ S)))  [INV] 0xe8: S ^ ((S ^ P) & (D ^ S))
// 0x18: (S ^ P) & (P ^ D)           [INV] 0xe7: ~((S ^ P) & (P ^ D))
// 0x19: ~(S ^ (D & ~(P & S)))       [INV] 0xe6: S ^ (D & ~(P & S))
// 0x1a: P ^ (D | (S & P))           [INV] 0xe5: ~(P ^ (D | (S & P)))
// 0x1b: ~(S ^ (D & (P ^ S)))        [INV] 0xe4: S ^ (D & (P ^ S))
// 0x1c: P ^ (S | (D & P))           [INV] 0xe3: ~(P ^ (S | (D & P)))
// 0x1d: ~(D ^ (S & (P ^ D)))        [INV] 0xe2: D ^ (S & (P ^ D))
// 0x1e: P ^ (D | S)                 [INV] 0xe1: ~(P ^ (D | S))
// 0x1f: ~(P & (D | S))              [INV] 0xe0: P & (D | S)
// 0x20: D & (P & ~S)                [INV] 0xdf: S | ~(D & P)
// 0x21: ~(S | (D ^ P))              [INV] 0xde: S | (D ^ P)
// 0x23: ~(S | (P & ~D))             [INV] 0xdc: S | (P & ~D)
// 0x24: (S ^ P) & (D ^ S)           [INV] 0xdb: ~((S ^ P) & (D ^ S))
// 0x25: ~(P ^ (D & ~(S & P)))       [INV] 0xda: D ^ (P & ~(S & D))
// 0x26: S ^ (D | (P & S))           [INV] 0xd9: ~(S ^ (D | (P & S)))
// 0x27: S ^ (D | ~(P ^ S))          [INV] 0xd8: P ^ (D & (S ^ P))
// 0x28: D & (P ^ S)                 [INV] 0xd7: ~(D & (P ^ S))
// 0x29: ~(P ^ (S ^ (D | (P & S))))  [INV] 0xd6: P ^ (S ^ (D | (P & S)))
// 0x2a: D & ~(P & S)                [INV] 0xd5: ~(D & ~(P & S))
// 0x2b: ~(S ^ ((S ^ P) & (P ^ D)))  [INV] 0xd4: S ^ ((S ^ P) & (P ^ D))
// 0x2c: S ^ (P & (D | S))           [INV] 0xd3: ~(S ^ (P & (D | S)))
// 0x2d: P ^ (S | ~D)                [INV] 0xd2: P ^ (D & ~S)
// 0x2e: P ^ (S | (D ^ P))           [INV] 0xd1: ~(P ^ (S | (D ^ P)))
// 0x2f: ~(P & (S | ~D))             [INV] 0xd0: P & (S | ~D)
// 0x31: ~(S | (D & ~P))             [INV] 0xce: S | (D & ~P)
// 0x32: S ^ (D | (P | S))           [INV] 0xcd: S | ~(D | P)
// 0x34: S ^ (P | (D & S))           [INV] 0xcb: ~(S ^ (P | (D & S)))
// 0x35: S ^ (P | ~(D ^ S))          [INV] 0xca: D ^ (P & (S ^ D))
// 0x36: S ^ (D | P)                 [INV] 0xc9: ~(S ^ (P | D))
// 0x37: ~(S & (D | P))              [INV] 0xc8: S & (D | P)
// 0x38: P ^ (S & (D | P))           [INV] 0xc7: ~(P ^ (S & (D | P)))
// 0x39: S ^ (P | ~D)                [INV] 0xc6: S ^ (D & ~P)
// 0x3a: S ^ (P | (D ^ S))           [INV] 0xc5: ~(S ^ (P | (D ^ S)))
// 0x3b: ~(S & (P | ~D))             [INV] 0xc4: S & (P | ~D)
// 0x3d: S ^ (P | ~(D | S))          [INV] 0xc2: ~(S ^ (P | ~(D | S)))
// 0x3e: S ^ (P | (D & ~S))          [INV] 0xc1: ~(S ^ (P | (D & ~S)))
// 0x40: P & (S & ~D)                [INV] 0xbf: D | ~(P & S)
// 0x41: ~(D | (P ^ S))              [INV] 0xbe: D | (P ^ S)
// 0x42: (S ^ D) & (P ^ D)           [INV] 0xbd: ~((S ^ D) & (P ^ D))
// 0x43: ~(S ^ (P & ~(D & S)))       [INV] 0xbc: S ^ (P & ~(D & S))
// 0x45: ~(D | (P & ~S))             [INV] 0xba: D | (P & ~S)
// 0x46: D ^ (S | (P & D))           [INV] 0xb9: ~(D ^ (S | (P & D)))
// 0x47: ~(P ^ (S & (D ^ P)))        [INV] 0xb8: P ^ (S & (D ^ P))
// 0x48: S & (D ^ P)                 [INV] 0xb7: ~(S & (D ^ P))
// 0x49: ~(P ^ (D ^ (S | (P & D))))  [INV] 0xb6: D ^ (P ^ (S | (D & P)))
// 0x4a: D ^ (P & (S | D))           [INV] 0xb5: ~(D ^ (P & (S | D)))
// 0x4b: P ^ (D | ~S)                [INV] 0xb4: P ^ (S & ~D)
// 0x4c: S & ~(D & P)                [INV] 0xb3: ~(S & ~(D & P))
// 0x4d: ~(S ^ ((S ^ P) | (D ^ S)))  [INV] 0xb2: S ^ ((S ^ P) | (D ^ S))
// 0x4e: P ^ (D | (S ^ P))           [INV] 0xb1: ~(P ^ (D | (S ^ P)))
// 0x4f: ~(P & (D | ~S))             [INV] 0xb0: P & (D | ~S)
// 0x51: ~(D | (S & ~P))             [INV] 0xae: D | (S & ~P)
// 0x52: D ^ (P | (S & D))           [INV] 0xad: ~(D ^ (P | (S & D)))
// 0x53: ~(S ^ (P & (D ^ S)))        [INV] 0xac: S ^ (P & (D ^ S))
// 0x54: ~(D | ~(P | S))             [INV] 0xab: D | ~(P | S)
// 0x56: D ^ (P | S)                 [INV] 0xa9: ~(D ^ (P | S))
// 0x57: ~(D & (P | S))              [INV] 0xa8: D & (P | S)
// 0x58: P ^ (D & (S | P))           [INV] 0xa7: ~(P ^ (D & (S | P)))
// 0x59: D ^ (P | ~S)                [INV] 0xa6: D ^ (S & ~P)
// 0x5b: D ^ (P | ~(S | D))          [INV] 0xa4: ~(P ^ (D | ~(S | P)))
// 0x5c: D ^ (P | (S ^ D))           [INV] 0xa3: ~(D ^ (P | (S ^ D)))
// 0x5d: ~(D & (P | ~S))             [INV] 0xa2: D & (P | ~S)
// 0x5e: D ^ (P | (S & ~D))          [INV] 0xa1: ~(P ^ (D | (S & ~P)))
// 0x60: P & (D ^ S)                 [INV] 0x9f: ~(P & (D ^ S))
// 0x61: ~(D ^ (S ^ (P | (D & S))))  [INV] 0x9e: D ^ (S ^ (P | (D & S)))
// 0x62: D ^ (S & (P | D))           [INV] 0x9d: ~(D ^ (S & (P | D)))
// 0x63: S ^ (D | ~P)                [INV] 0x9c: S ^ (P & ~D)
// 0x64: S ^ (D & (P | S))           [INV] 0x9b: ~(S ^ (D & (P | S)))
// 0x65: D ^ (S | ~P)                [INV] 0x9a: D ^ (P & ~S)
// 0x67: S ^ (D | ~(P | S))          [INV] 0x98: ~(S ^ (D | ~(P | S)))
// 0x68: ~(D ^ (S ^ (P | ~(D | S)))) [INV] 0x97: P ^ (S ^ (D | ~(P | S)))
// 0x69: ~(P ^ (D ^ S))              [INV] 0x96: D ^ (P ^ S)
// 0x6a: D ^ (P & S)                 [INV] 0x95: ~(D ^ (P & S))
// 0x6b: ~(P ^ (S ^ (D & (P | S))))  [INV] 0x94: P ^ (S ^ (D & (P | S)))
// 0x6c: S ^ (D & P)                 [INV] 0x93: ~(S ^ (P & D))
// 0x6d: ~(P ^ (D ^ (S & (P | D))))  [INV] 0x92: D ^ (P ^ (S & (D | P)))
// 0x6e: S ^ (D & (P | ~S))          [INV] 0x91: ~(S ^ (D & (P | ~S)))
// 0x6f: ~(P & ~(D ^ S))             [INV] 0x90: P & ~(D ^ S)
// 0x70: P & ~(D & S)                [INV] 0x8f: ~(P & ~(D & S))
// 0x71: ~(S ^ ((S ^ D) & (P ^ D)))  [INV] 0x8e: S ^ ((S ^ D) & (P ^ D))
// 0x72: S ^ (D | (P ^ S))           [INV] 0x8d: ~(S ^ (D | (P ^ S)))
// 0x73: ~(S & (D | ~P))             [INV] 0x8c: S & (D | ~P)
// 0x74: D ^ (S | (P ^ D))           [INV] 0x8b: ~(D ^ (S | (P ^ D)))
// 0x75: ~(D & (S | ~P))             [INV] 0x8a: D & (S | ~P)
// 0x76: S ^ (D | (P & ~S))          [INV] 0x89: ~(S ^ (D | (P & ~S)))
// 0x78: P ^ (D & S)                 [INV] 0x87: ~(P ^ (D & S))
// 0x79: ~(D ^ (S ^ (P & (D | S))))  [INV] 0x86: D ^ (S ^ (P & (D | S)))
// 0x7a: D ^ (P & (S | ~D))          [INV] 0x85: ~(P ^ (D & (S | ~P)))
// 0x7b: ~(S & ~(D ^ P))             [INV] 0x84: S & ~(D ^ P)
// 0x7c: S ^ (P & (D | ~S))          [INV] 0x83: ~(S ^ (P & (D | ~S)))
// 0x7d: ~(D & ~(P ^ S))             [INV] 0x82: D & ~(P ^ S)
// 0x7e: (S ^ P) | (D ^ S)           [INV] 0x81: ~((S ^ P) | (D ^ S))
// 0x7f: ~(D & (P & S))              [INV] 0x80: D & (P & S)
//
//
// The following macros will tell us if we need to use a 'mask' for ROP4
// and define if S / P / D are in a ROP3
//

#define ROP4_NEED_MASK(Rop4)    (((Rop4 >> 8) & 0xFF) != (Rop4 & 0xFF))
#define ROP3_NEED_PAT(Rop3)     (((Rop3 >> 4) & 0x0F) != (Rop3 & 0x0F))
#define ROP3_NEED_SRC(Rop3)     (((Rop3 >> 2) & 0x33) != (Rop3 & 0x33))
#define ROP3_NEED_DST(Rop3)     (((Rop3 >> 1) & 0x55) != (Rop3 & 0x55))
#define ROP4_FG_ROP(Rop4)       (Rop4 & 0xFF)
#define ROP4_BG_ROP(Rop4)       ((Rop4 >> 8) & 0xFF)


#define CSI_SRC         0
#define CSI_PAT         1
#define CSI_TMP         2
#define CSI_TOTAL       3

typedef struct _CLONESO {
    SURFOBJ *pso;
    HBITMAP hBmp;
    } CLONESO, *PCLONESO;


typedef struct _SDINFO {
    SURFOBJ     *psoDst;    // detination to write BITMAP or DEVICE
    SURFOBJ     *psoSrc;    // source to read must be BITMAP
    PRECTL      prclDst;    // destination rectangle
    PRECTL      prclSrc;    // source rectangle
    PPOINTL     pptlSrcOrg; // brush origin start
    } SDINFO, *PSDINFO;



//
// Function prototypes
//

BOOL
CloneBitBltSURFOBJ(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMask,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PRECTL      prclMask,
    BRUSHOBJ    *pbo,
    PCLONESO    pCloneSO,
    DWORD       RopBG,
    DWORD       RopFG
    );

BOOL
DoSpecialRop3(
    SURFOBJ *psoDst,
    CLIPOBJ *pco,
    PRECTL  prclDst,
    DWORD   Rop3
    );

BOOL
DoMix2(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PPOINTL     pptlSrcOrg,
    DWORD       Mix2
    );

BOOL
DoRop3(
    PPDEV       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoPat,
    SURFOBJ     *psoTmp,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PRECTL      prclPat,
    PPOINTL     pptlPatOrg,
    BRUSHOBJ    *pbo,
    DWORD       Rop3
    );


#endif  // _ROPBLT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\transpos.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    transpos.c


Abstract:

    This module implements the functions for transposing an 8BPP, 4BPP and
    1BPP bitmap. There is also a helper function for building a table which
    speeds some of the rotation logic.

Author:

    22-Dec-1993 Wed 13:09:11 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgTransPos

#define DBG_BUILD_TP8x8     0x00000001
#define DBG_TP_1BPP         0x00000002
#define DBG_TP_4BPP         0x00000004

DEFINE_DBGVAR(0);



//
// Private #defines and data structures for use only in this module.
//

#define ENTRY_TP8x8         256
#define SIZE_TP8x8          (sizeof(DWORD) * 2 * ENTRY_TP8x8)



LPDWORD
Build8x8TransPosTable(
    VOID
    )

/*++

Routine Description:

    This function build the 8x8 transpos table for use later in transposing
    1bpp.

Arguments:


Return Value:



Author:

    22-Dec-1993 Wed 14:19:50 created  -by-  DC


Revision History:


--*/

{
    LPDWORD pdwTP8x8;


    //
    // We now build the table which will represent the data for doing a
    // rotation. Basically for each combination of bits in the byte, we
    // build the equivalent 8 byte rotation for those bits. The 1st byte
    // of the translated bytes are mapped to the 0x01 bit of the source and
    // the last byte is mapped to the 0x80 bit.



    if (pdwTP8x8 = (LPDWORD)LocalAlloc(LPTR, SIZE_TP8x8)) {

        LPBYTE  pbData = (LPBYTE)pdwTP8x8;
        WORD    Entry;
        WORD    Bits;

        //
        // Now start buiding the table, for each entry we expand each bit
        // in the byte to the rotate byte value.
        //

        for (Entry = 0; Entry < ENTRY_TP8x8; Entry++) {

            //
            // For each of bit combinations in the byte, we will examine each
            // bit from bit 0 to bit 7, and set each of the trasposed bytes to
            // either 1 (bit set) or 0 (bit clear)
            //

            Bits = (WORD)Entry | (WORD)0xff00;

            while (Bits & 0x0100) {

                *pbData++   = (BYTE)(Bits & 0x01);
                Bits      >>= 1;
            }
        }

    } else {

        PLOTERR(("Build8x8TransPosTable: LocalAlloc(SIZE_TP8x8=%ld) failed",
                                                    SIZE_TP8x8));
    }

    return(pdwTP8x8);
}




BOOL
TransPos8BPP(
    PTPINFO pTPInfo
    )

/*++

Routine Description:

    This function rotates a 4bpp source to a 4bpp destination

Arguments:

    pTPINFO - Pointer to the TPINFO to describe how to do transpos, the fields
              must be set to following:

        pPDev:      Pointer to the PDEV
        pSrc:       Pointer to the source bitmap starting point
        pDest       Pointer to the destination bitmap location which stores the
                    transpos result starting from the fist destination scan line
                    in the rotated direction (rotating right will have the low
                    nibble source byte as the first destination scan line.
        cbSrcScan:  Count to be added to advance to then next source bitmap line
        cbDestScan: Count to be added to advance to the high nibble of the
                    destination bitmap line
        cySrc       Total source lines to be processed
        DestXStart: not used, Ignored


        NOTE: 1. The size of buffer area pointed by pDestL must have at least
                 (((cySrc + 1) / 2) * 2) size in bytes, and ABS(DestDelta)
                 must be at least half of that size.

              2. Unused last destination byte will be padded with 0

    Current transposition assumes the bitmap is rotated to the right, if caller
    wants to rotate the bitmap to the left then you must first call the macro
    ROTLEFT_4BPP_TPIINFO(pTPInfo)


Return Value:

    TRUE if sucessful, FALSE if failed.

    if sucessful the pTPInfo->pSrc will automatically be

    1. Incremented by one (1) if cbDestScan is negative (Rotated left 90 degree)
    2. Decremented by one (1) if cbDestScan is positive (Rotated right 90 degree)

Author:

    22-Dec-1993 Wed 13:11:30 created  -by-  DC


Revision History:


--*/

{
    LPBYTE  pSrc;
    LPBYTE  pDest;
    LONG    cbSrcScan;
    DWORD   cySrc;


    PLOTASSERT(1, "cbDestScan is not big enough (%ld)",
               (DWORD)(ABS(pTPInfo->cbDestScan)) >=
               (DWORD)(((pTPInfo->cySrc) + 1) >> 1), pTPInfo->cbDestScan);

    //
    // This is a simple 1x1 8bpp transpose, pSrc will start with one scan line
    // less so the inner loop can be clearly written.
    //

    cbSrcScan = pTPInfo->cbSrcScan;
    pSrc      = pTPInfo->pSrc - cbSrcScan;
    pDest     = pTPInfo->pDest;
    cySrc     = pTPInfo->cySrc;

    while (cySrc--) {

        *pDest++ = *(pSrc += cbSrcScan);
    }

    pTPInfo->pSrc += (INT)((pTPInfo->cbDestScan > 0) ? -1 : 1);

    return(TRUE);
}




BOOL
TransPos4BPP(
    PTPINFO pTPInfo
    )

/*++

Routine Description:

    This function rotates a 4bpp source to a 4bpp destination

Arguments:

    pTPINFO - Pointer to the TPINFO to describe how to do transpose, the fields
              must be set to following

        pPDev:      Pointer to the PDEV
        pSrc:       Pointer to the soruce bitmap starting point
        pDest       Pointer to the destination bitmap location which stores the
                    transpos result starting from the fist destination scan
                    line in the rotated direction (rotating right will have
                    low nibble source bytes as the first destination scan line)
        cbSrcScan:  Count to be added to advance to next source bitmap line
        cbDestScan: Count to be added to advance to the high nibble destination
                    bitmap line
        cySrc       Total source lines to be processed
        DestXStart: not used, Ignored


        NOTE: 1. The size of buffer area pointed to by pDestL must have at least
                 (((cySrc + 1) / 2) * 2) size in bytes, and ABS(DestDelta)
                 must at least half of that size.

              2. Unused last destination byte will be padded with 0

    Current transposition assumes the bitmap is rotated to the right, if caller
    wants to rotate the bitmap to the left then you must first call the macro
    ROTLEFT_4BPP_TPIINFO(pTPInfo)


Return Value:

    TRUE if sucessful, FALSE if failed.

    if sucessful the pTPInfo->pSrc will be automatically:

    1. Incremented by one (1) if cbDestScan is negative (Rotated left 90 degree)
    2. Decremented by one (1) if cbDestScan is positive (Rotated right 90 degree)

Author:

    22-Dec-1993 Wed 13:11:30 created  -by-  DC


Revision History:


--*/

{
    LPBYTE  pSrc;
    LPBYTE  pDest1st;
    LPBYTE  pDest2nd;
    LONG    cbSrcScan;
    DWORD   cySrc;
    BYTE    b0;
    BYTE    b1;


    PLOTASSERT(1, "cbDestScan is not big enough (%ld)",
               (DWORD)(ABS(pTPInfo->cbDestScan)) >=
               (DWORD)(((pTPInfo->cySrc) + 1) >> 1), pTPInfo->cbDestScan);

    //
    // This is a simple 2x2 4bpp transpos, we will transpos only up to cySrc
    // if cySrc is an odd number then the last destination low nibble is set
    // padded with 0
    //
    // Scan 0 - Src0_H Src0_L         pNibbleL - Src0_L Src1_L Src2_L Src3_L
    // Scan 1 - Src1_H Src1_L  ---->  pNibbleH - Src0_H Src1_H Src2_H Src3_H
    // Scan 2 - Src2_H Src2_L
    // Scan 3 - Src3_H Src3_L
    //
    //

    pSrc      = pTPInfo->pSrc;
    cbSrcScan = pTPInfo->cbSrcScan;
    pDest1st  = pTPInfo->pDest;
    pDest2nd  = pDest1st + pTPInfo->cbDestScan;
    cySrc     = pTPInfo->cySrc;

    //
    // Compute the transpose, leaving the last scan line for later. This
    // way we don't pollute the loop with having to check if its the last
    // line.
    //

    while (cySrc > 1) {

        //
        // Compose two input scan line buffers from the input scan buffer
        // by reading in the Y direction
        //

        b0           = *pSrc;
        b1           = *(pSrc += cbSrcScan);
        *pDest1st++  = (BYTE)((b0 << 4) | (b1 & 0x0f));
        *pDest2nd++  = (BYTE)((b1 >> 4) | (b0 & 0xf0));

        pSrc        += cbSrcScan;
        cySrc       -= 2;
    }

    //
    // Deal with last odd source scan line
    //

    if (cySrc > 0) {

        b0        = *pSrc;
        *pDest1st = (BYTE)(b0 <<   4);
        *pDest2nd = (BYTE)(b0 & 0xf0);
    }

    pTPInfo->pSrc += (INT)((pTPInfo->cbDestScan > 0) ? -1 : 1);

    return(TRUE);
}





BOOL
TransPos1BPP(
    PTPINFO pTPInfo
    )

/*++

Routine Description:

    This function rotates a 1bpp source to 1bpp destination.

Arguments:

    pTPINFO - Pointer to the TPINFO to describe how to do the transpose, the
    fields must be set to the following:

        pPDev:      Pointer to the PDEV
        pSrc:       Pointer to the soruce bitmap starting point
        pDest       Pointer to the destination bitmap location which stores the
                    transpos result starting from the fist destination scan
                    line in the rotated direction (rotating right will have
                    0x01 source bit as first destination scan line)
        cbSrcScan:  Count to be added to advance to next source bitmap line
        cbDestScan: Count to be added to advance to the next destination line
        cySrc       Total source lines to be processed
        DestXStart  Specifies where the transposed destination buffer starts,
                    in bit position. It is computed as DestXStart % 8. 0 means
                    it starts at the top bit (0x80), 1 means the next bit (0x40)
                    and so forth.

        NOTE:

              1. The ABS(DestDelta) must be large enough to accomodate the
                 transposed scan line. The size depends on cySrc and DestXStart,
                 the mimimum size must at least be of the size:

                    MinSize = (cySrc + (DestXStart % 8) + 7) / 8

              2. The size of the buffer are pointed to by pDest must have at
                 least ABS(DestDelta) * 8 bytes, if cySrc >= 8, or
                 ABS(DestDelta) * cySrc if cySrc is less than 8.


              3. Unused last byte destinations are padded with 0


    Current transposition assumes the bitmap is rotated to the right, if caller
    wants to rotate the bitmap to the left then you must first call the macro
    ROTLEFT_1BPP_TPIINFO(pTPInfo)


Return Value:

    TRUE if sucessful FALSE if failed

    if sucessful the pTPInfo->pSrc will be automatically

    1. Incremented by one (1) if cbDestScan is negative (Rotated left 90 degree)
    2. Decremented by one (1) if cbDestScan is positive (Rotated right 90 degree)

Author:

    22-Dec-1993 Wed 13:46:01 created  -by-  DC

    24-Dec-1993 Fri 04:58:24 updated  -by-  DC
        Fixed the RemainBits problem, we have to shift final data left if the
        cySrc is already exhausted and RemainBits is not zero.

Revision History:


--*/

{
    LPDWORD pdwTP8x8;
    LPBYTE  pSrc;
    TPINFO  TPInfo;
    INT     RemainBits;
    INT     cbNextDest;
    union {
        BYTE    b[8];
        DWORD   dw[2];
    } TPData;



    TPInfo             = *pTPInfo;
    TPInfo.DestXStart &= 0x07;

    PLOTASSERT(1, "cbDestScan is not big enough (%ld)",
            (DWORD)(ABS(TPInfo.cbDestScan)) >=
            (DWORD)((TPInfo.cySrc + TPInfo.DestXStart + 7) >> 3),
                                                        TPInfo.cbDestScan);
    //
    // Make sure we have the required transpose translate table. If we don't
    // get one built.
    //

    if (!(pdwTP8x8 = (LPDWORD)pTPInfo->pPDev->pTransPosTable)) {

        if (!(pdwTP8x8 = Build8x8TransPosTable())) {

            PLOTERR(("TransPos1BPP: Build 8x8 transpos table failed"));
            return(FALSE);
        }

        pTPInfo->pPDev->pTransPosTable = (LPVOID)pdwTP8x8;
    }

    //
    // set up all required parameters, and start TPData with 0s
    //

    pSrc         = TPInfo.pSrc;
    RemainBits   = (INT)(7 - TPInfo.DestXStart);
    cbNextDest   = (INT)((TPInfo.cbDestScan > 0) ? 1 : -1);
    TPData.dw[0] =
    TPData.dw[1] = 0;

    while (TPInfo.cySrc--) {

        LPDWORD pdwTmp;
        LPBYTE  pbTmp;

        //
        // Translate a byte to 8 bytes with each bit corresponding to each byte
        // each byte is shifted to the left by 1 before combining with the new
        // bit.
        //

        pdwTmp        = pdwTP8x8 + ((UINT)*pSrc << 1);
        TPData.dw[0]  = (TPData.dw[0] << 1) | *(pdwTmp + 0);
        TPData.dw[1]  = (TPData.dw[1] << 1) | *(pdwTmp + 1);
        pSrc         += TPInfo.cbSrcScan;

        //
        // Check to see if we are done with source scan lines. If this is the
        // case we need to possible shift the transposed scan lines by the
        // apropriate number based on RemainBits.
        //

        if (!TPInfo.cySrc) {

            //
            // We are done, check to see if we need to shift the resultant
            // transposed scan lines.
            //

            if (RemainBits) {

                TPData.dw[0] <<= RemainBits;
                TPData.dw[1] <<= RemainBits;

                RemainBits     = 0;
            }
        }

        if (RemainBits--) {

            NULL;

        } else {

            //
            // Save the current result to the output destination scan buffer.
            // Unwind the processing, to give the compiler a chance to generate
            // some fast code, rather that relying on a while loop.
            //

            *(pbTmp  = TPInfo.pDest     ) = TPData.b[0];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[1];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[2];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[3];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[4];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[5];
            *(pbTmp += TPInfo.cbDestScan) = TPData.b[6];
            *(pbTmp +  TPInfo.cbDestScan) = TPData.b[7];

            //
            // Reset RemainBits back to 7, TPData back to 0 and and advance to
            // the next destination
            //

            RemainBits    = 7;
            TPData.dw[0]  =
            TPData.dw[1]  = 0;
            TPInfo.pDest += cbNextDest;
        }
    }


    //
    // Since we succeded in transposing the bitmap, the next source byte
    // location must be incremented or decremented by one.
    //
    // The cbNextDest is 1 if the bitmap is rotated to the right 90 degrees, so
    // we want to decrement by 1.
    //
    // The cbNextDest is -1 if the bitmap is rotated to the right 90 degrees, so
    // we want to increment by 1.
    //

    pTPInfo->pSrc -= cbNextDest;

    return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\textout.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    textout.c


Abstract:

    This module contains the DrvTextOut entry point. This is the main routine
    called by the NT graphics engine in order to get text rendered on the
    target device. This implementation handles both drawing device paths that
    represent the glyphs of the STROBJ (the line of text to output), as well
    as outputing bitmaps that represent the glyphs on devices that can
    handle raster output.

Author:

    Written by AP on 8/17/92.

    15-Nov-1993 Mon 19:43:58 updated  -by-  DC, JB
        clean up / fixed / add debugging information


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgTextOut

#define DBG_GETGLYPHMODE    0x00000001
#define DBG_TEXTOUT         0x00000002
#define DBG_TEXTOUT1        0x00000004
#define DBG_TEXTOUT2        0x00000008
#define DBG_DRAWLINE        0x00000010
#define DBG_TRUETYPE        0x00000020
#define DBG_TRUETYPE1       0x00000040
#define DBG_TRUETYPE2       0x00000080
#define DBG_BMPFONT         0x00000100
#define DBG_BMPTEXTCLR      0x00000200
#define DBG_DEFCHARINC      0x00000400
#define DBG_SET_FONTTYPE    0x20000000
#define DBG_SHOWRASFONT     0x40000000
#define DBG_NO_RASTER_FONT  0x80000000

DEFINE_DBGVAR(0);


extern PALENTRY HTPal[];




DWORD
DrvGetGlyphMode(
    DHPDEV  dhpdev,
    FONTOBJ *pfo
    )

/*++

Routine Description:

    Asks the driver what sort of font information should be cached for a
    particular font. For remote printer devices, this determines the format
    that gets spooled.  For local devices, this determines what GDI stores in
    its font cache.  This call will be made for each particular font
    realization.

Arguments:

    dhpdev  - Pointer to our PDEV

    pfo     - Pointer to the font object

Return Value:

    DWORD as FO_xxxx


Author:

    27-Jan-1994 Thu 12:51:59 created  -by-  DC

    10-Mar-1994 Thu 00:36:30 updated  -by-  DC
        Re-write, so we will pre-examine the Font type, source and its
        technology together with PDEV setting to let engine know which type of
        the font output we are interested in the DrvTextOut(). Currently this
        is broken in GDI which caused a GP in winsrv. (this is why a
        DBG_SET_FONTTYPE switch is on by default)


Revision History:


--*/

{
#define pPDev   ((PPDEV)dhpdev)

    PIFIMETRICS pifi;
    DWORD       FOType;


    PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: Type=%08lx, cxMax=%ld",
                        pfo->flFontType, pfo->cxMax));

    //
    // If we cannot get the IFI metrics for the passed FONTOBJ, only
    // ask for PATHS.
    //

    if (!(pifi = FONTOBJ_pifi(pfo))) {

        PLOTERR(("DrvGetGlyphMode: FONTOBJ_pifi()=NULL, return FO_PATHOBJ"));

        return(FO_PATHOBJ);
    }

    FOType = FO_PATHOBJ;

    //
    // If its a bitmap font, ask for BITS
    //

    if (pifi->flInfo & FM_INFO_TECH_BITMAP) {

        PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: BITMAP FONT, return FO_GLYPHBITS"));

        FOType = FO_GLYPHBITS;

    } else if (pifi->flInfo & FM_INFO_TECH_STROKE) {

        PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: STROKE (Vector) FONT, return FO_PATHOBJ"));

    } else if (pifi->flInfo & FM_INFO_RETURNS_BITMAPS) {

        //
        // Now make a decision on whether to ask for glyphbits or paths.
        // This decision is based on the target device being raster, that
        // bitmap fonts are okay to use, and that the threshold for doing
        // raster fonts versus paths is met.
        //

        DWORD   cxBMFontMax = (DWORD)pPDev->pPlotGPC->RasterXDPI;

        if (pPDev->PlotDM.dm.dmPrintQuality == DMRES_HIGH) {

            cxBMFontMax <<= 3;

        } else {

            cxBMFontMax >>= 2;
        }

        PLOTDBG(DBG_GETGLYPHMODE,
                ("DrvGetGlyphMode: Font CAN return BITMAP, cxBMFontMax=%ld",
                                                    cxBMFontMax));

#if DBG
        if ((!(DBG_PLOTFILENAME & DBG_NO_RASTER_FONT))  &&
            (IS_RASTER(pPDev))                          &&
            (!NO_BMP_FONT(pPDev))                       &&
            (pfo->cxMax <= cxBMFontMax)) {
#else
        if ((IS_RASTER(pPDev))      &&
            (!NO_BMP_FONT(pPDev))   &&
            (pfo->cxMax <= cxBMFontMax)) {
#endif
            PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: Convert to BITMAP FONT, FO_GLYPHBITS"));

            FOType = FO_GLYPHBITS;

        } else {

            PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: Return as FO_PATHOBJ"));
        }

    } else if (pifi->flInfo & FM_INFO_RETURNS_OUTLINES) {

        PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: Font CAN return OUTLINES"));

    } else if (pifi->flInfo & FM_INFO_RETURNS_STROKES) {

        PLOTDBG(DBG_GETGLYPHMODE, ("DrvGetGlyphMode: Font CAN return STROKES"));
    }

#if DBG
    if (DBG_PLOTFILENAME & DBG_SET_FONTTYPE) {

        if ((FOType == FO_GLYPHBITS) &&
            (!(pfo->flFontType & FO_TYPE_RASTER))) {

            PLOTWARN(("DrvGetGlyphMode: Set FontType to RASTER"));

            pfo->flFontType &= ~(FO_TYPE_TRUETYPE | FO_TYPE_DEVICE);
            pfo->flFontType |= FO_TYPE_RASTER;
        }
    }
#endif
    return(FOType);

#undef pPDev
}




BOOL
BitmapTextOut(
    PPDEV       pPDev,
    STROBJ      *pstro,
    FONTOBJ     *pfo,
    PRECTL      pClipRect,
    LPDWORD     pOHTFlags,
    DWORD       Rop3
    )

/*++

Routine Description:

    This routine outputs the passed STROBJ with bitmaps that represent
    each of the glyphs, rather than converting the glyphs to paths that
    will be filled in the target device.

Arguments:

    pPDev           - Pointer to our PDEV

    pstro           - We pass a string object to be drawn

    pfo             - Pointer to the FONTOBJ

    pClipRect       - Current enumerated clipping rectangle

    pOHTFlags       - Pointer to the current OutputHTBitmap() flags

    Rop3            - Rop3 to be used in the device


Return Value:

    TRUE/FALSE


Author:

    18-Feb-1994 Fri 12:41:57 updated  -by-  DC
        change that so if pfo=NULL then the font already in BITMAP format

    14-Feb-1994 Mon 18:16:25 create  -by-  DC

Revision History:


--*/

{
    GLYPHPOS    *pgp;
    GLYPHBITS   *pgb;
    SURFOBJ     soGlyph;
    POINTL      ptlCur;
    SIZEL       sizlInc;
    RECTL       rclSrc;
    RECTL       rclDst;
    BOOL        MoreGlyphs;
    BOOL        Ok;
    BOOL        FirstCh;
    ULONG       cGlyphs;


    //
    // The public fields of SURFOBJ is what will be used by OutputHTBitmap
    // instead of actually creating a SURFOBJ from the graphics engine. This
    // is a safe thing to do, since only we look at these fields.
    //

    ZeroMemory(&soGlyph, sizeof(SURFOBJ));

    soGlyph.dhsurf        = (DHSURF)'PLOT';
    soGlyph.hsurf         = (HSURF)'TEXT';
    soGlyph.dhpdev        = (DHPDEV)pPDev;
    soGlyph.iBitmapFormat = BMF_1BPP;
    soGlyph.iType         = STYPE_BITMAP;
    soGlyph.fjBitmap      = BMF_TOPDOWN;

    //
    // We will now enumerate each of the glyphs in the STROBJ such that
    // we can image them. If the STROBJ has a non NULL pgp field, this means
    // that the GLYPH definitions are already available, and no enumeration
    // is required. If not, we will make a sequence of calls to STROBJ_bEnum
    // (an engine helper) to enumerate the glyphs. The actual imaging code
    // is the same, regardless of the stat of STROBJ->pgp
    //

    if (pstro->pgp) {

        pgp        = pstro->pgp;
        MoreGlyphs = FALSE;
        cGlyphs    = pstro->cGlyphs;

        PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: Character info already there (%ld glyphs)", cGlyphs));

    } else {

        STROBJ_vEnumStart(pstro);
        MoreGlyphs = TRUE;

        PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: STROBJ enub"));
    }

    //
    // Now straring drawing the glyphs, if we have MoreGlyphs = TRUE  then we
    // will initially do a STROBJ_bEnum first to initialize enumeration of
    // the glyphs
    //

    Ok          = TRUE;
    Rop3       &= 0xFF;
    sizlInc.cx  =
    sizlInc.cy  = 0;
    FirstCh     = TRUE;

    do {

        //
        // Verify the job is not aborting, if it is break out now.
        //

        if (PLOT_CANCEL_JOB(pPDev)) {

           break;
        }


        //
        // Check to see if we need to do an enumeration and start it if
        // it is required.
        //

        if (MoreGlyphs) {

            MoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);

            if (MoreGlyphs == DDI_ERROR) {

                PLOTERR(("DrvTextOut: STROBJ_bEnum()=DDI_ERROR"));
                return(FALSE);
            }
        }

        PLOTDBG(DBG_BMPFONT,
                ("BitmapTextOut: New batch of cGlyphs=%d", cGlyphs));

        //
        // Get the first character position
        //

        if ((FirstCh) && (cGlyphs)) {

            ptlCur  = pgp->ptl;
            FirstCh = FALSE;
        }

        //
        // Start sending each bitmap to the device
        //

        for ( ; (Ok) && (cGlyphs--); pgp++) {

            GLYPHDATA   gd;
            GLYPHDATA   *pgd;


            if (PLOT_CANCEL_JOB(pPDev)) {

                break;
            }

            if (pfo) {

                //
                // This is true type font, so query the bitmap
                //

                pgd = &gd;

                if (FONTOBJ_cGetGlyphs(pfo,
                                       FO_GLYPHBITS,
                                       1,
                                       &(pgp->hg),
                                       (LPVOID)&pgd) != 1) {

                    PLOTRIP(("BitmapTextOut: FONTOBJ_cGetGlyphs() FAILED"));
                    return(FALSE);
                }

                pgb = pgd->gdf.pgb;

            } else {

                //
                // For bitmap font, we already have the bitmap
                //

                pgb = pgp->pgdf->pgb;
            }

            //
            // Get the size of the bitmap
            //

            soGlyph.sizlBitmap = pgb->sizlBitmap;

            //
            // Compute new destination position for the text, based on the
            // passed accelerators.
            //

            if (pstro->ulCharInc) {

                sizlInc.cx =
                sizlInc.cy = (LONG)pstro->ulCharInc;

            } else if (pstro->flAccel & SO_CHAR_INC_EQUAL_BM_BASE) {

                sizlInc = soGlyph.sizlBitmap;

            } else {

                ptlCur = pgp->ptl;
            }

            if (!(pstro->flAccel & SO_HORIZONTAL)) {

                sizlInc.cx = 0;
            }

            if (!(pstro->flAccel & SO_VERTICAL)) {

                sizlInc.cy = 0;
            }

            if (pstro->flAccel & SO_REVERSED) {

                sizlInc.cx = -sizlInc.cx;
                sizlInc.cy = -sizlInc.cy;
            }


            //
            // The pgp->ptl informs us where to position the glyph origin in
            // the device surface, and pgb->ptlOrigin informs us of the
            // relationship between character origin and bitmap origin. For
            // example, if (2,-24) is passed in as the character origin, then
            // we would need to reposition rclDst.left right 2 pixels and
            // rclDst.top up 24 pixels.
            //

            rclDst.left    = ptlCur.x + pgb->ptlOrigin.x;
            rclDst.top     = ptlCur.y + pgb->ptlOrigin.y;
            rclDst.right   = rclDst.left + soGlyph.sizlBitmap.cx;
            rclDst.bottom  = rclDst.top + soGlyph.sizlBitmap.cy;
            ptlCur.x      += sizlInc.cx;
            ptlCur.y      += sizlInc.cy;


            //
            // NOTE: If the bitmap size is 1x1 and the value of the glyphdata
            //       is 0 (background only) then we skip this glyph. This is
            //       GDI's way of telling us we have an empty glyph (like a
            //       space).

            if ((soGlyph.sizlBitmap.cx == 1) &&
                (soGlyph.sizlBitmap.cy == 1) &&
                ((pgb->aj[0] & 0x80) == 0x0)) {

                PLOTDBG(DBG_BMPFONT,
                        ("BitmapTextOut: Getting (1x1)=0 bitmap, SKIP it"));

                soGlyph.sizlBitmap.cx =
                soGlyph.sizlBitmap.cy = 0;

            } else {

                rclSrc = rclDst;

                PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: pgp=%08lx, pgb=%08lx, ptl=(%ld, %ld) Inc=(%ld, %ld)",
                                            pgp, pgb, pgp->ptl.x, pgp->ptl.y,
                                            sizlInc.cx, sizlInc.cy));
                PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: Bmp=%ld x %ld, pgb->ptlOrigin=[%ld, %ld]",
                                            soGlyph.sizlBitmap.cx,
                                            soGlyph.sizlBitmap.cy,
                                            pgb->ptlOrigin.x, pgb->ptlOrigin.y));
                PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: rclDst=(%ld, %ld)-(%ld, %ld)",
                        rclDst.left, rclDst.top, rclDst.right, rclDst.bottom));

            }

            //
            // Now verify that we have a glyph to send, and that the glyphs
            // destination position in the target device, lies inside
            // the clipping region.
            //


            if ((soGlyph.sizlBitmap.cx)                 &&
                (soGlyph.sizlBitmap.cy)                 &&
                (IntersectRECTL(&rclDst, pClipRect))) {

                //
                // We will pass the internal version of soGlyph without making
                // a temp. copy.
                //

                soGlyph.pvBits  =
                soGlyph.pvScan0 = (LPVOID)pgb->aj;
                soGlyph.lDelta  = (LONG)((soGlyph.sizlBitmap.cx + 7) >> 3);
                soGlyph.cjBits  = (LONG)(soGlyph.lDelta *
                                         soGlyph.sizlBitmap.cy);
                rclSrc.left     = rclDst.left - rclSrc.left;
                rclSrc.top      = rclDst.top - rclSrc.top;
                rclSrc.right    = rclSrc.left + (rclDst.right - rclDst.left);
                rclSrc.bottom   = rclSrc.top + (rclDst.bottom - rclDst.top);

                PLOTDBG(DBG_BMPFONT, ("BitmapTextOut: rclSrc=(%ld, %ld)-(%ld, %ld)",
                        rclSrc.left, rclSrc.top, rclSrc.right, rclSrc.bottom));

#if DBG
                if (DBG_PLOTFILENAME & DBG_SHOWRASFONT) {

                    LPBYTE  pbSrc;
                    LPBYTE  pbCur;
                    UINT    x;
                    UINT    y;
                    UINT    Size;
                    BYTE    bData;
                    BYTE    Mask;
                    BYTE    Buf[128];

                    DBGP(("================================================="));
                    DBGP(("BitmapTextOut: Size=%ld x %ld, Origin=(%ld, %ld), Clip=(%ld, %ld)-(%ld, %ld)",
                            soGlyph.sizlBitmap.cx, soGlyph.sizlBitmap.cy,
                            pgb->ptlOrigin.x, pgb->ptlOrigin.y,
                            rclSrc.left, rclSrc.top,
                            rclSrc.right, rclSrc.bottom));

                    pbSrc = soGlyph.pvScan0;

                    for (y = 0; y < (UINT)soGlyph.sizlBitmap.cy; y++) {

                        pbCur  = pbSrc;
                        pbSrc += soGlyph.lDelta;
                        Mask   = 0x0;
                        Size   = 0;

                        for (x = 0; x < (UINT)soGlyph.sizlBitmap.cx; x++) {

                            if (!(Mask >>= 1)) {

                                Mask  = 0x80;
                                bData = *pbCur++;
                            }

                            if ((y >= (UINT)rclSrc.top)     &&
                                (y <  (UINT)rclSrc.bottom)  &&
                                (x >= (UINT)rclSrc.left)    &&
                                (x <  (UINT)rclSrc.right)) {

                                Buf[Size++] = (BYTE)((bData & Mask) ? 219 :
                                                                      177);

                            } else {

                                Buf[Size++] = (BYTE)((bData & Mask) ? 178 :
                                                                      176);
                            }
                        }

                        Buf[Size] = '\0';

                        DBGP((Buf));
                    }
                }
#endif
                //
                // Now output the bitmap that represents the glyph
                //

                Ok = OutputHTBitmap(pPDev,              // pPDev
                                    &soGlyph,           // psoHT
                                    NULL,               // pco
                                    (PPOINTL)&rclDst,   // pptlDst
                                    &rclSrc,            // prclSrc
                                    Rop3,               // Rop3
                                    pOHTFlags);         // pOHTFlags
            }
        }

    } while ((Ok) && (MoreGlyphs));

    return(Ok);
}




BOOL
OutlineTextOut(
    PPDEV       pPDev,
    STROBJ      *pstro,
    FONTOBJ     *pfo,
    PRECTL      pClipRect,
    BRUSHOBJ    *pboBrush,
    POINTL      *pptlBrushOrg,
    DWORD       OutlineFlags,
    ROP4        Rop4
    )

/*++

Routine Description:


    This routine outputs the passed STROBJ by outputing a path that
    represents each glyph to the target device.

Arguments:

    pPDev           - Pointer to our PDEV

    pstro           - We pass a string object to be drawn

    pfo             - Pointer to the FONTOBJ

    pClipRect       - Current enumerated clipping rectangle

    pboBrush        - Brush object to be used for the text

    pptlBrushOrg    - Brush origin alignment

    OutlineFlags    - specified how to do outline font from FPOLY_xxxx flags

    Rop4            - Rop4 to be used


Return Value:

    TRUE/FALSE


Author:

    18-Feb-1994 Fri 12:41:17 updated  -by-  DC
        Adding the OutlineFlags to specified how to do fill/stroke

    27-Jan-1994 Thu 13:10:34 updated  -by-  DC
        re-write, style update, and arrange codes

    25-Jan-1994 Wed 16:30:08 modified -by-  JB
        Added FONTOBJ as a parameter and now we only FILL truetype fonts,
        all others are stroked

    18-Dec-1993 Sat 10:38:08 created  -by-  DC
        Change style

    [t-kenl]  Mar 14, 93    taken from DrvTextOut()

Revision History:


--*/

{
    GLYPHPOS    *pgp;
    PATHOBJ     *ppo;
    RECTFX      rectfxBound;
    RECTFX      rclfxClip;
    POINTL      ptlCur;
    SIZEL       sizlInc;
    BOOL        MoreGlyphs;
    BOOL        Ok;
    BOOL        FirstCh;
    ULONG       cGlyphs;

    //
    // We will enumerate each of the glyphs in the passed STROBJ and use
    // the core polygon routine (DoPolygon) to draw each of them as a path.
    // If the STROBJ has a non NULL pgp field, then all the data is already
    // available on each gpyph. If not, we need to make a sequence of calls
    // to the engine helper function STROBJ_bEnum in order to enumerate the
    // glyphs. We will use the same code to output the data in both cases.
    //

    if (pClipRect) {

        rclfxClip.xLeft   = LTOFX(pClipRect->left);
        rclfxClip.yTop    = LTOFX(pClipRect->top);
        rclfxClip.xRight  = LTOFX(pClipRect->right);
        rclfxClip.yBottom = LTOFX(pClipRect->bottom);
    }

    if (pstro->pgp) {

        pgp        = pstro->pgp;
        MoreGlyphs = FALSE;
        cGlyphs    = pstro->cGlyphs;

        PLOTDBG(DBG_TRUETYPE, ("OutlineTextOut: Character info already there (%ld glyphs)", cGlyphs));

    } else {

        STROBJ_vEnumStart(pstro);
        MoreGlyphs = TRUE;

        PLOTDBG(DBG_TRUETYPE, ("OutlineTextOut: STROBJ enub"));
    }

    //
    // Now start drawing the glyphs, if we have MoreGlyphs = TRUE  then we
    // will do a STROBJ_bEnum first, in order to load up the Glyph data.
    //
    // Check the fill flags and set the flag appropriately out of the DEVMODE.
    // We will ONLY fill TrueType fonts, all other types (vector) will only be
    // stroked.
    //

    Ok         = TRUE;
    sizlInc.cx =
    sizlInc.cy = 0;
    FirstCh    = TRUE;

    do {

        //
        // Check to see if the job is being aborted, and exit out if such
        // is the case.
        //

        if (PLOT_CANCEL_JOB(pPDev)) {

           break;
        }

        //
        // We need to enum for more glyph data so do it now.
        //

        if (MoreGlyphs) {

            MoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);

            if (MoreGlyphs == DDI_ERROR) {

                PLOTERR(("DrvTextOut: STROBJ_bEnum()=DDI_ERROR"));
                return(FALSE);
            }
        }

        PLOTDBG(DBG_TRUETYPE1,
                ("OutlineTextOut: New batch of cGlyphs=%d", cGlyphs));

        //
        // Stroke each glyph in this batch, then check if there are more.
        // Getting the first character position
        //

        if ((FirstCh) && (cGlyphs)) {

            ptlCur  = pgp->ptl;
            FirstCh = FALSE;
        }

        for ( ; (Ok) && (cGlyphs--); pgp++) {

            #ifdef USERMODE_DRIVER

            GLYPHDATA   gd;
            GLYPHDATA   *pgd;

            #endif // USERMODE_DRIVER

            if (PLOT_CANCEL_JOB(pPDev)) {

                break;
            }

            //
            // Set up to enumerate path
            //

            #ifdef USERMODE_DRIVER

                pgd = &gd;

                if (FONTOBJ_cGetGlyphs(pfo,
                                       FO_PATHOBJ,
                                       1,
                                       &(pgp->hg),
                                       (LPVOID)&pgd) != 1) {

                    PLOTRIP(("OutlineTextOut: FONTOBJ_cGetGlyphs() FAILED"));
                    return(FALSE);
                }

                ppo = pgd->gdf.ppo;

            #else

            ppo = pgp->pgdf->ppo;

            #endif // USERMODE_DRIVER

            //
            // If the clip rect is not null then verify the glyph actually lies
            // within the clipping rect then OUTPUT!!!
            //

            if (pstro->ulCharInc) {

                PLOTDBG(DBG_DEFCHARINC, ("OutlineTextOut: CharInc=(%ld, %ld)->(%ld, %ld), [%ld]",
                                ptlCur.x, ptlCur.y,
                                ptlCur.x + pstro->ulCharInc, ptlCur.y,
                                pstro->ulCharInc));

                sizlInc.cx =
                sizlInc.cy = (LONG)pstro->ulCharInc;


                //
                // Check the text Accelators and adjust accordingly.
                //

                if (!(pstro->flAccel & SO_HORIZONTAL)) {

                    sizlInc.cx = 0;
                }

                if (!(pstro->flAccel & SO_VERTICAL)) {

                    sizlInc.cy = 0;
                }

                if (pstro->flAccel & SO_REVERSED) {

                    sizlInc.cx = -sizlInc.cx;
                    sizlInc.cy = -sizlInc.cy;
                }

                ptlCur.x += sizlInc.cx;
                ptlCur.y += sizlInc.cy;

            } else {

                ptlCur = pgp->ptl;
            }

            if (pClipRect) {

                //
                // Create a rect in correct device space and compare to the
                // clip rect
                //

                PATHOBJ_vGetBounds(ppo, &rectfxBound);

                //
                // Since the glyph positioning is based on the glyph origin
                // transform now to device space, in order to check if the
                // glyph lies inside the current clipping region.
                //

                rectfxBound.xLeft   += LTOFX(ptlCur.x);
                rectfxBound.yTop    += LTOFX(ptlCur.y);
                rectfxBound.xRight  += LTOFX(ptlCur.x);
                rectfxBound.yBottom += LTOFX(ptlCur.y);

                if ((rectfxBound.xLeft   > rclfxClip.xRight)    ||
                    (rectfxBound.xRight  < rclfxClip.xLeft)     ||
                    (rectfxBound.yTop    > rclfxClip.yBottom)   ||
                    (rectfxBound.yBottom < rclfxClip.yTop)) {

                    PLOTDBG(DBG_TRUETYPE1, ("OutlineTextOut: Outside of CLIP, skipping glyph ..."));
                    continue;
                }
            }

            //
            // Utilize the core path building function, taking advantage of
            // its ability to offset the passed PATH by a specific amount.
            //

            if (!(Ok = DoPolygon(pPDev,
                                 &ptlCur,
                                 NULL,
                                 ppo,
                                 pptlBrushOrg,
                                 pboBrush,
                                 pboBrush,
                                 Rop4,
                                 NULL,
                                 OutlineFlags))) {

                PLOTERR(("OutlineTextOut: Failed in DoPolygon(Options=%08lx)",
                                                        OutlineFlags));

                //
                // If we failed to draw it, then try just stroking it, since
                // that won't depend on any polygon constraints used in the
                // target device, and failing DrvStrokePath, won't make the
                // Text output get broken down to any simpler format.
                //

                if ((OutlineFlags & FPOLY_MASK) != FPOLY_STROKE) {

                    //
                    // If we failed then just stroke it
                    //

                    PLOTERR(("OutlineTextOut: Now TRY DoPolygon(FPOLY_STROKE)"));

                    Ok = DoPolygon(pPDev,
                                   &ptlCur,
                                   NULL,
                                   ppo,
                                   pptlBrushOrg,
                                   NULL,
                                   pboBrush,
                                   Rop4,
                                   NULL,
                                   FPOLY_STROKE);
                }
            }

            //
            // Go to next position

            ptlCur.x += sizlInc.cx;
            ptlCur.y += sizlInc.cy;
        }

    } while ((Ok) && (MoreGlyphs));

    return(TRUE);
}





BOOL
DrvTextOut(
    SURFOBJ     *pso,
    STROBJ      *pstro,
    FONTOBJ     *pfo,
    CLIPOBJ     *pco,
    RECTL       *prclExtra,
    RECTL       *prclOpaque,
    BRUSHOBJ    *pboFore,
    BRUSHOBJ    *pboOpaque,
    POINTL      *pptlBrushOrg,
    MIX         mix
    )

/*++

Routine Description:

    The Graphics Engine will call this routine to render a set of glyphs at
    specified positions. This function will review the passed data, and
    image the glyph either as a path to be filled or stroked, or as a bitmap.

Arguments:

    pso         - pointer to our surface object

    pstro       - pointer to the string object

    pfo         - pointer to the font object

    pco         - clipping object

    prclExtra   - pointer to array of rectangles to be merge with glyphs

    prclOpaque  - Pointer to a rectangle to be fill with pboOpaque brush

    pboFore     - pointer to the brush object for the foreground color

    pboOpqaue   - pointer to the brush object for the opaque rectangle

    pptlBrushOrg- Pointer to the brush alignment

    mix         - Two Rop2 mode


Return Value:

    TRUE/FALSE


Author:

    23-Jan-1994 Thu  2:59:31 created  -by-  JB

    27-Jan-1994 Thu 12:56:11 updated  -by-  DC
        Style, re-write, commented

    10-Mar-1994 Thu 00:30:38 updated  -by-  DC
        1. Make sure we not fill the stroke type of font
        2. Move rclOpqaue and rclExtra process out from the do loop, so that
           when it in the RTL mode for the font it will be correctly processed
           and it will also save output data size by not switching in/out
           RTL/HPGL2 mode just try to do the prclOpaque/prclExtra
        3. Process FO_TYPE correctly for all type of fonts (outline, truetype,
           bitmap, vector, stroke and others)

    11-Mar-1994 Fri 19:24:56 updated  -by-  DC
        Bug# 10276, the clipping window is set for the raster font and clear
        clipping window is done before the exit to HPGL2 mode, this causes
        all raster font after the first clip is not visible to end of the
        page.   Now changed it so we only do clipping window when the font is
        NOT RASTER.

Revision History:


--*/

{
#define pDrvHTInfo  ((PDRVHTINFO)(pPDev->pvDrvHTData))


    PPDEV       pPDev;
    PRECTL      pCurClipRect;
    HTENUMRCL   EnumRects;
    DWORD       RTLPalDW[2];
    DWORD       rgbText;
    DWORD       OHTFlags;
    DWORD       OutlineFlags;
    BOOL        DoRasterFont;
    BOOL        bMore;
    BOOL        bDoClipWindow;
    BOOL        Ok;
    DWORD       BMFontRop3;
    ROP4        Rop4;


    //
    // Transform the MIX to ROP4
    //

    Rop4 = MixToRop4(mix);

    PLOTDBG(DBG_TEXTOUT, ("DrvTextOut: prclOpaque       = %08lx", prclOpaque));
    PLOTDBG(DBG_TEXTOUT, ("            prclExtra        = %08lx", prclExtra));
    PLOTDBG(DBG_TEXTOUT, ("            pstro->flAccel   = %08lx", pstro->flAccel));
    PLOTDBG(DBG_TEXTOUT, ("            pstro->ulCharInc = %ld", pstro->ulCharInc));
    PLOTDBG(DBG_TEXTOUT, ("            pfo->cxMax       = %ld", pfo->cxMax));
    PLOTDBG(DBG_TEXTOUT, ("            FontType         = %08lx", pfo->flFontType));
    PLOTDBG(DBG_TEXTOUT, ("            MIX              = %04lx (Rop=%04lx)", mix, Rop4));

    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DoTextOut: Invalid pPDev in pso"));
        return(FALSE);
    }

    if (pPDev->PlotDM.Flags & PDMF_PLOT_ON_THE_FLY) {

        PLOTWARN(("DoTextOut: POSTER Mode IGNORE All Texts"));
        return(TRUE);
    }

    //
    // Since we dont support device fonts, make sure we are not getting one
    // now.
    //

    if (pfo->flFontType & FO_TYPE_DEVICE) {

        PLOTASSERT(1, "DrvTextOut: Getting DEVICE font (%08lx)",
                        !(pfo->flFontType & FO_TYPE_DEVICE ), pfo->flFontType);
        return(FALSE);
    }

    if (DoRasterFont = (BOOL)(pfo->flFontType & FO_TYPE_RASTER)) {

        PLOTDBG(DBG_TEXTOUT1, ("DrvTextOut: We got the BITMAP Font from GDI"));

        //
        // Make pfo = NULL so later we will not try to do FONTOBJ_cGetGlyph in
        // BitmapTextOut
        //

        #ifndef USERMODE_DRIVER

        pfo = NULL;

        #endif // !USERMODE_DRIVER

    } else {

        PIFIMETRICS pifi;

        //
        // Try to find out if we need to fill the font, or just stroke it.
        //

        if ((pifi = FONTOBJ_pifi(pfo)) &&
            (pifi->flInfo & FM_INFO_RETURNS_STROKES)) {

            PLOTDBG(DBG_TEXTOUT1, ("DrvTextOut() Font can only do STROKE"));

            OutlineFlags = FPOLY_STROKE;

        } else {

            PLOTDBG(DBG_TEXTOUT1, ("DrvTextOut() Font We can do FILL, User Said=%hs",
                    (pPDev->PlotDM.Flags & PDMF_FILL_TRUETYPE) ? "FILL" : "STROKE"));

            OutlineFlags = (pPDev->PlotDM.Flags & PDMF_FILL_TRUETYPE) ?
                                (DWORD)FPOLY_FILL : (DWORD)FPOLY_STROKE;
        }
    }

    //
    // Check if we need to opaque the area
    //

    if (prclOpaque) {

        PLOTDBG(DBG_TEXTOUT2, ("prclOpaque=(%ld, %ld) - (%ld, %ld)",
                           prclOpaque->left, prclOpaque->top,
                           prclOpaque->right, prclOpaque->bottom));

        if (!DrvBitBlt(pso,             // Target
                       NULL,            // Source
                       NULL,            // Mask Obj
                       pco,             // Clip Obj
                       NULL,            // XlateOBj
                       prclOpaque,      // Dest Rect Ptr
                       NULL,            // Source Pointl
                       NULL,            // Mask Pointl
                       pboOpaque,       // Brush Obj
                       pptlBrushOrg,    // Brush Origin
                       0xF0F0)) {       // ROP4 (PATCOPY)

            PLOTERR(("DrvTextOut: DrvBitBltBit(pboOpqaue) FAILED!"));
            return(FALSE);
        }
    }

    //
    // We will do prclExtra only if it is not NULL, this simulates the
    // underline or strikeout effects.
    //

    if (prclExtra) {

        //
        // The prclExtra terminated only if all points in rectangle coordinate
        // are all set to zeros
        //

        while ((prclExtra->left)    ||
               (prclExtra->top)     ||
               (prclExtra->right)   ||
               (prclExtra->bottom)) {

            PLOTDBG(DBG_TEXTOUT2, ("prclExtra=(%ld, %ld) - (%ld, %ld)",
                               prclExtra->left, prclExtra->top,
                               prclExtra->right, prclExtra->bottom));

            if (!DrvBitBlt(pso,             // Target
                           NULL,            // Source
                           NULL,            // Mask Obj
                           pco,             // Clip Obj
                           NULL,            // XlateOBj
                           prclExtra,       // Dest Rect Ptr
                           NULL,            // Source Pointl
                           NULL,            // Mask Pointl
                           pboFore,         // Brush Obj
                           pptlBrushOrg,    // Brush Origin
                           Rop4)) {         // ROP4

                PLOTERR(("DrvTextOut: DrvBitBltBit(pboFore) FAILED!"));
                return(FALSE);
            }

            //
            // Now try next EXTRA rectangle
            //

            ++prclExtra;
        }
    }

    //
    // If we are using Raster Font then the mode will be set as following
    //

    if (DoRasterFont) {

        RTLPalDW[0] = pDrvHTInfo->RTLPal[0].dw;
        RTLPalDW[1] = pDrvHTInfo->RTLPal[1].dw;

        //
        // Get the color to use.
        //

        if (!GetColor(pPDev,
                      pboFore,
                      &(pDrvHTInfo->RTLPal[1].dw),
                      NULL,
                      Rop4)) {

            PLOTERR(("DrvTextOut: Get Raster Font Text Color failed! use BLACK"));

            rgbText = 0x0;
        }

        if (pDrvHTInfo->RTLPal[1].dw == 0xFFFFFF) {

            //
            // White Text, our white is 1 and 0=black, so do:"not S and D"
            //

            PLOTDBG(DBG_BMPTEXTCLR, ("DrvTextOut: Doing WHITE TEXT (0xEEEE)"));

            pDrvHTInfo->RTLPal[0].dw = 0x0;
            OHTFlags                 = 0;
            BMFontRop3               = 0xEE;                // S | D

        } else {

            pDrvHTInfo->RTLPal[0].dw = 0xFFFFFF;
            OHTFlags                 = OHTF_SET_TR1;
            BMFontRop3               = 0xCC;                // S
        }

        PLOTDBG(DBG_BMPTEXTCLR,
                ("DrvTextOut: BG=%02x:%02x:%02x, FG=%02x:%02x:%02x, Rop3=%04lx",
                        (DWORD)pDrvHTInfo->RTLPal[0].Pal.R,
                        (DWORD)pDrvHTInfo->RTLPal[0].Pal.G,
                        (DWORD)pDrvHTInfo->RTLPal[0].Pal.B,
                        (DWORD)pDrvHTInfo->RTLPal[1].Pal.R,
                        (DWORD)pDrvHTInfo->RTLPal[1].Pal.G,
                        (DWORD)pDrvHTInfo->RTLPal[1].Pal.B,
                        BMFontRop3));

        //
        // We do not need clip window command in RTL mode
        //

        bDoClipWindow = FALSE;

    } else {

        bDoClipWindow = TRUE;
    }

    bMore       = FALSE;
    Ok          = TRUE;
    EnumRects.c = 1;

    if ((!pco) || (pco->iDComplexity == DC_TRIVIAL)) {

        //
        // The whole output destination rectangle is visible
        //

        PLOTDBG(DBG_TEXTOUT, ("DrvTextOut: pco=%hs",
                                            (pco) ? "DC_TRIVIAL" : "NULL"));

        EnumRects.rcl[0] = pstro->rclBkGround;
        bDoClipWindow    = FALSE;

    } else if (pco->iDComplexity == DC_RECT) {

        //
        // The visible area is one rectangle intersect with the destinaiton
        //

        PLOTDBG(DBG_TEXTOUT, ("DrvTextOut: pco=DC_RECT"));

        EnumRects.rcl[0] = pco->rclBounds;

    } else {

        //
        // We have complex clipping region to be computed, call engine to start
        // enumerating the rectangles and set More = TRUE so we can get the
        // first batch of rectangles.
        //

        PLOTDBG(DBG_TEXTOUT, ("DrvTextOut: pco=DC_COMPLEX, EnumRects now"));

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        bMore = TRUE;
    }

    do {

        //
        // If More is true then we need to get next batch of rectangles. In
        // this mode, we have a set of rectangles that represents the
        // clipping region in the target device. Since none of the devices
        // we handle can acommodate a complex clipping path, we enumerate the
        // cliping path (CLIPOBJ) as rectangles and image the entire STROBJ
        // through these rectangles, trying to determine as quickly as possible
        // when a glyph does not lie in the current clipping rect.
        //

        if (bMore) {

            bMore = CLIPOBJ_bEnum(pco, sizeof(EnumRects), (ULONG *)&EnumRects);
        }

        //
        // prcl will point to the first enumerated rectangle, which may just
        // be the RECT of the clipping area if its DC_RECT.
        //

        pCurClipRect = (PRECTL)&EnumRects.rcl[0];

        while ((Ok) && (EnumRects.c--)) {

            PLOTDBG(DBG_TEXTOUT, ("DrvTextOut: Clip=(%ld, %ld)-(%ld, %ld) %ld x %ld, Bound=(%ld, %d)-(%ld, %ld), %ld x %ld",
                         pCurClipRect->left, pCurClipRect->top,
                         pCurClipRect->right, pCurClipRect->bottom,
                         pCurClipRect->right - pCurClipRect->left,
                         pCurClipRect->bottom - pCurClipRect->top,
                         pstro->rclBkGround.left, pstro->rclBkGround.top,
                         pstro->rclBkGround.right, pstro->rclBkGround.bottom,
                         pstro->rclBkGround.right - pstro->rclBkGround.left,
                         pstro->rclBkGround.bottom - pstro->rclBkGround.top));

            //
            // If we will output the STROBJ as bitmaps that represent the
            // glyphs of the STROBJ, do it now.
            //

            if (DoRasterFont) {

                if (!(Ok = BitmapTextOut(pPDev,
                                         pstro,
                                         pfo,
                                         pCurClipRect,
                                         &OHTFlags,
                                         BMFontRop3))) {

                    PLOTERR(("DrvTextOut: BitmapTypeTextOut() FAILED"));
                    break;
                }

            } else {

                //
                // If we have a clip window, set it now, this will allow
                // the target device to do any clipping
                //

                if (bDoClipWindow) {

                    SetClipWindow(pPDev, pCurClipRect);
                }

                if (!(Ok = OutlineTextOut(pPDev,
                                          pstro,
                                          pfo,
                                          pCurClipRect,
                                          pboFore,
                                          pptlBrushOrg,
                                          OutlineFlags,
                                          Rop4))) {

                    PLOTERR(("DrvTextOut: TrueTypeTextOut() FAILED!"));
                    break;
                }
            }

            //
            // Goto next clip rectangle
            //

            pCurClipRect++;
        }

    } while ((Ok) && (bMore));


    if (DoRasterFont) {

        pDrvHTInfo->RTLPal[0].dw = RTLPalDW[0];
        pDrvHTInfo->RTLPal[1].dw = RTLPalDW[1];

        if (OHTFlags & OHTF_MASK) {

            OHTFlags |= OHTF_EXIT_TO_HPGL2;

            OutputHTBitmap(pPDev, NULL, NULL, NULL, NULL, 0xAA, &OHTFlags);
        }
    }

    //
    // If we had set a clip window now is the time to clear it after exit from
    // RTL Mode
    //

    if (bDoClipWindow) {

        ClearClipWindow(pPDev);
    }

    return(Ok);


#undef  pDrvHTInfo
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotter\transpos.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    transpos.h


Abstract:

    This module contains defines and prototypes for the transpos.c module.


Author:

    22-Dec-1993 Wed 15:49:08 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/



#ifndef _TRANSPOS_
#define _TRANSPOS_


typedef struct _TPINFO {
    PPDEV   pPDev;
    LPBYTE  pSrc;
    LPBYTE  pDest;
    LONG    cbSrcScan;
    LONG    cbDestScan;
    DWORD   cySrc;
    DWORD   DestXStart;
    } TPINFO, *PTPINFO;


#define _RL_TPI(pTPInfo, cScan)                                         \
{                                                                       \
    pTPInfo->pDest      += (pTPInfo->cbDestScan * cScan)                \
    pTPInfo->cbDestScan  = -pTBInfo->cbDestScan;                        \
    pTPInfo->pSrc       += (pTPInfo->cbSrcScan * (pTPInfo->cySrc - 1)); \
    pTPInfo->cbSrcScan   = -pTBInfo->cbSrcScan;                         \
}

#define ROTLEFT_8BPP_TPINFO(pTPInfo)    _RL_TPI((pTPInfo), 0)
#define ROTLEFT_4BPP_TPINFO(pTPInfo)    _RL_TPI((pTPInfo), 1)
#define ROTLEFT_1BPP_TPINFO(pTPInfo)    _RL_TPI((pTPInfo), 7)



//
// Function prototypes exported by transpos.c
//

BOOL
TransPos8BPP(
    PTPINFO pTPInfo
    );

BOOL
TransPos4BPP(
    PTPINFO pTPInfo
    );

BOOL
TransPos1BPP(
    PTPINFO pTPInfo
    );



#endif  // _TRANSPOS_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\cpsui.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    cpsui.h


Abstract:

    This module contains defines for cpsui.c


Author:

    03-Nov-1995 Fri 13:44:30 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/



typedef struct _EXTRAINFO {
    DWORD   Size;
    LPBYTE  pData;
    } EXTRAINFO, *PEXTRAINFO;

BOOL
CreateOPTTYPE(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData,
    UINT            cLBCBItem,
    PEXTRAINFO      pExtraInfo
    );

POPTITEM
FindOptItem(
    POPTITEM    pOptItem,
    UINT        cOptItem,
    BYTE        DMPubID
    );

LONG
CallCommonPropertySheetUI(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );

LONG
DefCommonUIFunc(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam,
    PPRINTERINFO        pPI,
    LONG_PTR            lData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\cpsui.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    cpsui.c


Abstract:

    This module contains helper functions to be used with common UI


Author:

    03-Nov-1995 Fri 13:24:41 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgCPSUI


DEFINE_DBGVAR(0);


#define SIZE_OPTTYPE(cOP)   (sizeof(OPTPARAM) + ((cOP) * sizeof(OPTPARAM)))

extern HMODULE  hPlotUIModule;

static BYTE cTVOP[] = { 2,3,2,3,3,0,0,2,1,1 };

OPDATA  OPNoYes[] = {

            { 0, IDS_CPSUI_NO,  IDI_CPSUI_OFF,  0,  0, 0  },
            { 0, IDS_CPSUI_YES, IDI_CPSUI_ON,   0,  0, 0  }
        };

static const CHAR szCompstui[] = "compstui.dll";



BOOL
CreateOPTTYPE(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData,
    UINT            cLBCBItem,
    PEXTRAINFO      pExtraInfo
    )

/*++

Routine Description:

    This fucntion allocate memory and initialized field for OPTTYPE/OPTPARAM



Arguments:

    pOptItem    - Pointer to OPTITEM data structure

    pOIData     - Pointer to the OIDATA structure


Return Value:




Author:

    03-Nov-1995 Fri 13:25:54 created  -by-  DC


Revision History:


--*/

{
    LPBYTE      pbData = NULL;
    UINT        cOP;
    DWORD       cbOP;
    DWORD       cbECB;
    DWORD       cbExtra;
    DWORD       cbAlloc;
    BYTE        Type;
    DWORD       Flags;


    Flags = pOIData->Flags;

    ZeroMemory(pOptItem, sizeof(OPTITEM));

    pOptItem->cbSize    = sizeof(OPTITEM);
    pOptItem->Level     = pOIData->Level;
    pOptItem->Flags     = (Flags & ODF_CALLBACK) ? OPTIF_CALLBACK : 0;

    if (Flags & ODF_COLLAPSE) {

        pOptItem->Flags |= OPTIF_COLLAPSE;
    }

    pOptItem->pName     = (LPTSTR)pOIData->IDSName;
    pOptItem->HelpIndex = (DWORD)pOIData->HelpIdx;
    pOptItem->DMPubID   = pOIData->DMPubID;

    if ((Type = pOIData->Type) >= sizeof(cTVOP)) {

        pOptItem->Sel = (LONG)pOIData->IconID;
        cOP           = 0;

    } else if (!(cOP = cTVOP[Type])) {

        cOP = cLBCBItem;
    }

    cbOP    = (cOP) ? SIZE_OPTTYPE(cOP) : 0;
    cbECB   = (Flags & ODF_ECB) ? sizeof(EXTCHKBOX) : 0;
    cbExtra = (pExtraInfo) ? pExtraInfo->Size : 0;

    if (cbAlloc = cbOP + cbECB + cbExtra) {

        if (pbData = (LPBYTE)LocalAlloc(LPTR, cbAlloc)) {

            POPDATA pOPData;

            pOPData = (pOIData->Flags & ODF_CALLCREATEOI) ? NULL :
                                                            pOIData->pOPData;

            pOptItem->UserData = (DWORD_PTR)pbData;

            if (cbECB) {

                PEXTCHKBOX  pECB;

                pOptItem->pExtChkBox  =
                pECB                  = (PEXTCHKBOX)pbData;
                pbData               += cbECB;
                pECB->cbSize          = sizeof(EXTCHKBOX);

                if (pOPData) {

                    pECB->Flags           = pOPData->Flags;
                    pECB->pTitle          = (LPTSTR)pOPData->IDSName;
                    pECB->IconID          = (DWORD)pOPData->IconID;
                    pECB->pSeparator      = (LPTSTR)pOPData->IDSSeparator;
                    pECB->pCheckedName    = (LPTSTR)pOPData->IDSCheckedName;
                    pOPData++;
                }
            }

            if (cbOP) {

                POPTTYPE    pOptType;
                POPTPARAM   pOP;
                UINT        i;


                pOptType  = (POPTTYPE)pbData;
                pbData   += cbOP;

                //
                // Initialize the OPTITEM
                //

                pOptItem->pOptType = pOptType;

                //
                // Initialize the OPTTYPE
                //

                pOptType->cbSize    = sizeof(OPTTYPE);
                pOptType->Type      = (BYTE)Type;
                pOptType->Count     = (WORD)cOP;
                pOP                 =
                pOptType->pOptParam = (POPTPARAM)(pOptType + 1);
                pOptType->Style     = pOIData->Style;

                for (i = 0; i < cOP; i++, pOP++) {

                    pOP->cbSize = sizeof(OPTPARAM);

                    if (pOPData) {

                        pOP->Flags  = (BYTE)(pOPData->Flags & 0xFF);
                        pOP->Style  = (BYTE)(pOPData->Style & 0xFF);
                        pOP->pData  = (LPTSTR)pOPData->IDSName;
                        pOP->IconID = (DWORD)pOPData->IconID;
                        pOP->lParam = (LONG)pOPData->sParam;

                        if (Type == TVOT_PUSHBUTTON) {

                            (DWORD_PTR)(pOP->pData) += (DWORD_PTR)pPI;

                        } else {

                            if (Flags & ODF_INC_IDSNAME) {

                                (DWORD_PTR)(pOP->pData) += i;
                            }

                            if (Flags & ODF_INC_ICONID) {

                                (DWORD)(pOP->IconID) += i;
                            }
                        }

                        if (!(Flags & ODF_NO_INC_POPDATA)) {

                            pOPData++;
                        }
                    }
                }
            }

            if (pExtraInfo) {

                pExtraInfo->pData = (cbExtra) ? pbData : 0;
            }

        } else {

            PLOTERR(("CreateOPTTYPE: LocalAlloc%ld) failed", cbAlloc));
            return(FALSE);
        }
    }

    return(TRUE);
}




POPTITEM
FindOptItem(
    POPTITEM        pOptItem,
    UINT            cOptItem,
    BYTE            DMPubID
    )

/*++

Routine Description:

    This function return the first occurence of the DMPubID


Arguments:




Return Value:




Author:

    16-Nov-1995 Thu 21:01:26 created  -by-  DC


Revision History:


--*/

{
    while (cOptItem--) {

        if (pOptItem->DMPubID == DMPubID) {

            return(pOptItem);
        }

        pOptItem++;
    }

    PLOTWARN(("FindOptItem: Cannot Find DMPubID=%u", (UINT)DMPubID));

    return(NULL);

}




LONG
CallCommonPropertySheetUI(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    )

/*++

Routine Description:

    This function dymically load the compstui.dll and call its entry


Arguments:

    pfnPropSheetUI  - Pointer to callback function

    lParam          - lParam for the pfnPropSheetUI

    pResult         - pResult for the CommonPropertySheetUI


Return Value:

    LONG    - as describe in compstui.h


Author:

    01-Nov-1995 Wed 13:11:19 created  -by-  DC


Revision History:


--*/

{
    HINSTANCE           hInstCompstui;
    FARPROC             pProc;
    LONG                Result = ERR_CPSUI_GETLASTERROR;
    static const CHAR   szCommonPropertySheetUI[] = "CommonPropertySheetUIW";


    //
    // ONLY need to call the ANSI version of LoadLibrary
    //


    if ((hInstCompstui = LoadLibraryA(szCompstui)) &&
        (pProc = GetProcAddress(hInstCompstui, szCommonPropertySheetUI))) {

        Result = (LONG) (*pProc)(hWndOwner, pfnPropSheetUI, lParam, pResult);
    }

    if (hInstCompstui) {

        FreeLibrary(hInstCompstui);
    }

    return(Result);
}



LONG
DefCommonUIFunc(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam,
    PPRINTERINFO        pPI,
    LONG_PTR            lData
    )

/*++

Routine Description:

    This is the default processing function for DocumentPropertySheet() and
    PrinterPropertySheet()


Arguments:

    pPSUIInfo   - From the original pfnPropSheetUI(pPSUIInfo, lParam)

    lParam      - From the original pfnPropSheetUI(pPSUIInfo, lParam)

    pPI         - Pointer to our instance data

    lData       - Extra data based on the pPSUIInfo->Reason


Return Value:

    LONG    Result to be return back from the pfnPropSheetUI()


Author:

    05-Feb-1996 Mon 17:47:51 created  -by-  DC


Revision History:


--*/

{
    PPROPSHEETUI_INFO_HEADER    pPSUIInfoHdr;
    LONG                        Result = -1;


    if (pPI) {

        switch (pPSUIInfo->Reason) {

        case PROPSHEETUI_REASON_INIT:

            //
            // Default result
            //

            pPSUIInfo->Result   = CPSUI_CANCEL;
            pPSUIInfo->UserData = (DWORD_PTR)pPI;

            //
            // the lData is the return value from the SetupDPOptItems() or
            // SetupPPOptItems()
            //

            if (lData) {

                PCOMPROPSHEETUI pCPSUI = pPI->pCPSUI;


                pCPSUI->cbSize         = sizeof(COMPROPSHEETUI);
                pCPSUI->hInstCaller    = (HINSTANCE)hPlotUIModule;
                pCPSUI->pCallerName    = (LPTSTR)IDS_PLOTTER_DRIVER;
                pCPSUI->UserData       = (DWORD_PTR)pPI;
                pCPSUI->pHelpFile      = pPI->pHelpFile;
                pCPSUI->IconID         = GetPlotterIconID(pPI);
                pCPSUI->pOptItemName   = pPI->PlotDM.dm.dmDeviceName;
                pCPSUI->CallerVersion  = DRIVER_VERSION;
                pCPSUI->OptItemVersion = (WORD)pPI->pPlotGPC->Version;
                pCPSUI->pOptItem       = pPI->pOptItem;
                pCPSUI->cOptItem       = pPI->cOptItem;

                if (pPI->Flags & PIF_UPDATE_PERMISSION) {

                    pCPSUI->Flags |= CPSUIF_UPDATE_PERMISSION;
                }

                if (pPI->hCPSUI = (HANDLE)
                        pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                                                   CPSFUNC_ADD_PCOMPROPSHEETUI,
                                                   (LPARAM)pCPSUI,
                                                   (LPARAM)&lData)) {

                    Result = 1;
                }
            }

            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:

            if (pPSUIInfoHdr = (PPROPSHEETUI_INFO_HEADER)lParam) {

                pPSUIInfoHdr->Flags      = (PSUIHDRF_PROPTITLE |
                                            PSUIHDRF_NOAPPLYNOW);
                pPSUIInfoHdr->pTitle     = (LPTSTR)lData;
                pPSUIInfoHdr->hInst      = (HINSTANCE)hPlotUIModule;
                pPSUIInfoHdr->IconID     = pPI->pCPSUI->IconID;

                Result = 1;
            }

            break;

        case PROPSHEETUI_REASON_SET_RESULT:

            //
            // Save the result and also set the result to the caller.
            //

            if (pPI->hCPSUI == ((PSETRESULT_INFO)lParam)->hSetResult) {

                pPSUIInfo->Result = ((PSETRESULT_INFO)lParam)->Result;
                Result = 1;
            }

            break;

        case PROPSHEETUI_REASON_DESTROY:

            UnMapPrinter(pPI);
            pPSUIInfo->UserData = 0;
            Result              = 1;
            break;

        }
    }

    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\devcaps.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    devcaps.c


Abstract:

    This module contains API function DrvDeviceCapabilities and other support
    functions


Author:

    02-Dec-1993 Thu 16:49:08 created  -by-  DC

    22-Mar-1994 Tue 13:00:04 updated  -by-  DC
        Update RESOLUTION caps so it return as not supported, this way the
        application will not used to setup the DMRES_xxx fields


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgDevCaps

extern HMODULE  hPlotUIModule;




#define DBG_DEVCAPS_0       0x00000001
#define DBG_DEVCAPS_1       0x00000002

DEFINE_DBGVAR(0);


//
// Local defines only used in this module
//
// The following sizes are copied from the Win 3.1 driver.  They do not appear
// to be defined in any public place,  although it looks like they should be.
//

#define CCHBINNAME          24      // Characters allowed for bin names
#define CCHPAPERNAME        64      // Max length of paper size names
#define DC_SPL_PAPERNAMES   0xFFFF
#define DC_SPL_MEDIAREADY   0xFFFE


#ifdef DBG

LPSTR   pDCCaps[] = {

            "FIELDS",
            "PAPERS",
            "PAPERSIZE",
            "MINEXTENT",
            "MAXEXTENT",
            "BINS",
            "DUPLEX",
            "SIZE",
            "EXTRA",
            "VERSION",
            "DRIVER",
            "BINNAMES",
            "ENUMRESOLUTIONS",
            "FILEDEPENDENCIES",
            "TRUETYPE",
            "PAPERNAMES",
            "ORIENTATION",
            "COPIES",

            //
            // 4.00
            //

            "BINADJUST",
            "EMF_COMPLIANT",
            "DATATYPE_PRODUCED",
            "COLLATE",
            "MANUFACTURER",
            "MODEL",

            //
            // 5.00
            //

            "PERSONALITY",
            "PRINTRATE",
            "PRINTRATEUNIT",
            "PRINTERMEM",
            "MEDIAREADY",
            "STAPLE",
            "PRINTRATEPPM",
            "COLORDEVICE",
            "NUP",
            "NULL"
        };

#endif





INT
CALLBACK
DevCapEnumFormProc(
    PFORM_INFO_1       pFI1,
    DWORD              Index,
    PENUMFORMPARAM     pEFP
    )

/*++

Routine Description:

    This is callback function from PlotEnumForm()

Arguments:

    pFI1    - pointer to the current FORM_INFO_1 data structure passed

    Index   - pFI1 index related to the pFI1Base (0 based)

    pEFP    - Pointer to the EnumFormParam


Return Value:

    > 0: Continue enumerate the next
    = 0: Stop enumerate, but keep the pFI1Base when return from PlotEnumForms
    < 0: Stop enumerate, and free pFI1Base memory

    the form enumerate will only the one has FI1F_VALID_SIZE bit set in the
    flag field, it also call one more time with pFI1 NULL to give the callback
    function a chance to free the memory (by return < 0)

Author:

    03-Dec-1993 Fri 23:00:25 created  -by-  DC

    27-Jan-1994 Thu 16:06:00 updated  -by-  DC
        Fixed the pptOutput which we did not increment the pointer

    12-Jul-1994 Tue 12:47:22 updated  -by-  DC
        Move paper tray checking into the PlotEnumForms() itselft


Revision History:


--*/

{
#define pwOutput    ((WORD *)pEFP->pCurForm)
#define pptOutput   ((POINT *)pEFP->pCurForm)
#define pwchOutput  ((WCHAR *)pEFP->pCurForm)
#define DeviceCap   (pEFP->ReqIndex)


    if (!pwOutput) {

        PLOTASSERT(0, "DevCapEnumFormProc(DevCaps=%ld) pvOutput=NULL",
                        pwOutput, DeviceCap);
        return(0);
    }

    if (!pFI1) {

        //
        // extra call, or no pvOutput, return a -1 to free memory for pFI1Base
        // We want to add the custom paper size so that application know we
        // supports that
        //

        switch (DeviceCap) {

        case DC_PAPERNAMES:

            LoadString(hPlotUIModule,
                       IDS_USERFORM,
                       pwchOutput,
                       CCHPAPERNAME);

            PLOTDBG(DBG_DEVCAPS_1, ("!!! Extra FormName = %s", pwchOutput));

            break;

        case DC_PAPERS:

            *pwOutput = (WORD)DMPAPER_USER;

            PLOTDBG(DBG_DEVCAPS_1, ("!!! Extra FormID = %ld", *pwOutput));

            break;

        case DC_PAPERSIZE:

            //
            // I'm not sure we should return POINT or POINTS structure here, what
            // is Window 3.1 do, because at here we return as dmPaperWidth and
            // dmPaperLength, these fields only as a SHORT (16 bits), we will do
            // win32 documentation said, POINT (32-bit version)
            //
            //
            // Return custom paper sizes as 8.5" x 11"
            //

            pptOutput->x = (LONG)2159;
            pptOutput->y = (LONG)2794;

            PLOTDBG(DBG_DEVCAPS_1, ("!!! Extra FormSize = %ld x %ld",
                        pptOutput->x, pptOutput->y));

            break;
        }

        return(-1);
    }

    switch (DeviceCap) {

    case DC_PAPERNAMES:
    case DC_MEDIAREADY:

        _WCPYSTR(pwchOutput, pFI1->pName, CCHPAPERNAME);
        pwchOutput += CCHPAPERNAME;
        break;

    case DC_PAPERS:

        *pwOutput++ = (WORD)(Index + DMPAPER_FIRST);
        break;

    case DC_PAPERSIZE:

        //
        // I'm not sure we should return POINT or POINTS structure here, what
        // is Window 3.1 do, because at here we return as dmPaperWidth and
        // dmPaperLength, these fields only as a SHORT (16 bits), we will do
        // win32 documentation said, POINT (32-bit version)
        //

        pptOutput->x = (LONG)SPLTODM(pFI1->Size.cx);
        pptOutput->y = (LONG)SPLTODM(pFI1->Size.cy);
        pptOutput++;
        break;
    }

    return(1);

#undef DeviceCap
#undef pwOutput
#undef pptOutput
#undef pwchOutput
}



DWORD
WINAPI
DrvDeviceCapabilities(
    HANDLE  hPrinter,
    LPWSTR  pwDeviceName,
    WORD    DeviceCap,
    VOID    *pvOutput,
    DEVMODE *pDM
    )

/*++

Routine Description:




Arguments:

    hPrinter        - handle the to specific printer.

    pwDeviceName    - pointer to the device name

    DeviceCap       - specific capability to get.

    pvOutput        - Pointer to the output buffer

    pDM             - Ponter to the input DEVMODE


Return Value:

    DWORD   depends on the DeviceCap


Author:

    02-Dec-1993 Thu 16:50:36 created  -by-  DC

    05-Jan-1994 Wed 23:35:19 updated  -by-  DC
        Replace PLOTTER_UNIT_DPI with pPlotGPC->PlotXDPI, pPlotGPC->PlotYDPI,

    06-Jan-1994 Thu 13:10:11 updated  -by-  DC
        Change RasterDPI always be the resoluton reports back to the apps


Revision History:


--*/

{
#define pbOutput    ((BYTE *)pvOutput)
#define psOutput    ((SHORT *)pvOutput)
#define pwOutput    ((WORD *)pvOutput)
#define pptOutput   ((POINT *)pvOutput)
#define pwchOutput  ((WCHAR *)pvOutput)
#define pdwOutput   ((DWORD *)pvOutput)
#define plOutput    ((LONG *)pvOutput)
#define pptsdwRet   ((POINTS *)&dwRet)


    PPRINTERINFO    pPI;
    ENUMFORMPARAM   EnumFormParam;
    DWORD           dwRet;


    //
    // The MapPrinter will allocate memory, set default devmode, reading and
    // validating the GPC then update from current pritner registry, it also
    // will cached the PlotGPC.
    //

    if (!(pPI = MapPrinter(hPrinter,
                           (PPLOTDEVMODE)pDM,
                           NULL,
                           (DeviceCap == DC_MEDIAREADY) ?
                                            MPF_DEVICEDATA : 0))) {

        PLOTERR(("DrvDeviceCapabilities: MapPrinter() failed"));
        return(GDI_ERROR);
    }

    //
    // Start checking DeviceCap now, set dwRet to 0 first for anything we do
    // not support.  We can do return() at any point in this function because
    // we use cached PI, and it will get destroy when the this module
    // get unloaded.
    //

    EnumFormParam.cMaxOut = 0x7FFFFFFF;
    dwRet                 = 0;

    switch (DeviceCap) {

    case DC_BINNAMES:
    case DC_BINS:

        //
        // For current plotter, it always only have ONE bin
        //

        if (pvOutput) {

            if (DeviceCap == DC_BINS) {

                *pwOutput = DMBIN_ONLYONE;

            } else {

                if (pPI->pPlotGPC->Flags & PLOTF_ROLLFEED) {

                    dwRet = IDS_ROLLFEED;

                } else {

                    dwRet = IDS_MAINFEED;
                }

                LoadString(hPlotUIModule, dwRet, pwchOutput, CCHBINNAME);
            }
        }

        dwRet = 1;

        break;

    case DC_COPIES:

        dwRet = (DWORD)pPI->pPlotGPC->MaxCopies;

        break;

    case DC_DRIVER:

        dwRet = (DWORD)pPI->PlotDM.dm.dmDriverVersion;

        break;

    case DC_COLLATE:
    case DC_DUPLEX:

        //
        // plotter now have no duplex support or collation support
        //

        break;

    case DC_ENUMRESOLUTIONS:

        //
        // We only have one resolution setting which will be RasterXDPI and
        // RasterYDPI in the GPC data for the raster able plotter, for pen
        // plotter now we returned pPlotGPC->PlotXDPI, pPlotGPC->PlotYDPI
        //
        // The RasterDPI will be used for raster printer resolution, for pen
        // plotter this is the GPC's ideal resolution
        //
        //
        // We will return not supported (dwRet=0) so that application will not
        // use this to set the DEVMODE's print quality and use the DMRES_XXXX
        // as print qualities which is use by us to send to the plotter
        //

        //
        // 26-Mar-1999 Fri 09:43:38 updated  -by-  Daniel Chou (danielc)
        //  We will return one pair of current PlotXDPI, PlotYDPI for DS
        //

        if (pdwOutput) {

            if (pPI->pPlotGPC->Flags & PLOTF_RASTER) {

                pdwOutput[0] = (DWORD)pPI->pPlotGPC->RasterXDPI;
                pdwOutput[1] = (DWORD)pPI->pPlotGPC->RasterYDPI;

            } else {

                pdwOutput[0] = (DWORD)pPI->pPlotGPC->PlotXDPI;
                pdwOutput[1] = (DWORD)pPI->pPlotGPC->PlotYDPI;
            }
        }

        dwRet = 1;
        break;

    case DC_EXTRA:

        dwRet = (DWORD)pPI->PlotDM.dm.dmDriverExtra;
        break;

    case DC_FIELDS:

        dwRet = (DWORD)pPI->PlotDM.dm.dmFields;
        break;

    case DC_FILEDEPENDENCIES:

        //
        // we are supposed to fill in an array of 64 character filenames,
        // this will include the DataFileName, HelpFileName and UIFileName
        // but, if we are to be of any use, we would need to use the
        // fully qualified pathnames, and 64 characters is probably not
        // enough

        if (pwchOutput) {

            *pwchOutput = (WCHAR)0;
        }

        break;

    case DC_MAXEXTENT:

        //
        // This is real problem, the document said that we return a POINT
        // structure but a POINT structure here contains 2 LONGs, so for
        // Windows 3.1 compatibility reason we return a POINTS structure, if device have
        // variable length paper support then return 0x7fff as Window 3.1
        // because a maximum positive number in POINTS is 0x7fff, this number
        // will actually only allowed us to support the paper length up to
        // 10.75 feet.
        //

        pptsdwRet->x = SPLTODM(pPI->pPlotGPC->DeviceSize.cx);

        if (pPI->pPlotGPC->DeviceSize.cy >= 3276700) {

            pptsdwRet->y = 0x7fff;      // 10.75" maximum.

        } else {

            pptsdwRet->y = SPLTODM(pPI->pPlotGPC->DeviceSize.cy);
        }

        break;

    case DC_MINEXTENT:

        //
        // This is real problem, the document said that we return a POINT
        // structure but a POINT structure here contains 2 LONGs, so for Win3.1
        // compatibility reason we return a POINTS structure
        //

        pptsdwRet->x = MIN_DM_FORM_CX;
        pptsdwRet->y = MIN_DM_FORM_CY;

        break;

    case DC_ORIENTATION:

        //
        // We always rotate the page to the left 90 degree from the user's
        // perspective
        //

        dwRet = 90;

        break;


    case DC_SPL_PAPERNAMES:

        if (!pvOutput) {

            PLOTERR(("DrvDeviceCapabilities: Spool's DC_PAPERNAMES, pvOutput=NULL"));
            dwRet = (DWORD)GDI_ERROR;
            break;
        }

        EnumFormParam.cMaxOut = pdwOutput[0];
        DeviceCap             = DC_PAPERNAMES;

        //
        // Fall through
        //

    case DC_PAPERNAMES:
    case DC_PAPERS:
    case DC_PAPERSIZE:

        //
        // One of the problem here is we can cached the FORM_INFO_1 which
        // enum through spooler, because in between calls the data could
        // changed, such as someone add/delete form through the printman, so
        // at here we always free (LocalAlloc() used in PlotEnumForms) the
        // memory afterward
        //

        EnumFormParam.pPlotDM  = &(pPI->PlotDM);
        EnumFormParam.pPlotGPC = pPI->pPlotGPC;
        EnumFormParam.ReqIndex = DeviceCap;
        EnumFormParam.pCurForm = (PFORMSIZE)pvOutput;

        if (!PlotEnumForms(hPrinter, DevCapEnumFormProc, &EnumFormParam)) {

            PLOTERR(("DrvDeviceCapabilities: PlotEnumForms() failed"));
            dwRet = GDI_ERROR;

        } else {

            dwRet = EnumFormParam.ValidCount;
        }

        break;

    case DC_SIZE:

        dwRet = (DWORD)pPI->PlotDM.dm.dmSize;

        break;

    case DC_TRUETYPE:

        //
        // For now we do not return anything, because we draw truetype font
        // as truetype (ie. line/curve segment), if we eventually doing ATM or
        // bitmap truetype download then we will return DCFF_BITMAP but for
        // now return 0
        //

        break;

    case DC_VERSION:

        dwRet = (DWORD)pPI->PlotDM.dm.dmSpecVersion;

        break;

    case DC_PERSONALITY:

        if (pwchOutput) {

            _WCPYSTR(pwchOutput, L"HP-GL/2", 32);
        }

        dwRet = 1;
        break;

    case DC_COLORDEVICE:

        dwRet = (pPI->pPlotGPC->Flags & PLOTF_COLOR) ? 1 : 0;
        break;

    case DC_SPL_MEDIAREADY:

        if (!pwchOutput) {

            PLOTERR(("DrvDeviceCapabilities: Spool's DC_MEDIAREADY, pwchOutput=NULL"));
            dwRet = (DWORD)GDI_ERROR;
            break;
        }

        EnumFormParam.cMaxOut = pdwOutput[0];

        //
        // Fall through for DC_MEDIAREADY
        //

    case DC_MEDIAREADY:

        PLOTDBG(DBG_DEVCAPS_0,
                ("DevCaps(DC_MEDIAREADY:pvOut=%p): CurPaper=%ws, %ldx%ld",
                        pwchOutput, pPI->CurPaper.Name,
                        pPI->CurPaper.Size.cx, pPI->CurPaper.Size.cy));

        if (pPI->CurPaper.Size.cy) {

            //
            // Non Roll Paper
            //

            dwRet = 1;

            if (pwchOutput) {

                if (EnumFormParam.cMaxOut >= 1) {

                    _WCPYSTR(pwchOutput, pPI->CurPaper.Name, CCHPAPERNAME);

                } else {

                    dwRet = 0;
                }
            }

        } else {

            //
            // Roll Paper Installed
            //

            EnumFormParam.pPlotDM  = &(pPI->PlotDM);
            EnumFormParam.pPlotGPC = pPI->pPlotGPC;
            EnumFormParam.ReqIndex = DC_MEDIAREADY;
            EnumFormParam.pCurForm = (PFORMSIZE)pvOutput;

            if (!PlotEnumForms(hPrinter, DevCapEnumFormProc, &EnumFormParam)) {

                PLOTERR(("DrvDeviceCapabilities: PlotEnumForms() failed"));
                dwRet = GDI_ERROR;

            } else {

                //
                // Remove Custom paper size
                //

                dwRet = EnumFormParam.ValidCount - 1;
            }
        }

        break;

    case DC_STAPLE:
    case DC_NUP:

        break;

    default:

        //
        // something is wrong here
        //

        PLOTERR(("DrvDeviceCapabilities: Invalid DeviceCap (%ld) passed.",
                                                                    DeviceCap));
        dwRet = (DWORD)GDI_ERROR;
    }

    PLOTDBG(DBG_DEVCAPS_0,
            ("DrvDeviceCapabilities: DC_%hs, pvOut=%p, dwRet=%ld",
                        pDCCaps[DeviceCap-1], (DWORD_PTR)pvOutput, dwRet));

    UnMapPrinter(pPI);

    return(dwRet);


#undef pbOutput
#undef psOutput
#undef pwOutput
#undef pptOutput
#undef pwchOutput
#undef pdwOutput
#undef plOutput
#undef pptsdwRet
}

//
// @@BEGIN_DDKSPLIT
//
// This entry point maybe is obsolete and I do not want to remove it since
// postscript and unidrv drivers still keep this private function. But I 
// will not put it in the DDK.
//
//                              lzhu 12-13-2000
//


DWORD
DrvSplDeviceCaps(
    HANDLE  hPrinter,
    LPWSTR  pwDeviceName,
    WORD    DeviceCap,
    VOID    *pvOutput,
    DWORD   cchBuf,
    DEVMODE *pDM
    )

/*++

Routine Description:

    This function support the querrying of device capabilities
    It gets the binary data (UIINFO) from the parser and return
    the requested capability to the caller.

Arguments:

    hPrinter        - handle the to specific printer.

    pwDeviceName    - pointer to the device name

    DeviceCap       - specific capability to get.

    pvOutput        - Pointer to the output buffer

    cchBuf          - Count of character for the pvOutput

    pDM             - Ponter to the input DEVMODE


Return Value:

    DWORD   depends on the DeviceCap


Author:

    20-May-1999 Thu 17:48:42 updated  -by-  Daniel Chou (danielc)
        For spooler special private call only for DC_PAPERNAMES


Revision History:


Return Value:
    The capabilities supported and relevant information in pOutput

--*/

{

    switch (DeviceCap) {

    case DC_PAPERNAMES:
    case DC_MEDIAREADY:

        if (pvOutput) {

            if (cchBuf >= CCHPAPERNAME) {

                DeviceCap            = (DeviceCap == DC_PAPERNAMES) ?
                                                            DC_SPL_PAPERNAMES :
                                                            DC_SPL_MEDIAREADY;
                *((LPDWORD)pvOutput) = (DWORD)(cchBuf / CCHPAPERNAME);

                PLOTDBG(DBG_DEVCAPS_0,
                        ("SplDeviceCap: DC_SPL_MEDIAREADY, cchBuf=%ld (%ld)",
                            cchBuf, *((LPDWORD)pvOutput)));

            } else {

                return(GDI_ERROR);
            }
        }

        return(DrvDeviceCapabilities(hPrinter,
                                     pwDeviceName,
                                     DeviceCap,
                                     pvOutput,
                                     pDM));
        break;

    default:

        return(GDI_ERROR);
    }

}

//
// @@END_DDKSPLIT
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\formbox.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    formbox.h


Abstract:

    This module contains FORM's COMBO box add/list/retrieve functions


Author:

    09-Dec-1993 Thu 16:07:35 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _LISTFORM_
#define _LISTFORM_


#define FS_ROLLPAPER    1
#define FS_TRAYPAPER    2

BOOL
GetFormSelect(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem
    );

UINT
CreateFormOI(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData
    );

BOOL
AddFormsToDataBase(
    PPRINTERINFO    pPI,
    BOOL            DeleteFirst
    );

#endif  // _LISTFORM_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\help.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    help.h


Abstract:

    This module contains all plotter help related function prototypes and
    defines


Author:

    06-Dec-1993 Mon 15:33:23 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTUI_HELP_
#define _PLOTUI_HELP

LPWSTR
GetPlotHelpFile(
    PPRINTERINFO    pPI
    );

INT
cdecl
PlotUIMsgBox(
    HWND    hWnd,
    LONG    IDString,
    LONG    Style,
    ...
    );

#endif  _PLOTUI_HELP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\help.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    help.c


Abstract:

    This module contains all help functions for the plotter user interface


Author:

    06-Dec-1993 Mon 14:25:45 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

    31-Jan-1994 Mon 09:47:56 updated  -by-  DC
        Change help file location from the system32 directory to the current
        plotui.dll directory


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgHelp


extern HMODULE  hPlotUIModule;


#define DBG_SHOW_HELP       0x00000001

DEFINE_DBGVAR(0);


#define MAX_HELPFILE_NAME   64
#define MAX_IDS_STR_LEN     160
#define cbWSTR(wstr)        ((wcslen(wstr) + 1) * sizeof(WCHAR))



LPWSTR
GetPlotHelpFile(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:

    This function setup the directory path for the driver Help file

Arguments:

    hPrinter    - Handle to the printer

Return Value:

    LPWSTR to the full path HelpFile, NULL if failed

Author:

    01-Nov-1995 Wed 18:43:40 created  -by-  DC


Revision History:


--*/

{
    PDRIVER_INFO_3  pDI3 = NULL;
    LPWSTR          pHelpFile = NULL;
    WCHAR           HelpFileName[MAX_HELPFILE_NAME];
    DWORD           cb;
    DWORD           cb2;


    if (pPI->pHelpFile) {

        return(pPI->pHelpFile);
    }

    if ((!GetPrinterDriver(pPI->hPrinter, NULL, 3, NULL, 0, &cb))           &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)                       &&
        (pDI3 = (PDRIVER_INFO_3)LocalAlloc(LMEM_FIXED, cb))                 &&
        (GetPrinterDriver(pPI->hPrinter, NULL, 3, (LPBYTE)pDI3, cb, &cb))   &&
        (pDI3->pHelpFile)                                                   &&
        (pHelpFile = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                        cbWSTR(pDI3->pHelpFile)))) {

        wcscpy(pHelpFile, (LPWSTR)pDI3->pHelpFile);

    } else if ((cb2 = LoadString(hPlotUIModule,
                                 IDS_HELP_FILENAME,
                                 &HelpFileName[1],
                                 COUNT_ARRAY(HelpFileName) - 1))            &&
               (cb2 = (cb2 + 1) * sizeof(WCHAR))                            &&
               (!GetPrinterDriverDirectory(NULL, NULL, 1, NULL, 0, &cb))    &&
               (GetLastError() == ERROR_INSUFFICIENT_BUFFER)                &&
               (pHelpFile = (LPWSTR)LocalAlloc(LMEM_FIXED, cb + cb2))       &&
               (GetPrinterDriverDirectory(NULL,
                                          NULL,
                                          1,
                                          (LPBYTE)pHelpFile,
                                          cb,
                                          &cb))) {

        HelpFileName[0] = L'\\';
        wcscat(pHelpFile, HelpFileName);

    } else if (pHelpFile) {

        LocalFree(pHelpFile);
        pHelpFile = NULL;
    }

    if (pDI3) {

        LocalFree((HLOCAL)pDI3);
    }

    PLOTDBG(DBG_SHOW_HELP, ("GetlotHelpFile: '%ws",
                                        (pHelpFile) ? pHelpFile : L"Failed"));

    return(pPI->pHelpFile = pHelpFile);
}




INT
cdecl
PlotUIMsgBox(
    HWND    hWnd,
    LONG    IDString,
    LONG    Style,
    ...
    )

/*++

Routine Description:

    This function pop up a simple message and let user to press key to
    continue

Arguments:

    hWnd        - Handle to the caller window

    IDString    - String ID to be output with

    ...         - Parameter

Return Value:




Author:

    06-Dec-1993 Mon 21:31:41 created  -by-  DC


Revision History:

    24-Jul-2000 Mon 12:18:12 updated  -by-  Daniel Chou (danielc)
        Fix for someone's change due to the fact that NULL character is not
        counted for the string


--*/

{
    va_list vaList;
    LPWSTR  pwTitle;
    LPWSTR  pwFormat;
    LPWSTR  pwMessage;
    INT     i;
    INT     MBRet = IDCANCEL;

    //
    // We assume that UNICODE flag is turn on for the compilation, bug the
    // format string passed to here is ASCII version, so we need to convert
    // it to LPWSTR before the wvsprintf()
    //
    // 24-Jul-2000 Mon 13:17:13 updated  -by-  Daniel Chou (danielc)
    //  1 MAX_IDS_STR_LEN for pwTitle,
    //  1 MAX_IDS_STR_LEN for pwFormat
    //  2 MAX_IDS_STR_LEN for pwMessage (wvsprintf)
    //

    if (!(pwTitle = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                       sizeof(WCHAR) * MAX_IDS_STR_LEN * 4))) {

        return(0);
    }

    if (i = LoadString(hPlotUIModule,
                       IDS_PLOTTER_DRIVER,
                       pwTitle,
                       MAX_IDS_STR_LEN - 1)) {

        pwFormat = pwTitle + i + 1;

        if (i = LoadString(hPlotUIModule,
                           IDString,
                           pwFormat,
                           MAX_IDS_STR_LEN - 1)) {

            pwMessage = pwFormat + i + 1;

            va_start(vaList, Style);
            wvsprintf(pwMessage, pwFormat, vaList);
            va_end(vaList);

            MBRet = MessageBox(hWnd, pwMessage, pwTitle, MB_APPLMODAL | Style);
        }
    }


    LocalFree((HLOCAL)pwTitle);

    return(MBRet);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\docprop.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    docprop.c


Abstract:

    This module contains functions for DrvDocumentPropertySheets


Author:

    07-Dec-1993 Tue 12:15:40 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


#define DBG_PLOTFILENAME    DbgDocProp


extern HMODULE  hPlotUIModule;


#define DBG_DP_SETUP        0x00000001
#define DBG_DP_FORM         0x00000002
#define DBG_HELP            0x00000004

DEFINE_DBGVAR(0);



OPDATA  OPOrientation[] = {

            { 0, IDS_CPSUI_PORTRAIT,  IDI_CPSUI_PORTRAIT,  0, 0, 0   },
            { 0, IDS_CPSUI_LANDSCAPE, IDI_CPSUI_LANDSCAPE, 0, 0, 0   }
        };

OPDATA  OPColor[] = {

            { 0, IDS_CPSUI_MONOCHROME, IDI_CPSUI_MONO,  0, 0, 0   },
            { 0, IDS_CPSUI_COLOR,      IDI_CPSUI_COLOR, 0, 0, 0   }
        };

OPDATA  OPCopyCollate[] = {

            { 0, IDS_CPSUI_COPIES, IDI_CPSUI_COPY, 0, 0,   0 },
            { 0, 0,                1,              0, 0, 100 }
        };

OPDATA  OPScaling[] = {

            { 0, IDS_CPSUI_PERCENT, IDI_CPSUI_SCALING, 0, 0,   0 },
            { 0, 0,                 1,                 0, 0, 100 }
        };

OPDATA  OPPrintQuality[] = {

            { 0, IDS_QUALITY_DRAFT,  IDI_CPSUI_RES_DRAFT,        0, 0, -1 },
            { 0, IDS_QUALITY_LOW,    IDI_CPSUI_RES_LOW,          0, 0, -2 },
            { 0, IDS_QUALITY_MEDIUM, IDI_CPSUI_RES_MEDIUM,       0, 0, -3 },
            { 0, IDS_QUALITY_HIGH,   IDI_CPSUI_RES_PRESENTATION, 0, 0, -4 }
        };

OPDATA  OPHTClrAdj = {

            0,
            PI_OFF(PlotDM) + PLOTDM_OFF(ca),
            IDI_CPSUI_HTCLRADJ,
            PUSHBUTTON_TYPE_HTCLRADJ,
            0,
            0
        };


extern OPDATA  OPNoYes[];

OPDATA  OPFillTrueType[] = {

            { 0, IDS_CPSUI_NO,  IDI_FILL_TRUETYPE_NO,  0,  0, 0  },
            { 0, IDS_CPSUI_YES, IDI_FILL_TRUETYPE_YES, 0,  0, 0  }
        };


OIDATA  DPOIData[] = {

    {
        ODF_PEN_RASTER | ODF_CALLCREATEOI,
        0,
        OI_LEVEL_1,
        DMPUB_FORMNAME,
        TVOT_LISTBOX,
        IDS_CPSUI_FORMNAME,
        0,
        IDH_FORMNAME,
        0,
        (POPDATA)CreateFormOI
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        DMPUB_ORIENTATION,
        TVOT_2STATES,
        IDS_CPSUI_ORIENTATION,
        0,
        IDH_ORIENTATION,
        COUNT_ARRAY(OPOrientation),
        OPOrientation
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        DMPUB_COPIES_COLLATE,
        TVOT_UDARROW,
        IDS_CPSUI_NUM_OF_COPIES,
        0,
        IDH_COPIES_COLLATE,
        COUNT_ARRAY(OPCopyCollate),
        OPCopyCollate
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        DMPUB_PRINTQUALITY,
        TVOT_LISTBOX,
        IDS_CPSUI_PRINTQUALITY,
        0,
        IDH_PRINTQUALITY,
        COUNT_ARRAY(OPPrintQuality),
        OPPrintQuality
    },

    {
        ODF_RASTER | ODF_COLOR,
        0,
        OI_LEVEL_1,
        DMPUB_COLOR,
        TVOT_2STATES,
        IDS_CPSUI_COLOR_APPERANCE,
        0,
        IDH_COLOR,
        COUNT_ARRAY(OPColor),
        OPColor
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        DMPUB_SCALE,
        TVOT_UDARROW,
        IDS_CPSUI_SCALING,
        0,
        IDH_SCALE,
        COUNT_ARRAY(OPScaling),
        OPScaling
    },

    {
        ODF_RASTER,
        0,
        OI_LEVEL_1,
        DP_HTCLRADJ,
        TVOT_PUSHBUTTON,
        IDS_CPSUI_HTCLRADJ,
        OTS_PUSH_ENABLE_ALWAYS,
        IDH_HTCLRADJ,
        1,
        &OPHTClrAdj
    },

    {
        ODF_PEN,
        0,
        OI_LEVEL_1,
        DP_FILL_TRUETYPE,
        TVOT_2STATES,
        IDS_FILL_TRUETYPE,
        0,
        IDH_FILL_TRUETYPE,
        2,
        OPFillTrueType
    },

    {
        ODF_RASTER,
        0,
        OI_LEVEL_1,
        DP_QUICK_POSTER_MODE,
        TVOT_2STATES,
        IDS_POSTER_MODE,
        0,
        IDH_POSTER_MODE,
        2,
        OPNoYes
    }
};



UINT
SetupDPOptItems(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    16-Nov-1995 Thu 14:15:25 created  -by-  DC


Revision History:


--*/

{
    PPLOTDEVMODE    pPlotDM;
    PPLOTGPC        pPlotGPC;
    POPTITEM        pOptItem;
    POPTITEM        pOI;
    POIDATA         pOIData;
    DWORD           Flags;
    DWORD           ODFlags;
    UINT            i;



    pOI      =
    pOptItem = pPI->pOptItem;
    pOIData  = DPOIData;
    i        = (UINT)COUNT_ARRAY(DPOIData);
    pPlotGPC = pPI->pPlotGPC;
    pPlotDM  = &(pPI->PlotDM);
    Flags    = pPlotGPC->Flags;
    ODFlags  = (Flags & PLOTF_RASTER) ? ODF_RASTER : ODF_PEN;

    while (i--) {

        DWORD   OIFlags = pOIData->Flags;


        switch (pOIData->DMPubID) {

        case DMPUB_COPIES_COLLATE:

            if (pPlotGPC->MaxCopies <= 1) {

                OIFlags = 0;
            }

            break;

        case DMPUB_SCALE:

            if (!pPlotGPC->MaxScale) {

                OIFlags = 0;
            }

            break;
        }

        if ((!(OIFlags & ODFlags))                                      ||
            ((OIFlags & ODF_ROLLFEED) && (!(Flags & PLOTF_ROLLFEED)))   ||
            ((OIFlags & ODF_NO_PAPERTRAY) && (Flags & PLOTF_PAPERTRAY)) ||
            ((OIFlags & ODF_COLOR) && (!(Flags & PLOTF_COLOR)))) {

            //
            // Nothing to do here
            //

            NULL;

        } else if (OIFlags & ODF_CALLCREATEOI) {

            pOI += pOIData->pfnCreateOI(pPI,
                                        (LPVOID)((pOptItem) ? pOI : NULL),
                                        pOIData);

        } else if (pOptItem) {

            if (CreateOPTTYPE(pPI, pOI, pOIData, pOIData->cOPData, NULL)) {

                POPTPARAM   pOP = pOI->pOptType->pOptParam;

                switch (pOI->DMPubID) {

                case DMPUB_ORIENTATION:

                    pOI->Sel = (LONG)((pPlotDM->dm.dmOrientation ==
                                                DMORIENT_PORTRAIT) ? 0 : 1);
                    break;

                case DMPUB_COPIES_COLLATE:

                    pOP[1].lParam = (LONG)pPlotGPC->MaxCopies;
                    pOI->Sel      = (LONG)pPlotDM->dm.dmCopies;
                    break;

                case DMPUB_PRINTQUALITY:

                    switch (pPlotGPC->MaxQuality) {

                    case 0:
                    case 1:

                        pPlotDM->dm.dmPrintQuality = DMRES_HIGH;
                        pOP[0].Flags |= OPTPF_HIDE;

                    case 2:

                        pOP[2].Flags |= OPTPF_HIDE;

                    case 3:

                        pOP[1].Flags |= OPTPF_HIDE;
                        break;

                    default:

                        break;
                    }

                    pOI->Sel = (LONG)-(pPlotDM->dm.dmPrintQuality -
                                                                DMRES_DRAFT);
                    break;

                case DMPUB_COLOR:

                    pOI->Sel = (LONG)((pPlotDM->dm.dmColor == DMCOLOR_COLOR) ?
                                                1 : 0);
                    break;

                case DMPUB_SCALE:

                    pOP[1].lParam = (LONG)pPlotGPC->MaxScale;
                    pOI->Sel      = (LONG)pPlotDM->dm.dmScale;
                    break;

                case DP_FILL_TRUETYPE:

                    pOI->Sel = (LONG)((pPlotDM->Flags & PDMF_FILL_TRUETYPE) ?
                                                                        1 : 0);
                    break;


                case DP_QUICK_POSTER_MODE:

                    pOI->Sel = (LONG)((pPlotDM->Flags & PDMF_PLOT_ON_THE_FLY) ?
                                                                        1 : 0);
                    break;
                }

                pOI++;
            }

        } else {

            pOI++;
        }

        pOIData++;
    }

    if ((i = (UINT)(pOI - pOptItem)) && (!pOptItem)) {

        if (pPI->pOptItem = (POPTITEM)LocalAlloc(LPTR, sizeof(OPTITEM) * i)) {

            pPI->cOptItem = (WORD)i;

            //
            // Call myself second time to really create it
            //

            SetupDPOptItems(pPI);

        } else {

            i = 0;

            PLOTERR(("GetPPpOptItem(): LocalAlloc(%ld) failed",
                                            sizeof(OPTITEM) * i));
        }
    }

    return(i);
}



VOID
SaveDPOptItems(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:

    This function save all the device options back to registry if one changed
    and has a update permission


Arguments:

    pPI     - Pointer to the PRINTERINFO


Return Value:

    VOID


Author:

    06-Nov-1995 Mon 18:05:16 created  -by-  DC


Revision History:


--*/

{
    POPTITEM        pOI;
    POPTITEM        pLastItem;
    PPLOTDEVMODE    pPlotDM;
    BYTE            DMPubID;


    pOI       = pPI->pOptItem;
    pLastItem = pOI + pPI->cOptItem - 1;
    pPlotDM   = &(pPI->PlotDM);

    while (pOI <= pLastItem) {

        if (pOI->Flags & OPTIF_CHANGEONCE) {

            switch (pOI->DMPubID) {

            case DMPUB_FORMNAME:

                GetFormSelect(pPI, pOI);
                break;

            case DMPUB_ORIENTATION:

                pPlotDM->dm.dmOrientation = (SHORT)((pOI->Sel) ?
                                                        DMORIENT_LANDSCAPE :
                                                        DMORIENT_PORTRAIT);
                break;

            case DMPUB_COPIES_COLLATE:

                pPlotDM->dm.dmCopies = (SHORT)pOI->Sel;
                break;

            case DMPUB_PRINTQUALITY:

                pPlotDM->dm.dmPrintQuality = (SHORT)(-(pOI->Sel) + DMRES_DRAFT);
                break;

            case DMPUB_COLOR:

                pPlotDM->dm.dmColor = (SHORT)((pOI->Sel) ? DMCOLOR_COLOR :
                                                           DMCOLOR_MONOCHROME);
                break;

            case DMPUB_SCALE:

                pPlotDM->dm.dmScale = (SHORT)pOI->Sel;
                break;

            case DP_FILL_TRUETYPE:

                if (pOI->Sel) {

                    pPlotDM->Flags |= PDMF_FILL_TRUETYPE;

                } else {

                    pPlotDM->Flags &= ~PDMF_FILL_TRUETYPE;
                }

                break;

            case DP_QUICK_POSTER_MODE:

                if (pOI->Sel) {

                    pPlotDM->Flags |= PDMF_PLOT_ON_THE_FLY;

                } else {

                    pPlotDM->Flags &= ~PDMF_PLOT_ON_THE_FLY;
                }

                break;
            }
        }

        pOI++;
    }
}




CPSUICALLBACK
DPCallBack(
    PCPSUICBPARAM   pCPSUICBParam
    )

/*++

Routine Description:

    This is the callback function from the common property sheet UI


Arguments:

    pCPSUICBParam   - Pointer to the CPSUICBPARAM data structure to describe
                      the nature of the callback


Return Value:

    LONG


Author:

    07-Nov-1995 Tue 15:15:02 created  -by-  DC


Revision History:


--*/

{
    POPTITEM    pCurItem = pCPSUICBParam->pCurItem;
    LONG        Action = CPSUICB_ACTION_NONE;

    if (pCPSUICBParam->Reason == CPSUICB_REASON_APPLYNOW) {

        PPRINTERINFO    pPI = (PPRINTERINFO)pCPSUICBParam->UserData;

        if ((pPI->Flags & PIF_UPDATE_PERMISSION) &&
            (pPI->pPlotDMOut)) {

            SaveDPOptItems(pPI);

            PLOTDBG(DBG_DP_SETUP, ("APPLYNOW: ConvertDevmodeOut"));

            ConvertDevmodeOut((PDEVMODE)&(pPI->PlotDM),
                              (PDEVMODE)pPI->pPlotDMIn,
                              (PDEVMODE)pPI->pPlotDMOut);

            pCPSUICBParam->Result = CPSUI_OK;
            Action                = CPSUICB_ACTION_ITEMS_APPLIED;
        }
    }

    return(Action);
}




BOOL
DrvConvertDevMode(
    LPTSTR      pPrinterName,
    PDEVMODE    pDMIn,
    PDEVMODE    pDMOut,
    PLONG       pcbNeeded,
    DWORD       fMode
    )

/*++

Routine Description:

    This function is used by the SetPrinter() and GetPrinter() spooler calls.

Arguments:

    pPrinterName    - Points to printer name string

    pDMIn           - Points to the input devmode

    pDMOut          - Points to the output devmode buffer

    pcbNeeded       - Specifies the size of output buffer on input On output,
                      this is the size of output devmode

    fMode           - Specifies what function to perform


Return Value:

    TRUE if successful
    FALSE otherwise and an error code is logged

Author:

    08-Jan-1996 Mon 12:40:22 created  -by-  DC


Revision History:


--*/

{
    DWORD                       cb;
    INT                         Result;
    static DRIVER_VERSION_INFO  PlotDMVersions = {

        DRIVER_VERSION, PLOTDM_PRIV_SIZE,   // current version/size
        0x0350,         PLOTDM_PRIV_SIZE,   // NT3.51 version/size
    };

    //
    // Call a library routine to handle the common cases
    //

    Result = CommonDrvConvertDevmode(pPrinterName,
                                     pDMIn,
                                     pDMOut,
                                     pcbNeeded,
                                     fMode,
                                     &PlotDMVersions);

    //
    // If not handled by the library routine, we only need to worry
    // about the case when fMode is CDM_DRIVER_DEFAULT
    //

    if ((Result == CDM_RESULT_NOT_HANDLED)  &&
        (fMode == CDM_DRIVER_DEFAULT)) {

        HANDLE  hPrinter;

        if (OpenPrinter(pPrinterName, &hPrinter, NULL)) {

            PPLOTGPC    pPlotGPC;

            if (pPlotGPC = hPrinterToPlotGPC(hPrinter, pDMOut->dmDeviceName)) {

                SetDefaultPLOTDM(hPrinter,
                                 pPlotGPC,
                                 pDMOut->dmDeviceName,
                                 (PPLOTDEVMODE)pDMOut,
                                 NULL);

                UnGetCachedPlotGPC(pPlotGPC);
                Result = CDM_RESULT_TRUE;

            } else {

                PLOTERR(("DrvConvertDevMode: hPrinterToPlotGPC(%ws) failed.",
                                                                pPrinterName));

                SetLastError(ERROR_INVALID_DATA);
            }

            ClosePrinter(hPrinter);

        } else {

            PLOTERR(("DrvConvertDevMode: OpenPrinter(%ws) failed.",
                                                            pPrinterName));
            SetLastError(ERROR_INVALID_DATA);
        }
    }

    return(Result == CDM_RESULT_TRUE);
}



LONG
DrvDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    Show document property dialog box and update the output DEVMODE


Arguments:

    pPSUIInfo   - Pointer to the PROPSHEETUI_INFO data structure

    lParam      - LPARAM for this call, it is a pointer to the
                  DOCUMENTPROPERTYHEADER

Return Value:

    LONG, 1=successful, 0=failed.


Author:

    02-Feb-1996 Fri 10:47:42 created  -by-  DC


Revision History:


--*/

{
    PDOCUMENTPROPERTYHEADER     pDPHdr;
    PPRINTERINFO                pPI;
    LONG_PTR                    Result;


    if (pPSUIInfo) {

        if (!(pDPHdr = (PDOCUMENTPROPERTYHEADER)pPSUIInfo->lParamInit)) {

            PLOTERR(("DrvDocumentPropertySheets: Pass a NULL lParamInit"));
            return(-1);
        }

    } else {

        if (pDPHdr = (PDOCUMENTPROPERTYHEADER)lParam) {

            //
            // Assume faild first
            //

            Result = -1;

            //
            // We do not have pPSUIInfo, so that we assume this is call
            // directly from the spooler and lParam is the pDPHdr
            //

            if ((pDPHdr->fMode == 0) || (pDPHdr->pdmOut == NULL)) {

                Result = (pDPHdr->cbOut = sizeof(PLOTDEVMODE));

            } else if ((pDPHdr->fMode & (DM_COPY | DM_UPDATE))  &&
                       (!(pDPHdr->fMode & DM_NOPERMISSION))     &&
                       (pDPHdr->pdmOut)) {
                //
                // The MapPrinter will allocate memory, set default devmode,
                // reading and validating the GPC then update from current pritner
                // registry, it also will cached the pPI.
                //

                if (pPI = MapPrinter(pDPHdr->hPrinter,
                                     (PPLOTDEVMODE)pDPHdr->pdmIn,
                                     NULL,
                                     0)) {

                    ConvertDevmodeOut((PDEVMODE)&(pPI->PlotDM),
                                      (PDEVMODE)pDPHdr->pdmIn,
                                      (PDEVMODE)pDPHdr->pdmOut);

                    Result = 1;
                    UnMapPrinter(pPI);

                } else {

                    PLOTRIP(("DrvDocumentPropertySheets: MapPrinter() failed"));
                }

            } else {

                Result = 1;
            }

        } else {

            PLOTRIP(("DrvDocumentPropertySheets: ??? pDPHdr (lParam) = NULL"));
        }

        return((LONG)Result);
    }

    //
    // Now, this is the call from common UI, assume error to start with
    //

    if (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT) {

        if (!(pPI = MapPrinter(pDPHdr->hPrinter,
                               (PPLOTDEVMODE)pDPHdr->pdmIn,
                               NULL,
                               MPF_HELPFILE | MPF_PCPSUI))) {

            PLOTRIP(("DrvDocumentPropertySheets: MapPrinter() failed"));

            SetLastError(ERROR_INVALID_DATA);
            return(ERR_CPSUI_GETLASTERROR);
        }

        if ((pDPHdr->fMode & (DM_COPY | DM_UPDATE))  &&
            (!(pDPHdr->fMode & DM_NOPERMISSION))     &&
            (pDPHdr->pdmOut)) {

            pPI->Flags      = (PIF_DOCPROP | PIF_UPDATE_PERMISSION);
            pPI->pPlotDMOut = (PPLOTDEVMODE)pDPHdr->pdmOut;

        } else {

            pPI->Flags      = PIF_DOCPROP;
            pPI->pPlotDMOut = NULL;
        }

        //
        // We need to display something to let user modify/update, we wll check
        // which document properties dialog box to be used
        //
        // The return value either IDOK or IDCANCEL
        //

        pPI->pCPSUI->Flags       = 0;
        pPI->pCPSUI->pfnCallBack = DPCallBack;
        pPI->pCPSUI->pDlgPage    = (pDPHdr->fMode & DM_ADVANCED) ?
                                                 CPSUI_PDLGPAGE_ADVDOCPROP :
                                                 CPSUI_PDLGPAGE_DOCPROP;

        Result = (LONG_PTR)SetupDPOptItems(pPI);

    } else {

        pPI    = (PPRINTERINFO)pPSUIInfo->UserData;
        Result = (LONG_PTR)pDPHdr->pszPrinterName;
    }

    return(DefCommonUIFunc(pPSUIInfo, lParam, pPI, Result));
}


// @@BEGIN_DDKSPLIT
// DrvDocumentProperties() and DrvAdvancedDocumentProperties()
// are obsolete, but we keep them here for old application which
// might be using these. But, we don't want these in the DDK samples.


LONG
DrvDocumentProperties(
    HWND            hWnd,
    HANDLE          hPrinter,
    LPWSTR          pwDeviceName,
    PPLOTDEVMODE    pDMOut,
    PPLOTDEVMODE    pDMIn,
    DWORD           fMode
    )

/*++

Routine Description:

    DrvDocumentProperties sets the public members of a PLOTDEVMODE structure
    for the given print document.

Arguments:

    hWnd            - Identifies the parent window of the printer-configuration
                      dialog box.

    hPrinter        - Identifies a printer object.

    pwDeviceName    - Points to a zero-terminated string that specifies the
                      name of the device for which the printer-configuration
                      dialog box should be displayed.

    pDMOut          - Points to a PLOTDEVMODE structure that initializes the
                      dialog box controls. NULL forces the use of the default
                      values.

    pDMIn           - Points to a PLOTDEVMODE structure that receives the
                      printer configuration data specified by the user.

    fMode           - Specifies a mask of values that determines which
                      operations the function performs. If this parameter is
                      zero, DrvDocumentProperties returns the number of bytes
                      required by the printer driver's PLOTDEVMODE structure.
                      Otherwise, use one or more of the following constants to
                      construct a value for this parameter; note, however, that
                      in order to change the print settings, an application
                      must specify at least one input value and one output
                      value:


            Value           Meaning
            ------------------------------------------------------------------

            DM_IN_BUFFER    Input value. Before prompting, copying, or updating,
            (DM_MODIFY)     the function merges the printer driver's current
                            print settings with the settings in the PLOTDEVMODE
                            specified by the pDMIn parameter. The structure
                            is updated only for those members specified by the
                            PLOTDEVMODE structure's dmFields member.  This
                            value is also defined as DM_MODIFY.

            DM_IN_PROMPT    Input value. The function presents the print
            (DM_PROMPT)     driver's Print Setup dialog box, then change the
                            settings in the printer's PLOTDEVMODE structure to
                            the values specified by the user.  This value is
                            also defined as DM_PROMPT.

            DM_OUT_BUFFER   Output value. The function writes the printer
            (DM_COPY)       driver's current print settings, including private
                            data, to the PLOTDEVMODE structure specified by
                            pDMOut. The caller must allocate a buffer large
                            enough to contain the information. If the bit
                            DM_OUT_BUFFER is clear, pDMOut can be NULL. This
                            value is also defined as DM_COPY.


Return Value:

    If fMode is zero, the return value is the size of the buffer (in bytes)
    required to contain the printer driver initialization data. Note that this
    buffer will generally be larger than the PLOTDEVMODE structure if the
    printer driver appends private data to the structure.  If the function
    displays the initialization dialog box, the return value is either IDOK or
    IDCANCEL, depending on which button the user selects.

    If the function does not display the dialog box and is successful, the
    return value is IDOK.  If the function fails, the return value is less than
    zero.

    In order to change print settings that are local to an application, the
    application should:

    * Call with fMode = 0 to get the size of DM_OUT_BUFFER.

    * Modify the returned PLOTDEVMODE structure.

    * Pass the modified PLOTDEVMODE back by calling DrvDocumentProperties,
      specifying both DM_IN_BUFFER and DM_OUT_BUFFER.


Author:

    15-Dec-1993 Wed 15:07:01 updated  -by-  DC
        it seems that spooler never passed a DM_MODIFY to the driver, and that
        caused we never merge the input devmode, we will assume that user has
        valid DM_IN_BUFFER/DM_MODIFY bit set if the pDMIn is not a NULL
        pointer.

    07-Dec-1993 Tue 12:19:47 created  -by-  DC


Revision History:


--*/

{
    DOCUMENTPROPERTYHEADER  DPHdr;
    LONG                    Result;


    DPHdr.cbSize         = sizeof(DPHdr);
    DPHdr.Reserved       = 0;
    DPHdr.hPrinter       = hPrinter;
    DPHdr.pszPrinterName = pwDeviceName;
    DPHdr.pdmIn          = (PDEVMODE)pDMIn;
    DPHdr.pdmOut         = (PDEVMODE)pDMOut;
    DPHdr.cbOut          = sizeof(PLOTDEVMODE);
    DPHdr.fMode          = fMode;

    PLOTDBG(DBG_DP_SETUP, ("DocProp: fMode=%08lx, %ws%ws%ws%ws",
                    fMode,
                    (INT_PTR)((fMode & DM_UPDATE) ? L"DM_UPDATE " : L""),
                    (INT_PTR)((fMode & DM_COPY  ) ? L"DM_COPY " : L""),
                    (INT_PTR)((fMode & DM_PROMPT) ? L"DM_PROMPT " : L""),
                    (INT_PTR)((fMode & DM_MODIFY) ? L"DM_MODIFY " : L"")));

    if (fMode & DM_PROMPT) {

        Result = CPSUI_CANCEL;

        if (CallCommonPropertySheetUI(hWnd,
                                      DrvDocumentPropertySheets,
                                      (LPARAM)&DPHdr,
                                      (LPDWORD)&Result) < 0) {

            Result = CPSUI_CANCEL;
        }

        PLOTDBG(DBG_DP_SETUP, ("Result=%hs",
                (Result == CPSUI_OK) ? "IDOK" : "IDCANCEL"));

        return((Result == CPSUI_OK) ? IDOK : IDCANCEL);

    } else {

        return(DrvDocumentPropertySheets(NULL, (LPARAM)&DPHdr));
    }
}




LONG
DrvAdvancedDocumentProperties(
    HWND            hWnd,
    HANDLE          hPrinter,
    LPWSTR          pwDeviceName,
    PPLOTDEVMODE    pDMOut,
    PPLOTDEVMODE    pDMIn
    )

/*++

Routine Description:

    DrvAdvancedDocumentProperties sets the public members of a PLOTDEVMODE
    structure for the given print document.

Arguments:

    hWnd            - Identifies the parent window of the printer-configuration
                      dialog box.

    hPrinter        - Identifies a printer object.

    pwDeviceName    - Points to a zero-terminated string that specifies the
                      name of the device for which the printer-configuration
                      dialog box should be displayed.

    pDMOut          - Points to a PLOTDEVMODE structure that initializes the
                      dialog box controls. NULL forces the use of the default
                      values.

    pDMIn           - Points to a PLOTDEVMODE structure that receives the
                      printer configuration data specified by the user.


Return Value:

    LONG value depends on the dilaog box outcome eiterh IDOK or IDCANCEL, if
    an error occurred then a negative number is returned


Author:

    07-Dec-1993 Tue 12:19:47 created  -by-  DC


Revision History:


--*/

{
    return((DrvDocumentProperties(hWnd,
                                  hPrinter,
                                  pwDeviceName,
                                  pDMOut,
                                  pDMIn,
                                  DM_PROMPT         |
                                    DM_MODIFY       |
                                    DM_COPY         |
                                    DM_ADVANCED) == CPSUI_OK) ? 1 : 0);
}

// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\pensetup.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    pensetup.h


Abstract:

    This module contains definitions for pen setup


Author:

    09-Dec-1993 Thu 19:38:33 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PENSETUP_
#define _PENSETUP_

POPTITEM
SavePenSet(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem
    );

UINT
CreatePenSetupOI(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData
    );

#endif  // _PENSETUP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\pensetup.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    pensetup.c


Abstract:

    This module contains modules to setup the pen


Author:

    09-Dec-1993 Thu 19:38:19 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPenSetup


extern HMODULE  hPlotUIModule;


#define DBG_PENSETUP        0x00000001
#define DBG_HELP            0x00000002
#define DBG_COLOR_CHG       0x00000004
#define DBG_THICK_CHG       0x00000008

DEFINE_DBGVAR(0);

//
//  Installed Pen Set: <Pen Set #1>
//  Pen Setup:
//      Pen Set #1: <Currently Installed>
//          Pen Number 1:
//          Pen Number 2:
//          Pen Number 3:
//          Pen Number 4:
//          Pen Number 5:
//          Pen Number 6:
//          Pen Number 7:
//          Pen Number 8:
//          Pen Number 9:
//          Pen Number 10:
//          Pen Number 11:
//      Pen Set #2;
//      Pen Set #3:
//      Pen Set #4: (Currently Installed>
//      Pen Set #5:
//      Pen Set #6:
//      Pen Set #7:
//      Pen Set #8:
//

EXTPUSH PenSetExtPush = {

            sizeof(EXTPUSH),
            EPF_NO_DOT_DOT_DOT,
            (LPTSTR)IDS_DEFAULT_PENCLR,
            NULL,
            IDI_DEFAULT_PENCLR,
            0
        };


OIDATA  OIPenSet = {

            ODF_PEN | ODF_COLLAPSE | ODF_CALLBACK,
            0,
            OI_LEVEL_2,
            PP_PENSET,
            TVOT_NONE,
            IDS_PENSET_FIRST,
            IDI_PENCLR,
            IDH_PENSET,
            0,
            NULL
        };

OPDATA  OPPenClr = { 0, IDS_COLOR_FIRST, IDI_COLOR_FIRST, 0, 0, 0 };

OIDATA  OIPenNum = {

            ODF_PEN | ODF_COLLAPSE |
                    ODF_INC_IDSNAME | ODF_INC_ICONID | ODF_NO_INC_POPDATA,
            0,
            OI_LEVEL_3,
            PP_PEN_NUM,
            TVOT_LISTBOX,
            IDS_PEN_NUM,
            OTS_LBCB_SORT,
            IDH_PEN_NUM,
            0,
            &OPPenClr
        };




POPTITEM
SavePenSet(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Nov-1995 Mon 18:52:15 created  -by-  DC


Revision History:


--*/

{
    PPENDATA    pPenData;
    UINT        MaxPens;
    UINT        i;


    pPenData = PI_PPENDATA(pPI);
    MaxPens  = (UINT)pPI->pPlotGPC->MaxPens;
    pOptItem++;

    for (i = 0; i < PRK_MAX_PENDATA_SET; i++) {

        UINT    cPens;
        BOOL    SavePen;

        //
        // Must skip the header
        //

        pOptItem++;
        cPens   = MaxPens;
        SavePen = FALSE;

        while (cPens--) {

            if (pOptItem->Flags & OPTIF_CHANGEONCE) {

                pPenData->ColorIdx = (WORD)pOptItem->Sel;
                SavePen            = TRUE;
            }

            pOptItem++;
            pPenData++;
        }

        if (SavePen) {

            if (!SaveToRegistry(pPI->hPrinter,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                MAKELONG(i, MaxPens),
                                pPenData - MaxPens)) {

                PlotUIMsgBox(NULL, IDS_PP_NO_SAVE, MB_ICONSTOP | MB_OK);
            }
        }
    }

    return(pOptItem);
}




UINT
CreatePenSetupOI(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Nov-1995 Mon 16:23:36 created  -by-  DC


Revision History:


--*/

{
    PPENDATA    pPenData;
    POPTITEM    pOI;
    POPTITEM    pOIPen;
    POPTTYPE    pOTPen;
    EXTRAINFO   EI;
    UINT        i;
    UINT        j;
    UINT        MaxPens;
    UINT        cPenClr;
    WCHAR       Buf[128];


    MaxPens  = (UINT)pPI->pPlotGPC->MaxPens;
    cPenClr  = PC_IDX_TOTAL;

    if (!pOptItem) {

        return(((MaxPens + 1) * PRK_MAX_PENDATA_SET) + 1);
    }

    EI.Size  = (UINT)((LoadString(hPlotUIModule,
                                  IDS_PEN_NUM,
                                  Buf,
                                  (sizeof(Buf) / sizeof(WCHAR)) - 1)
                       + 5) * sizeof(WCHAR));
    pPenData = PI_PPENDATA(pPI);
    pOTPen   = NULL;
    pOIPen   = NULL;
    pOI      = pOptItem;

    //
    // First: Create PenSetup: HEADER
    //

    if (CreateOPTTYPE(pPI, pOI, pOIData, 0, NULL)) {

        pOI++;
    }

    //
    // Now Create Each pen set
    //

    for (i = (UINT)IDS_PENSET_FIRST; i <= (UINT)IDS_PENSET_LAST; i++) {

        if (CreateOPTTYPE(pPI, pOI, &OIPenSet, 0, NULL)) {

            pOI->pName     = (LPTSTR)UIntToPtr(i);
            pOI->Flags    |= OPTIF_EXT_IS_EXTPUSH;
            pOI->pExtPush  = &PenSetExtPush;
        }

        pOI++;

        for (j = 1; j <= MaxPens; j++, pOI++, pPenData++) {

            if (CreateOPTTYPE(pPI, pOI, &OIPenNum, cPenClr, &EI)) {

                if (pOTPen) {

                    pOI->pOptType = pOTPen;

                } else {

                    pOTPen  = pOI->pOptType;
                    cPenClr = 0;
                }

                if (pOIPen) {

                    pOI->pName = pOIPen->pName;
                    pOIPen++;

                } else {

                    pOI->pName = (LPTSTR)EI.pData;
                    wsprintf(pOI->pName, L"%ws%u", Buf, j);
                }
            }

            pOI->Sel = pPenData->ColorIdx;
        }

        if (!pOIPen) {

            EI.Size = 0;
            pOIPen  = pOI;
        }

        pOIPen -= MaxPens;
    }

    return (UINT)(pOI - pOptItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\formbox.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    formbox.c


Abstract:

    This module contains functions to enumerate valid form and list on the
    combo box


Author:

    09-Dec-1993 Thu 14:31:44 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgFormBox

#define DBG_FORMS           0x00000001
#define DBG_TRAY            0x00000002
#define DBG_PERMISSION      0x00000004


DEFINE_DBGVAR(0);

WCHAR   wszModel[] = L"Model";




BOOL
GetFormSelect(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem
    )

/*++

Routine Description:

    This function retrieve the form selected by the user from the combo
    box

Arguments:

    pPI         - Pointer to the PRINTERINFO

    pOptItem    - Pointer to the FORM's OPTITEM

Return Value:

    TRUE if sucessful and pPI will be set correctly, FALSE if error occurred

Author:

    09-Dec-1993 Thu 14:44:18 created  -by-  DC

    18-Dec-1993 Sat 03:55:30 updated  -by-  DC
        Changed dmFields setting for the PAPER, now we will only set the
        DM_FORMNAME field, this way the returned document properties will be
        always in known form even user defines many forms in spooler.

    06-Nov-1995 Mon 12:56:00 updated  -by-  DC
        Re-write for the New UI

Revision History:


--*/

{
    PAPERINFO   CurPaper;
    POPTPARAM   pOptParam;


    pOptParam = pOptItem->pOptType->pOptParam + pOptItem->Sel;

    if (pOptParam->Style == FS_ROLLPAPER) {

        PFORMSRC    pFS;

        //
        // This was added from the GPC data for the roll feed
        //

        PLOTASSERT(0, "GetComboBoxSelForm: INTERNAL ERROR, ROLLPAPER In document properties",
                            !(pPI->Flags & PIF_DOCPROP), 0);
        PLOTASSERT(0, "GetComboBoxSelForm: INTERNAL ERROR, device CANNOT have ROLLPAPER",
                            pPI->pPlotGPC->Flags & PLOTF_ROLLFEED, 0);

        PLOTDBG(DBG_FORMS,
                ("Roll Feed Paper is selected, (%ld)", pOptParam->lParam));

        if (pOptParam->lParam < (LONG)pPI->pPlotGPC->Forms.Count) {

            pFS = (PFORMSRC)pPI->pPlotGPC->Forms.pData + pOptParam->lParam;

            //
            // Since the RollFeed paper has variable length, and the cy is set
            // to zero at GPC data, we must take that into account
            //

            CurPaper.Size             = pFS->Size;
            CurPaper.ImageArea.left   = pFS->Margin.left;
            CurPaper.ImageArea.top    = pFS->Margin.top;
            CurPaper.ImageArea.right  = CurPaper.Size.cx -
                                                        pFS->Margin.right;
            CurPaper.ImageArea.bottom = pPI->pPlotGPC->DeviceSize.cy -
                                                        pFS->Margin.bottom;
            str2Wstr(CurPaper.Name, pFS->Name);

        } else {

            PLOTERR(("GetComboBoxSelForm: Internal Error, Invalid lParam=%ld",
                     pOptParam->lParam));
            return(FALSE);
        }

    } else {

        FORM_INFO_1 *pFI1;
        DWORD       cb;

        //
        // This form is in the form data base
        //

        pFI1 = pPI->pFI1Base + pOptParam->lParam;

        CurPaper.Size      = pFI1->Size;
        CurPaper.ImageArea = pFI1->ImageableArea;

        WCPYFIELDNAME(CurPaper.Name, pFI1->pName);
    }

    //
    // Now we have current paper validated
    //

    if (pPI->Flags & PIF_DOCPROP) {

        //
        // Turn off first, then turn on paper fields as needed
        //

        pPI->PlotDM.dm.dmFields &= ~DM_PAPER_FIELDS;
        pPI->PlotDM.dm.dmFields |= (DM_FORMNAME | DM_PAPERSIZE);

        //
        // Copy down the dmFormName, dmPaperSize and set dmPaperWidth/Length,
        // the fields for PAPER will bb set to DM_FORMNAME so that we always
        // can find the form also we may set DM_PAPERSIZE if index number is
        // <= DMPAPER_LAST
        //

        WCPYFIELDNAME(pPI->PlotDM.dm.dmFormName, CurPaper.Name);

        pPI->PlotDM.dm.dmPaperSize   = (SHORT)(pOptParam->lParam +
                                                            DMPAPER_FIRST);
        pPI->PlotDM.dm.dmPaperWidth  = SPLTODM(CurPaper.Size.cx);
        pPI->PlotDM.dm.dmPaperLength = SPLTODM(CurPaper.Size.cy);

#if DBG
        *(PRECTL)&pPI->PlotDM.dm.dmBitsPerPel = CurPaper.ImageArea;
#endif

    } else {

        pPI->CurPaper = CurPaper;
    }

    PLOTDBG(DBG_FORMS, ("*** GetComboBoxSelForm from COMBO = '%s'", CurPaper.Name));
    PLOTDBG(DBG_FORMS, ("Size=%ld x %ld", CurPaper.Size.cx, CurPaper.Size.cy));
    PLOTDBG(DBG_FORMS, ("ImageArea=(%ld, %ld) - (%ld, %ld)",
                         CurPaper.ImageArea.left,   CurPaper.ImageArea.top,
                         CurPaper.ImageArea.right,  CurPaper.ImageArea.bottom));

    return(TRUE);
}




UINT
CreateFormOI(
    PPRINTERINFO    pPI,
    POPTITEM        pOptItem,
    POIDATA         pOIData
    )

/*++

Routine Description:

    This function add the available forms to the combo box, it will optionally
    add the roll feed type of form


Arguments:

    pPI         - Pointer to the PRINTERINFO data structure

    pOptItem    - Pointer to the FORM's OPTITEM

    pOIData     - Pointer to the OIDATA structure

Return Value:

    The form selected, a netavie number means error

Author:

    09-Dec-1993 Thu 14:35:59 created  -by-  DC

    06-Nov-1995 Mon 12:56:24 updated  -by-  DC
        Re-write for the New UI

Revision History:


--*/

{
    LPWSTR          pwSelName;
    POPTPARAM       pOptParam;
    PFORM_INFO_1    pFI1;
    PFORMSRC        pFS;
    ENUMFORMPARAM   EFP;
    DWORD           i;
    LONG            Sel;
    DWORD           cRollPaper;
    EXTRAINFO       EI;


    if (!pOptItem) {

        return(1);
    }

    pwSelName = (LPWSTR)((pPI->Flags & PIF_DOCPROP) ?
                            pPI->PlotDM.dm.dmFormName : pPI->CurPaper.Name);

    PLOTDBG(DBG_FORMS, ("Current Form: <%ws>", pwSelName));

    EFP.pPlotDM  = &(pPI->PlotDM);
    EFP.pPlotGPC = pPI->pPlotGPC;

    if (!PlotEnumForms(pPI->hPrinter, NULL, &EFP)) {

        PLOTERR(("CreateFormOI: PlotEnumForms() failed"));
        return(0);
    }

    cRollPaper = 0;

    if ((!(pPI->Flags & PIF_DOCPROP)) &&
        (pPI->pPlotGPC->Flags & PLOTF_ROLLFEED)) {

        //
        // Add device' roll paper to the combo box too.
        //

        PLOTDBG(DBG_FORMS, ("Device support ROLLFEED so add RollPaper if any"));

        for (i= 0, pFS = (PFORMSRC)pPI->pPlotGPC->Forms.pData;
             i < (DWORD)pPI->pPlotGPC->Forms.Count;
             i++, pFS++) {

            if (!pFS->Size.cy) {

                ++cRollPaper;
            }
        }
    }

    PLOTDBG(DBG_FORMS, ("Valid Count is %ld [%ld + %ld] out of %ld",
                            EFP.ValidCount + cRollPaper,
                            EFP.ValidCount, cRollPaper, EFP.Count));

    EI.Size = (DWORD)(cRollPaper * (sizeof(WCHAR) * CCHFORMNAME));

    if (!CreateOPTTYPE(pPI,
                       pOptItem,
                       pOIData,
                       EFP.ValidCount + cRollPaper,
                       &EI)) {

        LocalFree((HLOCAL)EFP.pFI1Base);
        return(0);
    }

    pPI->pFI1Base             = EFP.pFI1Base;
    pOptItem->pOptType->Style = OTS_LBCB_SORT;
    pOptParam                 = pOptItem->pOptType->pOptParam;

    for (i = 0, Sel = 0, pFI1 = EFP.pFI1Base; i < EFP.Count; i++, pFI1++) {

        if (pFI1->Flags & FI1F_VALID_SIZE) {

            pOptParam->cbSize = sizeof(OPTPARAM);
            pOptParam->Style  = (pPI->pPlotGPC->Flags & PLOTF_PAPERTRAY) ?
                                                            FS_TRAYPAPER : 0;
            pOptParam->pData  = pFI1->pName;
            pOptParam->IconID = (pFI1->Flags & FI1F_ENVELOPE) ?
                                    IDI_CPSUI_ENVELOPE : IDI_CPSUI_STD_FORM;
            pOptParam->lParam = (LONG)i;

            if (!lstrcmp(pwSelName, pOptParam->pData)) {

                pOptItem->Sel = Sel;
            }

            pOptParam++;
            Sel++;
        }
    }

    if (cRollPaper) {

        LPWSTR  pwStr = (LPWSTR)EI.pData;

        //
        // Add device' roll paper to the combo box too.
        //

        for (i = 0, pFS = (PFORMSRC)pPI->pPlotGPC->Forms.pData;
             i < (DWORD)pPI->pPlotGPC->Forms.Count;
             i++, pFS++) {

            if (!(pFS->Size.cy)) {

                //
                // Got one, we have to translated into the UNICODE first
                //

                pOptParam->cbSize = sizeof(OPTPARAM);
                pOptParam->Style   = FS_ROLLPAPER;
                pOptParam->pData   = (LPTSTR)pwStr;
                pwStr             += CCHFORMNAME;
                pOptParam->IconID  = IDI_ROLLPAPER;
                pOptParam->lParam  = (LONG)i;

                str2Wstr(pOptParam->pData, pFS->Name);

                if (!lstrcmp(pwSelName, pOptParam->pData)) {

                    pOptItem->Sel = Sel;
                }

                pOptParam++;
                Sel++;
            }
        }
    }

    return(1);
}



BOOL
AddFormsToDataBase(
    PPRINTERINFO    pPI,
    BOOL            DeleteFirst
    )

/*++

Routine Description:

    This function add driver supports forms to the data base

Arguments:

    pPI - Pointer to the PRINTERINFO


Return Value:

    BOOLEAN


Author:

    09-Dec-1993 Thu 22:38:27 created  -by-  DC

    27-Apr-1994 Wed 19:18:58 updated  -by-  DC
        Fixed bug# 13592 which printman/spooler did not call ptrprop first but
        docprop so let us into unknown form database state,

Revision History:


--*/

{
    WCHAR       wName[CCHFORMNAME + 2];
    BOOL        bRet;
    LONG        i;
    DWORD       Type;


    Type = REG_SZ;

    if ((GetPrinterData(pPI->hPrinter,
                        wszModel,
                        &Type,
                        (LPBYTE)wName,
                        sizeof(wName),
                        &i) == ERROR_SUCCESS) &&
        (wcscmp(pPI->PlotDM.dm.dmDeviceName, wName))) {

        PLOTDBG(DBG_FORMS, ("Already added forms to the data base for %s",
                                                pPI->PlotDM.dm.dmDeviceName));
        return(TRUE);
    }

    //
    // Find out if we have permission to do this
    //

    if (SetPrinterData(pPI->hPrinter,
                       wszModel,
                       REG_SZ,
                       (LPBYTE)pPI->PlotDM.dm.dmDeviceName,
                       (wcslen(pPI->PlotDM.dm.dmDeviceName) + 1) *
                                            sizeof(WCHAR)) == ERROR_SUCCESS) {

        PFORMSRC    pFS;
        FORM_INFO_1 FI1;

        //
        // We have permission to update the registry so do it now
        //

        pPI->Flags |= PIF_UPDATE_PERMISSION;

        PLOTDBG(DBG_PERMISSION,
                ("!!! MODEL NAME: '%s' not Match, Re-installed Form Database",
                                            pPI->PlotDM.dm.dmDeviceName));

        //
        // Add the driver supportes forms to the system spooler data base if
        // not yet done so
        //

        FI1.pName = wName;

        for (i = 0, pFS = (PFORMSRC)pPI->pPlotGPC->Forms.pData;
             i < (LONG)pPI->pPlotGPC->Forms.Count;
             i++, pFS++) {

            //
            // We will only add the non-roll paper forms
            //

            if (pFS->Size.cy) {

                str2Wstr(wName, pFS->Name);

                //
                // Firstable we will delete the same name form in the data
                // base first, this will ensure we have our curent user defined
                // form can be installed
                //

                if (DeleteFirst) {

                    DeleteForm(pPI->hPrinter, wName);
                }

                FI1.Size                 = pFS->Size;
                FI1.ImageableArea.left   = pFS->Margin.left;
                FI1.ImageableArea.top    = pFS->Margin.top;
                FI1.ImageableArea.right  = FI1.Size.cx - pFS->Margin.right;
                FI1.ImageableArea.bottom = FI1.Size.cy - pFS->Margin.bottom;

                PLOTDBG(DBG_FORMS, (
                        "AddForm: %s-[%ld x %ld] (%ld, %ld)-(%ld, %ld)",
                        FI1.pName, FI1.Size.cx, FI1.Size.cy,
                        FI1.ImageableArea.left, FI1.ImageableArea.top,
                        FI1.ImageableArea.right,FI1.ImageableArea.bottom));

                FI1.Flags = FORM_PRINTER;

                if ((!AddForm(pPI->hPrinter, 1, (LPBYTE)&FI1))  &&
                    (GetLastError() != ERROR_FILE_EXISTS)       &&
                    (GetLastError() != ERROR_ALREADY_EXISTS)) {

                    bRet = FALSE;
                    PLOTERR(("AddFormsToDataBase: AddForm(%s) failed, [%ld]",
                                        wName, GetLastError()));
                }
            }
        }

        return(TRUE);

    } else {

        pPI->Flags &= ~PIF_UPDATE_PERMISSION;

        PLOTDBG(DBG_PERMISSION, ("AddFormsToDataBase(): NO UPDATE PERMISSION"));

        return(FALSE);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\plotui.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    plotui.h


Abstract:

    This module contains all plotters's user interface common defines


Author:

    02-Dec-1993 Thu 09:56:07 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTUI_
#define _PLOTUI_

//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif


//
// PrinterINFO data structure which used by following calls to map a hPrinter
// to this data structrue by follwoing funciton
//
//  1. DrvDeviceCapabilities()
//  2. PrinterProperties()
// @@BEGIN_DDKSPLIT
//  3. DrvDocumentProperties()
//  4. DrvAdvancedDocumentProperties()
// @@END_DDKSPLIT
//

#define PIF_UPDATE_PERMISSION       0x01
#define PIF_DOCPROP                 0x02

typedef struct _PRINTERINFO {
    HANDLE          hPrinter;       // Handle to the printer belong to here
    POPTITEM        pOptItem;
    LPWSTR          pHelpFile;      // pointer to the help file
    PFORM_INFO_1    pFI1Base;       // intalled form
    PPLOTGPC        pPlotGPC;       // loaded/updated Plotter GPC data
    WORD            cOptItem;
    BYTE            Flags;
    BYTE            IdxPenSet;      // plotter pen data set
    DWORD           dmErrBits;      // ErrorBits for DM_
    PLOTDEVMODE     PlotDM;         // Validated PLOTDEVMODE
    PAPERINFO       CurPaper;       // Current loaded form on the device
    PPDATA          PPData;         // Printer Prop Data
    HANDLE          hCPSUI;         // handle to the common ui pages
    PCOMPROPSHEETUI pCPSUI;         // pointer to COMPROPSHEETUI
    PPLOTDEVMODE    pPlotDMIn;      // input devmode
    PPLOTDEVMODE    pPlotDMOut;     // output devmode
    DWORD           dw64Align;      // QWORD alignment.
    DWORD           ExtraData;      // starting of extra data
    } PRINTERINFO, *PPRINTERINFO;

#define PI_PADJHTINFO(pPI)      (PDEVHTINFO)&((pPI)->ExtraData)
#define PI_PDEVHTADJDATA(pPI)   (PDEVHTADJDATA)(PI_PADJHTINFO(pPI) + 1)
#define PI_PPENDATA(pPI)        (PPENDATA)&((pPI)->ExtraData)

typedef struct _DOCPROPINFO {
    HWND                    hWnd;
    DWORD                   Result;
    DOCUMENTPROPERTYHEADER  DPHdr;
    } DOCPROPINFO, *PDOCPROPINFO;

typedef struct _DEVPROPINFO {
    HWND                    hWnd;
    DWORD                   Result;
    DEVICEPROPERTYHEADER    DPHdr;
    } DEVPROPINFO, *PDEVPROPINFO;

typedef UINT (* _CREATEOIFUNC)(PPRINTERINFO  pPI,
                               POPTITEM      pOptItem,
                               LPVOID        pOIData);

#define CREATEOIFUNC    UINT


typedef struct _OPDATA {
    WORD    Flags;
    WORD    IDSName;
    WORD    IconID;
    union {
        WORD    Style;
        WORD    IDSSeparator;
        } DUMMYUNIONNAME;
    union {
        WORD    wParam;
        WORD    IDSCheckedName;
        } DUMMYUNIONNAME2;
    SHORT   sParam;
    } OPDATA, *POPDATA;

#define ODF_PEN                 0x00000001
#define ODF_RASTER              0x00000002
#define ODF_PEN_RASTER          (ODF_PEN | ODF_RASTER)
#define ODF_COLOR               0x00000004
#define ODF_ROLLFEED            0x00000008
#define ODF_ECB                 0x00000010
#define ODF_INC_IDSNAME         0x00000020
#define ODF_INC_ICONID          0x00000040
#define ODF_NO_INC_POPDATA      0x00000080
#define ODF_COLLAPSE            0x00000100
#define ODF_CALLBACK            0x00000200
#define ODF_NO_PAPERTRAY        0x00000400
#define ODF_CALLCREATEOI        0x00000800
#define ODF_MANUAL_FEED         0x00001000


#define OI_LEVEL_1              0
#define OI_LEVEL_2              1
#define OI_LEVEL_3              2
#define OI_LEVEL_4              3
#define OI_LEVEL_5              4
#define OI_LEVEL_6              5

typedef struct _OIDATA {
    DWORD               Flags;
    BYTE                NotUsed;
    BYTE                Level;
    BYTE                DMPubID;
    BYTE                Type;
    WORD                IDSName;
    union {
        WORD            IconID;
        WORD            Style;
        } DUMMYUNIONNAME;
    WORD                HelpIdx;
    WORD                cOPData;
    union {
        POPDATA         pOPData;
        _CREATEOIFUNC   pfnCreateOI;
        } DUMMYUNIONNAME2;
    } OIDATA, *POIDATA;

#define PI_OFF(x)               (WORD)FIELD_OFFSET(PRINTERINFO, x)
#define PLOTDM_OFF(x)           (WORD)FIELD_OFFSET(PLOTDEVMODE, x)

#define OPTIF_NONE                  0
#define PP_FORMTRAY_ASSIGN          (DMPUB_USER + 0)
#define PP_INSTALLED_FORM           (DMPUB_USER + 1)
#define PP_MANUAL_FEED_METHOD       (DMPUB_USER + 2)
#define PP_PRINT_FORM_OPTIONS       (DMPUB_USER + 3)
#define PP_AUTO_ROTATE              (DMPUB_USER + 4)
#define PP_PRINT_SMALLER_PAPER      (DMPUB_USER + 5)
#define PP_HT_SETUP                 (DMPUB_USER + 6)
#define PP_INSTALLED_PENSET         (DMPUB_USER + 7)
#define PP_PEN_SETUP                (DMPUB_USER + 8)
#define PP_PENSET                   (DMPUB_USER + 9)
#define PP_PEN_NUM                  (DMPUB_USER + 10)

#define DP_HTCLRADJ                 (DMPUB_USER + 0)
#define DP_FILL_TRUETYPE            (DMPUB_USER + 1)
#define DP_QUICK_POSTER_MODE        (DMPUB_USER + 2)


//
// Icon ID
//

#define IDI_RASTER_ROLLFEED         64089
#define IDI_RASTER_TRAYFEED         64090
#define IDI_PEN_ROLLFEED            64087
#define IDI_PEN_TRAYFEED            64088
#define IDI_ROLLPAPER               64091

#define IDI_PEN_SETUP               64093
#define IDI_PENSET                  64092
#define IDI_DEFAULT_PENCLR          1007
#define IDI_PENCLR                  64092
#define IDI_AUTO_ROTATE_NO          1009
#define IDI_AUTO_ROTATE_YES         1010
#define IDI_PRINT_SMALLER_PAPER_NO  1011
#define IDI_PRINT_SMALLER_PAPER_YES 1012
#define IDI_MANUAL_CX               1013
#define IDI_MANUAL_CY               1014
#define IDI_FILL_TRUETYPE_NO        1015
#define IDI_FILL_TRUETYPE_YES       1016


#define IDI_COLOR_FIRST             IDI_WHITE
#define IDI_WHITE                   1100
#define IDI_BLACK                   1101
#define IDI_RED                     1102
#define IDI_GREEN                   1103
#define IDI_YELLOW                  1104
#define IDI_BLUE                    1105
#define IDI_MAGENTA                 1106
#define IDI_CYAN                    1107
#define IDI_ORANGE                  1108
#define IDI_BROWN                   1109
#define IDI_VIOLET                  1110
#define IDI_COLOR_LAST              IDI_VIOLET


//
// String table ID
//

#define IDS_PLOTTER_DRIVER          1900
#define IDS_CAUTION                 1901
#define IDS_NO_MEMORY               1902
#define IDS_INVALID_DATA            1903
#define IDS_FORM_TOO_BIG            1904
#define IDS_INV_DMSIZE              1905
#define IDS_INV_DMVERSION           1906
#define IDS_INV_DMDRIVEREXTRA       1907
#define IDS_INV_DMCOLOR             1908
#define IDS_INV_DMCOPIES            1909
#define IDS_INV_DMSCALE             1910
#define IDS_INV_DMORIENTATION       1911
#define IDS_INV_DMFORM              1912
#define IDS_INV_DMQUALITY           1913
#define IDS_FORM_NOT_AVAI           1914
#define IDS_MODEL                   1915
#define IDS_HELP_FILENAME           1916
#define IDS_NO_HELP                 1918
#define IDS_PP_NO_SAVE              1919

#define IDS_INSTALLED_FORM          2030

#define IDS_MANUAL_FEEDER           2040
#define IDS_MANUAL_FEED_METHOD      2041
#define IDS_MANUAL_CX               2042
#define IDS_MANUAL_CY               2043
#define IDS_ROLLFEED                2044
#define IDS_MAINFEED                2045

#define IDS_PRINT_FORM_OPTIONS      2050
#define IDS_AUTO_ROTATE             2051
#define IDS_PRINT_SAMLLER_PAPER     2052

#define IDS_INSTALLED_PENSET        2060
#define IDS_PEN_SETUP               2061

#define IDS_PENSET_FIRST            IDS_PENSET_1
#define IDS_PENSET_1                2070
#define IDS_PENSET_2                2071
#define IDS_PENSET_3                2072
#define IDS_PENSET_4                2073
#define IDS_PENSET_5                2074
#define IDS_PENSET_6                2075
#define IDS_PENSET_7                2076
#define IDS_PENSET_8                2077
#define IDS_PENSET_LAST             IDS_PENSET_8

#define IDS_PEN_NUM                 2100
#define IDS_DEFAULT_PENCLR          2101


#define IDS_QUALITY_FIRST           IDS_QUALITY_DRAFT
#define IDS_QUALITY_DRAFT           2110
#define IDS_QUALITY_LOW             2111
#define IDS_QUALITY_MEDIUM          2112
#define IDS_QUALITY_HIGH            2113
#define IDS_QUALITY_LAST            IDS_QUALITY_HIGH

#define IDS_COLOR_FIRST             IDS_WHITE
#define IDS_WHITE                   2120
#define IDS_BLACK                   2121
#define IDS_RED                     2122
#define IDS_GREEN                   2123
#define IDS_YELLOW                  2124
#define IDS_BLUE                    2125
#define IDS_MAGENTA                 2126
#define IDS_CYAN                    2127
#define IDS_ORANGE                  2128
#define IDS_BROWN                   2129
#define IDS_VIOLET                  2130
#define IDS_COLOR_LAST              IDS_VIOLET

#define IDS_FILL_TRUETYPE           2140
#define IDS_POSTER_MODE             2150


#define IDS_USERFORM                2200

//
// Help Index for Printer Properties
//

#define IDH_FORMTRAYASSIGN          5000
#define IDH_FORM_ROLL_FEEDER        5010
#define IDH_FORM_MAIN_FEEDER        5020
#define IDH_FORM_MANUAL_FEEDER      5030
#define IDH_MANUAL_FEED_METHOD      5040
#define IDH_PRINT_FORM_OPTIONS      5050
#define IDH_AUTO_ROTATE             5060
#define IDH_PRINT_SMALLER_PAPER     5070
#define IDH_HALFTONE_SETUP          5080
#define IDH_INSTALLED_PENSET        5090
#define IDH_PEN_SETUP               5100
#define IDH_PENSET                  5110
#define IDH_PEN_NUM                 5120

//
// Help Index for Document Properties

#define IDH_FORMNAME                5500
#define IDH_ORIENTATION             5510
#define IDH_COPIES_COLLATE          5520
#define IDH_PRINTQUALITY            5530
#define IDH_COLOR                   5540
#define IDH_SCALE                   5550
#define IDH_HTCLRADJ                5560
#define IDH_FILL_TRUETYPE           5570
#define IDH_POSTER_MODE             5580


#endif  // _PLOTUI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\plotui.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    plotinit.c


Abstract:

    This module contains plotter UI dll entry point


Author:

    18-Nov-1993 Thu 07:12:52 created  -by-  DC

    01-Nov-1995 Wed 10:29:33 updated  -by-  DC
        Re-write for the SUR common UI

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPlotUI


#define DBG_PROCESS_ATTACH  0x00000001
#define DBG_PROCESS_DETACH  0x00000002

DEFINE_DBGVAR(0);




#if DBG
TCHAR   DebugDLLName[] = TEXT("PLOTUI");
#endif


HMODULE     hPlotUIModule = NULL;



BOOL
PlotUIDLLEntryFunc(
    HINSTANCE   hModule,
    DWORD       Reason,
    LPVOID      pReserved
    )

/*++

Routine Description:

    This is the DLL entry point


Arguments:

    hMoudle     - handle to the module for this function

    Reason      - The reason called

    pReserved   - Not used, do not touch


Return Value:

    BOOL, we will always return ture and never failed this function

Author:

    15-Dec-1993 Wed 15:05:56 updated  -by-  DC
        Add the DestroyCachedData()

    18-Nov-1993 Thu 07:13:56 created  -by-  DC


Revision History:


--*/

{
    WCHAR   wName[MAX_PATH + 32];


    UNREFERENCED_PARAMETER(pReserved);

    switch (Reason) {

    case DLL_PROCESS_ATTACH:

        PLOTDBG(DBG_PROCESS_ATTACH,
                ("PlotUIDLLEntryFunc: DLL_PROCESS_ATTACH: hModule = %08lx",
                                                                    hModule));
        hPlotUIModule = hModule;

        //
        // Load the module second time so it will stick with the process to
        // save reload time
        //

        if (GetModuleFileName(hPlotUIModule, wName, COUNT_ARRAY(wName))) {

            PLOTDBG(DBG_PROCESS_ATTACH,
                    ("PlotUIDLLEntryFunc: ModuleName=%ws", wName));

            LoadLibrary(wName);

        } else {

            PLOTERR(("PlotUIDLLEntryFunc: GetModuleFileName FAILED"));
        }

        //
        // Initialize GPC data cache
        //

        InitCachedData();

        break;

    case DLL_PROCESS_DETACH:

        //
        // Free up all the memory used by this module
        //

        PLOTDBG(DBG_PROCESS_DETACH,
                ("PlotUIDLLEntryFunc: DLL_PROCESS_DETACH Destroy CACHED Data"));

        DestroyCachedData();
        break;
    }

    return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\precomp.h ===
#define _WINDEFP_NO_PDEVBRUSH

#include <stddef.h>
#include <stdarg.h>
#include <windows.h>
#include <winddi.h>
#include <winspool.h>
#include <winddiui.h>

#include <plotgpc.h>
#include <plotdm.h>
#include <plotters.h>
#include <plotlib.h>

#include "plotui.h"
#include "cpsui.h"

#include "formbox.h"
#include "help.h"
#include "pensetup.h"
#include "ptrinfo.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\ptrinfo.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    uituils.h


Abstract:

    This module contains the defines for UIUtils.c


Author:

    03-Dec-1993 Fri 21:35:50 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/



#ifndef _PRINTER_INFO_
#define _PRINTER_INFO_


#define MPF_DEVICEDATA      0x00000001
#define MPF_HELPFILE        0x00000002
#define MPF_PCPSUI          0x00000004


PPRINTERINFO
MapPrinter(
    HANDLE          hPrinter,
    PPLOTDEVMODE    pPlotDMIn,
    LPDWORD         pdwErrIDS,
    DWORD           MPFlags
    );

VOID
UnMapPrinter(
    PPRINTERINFO    pPI
    );

LPBYTE
GetPrinterInfo(
    HANDLE  hPrinter,
    UINT    PrinterInfoLevel
    );

DWORD
GetPlotterIconID(
    PPRINTERINFO    pPI
    );


#endif  // _PRINTER_INFO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\ptrinfo.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    ptrInfo.c


Abstract:

    This module contains functions to mappring a hPrinter to useful data, it
    will also cached the printerinfo data


Author:

    03-Dec-1993 Fri 00:16:37 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPtrInfo


#define DBG_MAPPRINTER      0x00000001
#define DBG_CACHE_DATA      0x00000002


DEFINE_DBGVAR(0);




PPRINTERINFO
MapPrinter(
    HANDLE          hPrinter,
    PPLOTDEVMODE    pPlotDMIn,
    LPDWORD         pdwErrIDS,
    DWORD           MPFlags
    )

/*++

Routine Description:

    This function map a handle to the printer to useful information for the
    plotter UI


Arguments:

    hPrinter    - Handle to the printer

    pPlotDMIn   - pointer to the PLOTDEVMODE pass in to be validate and merge
                  with default into pPI->PlotDM, if this pointer is NULL then
                  a default PLOTDEVMODE is set in the pPI

    pdwErrIDS   - pointer to a DWORD to store the error string ID if an error
                  occured.

    MPFlags     - MPF_xxxx flags for this function


Return Value:

    return a pointer to the PRINTERINFO data structure, if NULL then it failed

    when a pPI is returned then following fields are set and validated

        hPrinter, pPlotGPC, CurPaper.

    and following fields are set to NULL

        Flags,

Author:

    02-Dec-1993 Thu 23:04:18 created  -by-  DC

    29-Dec-1993 Wed 14:50:23 updated  -by-  DC
        NOT automatically select AUTO_ROTATE if roll feed device


Revision History:


--*/

{
    HANDLE          hHeap;
    PPRINTERINFO    pPI;
    PPLOTGPC        pPlotGPC;
    WCHAR           DeviceName[CCHDEVICENAME];
    UINT            cPenSet;
    UINT            MaxPens;
    DWORD           cbPen;
    DWORD           cb;


    if (!(pPlotGPC = hPrinterToPlotGPC(hPrinter, DeviceName))) {

        if (pdwErrIDS) {

            *pdwErrIDS = IDS_NO_MEMORY;
        }

        return(NULL);
    }

    if (pPlotGPC->Flags & PLOTF_RASTER) {

        cb = sizeof(PRINTERINFO) +
             ((MPFlags & MPF_DEVICEDATA) ?
                    (sizeof(DEVHTADJDATA) + (sizeof(DEVHTINFO) * 2)) : 0);

    } else {

        MaxPens = (UINT)pPlotGPC->MaxPens;
        cbPen   = (DWORD)(sizeof(PENDATA) * MaxPens);
        cPenSet = (MPFlags & MPF_DEVICEDATA) ? PRK_MAX_PENDATA_SET : 1;
        cb      = sizeof(PRINTERINFO) + (DWORD)(cbPen * cPenSet);
    }

    if (!(pPI = (PPRINTERINFO)LocalAlloc(LPTR,
                                         cb + ((MPFlags & MPF_PCPSUI) ?
                                                sizeof(COMPROPSHEETUI) : 0)))) {

        UnGetCachedPlotGPC(pPlotGPC);

        if (pdwErrIDS) {

            *pdwErrIDS = IDS_NO_MEMORY;
        }

        return(NULL);
    }

    if (MPFlags & MPF_PCPSUI) {

        pPI->pCPSUI = (PCOMPROPSHEETUI)((LPBYTE)pPI + cb);
    }

    pPI->hPrinter     = hPrinter;
    pPI->pPlotDMIn    = pPlotDMIn;
    pPI->PPData.Flags = PPF_AUTO_ROTATE     |
                        PPF_SMALLER_FORM    |
                        PPF_MANUAL_FEED_CX;
    pPI->IdxPenSet    = 0;
    pPI->pPlotGPC     = pPlotGPC;
    pPI->dmErrBits    = ValidateSetPLOTDM(hPrinter,
                                          pPlotGPC,
                                          DeviceName,
                                          pPlotDMIn,
                                          &(pPI->PlotDM),
                                          NULL);

    GetDefaultPlotterForm(pPlotGPC, &(pPI->CurPaper));

    if (pPlotGPC->Flags & PLOTF_RASTER) {

        //
        // Get the raster plotter default and settings
        //

        if (MPFlags & MPF_DEVICEDATA) {

            PDEVHTADJDATA   pDHTAD;
            PDEVHTINFO      pDefHTInfo;
            PDEVHTINFO      pAdjHTInfo;

            pAdjHTInfo                = PI_PADJHTINFO(pPI);
            pDHTAD                    = PI_PDEVHTADJDATA(pPI);
            pDefHTInfo                = (PDEVHTINFO)(pDHTAD + 1);

            pDHTAD->DeviceFlags       = (pPlotGPC->Flags & PLOTF_COLOR) ?
                                                    DEVHTADJF_COLOR_DEVICE : 0;
            pDHTAD->DeviceXDPI        = (DWORD)pPI->pPlotGPC->RasterXDPI;
            pDHTAD->DeviceYDPI        = (DWORD)pPI->pPlotGPC->RasterYDPI;
            pDHTAD->pDefHTInfo        = pDefHTInfo;
            pDHTAD->pAdjHTInfo        = pAdjHTInfo;

            pDefHTInfo->HTFlags       = HT_FLAG_HAS_BLACK_DYE;
            pDefHTInfo->HTPatternSize = (DWORD)pPlotGPC->HTPatternSize;
            pDefHTInfo->DevPelsDPI    = (DWORD)pPlotGPC->DevicePelsDPI;
            pDefHTInfo->ColorInfo     = pPlotGPC->ci;
            *pAdjHTInfo               = *pDefHTInfo;

            UpdateFromRegistry(hPrinter,
                               &(pAdjHTInfo->ColorInfo),
                               &(pAdjHTInfo->DevPelsDPI),
                               &(pAdjHTInfo->HTPatternSize),
                               &(pPI->CurPaper),
                               &(pPI->PPData),
                               NULL,
                               0,
                               NULL);
        }

    } else {

        PPENDATA    pPenData;
        WORD        IdxPenSet;

        //
        // Get the pen plotter default and settings
        //

        pPenData = PI_PPENDATA(pPI);

        UpdateFromRegistry(hPrinter,
                           NULL,
                           NULL,
                           NULL,
                           &(pPI->CurPaper),
                           &(pPI->PPData),
                           &(pPI->IdxPenSet),
                           0,
                           NULL);

        if (MPFlags & MPF_DEVICEDATA) {

            IdxPenSet = 0;

        } else {

            IdxPenSet = (WORD)pPI->IdxPenSet;
        }

        //
        // Set default pen set and get all the pen set back
        //

        while (cPenSet--) {

            CopyMemory(pPenData, pPlotGPC->Pens.pData, cbPen);

            UpdateFromRegistry(hPrinter,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               MAKELONG(IdxPenSet, MaxPens),
                               pPenData);

            IdxPenSet++;
            (LPBYTE)pPenData += cbPen;
        }
    }

    if (MPFlags & MPF_HELPFILE) {

        GetPlotHelpFile(pPI);
    }

    return(pPI);
}




VOID
UnMapPrinter(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    01-Nov-1995 Wed 19:05:40 created  -by-  DC


Revision History:


--*/

{
    if (pPI) {

        if (pPI->pPlotGPC) {

            UnGetCachedPlotGPC(pPI->pPlotGPC);
        }

        if (pPI->pFI1Base) {

            LocalFree((HLOCAL)pPI->pFI1Base);
        }

        if (pPI->pHelpFile) {

            LocalFree((HLOCAL)pPI->pHelpFile);
        }

        if (pPI->pOptItem) {

            POPTITEM    pOI = pPI->pOptItem;
            UINT        cOI = (UINT)pPI->cOptItem;

            while (cOI--) {

                if (pOI->UserData) {

                    LocalFree((HLOCAL)pOI->UserData);
                }

                pOI++;
            }

            LocalFree((HLOCAL)pPI->pOptItem);
        }

        LocalFree((HLOCAL)pPI);
    }
}




LPBYTE
GetPrinterInfo(
    HANDLE  hPrinter,
    UINT    PrinterInfoLevel
    )

/*++

Routine Description:

    This function get the DRIVER_INFO_1 Pointer from a hPrinter

Arguments:

    hPrinter            - The handle to the printer interested

    PrinterInfoLevel    - It can be PRINTER_INFO_1, PRINTER_INFO_2,
                          PRINTER_INFO_3, PRINTER_4, PRINTER_INFO_5.

Return Value:

    the return value is NULL if failed else a pointer to the PRINTER_INFO_X
    where X is from 1 to 5. the caller must call LocalFree() to free the
    memory object after using it.


Author:

    16-Nov-1995 Thu 23:58:37 created  -by-  DC


Revision History:


--*/

{
    LPVOID  pb;
    DWORD   cb;

    //
    // Find out total bytes required
    //

    GetPrinter(hPrinter, PrinterInfoLevel, NULL, 0, &cb);

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {

        PLOTERR(("GetPrinterInfo%d: GetPrinterPrinter(1st) error=%08lx",
                                        PrinterInfoLevel, xGetLastError()));

    } else if (!(pb = (LPBYTE)LocalAlloc(LMEM_FIXED, cb))) {

        PLOTERR(("GetPrinterInfo%d: LocalAlloc(%ld) failed", PrinterInfoLevel, cb));

    } else if (GetPrinter(hPrinter, PrinterInfoLevel, pb, cb, &cb)) {

        //
        // Got it allright, so return it
        //

        return(pb);

    } else {

        PLOTERR(("GetPrinterInfo%d: GetPrinterPrinter(2nd) error=%08lx",
                                        PrinterInfoLevel, xGetLastError()));
        LocalFree((HLOCAL)pb);
    }

    return(NULL);
}




DWORD
GetPlotterIconID(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    29-Nov-1995 Wed 19:32:00 created  -by-  DC


Revision History:


--*/

{
    DWORD   Flags;
    DWORD   IconID;


    if ((Flags = pPI->pPlotGPC->Flags) & PLOTF_RASTER) {

        IconID = (Flags & PLOTF_ROLLFEED) ? IDI_RASTER_ROLLFEED :
                                            IDI_RASTER_TRAYFEED;

    } else {

        IconID = (Flags & PLOTF_ROLLFEED) ? IDI_PEN_ROLLFEED :
                                            IDI_PEN_TRAYFEED;
    }

    return(IconID);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\inc\name.h ===
CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\ptrprop.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    ptrprop.c


Abstract:

    This module contains PrinterProperties() API entry and it's related
    functions


Author:

    06-Dec-1993 Mon 10:30:43 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgPtrProp


extern HMODULE  hPlotUIModule;


#define DBG_DEVHTINFO           0x00000001
#define DBG_PP_FORM             0x00000002
#define DBG_EXTRA_DATA          0x00000004
#define DBG_CHK_PENSET_BUTTON   0x00000008

DEFINE_DBGVAR(0);


//
//  Form To Tray Assignment:
//      Roll Paper Feeder: <XYZ>
//          Manual Feed Method:
//  Print Form Options:
//      [] Auto. Rotate To Save Roll Paper:
//      [] Print Smaller Paper Size:
//  Halftone Setup...
//  Installed Pen Set: Pen Set #1
//  Pen Setup:
//      Installed: Pen Set #1
//      Pen Set #1:
//          Pen Number 1:
//          Pen Number 2:
//          Pen Number 3:
//          Pen Number 4:
//          Pen Number 5:
//          Pen Number 6:
//          Pen Number 7:
//          Pen Number 8:
//          Pen Number 9:
//          Pen Number 10:
//          Pen Number 11:
//      Pen Set #2;
//      Pen Set #3:
//      Pen Set #4: <Currently Installed>
//      Pen Set #5:
//      Pen Set #6:
//      Pen Set #7:
//      Pen Set #8:
//

OPDATA  OPPenSet = { 0, IDS_PENSET_FIRST, IDI_PENSET, 0, 0, 0 };

OPDATA  OPAutoRotate[] = {

    { 0, IDS_CPSUI_NO,  IDI_AUTO_ROTATE_NO,  0,  0, 0  },
    { 0, IDS_CPSUI_YES, IDI_AUTO_ROTATE_YES, 0,  0, 0  }
};

OPDATA  OPPrintSmallerPaper[] = {

    { 0, IDS_CPSUI_NO,  IDI_PRINT_SMALLER_PAPER_NO,  0,  0, 0  },
    { 0, IDS_CPSUI_YES, IDI_PRINT_SMALLER_PAPER_YES, 0,  0, 0  }
};


OPDATA  OPManualFeed[] = {

            { 0, IDS_MANUAL_CX, IDI_MANUAL_CX,  0, 0, 0   },
            { 0, IDS_MANUAL_CY, IDI_MANUAL_CY, 0, 0, 0   }
        };

OPDATA  OPHTSetup = {

            0,
            PI_OFF(ExtraData) + sizeof(DEVHTINFO),
            IDI_CPSUI_HALFTONE_SETUP,
            PUSHBUTTON_TYPE_HTSETUP,
            0,
            0
        };


OIDATA  PPOIData[] = {

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        PP_FORMTRAY_ASSIGN,
        TVOT_NONE,
        IDS_CPSUI_FORMTRAYASSIGN,
        IDI_CPSUI_FORMTRAYASSIGN,
        IDH_FORMTRAYASSIGN,
        0,
        NULL
    },

    {
        ODF_RASTER | ODF_ROLLFEED | ODF_CALLBACK | ODF_CALLCREATEOI,
        0,
        OI_LEVEL_2,
        PP_INSTALLED_FORM,
        TVOT_LISTBOX,
        IDS_ROLLFEED,
        OTS_LBCB_SORT,
        IDH_FORM_ROLL_FEEDER,
        0,
        (POPDATA)CreateFormOI
    },

    {
        ODF_RASTER | ODF_MANUAL_FEED | ODF_CALLBACK | ODF_CALLCREATEOI,
        0,
        OI_LEVEL_2,
        PP_INSTALLED_FORM,
        TVOT_LISTBOX,
        IDS_MANUAL_FEEDER,
        OTS_LBCB_SORT,
        IDH_FORM_MANUAL_FEEDER,
        0,
        (POPDATA)CreateFormOI
    },

    {
        ODF_PEN | ODF_CALLBACK | ODF_CALLCREATEOI,
        0,
        OI_LEVEL_2,
        PP_INSTALLED_FORM,
        TVOT_LISTBOX,
        IDS_MAINFEED,
        OTS_LBCB_SORT,
        IDH_FORM_MAIN_FEEDER,
        0,
        (POPDATA)CreateFormOI
    },

    {
        ODF_PEN_RASTER | ODF_CALLBACK | ODF_NO_PAPERTRAY,
        0,
        OI_LEVEL_3,
        PP_MANUAL_FEED_METHOD,
        TVOT_2STATES,
        IDS_MANUAL_FEED_METHOD,
        0,
        IDH_MANUAL_FEED_METHOD,
        COUNT_ARRAY(OPManualFeed),
        OPManualFeed
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_1,
        PP_PRINT_FORM_OPTIONS,
        TVOT_NONE,
        IDS_PRINT_FORM_OPTIONS,
        IDI_CPSUI_GENERIC_OPTION,
        IDH_PRINT_FORM_OPTIONS,
        0,
        NULL
    },

    {
        ODF_PEN_RASTER | ODF_ROLLFEED,
        0,
        OI_LEVEL_2,
        PP_AUTO_ROTATE,
        TVOT_2STATES,
        IDS_AUTO_ROTATE,
        0,
        IDH_AUTO_ROTATE,
        2,
        OPAutoRotate
    },

    {
        ODF_PEN_RASTER,
        0,
        OI_LEVEL_2,
        PP_PRINT_SMALLER_PAPER,
        TVOT_2STATES,
        IDS_PRINT_SAMLLER_PAPER,
        0,
        IDH_PRINT_SMALLER_PAPER,
        2,
        OPPrintSmallerPaper
    },

    {
        ODF_RASTER,
        0,
        OI_LEVEL_1,
        PP_HT_SETUP,
        TVOT_PUSHBUTTON,
        IDS_CPSUI_HALFTONE_SETUP,
        0,
        IDH_HALFTONE_SETUP,
        1,
        &OPHTSetup
    },

    {
        ODF_PEN | ODF_INC_IDSNAME | ODF_NO_INC_POPDATA,
        0,
        OI_LEVEL_1,
        PP_INSTALLED_PENSET,
        TVOT_LISTBOX,
        IDS_INSTALLED_PENSET,
        OTS_LBCB_SORT,
        IDH_INSTALLED_PENSET,
        PRK_MAX_PENDATA_SET,
        &OPPenSet
    },

    {
        ODF_PEN | ODF_COLLAPSE | ODF_CALLCREATEOI,
        0,
        OI_LEVEL_1,
        PP_PEN_SETUP,
        TVOT_NONE,
        IDS_PEN_SETUP,
        IDI_PEN_SETUP,
        IDH_PEN_SETUP,
        1,
        (POPDATA)CreatePenSetupOI
    }
};




DWORD
CheckPenSetButton(
    PPRINTERINFO    pPI,
    DWORD           Action
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    30-Nov-1995 Thu 16:41:05 created  -by-  DC


Revision History:


--*/

{
    POPTITEM    pOptItem = pPI->pOptItem;
    POPTITEM    pEndItem = pOptItem + pPI->cOptItem;

    PLOTDBG(DBG_CHK_PENSET_BUTTON,
            ("CheckPenSetButton: pFirst=%08lx, pLast=%08lx, Count=%ld",
            pOptItem, pEndItem, pPI->cOptItem));

    while (pOptItem < pEndItem) {

        if (pOptItem->DMPubID == PP_PENSET) {

            PPENDATA    pPD;
            POPTITEM    pOI;
            DWORD       Flags;
            UINT        i;


            pOI   = pOptItem + 1;
            pPD   = (PPENDATA)pPI->pPlotGPC->Pens.pData;
            i     = (UINT)pPI->pPlotGPC->MaxPens;
            Flags = (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE);

            while (i--) {

                if (pOI->Sel != pPD->ColorIdx) {

                    Flags &= ~(OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE);
                }

                pOI++;
                pPD++;
            }

            if ((Flags & (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE)) !=
                (pOptItem->Flags & (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE))) {

                Action           = CPSUICB_ACTION_REINIT_ITEMS;
                pOptItem->Flags &= ~(OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE);
                pOptItem->Flags |= (Flags | OPTIF_CHANGED);
            }

            pOptItem = pOI;

        } else {

            pOptItem++;
        }
    }

    return(Action);
}



DWORD
CheckInstalledForm(
    PPRINTERINFO    pPI,
    DWORD           Action
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    30-May-1996 Thu 12:34:00 created  -by-  DC


Revision History:


--*/

{
    POPTITEM    pOIForm;
    POPTITEM    pOIFeed;
    POPTITEM    pOITemp;
    POPTPARAM   pOP;
    FORM_INFO_1 *pFI1;
    DWORD       MFFlags;
    DWORD       PSPFlags;
    DWORD       ARFlags;


    if ((pOIForm = FindOptItem(pPI->pOptItem,
                              pPI->cOptItem,
                              PP_INSTALLED_FORM))   &&
        (pOIFeed = FindOptItem(pPI->pOptItem,
                              pPI->cOptItem,
                              PP_MANUAL_FEED_METHOD))) {

        pOP = pOIForm->pOptType->pOptParam + pOIForm->Sel;

        switch (pOP->Style) {

        case FS_ROLLPAPER:
        case FS_TRAYPAPER:

            MFFlags = OPTIF_DISABLED;
            break;

        default:

            pFI1 = pPI->pFI1Base + pOP->lParam;

            if ((pFI1->Size.cx > pPI->pPlotGPC->DeviceSize.cx) ||
                (pFI1->Size.cy > pPI->pPlotGPC->DeviceSize.cx)) {

                MFFlags = (OPTIF_OVERLAY_STOP_ICON | OPTIF_DISABLED);

            } else {

                MFFlags = 0;
            }

            break;
        }

        if ((pOIFeed->Flags & (OPTIF_OVERLAY_STOP_ICON |
                               OPTIF_DISABLED)) != MFFlags) {

            pOIFeed->Flags &= ~(OPTIF_OVERLAY_STOP_ICON | OPTIF_DISABLED);
            pOIFeed->Flags |= (MFFlags | OPTIF_CHANGED);
            Action          = CPSUICB_ACTION_OPTIF_CHANGED;
        }

        if (pOP->Style & FS_ROLLPAPER) {

            ARFlags  = 0;
            PSPFlags = OPTIF_DISABLED;

        } else {

            ARFlags  = OPTIF_DISABLED;
            PSPFlags = 0;
        }

        if ((pOITemp = FindOptItem(pPI->pOptItem,
                                   pPI->cOptItem,
                                   PP_PRINT_SMALLER_PAPER))  &&
            ((pOITemp->Flags & OPTIF_DISABLED) != PSPFlags)) {

            pOITemp->Flags &= ~OPTIF_DISABLED;
            pOITemp->Flags |= (PSPFlags | OPTIF_CHANGED);
            Action          = CPSUICB_ACTION_OPTIF_CHANGED;
        }

        if ((pOITemp = FindOptItem(pPI->pOptItem,
                                   pPI->cOptItem,
                                   PP_AUTO_ROTATE))  &&
            ((pOITemp->Flags & OPTIF_DISABLED) != ARFlags)) {

            pOITemp->Flags &= ~OPTIF_DISABLED;
            pOITemp->Flags |= (ARFlags | OPTIF_CHANGED);
            Action          = CPSUICB_ACTION_OPTIF_CHANGED;
        }
    }

    return(Action);
}



UINT
SetupPPOptItems(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    16-Nov-1995 Thu 14:15:25 created  -by-  DC


Revision History:


--*/

{
    POPTITEM    pOIForm;
    POPTITEM    pOptItem;
    POPTITEM    pOI;
    POIDATA     pOIData;
    WORD        PPFlags;
    DWORD       Flags;
    DWORD       ODFlags;
    UINT        i;



    pOI      =
    pOptItem = pPI->pOptItem;
    pOIData  = PPOIData;
    i        = (UINT)COUNT_ARRAY(PPOIData);
    Flags    = pPI->pPlotGPC->Flags;
    PPFlags  = pPI->PPData.Flags;
    ODFlags  = (Flags & PLOTF_RASTER) ? ODF_RASTER : ODF_PEN;

    while (i--) {

        DWORD   OIFlags = pOIData->Flags;

        if ((!(OIFlags & ODFlags))                                      ||
            ((OIFlags & ODF_MANUAL_FEED) &&
                        (Flags & (PLOTF_ROLLFEED | PLOTF_PAPERTRAY)))   ||
            ((OIFlags & ODF_ROLLFEED) && (!(Flags & PLOTF_ROLLFEED)))   ||
            ((OIFlags & ODF_NO_PAPERTRAY) && (Flags & PLOTF_PAPERTRAY)) ||
            ((OIFlags & ODF_COLOR) && (!(Flags & PLOTF_COLOR)))) {

            //
            // Nothing to do here
            //

            NULL;

        } else if (OIFlags & ODF_CALLCREATEOI) {

            pOI += pOIData->pfnCreateOI(pPI,
                                        (LPVOID)((pOptItem) ? pOI : NULL),
                                        pOIData);

        } else if (pOptItem) {

            if (CreateOPTTYPE(pPI, pOI, pOIData, pOIData->cOPData, NULL)) {

                switch (pOI->DMPubID) {

                case PP_MANUAL_FEED_METHOD:

                    pOI->Sel = (LONG)((PPFlags & PPF_MANUAL_FEED_CX) ? 0 : 1);
                    break;

                case PP_AUTO_ROTATE:

                    pOI->Sel = (LONG)((PPFlags & PPF_AUTO_ROTATE) ? 1 : 0);
                    break;

                case PP_PRINT_SMALLER_PAPER:

                    pOI->Sel = (LONG)((PPFlags & PPF_SMALLER_FORM) ? 1 : 0);
                    break;

                case PP_INSTALLED_PENSET:

                    pOI->Sel = (LONG)pPI->IdxPenSet;
                    break;
                }

                pOI++;
            }

        } else {

            pOI++;
        }

        pOIData++;
    }

    if ((i = (UINT)(pOI - pOptItem)) && (!pOptItem)) {

        if (pPI->pOptItem = (POPTITEM)LocalAlloc(LPTR, sizeof(OPTITEM) * i)) {

            pPI->cOptItem = (WORD)i;

            //
            // Call myself second time to really create it
            //

            SetupPPOptItems(pPI);

            CheckInstalledForm(pPI, 0);
            CheckPenSetButton(pPI, 0);

        } else {

            i = 0;

            PLOTERR(("GetPPpOptItem(): LocalAlloc(%ld) failed",
                                            sizeof(OPTITEM) * i));
        }
    }

    return(i);
}



VOID
SavePPOptItems(
    PPRINTERINFO    pPI
    )

/*++

Routine Description:

    This function save all the device options back to registry if one changed
    and has a update permission


Arguments:

    pPI     - Pointer to the PRINTERINFO


Return Value:

    VOID


Author:

    06-Nov-1995 Mon 18:05:16 created  -by-  DC


Revision History:


--*/

{
    POPTITEM        pOptItem;
    POPTITEM        pLastItem;
    PDEVHTINFO      pAdjHTInfo;
    PCOLORINFO      pCI;
    LPDWORD         pHTPatSize;
    LPDWORD         pDevPelsDPI;
    PPAPERINFO      pCurPaper;
    LPBYTE          pIdxPen;
    WORD            PPFlags;
    BYTE            DMPubID;


    pCI         = NULL;
    pHTPatSize  = NULL;
    pDevPelsDPI = NULL;
    pCurPaper   = NULL;
    pIdxPen     = NULL;


    if (!(pPI->Flags & PIF_UPDATE_PERMISSION)) {

        return;
    }

    pOptItem  = pPI->pOptItem;
    pLastItem = pOptItem + pPI->cOptItem - 1;

    while (pOptItem <= pLastItem) {

        if ((DMPubID = pOptItem->DMPubID) == PP_PEN_SETUP) {

            pOptItem = SavePenSet(pPI, pOptItem);

        } else {

            if (pOptItem->Flags & OPTIF_CHANGEONCE) {

                switch (DMPubID) {

                case PP_INSTALLED_FORM:

                    if (GetFormSelect(pPI, pOptItem)) {

                        pCurPaper = &(pPI->CurPaper);
                    }

                    break;

                case PP_MANUAL_FEED_METHOD:

                    if (pOptItem->Sel) {

                        pPI->PPData.Flags &= ~PPF_MANUAL_FEED_CX;

                    } else {

                        pPI->PPData.Flags |= PPF_MANUAL_FEED_CX;
                    }

                    break;

                case PP_AUTO_ROTATE:

                    if (pOptItem->Sel) {

                        pPI->PPData.Flags |= PPF_AUTO_ROTATE;

                    } else {

                        pPI->PPData.Flags &= ~PPF_AUTO_ROTATE;
                    }

                    break;

                case PP_PRINT_SMALLER_PAPER:

                    if (pOptItem->Sel) {

                        pPI->PPData.Flags |= PPF_SMALLER_FORM;

                    } else {

                        pPI->PPData.Flags &= ~PPF_SMALLER_FORM;
                    }

                    break;

                case PP_HT_SETUP:

                    pAdjHTInfo  = PI_PADJHTINFO(pPI);
                    pCI         = &(pAdjHTInfo->ColorInfo);
                    pDevPelsDPI = &(pAdjHTInfo->DevPelsDPI);
                    pHTPatSize  = &(pAdjHTInfo->HTPatternSize);
                    break;

                case PP_INSTALLED_PENSET:

                    pPI->IdxPenSet = (BYTE)pOptItem->Sel;
                    pIdxPen        = (LPBYTE)&(pPI->IdxPenSet);
                    break;
                }
            }

            pOptItem++;
        }
    }

    if (!SaveToRegistry(pPI->hPrinter,
                        pCI,
                        pDevPelsDPI,
                        pHTPatSize,
                        pCurPaper,
                        &(pPI->PPData),
                        pIdxPen,
                        0,
                        NULL)) {

        PlotUIMsgBox(NULL, IDS_PP_NO_SAVE, MB_ICONSTOP | MB_OK);
    }
}



CPSUICALLBACK
PPCallBack(
    PCPSUICBPARAM   pCPSUICBParam
    )

/*++

Routine Description:

    This is the callback function from the common property sheet UI


Arguments:

    pCPSUICBParam   - Pointer to the CPSUICBPARAM data structure to describe
                      the nature of the callback


Return Value:

    LONG


Author:

    07-Nov-1995 Tue 15:15:02 created  -by-  DC


Revision History:


--*/

{
    POPTITEM        pCurItem = pCPSUICBParam->pCurItem;
    POPTITEM        pItem;
    PPRINTERINFO    pPI = (PPRINTERINFO)pCPSUICBParam->UserData;
    POPTPARAM       pOP;
    DWORD           Flags;
    UINT            i;
    WORD            Reason = pCPSUICBParam->Reason;
    LONG            Action = CPSUICB_ACTION_NONE;



    if (Reason == CPSUICB_REASON_APPLYNOW) {

        PRINTER_INFO_7  PI7;

        SavePPOptItems(pPI);

        pCPSUICBParam->Result = CPSUI_OK;
        Action                = CPSUICB_ACTION_ITEMS_APPLIED;

        PI7.pszObjectGUID = NULL;
        PI7.dwAction      = DSPRINT_UPDATE;

        SetPrinter(pPI->hPrinter, 7, (LPBYTE)&PI7, 0);

    } else if (Reason == CPSUICB_REASON_ITEMS_REVERTED) {

        Action = CheckInstalledForm(pPI, Action);
        Action = CheckPenSetButton(pPI, Action);

    } else {

        switch (pCurItem->DMPubID) {

        case PP_PENSET:

            if ((Reason == CPSUICB_REASON_EXTPUSH)          ||
                (Reason == CPSUICB_REASON_OPTITEM_SETFOCUS)) {

                PPENDATA    pPD;

                pPI   = (PPRINTERINFO)pCPSUICBParam->UserData;
                pPD   = (PPENDATA)pPI->pPlotGPC->Pens.pData;
                i     = (UINT)pPI->pPlotGPC->MaxPens;
                pItem = pCurItem++;

                if (Reason == CPSUICB_REASON_EXTPUSH) {

                    while (i--) {

                        pCurItem->Sel    = pPD->ColorIdx;
                        pCurItem->Flags |= OPTIF_CHANGED;

                        pCurItem++;
                        pPD++;
                    }

                    pItem->Flags |= (OPTIF_EXT_DISABLED |
                                     OPTIF_EXT_HIDE     |
                                     OPTIF_CHANGED);
                    Action        = CPSUICB_ACTION_REINIT_ITEMS;

                } else {

                    Action = CheckPenSetButton(pPI, Action);
                }
            }

            break;

        case PP_INSTALLED_FORM:

            if ((Reason == CPSUICB_REASON_SEL_CHANGED) ||
                (Reason == CPSUICB_REASON_OPTITEM_SETFOCUS)) {

                Action = CheckInstalledForm(pPI, Action);
            }

            break;

        default:

            break;
        }
    }

    return(Action);
}



LONG
DrvDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    Show document property dialog box and update the output DEVMODE


Arguments:

    pPSUIInfo   - Pointer to the PROPSHEETUI_INFO data structure

    lParam      - LPARAM for this call, it is a pointer to the
                  DEVICEPROPERTYHEADER

Return Value:

    LONG, 1=successful, 0=failed.


Author:

    02-Feb-1996 Fri 10:47:42 created  -by-  DC


Revision History:


--*/

{
    PDEVICEPROPERTYHEADER   pDPHdr;
    PPRINTERINFO            pPI;
    LONG_PTR                Result = -1;

    //
    // The MapPrinter will allocate memory, set default devmode, reading and
    // validating the GPC then update from current pritner registry, it also
    // will cached the pPI.

    if ((!pPSUIInfo) ||
        (!(pDPHdr = (PDEVICEPROPERTYHEADER)pPSUIInfo->lParamInit))) {

        SetLastError(ERROR_INVALID_DATA);
        return(ERR_CPSUI_GETLASTERROR);
    }

    if (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT) {

        if (!(pPI = MapPrinter(pDPHdr->hPrinter,
                               NULL,
                               NULL,
                               MPF_HELPFILE | MPF_DEVICEDATA | MPF_PCPSUI))) {

            PLOTRIP(("DrvDevicePropertySheets: MapPrinter() failed"));

            SetLastError(ERROR_INVALID_DATA);
            return(ERR_CPSUI_GETLASTERROR);
        }

        pPI->Flags               = (pDPHdr->Flags & DPS_NOPERMISSION) ?
                                                    0 : PIF_UPDATE_PERMISSION;
        pPI->pCPSUI->Flags       = 0;
        pPI->pCPSUI->pfnCallBack = PPCallBack;
        pPI->pCPSUI->pDlgPage    = CPSUI_PDLGPAGE_PRINTERPROP;

        //
        // Add form to the database and find out if we can update
        //
        //  Move to DrvPrinterEven()
        //
        //
        // AddFormsToDataBase(pPI, TRUE);
        //

        Result = (LONG_PTR)SetupPPOptItems(pPI);

    } else {

        pPI    = (PPRINTERINFO)pPSUIInfo->UserData;
        Result = (LONG_PTR)pDPHdr->pszPrinterName;
    }

    return(DefCommonUIFunc(pPSUIInfo, lParam, pPI, Result));
}



BOOL
PrinterProperties(
    HWND    hWnd,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    This function first retrieves and displays the current set of printer
    properties for the printer.  The user is allowed to change the current
    printer properties from the displayed dialog box.

Arguments:

    hWnd        - Handle to the caller's window (parent window)

    hPrinter    - Handle to the pritner interested


Return Value:

    TRUE if function sucessful FALSE if failed


Author:

    06-Dec-1993 Mon 11:21:28 created  -by-  DC


Revision History:


--*/

{
    PRINTER_INFO_4          *pPI4;
    DEVICEPROPERTYHEADER    DPHdr;
    LONG                    Result = CPSUI_CANCEL;


    pPI4 = (PRINTER_INFO_4 *)GetPrinterInfo(hPrinter, 4);

    DPHdr.cbSize         = sizeof(DPHdr);
    DPHdr.Flags          = 0;
    DPHdr.hPrinter       = hPrinter;
    DPHdr.pszPrinterName = (pPI4) ? pPI4->pPrinterName : NULL;

    CallCommonPropertySheetUI(hWnd,
                              DrvDevicePropertySheets,
                              (LPARAM)&DPHdr,
                              (LPDWORD)&Result);

    if (pPI4) {

        LocalFree((HLOCAL)pPI4);
    }

    return(Result == CPSUI_OK);
}




BOOL
DrvPrinterEvent(
    LPWSTR  pPrinterName,
    INT     Event,
    DWORD   Flags,
    LPARAM  lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    08-May-1996 Wed 17:38:34 created  -by-  DC


Revision History:

    04-Jun-1996 Tue 14:51:25 updated  -by-  DC
        Matched a ClosePrinter() to OpenPrinter()


--*/

{
    PRINTER_DEFAULTS    PrinterDef = { NULL, NULL, PRINTER_ALL_ACCESS };
    HANDLE              hPrinter;
    BOOL                bRet = TRUE;


    switch (Event) {

    case PRINTER_EVENT_INITIALIZE:

        if (OpenPrinter(pPrinterName, &hPrinter, &PrinterDef)) {

            PPRINTERINFO    pPI;

            if (pPI = MapPrinter(hPrinter, NULL, NULL, MPF_DEVICEDATA)) {

                bRet = AddFormsToDataBase(pPI, FALSE);

                UnMapPrinter(pPI);
            }

            ClosePrinter(hPrinter);
        }

        break;

    default:

        break;
    }

    return(bRet);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\qryprint.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    qryprint.c


Abstract:

    This module contains functions called by the spoller to determine if a
    particular job can be print to a given printer


Author:

    07-Dec-1993 Tue 00:48:24 created  -by-  DC


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgQryPrint

extern HMODULE  hPlotUIModule;


#define DBG_DEVQPRINT       0x00000001
#define DBG_FORMDATA        0x00000002

DEFINE_DBGVAR(0);


#define USER_PAPER          (DM_PAPERWIDTH | DM_PAPERLENGTH | DM_PAPERSIZE)
#define MAX_ERROR_CHARS     512



UINT
cdecl
DQPsprintf(
    HINSTANCE   hInst,
    LPWSTR      pwBuf,
    DWORD       cchBuf,
    LPDWORD     pcchNeeded,
    LPWSTR      pwszFormat,
    ...
    )

/*++

Routine Description:

    This fucntion output the debug informat to the debugger


Arguments:

    hInst       - handle to the driver's instance (hModule)

    pwBuf       - Pointer to the WCHAR buffer for the output

    cchBuf      - Count of characters pointed by the pwBuf, this includs
                  the NULL terminator

    pcchBuf     - pointer to the a DWORD to received total characteers needed
                  for pwBuf (includes null terminator).  If this pointer is
                  NULL then no data is returned.

    pwszFormat  - pointer to WCHAR format string, the introduce character is
                  '%' and it may followed by a format character of following

                    %c = a WCHAR
                    %s = Insert a unicode string.
                    %d = convert to long integer
                    %u = convert to DWORD
                    %x = Convert to lower case hex, 10 = a
                    %X = Convert to upper case hex, 10 = A
                    %! = Load the resource ID unicode string


    ...         - variable data, each one must be pushed as a 32-bit data


Return Value:

    Count of total characters put into the pwBuf. (not includes the null
    terminator).


Author:

    08-Feb-1996 Thu 00:53:36 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define MAX_CUR_TEXT_CHARS      256

    va_list vaList;
    LPWSTR  pwStrData;
    LPWSTR  pwEndBuf;
    LPWSTR  pwBufOrg;
    WCHAR   c;
    WCHAR   CurText[MAX_CUR_TEXT_CHARS];
    DWORD   cchNeeded;
    UINT    i;
    static const LPWSTR pNumFmt[] = { L"%lX", L"%lx", L"%lu", L"%ld" };


    va_start(vaList, pwszFormat);

    //
    // pwEndBuf = the last character, cchNeeded is start with one since it
    // includes a null terminator
    //

    if (pwBufOrg = pwBuf) {

        pwEndBuf = (pwBuf + cchBuf - 1);

    } else {

        pwEndBuf = pwBuf;
    }

    cchNeeded = 1;

    while (c = *pwszFormat++) {

        pwStrData = NULL;
        i = 1;

        if (c == L'%') {

            pwStrData = CurText;
            i         = 0;

            switch (c = *pwszFormat++) {

            case L's':

                pwStrData = (LPWSTR)va_arg(vaList, LPWSTR);
                break;

            case L'd':  // Index = 3

                ++i;

            case L'u':  // Index = 2

                ++i;

            case L'x':  // Index = 1

                ++i;

            case L'X':  // Index = 0;

                wsprintf(pwStrData, pNumFmt[i], (DWORD)va_arg(vaList, DWORD));
                i = 0;
                break;

            case '!':

                //
                // %! = load the string from resource ID
                //

                //
                // The LoadString will append a NULL too
                //

                if (!LoadString(hInst,
                                (UINT)va_arg(vaList, UINT),
                                pwStrData,
                                MAX_CUR_TEXT_CHARS)) {

                    // If we can't read the string, put and empty string here.
                    pwStrData[0] = L'\0';
                }
                break;

            case L'c':

                c = (WCHAR)va_arg(vaList, WCHAR);

                //
                // Fall through
                //

            default:

                pwStrData = NULL;
                i         = 1;
                break;
            }
        }

        if (!i) {

            if (pwStrData) {

                i = lstrlen(pwStrData);

            } else {

                c = L' ';
                i = 0;
            }
        }

        cchNeeded += i;

        if (pwBuf < pwEndBuf) {

            if (pwStrData) {

                lstrcpyn(pwBuf, pwStrData, (int)(pwEndBuf - pwBuf + 1));
                pwBuf += lstrlen(pwBuf);

            } else {

                *pwBuf++ = c;
            }

        } else if (!pcchNeeded) {

            break;
        }
    }

    if (pwEndBuf) {

        *pwEndBuf = L'\0';
    }

    if (pcchNeeded) {

        *pcchNeeded = cchNeeded;
    }

    va_end(vaList);

    return((UINT)(pwBuf - pwBufOrg));


#undef MAX_CUR_TEXT_CHARS
}




BOOL
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
    )

/*++

Routine Description:

   This routine determines whether or not the driver can print the job
   described by pDevMode on the printer described by hPrinter


Arguments:

    pDQPInfo    - Pointer to DEVQUERYPRINT_INFO data structure

        typedef struct _DEVQUERYPRINT_INFO {
            WORD    cbSize;         // size of this structure in bytes
            WORD    Level;          // Level of this info, 1 for this version
            HANDLE  hPrinter;       // handle to the printer for the query
            DEVMODE *pDevMode;      // pointer to the DEVMODE for this job.
            LPTSTR  pszErrorStr;    // pointer to the error string buffer.
            WORD    cchErrorStr;    // count characters of pszErrorStr passed.
            WORD    cchNeeded;      // count characters of pszErrorStr needed.
            } DEVQUERYPRINT_INFO, *PDEVQUERYPRINT_INFO;


        cbSize      - size of this structure

        Level       - This must be one (1) for this version of structure

        hPrinter    - Identifies the printer on which the job is to be printed.

        pDevMode    - Points to the DEVMODE structure that describes the print
                      job that is to be determined as printable or
                      non-printable by hPrinter.  The driver should always
                      validate the DEVMODE structure whenever it is passed in.

        pszErrorStr - This is the pointer to a null terminated unicode string
                      which to stored the reason for non-printable job. If the
                      job is printable then it return TRUE.  If the job
                      is non-printable then it return FALSE,  and a null
                      terminated unicode string pointed by the pszErrorStr for
                      the reason by this job is not printable.  The size of
                      this buffer in characters is specified by the cchErrorStr.

        cchErrorStr - Specified the size of pszErrorStr in characters (includs
                      null terminator) when calling this function.  If an error
                      string is returned due to the non-printable job (returned
                      FALSE), the driver will set ccchNeeded to the total
                      characters (includes null terminator) required for the
                      pszErrorStr,  in this case the driver must always
                      truncate the error string to fit into the pwErrorStr
                      (only if it is not NULL) passed up to the cchErrorStr
                      characters passed.

        cchNeeded   - When driver returned FALSE, it specified total characters
                      required for the pszErrorStr.  If cchNeeded returned
                      from the driver is larger then the cchErrorStr then it
                      indicate the passed pszErrorStr is too small to hold the
                      full error string, in this case the driver must always
                      truncate the error string to fit into the pszErrorStr
                      passed up to the cchErrorStr size.

Return Value:

    BOOLEAN - TRUE  - The job is printable and should not be hold.
              FALSE - The job is not printable and cchNeeded in the
                      DEVQUERYPRINT_INFO data structure specified total
                      characters required for the pszErrorStr.  If returned
                      cchNeeded is greater then cchErrorStr passed then it
                      indicated that pszErrorStr is too small for storing the
                      error string, in this case the driver must always
                      truncate the error string to fit into the pszErrorStr
                      passed, up to the cchErrorStr characters.

    *Note*

        The driver should have some predefined generic resource error strings
        for some possible known errors. such as memroy allocation error, data
        file not found, invalid devmode,... for returning non devmode related
        errors.  The caller can pre-allocated larger buffer (such as 256
        wchars) for storing the error string rather than calling this function
        twice.

Author:

    07-Feb-1996 Wed 20:37:31 created  -by-  DC


Revision History:


--*/

{
    PPRINTERINFO    pPI = NULL;
    LONG            ErrorResID = 0;
    static WCHAR    wFormat1[] = L"<%s> %!";

    //
    // if it passed a NULL DEVMODE then we just honor it to said can print
    //

    pDQPInfo->cchNeeded = 0;
    ErrorResID          = IDS_FORM_NOT_AVAI;

    if (!pDQPInfo->pDevMode) {

        PLOTWARN(("DevQueryPrint: No DEVMODE passed, CANNOT PRINT"));

        ErrorResID = IDS_INVALID_DATA;

    } else if (!(pPI = MapPrinter(pDQPInfo->hPrinter,
                                  (PPLOTDEVMODE)pDQPInfo->pDevMode,
                                  (LPDWORD)&ErrorResID,
                                  MPF_DEVICEDATA))) {

        //
        // The MapPrinter will allocate memory, set default devmode, reading
        // and validating the GPC then update from current pritner registry,
        //

        PLOTRIP(("DevQueryPrint: MapPrinter() failed"));

    } else if (pPI->dmErrBits & (USER_PAPER | DM_FORMNAME)) {

        //
        // We encounter some errors, and the form has been set to default
        //

        PLOTWARN(("DevQueryPrint: CAN'T PRINT, dmErrBits=%08lx (PAPER/FORM)",
                   pPI->dmErrBits));

    } else if ((pPI->PlotDM.dm.dmFields & DM_FORMNAME) &&
               (wcscmp(pPI->CurPaper.Name, pPI->PlotDM.dm.dmFormName) == 0)) {

        //
        // We can print this form now
        //

        ErrorResID = 0;

        PLOTDBG(DBG_DEVQPRINT, ("DevQueryPrint: Match FormName=%s",
                                                pPI->PlotDM.dm.dmFormName));

    } else if ((!pPI->CurPaper.Size.cy)                                   ||
               (((pPI->PlotDM.dm.dmFields & USER_PAPER) == USER_PAPER) &&
                (pPI->PlotDM.dm.dmPaperSize == DMPAPER_USER))             ||
               (pPI->PPData.Flags & PPF_SMALLER_FORM)) {

        LONG    lTmp;
        SIZEL   szl;
        BOOL    VarLenPaper;

        //
        // 1. If we have ROLL PAPER Installed OR
        // 2. User Defined Paper Size
        // 3. User said OK to print smaller form then installed one
        //
        // THEN we want to see if it can fit into the device installed form
        //

        szl.cx = DMTOSPL(pPI->PlotDM.dm.dmPaperWidth);
        szl.cy = DMTOSPL(pPI->PlotDM.dm.dmPaperLength);

        if (VarLenPaper = (BOOL)!pPI->CurPaper.Size.cy) {

            pPI->CurPaper.Size.cy = pPI->pPlotGPC->DeviceSize.cy;
        }

        PLOTDBG(DBG_DEVQPRINT,
                ("DevQueryPrint: CurPaper=%ldx%ld, Req=%ldx%ld, VarLen=%ld",
                pPI->CurPaper.Size.cx,  pPI->CurPaper.Size.cy,
                szl.cx, szl.cy, VarLenPaper));

        //
        // One of Following conditions met in that sequence then we can print
        // the form on loaded paper
        //
        // 1. Same size (PORTRAIT or LANDSCAPE)
        // 2. Larger Size (PORTRAIT or LANDSCAPE)   AND
        //    Not a variable length paper           AND
        //    PPF_SAMLLER_FORM flag set
        //

        if ((pPI->CurPaper.Size.cx < szl.cx) ||
            (pPI->CurPaper.Size.cy < szl.cy)) {

            //
            // Swap this so we can do one easier comparsion later
            //

            SWAP(szl.cx, szl.cy, lTmp);
        }

        if ((pPI->CurPaper.Size.cx >= szl.cx) &&
            (pPI->CurPaper.Size.cy >= szl.cy)) {

            if ((!VarLenPaper)                          &&
                (!(pPI->PPData.Flags & PPF_SMALLER_FORM)) &&
                ((pPI->CurPaper.Size.cx > szl.cx)  ||
                 (pPI->CurPaper.Size.cy > szl.cy))) {

                PLOTDBG(DBG_DEVQPRINT,
                        ("DevQueryPrint: CAN'T PRINT: user DO NOT want print on larger paper"));

            } else {

                PLOTDBG(DBG_DEVQPRINT,
                        ("DevQueryPrint: Paper Size FITS in DEVICE, %ld x %ld",
                        szl.cx, szl.cy));

                ErrorResID = 0;
            }

        } else {

            DQPsprintf((HINSTANCE)hPlotUIModule,
                       pDQPInfo->pszErrorStr,
                       pDQPInfo->cchErrorStr,
                       &(pDQPInfo->cchNeeded),
                       wFormat1,
                       pPI->PlotDM.dm.dmFormName,
                       IDS_FORM_TOO_BIG);

            PLOTDBG(DBG_DEVQPRINT,
                    ("DevQueryPrint: CAN'T PRINT: Form Size too small"));
        }
    }

    PLOTDBG(DBG_DEVQPRINT, ("DevQueryPrint: %s PRINT %s",
                (ErrorResID) ? "CAN'T" : "OK to", pPI->PlotDM.dm.dmFormName));

    if ((!pDQPInfo->cchNeeded) && (ErrorResID)) {

        switch (ErrorResID) {

        case IDS_FORM_NOT_AVAI:

            DQPsprintf((HINSTANCE)hPlotUIModule,
                       pDQPInfo->pszErrorStr,
                       pDQPInfo->cchErrorStr,
                       &(pDQPInfo->cchNeeded),
                       wFormat1,
                       pPI->PlotDM.dm.dmFormName,
                       IDS_FORM_NOT_AVAI);

            break;

        default:

            DQPsprintf((HINSTANCE)hPlotUIModule,
                       pDQPInfo->pszErrorStr,
                       pDQPInfo->cchErrorStr,
                       &(pDQPInfo->cchNeeded),
                       L"%!",
                       ErrorResID);
            break;
        }
    }

    //
    // Unget the printer GPC mapping if we got one
    //

    if (pPI) {

        UnMapPrinter(pPI);
    }

    return((!ErrorResID) && (!pDQPInfo->cchNeeded));
}


#if 0


BOOL
WINAPI
DevQueryPrint(
    HANDLE  hPrinter,
    DEVMODE *pDM,
    DWORD   *pdwErrIDS
    )

/*++

Routine Description:

   This routine determines whether or not the driver can print the job
   described by pDevMode on the printer described by hPrinter. If if can, it
   puts zero into pdwErrIDS.  If it cannot, it puts the resource id of the
   string describing why it could not.

Arguments:

    hPrinter    - Handle to the printer to be checked

    pDM         - Point to the DEVMODE passed in

    pdwErrIDS   - Point the the DWORD to received resource string ID number for
                  the error.


Return Value:

   This routine returns TRUE for success, FALSE for failure.

   when it return TRUE, the *pdwErrIDS determine if it can print or not, if
   *pdwErrIDS == 0, then it can print else it contains the string ID for the
   reason why it can not print.


Author:

    07-Dec-1993 Tue 00:50:32 created  -by-  DC

    14-Jun-1994 Tue 22:43:36 updated  -by-  DC
        Make installed RollPaper always print if the size is reasonable


Revision History:


--*/

{
    PPRINTERINFO    pPI = NULL;


    //
    // if it passed a NULL DEVMODE then we just honor it to said can print
    //

    if (!pDM) {

        PLOTWARN(("DevQueryPrint: No DEVMODE passed, CANNOT PRINT"));

        *pdwErrIDS = IDS_INV_DMSIZE;
        return(TRUE);
    }

    if (!(pPI = MapPrinter(hPrinter,
                           (PPLOTDEVMODE)pDM,
                           pdwErrIDS,
                           MPF_DEVICEDATA))) {

        //
        // The MapPrinter will allocate memory, set default devmode, reading
        // and validating the GPC then update from current pritner registry,
        //

        PLOTRIP(("DevQueryPrint: MapPrinter() failed"));

        return(TRUE);
    }

    //
    // Assume this error
    //

    *pdwErrIDS = IDS_FORM_NOT_AVAI;

    if (pPI->dmErrBits & (USER_PAPER | DM_FORMNAME)) {

        //
        // We encounter some errors, and the form has been set to default
        //

        PLOTWARN(("DevQueryPrint: CAN'T PRINT, dmErrBits=%08lx (PAPER/FORM)",
                   pPI->dmErrBits));

    } else if ((pPI->PlotDM.dm.dmFields & DM_FORMNAME) &&
               (wcscmp(pPI->CurPaper.Name, pPI->PlotDM.dm.dmFormName) == 0)) {

        //
        // We can print this form now
        //

        *pdwErrIDS = 0;

        PLOTDBG(DBG_DEVQPRINT, ("DevQueryPrint: Match FormName=%s",
                                                pPI->PlotDM.dm.dmFormName));


    } else if ((!pPI->CurPaper.Size.cy)                                   ||
               (((pPI->PlotDM.dm.dmFields & USER_PAPER) == USER_PAPER) &&
                (pPI->PlotDM.dm.dmPaperSize == DMPAPER_USER))             ||
               (pPI->PPData.Flags & PPF_SMALLER_FORM)) {

        LONG    lTmp;
        SIZEL   szl;
        BOOL    VarLenPaper;

        //
        // 1. If we have ROLL PAPER Installed OR
        // 2. User Defined Paper Size
        // 3. User said OK to print smaller form then installed one
        //
        // THEN we want to see if it can fit into the device installed form
        //

        szl.cx = DMTOSPL(pPI->PlotDM.dm.dmPaperWidth);
        szl.cy = DMTOSPL(pPI->PlotDM.dm.dmPaperLength);

        if (VarLenPaper = (BOOL)!pPI->CurPaper.Size.cy) {

            pPI->CurPaper.Size.cy = pPI->pPlotGPC->DeviceSize.cy;
        }

        PLOTDBG(DBG_DEVQPRINT,
                ("DevQueryPrint: CurPaper=%ldx%ld, Req=%ldx%ld, VarLen=%ld",
                pPI->CurPaper.Size.cx,  pPI->CurPaper.Size.cy,
                szl.cx, szl.cy, VarLenPaper));

        //
        // One of Following conditions met in that sequence then we can print
        // the form on loaded paper
        //
        // 1. Same size (PORTRAIT or LANDSCAPE)
        // 2. Larger Size (PORTRAIT or LANDSCAPE)   AND
        //    Not a variable length paper           AND
        //    PPF_SAMLLER_FORM flag set
        //

        if ((pPI->CurPaper.Size.cx < szl.cx) ||
            (pPI->CurPaper.Size.cy < szl.cy)) {

            //
            // Swap this so we can do one easier comparsion later
            //

            SWAP(szl.cx, szl.cy, lTmp);
        }

        if ((pPI->CurPaper.Size.cx >= szl.cx) &&
            (pPI->CurPaper.Size.cy >= szl.cy)) {

            if ((!VarLenPaper)                          &&
                (!(pPI->PPData.Flags & PPF_SMALLER_FORM)) &&
                ((pPI->CurPaper.Size.cx > szl.cx)  ||
                 (pPI->CurPaper.Size.cy > szl.cy))) {

                PLOTDBG(DBG_DEVQPRINT,
                        ("DevQueryPrint: CAN'T PRINT: user DO NOT want print on larger paper"));

            } else {

                PLOTDBG(DBG_DEVQPRINT,
                        ("DevQueryPrint: Paper Size FITS in DEVICE, %ld x %ld",
                        szl.cx, szl.cy));

                *pdwErrIDS = 0;
            }

        } else {

            PLOTDBG(DBG_DEVQPRINT,
                    ("DevQueryPrint: CAN'T PRINT: Form Size too small"));
        }
    }

    PLOTDBG(DBG_DEVQPRINT, ("DevQueryPrint: %s PRINT %s",
                (*pdwErrIDS) ? "CAN'T" : "OK to", pPI->PlotDM.dm.dmFormName));

    //
    // Unget the printer GPC mapping if we got one
    //

    UnMapPrinter(pPI);

    return(TRUE);
}


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\plotui\upgrade.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    upgrade.c


Abstract:

    This module contains upgrade functions


Author:

    09-Feb-1996 Fri 12:37:01 created  -by-  DC


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/



#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgUpgrade

extern HMODULE  hPlotUIModule;


#define DBG_UPGRADE         0x00000001

DEFINE_DBGVAR(0);


BOOL
DrvUpgradePrinter(
    DWORD   Level,
    LPBYTE  pDriverUpgradeInfo
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Feb-1996 Fri 12:37:46 created  -by-  DC


Revision History:


--*/

{
    PDRIVER_UPGRADE_INFO_1  pDUI1;
    HANDLE                  hPrinter;
    PRINTER_DEFAULTS        PrinterDef = { NULL, NULL, PRINTER_ALL_ACCESS };
    BOOL                    Ok = FALSE;

    if ((Level == 1)                                            &&
        (pDUI1 = (PDRIVER_UPGRADE_INFO_1)pDriverUpgradeInfo)    &&
        (OpenPrinter(pDUI1->pPrinterName, &hPrinter, &PrinterDef))) {

        PPRINTERINFO    pPI;

        if (pPI = MapPrinter(hPrinter, NULL, NULL, MPF_DEVICEDATA)) {

            Ok = AddFormsToDataBase(pPI, TRUE);

            UnMapPrinter(pPI);
        }

        ClosePrinter(hPrinter);

    } else {

        PLOTERR(("DrvConvertDevMode: OpenPrinter(%ws) failed.",
                                                pDUI1->pPrinterName));
        SetLastError(ERROR_INVALID_DATA);
    }

    return(Ok);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\rendps\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    DbgPrint(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPTSTR OEMDevMode_fMode[] = {   __TEXT("NULL"),
                                    __TEXT("OEMDM_SIZE"),
                                    __TEXT("OEMDM_DEFAULT"),
                                    __TEXT("OEMDM_CONVERT"),
                                    __TEXT("OEMDM_MERGE"),
                                };

    DbgPrint(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]);

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DbgPrint(__TEXT("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DbgPrint(__TEXT("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DbgPrint(__TEXT("\tcbSize = %d.\r\n"), pOEMDevModeParam->cbSize);
        DbgPrint(__TEXT("\thPrinter = %#lx.\r\n"), pOEMDevModeParam->hPrinter);
        DbgPrint(__TEXT("\thModule = %#lx.\r\n"), pOEMDevModeParam->hModule);
        DbgPrint(__TEXT("\tpPublicDMIn = %#lx.\r\n"), pOEMDevModeParam->pPublicDMIn);
        DbgPrint(__TEXT("\tpPublicDMOut = %#lx.\r\n"), pOEMDevModeParam->pPublicDMOut);
        DbgPrint(__TEXT("\tpOEMDMIn = %#lx.\r\n"), pOEMDevModeParam->pOEMDMIn);
        DbgPrint(__TEXT("\tpOEMDMOut = %#lx.\r\n"), pOEMDevModeParam->pOEMDMOut);
        DbgPrint(__TEXT("\tcbBufSize = %d.\r\n"), pOEMDevModeParam->cbBufSize);
    }
}


#ifndef DBG
ULONG _cdecl MyDbgPrint(
    PCSTR   pwstr, 
    ...)
{
    return 1;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\rendps\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Pscript OEM test dll's.

Environment:

         Windows NT Pscript driver

Revision History:

              Created it.

--*/


extern "C" {
#include "pdev.h"
#include "..\inc\name.h"
}
#include <initguid.h>
#include <prcomoem.h>
#include <assert.h>

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks


#include "comoem.h"

extern "C"
DWORD
PSCommand(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pData,
    DWORD   cbSize,
    PTSTR  *ppStr);


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
IOemCB::~IOemCB()
{
    // Make sure that helper interface is released.
    if(NULL != this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == this->m_cRef);
}

HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        DbgPrint(DLLTEXT("IOemcB::QueryInterface IUnknown.")) ; 
    }
    else if (iid == IID_IPrintOemPS)
    {
        *ppv = static_cast<IPrintOemPS*>(this) ;
        DbgPrint(DLLTEXT("IOemcB::QueryInterface IPrintOemPs.")) ; 
    }
    else
    {
        *ppv = NULL ;
        DbgPrint(DLLTEXT("IOemcB::QueryInterface NULL.")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    DbgPrint(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    DbgPrint(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

HRESULT __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    DbgPrint(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
    OEMEnableDriver(dwDriverVersion, cbSize, pded);

    return S_OK;
}

HRESULT __stdcall IOemCB::DisableDriver(VOID)
{
    DbgPrint(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
    OEMDisableDriver();

    if(this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
}

HRESULT __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    DbgPrint(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverPS, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    DbgPrint(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    return S_OK;
};

HRESULT __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    DbgPrint(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    return S_OK;
}


HRESULT __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    DbgPrint(DLLTEXT("IOemCB::ResetPDEV() entry.\r\n"));
    OEMResetPDEV(pdevobjOld, pdevobjNew);
    return S_OK;
}

HRESULT __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    DbgPrint(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}

#if 0
HRESULT __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    DbgPrint(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    return OEMDevMode(dwMode, pOemDMParam);
}
#endif

HRESULT __stdcall IOemCB::Command(
    PDEVOBJ     pdevobj,
    DWORD       dwIndex,
    PVOID       pData,
    DWORD       cbSize,
    OUT DWORD   *pdwResult)
{
    DWORD dwResult;
    PTSTR ptstrStr;

    DbgPrint(DLLTEXT("IOemCB::Command() entry.\r\n"));
    dwResult = 0;;
    *pdwResult = PSCommand(pdevobj, dwIndex, pData, cbSize, &ptstrStr);
    pOEMHelp->DrvWriteSpoolBuf(pdevobj, ptstrStr, *pdwResult, &dwResult);

    if (dwResult == *pdwResult)
        return S_OK;
    else
        return S_FALSE;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
#undef INTERFACE
#define INTERFACE IOemCF
DECLARE_INTERFACE_(IOemCF, IClassFactory)
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
   
    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
//    ~IOemCF() {DbgPrint(DLLTEXT("IOemCFt\tDestroy self.")); };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{    
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ; 
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release() 
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock) 
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ; 
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//

#if 0
BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;

    // pOemCB->AddRef();    // shouldn't do this since constructor already sets m_cRef=1

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}
#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //DbgPrint(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

#if 0
//
// Server registration
//


// Friendly name of component
const char g_szFriendlyName[] = "Pscript Plugin Rendering callbak test";

// Version-independent ProgID
const char g_szVerIndProgID[] = "Pscript.Plugin.Rendering.callbak.test";

// ProgID
const char g_szProgID[] = "Pscript.Plugin.Rendering.callbak.test.1";



STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule, 
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID) ;
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\rendps\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H
#define _WIN32_WINNT 0x0500
#include "oemud.h"

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'RNPS'      // Raster module callback test dll
#define DLLTEXT(s)      __TEXT("RENDPS:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    DWORD     dwReserved[1];

} OEMPDEV, *POEMPDEV;


#ifndef DBG
#define DbgPrint    MyDbgPrint
ULONG _cdecl MyDbgPrint(PCSTR, ...);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\rendps\oemud.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       OEMUD.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//                              for OEMUD Test Module.
//
//  PLATFORMS:
//    Windows NT 5.0
//
//
#ifndef _OEMUD_H
#define _OEMUD_H

#include <lib.h>
#include <printoem.h>



////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;


////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\rendps\enable.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    enable.c

Abstract:

    Implementation of OEM DDI exports.
        OEMEnablePDEV (required)
        OEMDisablePDEV (required)
        OEMResetPDEV (optional)

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;


    DbgPrint(DLLTEXT("OEMEnablePDEV() entry.\r\n"));

    //
    // Allocate the OEMDev
    //
    if (!(poempdev = MemAlloc(sizeof(OEMPDEV))))
        return NULL;

    //
    // Fill in OEMDEV as you need
    //

    poempdev->dwReserved[0] = 0xFFFFFFFF;


    return (POEMPDEV) poempdev;
}


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
    DbgPrint(DLLTEXT("OEMDisablePDEV() entry.\r\n"));

    //ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM);

    //
    // free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    //
    MemFree(pdevobj->pdevOEM);

}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    DbgPrint(DLLTEXT("OEMResetPDEV() entry.\r\n"));

    //ASSERT(VALID_PDEVOBJ(pdevobjOld) && pdevobjOld->pdevOEM);
    //ASSERT(VALID_PDEVOBJ(pdevobjNew) && pdevobjOld->pdevOEM);

    //
    // if you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\rendps\comoem.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all PostScript OEM test dll's.

Environment:

         Windows NT PostScript driver

Revision History:

              Created it.

--*/


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB
//
class IOemCB:public IPrintOemPS
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);


    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);
    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam) { return E_NOTIMPL;};

    //
    // OEMCommand - PSCRIPT only, return E_NOTIMPL on Unidrv
    //

    STDMETHOD(Command) (THIS_ PDEVOBJ     pdevobj,
                              DWORD       dwIndex,
                              PVOID       pData,
                              DWORD       cbSize,
                              OUT DWORD   *pdwResult);

    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
//    ~IOemCB() {DbgPrint(DLLTEXT("IOemCB:\t\tDestroy self.")); };
    ~IOemCB();

protected:
    IPrintOemDriverPS* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\rendps\ps.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ps.c

Abstract:


Environment:

    Windows NT PostScript driver

Revision History:


    mm/dd/yy -author-
        description

--*/

#include "pdev.h"


//
// Global variables
//

char gcstrTest_BEGINSTREAM[]   = "%%Test: Before begin stream\r\n";
char gcstrTest_PSADOBE[]       = "%%Test: Before %!PS-Adobe\r\n";
char gcstrTest_COMMENTS[]      = "%%Test: Before %%EndComments\r\n";
char gcstrTest_DEFAULTS[]      = "%%Test: Before %%BeginDefaults and %%EndDefaults\r\n";
char gcstrTest_BEGINPROLOG[]   = "%%Test: After %%BeginProlog\r\n";
char gcstrTest_ENDPROLOG[]     = "%%Test: Before %%EndProlog\r\n";
char gcstrTest_BEGINSETUP[]    = "%%Test: After %%BeginSetup\r\n";
char gcstrTest_ENDSETUP[]      = "%%Test: Before %%EndSetup\r\n";
char gcstrTest_BEGINPAGESETUP[]= "%%Test: After %%BeginPageSetup\r\n";
char gcstrTest_ENDPAGESETUP[]  = "%%Test: Before %%EndpageSetup\r\n";
char gcstrTest_PAGETRAILER[]   = "%%Test: After %%PageTrailer\r\n";
char gcstrTest_TRAILER[]       = "%%Test: After %%Trailer\r\n";
char gcstrTest_PAGES[]         = "%%Test: Replace driver's %%Pages: (atend)\r\n";
char gcstrTest_PAGENUMBER[]    = "%%Test: Replace driver's %%Page:\r\n";
char gcstrTest_PAGEORDER[]     = "%%Test: Replace driver's %%PageOrder:\r\n";
char gcstrTest_ORIENTATION[]   = "%%Test: Replace driver's %%Orientation:\r\n";
char gcstrTest_BOUNDINGBOX[]   = "%%Test: Replace driver's %%BoundingBox:\r\n";
char gcstrTest_DOCNEEDEDRES[]  = "%%Test: Append to driver's %%DocumentNeededResourc\r\n";
char gcstrTest_DOCSUPPLIEDRES[]= "%%Test: Append to driver's %%DocumentSuppliedResou\r\n";
char gcstrTest_EOF[]           = "%%Test: After %%EOF\r\n";
char gcstrTest_ENDSTREAM[]     = "%%Test: After the last byte of job stream\r\n";
char gcstrTest_VMSAVE[]        = "%%Test: VMSave\r\n";
char gcstrTest_VMRESTORE[]     = "%%Test: VMRestore\n";

VOID APIENTRY OEMDisableDriver()
{
        DbgPrint(DLLTEXT("OEMDisableDriver() entry.\r\n"));
}


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    // DbgPrint(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // Validate paramters.
    if( (PRINTER_OEMINTF_VERSION != dwOEMintfVersion)
        ||
        (sizeof(DRVENABLEDATA) > dwSize)
        ||
        (NULL == pded)
      )
    {
        //  DbgPrint(DLLTEXTERRORTEXT("OEMEnableDriver() ERROR_INVALID_PARAMETER.\r\n"));

        return FALSE;
    }

    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION ; //   not  DDI_DRIVER_VERSION;
    pded->c = 0;

    return TRUE;
}


DWORD
PSCommand(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pData,
    DWORD   cbSize,
    PTSTR  *ppStr)
/*++

Routine Description:

    The PSCRIPT driver calls this OEM function at specific points during output
    generation. This gives the OEM DLL an opportunity to insert code fragments
    at specific injection points in the driver's code. It should use
    DrvWriteSpoolBuf for generating any output it requires.


Arguments:

    pdevobj -
    dwIndex
    pData
    dwSize


Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PBYTE  pProcedure;
    DbgPrint(DLLTEXT("Entering OEMCommand...\n"));

    switch (dwIndex)
    {
    case PSINJECT_BEGINSTREAM:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_BEGINSTREAM\n"));
        pProcedure = gcstrTest_BEGINSTREAM;
        break;

    case PSINJECT_PSADOBE:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_PSADOBE\n"));
        pProcedure = gcstrTest_PSADOBE;
        break;

    case PSINJECT_COMMENTS:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_COMMENTS\n"));
        pProcedure = gcstrTest_COMMENTS;
        break;

    case PSINJECT_BEGINPROLOG:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_BEGINPROLOG\n"));
        pProcedure = gcstrTest_BEGINPROLOG;
        break;

    case PSINJECT_ENDPROLOG:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_ENDPROLOG\n"));
        pProcedure = gcstrTest_ENDPROLOG;
        break;

    case PSINJECT_BEGINSETUP:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_BEGINSETUP\n"));
        pProcedure = gcstrTest_BEGINSETUP;
        break;

    case PSINJECT_ENDSETUP:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_ENDSETUP\n"));
        pProcedure = gcstrTest_ENDSETUP;
        break;

    case PSINJECT_BEGINPAGESETUP:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_BEGINPAGESETUP\n"));
        pProcedure = gcstrTest_BEGINPAGESETUP;
        break;

    case PSINJECT_ENDPAGESETUP:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_ENDPAGESETUP\n"));
        pProcedure = gcstrTest_ENDPAGESETUP;
        break;

    case PSINJECT_PAGETRAILER:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_PAGETRAILER\n"));
        pProcedure = gcstrTest_PAGETRAILER;
        break;

    case PSINJECT_TRAILER:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_TRAILER\n"));
        pProcedure = gcstrTest_TRAILER;
        break;

    case PSINJECT_PAGES:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_PAGES\n"));
        pProcedure = gcstrTest_PAGES;
        break;

    case PSINJECT_PAGENUMBER:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_PAGENUMBER\n"));
        pProcedure = gcstrTest_PAGENUMBER;
        break;

    case PSINJECT_PAGEORDER:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_PAGEORDER\n"));
        pProcedure = gcstrTest_PAGEORDER;
        break;

    case PSINJECT_ORIENTATION:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_ORIENTATION\n"));
        pProcedure = gcstrTest_ORIENTATION;
        break;

    case PSINJECT_BOUNDINGBOX:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_BOUNDINGBOX\n"));
        pProcedure = gcstrTest_BOUNDINGBOX;
        break;

    case PSINJECT_DOCNEEDEDRES:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_DOCNEEDEDRES\n"));
        pProcedure = gcstrTest_DOCNEEDEDRES;
        break;

    case PSINJECT_DOCSUPPLIEDRES:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_DOCSUPPLIEDRES\n"));
        pProcedure = gcstrTest_DOCSUPPLIEDRES;
        break;

    case PSINJECT_EOF:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_EOF\n"));
        pProcedure = gcstrTest_EOF;
        break;

    case PSINJECT_ENDSTREAM:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_ENDSTREAM\n"));
        pProcedure = gcstrTest_ENDSTREAM;
        break;

    case PSINJECT_VMSAVE:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_VMSAVE\n"));
        pProcedure = gcstrTest_VMSAVE;
        break;

    case PSINJECT_VMRESTORE:
        DbgPrint(DLLTEXT("OEMCommand PSINJECT_VMRESTORE\n"));
        pProcedure = gcstrTest_VMRESTORE;
        break;

    default:
        DbgPrint(DLLTEXT("Entering No...\n"));
        pProcedure = NULL;

    }

    *ppStr = pProcedure;
    if (pProcedure)
        return strlen(pProcedure);
    else
        return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\rendps\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUD.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\cmdcb.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//
// command callback ID's for "test.gpd"
//
#define CMDCB_SELECTPORTRAIT    1
#define CMDCB_SELECTLANDSCAPE   2
#define CMDCB_SENDBLOCKDATA     3


static  int
iDwtoA( LPSTR buf, DWORD n )
{
    int     i, j;

    for( i = 0; n; i++ )
    {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ )
    {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}


INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    DbgPrint(DLLTEXT("OEMCommandCallback() entry.\r\n"));

    //
    // fill in printer commands
    //
    switch (dwCmdCbID)
    {
    case CMDCB_SELECTPORTRAIT:
        //pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, "\x1B&l0O", 5);
        break;

    case CMDCB_SELECTLANDSCAPE:
        //pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, "\x1B&l1O", 5);
        break;

    case CMDCB_SENDBLOCKDATA:
    {
        //
        // this command requires one parameter. Compose the string first.
        //
        BYTE    abSBDCmd[16];
        INT     i = 0;

        if (dwCount < 1 || !pdwParams)
            return 0;       // cannot do anything

        abSBDCmd[i++] = '\x1B';
        abSBDCmd[i++] = '*';
        abSBDCmd[i++] = 'b';
        i += iDwtoA(&abSBDCmd[i], *pdwParams);
        abSBDCmd[i++] = 'W';

        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, abSBDCmd, i);

        break;
    }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    DbgPrint(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPTSTR OEMDevMode_fMode[] = {   __TEXT("NULL"),
                                    __TEXT("OEMDM_SIZE"),
                                    __TEXT("OEMDM_DEFAULT"),
                                    __TEXT("OEMDM_CONVERT"),
                                    __TEXT("OEMDM_MERGE"),
                                };

    DbgPrint(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]);

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DbgPrint(__TEXT("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DbgPrint(__TEXT("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DbgPrint(__TEXT("\tcbSize = %d.\r\n"), pOEMDevModeParam->cbSize);
        DbgPrint(__TEXT("\thPrinter = %#lx.\r\n"), pOEMDevModeParam->hPrinter);
        DbgPrint(__TEXT("\thModule = %#lx.\r\n"), pOEMDevModeParam->hModule);
        DbgPrint(__TEXT("\tpPublicDMIn = %#lx.\r\n"), pOEMDevModeParam->pPublicDMIn);
        DbgPrint(__TEXT("\tpPublicDMOut = %#lx.\r\n"), pOEMDevModeParam->pPublicDMOut);
        DbgPrint(__TEXT("\tpOEMDMIn = %#lx.\r\n"), pOEMDevModeParam->pOEMDMIn);
        DbgPrint(__TEXT("\tpOEMDMOut = %#lx.\r\n"), pOEMDevModeParam->pOEMDMOut);
        DbgPrint(__TEXT("\tcbBufSize = %d.\r\n"), pOEMDevModeParam->cbBufSize);
    }
}

#ifndef DBG
ULONG _cdecl MyDbgPrint(
    PCSTR   pwstr, 
    ...)
{
    return 1;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

extern "C" {
#include "pdev.h"
#include "..\inc\name.h"
}
#include <initguid.h>
#include <prcomoem.h>
#include <assert.h>

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
IOemCB::~IOemCB()
{
    // Make sure that helper interface is released.
    if(NULL != this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == this->m_cRef);
}

HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    DbgPrint(DLLTEXT("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        DbgPrint(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ; 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        DbgPrint(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ; 
    }
    else
    {
        *ppv = NULL ;
        DbgPrint(DLLTEXT("IOemCB:Return NULL.\n")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    DbgPrint(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    DbgPrint(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

HRESULT __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    DbgPrint(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
    OEMEnableDriver(dwDriverVersion, cbSize, pded);

    return S_OK;
}

HRESULT __stdcall IOemCB::DisableDriver(VOID)
{
    DbgPrint(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
    OEMDisableDriver();
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
}

HRESULT __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    DbgPrint(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    DbgPrint(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
}

HRESULT __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    DbgPrint(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    OEMDisablePDEV(pdevobj);
    return S_OK;
};

HRESULT __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    DbgPrint(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


HRESULT __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    DbgPrint(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    DbgPrint(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
#if 0
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
#if 0
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'I':
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'M':
#if 0
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'O':
#if 0
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

#if 0
            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;
#endif

            case (WCHAR)'T':
#if 0
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
#endif
                break;
        }
    }

    if (lReturn)
    {
        DbgPrint(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        DbgPrint(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

HRESULT __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    DbgPrint(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
#if 0 // Disable DevMode
    OEMDevMode(dwMode, pOemDMParam);
    return S_OK;
#else
    return E_NOTIMPL;
#endif
}


HRESULT __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    DbgPrint(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    DbgPrint(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    DbgPrint(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    return E_NOTIMPL;
}

HRESULT __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    DbgPrint(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
                        dwCallbackID, pIPParams))
        return S_OK;
    else
        return S_FALSE;
}

HRESULT __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    DbgPrint(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    if (dwResult == dwLen)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    DbgPrint(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


HRESULT __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    DbgPrint(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    DbgPrint(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    DbgPrint(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));
    //*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);

    return E_NOTIMPL;
}

HRESULT __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    DbgPrint(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));
    //*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);

    return E_NOTIMPL;
}

HRESULT __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    DbgPrint(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));
    //*pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);

    return E_NOTIMPL;
}

HRESULT __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    DbgPrint(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));
    //OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return E_NOTIMPL;
}

HRESULT __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    DbgPrint(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    //OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    //return S_OK;
    return E_NOTIMPL;
}

HRESULT __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    DbgPrint(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    DbgPrint(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    DbgPrint(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
#undef INTERFACE
#define INTERFACE IOemCF
DECLARE_INTERFACE_(IOemCF, IClassFactory)
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
//    ~IOemCF() {DbgPrint(DLLTEXT("IOemCFt\tDestroy self.")); };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //DbgPrint(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID) ;
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\ddihooks.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    ddihooks.c

Abstract:

    Implementation of OEM DDI hooks (all drawing DDI hooks)

    This test DLL hooks out every DDI call. In reality, an OEM DLL does
    not need to hook out every DDI unless there is a reason to. The only two
    required functions are OEMEnablePDEV and OEMDisablePDEV, which must be
    exported.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMBitBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTrg->dhpdev;

    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvBitBlt)(poempdev->pfnUnidrv[UD_DrvBitBlt])) (
           psoTrg,
           psoSrc,
           psoMask,
           pco,
           pxlo,
           prclTrg,
           pptlSrc,
           pptlMask,
           pbo,
           pptlBrush,
           rop4));

}

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStretchBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;


    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStretchBlt)(poempdev->pfnUnidrv[UD_DrvStretchBlt])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode));

}

//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStretchBltROP() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStretchBltROP)(poempdev->pfnUnidrv[UD_DrvStretchBltROP])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode,
            pbo,
            rop4
            ));


}

//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMCopyBits() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvCopyBits)(poempdev->pfnUnidrv[UD_DrvCopyBits])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            pptlSrc));

}

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMPlgBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvPlgBlt)(poempdev->pfnUnidrv[UD_DrvPlgBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlBrushOrg,
            pptfixDest,
            prclSrc,
            pptlMask,
            iMode));

}

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMAlphaBlend() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvAlphaBlend)(poempdev->pfnUnidrv[UD_DrvAlphaBlend])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            prclSrc,
            pBlendObj
            ));

}

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
        SURFOBJ    *psoDest,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        TRIVERTEX  *pVertex,
        ULONG       nVertex,
        PVOID       pMesh,
        ULONG       nMesh,
        RECTL      *prclExtents,
        POINTL     *pptlDitherOrg,
        ULONG       ulMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMGradientFill() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvGradientFill)(poempdev->pfnUnidrv[UD_DrvGradientFill])) (
            psoDest,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode
            ));

}

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMTextOut() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvTextOut)(poempdev->pfnUnidrv[UD_DrvTextOut])) (
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix));

}

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStokePath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStrokePath)(poempdev->pfnUnidrv[UD_DrvStrokePath])) (
            pso,
            ppo,
            pco,
            pxo,
            pbo,
            pptlBrushOrg,
            plineattrs,
            mix));

}

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvFillPath)(poempdev->pfnUnidrv[UD_DrvFillPath])) (
            pso,
            ppo,
            pco,
            pbo,
            pptlBrushOrg,
            mix,
            flOptions));

}

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStrokeAndFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStrokeAndFillPath)(poempdev->pfnUnidrv[UD_DrvStrokeAndFillPath])) (
            pso,
            ppo,
            pco,
            pxo,
            pboStroke,
            plineattrs,
            pboFill,
            pptlBrushOrg,
            mixFill,
            flOptions));

}

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStrokeAndFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTarget->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into Unidrv since Unidrv doesn't hook it.
    //

    //
    // In this test DLL, the drawing hooks does not call EngRealizeBrush. So this
    // this function will never be called. Do nothing.
    //

    return TRUE;
}

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStartPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartPage)(poempdev->pfnUnidrv[UD_DrvStartPage]))(pso));

}

#define OEM_TESTSTRING  "The DDICMDCB DLL adds this line of text."

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMEndPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // print a line of text, just for testing
    //
    if (pso->iType == STYPE_BITMAP)
    {
        pdevobj->pDrvProcs->DrvXMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvYMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, OEM_TESTSTRING,
                                             sizeof(OEM_TESTSTRING));
    }

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvSendPage)(poempdev->pfnUnidrv[UD_DrvSendPage]))(pso));

}

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMEscape() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvEscape)(poempdev->pfnUnidrv[UD_DrvEscape])) (
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStartDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartDoc)(poempdev->pfnUnidrv[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));

}

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMEndDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvEndDoc)(poempdev->pfnUnidrv[UD_DrvEndDoc])) (
            pso,
            fl));

}

////////
// NOTE:
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG       iFile,
    ULONG       iFace,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMQueryFont() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvQueryFont)(poempdev->pfnUnidrv[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));

}

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG       iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMQueryFontTree() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvQueryFontTree)(poempdev->pfnUnidrv[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));

}

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMQueryFontData() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryFontData)(poempdev->pfnUnidrv[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));

}

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMQueryAdvanceWidths() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnUnidrv[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));

}

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMFontManagement() entry.\r\n"));

    //
    // Note that Unidrv will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvFontManagement)(poempdev->pfnUnidrv[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMGetGlyphMode() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvGetGlyphMode)(poempdev->pfnUnidrv[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));

}

BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMNextBand() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvNextBand)(poempdev->pfnUnidrv[UD_DrvNextBand])) (
            pso,
            pptl));

}

BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStartBanding() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartBanding)(poempdev->pfnUnidrv[UD_DrvStartBanding])) (
            pso,
            pptl));


}

ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMDitherColor() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvDitherColor)(poempdev->pfnUnidrv[UD_DrvDitherColor])) (
            dhpdev,
            iMode,
            rgbColor,
            pulDither));

}

BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMPaint() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvPaint)(poempdev->pfnUnidrv[UD_DrvPaint])) (
            pso,
            pco,
            pbo,
            pptlBrushOrg,
            mix));

}

BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMLineTo() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvLineTo)(poempdev->pfnUnidrv[UD_DrvLineTo])) (
            pso,
            pco,
            pbo,
            x1,
            y1,
            x2,
            y2,
            prclBounds,
            mix));

}

BOOL APIENTRY
OEMTransparentBlt(
        SURFOBJ    *psoDst,
        SURFOBJ    *psoSrc,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        RECTL      *prclDst,
        RECTL      *prclSrc,
        ULONG      iTransColor,
        ULONG      ulReserved
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMTransparentBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvTransparentBlt)(poempdev->pfnUnidrv[UD_DrvTransparentBlt])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            iTransColor,
            ulReserved
            ));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\oemud.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       OEMUD.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//                              for OEMUD Test Module.
//
//  PLATFORMS:
//    Windows NT 5.0
//
//
#ifndef _OEMUD_H
#define _OEMUD_H

#include <lib.h>
#include <printoem.h>



////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;


////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\msplot\tools\ntres\plotgpc.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    plotgpc.c


Abstract:

    This module contains the function to generate plotter gpc data for
    NT 1.0a
    This module contains the functions required to generate a plotter gpc
    data file.

Author:

    15-Feb-1994 Tue 22:50:10 updated  -by-  DC
        Add bitmap font caps

    09-Nov-1993 Tue 09:23:48 created  -by-  DC

    18-Mar-1994 Fri 14:00:14 updated  -by-  DC
        Adding PLOTF_RTL_NO_DPI_XY, PLOTF_RTLMONO_NO_CID and
        PLOTF_RTLMONO_FIXPAL flags


[Environment:]

    GDI Device Driver - PLOTTER


[Notes:]


Revision History:


--*/


#if 0

;
; Plotter GPC data file format
;
;  1. All key value(s) for the keyword must be encloses by a {} brace pair.
;  2. Any Strings must be enclosed by quotes ("").
;  3. a ';' denotes a comment to the end of the current line.
;  4. Types
;      a. FLAG      - 1 or 0
;      b. WORD      - 16 bit number
;      c. DWORD     - 32 bit number
;      d. STRING    - ANSI character string, maximum size depends on keyword
;      e. FORMSRC   - 1. 31 byte string for the name of the form (paper source)
;                     2. 2 DWORDs: size width/height (SIZEL) 1/1000mm
;                           ** if height is <= 25400 (1 inch) or it greater
;                              then DeviceSize CY then it is assumed that
;                              the form is variable length and the height
;                              will be reset to zero (0)
;
;                     3. 4 DWORDs: Left/Top/Right/Bottom margins in 1/1000mm
;
;      f. CONSTANT  - Pick from a set of predefined strings in the header file
;      g. COLORINFO - Windows NT DDI COLORINFO data structure (30 DWORDs)
;      h. PENDATA   - 1. One word that specifies the location in the carousel
;                        of this pen (1=slot 1, 2=slot 2).
;                     2. constant which specifies the predefined pen color
;                        PC_IDX_xxxx can be one of:
;
;                        Index            R   G   B
;                       ------------------------------
;                       PC_IDX_WHITE     255 255 255
;                       PC_IDX_BLACK       0   0   0
;                       PC_IDX_RED       255   0   0
;                       PC_IDX_GREEN       0 255   0
;                       PC_IDX_YELLOW    255 255   0
;                       PC_IDX_BLUE        0   0 255
;                       PC_IDX_MAGENTA   255   0 255
;                       PC_IDX_CYAN        0 255 255
;                       PC_IDX_ORANGE    255 128   0
;                       PC_IDX_BROWN     255 192   0
;                       PC_IDX_VIOLET    128   0 255
;
;       i. ROPLEVEL - One of following levels:
;
;                       ROP_LEVEL_0 - No Rop support
;                       ROP_LEVEL_1 - ROP1 support (SRC)
;                       ROP_LEVEL_2 - ROP2 support (SRC/DEST)
;                       ROP_LEVEL_3 - ROP3 support (SRC/DEST/PAT)
;
;  *** if DeviceSize' height is <= 25400 (1 inch) then it is assumed that the
;      device can handle variable length paper and the height will be reset to
;      zero (0)
;
;  *** RasterDPI must be defined for both raster and pen plotters. For raster
;      plotters this should be the raster resolution of the device. For pen
;      plotters it should be the ideal resolution for the device that GDI
;      will report back to the calling windows application.
;
;  Keyword              Type    Count          Range/Size
; -------------------------------------------------------------------------
;  DeviceName           STRING    31           Device name as it appears in UI's
;  DeviceSize           DWORD     2            Device cx/cy in 1/1000mm
;  DeviceMargin         DWORD     4            Device L/T/R/B margin in 1/1000mm
;  RasterCap            Flag      1            0/1 (1=Raster Device, 2=Pen Device)
;  ColorCap             Flag      1            0/1 (1=Color Device, 2=Mono)
;  BezierCap            Flag      1            0/1 (1=Device supports HPGL2
;                                                   Beziers extension)
;  RasterByteAlign      Flag      1            0/1 (1=Device must receive all
;                                                   raster data on byte alligned
;                                                   x coordinates)
;  PushPopPal           Flag      1            0/1 (1=Driver must push/pop
;                                                  pallete when switching
;                                                  between RTL / HPGL2)
;  TransparentCap       Flag      1            0/1 (1=Device supports transp. cmd)
;  WindingFillCap       Flag      1            0/1 (1=Device can do winding fills)
;  RollFeedCap          Flag      1            0/1 (1=Device has roll paper src)
;  PaperTrayCap         Flag      1            0/1 has a main paper tray?
;  NoBitmapFont         Flag      1            0/1 Do not do bitmap font
;  RTLMonoEncode5       Flag      1            0/1 RTL Mono Compress Mode 5?
;  RTLNoDPIxy           Flag      1            0/1 NO RTL DPI X,Y Move command
;  RTLMonoNoCID         Flag      1            0/1 RTL Mono No CID command
;  RTLMonoFixPal        Flag      1            0/1 RTL Mono PAL ONLY 0=W, 1=K
;  PlotDPI              DWORD     2            Plotter UNIT X/Y Dots per Inch
;  RasterDPI            WORD      2            Raster (RTL) X/Y Dots per Inch
;  ROPLevel             DWORD     1            0/1/2/3
;  MaxScale             WORD      1            0-10000 (100 times bigger)
;  MaxPens              WORD      1            Device max # of pens for pen plotter
;  MaxCopies            WORD      1            Device max # of copies of each
;                                              page device can render by itself.
;  MaxPolygonPts        WORD      1            Device max # of points when defining
;                                              a polygon to later be stroked or
;                                              filled.
;  MaxQuality           WORD      1            Device maximum quality levels
;  PaperTraySize        DWORD     2            Paper Tray width/height in 1/1000mm
;  COLORINFO            DWORD     30           COLORINFO data structure
;  DevicePelsDPI        DWORD     1            Dots Per Inch
;  HTPatternSize        CONSTANT  1            HT_PATSIZE_xx
;  InitString           STRING    255          Standard string sent to device for
;                                              initialization.
;  PlotPenData          PENDATA   32 (Max)     Pen Plotter's carousel def.
;  FormInfo             FORMSRC   64           Device supported forms
;
; Following are example values for the PLOTTER characterization data:
;

DeviceName      { "HP DesignJet 650C (C2859B)" }; Device Name
DeviceSize      { 914400, 15240000 }            ; Device Size (36" x 50')
DeviceMargin    { 25400, 25400, 5000, 36000 }   ; Device Margin (in 1/1000mm)
RasterCap       { 1 }                           ; Pen/Raster plotter  (0/1)
ColorCap        { 1 }                           ; Color plotter (0/1)
BezierCap       { 1 }                           ; Can do bezier curves (0/1)
RasterByteAlign { 0 }                           ; need to byte aligned (0/1)
PushPopPal      { 1 }                           ; need to push/pop palette (0/1)
TransparentCap  { 0 }                           ; Has transparent mode (0/1)
WindingFillCap  { 0 }                           ; Can do winding fills (0/1)
RollFeedCap     { 1 }                           ; Can do RollPaper feed (0/1)
PaperTrayCap    { 0 }                           ; Has paper input tray (0/1)
NoBitmapFont    { 0 }                           ; Do not do bitmap font
RTLMonoEncode5  { 1 }                           ; RTL Mono Adapt Compression
RTLNoDPIxy      { 0 }                           ; Has RTL DPI XY move comand
RTLMonoNoCID    { 0 }                           ; Has RTL MONO CID Command
RTLMonoFixPal   { 0 }                           ; Can change RTL Palette 0/1
PlotDPI         { 1016, 1016 }                  ; Pen Plotter X/Y DPI
RasterDPI       { 300, 300 }                    ; Raster Plotter X/Y DPI
ROPLevel        { ROP_LEVEL_2 }                 ; ROP levels (0/1/2/3)
MaxScale        { 1600 }                        ; Maximum allowed Scale %
MaxPens         { 256 }                         ; Maximum allowed pens
MaxCopies       { 1 }                           ; Maximum allowed copies
MaxPolygonPts   { 8192 }                        ; Maximum Polygon points
MaxQuality      { 3 }                           ; Maximum quality levels

;
; Only needed if PaperTrayCap = 1,
;
PaperTraySize   { 215900, 279400 }        ; Letter size paper tray
;

COLORINFO       {  6810,  3050,     0,      ; xr, yr, Yr
                   2260,  6550,     0,      ; xg, yg, Yg
                   1810,   500,     0,      ; xb, yb, Yb
                   2000,  2450,     0,      ; xc, yc, Yc
                   5210,  2100,     0,      ; xm, ym, Ym
                   4750,  5100,     0,      ; xy, yy, Yy
                   3324,  3474, 10000,      ; xw, yw, Yw
                  10000, 10000, 10000,      ; RGB gamma
                   1422,   952,   787,      ; Dye correction datas
                    495,   324,   248 }

DevicePelsDPI   { 0 }                       ; effective device DPI (default)
HTPatternSize   { HT_PATSIZE_6x6_M }        ; GDI Halftone pattern size

InitString      { "\033E" }

;
; Only allowed if RasterCap = 0, and must define all pens (MaxPens)
;
; PlotPenData     {  1, PC_WHITE   }
; PlotPenData     {  2, PC_BLACK   }
; PlotPenData     {  3, PC_RED     }
; PlotPenData     {  4, PC_GREEN   }
; PlotPenData     {  5, PC_YELLOW  }
; PlotPenData     {  6, PC_BLUE    }
; PlotPenData     {  7, PC_MAGENTA }
; PlotPenData     {  8, PC_CYAN    }
; PlotPenData     {  9, PC_ORANGE  }
; PlotPenData     { 10, PC_BROWN   }
; PlotPenData     { 11, PC_VIOLET  }
;

FormInfo        { "Roll Paper 24 in",       609600,       0, 0, 0, 0, 0 }
FormInfo        { "Roll Paper 36 in",       914400,       0, 0, 0, 0, 0 }
FormInfo        { "ANSI A 8.5 x 11 in",     215900,  279400, 0, 0, 0, 0 }
FormInfo        { "ANSI B 11 x 17 in",      279400,  431800, 0, 0, 0, 0 }
FormInfo        { "ANSI C 17 x 22 in",      431800,  558800, 0, 0, 0, 0 }
FormInfo        { "ANSI D 22 x 34 in",      558800,  863600, 0, 0, 0, 0 }
FormInfo        { "ANSI E 34 x 44 in",      863600, 1117600, 0, 0, 0, 0 }
FormInfo        { "ISO A4 210 x 297 mm",    210000,  297000, 0, 0, 0, 0 }
FormInfo        { "ISO A3 297 x 420 mm",    297000,  420000, 0, 0, 0, 0 }
FormInfo        { "ISO A2 420 x 594 mm",    420000,  594000, 0, 0, 0, 0 }
FormInfo        { "ISO A1 594 x 841 mm",    594000,  841000, 0, 0, 0, 0 }
FormInfo        { "ISO A0 841 x 1189 mm",   841000, 1189000, 0, 0, 0, 0 }
FormInfo        { "ISO OS A2 480 x 625 mm", 480000,  625000, 0, 0, 0, 0 }
FormInfo        { "ISO OS A1 625 x 900 mm", 625000,  900000, 0, 0, 0, 0 }
FormInfo        { "JIS B4 257 x 364 mm",    257000,  364000, 0, 0, 0, 0 }
FormInfo        { "JIS B3 364 x 515 mm",    364000,  515000, 0, 0, 0, 0 }
FormInfo        { "JIS B2 515 x 728 mm",    515000,  728000, 0, 0, 0, 0 }
FormInfo        { "JIS B1 728 x 1030 mm",   728000, 1030000, 0, 0, 0, 0 }
FormInfo        { "Arch A 9 x 12 in",       228600,  304800, 0, 0, 0, 0 }
FormInfo        { "Arch B 12 x 18 in",      304800,  457200, 0, 0, 0, 0 }
FormInfo        { "Arch C 18 x 24 in",      457200,  609600, 0, 0, 0, 0 }
FormInfo        { "Arch D 24 x 36 in",      609600,  914400, 0, 0, 0, 0 }
FormInfo        { "Arch E 36 x 48 in",      914400, 1219200, 0, 0, 0, 0 }
FormInfo        { "Arch E1 30 x 42 in",     762000, 1066800, 0, 0, 0, 0 }




#endif


#define DBG_PLOTFILENAME    DbgPlotGPC



#include <stddef.h>
#include <windows.h>
#include <winddi.h>
#include <wingdi.h>
#include <winspool.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#include <plotlib.h>

#define DBG_FORM            0x00000001
#define DBG_PAPERTRAY       0x00000002
#define DBG_FULLGPC         0x00000004


DEFINE_DBGVAR(0);


#if DBG
TCHAR   DebugDLLName[] = TEXT("PLOTGPC");
#endif



#define SIZE_ARRAY(a)           (sizeof((a)) / sizeof((a)[0]))
#define SIZE_COLORINFO          (sizeof(COLORINFO) / sizeof(LDECI4))

#define PK_FLAG                 0
#define PK_WORD                 1
#define PK_DWORD                2
#define PK_STRING               3
#define PK_FORMSRC              4
#define PK_PENDATA              5

#define PKF_DEFINED             0x8000
#define PKF_REQ                 0x0001
#define PKF_MUL_OK              0x0002
#define PKF_VARSIZE             0x0004
#define PKF_FS_VARLEN           0x0008
#define PKF_ALL                 0x0010

#define PKF_REQALL              (PKF_REQ | PKF_ALL)
#define PKF_ROLLPAPER           (PKF_MUL_OK | PKF_VARSIZE | PKF_FS_VARLEN)
#define PKF_FORMINFO            (PKF_MUL_OK     |           \
                                 PKF_VARSIZE    |           \
                                 PKF_REQ        |           \
                                 PKF_FS_VARLEN)
#define PKF_PENDATA             (PKF_MUL_OK | PKF_VARSIZE)

#define PLOTOFF(a)              (DWORD)FIELD_OFFSET(PLOTGPC, a)
#define GET_PLOTOFF(pPK)        ((LPBYTE)&PlotGPC + pPK->Data)
#define ADD_PLOTOFF(p, pPK)     ((LPBYTE)(p) + pPK->Data)


//
// The plotval is used to provide a name constant selection.
//

typedef struct _PLOTVAL {
    LPSTR   pValName;
    DWORD   Val;
    } PLOTVAL, *PPLOTVAL;

//
// The keyword parser structure
//

typedef struct _PLOTKEY {
    LPSTR       pKeyword;       // Keyword name
    WORD        KeywordLen;     // Keyword length
    WORD        Flags;          // PKF_xxxx
    WORD        Type;           // PK_xxxx
    SHORT       Count;          // maximum size allowed, < 0 if non-Zero string
    DWORD       Data;           // data
    LPVOID      pInfo;          // extra set of pointer data
    } PLOTKEY, *PPLOTKEY;

//
// Local/Global variables
//

PLOTVAL PenColorVal[PC_IDX_TOTAL + 1] = {

        { "PC_WHITE",   PC_IDX_WHITE    },
        { "PC_BLACK",   PC_IDX_BLACK    },
        { "PC_RED",     PC_IDX_RED      },
        { "PC_GREEN",   PC_IDX_GREEN    },
        { "PC_YELLOW",  PC_IDX_YELLOW   },
        { "PC_BLUE",    PC_IDX_BLUE     },
        { "PC_MAGENTA", PC_IDX_MAGENTA  },
        { "PC_CYAN",    PC_IDX_CYAN     },
        { "PC_ORANGE",  PC_IDX_ORANGE   },
        { "PC_BROWN",   PC_IDX_BROWN    },
        { "PC_VIOLET",  PC_IDX_VIOLET   },
        { NULL,         0xffffffff      }
    };

PLOTVAL ROPLevelVal[ROP_LEVEL_MAX + 2] = {

        { "ROP_LEVEL_0",        ROP_LEVEL_0     },
        { "ROP_LEVEL_1",        ROP_LEVEL_1     },
        { "ROP_LEVEL_2",        ROP_LEVEL_2     },
        { "ROP_LEVEL_3",        ROP_LEVEL_3     },
        { NULL,                 0xffffffff      }
    };

PLOTVAL HTPatSizeVal[] = {

        { "HT_PATSIZE_2x2",     HT_PATSIZE_2x2     },
        { "HT_PATSIZE_2x2_M",   HT_PATSIZE_2x2_M   },
        { "HT_PATSIZE_4x4",     HT_PATSIZE_4x4     },
        { "HT_PATSIZE_4x4_M",   HT_PATSIZE_4x4_M   },
        { "HT_PATSIZE_6x6",     HT_PATSIZE_6x6     },
        { "HT_PATSIZE_6x6_M",   HT_PATSIZE_6x6_M   },
        { "HT_PATSIZE_8x8",     HT_PATSIZE_8x8     },
        { "HT_PATSIZE_8x8_M",   HT_PATSIZE_8x8_M   },
        { "HT_PATSIZE_10x10",   HT_PATSIZE_10x10   },
        { "HT_PATSIZE_10x10_M", HT_PATSIZE_10x10_M },
        { "HT_PATSIZE_12x12",   HT_PATSIZE_12x12   },
        { "HT_PATSIZE_12x12_M", HT_PATSIZE_12x12_M },
        { "HT_PATSIZE_14x14",   HT_PATSIZE_14x14   },
        { "HT_PATSIZE_14x14_M", HT_PATSIZE_14x14_M },
        { "HT_PATSIZE_16x16",   HT_PATSIZE_16x16   },
        { "HT_PATSIZE_16x16_M", HT_PATSIZE_16x16_M },
        { NULL,                 0xffffffff         }
    };


BYTE        InitString[512] = "";
FORMSRC     AvaiForms[64];
PENDATA     AvaiPenData[MAX_PENPLOTTER_PENS];

UINT        MaxKeywordLen      = 0;
UINT        MaxPCValLen        = 0;
CHAR        szFormInfo[]       = "FormInfo";
CHAR        szPenData[]        = "PlotPenData";
CHAR        szPaperTrayCap[]   = "PaperTrayCap";
CHAR        szPaperTraySize[]  = "PaperTraySize";
CHAR        szNoBmpFont[]      = "NoBitmapFont";
CHAR        szRTLMonoEncode5[] = "RTLMonoEncode5";
CHAR        szRTLNoDPIxy[]     = "RTLNoDPIxy";
CHAR        szRTLMonoNoCID[]   = "RTLMonoNoCID";
CHAR        szRTLMonoFixPal[]  = "RTLMonoFixPal";



FILE        *InFile;
FILE        *OutFile;
UINT        LineNo;
CHAR        InFileName[80];
BYTE        LineBuf[1024];



//
// The keys to search / parse
//

PLOTKEY PlotKey[] = {

    { "DeviceName",     0,PKF_REQ,        PK_STRING, (SHORT)CCHDEVICENAME,          PLOTOFF(DeviceName),    NULL         },
    { "DeviceSize",     0,PKF_REQALL,     PK_DWORD,  2,                             PLOTOFF(DeviceSize),    NULL         },
    { "DeviceMargin",   0,PKF_REQALL,     PK_DWORD,  4,                             PLOTOFF(DeviceMargin),  NULL         },
    { "RasterCap",      0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_RASTER,           NULL         },
    { "ColorCap",       0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_COLOR,            NULL         },
    { "BezierCap",      0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_BEZIER,           NULL         },
    { "RasterByteAlign",0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_RASTERBYTEALIGN,  NULL         },
    { "PushPopPal",     0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_PUSHPOPPAL,       NULL         },
    { "TransparentCap", 0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_TRANSPARENT,      NULL         },
    { "WindingFillCap", 0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_WINDINGFILL,      NULL         },
    { "RollFeedCap",    0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_ROLLFEED,         NULL         },
    { szPaperTrayCap,   0,PKF_REQ,        PK_FLAG,   1,                             PLOTF_PAPERTRAY,        NULL         },
    { szNoBmpFont,      0,0,              PK_FLAG,   1,                             PLOTF_NO_BMP_FONT,      NULL         },
    { szRTLMonoEncode5, 0,0,              PK_FLAG,   1,                             PLOTF_RTLMONOENCODE_5,  NULL         },
    { szRTLNoDPIxy,     0,0,              PK_FLAG,   1,                             PLOTF_RTL_NO_DPI_XY,    NULL         },
    { szRTLMonoNoCID,   0,0,              PK_FLAG,   1,                             PLOTF_RTLMONO_NO_CID,   NULL         },
    { szRTLMonoFixPal,  0,0,              PK_FLAG,   1,                             PLOTF_RTLMONO_FIXPAL,   NULL         },
    { "PlotDPI",        0,PKF_REQALL,     PK_DWORD,  2,                             PLOTOFF(PlotXDPI),      NULL         },
    { "RasterDPI",      0,PKF_REQALL,     PK_WORD,   2,                             PLOTOFF(RasterXDPI),    NULL         },
    { "ROPLevel",       0,0,              PK_WORD,   1,                             PLOTOFF(ROPLevel),      ROPLevelVal  },
    { "MaxScale",       0,0,              PK_WORD,   1,                             PLOTOFF(MaxScale),      NULL         },
    { "MaxPens",        0,PKF_REQ,        PK_WORD,   1,                             PLOTOFF(MaxPens),       NULL         },
    { "MaxCopies",      0,0,              PK_WORD,   1,                             PLOTOFF(MaxCopies),     NULL         },
    { "MaxPolygonPts",  0,PKF_REQ,        PK_WORD,   1,                             PLOTOFF(MaxPolygonPts), NULL         },
    { "MaxQuality",     0,0,              PK_WORD,   1,                             PLOTOFF(MaxQuality),    NULL         },
    { szPaperTraySize,  0,PKF_ALL,        PK_DWORD,  2,                             PLOTOFF(PaperTraySize), NULL         },
    { "COLORINFO",      0,0,              PK_DWORD,  (SHORT)SIZE_COLORINFO,         PLOTOFF(ci),            NULL         },
    { "DevicePelsDPI",  0,0,              PK_DWORD,  1,                             PLOTOFF(DevicePelsDPI), NULL         },
    { "HTPatternSize",  0,0,              PK_DWORD,  1,                             PLOTOFF(HTPatternSize), HTPatSizeVal },
    { "InitString",     0,PKF_VARSIZE,    PK_STRING, -(SHORT)SIZE_ARRAY(InitString),PLOTOFF(InitString),    InitString   },
    { szPenData,        0,PKF_PENDATA,    PK_PENDATA,(SHORT)SIZE_ARRAY(AvaiPenData),PLOTOFF(Pens),          AvaiPenData  },
    { szFormInfo,       0,PKF_FORMINFO,   PK_FORMSRC,(SHORT)SIZE_ARRAY(AvaiForms),  PLOTOFF(Forms),         AvaiForms    },
    { NULL,             0 }
};


//
// Current default plotter's GPC
//

PLOTGPC PlotGPC = {

            PLOTGPC_ID,                         // ID
            PLOTGPC_VERSION,                    // Version
            sizeof(PLOTGPC),                    // cjThis
            0,                                  // SizeExtra
            "HPGL/2 Plotter",                   // DeviceName,
            { 215900, 279400 },                 // DeviceSize
            { 5000, 5000, 5000, 36000 },        // DeviceMargin
            0,                                  // Flags
            1016,                               // PlotXDPI
            1016,                               // PlotYDPI
            300,                                // RasterXDPI
            300,                                // RasterYDPI
            ROP_LEVEL_0,                        // ROPLevel
            100,                                // MaxScale
            8,                                  // MaxPens
            1,                                  // MaxCopies
            128,                                // MaxPolygonPts
            4,                                  // MaxQuality 100 levels

            { -1, -1 },                         // PaperTraySize = 0

            {                                   // ci
                { 6810, 3050,     0 },          // xr, yr, Yr
                { 2260, 6550,     0 },          // xg, yg, Yg
                { 1810,  500,     0 },          // xb, yb, Yb
                { 2000, 2450,     0 },          // xc, yc, Yc
                { 5210, 2100,     0 },          // xm, ym, Ym
                { 4750, 5100,     0 },          // xy, yy, Yy
                { 3324, 3474, 10000 },          // xw, yw, Yw
                10000, 10000, 10000,            // RGBB gamma
                1422,  952,                     // M/C, Y/C
                 787,  495,                     // C/M, Y/M
                 324,  248                      // C/Y, M/Y
            },

            0,                                  // DevicePelsDPI
            0xffffffff,                         // HTPatternSize

            { 0, 0,                NULL },      // init string
            { 0, sizeof(FORMSRC),  NULL },      // Forms
            { 0, sizeof(PENDATA),  NULL }       // Pens
        };



VOID
ShowUsage(
    VOID
    )
{
    fprintf(stderr, "\nPlotGPC [-?] InputDataFile [OutputPlotGPC]\n");
    fprintf(stderr, "Build NT Plotter GPC data file\n\n");
    fprintf(stderr, "               -?: display this message.\n");
    fprintf(stderr, "    InputDataFile: input ASCII data file\n");
    fprintf(stderr, "    OutputPlotGPC: output binary plotter gpc data file\n");

}



VOID
cdecl
DispError(
    INT     Level,
    LPSTR   pStr,
    ...
    )
{
    va_list vaList;

    if (Level) {

        if (Level > 2) {

            fprintf(stderr, "\n", InFileName);

        } else {

            fprintf(stderr, "\n%s(%u): ", InFileName, LineNo);
        }

        if (Level < 0) {

            fprintf(stderr, "INTERNAL ERROR: ");

        } else if (Level == 1) {

            fprintf(stderr, "warning: ");

        } else if (Level >= 2) {

            fprintf(stderr, "error: ");
        }

    } else {

        fprintf(stderr, "\n!!! ");
    }

    va_start(vaList, pStr);
    vfprintf(stderr, pStr, vaList);
    va_end(vaList);
}



VOID
ShowSpaces(
    UINT    Spaces
    )
{
    BYTE    Buf[81];


    while (Spaces) {

        memset(Buf, ' ', sizeof(Buf));

        if (Spaces > (sizeof(Buf) - 1)) {

            Buf[sizeof(Buf) - 1] = '\0';
            Spaces -= (sizeof(Buf) - 1);

        } else {

            Buf[Spaces] = '\0';
            Spaces = 0;
        }

        fprintf(stdout, "%s", Buf);
    }
}


VOID
ShowNumbers(
    LPBYTE      pNum,
    PPLOTVAL    pPV,
    WORD        Type,
    UINT        Count,
    UINT        NumDigits,
    UINT        NumPerLine
    )

/*++

Routine Description:

    This function shows numbers in the passed format.


Arguments:

    pNum        - Points to the number

    pPV         - Point to the value constant key name to be displayed

    Type        - PK_xxx type

    Count       - Total numbers

    NumDigits   - Total digits per number

    NumPerLine  - Total number per line to display


Return Value:

    VOID


Author:

    09-Nov-1993 Tue 19:45:13 created  -by-  DC


Revision History:


--*/

{
    DWORD       *pdw;
    WORD        *pw;
    DWORD       dw;
    UINT        Wrap;
    static BYTE DigitFormat[] = "%4lu";


    if (NumDigits > 9) {

        NumDigits = 9;
    }

    DigitFormat[1] = (BYTE)(NumDigits + '0');
    pdw            = NULL;
    pw             = NULL;
    Wrap           = 0;


    if (pPV) {

        Count = 1;
    }

    switch (Type) {

    case PK_DWORD:

        pdw = (DWORD *)pNum;
        break;

    case PK_WORD:

        pw = (WORD *)pNum;
        break;

    default:

        DispError(-1, "ShowNumbers only allowes PK_WORD, PK_DWORD");
        return;
    }

    while (Count--) {

        if (pdw) {

            dw = *pdw++;

        } else {

            dw = (DWORD)*pw++;
        }

        if (pPV) {

            pPV += dw;

            fprintf(stdout, "%s", pPV->pValName);

        } else {

            fprintf(stdout, DigitFormat, dw);
        }

        if (Count) {

            fprintf(stdout, ", ");

            if (++Wrap >= NumPerLine) {

                fprintf(stdout, "\n");
                ShowSpaces(MaxKeywordLen + 3);
                Wrap = 0;
            }
        }
    }
}





UINT
ShowString(
    LPBYTE  pBuf,
    UINT    cBuf
    )

/*++

Routine Description:

    This function displays a formatted string


Arguments:

    pBuf    - points to the string buffer

    cBuf    - Size of the string pointed to by pBuf

Return Value:

    UINT    - total characters displayed


Author:

    14-Dec-1993 Tue 09:47:06 created  -by-  DC


Revision History:


--*/

{
    BYTE    Ch;
    UINT    i = 1;


    if (!cBuf) {

        cBuf = strlen(pBuf);
    }

    fprintf(stdout, "\"");

    while (cBuf--) {

        Ch  = *pBuf++;
        i  += 2;

        if ((Ch >= ' ') && (Ch <= 0x7f)) {

            if (Ch == '\\') {

                fprintf(stdout, "\\\\");

            } else if (Ch == '\"') {

                fprintf(stdout, "\\\"");

            } else {

                fprintf(stdout, "%c", Ch);
                --i;
            }

        } else {

            if (Ch == '\a') {

                fprintf(stdout, "\\a");

            } else if (Ch == '\b') {

                fprintf(stdout, "\\b");

            } else if (Ch == '\f') {

                fprintf(stdout, "\\f");

            } else if (Ch == '\n') {

                fprintf(stdout, "\\n");

            } else if (Ch == '\r') {

                fprintf(stdout, "\\r");

            } else if (Ch == '\t') {

                fprintf(stdout, "\\t");

            } else {

                fprintf(stdout, "\\x%02x", Ch);
                ++i;
            }
        }
    }

    fprintf(stdout, "\"");

    return(++i);
}





BOOL
ShowOnePlotKey(
    PPLOTGPC    pPlotGPC,
    PPLOTKEY    pPK,
    UINT        VarSizeIdx,
    UINT        MaxLen
    )

/*++

Routine Description:

    This function takes a PLOTKEY structure and displays its content


Arguments:

    pPlotGPC    - Points to the current PLOTGPC data structure

    pPK         - Points to the PLOTKEY data structure

    VarSizeIdx  - a variable size index, must be less then pVS->Count

    MaxLen      - The size to pack the output into

Return Value:

    BOOL


Author:

    14-Dec-1993 Tue 09:48:13 created  -by-  DC


Revision History:


--*/

{
    PGPCVARSIZE pVS = NULL;
    LPBYTE      pData;
    PFORMSRC    pFS;
    PPENDATA    pPD;
    UINT        i;
    DWORD       dw;



    pData = ADD_PLOTOFF(pPlotGPC, pPK);

    if (pPK->Flags & PKF_VARSIZE) {

        pVS = (PGPCVARSIZE)pData;

        if (VarSizeIdx >= pVS->Count) {

            DispError(-1, "VarSizeIdx [%u] > GPCVarSize.Count [%u",
                                 VarSizeIdx, pVS->Count);

            return(FALSE);
        }

        pData = (LPBYTE)pPK->pInfo + (pVS->SizeEach * VarSizeIdx);
    }

    fprintf(stdout, "\n%s", pPK->pKeyword);
    ShowSpaces(MaxKeywordLen - pPK->KeywordLen + 1);
    fprintf(stdout, "{ ");


    switch (pPK->Type) {

    case PK_FLAG:

        fprintf(stdout, "%c", (pPlotGPC->Flags & pPK->Data) ? '1' : '0');
        break;

    case PK_WORD:
    case PK_DWORD:

        ShowNumbers(pData,
                    (PPLOTVAL)pPK->pInfo,
                    pPK->Type,
                    (UINT)pPK->Count,
                    (pPK->Data == PLOTOFF(ci)) ? 5 : 0,
                    (pPK->Data == PLOTOFF(ci)) ? 3 : 6);

        break;

    case PK_STRING:

        if (pVS) {

            ShowString(pData, pVS->SizeEach);

        } else {

            ShowString(pData, 0);
        }

        break;

    case PK_FORMSRC:

        pFS = (PFORMSRC)pData;
        i   = ShowString(pFS->Name, 0);

        fprintf(stdout, ",");
        ShowSpaces(MaxLen + 2 - i);
        fprintf(stdout, "%7lu,%8lu,%5lu,%5lu,%5lu,%5lu",
                    pFS->Size.cx, pFS->Size.cy,
                    pFS->Margin.left,   pFS->Margin.top,
                    pFS->Margin.right,  pFS->Margin.bottom);
        break;

    case PK_PENDATA:

        pPD = (PPENDATA)pData;
        dw  = VarSizeIdx + 1;

        ShowNumbers((LPBYTE)&dw, NULL, PK_DWORD, 1, 2, 1);
        fprintf(stdout, ", ");
        i = ShowString(PenColorVal[pPD->ColorIdx].pValName, 0);
        ShowSpaces(MaxLen + 2 - i);
        break;
    }

    fprintf(stdout, " }");

    return(TRUE);
}



VOID
ShowPlotGPC(
    PPLOTGPC    pPlotGPC
    )

/*++

Routine Description:

    This function show current settings of plotter GPC structure.

Arguments:

    pPlotGPC    - the GPC to be displayed


Return Value:

    VOID


Author:

    09-Nov-1993 Tue 19:07:05 created  -by-  DC


Revision History:


--*/

{
    PGPCVARSIZE pVS;
    PFORMSRC    pFS;
    PPLOTKEY    pPK;
    PLOTKEY     PK;
    UINT        i;
    UINT        Size;
    UINT        Count;
    UINT        MaxLen = 0;


    fprintf(stdout, "\n\n;\n; '%s' plotter characterization data\n;\n",
                                        pPlotGPC->DeviceName);

    pPK = &PlotKey[0];

    while (pPK->pKeyword) {

        PK = *pPK++;

        if (PK.Flags & PKF_VARSIZE) {

            pVS      = (PGPCVARSIZE)ADD_PLOTOFF(pPlotGPC, (&PK));
            Count    = pVS->Count;
            PK.pInfo = pVS->pData;

        } else {

            Count = 1;
        }

        if (PK.Type == PK_FORMSRC) {

            if (PK.Flags & PKF_VARSIZE) {

                pFS = (PFORMSRC)PK.pInfo;

            } else {

                pFS = (PFORMSRC)ADD_PLOTOFF(pPlotGPC, pPK);
            }

            for (MaxLen = i = 0; i < Count; i++, pFS++) {

                if ((Size = strlen(pFS->Name)) > MaxLen) {

                    MaxLen = Size;
                }
            }
        }

        if (PK.Type == PK_PENDATA) {

            MaxLen = MaxPCValLen;
        }

        if (Count > 1) {

            fprintf(stdout, "\n");
        }

        for (i = 0; i < Count; i++) {

            ShowOnePlotKey(pPlotGPC, &PK, i, MaxLen);
        }
    }

    fprintf(stdout, "\n\n");
}




#if 0


VOID
ShowUndefined(
    VOID
    )

/*++

Routine Description:

    This function displayes all undefined keywords


Arguments:


    nono


Return Value:

    VOID

Author:

    12-Nov-1993 Fri 17:20:24 created  -by-  DC


Revision History:


--*/

{
    PPLOTKEY    pPK;
    BOOL        Ok = TRUE;


    pPK = (PPLOTKEY)&PlotKey[0];

    while (pPK->pKeyword) {

        if (!(pPK->Flags & PKF_DEFINED)) {

            DispError(1, "keyword '%s' not defined.", pPK->pKeyword);
            Ok = FALSE;
        }

        ++pPK;
    }

    if (!Ok) {

        fprintf(stdout, "\n\n");
    }
}

#endif



LPBYTE
GetOneLine(
    BOOL    SkipFrontSpace
    )

/*++

Routine Description:

    This function return the next line in the input file string


Arguments:

    SkipFrontSpace  - skip the white space in the begining of the line

Return Value:

    pointer to the string, NULL if Error/EOF


Author:

    09-Nov-1993 Tue 10:39:31 created  -by-  DC


Revision History:


--*/

{
    LPBYTE      pLine;
    static BYTE LineBuf[1024];


    while (fgets(LineBuf, sizeof(LineBuf) - 1, InFile)) {

        ++LineNo;

        //
        // Skip End white spaces
        //

        pLine = &LineBuf[strlen(LineBuf)];

        while ((pLine > LineBuf) && (isspace(*(pLine - 1)))) {

            --pLine;
        }

        *pLine = '\0';

        //
        // Skip Front white spaces
        //

        pLine = LineBuf;

        if (SkipFrontSpace) {

            while ((*pLine) && (isspace(*pLine))) {

                ++pLine;
            }
        }

        if (*pLine) {

            return(pLine);
        }
    }

    return (NULL);
}






LPBYTE
ParseString(
    LPSTR   pKeyword,
    LPBYTE  *pLineLoc,
    LPBYTE  pBuf,
    SHORT   cBuf
    )

/*++

Routine Description:

    This function takes a pBuf and parses a series of characters into a string,
    it may contain escape format characters, the string may or may not be NULL
    terminated

Arguments:

    pKeyword    - Current keyword name

    pLineLoc    - Pointer to pointer of buffer line location

    pBuf        - Pointer to the buffer

    cBuf        - size of output buffer, if negative then NULL is allowed in
                  the string

Return Value:

    LPBYTE points to the end of the string, NULL if failure.


Author:

    14-Dec-1993 Tue 09:52:07 created  -by-  DC


Revision History:


--*/

{
#define STR_STATE_ERROR     -1
#define STR_STATE_END       0
#define STR_STATE_BYTE      1
#define STR_STATE_BKSLASH   2
#define STR_STATE_HEX1      3
#define STR_STATE_HEX2      4
#define STR_STATE_OCT2      5
#define STR_STATE_OCT3      6

    LPBYTE  pLine;
    LPBYTE  pStrBuf;
    LPBYTE  pEnd;
    INT     State;
    INT     Number;
    BOOL    Error = FALSE;
    BOOL    szStr;
    BYTE    Ch;


    if (cBuf < 0) {

        cBuf  = -cBuf;
        szStr = FALSE;

    } else {

        szStr = TRUE;
    }

    pLine   = *pLineLoc;
    pStrBuf = pBuf;
    pEnd    = pBuf + cBuf - 1;
    State   = STR_STATE_BYTE;

    while ((State != STR_STATE_ERROR)   &&
           (State != STR_STATE_END)     &&
           (pBuf <= pEnd)               &&
           (Ch = *pLine++)) {

        switch (State) {

        case STR_STATE_BYTE:

            if (Ch == '\\') {

                //
                // Check if end of the line, if so read the next line in
                // without stripping white space.
                //

                if (*pLine == '\0') {

                    if (!(pLine = GetOneLine(FALSE))) {

                        Ch = 0;
                        State = STR_STATE_ERROR;

                    } else {

                        continue;
                    }

                } else {

                    State = STR_STATE_BKSLASH;
                }

            } else if (Ch == '\"') {

                State = STR_STATE_END;
            }

            break;

        case STR_STATE_BKSLASH:

            State = STR_STATE_BYTE;

            switch (Ch) {

            case '0':       //
            case '1':       // Maximum OCT number is 377
            case '2':
            case '3':

                Number = (INT)(Ch - '0');
                State  = STR_STATE_OCT2;
                break;

            case 'x':

                Number = 0;
                State  = STR_STATE_HEX1;
                break;

            case 'a':

                Ch = '\a';
                break;

            case 'b':

                Ch = '\b';
                break;

            case 'f':

                Ch = '\f';
                break;

            case 'n':

                Ch = '\n';
                break;

            case 'r':

                Ch = '\r';
                break;

            case 't':

                Ch = '\t';
                break;

            case '\\':
            case '\"':

                break;

            default:

                DispError(2, "Invalid escape character '%c' (%s)", Ch, pKeyword);
                State = STR_STATE_ERROR;
            }

            break;

        case STR_STATE_OCT2:
        case STR_STATE_OCT3:

            if ((Ch >= '0') && (Ch <= '7')) {

                Number = (INT)((Number * 8) + (Ch - '0'));

                if (State == STR_STATE_OCT2) {

                    State = STR_STATE_OCT3;

                } else {

                    State = STR_STATE_BYTE;
                    Ch    = (BYTE)Number;
                }

            } else {

                DispError(2, "invalid digits for octal number '%c'", Ch);
                State = STR_STATE_ERROR;
            }

            break;

        case STR_STATE_HEX1:
        case STR_STATE_HEX2:

            if ((Ch >= '0') && (Ch <= '9')) {

                Number = (INT)((Number << 4) | (Ch - '0'));

            } else if ((Ch >= 'a') && (Ch <= 'f')) {

                Number = (INT)((Number << 4) | (Ch - 'a' + 10));

            } else if ((Ch >= 'A') && (Ch <= 'F')) {

                Number = (INT)((Number << 4) | (Ch - 'A' + 10));

            } else if (State == STR_STATE_HEX1) {

                DispError(2, "string hex escape must have at least one hex digit");

                State = STR_STATE_ERROR;

            } else {

                --pLine;        // re-process current one
            }

            if (State == STR_STATE_HEX1) {

                State = STR_STATE_HEX2;

            } else {

                Ch    = (BYTE)Number;
                State = STR_STATE_BYTE;
            }
        }

        if (State == STR_STATE_BYTE) {

            if ((szStr) && (!Ch)) {

                //
                // Do not allowe zero in the string
                //

                DispError(2, "CANNOT have NULL char. in the middle of '%s' string",
                                                    pKeyword);
                State = STR_STATE_ERROR;

            } else {

                *pBuf++ = Ch;
            }
        }
    }

    if (State != STR_STATE_END) {

        Error = TRUE;

        if (pBuf > pEnd) {

            DispError(2, "string too big: maximum length is %u for '%s'.",
                                                cBuf - 1, pKeyword);

        } else if (Ch == 0) {

            DispError(2, "string must end with a '\"'");
        }
    }

    *pLineLoc = pLine;

    if (Error) {

        return(NULL);

    } else {

        *pBuf = '\0';

        if (pStrBuf == pBuf) {

            DispError(1, "NULL string is defined for '%s'", pKeyword);
        }

        return(pBuf);
    }

#undef STR_STATE_ERROR
#undef STR_STATE_END
#undef STR_STATE_BYTE
#undef STR_STATE_BKSLASH
#undef STR_STATE_HEX1
#undef STR_STATE_HEX2
#undef STR_STATE_OCT2
#undef STR_STATE_OCT3
}





LPBYTE
GetNextToken(
    LPSTR   pKeyword,
    LPBYTE  pBuf,
    SHORT   cBuf
    )

/*++

Routine Description:

    This function retrieves the next token from the input file


Arguments:

    pKeyword    - Current keyword name

    pBuf        - pointer to the string parsing output buffer, if not NULL

    cBuf        - size of pBuf


Return Value:

    LPBYTE  - a pointer to the output buffer or token string, NULL if failure


Author:

    09-Nov-1993 Tue 11:21:11 created  -by-  DC


Revision History:


--*/

{
    static LPBYTE   pLine = NULL;
    static BYTE     LastCh = '\0';


    if (pLine == NULL) {

        LineNo = 0;
        pLine  = GetOneLine(TRUE);
    }

    if (LastCh) {

        *pLine = LastCh;
        LastCh = '\0';
    }

    LastCh = 0;

    if (pBuf) {

        if (!cBuf) {

            return(pBuf);
        }

        //
        // reading a string section
        //

        while (pLine) {

            while((*pLine) &&
                  ((isspace(*pLine)) ||
                   (*pLine == ','))) {

                pLine++;
            }

            if ((*pLine) && (*pLine != ';')) {

                if (*pLine++ != '"') {

                    DispError(2, "string must enclosed by \" (Quote)");
                    return(NULL);
                }

                return(ParseString(pKeyword, &pLine, pBuf, cBuf));

            } else {

                pLine = GetOneLine(TRUE);
            }
        }

    } else {

        while (pLine) {

            while((*pLine) &&
                  ((isspace(*pLine)) ||
                   (*pLine == ','))) {

                pLine++;
            }

            if ((*pLine) && (*pLine != ';')) {

                LPBYTE  pLineRet = pLine;

                while((*pLine)           &&
                      (!isspace(*pLine)) &&
                      (*pLine != ',')    &&
                      (*pLine != '{')    &&
                      (*pLine != '}')) {

                    ++pLine;
                }

                if ((*pLine == '{') ||
                    (*pLine == '}')) {

                    if (pLine == pLineRet) {

                        ++pLine;
                    }

                    LastCh = *pLine;
                    *pLine = '\0';

                } else {

                    *pLine++ = '\0';
                }

                // fprintf(stderr, "\nTOKEN = '%s'", pLineRet);
                return(pLineRet);

            } else {

                pLine = GetOneLine(TRUE);
            }
        }
    }

    return(NULL);
}


BOOL
CheckSingleToken(
    BYTE    Token
    )

/*++

Routine Description:

    Check if a single character 'Token' exists


Arguments:

    Token   - Token to be checked


Return Value:

    TRUE if found, FALSE otherwise

Author:

    09-Nov-1993 Tue 12:13:33 created  -by-  DC


Revision History:


--*/

{
    LPBYTE  pToken;


    if (!(pToken = GetNextToken(NULL, NULL, 0))) {

        DispError(2, "Unexpected end of file.");
        return(FALSE);
    }

    return(*pToken == Token);
}




BOOL
ConvertNumber(
    LPSTR   pBuf,
    BOOL    NegOk,
    LONG    *pRetVal
    )

/*++

Routine Description:

    Convert pBuf to a number based on the parameters passed


Arguments:

    pBuf    - Point to the string to be converted to a number

    NegOk   - TRUE if a negative number is allowed

    pRetVal - Pointer to a LONG to return a converted number

Return Value:

    TRUE if sucessful, FALSE if falied.


Author:

    09-Nov-1993 Tue 18:47:43 created  -by-  DC


Revision History:


--*/

{
    if ((*pRetVal = atol(pBuf)) < 0) {

        if (!NegOk) {

            DispError(2, "expect a positive number. [%s]", pBuf);
            return(FALSE);
        }

    } else if (*pRetVal == 0) {

        if (*pBuf != '0') {

            DispError(2, "expect a number. [%s]", pBuf);
            return(FALSE);
        }
    }

    return(TRUE);

}




INT
ReadNumbers(
    LPSTR       pKeyword,
    LPVOID      pNumbers,
    PPLOTVAL    pPlotVal,
    UINT        Total,
    UINT        Type,
    UINT        Flags
    )

/*++

Routine Description:

    This function reads the next token and returns a number, the number can be

        1. '0x' prefixed for a hex type
        2. normal for an integer type


Arguments:

    pPK     - Pointer to PLOTKEY

Return Value:


    Expanded to DWORD, this function will only read positive numbers


Author:

    09-Nov-1993 Tue 11:03:36 created  -by-  DC


Revision History:


--*/

{
    PPLOTVAL    pPV;
    LPBYTE      pToken;
    UINT        Count;
    DWORD       SetBit;
    DWORD       *pdw;
    WORD        *pw;


    pdw = NULL;
    pw  = NULL;

    switch (Type) {

    case PK_WORD:

        pw = (WORD *)pNumbers;
        break;

    case PK_DWORD:

        pdw = (DWORD *)pNumbers;
        break;

    case PK_FLAG:

        if (Total != 1) {

            DispError(-1, "PK_FLAG has more than one count");
            Total = 1;
        }

        SetBit = *(DWORD *)pNumbers;

        break;

    default:

        DispError(-1, "!!Unknow key type!!, internal error");
        return(-1);
    }

    for (Count = 0; Count < Total; Count++) {

        LONG    RetVal;
        BYTE    Ch;


        RetVal = 0;

        if (pToken = GetNextToken(pKeyword, NULL, 0)) {

            if (*pToken == '}') {

                if (!Count) {

                    DispError(1, "%s none of %u numbers defined",
                                                            pKeyword, Total);

                } else {

                    DispError(1, "%s defined only %u of %u numbers",
                                                    pKeyword, Count, Total);
                }

                if (Flags & PKF_ALL) {

                    DispError(2, "All %u numbers in keyword '%s' must defined",
                                        Total, pKeyword);
                    return(-1);

                } else {

                    return(0x01);
                }

            } else if (pPV = pPlotVal) {

                while (pPV->pValName) {

                    if (!_stricmp(pToken, pPV->pValName)) {

                        break;
                    }

                    ++pPV;
                }

                if (pPV->pValName) {

                    RetVal = pPV->Val;

                } else {

                    DispError(2, "unknown key value '%s' for keyword '%s'",
                                                    pToken, pKeyword);
                    return(-1);
                }

            } else if ((*pToken == '0') &&
                       ((*(pToken + 1) == 'x') || (*(pToken + 1) == 'X'))) {

                   //
                   // This is a Hex type format
                   //

                   pToken += 2;

                   while (Ch = *pToken++) {

                       if ((Ch >= '0') && (Ch <= '9')) {

                           Ch -= '0';

                       } else if ((Ch >= 'a') && (Ch <= 'f')) {

                           Ch = (Ch - 'a') + 10;

                       } else if ((Ch >= 'A') && (Ch <= 'F')) {

                           Ch = (Ch - 'A') + 10;

                       }  else {

                           break;
                       }

                       RetVal = (LONG)(((DWORD)RetVal << 4) | (DWORD)Ch);
                   }

            } else if (!ConvertNumber(pToken, Type == PK_FLAG, &RetVal)) {

                DispError(2, "expect another %u numbers. [%s]",
                                                Total - Count, pToken);
                return(-1);
            }

            if (pdw) {

                *pdw++ = (DWORD)RetVal;

            } else if (pw) {

                *pw++ = (WORD)RetVal;

            } else {

                if (RetVal) {

                    PlotGPC.Flags |= SetBit;

                } else {

                    PlotGPC.Flags &= ~SetBit;
                }
            }

        } else {

            DispError(2, "'%s' expect another %u numbers. [End Of File]",
                                                pKeyword, Total - Count);
            return(-1);
        }
    }

    return(0);
}





INT
ReadString(
    PPLOTKEY    pPK
    )

/*++

Routine Description:

    This function reads in the string for the PK (plotkey)


Arguments:

    pPK - Points to the PLOTKEY data structure


Return Value:

    size of the string that was read.

Author:

    12-Nov-1993 Fri 12:25:50 created  -by-  DC


Revision History:


--*/

{
    LPBYTE  pBuf;
    LPBYTE  pEnd;


    pBuf = (LPBYTE)((pPK->Flags & PKF_VARSIZE) ? pPK->pInfo : GET_PLOTOFF(pPK));

    if (!(pPK->Flags & PKF_VARSIZE)) {

        if (pPK->Count < 0) {

            DispError(-1, "'%s' is a non-variable size string, it CANNOT have NULL char",
                                                    pPK->pKeyword);
            return(-1);
        }
    }

    if (pEnd = GetNextToken(pPK->pKeyword, pBuf, pPK->Count)) {

        UINT    Size = (UINT)(pEnd - pBuf);

        if (pPK->Flags & PKF_VARSIZE) {

            PGPCVARSIZE pVS;


            pVS = (PGPCVARSIZE)GET_PLOTOFF(pPK);

            if (Size) {

                pVS->Count = 1;
            }

            pVS->SizeEach = (WORD)Size;
            pVS->pData    = NULL;
        }

        return((pBuf[0] == '\0') ? 0x02 : 0x00);
    }

    return(-1);
}




BOOL
CheckFormSrc(
    LPBYTE      pKeyword,
    WORD        Flags,
    SIZEL       *pSize,
    RECTL       *pMargin,
    LPSTR       pFormName,
    INT         ErrNo
    )

/*++

Routine Description:

    Check if FORMSRC input is valid

Arguments:

    pKeyword    - Point to current keyword

    Flags       - PKF_xxxx

    pSize       - pointer to SIZEL for Form size

    RECTL       - Pointer to the RECTL for margins

    pFormName   - Name of the form

    ErrNo       - error number to send to DispError() if an error occurs


Return Value:


    TRUE if OK, FALSE otherwise


Author:

    18-Nov-1993 Thu 00:04:12 created  -by-  DC


Revision History:


--*/

{

    if (pSize->cx < MIN_PLOTGPC_FORM_CX) {

        DispError(ErrNo, "minimum height for '%s' (%s) must >= %lu",
                                    pFormName, pKeyword, MIN_PLOTGPC_FORM_CX);
        return(FALSE);
    }

    if (pSize->cy < MIN_PLOTGPC_FORM_CY) {

        if (Flags & PKF_FS_VARLEN) {

            if (pSize->cy) {

                pSize->cy = 0;
                DispError(1, "ASSUME variable length (set to 0) for '%s' (%s)",
                                                    pFormName, pKeyword);
            }

        } else {

            DispError(ErrNo, "minimum height for '%s' (%s) must >= %lu",
                                pFormName, pKeyword, MIN_PLOTGPC_FORM_CY);
            return(FALSE);
        }
    }

    if ((pSize->cx - pMargin->left - pMargin->right) < MIN_PLOTGPC_FORM_CX) {

        DispError(ErrNo, "invalid left/right margins for '%s' (%s)",
                                                    pFormName, pKeyword);
        return(FALSE);
    }

    if ((pSize->cy) &&
        ((pSize->cx - pMargin->left - pMargin->right) < MIN_PLOTGPC_FORM_CY)) {

        DispError(ErrNo, "invalid top/bottom margins for '%s' (%s)",
                                                    pFormName, pKeyword);
        return(FALSE);
    }

    return(TRUE);
}




INT
ReadFormSrc(
    PPLOTKEY    pPK
    )

/*++

Routine Description:

    Input a FORMSRC line from the input file.


Arguments:

    pPK - Pointer to the PLOTKEY data structure


Return Value:

    INT - >= 0 if OK, -1 if failure, a 0 return means no '}' end bracket is read
    a > 0 means '}' already read.


Author:

    12-Nov-1993 Fri 13:34:50 created  -by-  DC


Revision History:


--*/

{
    PGPCVARSIZE pVS;
    PFORMSRC    pFS;


    pVS = NULL;
    pFS = (PFORMSRC)GET_PLOTOFF(pPK);

    if (pPK->Flags & PKF_VARSIZE) {

        pVS = (PGPCVARSIZE)pFS;
        pFS = (PFORMSRC)pPK->pInfo;

        if (pVS->Count >= pPK->Count) {

            DispError(2, "too many '%s' defined, allowed only (%u)",
                                            pPK->pKeyword, pPK->Count);
            return(-1);
        }

        pFS += pVS->Count;
    }

    ZeroMemory(pFS, sizeof(FORMSRC));

    if ((GetNextToken(pPK->pKeyword, pFS->Name, CCHFORMNAME)) &&
        (pFS->Name[0]) &&
        (ReadNumbers(pPK->pKeyword,
                     (LPVOID)&pFS->Size,
                     NULL,
                     6,
                     PK_DWORD,
                     PKF_REQ) >= 0) &&
        (CheckFormSrc(pPK->pKeyword,
                      pPK->Flags,
                      &(pFS->Size),
                      &(pFS->Margin),
                      &(pFS->Name[0]),
                      2))) {

        if (pVS) {

            PFORMSRC    pOrgFS = (PFORMSRC)pPK->pInfo;
            UINT        i = pVS->Count;

            while (i--) {

                if (_stricmp(pFS->Name, pOrgFS->Name) == 0) {

                    DispError(2, "'%s' already defined in keyword '%s'",
                                                pOrgFS->Name, pPK->pKeyword);
                    return(-1);
                }

                pOrgFS++;
            }

            pVS->Count    += 1;
            pVS->SizeEach  = sizeof(FORMSRC);
            pVS->pData     = NULL;

        }

        return(0);
    }

    return(-1);
}





INT
ReadPenData(
    PPLOTKEY    pPK
    )

/*++

Routine Description:

    Read a PENDATA structure


Arguments:

    pPK - Pointer to the PLOTKEY data structure


Return Value:

    INT - >= 0 if OK, -1 if failed,  0 if no '}' end bracket is
    definined, > 0 means '}' already read.


Author:

    12-Nov-1993 Fri 13:34:50 created  -by-  DC


Revision History:


--*/

{
    PGPCVARSIZE pVS;
    PPENDATA    pPD;
    PENDATA     PD;
    WORD        IdxPen;
    INT         Ret;


    pVS = (PGPCVARSIZE)GET_PLOTOFF(pPK);
    pPD = (PPENDATA)pPK->pInfo;

    if ((ReadNumbers(pPK->pKeyword,
                     (LPVOID)&IdxPen,
                     NULL,
                     1,
                     PK_WORD,
                     PKF_REQ) == 0) &&
        ((Ret = ReadNumbers(pPK->pKeyword,
                            (LPVOID)&PD.ColorIdx,
                            PenColorVal,
                            1,
                            PK_WORD,
                            PKF_REQ)) >= 0)) {

        if (IdxPen <= 0) {

            DispError(2, "first pen number started at one (1), not zero (0).");
            return(-1);
        }

        if (IdxPen > MAX_PENPLOTTER_PENS) {

            DispError(2, "maximum pen number is '%s'.", MAX_PENPLOTTER_PENS);
            return(-1);
        }

        pPD += (IdxPen - 1);

        if (pPD->ColorIdx != 0xffff) {

            DispError(1, "redefined Pen #%d for '%s' keyword '%s'",
                                        IdxPen, pPK->pKeyword);

        } else {

            ++pVS->Count;
        }

        *pPD = PD;

        pVS->SizeEach = sizeof(PENDATA);
        pVS->pData    = NULL;

        return(Ret);
    }

    return(-1);
}




PPLOTGPC
GetFullPlotGPC(
    VOID
    )

/*++

Routine Description:

    This function converts the current contents of PlotGPC to allocated memory
    so it has the entire PLOTGPC defined

Arguments:

    VOID


Return Value:

    PPLOTGPC, Pointer to the PLOTGPC packed and converted, NULL if failure


Author:

    17-Nov-1993 Wed 17:08:53 created  -by-  DC


Revision History:


--*/

{
    PPLOTGPC    pPlotGPC;
    LPBYTE      pData;
    DWORD       InitStrSize[2];
    DWORD       FormsSize[2];
    DWORD       PlotPensSize[2];
    DWORD       SizeExtra;



    if ((PlotGPC.InitString.Count == 1)   ||
        (PlotGPC.InitString.SizeEach)) {

        //
        // Include the NULL terminated character
        //

        InitStrSize[0] = PlotGPC.InitString.SizeEach + 1;

    } else {

        InitStrSize[0] = 0;
        ZeroMemory(&(PlotGPC.InitString), sizeof(GPCVARSIZE));
    }

    if ((PlotGPC.Forms.Count)                       &&
        (PlotGPC.Forms.SizeEach == sizeof(FORMSRC))) {

        FormsSize[0] = sizeof(FORMSRC) * PlotGPC.Forms.Count;

    } else {

        FormsSize[0] = 0;
        ZeroMemory(&(PlotGPC.Forms), sizeof(GPCVARSIZE));
    }

    if ((PlotGPC.Pens.Count)                        &&
        (PlotGPC.Pens.SizeEach == sizeof(PENDATA))) {

        PlotPensSize[0] = sizeof(PENDATA) * PlotGPC.Pens.Count;

    } else {

        PlotPensSize[0] = 0;
        ZeroMemory(&(PlotGPC.Pens), sizeof(GPCVARSIZE));
    }

    SizeExtra = (InitStrSize[1]  = DWORD_ALIGNED(InitStrSize[0])) +
                (FormsSize[1]    = DWORD_ALIGNED(FormsSize[0]))   +
                (PlotPensSize[1] = DWORD_ALIGNED(PlotPensSize[0]));


    PLOTDBG(DBG_FULLGPC, ("Size = PLOTGPC=%ld + SizeExtra=%ld = %ld",
                    sizeof(PLOTGPC), SizeExtra,  sizeof(PLOTGPC) + SizeExtra));


    if (pPlotGPC = (PPLOTGPC)LocalAlloc(LPTR, sizeof(PLOTGPC) + SizeExtra)) {

        PlotGPC.SizeExtra = (WORD)SizeExtra;

        CopyMemory(pData = (LPBYTE)pPlotGPC, &PlotGPC, sizeof(PLOTGPC));

        pData += sizeof(PLOTGPC);

        if (InitStrSize[0]) {

            CopyMemory(pData, InitString, InitStrSize[0]);
            pPlotGPC->InitString.pData = (LPVOID)pData;
            pData += InitStrSize[1];
        }

        if (FormsSize[0]) {

            CopyMemory(pData, AvaiForms, FormsSize[0]);
            pPlotGPC->Forms.pData = (LPVOID)pData;
            pData += FormsSize[1];
        }

        if (PlotPensSize[0]) {

            CopyMemory(pData, AvaiPenData, PlotPensSize[0]);
            pPlotGPC->Pens.pData = (LPVOID)pData;
            pData += PlotPensSize[1];
        }
    }

    return(pPlotGPC);
}




INT
ParsePlotGPC(
    VOID
    )

/*++

Routine Description:

    This function parses a PlotGPC from a text file


Arguments:

    VOID


Return Value:

    INT, >= 0 means ok, -x if a failure occured.

Author:

    09-Nov-1993 Tue 12:19:20 created  -by-  DC


Revision History:


--*/

{
    LPBYTE      pToken;
    PPLOTKEY    pPK;
    INT         Result;
    LONG        cy;
    INT         i;


    while (pToken = GetNextToken(NULL, NULL, 0)) {

        pPK = (PPLOTKEY)&PlotKey[0];

        while (pPK->pKeyword) {

            if (!_stricmp(pToken, pPK->pKeyword)) {

                break;
            }

            ++pPK;
        }

        if (pPK->pKeyword) {

            // fprintf(stderr, "\nFound keyword '%s'", pToken);

            if ((pPK->Flags & PKF_DEFINED) &&
                (!(pPK->Flags & PKF_MUL_OK))) {

                DispError(1, "keyword '%s' section redefined.", pToken);
            }

            if (!CheckSingleToken('{')) {

                DispError(2, "expect '{' after keyword '%s. key values must enclosed in {}",
                                                        pPK->pKeyword);
                return(-1);
            }

            switch (pPK->Type) {

            case PK_FLAG:

                Result = ReadNumbers(pPK->pKeyword,
                                     (LPVOID)&(pPK->Data),
                                     (PPLOTVAL)pPK->pInfo,
                                     pPK->Count,
                                     PK_FLAG,
                                     pPK->Flags);
                break;

            case PK_WORD:
            case PK_DWORD:

                Result = ReadNumbers(pPK->pKeyword,
                                     (LPVOID)GET_PLOTOFF(pPK),
                                     (PPLOTVAL)pPK->pInfo,
                                     pPK->Count,
                                     pPK->Type,
                                     pPK->Flags);
                break;

            case PK_STRING:

                Result = ReadString(pPK);
                break;

            case PK_FORMSRC:

                Result = ReadFormSrc(pPK);
                break;

            case PK_PENDATA:

                Result = ReadPenData(pPK);
                break;

            default:

                Result = -1;
                break;
            }

            if (Result < 0) {

                return(-1);
            }

            if (!(Result & 0x01)) {

                if (!CheckSingleToken('}')) {

                    DispError(2, "unbalanced braces, missing '}' at end of keyword '%s'",
                                                        pPK->pKeyword);
                    return(-1);
                }
            }

            if (!(Result & 0x02)) {

                pPK->Flags |= PKF_DEFINED;
            }

        } else {

            DispError(2, "Unknown keyword '%s'", pToken);
            return(-1);
        }
    }

    if (PlotGPC.Flags & PLOTF_RASTER) {

        if (PlotGPC.Flags & PLOTF_COLOR) {

            PlotGPC.Flags &= ~PLOTF_RTLMONO_NO_CID;
        }

        if ((pPK->pKeyword == szRTLMonoEncode5) &&
            (!(pPK->Flags & PKF_DEFINED))) {

            Result = -1;
            DispError(2, "Flag keyword '%s' must defined for RASTER Plotter.", pPK->pKeyword);
        }

    } else {

        PlotGPC.Flags |= (PLOTF_NO_BMP_FONT     |
                          PLOTF_RTL_NO_DPI_XY   |
                          PLOTF_RTLMONO_NO_CID  |
                          PLOTF_RTLMONO_FIXPAL);
    }

    //
    // Find out if a required keyword is missing
    //

    Result = 1;
    pPK    = (PPLOTKEY)&PlotKey[0];

    while (pPK->pKeyword) {

        if ((PlotGPC.Flags & PLOTF_RASTER)      &&
            (pPK->pKeyword == szRTLMonoEncode5) &&
            (!(pPK->Flags & PKF_DEFINED))) {

            Result = -1;
            DispError(2, "Flag keyword '%s' must defined for RASTER Plotter.", pPK->pKeyword);
        }

        if ((pPK->Flags & PKF_REQ) &&
            (!(pPK->Flags & PKF_DEFINED))) {

            Result = -1;
            DispError(2, "required keyword '%s' undefined", pPK->pKeyword);
        }

        ++pPK;
    }

    //
    // Validate DeviceSize/DeviceMargins
    //

    if (PlotGPC.DeviceSize.cx < MIN_PLOTGPC_FORM_CX) {

        DispError(2, "Invalid DeviceSize CX = %ld", PlotGPC.DeviceSize.cx);
        Result = -1;
    }

    if (PlotGPC.DeviceSize.cy < MIN_PLOTGPC_FORM_CY) {

        if (PlotGPC.Flags & PLOTF_ROLLFEED) {

            PlotGPC.DeviceSize.cy = 15240000;   // default to 50' of length
            DispError(1, "Assume device length can handle up to 50 feet of paper");

        } else {

            PlotGPC.DeviceSize.cy = 279400;     // default to 11" of length
            DispError(1, "Assume device length can handle up to 11 inch of paper");
        }
    }

    if (PlotGPC.DeviceSize.cx - (PlotGPC.DeviceMargin.left +
                        PlotGPC.DeviceMargin.right) < MIN_PLOTGPC_FORM_CX) {

        DispError(3, "Invalid DeviceMargin left/right (%ld/%ld",
                        PlotGPC.DeviceMargin.left, PlotGPC.DeviceMargin.right);
        Result = -1;
    }

    if (PlotGPC.DeviceSize.cy - (PlotGPC.DeviceMargin.top +
                        PlotGPC.DeviceMargin.bottom) < MIN_PLOTGPC_FORM_CY) {

        DispError(3, "Invalid DeviceMargin top/bottom (%ld/%ld",
                        PlotGPC.DeviceMargin.top, PlotGPC.DeviceMargin.bottom);
        Result = -1;
    }

    for (i = 0; i < (INT)PlotGPC.Forms.Count; i++) {

        if ((!(PlotGPC.Flags & PLOTF_ROLLFEED)) &&
            (AvaiForms[i].Size.cy == 0)) {

            DispError(3, "%s '%s', the device CANNOT handle roll paper",
                            szFormInfo, AvaiForms[i].Name);

            Result = -1;
        }

        if ((cy = AvaiForms[i].Size.cy) == 0) {

            cy = PlotGPC.DeviceSize.cy;
        }

        if (((AvaiForms[i].Size.cx <= PlotGPC.DeviceSize.cx) &&
             (cy <= PlotGPC.DeviceSize.cy))                         ||
            ((AvaiForms[i].Size.cx <= PlotGPC.DeviceSize.cy) &&
             (cy <= PlotGPC.DeviceSize.cx))) {

            NULL;

        } else {

            DispError(3, "%s '%s' size too big for device to handle",
                                szFormInfo, AvaiForms[i].Name);

            Result = -1;
        }
    }

    //
    // Find out if pen data must be present
    //

    if (PlotGPC.Flags & PLOTF_RASTER) {

        if (PlotGPC.Pens.Count) {

            DispError(3, "CANNOT define Pen colors for a raster device");
            Result = -1;
        }

    } else {

        if (!(PlotGPC.Flags & PLOTF_NO_BMP_FONT)) {

            DispError(3, "PEN plotter MUST SET '%s' to 1", szNoBmpFont);
            Result = -1;
        }

        if (!(PlotGPC.Flags & PLOTF_COLOR)) {

            DispError(3, "PEN plotter must specify COLOR. (ColorCap {1})");
            Result = -1;
        }

        if (PlotGPC.MaxPens > MAX_PENPLOTTER_PENS) {

            DispError(3, "maximum plotter Pens allowed are %ld, you defined %ld",
                                MAX_PENPLOTTER_PENS, PlotGPC.MaxPens);

            PlotGPC.MaxPens = MAX_PENPLOTTER_PENS;
            Result = -1;
        }

        if (PlotGPC.Pens.Count < PlotGPC.MaxPens) {

            DispError(3, "only %ld pens out of %ld pens defined",
                            PlotGPC.Pens.Count, PlotGPC.MaxPens);
            Result = -1;
        }

        if (PlotGPC.Pens.Count > PlotGPC.MaxPens) {

            DispError(3, "too many pens (%ld) defined for '%s', Maximum is %ld",
                        PlotGPC.Pens.Count, szPenData, PlotGPC.MaxPens);
            Result = -1;
        }

        for (i = 0; i < PlotGPC.MaxPens; i++) {

            if (AvaiPenData[i].ColorIdx == 0xffff) {

                DispError(3, "'%s' Pen #%ld undefined", szPenData, i + 1);
                Result = -1;
            }
        }
    }

    if (PlotGPC.Flags & PLOTF_PAPERTRAY) {

        if ((PlotGPC.PaperTraySize.cx < 0) ||
            (PlotGPC.PaperTraySize.cy < 0)) {

            DispError(3, "'%s' defined, but '%s' not defined",
                                            szPaperTrayCap, szPaperTraySize);

            Result = -1;

        } else if ((PlotGPC.PaperTraySize.cx == 0) ||
                   (PlotGPC.PaperTraySize.cy == 0)) {

            DispError(3, "'%s': Invalid Size (%ld x %ld), must have a size",
                            szPaperTraySize,
                            PlotGPC.PaperTraySize.cx,
                            PlotGPC.PaperTraySize.cy);
            Result = -1;

        } else if ((PlotGPC.PaperTraySize.cx != PlotGPC.DeviceSize.cx) &&
                   (PlotGPC.PaperTraySize.cy != PlotGPC.DeviceSize.cx)) {

            DispError(3, "'%s': Invalid Size (%ld x %ld), one of width/height must eqaul device width (%ld)",
                            szPaperTraySize,
                            PlotGPC.PaperTraySize.cx,
                            PlotGPC.PaperTraySize.cy, PlotGPC.DeviceSize.cx);

            Result = -1;
        }
    }

    return(Result);
}





VOID
CopyPlotGPCToPCD(
    PPLOTGPC_PCD  pPlotGPC_PCD,
    PPLOTGPC      pPlotGPC
    )

/*++

Routine Description:

    This function copies a PLOTGPC structure into a PLOTGPC_GPC structure.

Arguments:

    pPlotGPC_PCD  - destination
    pPlotGPC      - source

Return Value:

    None 

Author:

    1 Feb 2000, Manu Thambi 

Revision History:

--*/

{
    // All the datatypes upto InitString are the same in both the structures.
    CopyMemory(pPlotGPC_PCD, 
               pPlotGPC, 
               (LPBYTE)&(pPlotGPC_PCD->InitString) - (LPBYTE)pPlotGPC_PCD);

    // We need the size of PLOTGPC_PCD here, not the size of PLOTGPC
    pPlotGPC_PCD->cjThis = sizeof(PLOTGPC_PCD);  
    
    pPlotGPC_PCD->InitString.Count     = pPlotGPC->InitString.Count;
    pPlotGPC_PCD->InitString.SizeEach  = pPlotGPC->InitString.SizeEach;
    if (pPlotGPC->InitString.pData) {
        pPlotGPC_PCD->InitString.pData = (DWORD)(ULONG_PTR)(pPlotGPC->InitString.pData) 
                                                    - (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD));
    } else {
        pPlotGPC_PCD->InitString.pData = 0;
    }

    pPlotGPC_PCD->Forms.Count          = pPlotGPC->Forms.Count;
    pPlotGPC_PCD->Forms.SizeEach       = pPlotGPC->Forms.SizeEach;
    if (pPlotGPC->Forms.pData) {
        pPlotGPC_PCD->Forms.pData      = (DWORD)(ULONG_PTR)(pPlotGPC->Forms.pData)
                                                    - (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD));
    } else {
        pPlotGPC_PCD->Forms.pData      = 0;
    }

    pPlotGPC_PCD->Pens.Count           = pPlotGPC->Pens.Count;
    pPlotGPC_PCD->Pens.SizeEach        = pPlotGPC->Pens.SizeEach;
    if (pPlotGPC->Pens.pData) {
        pPlotGPC_PCD->Pens.pData       = (DWORD)(ULONG_PTR)(pPlotGPC->Pens.pData)
                                                    - (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD));
    } else {
        pPlotGPC_PCD->Pens.pData       = 0;
    }
}



VOID
WritePlotGPCToFile(
    PPLOTGPC  pPlotGPC
    )

/*++

Routine Description:

    This routine writes out pPlotGPC into a .pcd file. A FILE* pointer
    to the file should be present in OutFile.

Arguments:

    pPlotGPC      - pointer to the PLOTGPC structure to be written. Some elements
                    maybe modified in *pPlotGPC in this function.

Return Value:

    None 

Author:

    1 Feb 2000, Manu Thambi 

Revision History:

--*/

{
    PLOTGPC_PCD PlotGPC_PCD;

    //
    // make the references to offset
    //
    if (pPlotGPC->InitString.pData) {

        (LPBYTE)pPlotGPC->InitString.pData -= (ULONG_PTR)pPlotGPC;
    }

    if (pPlotGPC->Forms.pData) {

        (LPBYTE)pPlotGPC->Forms.pData -= (ULONG_PTR)pPlotGPC;
    }

    if (pPlotGPC->Pens.pData) {

        (LPBYTE)pPlotGPC->Pens.pData -= (ULONG_PTR)pPlotGPC;
    }

    CopyPlotGPCToPCD(&PlotGPC_PCD, pPlotGPC);

    if (OutFile) {

        fwrite(&PlotGPC_PCD,
               PlotGPC_PCD.cjThis,
               1,
               OutFile);

        fwrite((LPBYTE)pPlotGPC + pPlotGPC->cjThis,
               PlotGPC.SizeExtra,
               1,
               OutFile);
    }

}

//
//***************************************************************************
// C main function entry point
//***************************************************************************
//


#define MAIN_SHOW_USAGE     0x0001


int __cdecl
main(
    INT     argc,
    CHAR    **argv
    )
{
    PPLOTGPC    pPlotGPC = NULL;
    INT         RetVal = 1;
    UINT        Flags = 0;
    UINT        i;
    LPSTR       pOutFile = NULL;
    PPLOTKEY    pPK;
    PPLOTVAL    pPV;


    memset(AvaiPenData, 0xff, sizeof(AvaiPenData));

    pPV         = PenColorVal;
    MaxPCValLen = 0;

    while (pPV->pValName) {

        if ((i = (UINT)strlen(pPV->pValName)) > MaxPCValLen) {

            MaxPCValLen = i;
        }

        ++pPV;
    }

    pPK           = &PlotKey[0];
    MaxKeywordLen = 0;

    while (pPK->pKeyword) {

        if ((pPK->KeywordLen = (WORD)strlen(pPK->pKeyword)) > MaxKeywordLen) {

            MaxKeywordLen = pPK->KeywordLen;
        }

        ++pPK;
    }

    InFile  = NULL;
    OutFile = NULL;

    if (argc > 1) {

        for (--argc, ++argv; argc > 0; --argc, ++argv) {

            if (**argv == '-' ) {

                switch (*(*argv + 1)) {

                case '?':
                case 'h':
                case 'H':

                    Flags |= MAIN_SHOW_USAGE;
                    RetVal = -1;
                    break;
                }

            } else if (InFile) {

                if ((OutFile) && (OutFile != stdout)) {

                    DispError(0, "Unknown parameter '%s'", *argv);
                    Flags |= MAIN_SHOW_USAGE;
                    RetVal = 0;

                } else if ((OutFile = fopen(pOutFile = *argv, "wb")) == NULL) {

                    DispError(0, "Cannot open output file '%s'\n", *argv);
                    RetVal = 0;
                }

            } else {

                strcpy(InFileName, *argv);

                if ((InFile = fopen(*argv, "rt" )) == NULL) {

                    DispError(0, "Cannot open input file '%s'\n", *argv);
                    RetVal = -1;
                }

            }
        }

    } else {

        Flags |= MAIN_SHOW_USAGE;
        RetVal = -1;
    }

    if (Flags & MAIN_SHOW_USAGE) {

        ShowUsage();
    }

    if ((RetVal >= 0) &&
        (InFile)) {

        RetVal = ParsePlotGPC();
    }

    if (RetVal >= 0) {

        //
        // if (InFile) {
        //
        //     ShowUndefined();
        // }
        //

        if (pPlotGPC = GetFullPlotGPC()) {

            ValidatePlotGPC(pPlotGPC);
            ShowPlotGPC(pPlotGPC);
            WritePlotGPCToFile(pPlotGPC);
        }

    } else {

        fprintf(stdout, "\n");
    }

    if (InFile) {

        fclose(InFile);
    }

    if ((OutFile) && (OutFile != stdout)) {

        fclose(OutFile);
    }


#if (DBG && GPC_READ_TEST)

    if (pOutFile) {

        LPWSTR      pwStr = NULL;
        PPLOTGPC    pReadPlotGPC;
        UINT        Idx = 0;


        pwStr = str2MemWstr(pOutFile);

        if (pReadPlotGPC = ReadPlotGPCFromFile(pwStr)) {

            ShowPlotGPC(pReadPlotGPC);

            //
            // make the references to offset
            //

            if (pReadPlotGPC->InitString.pData) {

                (LPBYTE)pReadPlotGPC->InitString.pData -= (DWORD)pReadPlotGPC;
            }

            if (pReadPlotGPC->Forms.pData) {

                (LPBYTE)pReadPlotGPC->Forms.pData -= (DWORD)pReadPlotGPC;
            }

            if (pReadPlotGPC->Pens.pData) {

                (LPBYTE)pReadPlotGPC->Pens.pData -= (DWORD)pReadPlotGPC;
            }

            if ((pPlotGPC->cjThis != pReadPlotGPC->cjThis) ||
                (pPlotGPC->SizeExtra != pReadPlotGPC->SizeExtra)) {

                DispError(-1, "Write / Read Size different");

            } else {

                UINT    i;
                LPBYTE  pP1;
                LPBYTE  pP2;

                pP1 = (LPBYTE)pPlotGPC;
                pP2 = (LPBYTE)pReadPlotGPC;
                Idx = pPlotGPC->cjThis + pPlotGPC->SizeExtra;

                for (i = 0; i < Idx; i++) {

                    if (*pP1 != *pP2) {

                        fprintf(stdout, "\nOffset 0x%04x: Write = %02x, Read = %02x",
                                            i, *pP1, *pP2);
                    }

                    ++pP1;
                    ++pP2;
                }
            }

            LocalFree(pReadPlotGPC);

        } else {

            DispError(-1, "ReadPlotGPCFromFile(%s) failed", pOutFile);
        }

        if (pwStr) {

            LocalFree(pwStr);
        }
    }
#endif

    if (pPlotGPC) {

        LocalFree((HLOCAL)pPlotGPC);
    }

    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\comoem.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
//    ~IOemCB() {DbgPrint(DLLTEXT("IOemCB:\t\tDestroy self.")); };
    ~IOemCB();
    IOemCBInit();

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUD.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\enable.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    enable.c

Abstract:

    Implementation of OEM DDI exports.
        OEMEnablePDEV (required)
        OEMDisablePDEV (required)
        OEMResetPDEV (optional)

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

static const DRVFN OEMHookFuncs[] =
{
    { INDEX_DrvRealizeBrush,        (PFN) OEMRealizeBrush        },
    { INDEX_DrvDitherColor,         (PFN) OEMDitherColor         },
    { INDEX_DrvCopyBits,            (PFN) OEMCopyBits            },
    { INDEX_DrvBitBlt,              (PFN) OEMBitBlt              },
    { INDEX_DrvStretchBlt,          (PFN) OEMStretchBlt          },
    { INDEX_DrvStretchBltROP,       (PFN) OEMStretchBltROP       },
    { INDEX_DrvPlgBlt,              (PFN) OEMPlgBlt              },
    { INDEX_DrvTransparentBlt,      (PFN) OEMTransparentBlt      },
    { INDEX_DrvAlphaBlend,          (PFN) OEMAlphaBlend          },
    { INDEX_DrvGradientFill,        (PFN) OEMGradientFill        },
    { INDEX_DrvTextOut,             (PFN) OEMTextOut             },
    { INDEX_DrvStrokePath,          (PFN) OEMStrokePath          },
    { INDEX_DrvFillPath,            (PFN) OEMFillPath            },
    { INDEX_DrvStrokeAndFillPath,   (PFN) OEMStrokeAndFillPath   },
    { INDEX_DrvPaint,               (PFN) OEMPaint               },
    { INDEX_DrvLineTo,              (PFN) OEMLineTo              },
    { INDEX_DrvStartPage,           (PFN) OEMStartPage           },
    { INDEX_DrvSendPage,            (PFN) OEMSendPage            },
    { INDEX_DrvEscape,              (PFN) OEMEscape              },
    { INDEX_DrvStartDoc,            (PFN) OEMStartDoc            },
    { INDEX_DrvEndDoc,              (PFN) OEMEndDoc              },
    { INDEX_DrvNextBand,            (PFN) OEMNextBand            },
    { INDEX_DrvStartBanding,        (PFN) OEMStartBanding        },
    { INDEX_DrvQueryFont,           (PFN) OEMQueryFont           },
    { INDEX_DrvQueryFontTree,       (PFN) OEMQueryFontTree       },
    { INDEX_DrvQueryFontData,       (PFN) OEMQueryFontData       },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) OEMQueryAdvanceWidths  },
    { INDEX_DrvFontManagement,      (PFN) OEMFontManagement      },
    { INDEX_DrvGetGlyphMode,        (PFN) OEMGetGlyphMode        }
};


VOID
TestGetDriverSetting(
    PDEVOBJ pdevobj,
    BOOL    bDocSticky
    )

{
    DWORD   dwIndex, cbNeeded, cOptions;
    CHAR    buf[64];

    if (bDocSticky)
    {
        for (dwIndex=OEMGDS_UNIDM_GPDVER; dwIndex <= OEMGDS_UNIDM_FLAGS+1; dwIndex++)
        {
            if (pdevobj->pDrvProcs->DrvGetDriverSetting(
                    pdevobj,
                    (PCSTR) dwIndex,
                    buf,
                    64,
                    &cbNeeded,
                    &cOptions))
            {
                VERBOSE(("DrvGetDriverSetting %d: %d, %d\n", dwIndex, cbNeeded, cOptions));
            }
        }

        VERBOSE(("DrvGetDriverSetting OutputBin: "));

        if (pdevobj->pDrvProcs->DrvGetDriverSetting(
                    pdevobj,
                    "OutputBin",
                    buf,
                    64,
                    &cbNeeded,
                    &cOptions))
        {
            VERBOSE(("%s (%d, %d)\n", buf, cbNeeded, cOptions));
        }

    }
    else
    {
        for (dwIndex=OEMGDS_PRINTFLAGS; dwIndex <= OEMGDS_PROTOCOL+1; dwIndex++)
        {
            if (pdevobj->pDrvProcs->DrvGetDriverSetting(
                    pdevobj,
                    (PCSTR) dwIndex,
                    buf,
                    64,
                    &cbNeeded,
                    &cOptions))
            {
                VERBOSE(("DrvGetDriverSetting %d: %d, %d\n", dwIndex, cbNeeded, cOptions));
            }
        }

        VERBOSE(("DrvGetDriverSetting InstalledMemory: "));
        if (pdevobj->pDrvProcs->DrvGetDriverSetting(
                    pdevobj,
                    "InstalledMemory",
                    buf,
                    64,
                    &cbNeeded,
                    &cOptions))
        {
            VERBOSE(("%s (%d, %d)\n", buf, cbNeeded, cOptions));
        }

    }
}


PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    DbgPrint(DLLTEXT("OEMEnablePDEV() entry.\r\n"));

    //
    // Allocate the OEMDev
    //
    if (!(poempdev = MemAlloc(sizeof(OEMPDEV))))
        return NULL;

    //
    // Fill in OEMDEV as you need
    //

    //
    // Fill in OEMDEV
    //

    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        //
        // search through Unidrv's hooks and locate the function ptr
        //
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnUnidrv[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            //
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            //
            poempdev->pfnUnidrv[i] = NULL;
        }

    }

    //TestGetDriverSetting(pdevobj, TRUE);
    //TestGetDriverSetting(pdevobj, FALSE);

    return (POEMPDEV) poempdev;
}


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
    DbgPrint(DLLTEXT("OEMDisablePDEV() entry.\r\n"));


    //
    // free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    //
    MemFree(pdevobj->pdevOEM);

}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    DbgPrint(DLLTEXT("OEMResetPDEV() entry.\r\n"));


    //
    // if you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}


VOID APIENTRY OEMDisableDriver()
{
        DbgPrint(DLLTEXT("OEMDisableDriver() entry.\r\n"));
}


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    // DbgPrint(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // Validate paramters.
    if( (PRINTER_OEMINTF_VERSION != dwOEMintfVersion)
        ||
        (sizeof(DRVENABLEDATA) > dwSize)
        ||
        (NULL == pded)
      )
    {
        //  DbgPrint(ERRORTEXT("OEMEnableDriver() ERROR_INVALID_PARAMETER.\r\n"));

        return FALSE;
    }

    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION ; //   not  DDI_DRIVER_VERSION;
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\raster.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    raster.c

Abstract:

    Implementation of raster module customization:
        OEMImageProcessing
        OEMFilterGraphics

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created the framework. The functions are not yet exported in
        oemud\oemud.def file. So they are not actually used by Unidrv.

--*/

#include "pdev.h"

VOID Dither24to4(PBYTE,PBYTE,int,int,DWORD);

PBYTE APIENTRY OEMImageProcessing(
    PDEVOBJ pdevobj,
    PBYTE pSrcBitmap,
    PBITMAPINFOHEADER pBitmapInfo,
    PBYTE pColorTable,
    DWORD dwCallbackID,
    PIPPARAMS pIPParams
    )
{
#ifdef DBG
    DbgPrint(DLLTEXT("OEMImageProcessing() entry.\r\n"));
#endif
    if (pBitmapInfo->biBitCount == 24)
    {
        if (pIPParams->bBlankBand)
        {
            int i = (((pBitmapInfo->biWidth * 4) + 31) / 32) * 4 * pBitmapInfo->biHeight;
            ZeroMemory(pSrcBitmap,i);
        }
        else
            Dither24to4(pSrcBitmap,pSrcBitmap,
                        pBitmapInfo->biWidth,pBitmapInfo->biHeight,dwCallbackID);
        return pSrcBitmap;                        
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\ht24to4.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ht24to4.c

Abstract:

    Implementation of the test file to convert 24 bit data to
    4 bit data for OEMImageProcessing callback.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/11/97 -alvins-
        Created

--*/
#include "pdev.h"

//
// pattern must have a multiple of 2 width
//
#define PATWIDTH 8
#define PATHEIGHT 8

BYTE  gFine8x8[PATWIDTH*PATHEIGHT] =
{
    0*4+64, 0*4+128, 8*4+64, 8*4+128, 2*4+64, 2*4+128, 10*4+64, 10*4+128,
    0*4+192, 0*4+1, 8*4+192, 8*4, 2*4+192, 2*4, 10*4+192, 10*4,
    12*4+64, 12*4+128, 4*4+64, 4*4+128, 14*4+64, 14*4+128, 6*4+64, 6*4+128,
    12*4+192, 12*4, 4*4+192, 4*4, 14*4+192, 14*4, 6*4+192, 6*4,
    3*4+64, 3*4+128, 11*4+64, 11*4+128, 1*4+64, 1*4+128, 9*4+64, 9*4+128,
    3*4+192, 3*4, 11*4+192, 11*4, 1*4+192, 1*4, 9*4+192, 9*4,
    15*4+64, 15*4+128, 7*4+64, 7*4+128, 13*4+64, 13*4+128, 5*4+64, 5*4+128,
    15*4+192, 15*4, 7*4+192, 7*4, 13*4+192, 13*4, 5*4+192, 5*4
};


VOID Dither24to4(
    BYTE *pOrgIn,
    BYTE *pOrgOut,
    int  x,
    int  y,
    DWORD dwCallbackID
)
{
    int i,j;
    int iInScanBytes;
    int iOutScanBytes;
    BYTE *pIn,*pOut,*pPat,*pPatEnd;
    BYTE arBlackGen[256];

    //
    // generate NULL lookup table for three color
    //
    if (dwCallbackID == 3)
    {
        for (i = 0;i < 256;i++)
            arBlackGen[i] = i;
    }
    //
    // generate look up table to create black plane
    //
    else
    {
        for (i = 0;i < 256;i++)
        {
            BYTE bOut = i;
            if ((bOut & 0x07) == 0x07)
                bOut = (bOut & ~0x07) | 0x08;
            if ((bOut & 0x70) == 0x70)
                bOut = (bOut & ~0x70) | 0x80;
            arBlackGen[i] = bOut;
        }
    }
    //
    // calculate 24 bit input scan line size to nearest dword
    //
    iInScanBytes = ((x * 3) + 3) & ~3; 
    //
    // calculate 4 bit output scan line size to nearest dword
    //
    iOutScanBytes = (((x * 4) + 31) & ~31) / 8;
    
    //
    // loop once per scan line
    //
    for (i = 0;i < y;i++)
    {    
        pIn = pOrgIn;
        pOut = pOrgOut;
        pOrgIn += iInScanBytes;
        pOrgOut += iOutScanBytes;
        pPat = &gFine8x8[(i % PATHEIGHT) * PATWIDTH];
        pPatEnd = pPat + PATWIDTH;

        j = x >> 1;
        while (j--)
        {
            BYTE bOut = 0;
            if (pIn[0] < pPat[0])
                bOut |= 0x10;
            if (pIn[1] < pPat[0])
                bOut |= 0x20;
            if (pIn[2] < pPat[0])
                bOut |= 0x40;
            
            if (pIn[3] < pPat[1])
                bOut |= 0x01;
            if (pIn[4] < pPat[1])
                bOut |= 0x02;
            if (pIn[5] < pPat[1])
                bOut |= 0x04;

            *pOut++ = arBlackGen[bOut];
            pIn += 6;
            if ((pPat += 2) >= pPatEnd)
                pPat -= PATWIDTH;
        }
        // halftone last pixel if odd count
        //
        if (x & 1)
        {
            BYTE bOut = 0;
            if (pIn[0] < pPat[0])
                bOut |= 0x10;
            if (pIn[1] < pPat[0])
                bOut |= 0x20;
            if (pIn[2] < pPat[0])
                bOut |= 0x40;
            *pOut++ = arBlackGen[bOut];
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\guids.h ===
//
// GUIDs.cpp
//   - Defines all IIDs and CLSIDs for the client and the component.
//     The declaration of these GUIDs is in Iface.h
//
// {94537A69-8D57-11d1-A794-00C04FB92C81}
DEFINE_GUID(IID_IOemCB,
0x94537a69, 0x8d57, 0x11d1, 0xa7, 0x94, 0x0, 0xc0, 0x4f, 0xb9, 0x2c, 0x81);


// {35853e8-8d55-11d1-a794-00c04fb92c81}
DEFINE_GUID(IID_IOemCF,
0x35853e8, 0x8d55, 0x11d1, 0xa7, 0x94, 0x0, 0xc0, 0x4f, 0xb9, 0x2c, 0x81);


// {D67EBBF0-78BF-11d1-9480-00A0C90640B8}
DEFINE_GUID(IID_IPrintOemUni,
0xd67ebbf0, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\font.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    font.c

Abstract:

    Implementation of font module customization:
        OEMDownloadFontHeader
        OEMDownloadCharGlyph
        OEMTTDownloadMethod
        OEMOutputCharStr
        OEMSendFontCmd

Environment:

    Windows NT Unidrv driver

Revision History:

    04/28/97 -eigos-
        Filled the functionality for PCL printers.

    04/07/97 -zhanw-
        Created the framework. The functions are not yet exported in
        oemud\oemud.def file. So they are not actually used by Unidrv.

--*/

#include "pdev.h"
#include "sf_pcl.h"
#include "fmnewgly.h"
#include "fmnewfm.h"

#define BBITS 8
#define PCL_MAX_CHAR_HEADER_SIZE  32767
#define SWAB(x) ((WORD)(x) = (WORD)((((x) >> 8)& 0xff) | (((x) << 8) &0xff00)))

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes);

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr);


DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj)
{
    DWORD       dwFontHdrCmdLen;
    WORD        wSend;
    SF_HEADER20 sfh;
    BYTE        aubPCLFontHdrCmd[20];

    DbgPrint(DLLTEXT("OEMDownloadFontHeader() entry.\r\n"));

    ZeroMemory( &sfh, sizeof(SF_HEADER20));

    //
    // Fill in PCL font header.
    //

    sfh.wSize     = wSend = sizeof( SF_HEADER20 );
    sfh.bFormat   = PCL_FM_RESOLUTION;
    sfh.wXResn    = (WORD)600;
    sfh.wYResn    = (WORD)600;
    sfh.bFontType = PCL_FT_8LIM;
    sfh.wSymSet   = 277;
    sfh.wBaseline = max( pUFObj->pIFIMetrics->rclFontBox.top,
                         pUFObj->pIFIMetrics->fwdWinAscender );
    sfh.wCellWide = max( pUFObj->pIFIMetrics->rclFontBox.right -
                         pUFObj->pIFIMetrics->rclFontBox.left + 1,
                         pUFObj->pIFIMetrics->fwdAveCharWidth );
    sfh.wCellHeight = (WORD)(1 +
                             max(pUFObj->pIFIMetrics->rclFontBox.top,
                                 pUFObj->pIFIMetrics->fwdWinAscender) -
                             min(-pUFObj->pIFIMetrics->fwdWinDescender,
                                 pUFObj->pIFIMetrics->rclFontBox.bottom ));
    sfh.bOrientation = 0;
    sfh.bSpacing    = (pUFObj->pIFIMetrics->flInfo & FM_INFO_CONSTANT_WIDTH) ?
                      0 : 1;
    sfh.wPitch      = 4 * pUFObj->pIFIMetrics->fwdAveCharWidth;
    sfh.wHeight     = 4 * sfh.wCellHeight;
    sfh.wXHeight    = 4 * (pUFObj->pIFIMetrics->fwdWinAscender / 2);
    sfh.sbWidthType = 0;
    sfh.bStyle      = pUFObj->pIFIMetrics->ptlCaret.x ? 0 : 1;
    sfh.sbStrokeW   = 0;
    sfh.bTypeface   = 0;
    sfh.bSerifStyle = 0;
    sfh.sbUDist     = -1;
    sfh.bUHeight    = 3;
    sfh.wTextHeight = 4 * (pUFObj->pIFIMetrics->fwdWinAscender +
                           pUFObj->pIFIMetrics->fwdWinDescender);
    sfh.wTextWidth  = 4 * pUFObj->pIFIMetrics->fwdAveCharWidth;
    sfh.bPitchExt  = 0;
    sfh.bHeightExt = 0;
    sfh.chName[0]  = 'C';
    sfh.chName[1]  = 'a';
    sfh.chName[2]  = 'c';
    sfh.chName[3]  = 'h';
    sfh.chName[4]  = 'e';
    sfh.chName[5]  = ' '; 
    _ltoa(pUFObj->ulFontID, &sfh.chName[6], 10 );

    SWAB( sfh.wSize );
    SWAB( sfh.wBaseline );
    SWAB( sfh.wCellWide );
    SWAB( sfh.wCellHeight );
    SWAB( sfh.wSymSet );
    SWAB( sfh.wPitch );
    SWAB( sfh.wHeight );
    SWAB( sfh.wXHeight );
    SWAB( sfh.wTextHeight );
    SWAB( sfh.wTextWidth );
    SWAB( sfh.wXResn );
    SWAB( sfh.wYResn );

    //
    //"\x1B)s%dW", cbSend
    //

    ZeroMemory( aubPCLFontHdrCmd, sizeof( aubPCLFontHdrCmd ) );

    dwFontHdrCmdLen = 0;
    aubPCLFontHdrCmd[dwFontHdrCmdLen++] = 0x1B;
    aubPCLFontHdrCmd[dwFontHdrCmdLen++] = ')';
    aubPCLFontHdrCmd[dwFontHdrCmdLen++] = 's';
    dwFontHdrCmdLen += strlen(_ltoa(wSend,
                                    &aubPCLFontHdrCmd[dwFontHdrCmdLen],
                                    10));
    aubPCLFontHdrCmd[dwFontHdrCmdLen++] = 'W';

#if 0
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                        aubPCLFontHdrCmd,
                                        dwFontHdrCmdLen);
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                        (BYTE *)&sfh,
                                        wSend );
#endif

    return 2048;
}


DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth)
{
    GETINFO_GLYPHBITMAP GBmp;
    CH_HEADER           chh;
    GLYPHBITS          *pgb;

    DWORD dwCharHdrCmdLen, dwGetInfo;
    LONG  cbLines, cbSend;
    BYTE  aubPCLCharHdrCmd[20];

    DbgPrint(DLLTEXT("OEMDownloadCharGlyph() entry.\r\n"));
    DbgPrint(DLLTEXT("ulFontID = %d\n"), pUFObj->ulFontID);
    DbgPrint(DLLTEXT("hGlyph   = %d\n"), hGlyph);

    //
    // Get the character information.
    //

    dwGetInfo       =
    GBmp.dwSize     = sizeof(GETINFO_GLYPHBITMAP);
    GBmp.hGlyph     = hGlyph;
    GBmp.pGlyphData = NULL;

    if (!pUFObj->pfnGetInfo(pUFObj,
                            UFO_GETINFO_GLYPHBITMAP,
                            (PVOID)&GBmp,
                            dwGetInfo,
                            &dwGetInfo))
    {
        DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\r\n"));
        return 0;
    }
    pgb = GBmp.pGlyphData->gdf.pgb;

    DbgPrint(DLLTEXT("ptlOrigin.x   = %d\n"),pgb->ptlOrigin.x);
    DbgPrint(DLLTEXT("ptlOrigin.y   = %d\n"),pgb->ptlOrigin.y);
    DbgPrint(DLLTEXT("sizlBitmap.cx = %d\n"),pgb->sizlBitmap.cx);
    DbgPrint(DLLTEXT("sizlBitmap.cy = %d\n"),pgb->sizlBitmap.cy);

    //
    // Fill int character header.
    //

    ZeroMemory( &chh, sizeof( chh ) );           // Safe initial values

    chh.bFormat       = CH_FM_RASTER;
    chh.bContinuation = 0;
    chh.bDescSize     = sizeof( chh ) - sizeof( CH_CONT_HDR );
    chh.bClass        = CH_CL_BITMAP;

    chh.bOrientation = 0;        /* !!!LindsayH: NEED ORIENTATION!!! */

    chh.sLOff     = (short) pgb->ptlOrigin.x;
    chh.sTOff     = (short)-pgb->ptlOrigin.y;
    chh.wChWidth  = (WORD)  pgb->sizlBitmap.cx;
    chh.wChHeight = (WORD)  pgb->sizlBitmap.cy;
    chh.wDeltaX   = (WORD)  ((GBmp.pGlyphData->ptqD.x.HighPart + 3) >> 2);

    cbLines = (chh.wChWidth + BBITS - 1) / BBITS;
    cbSend = sizeof(chh) + cbLines * (WORD) pgb->sizlBitmap.cy;

    SWAB( chh.sLOff );
    SWAB( chh.sTOff );
    SWAB( chh.wChWidth );
    SWAB( chh.wChHeight );
    SWAB( chh.wDeltaX );

    ZeroMemory( aubPCLCharHdrCmd, sizeof( aubPCLCharHdrCmd ) );

    //
    //"\x1B(s%dW", cbSend
    //

    dwCharHdrCmdLen = 0;
    aubPCLCharHdrCmd[dwCharHdrCmdLen++] = 0x1B;
    aubPCLCharHdrCmd[dwCharHdrCmdLen++] = '(';
    aubPCLCharHdrCmd[dwCharHdrCmdLen++] = 's';
    dwCharHdrCmdLen += strlen(_ltoa(cbSend,
                                   &aubPCLCharHdrCmd[dwCharHdrCmdLen],
                                   10));
    aubPCLCharHdrCmd[dwCharHdrCmdLen++] = 'W';

#if 0
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                         aubPCLCharHdrCmd,
                                         dwCharHdrCmdLen);
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                         (BYTE *)&chh,
                                         sizeof( chh ));
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                         pgb->aj,
                                         cbSend-sizeof(chh));
#endif

    DbgPrint(DLLTEXT("OEMDownloadCharGlyph returns %d\n"),
            cbLines * pgb->sizlBitmap.cy);

    return cbLines * pgb->sizlBitmap.cy;
}


DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj)
{
    GETINFO_MEMORY Memory;
    DWORD          dwGetInfo;

    DbgPrint(DLLTEXT("OEMTTDownloadMethod() entry.\r\n"));

    if (pUFObj->pfnGetInfo(pUFObj,
                           UFO_GETINFO_MEMORY,
                           (PVOID)&Memory,
                           dwGetInfo,
                           &dwGetInfo))
    {
        DbgPrint(DLLTEXT("dwRemainingMemory = %d\n"), Memory.dwRemainingMemory);
    }
    else
    {
        DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_MEMORY failed.\r\n"));
        return 0;
    }

    return TTDOWNLOAD_BITMAP;
}


VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    GETINFO_GLYPHWIDTH  GWidth;
    BYTE  aubBuff[256];
    PTRANSDATA pTrans;
    PDWORD pdwGlyphID;
    PLONG  plWidth;
    PWORD  pwUnicode;
    DWORD  dwI, dwGetInfo;

    DbgPrint(DLLTEXT("OEMOutputCharStr() entry.\r\n"));

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:
        DbgPrint(DLLTEXT("dwType = TYPE_GLYPHHANDLE\n"));

        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_UNICODE;
        GStr.pGlyphOut = aubBuff;
        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHSTRING,
                                &GStr,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return;
        }

        pwUnicode = (PWORD)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("Unicode[%d] = %x\r\n"), dwI, pwUnicode[dwI]);
        }

        GStr.dwTypeOut = TYPE_TRANSDATA;
        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHSTRING,
                                &GStr,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return;
        }

        pTrans = (PTRANSDATA)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubCodePageID:0x%x\n"),pTrans->ubCodePageID);
            DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubType:0x%x\n"),pTrans->ubType);
            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_DIRECT: 
                DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubCode:0x%x\n"),pTrans->uCode.ubCode);
#if 0
                pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                                     &pTrans->uCode.ubCode,
                                                     1);
#endif
                break;
            case MTYPE_PAIRED: 
                DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubPairs:0x%x\n"),*(PWORD)(pTrans->uCode.ubPairs));
#if 0
                pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                                     pTrans->uCode.ubPairs,
                                                     2);
#endif
                break;
            }
        }
        GWidth.dwSize = sizeof(GETINFO_GLYPHSTRING);
        GWidth.dwCount = dwCount;
        GWidth.dwType = TYPE_GLYPHHANDLE;
        GWidth.pGlyph = pGlyph;
        GWidth.plWidth = (PLONG)aubBuff;
        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHWIDTH,
                                &GWidth,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHWIDTH failed.\r\n"));
            return;
        }
        plWidth = (PLONG)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("Width[%d] = %d\r\n"), dwI, plWidth[dwI]);
        }
        break;

    case TYPE_GLYPHID:
        DbgPrint(DLLTEXT("dwType = TYPE_GLYPHID\n"));

        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHID;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_GLYPHHANDLE;
        GStr.pGlyphOut = aubBuff;

        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHSTRING,
                                &GStr,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        }
        pdwGlyphID = (PDWORD)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("GlyphHandle[%d] = %d\r\n"), dwI, pdwGlyphID[dwI]);
        }

        GStr.dwTypeOut = TYPE_UNICODE;
        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHSTRING,
                                &GStr,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        }
        pwUnicode = (PWORD)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("Unicode[%d] = %x\r\n"), dwI, pwUnicode[dwI]);
        }

        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {
            DbgPrint(DLLTEXT("TYEP_GLYPHID:0x%x\n"), *(PDWORD)pGlyph);
#if 0
            pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                                 (PBYTE)pGlyph,
                                                 1);
#endif
        }
        GWidth.dwSize  = sizeof(GETINFO_GLYPHSTRING);
        GWidth.dwCount = dwCount;
        GWidth.dwType  = TYPE_GLYPHID;
        GWidth.pGlyph  = pGlyph;
        GWidth.plWidth = (PLONG)aubBuff;
        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHWIDTH,
                                (PVOID)&GWidth,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHWIDTH failed.\r\n"));
            return;
        }
        plWidth = (PLONG)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("Width[%d] = %d\r\n"), dwI, plWidth[dwI]);
        }
        break;
    }
}


VOID APIENTRY
OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD adwStdVariable[2+2*4];
    DWORD dwIn, dwOut, dwGetInfo;
    PBYTE pubCmd;
    BYTE  aubCmd[80];

    GETINFO_FONTOBJ FO;

    DbgPrint(DLLTEXT("OEMSendFontCmd() entry.\r\n"));

    pubCmd = pFInv->pubCommand;

    //
    // Callback function testing
    //

    //
    // GETINFO_FONTOBJ
    //
    FO.dwSize = sizeof(GETINFO_FONTOBJ);
    FO.pFontObj = NULL;

    if (!pUFObj->pfnGetInfo(pUFObj,
                            UFO_GETINFO_FONTOBJ,
                            (PVOID)&FO,
                            dwGetInfo,
                            &dwGetInfo))
    {
        DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_FONTOBJ failed.\r\n"));
        return;
    }
    DbgPrint(DLLTEXT("FontObj.iUniq=%d\r\n"), FO.pFontObj->iUniq);
    DbgPrint(DLLTEXT("FontObj.iFace=%d\r\n"), FO.pFontObj->iFace);
    DbgPrint(DLLTEXT("FontObj.cxMax=%d\r\n"), FO.pFontObj->cxMax);
    DbgPrint(DLLTEXT("FontObj.flFontType=%d\r\n"), FO.pFontObj->flFontType);
    DbgPrint(DLLTEXT("FontObj.iTTUniq=%d\r\n"), FO.pFontObj->iTTUniq);
    DbgPrint(DLLTEXT("FontObj.iFile=%d\r\n"), FO.pFontObj->iFile);
    DbgPrint(DLLTEXT("FontObj.sizLogResPpi.cx=%d\r\n"), FO.pFontObj->sizLogResPpi.cx);
    DbgPrint(DLLTEXT("FontObj.sizLogResPpi.cy=%d\r\n"), FO.pFontObj->sizLogResPpi.cy);
    DbgPrint(DLLTEXT("FontObj.pvConsumer=%d\r\n"), FO.pFontObj->pvConsumer);
    DbgPrint(DLLTEXT("FontObj.pvProducer=%d\r\n"), FO.pFontObj->pvProducer);


    //
    // Get standard variables.
    //

    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (5 - 1);
    pSV->dwNumOfVariable = 5;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj,
                            UFO_GETINFO_STDVARIABLE,
                            (PVOID)pSV,
                            dwGetInfo,
                            &dwGetInfo))
    {
        DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }

    DbgPrint(DLLTEXT("FNT_INFO_FONTHEIGHT:%d\n"),pSV->StdVar[0].lStdVariable);
    DbgPrint(DLLTEXT("FNT_INFO_FONTWIDTH:%d\n"),pSV->StdVar[1].lStdVariable);
    DbgPrint(DLLTEXT("FNT_INFO_FONTTEXTYRES:%d\n"),pSV->StdVar[2].lStdVariable);
    DbgPrint(DLLTEXT("FNT_INFO_FONTTEXTXRES:%d\n"),pSV->StdVar[3].lStdVariable);

    dwOut = 0;

    for( dwIn = 0; dwIn < pFInv->dwCount;)
    {
        if (pubCmd[dwIn] == '#')
        {
            dwIn ++;
            if (pubCmd[dwIn] == 'v' || pubCmd[dwIn] == 'V')
            {
                dwOut += LConvertFontSizeToStr(
                                LGetPointSize100(pSV->StdVar[0].lStdVariable,
                                                 600),
                                (PSTR)&aubCmd[dwOut]);
            }
            else if ((pubCmd[dwIn] == 'h' || pubCmd[dwIn] == 'H')    // pitch
                     && pSV->StdVar[1].lStdVariable > 0)
            {
                dwOut += LConvertFontSizeToStr(
                              (LONG)MulDiv(600, 100,
                                           pSV->StdVar[1].lStdVariable),
                              (PSTR)&aubCmd[dwOut]);
            }
            else
            {
                return;
            }
        }
        else
        {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }
#if  0
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, aubCmd, dwOut);
#endif

}


LONG
LGetPointSize100(
    LONG height,
    LONG vertRes)
{
    LONG tmp = ((LONG)height * (LONG)7200) / (LONG)vertRes;

    //
    // round to the nearest quarter point.
    //
    return 25 * ((tmp + 12) / (LONG)25);
}

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr)
{
    register long count;

    if (size % 100 == 0)
    {
        count = strlen(_ltoa(size / 100, pStr, 10));
    }
    else if (size % 10 == 0)
    {
        count           = strlen(_ltoa(size / 10, pStr, 10));
        pStr[count]     = pStr[count - 1];
        pStr[count - 1] = '.';
        pStr[++count]   = '\0';
    }
    else
    {
        count           = strlen(_ltoa(size, pStr, 10));
        pStr[count]     = pStr[count - 1];
        pStr[count - 1] = pStr[count - 2];
        pStr[count - 2] = '.';
        pStr[++count]   = '\0';
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\ui\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#include "stddef.h"
#include "stdlib.h"
#include "objbase.h"
#include <windows.h>
#include <assert.h>
#include <prsht.h>
#include <compstui.h>
#include <winddiui.h>
#include "printoem.h"
#include <initguid.h>
#include "prcomoem.h"
#include "oemui.h"
#include "..\inc\name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks
// Friendly name of component
const char g_szFriendlyName[] = "UNIDRV Plugin UI callback test";

// Version-independent ProgID
const char g_szVerIndProgID[] = "UNIDRV.Plugin.UI.callback.test";

// ProgID
const char g_szProgID[] = "UNIDRV.Plugin.UI.callbak.test.1";


BOOL DebugMsgA(LPCSTR lpszMessage, ...);
BOOL DebugMsgW(LPCWSTR lpszMessage, ...);

#if UNICODE
#define DebugMsg    DebugMsgW
#else
#define DebugMsg    DebugMsgA
#endif

#include "comoem.h"

////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
IOemCB::~IOemCB()
{
    // Make sure that helper interface is released.
    if(NULL != this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == this->m_cRef);
}

HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    DebugMsg(DLLTEXT("IOemCB:QueryInterface entry.\n\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IUnknown.\n\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IPrintOemUI.\n")); 
    }
    else
    {
        *ppv = NULL ;
        DebugMsg(DLLTEXT("IOemCB:No Interface. Return NULL.\n")); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    DebugMsg(DLLTEXT("IOemCB:AddRef entry.\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    DebugMsg(DLLTEXT("IOemCB:Release entry.\n")); 
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

HRESULT __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    DebugMsg(DLLTEXT("IOemCB:PublishDriverInterface entry.\n")); 

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT __stdcall IOemCB::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{

    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}

HRESULT __stdcall IOemCB::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
#if 1
{   
    DebugMsg(DLLTEXT("IOemCB:DevMode entry.\n")); 
    return E_NOTIMPL;
}
#else
{
    OEMDevMode(dwMode, pOemDMParam);
    return S_OK;
}
#endif

HRESULT __stdcall IOemCB::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    OEMCommonUIProp(dwMode, pOemCUIPParam);
    return S_OK;
}


HRESULT __stdcall IOemCB::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    OEMDocumentPropertySheets(pPSUIInfo, lParam);
    return S_OK;
}

HRESULT __stdcall IOemCB::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    OEMDevicePropertySheets(pPSUIInfo, lParam);
    return S_OK;
}

HRESULT __stdcall IOemCB::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
#if 0
{
    *dwResult = OEMDeviceCapabilities(poemuiobj, hPrinter, pDeviceName, wCapability, pOutput,
    pPublicDM, pOEMDM, dwOld);

    return S_OK;
}
#else
{
    DebugMsg(DLLTEXT("IOemCB:DeviceCapabilities entry.\n"));
    return E_NOTIMPL;
}
#endif

HRESULT __stdcall IOemCB::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    OEMDevQueryPrintEx(poemuiobj, pDQPInfo, pPublicDM, pOEMDM);
    return S_OK;
}

HRESULT __stdcall IOemCB::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    OEMUpgradePrinter(dwLevel, pDriverUpgradeInfo);
    return S_OK;
}

HRESULT __stdcall IOemCB::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    OEMPrinterEvent(pPrinterName, iDriverEvent, dwFlags, lParam);
    return S_OK;
}

HRESULT __stdcall IOemCB::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    DebugMsg(DLLTEXT("IOemCB:DriverEvent entry.\n"));
    return E_NOTIMPL;
};

HRESULT __stdcall IOemCB::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{ 
    DebugMsg(DLLTEXT("IOemCB:QueryColorProfile entry.\n"));
    return E_NOTIMPL;
};

HRESULT __stdcall IOemCB::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WORD    wParam,
        LONG    lParam) 
{
    DebugMsg(DLLTEXT("IOemCB:FontInstallerDlgProc entry.\n"));
    return E_NOTIMPL;
};

HRESULT __stdcall IOemCB::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    DebugMsg(DLLTEXT("IOemCB:UpdateExternalFonts entry.\n"));
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
#undef INTERFACE
#define INTERFACE IOemCF
DECLARE_INTERFACE_(IOemCF, IClassFactory)
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
//    ~IOemCF() {DbgPrint(DLLTEXT("IOemCFt\tDestroy self.")); };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//

#if 0
BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;

    // pOemCB->AddRef();    // shouldn't do this since constructor already sets m_cRef=1

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}
#endif

//
// Registration functions
// Testing purpose
//

// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    DebugMsg(DLLTEXT("DllGetClassObject:Create class factory.\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule, 
                          CLSID_OEMUI,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMUI,
                            g_szVerIndProgID,
                            g_szProgID) ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\renduni\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H
#define _WIN32_WINNT 0x0500

#include <lib.h>
#include <printoem.h>



////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////
#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

////////////////////////////////////////////////////////
// OEM Signature and version.
////////////////////////////////////////////////////////
#define OEM_SIGNATURE   'FTCB'      // Raster module callback test dll
#define DLLTEXT(s)      __TEXT("RENDUNI:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L


///////////////////////////////////////////////////////
// Warning: the following enum order must match the order in OEMHookFuncs[].
///////////////////////////////////////////////////////
enum {
    UD_DrvRealizeBrush,
    UD_DrvDitherColor,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvPaint,
    UD_DrvLineTo,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvNextBand,
    UD_DrvStartBanding,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,

    MAX_DDI_HOOKS,
};
typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // This test DLL hooks out every drawing DDI. So it needs to remember
    // Unidrv's hook function pointer so it call back.
    //
    PFN     pfnUnidrv[MAX_DDI_HOOKS];

    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    DWORD     dwReserved[1];

} OEMPDEV, *POEMPDEV;

#ifndef DBG
#define DbgPrint    MyDbgPrint
ULONG _cdecl MyDbgPrint(PCSTR, ...);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\ui\comoem.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// IOemCB
//
class IOemCB: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WORD    wParam,
            LONG    lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
//    ~IOemCB() {DbgPrint(DLLTEXT("IOemCB:\t\tDestroy self.")); };
    ~IOemCB();
    IOemCBInit();

protected:
    IPrintOemDriverUI* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\inc\oemdev.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    oemdev.h

Abstract:

    OEM DEVMODE

Environment:

    Windows NT printer driver

Revision History:

    01/02/97 -eigos-
        Created it.

    dd-mm-yy -author-
        description

--*/

#define OEM_DEVMODE_VERSION_1_0 0x00010000

#ifdef PSCRIPT

typedef struct _CMD_INJECTION {
    DWORD dwbSize;
    DWORD dwIndex;
    DWORD loOffset;
} CMD_INJECTION;

#define NUM_OF_PS_INJECTION 5

typedef struct _OEMDEVMODE {
    OEM_DMEXTRAHEADER DMExtraHdr;
    CMD_INJECTION     InjectCmd[NUM_OF_PS_INJECTION];
} OEMDEVMODE, *POEMDEVMODE;

#else
typedef struct _OEMDEVMODE {
    DMEXTRADR DMExtraHdr;
    DWORD     dwTest;
} OEMDEVMODE, *POEMDEVMODE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\ui\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//
#ifndef _OEMUI_H
#define _OEMUI_H


////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////

// fMode values.
#define OEMDM_SIZE      1
#define OEMDM_DEFAULT   2
#define OEMDM_CONVERT   3
#define OEMDM_VALIDATE  4

// OEM Signature and version.
    #define OEM_SIGNATURE	'Test'
    #define TESTSTRING      "This is a test."
    #define PROP_TITLE      L"OEM UI Page"
    #define DLLTEXT(s)      __TEXT("UI:  ") __TEXT(s)
#define OEM_VERSION      0x82824141L

// OEM UI Misc defines.
#define OEM_ITEMS       5
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


////////////////////////////////////////////////////////
//      OEM UI Type Defines
////////////////////////////////////////////////////////

typedef struct tag_DMEXTRAHDR {
    DWORD   dwSize;
    DWORD   dwSignature;
    DWORD   dwVersion;
} DMEXTRAHDR, *PDMEXTRAHDR;


typedef struct tag_OEMUI_EXTRADATA {
    DMEXTRAHDR  dmExtraHdr;
    BYTE        cbTestString[sizeof(TESTSTRING)];
} OEMUI_EXTRADATA, *POEMUI_EXTRADATA;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\ui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUI.rc
//
#define IDD_DOC_PROPPAGE                102
#define IDD_DEV_PROPPAGE                103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\km\globals.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    globals.c

Abstract:

    Global variables used by the OEM PostScript rendering dll

Environment:

    Windows NT PostScript driver

Revision History:

    09/09/96 -eigos-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "oem.h"


#ifdef PSCRIPT

//
// Global variables
//

char gcstrTest_BEGINSTREAM[]   = "%%Test: Before begin stream\r\n";
char gcstrTest_PSADOBE[]       = "%%Test: Before %!PS-Adobe\r\n";
char gcstrTest_COMMENTS[]      = "%%Test: Before %%EndComments\r\n";
char gcstrTest_DEFAULTS[]      = "%%Test: Before %%BeginDefaults and %%EndDefaults\r\n";
char gcstrTest_BEGINPROLOG[]   = "%%Test: After %%BeginProlog\r\n";
char gcstrTest_ENDPROLOG[]     = "%%Test: Before %%EndProlog\r\n";
char gcstrTest_BEGINSETUP[]    = "%%Test: After %%BeginSetup\r\n";
char gcstrTest_ENDSETUP[]      = "%%Test: Before %%EndSetup\r\n";
char gcstrTest_BEGINPAGESETUP[]= "%%Test: After %%BeginPageSetup\r\n";
char gcstrTest_ENDPAGESETUP[]  = "%%Test: Before %%EndpageSetup\r\n";
char gcstrTest_PAGETRAILER[]   = "%%Test: After %%PageTrailer\r\n";
char gcstrTest_TRAILER[]       = "%%Test: After %%Trailer\r\n";
char gcstrTest_PAGES[]         = "%%Test: Replace driver's %%Pages: (atend)\r\n";
char gcstrTest_PAGENUMBER[]    = "%%Test: Replace driver's %%Page:\r\n";
char gcstrTest_PAGEORDER[]     = "%%Test: Replace driver's %%PageOrder:\r\n";
char gcstrTest_ORIENTATION[]   = "%%Test: Replace driver's %%Orientation:\r\n";
char gcstrTest_BOUNDINGBOX[]   = "%%Test: Replace driver's %%BoundingBox:\r\n";
char gcstrTest_DOCNEEDEDRES[]  = "%%Test: Append to driver's %%DocumentNeededResourc\r\n";
char gcstrTest_DOCSUPPLIEDRES[]= "%%Test: Append to driver's %%DocumentSuppliedResou\r\n";
char gcstrTest_EOF[]           = "%%Test: After %%EOF\r\n";
char gcstrTest_ENDSTREAM[]     = "%%Test: After the last byte of job stream\r\n";
char gcstrTest_VMSAVE[]        = "%%Test: VMSave\r\n";
char gcstrTest_VMRESTORE[]     = "%%Test: VMRestore\n";

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\km\oem.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oem.h

Abstract:

    OEM rendering module main header file.
    All other header files should be included in this for precompiled headers
    to work.

Environment:

    Windows NT printer driver

Revision History:

    09/09/96 -eigos-
        Created it.

    mm/dd/yy -author-
        description

--*/


#ifndef _OEM_H_
#define _OEM_H_

#include "lib.h"
#include "printoem.h"
#include "oemutil.h"
#include "oemdev.h"

#define OEM_DRIVER_VERSION 0x0500

//
// PSINECT macros
// These should be in winddi.h
//

#define PSINJECT_BEGINSTREAM     0 // before the first byte of job stream
#define PSINJECT_PSADOBE         1 // before %!PS-Adobe
#define PSINJECT_COMMENTS        2 // before %%EndComments
#define PSINJECT_DEFAULTS        3 // before %%BeginDefaults and %%EndDefaults
#define PSINJECT_BEGINPROLOG     4 // after %%BeginProlog
#define PSINJECT_ENDPROLOG       5 // before %%EndProlog
#define PSINJECT_BEGINSETUP      6 // after %%BeginSetup
#define PSINJECT_ENDSETUP        7 // before %%EndSetup
#define PSINJECT_BEGINPAGESETUP  8 // after %%BeginPageSetup
#define PSINJECT_ENDPAGESETUP    9 // before %%EndpageSetup
#define PSINJECT_PAGETRAILER    10 // after %%PageTrailer
#define PSINJECT_TRAILER        11 // after %%Trailer
#define PSINJECT_PAGES          12 // replace driver's %%Pages: (atend)
#define PSINJECT_PAGENUMBER     13 // replace driver's %%Page:
#define PSINJECT_PAGEORDER      14 // replace driver's %%PageOrder:
#define PSINJECT_ORIENTATION    15 // replace driver's %%Orientation:
#define PSINJECT_BOUNDINGBOX    16 // replace driver's %%BoundingBox:
#define PSINJECT_DOCNEEDEDRES   17 // append to driver's %%DocumentNeededResources.
#define PSINJECT_DOCSUPPLIEDRES 18 // append to driver's %%DocumentSuppliedResources.
#define PSINJECT_EOF            19 // after %%EOF
#define PSINJECT_ENDSTREAM      20 // after the last byte of job stream
#define PSINJECT_VMSAVE         21 // Driver has sent a "save" command. OEM
                                   // uses this to track its resources
                                   // on the printer.
#define PSINJECT_VMRESTORE      22 // Driver is about to send a "restore"
                                   // command. OEM has to resend any resources
                                   // it sent after the last "save"
                                   // before using them again.

//
// OEM Physical Device
//

typedef struct _OEMPDEV {
    DWORD dwSize;
    PFN   pfnFunc[INDEX_LAST];
} OEMPDEV, *POEMPDEV;


#ifdef PSCRIPT

char gcstrTest1[];

char gcstrTest_BEGINSTREAM[];
char gcstrTest_PSADOBE[];
char gcstrTest_COMMENTS[];
char gcstrTest_DEFAULTS[];
char gcstrTest_BEGINPROLOG[];
char gcstrTest_ENDPROLOG[];
char gcstrTest_BEGINSETUP[];
char gcstrTest_ENDSETUP[];
char gcstrTest_BEGINPAGESETUP[];
char gcstrTest_ENDPAGESETUP[];
char gcstrTest_PAGETRAILER[];
char gcstrTest_TRAILER[];
char gcstrTest_PAGES[];
char gcstrTest_PAGENUMBER[];
char gcstrTest_PAGEORDER[];
char gcstrTest_ORIENTATION[];
char gcstrTest_BOUNDINGBOX[];
char gcstrTest_DOCNEEDEDRES[];
char gcstrTest_DOCSUPPLIEDRES[];
char gcstrTest_EOF[];
char gcstrTest_ENDSTREAM[];
char gcstrTest_VMSAVE[];
char gcstrTest_VMRESTORE[];
#endif

//
// Helper functions
//

VOID
VCreateDDIEntryPointsTable(
    POEMPDEV       pOEMPDev,
    DRVENABLEDATA *pded);


#endif // _OEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\com\ui\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 95, Windows NT
//
//

#include "stddef.h"
#include "stdlib.h"
#include "objbase.h"
#include <windows.h>
#include <assert.h>
#include <prsht.h>
#include <compstui.h>
#include <winddiui.h>
#include "printoem.h"
#include "resource.h"
#include "oemui.h"



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

#ifdef _UNICODE
    #define DebugMsg    DebugMsgW
#else
    #define DebugMsg    DebugMsgA
#endif


#define NUM_DRIVER_FEATURES        13


////////////////////////////////////////////////////////
//      INTERNAL GLOBALS
////////////////////////////////////////////////////////

LPTSTR OEM_INFO[] = {   
    __TEXT("Bad Index"),
    __TEXT("OEM_GETSIGNATURE"),
    __TEXT("OEM_GETINTERFACEVERSION"),
    __TEXT("OEMGETVERSION"),
};

LPTSTR OEMCommonUIProp_Mode[] = {
    __TEXT("Bad Index"),
    __TEXT("OEMCUIP_DOCPROP"),
    __TEXT("OEMCUIP_PRNPROP"),
};

LPTSTR OEMDevMode_fMode[] = {
    __TEXT("NULL"),
    __TEXT("OEMDM_SIZE"),
    __TEXT("OEMDM_DEFAULT"),
    __TEXT("OEMDM_CONVERT"),
    __TEXT("OEMDM_MERGE"),
};


HINSTANCE ghInstance = NULL;


////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

LONG APIENTRY OEMUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
BOOL DebugMsgA(LPCSTR lpszMessage, ...);
BOOL DebugMsgW(LPCWSTR lpszMessage, ...);
static BOOL IsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static BOOL IsValidOEMExtraData(PVOID pOEMExtra, DWORD dwSize);
static BOOL InitOEMExtraData(PVOID pOEMExtra, DWORD dwSize);
static BOOL IsValidOEMUIParam(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
BOOL APIENTRY PropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
void DumpOEMUIParam(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
void DumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);
void DumpDevMode(PDEVMODE pDevMode);
BOOL IsValidOEMUIOBJ(POEMUIOBJ poemuiobj);
void ExerciseOEMUIOBJ(POEMUIOBJ poemuiobj);
static BOOL MergeOEMExtraData(POEMUI_EXTRADATA pdmIn, POEMUI_EXTRADATA pdmOut);


// Need to export these functions as c declarations.
extern "C" {



//////////////////////////////////////////////////////////////////////////
//  Function:    DllMain
//
//  Description:  Dll entry point for initialization..
//    
//
//  Comments:
//     
//
//  History:
//        1/27/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
    switch(wReason)
    {
        case DLL_PROCESS_ATTACH:
            DebugMsg(DLLTEXT("Process attach.\r\n"));

            // Save DLL instance for use later.
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            DebugMsg(DLLTEXT("Thread attach.\r\n"));
            break;

        case DLL_PROCESS_DETACH:
            DebugMsg(DLLTEXT("Process detach.\r\n"));
            break;

        case DLL_THREAD_DETACH:
            DebugMsg(DLLTEXT("Thread detach.\r\n"));
            break;
    }

    return TRUE;
}


BOOL APIENTRY OEMGetInfo(IN DWORD dwInfo, OUT PVOID pBuffer, IN DWORD cbSize, 
                         OUT PDWORD pcbNeeded)
{
    DebugMsg(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo)
          &&
          (OEMGI_GETINTERFACEVERSION != dwInfo)
          &&
          (OEMGI_GETVERSION != dwInfo)
        )
        ||
        ( (NULL != pBuffer)
          &&
          IsBadWritePtr(pBuffer, cbSize)
        )
        ||
        (NULL == pcbNeeded)
      )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
            *pcbNeeded = 0;

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if(    (NULL == pBuffer)
        ||
        (4 > cbSize)
      )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        // Return insufficient buffer size.
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
        case OEMGI_GETSIGNATURE:
            *(LPDWORD)pBuffer = OEM_SIGNATURE;
            break;

        case OEMGI_GETINTERFACEVERSION:
            *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
            break;

        case OEMGI_GETVERSION:
            *(LPDWORD)pBuffer = OEM_VERSION;
            break;
    }

    return TRUE;
}


#if 0
BOOL APIENTRY OEMDevMode(IN DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    DebugMsg(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[NULL != pOEMDevModeParam ? dwMode : 0]);

    // Validate parameters.
      if(!IsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DebugMsg(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n"));
        DumpOEMDevModeParam(pOEMDevModeParam);
        DebugBreak();

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) 
        &&
        sizeof(OEMUI_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DebugMsg(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        // Return insuffient buffer error.
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Handle fModes.
    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOEMDevModeParam->cbBufSize = sizeof(OEMUI_EXTRADATA);
            break;

        case OEMDM_DEFAULT:
            return InitOEMExtraData(pOEMDevModeParam->pOEMDMOut, pOEMDevModeParam->cbBufSize);

        case OEMDM_CONVERT:
            return InitOEMExtraData(pOEMDevModeParam->pOEMDMOut, pOEMDevModeParam->cbBufSize);

        case OEMDM_MERGE:
            DumpDevMode(pOEMDevModeParam->pPublicDMIn);
            if(!MergeOEMExtraData((POEMUI_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                                   (POEMUI_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
            {
                DebugMsg(DLLTEXT("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

                return FALSE;
            }
            DumpDevMode(pOEMDevModeParam->pPublicDMIn);
            break;
    }

    return TRUE;
}
#endif

BOOL APIENTRY OEMCommonUIProp(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    DebugMsg(DLLTEXT("OEMCommonUI(%s) entry.\r\n"), OEMCommonUIProp_Mode[dwMode]);

    // Validate parameters.
    if( ( (OEMCUIP_DOCPROP != dwMode)
          &&
          (OEMCUIP_PRNPROP != dwMode)
        )
        ||
        !IsValidOEMUIParam(dwMode, pOEMUIParam)
      )
    {
        DebugMsg(ERRORTEXT("OEMCommonUI() ERROR_INVALID_PARAMETER.\r\n"));

        DebugMsg(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);
        DumpOEMUIParam(dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Return number of requested tree view items to add.
        pOEMUIParam->cOEMOptItems = OEM_ITEMS;

        DebugMsg(DLLTEXT("OEMCommonUI() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        DebugMsg(DLLTEXT("OEMCommonUI() fill out items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init OEMOptItmes.
        memset(pOEMUIParam->pOEMOptItems, 0, sizeof(OPTITEM) * pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.
        for(DWORD dwCount = 0; dwCount < pOEMUIParam->cOEMOptItems; dwCount++)
        {
            pOEMUIParam->pOEMOptItems[dwCount].cbSize = sizeof(OPTITEM);
            pOEMUIParam->pOEMOptItems[dwCount].Level = 1;
            pOEMUIParam->pOEMOptItems[dwCount].Flags = 0; //OPTIF_CALLBACK | OPTIF_HAS_POIEXT;
            pOEMUIParam->pOEMOptItems[dwCount].pName = (LPTSTR) HeapAlloc(pOEMUIParam->hOEMHeap, HEAP_ZERO_MEMORY, 64);
            wsprintfW((LPWSTR)pOEMUIParam->pOEMOptItems[dwCount].pName, L"OEM UI %d", dwCount);
            pOEMUIParam->pOEMOptItems[dwCount].DMPubID = DMPUB_NONE;
            pOEMUIParam->OEMCUIPCallback = OEMUICallBack;
        }
    }

    return TRUE;
}


LONG APIENTRY OEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LONG    lResult = FALSE;


    DebugMsg(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        IsBadWritePtr(pPSUIInfo, pPSUIInfo->cbSize)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
        ||
        ( (PROPSHEETUI_REASON_INIT != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_GET_INFO_HEADER != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_GET_ICON != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_SET_RESULT != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_DESTROY != pPSUIInfo->Reason)
        )
      )
    {
        DebugMsg(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;

                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize = sizeof(PROPSHEETPAGE);
                Page.dwFlags = PSP_DEFAULT;
                Page.hInstance = ghInstance;
                Page.pszTemplate = MAKEINTRESOURCE(IDD_DOC_PROPPAGE);
                Page.pfnDlgProc = (DLGPROC) PropPageProc;

                // Add property sheets.
                lResult = (pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE,
                                                      (LPARAM)&Page, 0) > 0 ? TRUE : FALSE);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return lResult;
}


LONG APIENTRY OEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LONG    lResult;


    DebugMsg(DLLTEXT("OEMDevicePropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        IsBadWritePtr(pPSUIInfo, pPSUIInfo->cbSize)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        DebugMsg(ERRORTEXT("OEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;

                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize = sizeof(PROPSHEETPAGE);
                Page.dwFlags = PSP_DEFAULT;
                Page.hInstance = ghInstance;
                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEV_PROPPAGE);
                Page.pfnDlgProc = (DLGPROC) PropPageProc;

                // Add property sheets.
                lResult = (pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE,
                                                      (LPARAM)&Page, 0) > 0 ? TRUE : FALSE);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return lResult;
}


BOOL APIENTRY OEMDevQueryPrintEx(IN POEMUIOBJ poemuiobj, IN PDEVQUERYPRINT_INFO pDQPInfo, 
                                 IN PDEVMODE pPublicDM, IN PVOID pOEMDM)
{
    DebugMsg(DLLTEXT("OEMDevQueryPrintEx() entry.\r\n"));

    // Validate parameters.
    if( (NULL == poemuiobj)
        ||
        (NULL == pDQPInfo)
        ||
        (NULL == pPublicDM)
        ||
        IsBadReadPtr(pPublicDM, sizeof(DEVMODE))
        ||
        (NULL == pOEMDM)
        ||
        !IsValidOEMExtraData(pOEMDM, *(LPDWORD)pOEMDM)
        ||
        !IsValidOEMUIOBJ(poemuiobj)
      )
    {
        DebugMsg(ERRORTEXT("OEMDevQueryPrintEx() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ExerciseOEMUIOBJ(poemuiobj);

    return TRUE;
}


DWORD APIENTRY OEMDeviceCapabilities(IN POEMUIOBJ poemuiobj, IN HANDLE hPrinter, 
                                     IN LPWSTR pDeviceName, IN WORD wCapability, 
                                     OUT PVOID pOutput, IN PDEVMODE pPublicDM, IN PVOID pOEMDM, 
                                     IN DWORD dwLastResult)
{
    DebugMsg(DLLTEXT("OEMDeviceCapabilities() entry.\r\n"));

    // Validate parameters.
    if( (NULL == poemuiobj)
        ||
        (NULL == hPrinter)
        ||
        (NULL == pDeviceName)
        ||
        IsBadReadPtr(pDeviceName, wcslen(pDeviceName))
        ||
        (NULL == pPublicDM)
        ||
        IsBadReadPtr(pPublicDM, sizeof(DEVMODE))
        ||
        (NULL == pOEMDM)
        ||
        !IsValidOEMExtraData(pOEMDM, *(LPDWORD)pOEMDM)
        ||
        !IsValidOEMUIOBJ(poemuiobj)
      )
    {
        DebugMsg(ERRORTEXT("OEMDeviceCapabilities() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return GDI_ERROR;
    }

    ExerciseOEMUIOBJ(poemuiobj);

    // Process capability.
    switch(wCapability)
    {
        case DC_FIELDS:
            break;

        case DC_PAPERS:
            break;

        case DC_PAPERSIZE:
            break;

        case DC_PAPERNAMES:
            break;

        case DC_MINEXTENT:
            break;

        case DC_MAXEXTENT:
            break;

        case DC_BINS:
            break;

        case DC_BINNAMES:
            break;

        case DC_DUPLEX:
            break;

        case DC_SIZE:
            break;

        case DC_EXTRA:
            break;

        case DC_VERSION:
            break;

        case DC_DRIVER:
            break;

        case DC_ENUMRESOLUTIONS:
            break;

        case DC_FILEDEPENDENCIES:
            break;

        case DC_TRUETYPE:
            break;

        case DC_COPIES:
            break;
    }

    // OEM modules support no capabilities.
    return dwLastResult;
}


BOOL APIENTRY OEMUpgradePrinter(DWORD dwLevel, LPBYTE pDriverUpgradeInfo)
{
    PDRIVER_UPGRADE_INFO_1  pUpgradeInfo_1 = (PDRIVER_UPGRADE_INFO_1) pDriverUpgradeInfo;


    DebugMsg(DLLTEXT("OEMUpgradePrinter() entry.\r\n"));

    // Validate parameters.
    if( (1 != dwLevel)
        ||
        (NULL == pUpgradeInfo_1)
        ||
        IsBadReadPtr(pUpgradeInfo_1, sizeof(DRIVER_UPGRADE_INFO_1))
        ||
        (NULL == pUpgradeInfo_1->pPrinterName)
        ||
        IsBadReadPtr(pUpgradeInfo_1->pPrinterName, wcslen((LPWSTR)pUpgradeInfo_1->pPrinterName))
        ||
        (NULL == pUpgradeInfo_1->pOldDriverDirectory)
        ||
        IsBadReadPtr(pUpgradeInfo_1->pOldDriverDirectory, wcslen((LPWSTR)pUpgradeInfo_1->pOldDriverDirectory))
      )
    {
        DebugMsg(ERRORTEXT("OEMUpgradePrinter() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}


BOOL APIENTRY OEMPrinterEvent(LPWSTR pPrinterName, INT iDriverEvent, DWORD dwFlags, 
                              LPARAM lParam)
{
    DebugMsg(DLLTEXT("OEMPrinterEvent() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPrinterName)
        ||
        IsBadReadPtr(pPrinterName, wcslen(pPrinterName))
        ||
        ( (PRINTER_EVENT_ADD_CONNECTION != iDriverEvent)
          &&
          (PRINTER_EVENT_DELETE_CONNECTION != iDriverEvent)
          &&
          (PRINTER_EVENT_INITIALIZE != iDriverEvent)
          &&
          (PRINTER_EVENT_DELETE != iDriverEvent)
          &&
          (PRINTER_EVENT_CACHE_REFRESH != iDriverEvent)
          &&
          (PRINTER_EVENT_CACHE_DELETE != iDriverEvent)
        )
        ||
        ((dwFlags & ~PRINTER_EVENT_FLAG_NO_UI) != 0)
        ||
        (NULL != lParam)
      )
    {
        DebugMsg(ERRORTEXT("OEMPrinterEvent() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}


} // End of extern "C"


LONG APIENTRY OEMUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    DebugMsg(DLLTEXT("OEMUICallBack() entry.\r\n"));

    return CPSUICB_ACTION_NONE;
}




//////////////////////////////////////////////////////////////////////////
//  Function:    DebugMsgA
//
//  Description:  Outputs variable argument ANSI debug string.
//    
//
//  Parameters:    
//
//      lpszMessage     Format string.
//
//
//  Returns:  TRUE on success and FALSE on failure.
//    
//
//  Comments:
//     
//
//  History:
//        12/18/96    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMsgA(LPCSTR lpszMessage, ...)
{
#if defined(_DEBUG) || defined(DBG)
    BOOL    bResult = FALSE;
    char    szMsgBuf[1024];
    va_list VAList;


    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfA(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringA(szMsgBuf);
        va_end(VAList);
        bResult = FALSE;
    }

    return bResult;
#else
    return TRUE;
#endif
}


//////////////////////////////////////////////////////////////////////////
//  Function:    DebugMsgW
//
//  Description:  Outputs variable argument UNICODE debug string.
//    
//
//  Parameters:    
//
//      lpszMessage     Format string.
//
//
//  Returns:  TRUE on success and FALSE on failure.
//    
//
//  Comments:
//     
//
//  History:
//        12/18/96    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMsgW(LPCWSTR lpszMessage, ...)
{
#if defined(_DEBUG) || defined(DBG)
    BOOL    bResult = FALSE;
    WCHAR   szMsgBuf[1024];
    va_list VAList;


    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfW(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringW(szMsgBuf);
        va_end(VAList);
        bResult = FALSE;
    }

    return bResult;
#else
    return TRUE;
#endif
}


//////////////////////////////////////////////////////////////////////////
//  Function:    IsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//    
//
//  Parameters:    
//
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//    
//
//  Comments:
//     
//
//  History:
//        02/11/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL IsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) != pOEMDevModeParam->cbSize)
    {
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  cbSize not equel to sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_SIZE != dwMode)
        &&
        (OEMDM_DEFAULT != dwMode)
        &&
        (OEMDM_CONVERT != dwMode)
        &&
        (OEMDM_MERGE != dwMode)
      )
    {
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  invalid fMode.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if(ghInstance != pOEMDevModeParam->hModule)
    {
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  hModule is not DLL instance.\r\n"));

        bValid = FALSE;
    }

    if( (NULL != pOEMDevModeParam->pPublicDMIn)
        &&
        IsBadReadPtr(pOEMDevModeParam->pPublicDMIn, pOEMDevModeParam->pPublicDMIn->dmSize + 
                     pOEMDevModeParam->pPublicDMIn->dmDriverExtra)
      )
    {
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  pPublicDMIn is bad read ptr.\r\n"));
        //DumpDevMode(pOEMDevModeParam->pPublicDMIn);
        //DebugBreak();

        bValid = FALSE;
    }

    if(bValid && (NULL != pOEMDevModeParam->pPublicDMIn) )
    {
        if(pOEMDevModeParam->pPublicDMIn->dmSpecVersion > 200)
        {
            bValid = FALSE;
        }
    }

    if( (NULL != pOEMDevModeParam->pPublicDMOut)
        &&
        IsBadWritePtr(pOEMDevModeParam->pPublicDMOut, pOEMDevModeParam->pPublicDMOut->dmSize + 
                      pOEMDevModeParam->pPublicDMOut->dmDriverExtra)
      )
    {
        assert(0);
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  pPublicDMOut is bad write ptr.\r\n"));

        bValid = FALSE;
    }

    if( (NULL != pOEMDevModeParam->pOEMDMIn)
        &&
        (IsBadReadPtr(pOEMDevModeParam->pOEMDMIn, *(LPDWORD)pOEMDevModeParam->pOEMDMIn))
      )
    {
        assert(0);
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  pOEMDMIn is bad read ptr.\r\n"));

        bValid = FALSE;
    }

    if( (NULL != pOEMDevModeParam->pOEMDMOut)
        &&
        (IsBadWritePtr(pOEMDevModeParam->pOEMDMOut, pOEMDevModeParam->cbBufSize))
      )
    {
        assert(0);
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  pOEMDMOut is bad write ptr.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize)
        &&
        (OEMDM_MERGE != dwMode)
        &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize)
        &&
        (OEMDM_MERGE == dwMode)
        &&
        (NULL == pOEMDevModeParam->pOEMDMIn)
      )
    {
        DebugMsg(ERRORTEXT("IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DebugMsg(ERRORTEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}


//////////////////////////////////////////////////////////////////////////
//  Function:    IsValidOEMExtraData
//
//  Description:  Validates OEM Extra data.
//    
//
//  Parameters:    
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//    
//
//  Comments:
//     
//
//  History:
//        02/11/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL IsValidOEMExtraData(PVOID pOEMExtra, DWORD dwSize)
{
    BOOL                bValid = TRUE;
    POEMUI_EXTRADATA    pExtraData = (POEMUI_EXTRADATA) pOEMExtra;


    // Validate extra data.
    if(NULL == pExtraData)
    {
        DebugMsg(ERRORTEXT("IsValidOEMExtraData():  pExtraData is NULL.\r\n"));

        bValid = FALSE;
    }

    if(sizeof(OEMUI_EXTRADATA) > dwSize)
    {
        DebugMsg(ERRORTEXT("IsValidOEMExtraData():  dwSize is less than sizeof(OEMUI_EXTRADATA).\r\n"));

        bValid = FALSE;
    }

    if(NULL != pExtraData)
    {
        if(IsBadReadPtr(pExtraData, dwSize))
        {
            assert(0);
            DebugMsg(ERRORTEXT("IsValidOEMExtraData():  pExtraData is bad read ptr.\r\n"));

            bValid = FALSE;
        }

        if(sizeof(OEMUI_EXTRADATA) > pExtraData->dmExtraHdr.dwSize)
        {
            DebugMsg(ERRORTEXT("IsValidOEMExtraData():  dmExtraHdr.dwSize is less than sizeof(OEMUI_EXTRADATA).\r\n"));

            bValid = FALSE;
        }

        if(OEM_SIGNATURE != pExtraData->dmExtraHdr.dwSignature)
        {
            DebugMsg(ERRORTEXT("IsValidOEMExtraData():  dmExtraHdr.dwSignature is not OEM_SIGNATURE.\r\n"));

            bValid = FALSE;
        }

        if(OEM_VERSION != pExtraData->dmExtraHdr.dwVersion)
        {
            DebugMsg(ERRORTEXT("IsValidOEMExtraData():  dmExtraHdr.dwVersion is not OEM_VERSION.\r\n"));

            bValid = FALSE;
        }

        if(memcmp(pExtraData->cbTestString, TESTSTRING, sizeof(TESTSTRING)))
        {
            DebugMsg(ERRORTEXT("IsValidOEMExtraData():  cbTestString is not TESTSTRING.\r\n"));

            bValid = FALSE;
        }
    }

    return bValid;
}


//////////////////////////////////////////////////////////////////////////
//  Function:    InitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//    
//
//  Parameters:    
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//    
//
//  Comments:
//     
//
//  History:
//        02/11/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL InitOEMExtraData(PVOID pOEMExtra, DWORD dwSize)
{
    POEMUI_EXTRADATA  pExtraData = (POEMUI_EXTRADATA) pOEMExtra;

    // Initialize OEM Extra data.
    pExtraData->dmExtraHdr.dwSize = dwSize;
    pExtraData->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pExtraData->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pExtraData->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:    IsValidOEMUIParam
//
//  Description:  Validates OEMUI_PARAM structure.
//    
//
//  Parameters:    
//
//      pOEMUIParam     Pointer to an OEM param structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//    
//
//  Comments:
//     
//
//  History:
//        02/11/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL IsValidOEMUIParam(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMUIParam)
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pOEMUIParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMCUIPPARAM) != pOEMUIParam->cbSize)
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  cbSize is not sizeof(OEMUI_PARAM).\r\n"));

        bValid = FALSE;
    }

    if(IsBadWritePtr(pOEMUIParam, pOEMUIParam->cbSize))
    {
        assert(0);
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pOEMUIParam is bad write ptr.\r\n"));

        bValid = FALSE;
    }

    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)
      )
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  invalid dwMode.\r\n"));

        bValid = FALSE;
    }

    if(IsValidOEMUIOBJ(pOEMUIParam->poemuiobj))
    {
        ExerciseOEMUIOBJ(pOEMUIParam->poemuiobj);
    }

    if(NULL == pOEMUIParam->hPrinter)
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMUIParam->pPrinterName)
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pPrinterName is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (NULL != pOEMUIParam->pPrinterName)
        &&
        IsBadReadPtr(pOEMUIParam->pPrinterName, wcslen(pOEMUIParam->pPrinterName))
      )
    {
        assert(0);
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pPrinterName is bad read ptr.\r\n"));

        bValid = FALSE;
    }

    if( (NULL != pOEMUIParam->pOEMOptItems)
        &&
        (NULL == pOEMUIParam->hOEMHeap)
      )
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  hOEMHeap is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (NULL == pOEMUIParam->pPublicDM)
        &&
        (OEMCUIP_PRNPROP != dwMode)
      )
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pPublicDM is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (NULL != pOEMUIParam->pPublicDM)
        &&
        (OEMCUIP_PRNPROP == dwMode)
      )
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pPublicDM is not NULL.\r\n"));

        bValid = FALSE;
    }

    if( (NULL != pOEMUIParam->pPublicDM)
        &&
        IsBadWritePtr(pOEMUIParam->pPublicDM, pOEMUIParam->pPublicDM->dmSize + 
                      pOEMUIParam->pPublicDM->dmDriverExtra)
      )
    {
        assert(0);
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pPublicDM is bad write ptr.\r\n"));

        bValid = FALSE;
    }

    if( (NULL != pOEMUIParam->pOEMDM)
        &&
        IsBadWritePtr(pOEMUIParam->pOEMDM, *(LPDWORD)pOEMUIParam->pOEMDM)
      )
    {
        assert(0);
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pOEMDM is bad write ptr.\r\n"));

        bValid = FALSE;
    }

    if( (NULL != pOEMUIParam->pDrvOptItems)
        &&
        IsBadWritePtr(pOEMUIParam->pDrvOptItems, sizeof(OPTITEM) * pOEMUIParam->cDrvOptItems)
      )
    {
        assert(0);
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pDrvOptItems is bad write ptr.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMUIParam->cOEMOptItems)
        &&
        (NULL == pOEMUIParam->pOEMOptItems)
      )
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pOEMOptItems is NULL when cOEMOptItems is not zero.\r\n"));

        bValid = FALSE;
    }

    if( (0 == pOEMUIParam->cOEMOptItems)
        &&
        (NULL != pOEMUIParam->pOEMOptItems)
      )
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pOEMOptItems is not NULL when cOEMOptItems is zero.\r\n"));

        bValid = FALSE;
    }

    if( (NULL != pOEMUIParam->pOEMOptItems)
        &&
        IsBadWritePtr(pOEMUIParam->pOEMOptItems, sizeof(OPTITEM) * pOEMUIParam->cOEMOptItems)
      )
    {
        assert(0);
        DebugMsg(ERRORTEXT("IsValidOEMUIParam():  pOEMOptItems is bad write ptr.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}


//////////////////////////////////////////////////////////////////////////
//  Function:    PropPageProc
//
//  Description:  Generic property page procedure.
//    
//
//    
//
//  Comments:
//     
//
//  History:
//        02/12/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL APIENTRY PropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code)  // type of notification message
            {
                case PSN_SETACTIVE:
                    break;
    
                case PSN_KILLACTIVE:
                    break;

                case PSN_APPLY:
                    break;

                case PSN_RESET:
                    break;
            }
            break;
    }

    return FALSE;
} 


//////////////////////////////////////////////////////////////////////////
//  Function:    DumpOEMUIParam
//
//  Description:  Debug dump of POEMCUIPPARAM structure.
//    
//
//  Parameters:    
//
//      pOEMUIParam     Pointer to an OEM param structure.
//
//
//  Returns:  N/A.
//    
//
//  Comments:
//     
//
//  History:
//        02/18/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

void DumpOEMUIParam(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    // Can't dump if pOEMUIParam NULL.
    if(NULL != pOEMUIParam)
    {
        DebugMsg(__TEXT("\r\n\tOEMUI_PARAM dump:\r\n\r\n"));

        DebugMsg(__TEXT("\tcbSize = %d.\r\n"), pOEMUIParam->cbSize);
        DebugMsg(__TEXT("\tfMode = %d.\r\n"), dwMode);
        DebugMsg(__TEXT("\thPrinter = %#lx.\r\n"), pOEMUIParam->hPrinter);
        if(NULL == pOEMUIParam->pPrinterName)
        {
            DebugMsgW(L"\tpPrinterName = NULL.\r\n");
        }
        else if(IsBadReadPtr(pOEMUIParam->pPrinterName, wcslen(pOEMUIParam->pPrinterName)))
        {
            assert(0);
            DebugMsgW(L"\tpPrinterName = %#lx (IsBadReadPtr).\r\n", pOEMUIParam->pPrinterName);
        }
        else
        {
            DebugMsgW(L"\tpPrinterName = \"%s\".\r\n", pOEMUIParam->pPrinterName);
        }
        DebugMsg(__TEXT("\thOEMHeap = %#lx.\r\n"), pOEMUIParam->hOEMHeap);
        DebugMsg(__TEXT("\tpPublicDM = %#lx.\r\n"), pOEMUIParam->pPublicDM);
        DebugMsg(__TEXT("\tpOEMDM = %#lx.\r\n"), pOEMUIParam->pOEMDM);
        DebugMsg(__TEXT("\tpDrvOptItems = %#lx.\r\n"), pOEMUIParam->pDrvOptItems);
        DebugMsg(__TEXT("\tcDrvOptItems = %d.\r\n"), pOEMUIParam->cDrvOptItems);
        DebugMsg(__TEXT("\tpOEMOptItems = %#lx.\r\n"), pOEMUIParam->pOEMOptItems);
        DebugMsg(__TEXT("\tcOEMOptItems = %d.\r\n"), pOEMUIParam->cOEMOptItems);
        DebugMsg(__TEXT("\tpOEMUserData = %#lx.\r\n"), pOEMUIParam->pOEMUserData);
        DebugMsg(__TEXT("\tOEMCUIPCallback = %#lx.\r\n"), pOEMUIParam->OEMCUIPCallback);
        DebugMsg(__TEXT("\tdwFlags = %#lx.\r\n"), pOEMUIParam->dwFlags);
    }
}


//////////////////////////////////////////////////////////////////////////
//  Function:    DumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//    
//
//  Parameters:    
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//    
//
//  Comments:
//     
//
//  History:
//        02/18/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

void DumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DebugMsg(__TEXT("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DebugMsg(__TEXT("\tcbSize = %d.\r\n"), pOEMDevModeParam->cbSize);
        DebugMsg(__TEXT("\thPrinter = %#lx.\r\n"), pOEMDevModeParam->hPrinter);
        DebugMsg(__TEXT("\thModule = %#lx.\r\n"), pOEMDevModeParam->hModule);
        DebugMsg(__TEXT("\tpPublicDMIn = %#lx.\r\n"), pOEMDevModeParam->pPublicDMIn);
        DebugMsg(__TEXT("\tpPublicDMOut = %#lx.\r\n"), pOEMDevModeParam->pPublicDMOut);
        DebugMsg(__TEXT("\tpOEMDMIn = %#lx.\r\n"), pOEMDevModeParam->pOEMDMIn);
        DebugMsg(__TEXT("\tpOEMDMOut = %#lx.\r\n"), pOEMDevModeParam->pOEMDMOut);
        DebugMsg(__TEXT("\tcbBufSize = %d.\r\n"), pOEMDevModeParam->cbBufSize);

        DumpDevMode(pOEMDevModeParam->pPublicDMIn);
    }
}


//////////////////////////////////////////////////////////////////////////
//  Function:    DumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//    
//
//  Parameters:    
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//    
//
//  Comments:
//     
//
//  History:
//        02/18/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

void DumpDevMode(PDEVMODE pDevMode)
{
    // Can't dump if pDevMode NULL.
    if(NULL != pDevMode)
    {
        DebugMsg(__TEXT("\r\n\tDEVMODE dump of %#x:\r\n\r\n"), pDevMode);

        DebugMsg(__TEXT("\tdmSpecVersion = %d.\r\n"), pDevMode->dmSpecVersion);
        DebugMsg(__TEXT("\tdmDriverVersion = %d.\r\n"), pDevMode->dmDriverVersion);
        DebugMsg(__TEXT("\tdmSize = %d.\r\n"), pDevMode->dmSize);
        DebugMsg(__TEXT("\tdmDriverExtra = %d.\r\n"), pDevMode->dmDriverExtra);
    }
}


//////////////////////////////////////////////////////////////////////////
//  Function:    IsValidOEMUIOBJ
//
//  Description:  Validates OEMUIOBJ structure.
//    
//
//  Parameters:    
//
//      poemuiobj     Pointer to an OEMUI object structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//    
//
//  Comments:
//     
//
//  History:
//        04/22/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL IsValidOEMUIOBJ(POEMUIOBJ poemuiobj)
{
    if(NULL == poemuiobj)
    {
        return FALSE;
    }

    if(sizeof(OEMUIOBJ) != poemuiobj->cbSize)
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIOBJ: cbSize is not sizeof(OEMUIOBJ)!\r\n"));

        return FALSE;
    }

    if(NULL == poemuiobj->pOemUIProcs)
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIOBJ: pOemUIProcs is NULL!\r\n"));

        return FALSE;
    }

    if(NULL == poemuiobj->pOemUIProcs->DrvGetDriverSetting)
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIOBJ: pOemUIProcs->DrvGetDriverSetting is NULL!\r\n"));

        return FALSE;
    }

    if(IsBadCodePtr((FARPROC) poemuiobj->pOemUIProcs->DrvGetDriverSetting))
    {
        DebugMsg(ERRORTEXT("IsValidOEMUIOBJ: pOemUIProcs->DrvGetDriverSetting is bad code ptr!\r\n"));

        return FALSE;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:    ExerciseOEMUIOBJ
//
//  Description:  Calls GetDriverSetting function for each predifined feature.
//    
//
//  Parameters:    
//
//      poemuiobj     Pointer to an OEMUI object structure.
//
//
//  Returns:  N/A.
//    
//
//  Comments:
//     
//
//  History:
//        04/22/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

void ExerciseOEMUIOBJ(POEMUIOBJ poemuiobj)
{
#if _KM_DRIVER

    DWORD                    dwNeeded;
    DWORD                    dwOptions;
    PCSTR                    pszFeature;
    PBYTE                    pOutput;
    PFN_DrvGetDriverSetting    DrvGetDriverSetting = poemuiobj->pOemUIProcs->DrvGetDriverSetting;


    for(DWORD dwCount = 0; dwCount < NUM_DRIVER_FEATURES; dwCount++)
    {
        switch(dwCount)
        {
            case 0:
                pszFeature = (PCSTR) OEMGDS_PSDM_FLAGS;
                break;

            case 1:
                pszFeature = (PCSTR) OEMGDS_PSDM_DIALECT;
                break;

            case 2:
                pszFeature = (PCSTR) OEMGDS_PSDM_TTDLFMT;
                break;

            case 3:
                pszFeature = (PCSTR) OEMGDS_PSDM_NUP;
                break;

            case 4:
                pszFeature = (PCSTR) OEMGDS_PSDM_PSLEVEL;
                break;

            case 5:
                pszFeature = (PCSTR) OEMGDS_MINOUTLINE;
                break;

            case 6:
                pszFeature = (PCSTR) OEMGDS_MAXBITMAP;
                break;

            case 7:
                pszFeature = (PCSTR) OEMGDS_PSDM_CUSTOMSIZE;
                break;

            case 8:
                pszFeature = (PCSTR) OEMGDS_PRINTFLAGS;
                break;

            case 9:
                pszFeature = (PCSTR) OEMGDS_FREEMEM;
                break;

            case 10:
                pszFeature = (PCSTR) OEMGDS_JOBTIMEOUT;
                break;

            case 11:
                pszFeature = (PCSTR) OEMGDS_WAITTIMEOUT;
                break;

            case 12:
                pszFeature = (PCSTR) OEMGDS_PROTOCOL;
                break;

            default:
                DebugMsg(ERRORTEXT("ExerciseOEMUIOBJ: beyond defined features!\r\n"));
                pszFeature = NULL;
                break;
        }

        // Call GetDriverSetting; will need to call twice.
        dwNeeded = 0;
        SetLastError(0);
        if(!DrvGetDriverSetting(poemuiobj, pszFeature, NULL, 0, &dwNeeded, &dwOptions))
        {
            DWORD dwLastError = GetLastError();
            if(ERROR_INSUFFICIENT_BUFFER == dwLastError)
            {
                if(0 != dwNeeded)
                {
                    pOutput = new BYTE[dwNeeded];

                    SetLastError(0);
                    if(!DrvGetDriverSetting(poemuiobj, pszFeature, pOutput, dwNeeded, &dwNeeded, &dwOptions))
                    {
                        dwLastError = GetLastError();
                        DebugMsg(DLLTEXT("ExerciseOEMUIOBJ: GetDriverSetting() feature %#x failed with LastError of %d!\r\n"), pszFeature, dwLastError);
                    }

                    delete pOutput;
                }
                else
                {
                    DebugMsg(ERRORTEXT("ExerciseOEMUIOBJ: dwNeeded is 0!\r\n"));
                }
            }
            else
            {
                DebugMsg(DLLTEXT("ExerciseOEMUIOBJ: GetDriverSetting() feature %#x query size failed with LastError of %d!\r\n"), pszFeature, dwLastError);
            }
        }
    }

#endif
}

//////////////////////////////////////////////////////////////////////////
//  Function:   MergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL MergeOEMExtraData(POEMUI_EXTRADATA pdmIn, POEMUI_EXTRADATA pdmOut)
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\km\intface.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    intface.c

Abstract:

    Implementation of kernel mode OEM rendering module
        OEMEnableDriver
        OEMDiableDriver
        OEMEnablePDEV
        OEMDisablePDEV
        OEMResetPDEV
        OEMGetInfo
        OEMCommand
        OEMGetResources

Environment:

    Windows NT printer driver

Revision History:

    09/09/96 -eigos-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "oem.h"

//
// OEM driver memory pool tag
//

DWORD gdwDrvMemPoolTag = 'Oem5';
DWORD gdwOEMSig        = 'OEKM';

//
// Our DRVFN table which tells the engine where to find the routines we support.
//

#ifdef DDI_HOOK
static DRVFN gaOEMDriverFuncs[] = {
    //
    // Optional DDI entries to hook
    //


    { INDEX_DrvRealizeBrush,        (PFN) OEMRealizeBrush        },
    { INDEX_DrvCopyBits,            (PFN) OEMCopyBits            },
    { INDEX_DrvBitBlt,              (PFN) OEMBitBlt              },
    { INDEX_DrvStretchBlt,          (PFN) OEMStretchBlt          },
    { INDEX_DrvStretchBltROP,       (PFN) OEMStretchBltROP       },
    { INDEX_DrvAlphaBlend,          (PFN) OEMAlphaBlend          },
    { INDEX_DrvTriangleMesh,        (PFN) OEMTriangleMesh        },
    { INDEX_DrvTextOut,             (PFN) OEMTextOut             },
    { INDEX_DrvFillPath,            (PFN) OEMFillPath            },
    { INDEX_DrvStrokePath,          (PFN) OEMStrokePath          },
    { INDEX_DrvStrokeAndFillPath,   (PFN) OEMStrokeAndFillPath   },
    { INDEX_DrvStartPage,           (PFN) OEMStartPage           },
    { INDEX_DrvStartDoc,            (PFN) OEMStartDoc            },
    { INDEX_DrvEscape,              (PFN) OEMEscape              },
    { INDEX_DrvEndDoc,              (PFN) OEMEndDoc              },
    { INDEX_DrvSendPage,            (PFN) OEMSendPage            },
    { INDEX_DrvQueryFont,           (PFN) OEMQueryFont           },
    { INDEX_DrvQueryFontTree,       (PFN) OEMQueryFontTree       },
    { INDEX_DrvQueryFontData,       (PFN) OEMQueryFontData       },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) OEMQueryAdvanceWidths  },
    { INDEX_DrvFontManagement,      (PFN) OEMFontManagement      },
    { INDEX_DrvGetGlyphMode,        (PFN) OEMGetGlyphMode        },
    { INDEX_DrvIcmCreateTransformW, (PFN) OEMIcmCreateTransformW },
    { INDEX_DrvIcmDeleteTransform,  (PFN) OEMIcmDeleteTransform  }

};
#endif



BOOL
OEMEnableDriver(
    DWORD          EngineVersion,
    DWORD          cbSize,
    PDRVENABLEDATA pDrvEnableData
    )

/*++

Routine Description:


Arguments:


Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    VERBOSE(("Entering OEMEnableDriver...\n"));
    ASSERT((pDrvEnableData != NULL));

    //
    // Debug initialize
    //

    MemDebugInit();

    if (EngineVersion < DDI_DRIVER_VERSION_NT4 || cbSize < sizeof(DRVENABLEDATA))
    {
        ERR(( "Invalid parameters.\n"));
        return FALSE;
    }

    //
    // Fill in the OEMENABLEDATA structure for the engine.
    //

    pDrvEnableData->iDriverVersion = OEM_DRIVER_VERSION;
    pDrvEnableData->c              = sizeof(gaOEMDriverFuncs) / sizeof(DRVFN);

    #if DDI_HOOK
    pDrvEnableData->pdrvfn         = gaOEMDriverFuncs;
    #else
    pDrvEnableData->pdrvfn         = NULL;
    #endif

    VERBOSE(("Leaving OEMEnableDriver...\n"));
    return TRUE;
}


PDEVOEM
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)

/*++

Routine Description:


Arguments:


Return Value:

    Driver device handle, NULL if there is an error

--*/

{
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMEnablePDEV...\n"));

    //
    // Allocate the OEMDev
    //

    pOEMPDev = MemAlloc(sizeof(OEMPDEV));

    //
    // Fill in OEMDEV
    //

    VCreateDDIEntryPointsTable(pOEMPDev, pded);

    VERBOSE(("Leaving OEMEnablePDEV...\n"));

    return (POEMPDEV) pOEMPDev;
}



BOOL
OEMResetPDEV(
    PDEVOBJ  pdevOld,
    PDEVOBJ  pdevNew
    )

/*++

Routine Description:

    Implementation of DDI entry point OEMResetPDEV.

Arguments:


Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{

    VERBOSE(("Entering OEMResetPDEV...\n"));


    if (!pdevOld || !pdevNew) {

        RIP(("Invalid PDEV\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    VERBOSE(("Leaving OEMResetPDEV...\n"));

    return TRUE;

}




VOID
OEMDisablePDEV(
    PDEVOBJ pDevObj
    )

/*++

Routine Description:

    Implementation of DDI entry point OEMDisablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

Return Value:

    NONE

--*/

{
    POEMPDEV pOEMPDev = (POEMPDEV) pDevObj->pdevOEM;
    PFN     MemFree;

    VERBOSE(("Entering OEMDisablePDEV...\n"));
    ASSERT(!pOEMPDev);

    //
    // Free up all memory allocated for the PDEV
    //

    MemFree(pOEMPDev);

}



VOID
OEMDisableDriver(
    VOID
    )

/*++

Routine Description:

    Implementation of DDI entry point OEMDisableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    VERBOSE(("Entering gOEMDisablePDEV...\n"));

    //
    // Debug cleanup
    //

    MemDebugCleanup();
}


BOOL
OEMDevMode(
    POEM_DEVMODEPARAM pOEMDevModeParam)
/*++

Routine Description:


Arguments:


Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    POEMDEVMODE pOEMDevMode;
    BOOL         bRet;

    VERBOSE(("Entering OEMDevMode...\n"));
    ASSERT(pOEMDevModeParam != NULL);

    bRet = FALSE;

    switch (pOEMDevModeParam->fMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMDEVMODE);
        bRet = TRUE;
        break;

    case OEMDM_DEFAULT:
        pOEMDevModeParam->cbBufSize = sizeof(OEMDEVMODE);
        bRet = TRUE;
        break;

    case OEMDM_CONVERT:
        pOEMDevModeParam->cbBufSize = sizeof(OEMDEVMODE);
        bRet = TRUE;
        break;

    case OEMDM_VALIDATE:
        break;
    }


    return FALSE;
}

BOOL
OEMGetInfo(
    DWORD  dwInfo,
    PVOID  pvBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
/*++

Routine Description:


Arguments:


Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    BOOL  bRet;
    DWORD dwSigSize;

    VERBOSE(("Entering OEMGetInfo...\n"));

    switch (dwInfo)
    {
    case OEM_GETSIGNATURE:

        if (cbSize != sizeof(DWORD))
        {
            *pcbNeeded = sizeof(DWORD);
            bRet = FALSE;
        }
        else
        {
            *(PDWORD)pvBuffer = gdwOEMSig;
            *pcbNeeded = sizeof(DWORD);
            bRet = TRUE;
        }

        break;
    case OEM_GETINTERFACEVERSION:

        if (cbSize != sizeof(DWORD))
        {
            *pcbNeeded = sizeof(DWORD);
            bRet = FALSE;
        }
        else
        {
            *(PDWORD)pvBuffer = PRINTER_OEMINTF_VERSION;
            *pcbNeeded = sizeof(DWORD);
            bRet = TRUE;
        }

        break;

    default:
        bRet = FALSE;

    }

    return bRet;
}

#ifdef PSCRIPT
DWORD
OEMCommand(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pData,
    DWORD   cbSize)
/*++

Routine Description:

    The PSCRIPT driver calls this OEM function at specific points during output
    generation. This gives the OEM DLL an opportunity to insert code fragments
    at specific injection points in the driver's code. It should use
    DrvWriteSpoolBuf for generating any output it requires.


Arguments:

    pdevobj -
    dwIndex
    pData
    dwSize


Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PBYTE  pProcedure;

    switch (dwIndex)
    {
    case PSINJECT_BEGINSTREAM:
        VERBOSE(("OEMCommand PSINJECT_BEGINSTREAM\n"));
        pProcedure = gcstrTest_BEGINSTREAM;
        break;

    case PSINJECT_PSADOBE:
        VERBOSE(("OEMCommand PSINJECT_PSADOBE\n"));
        pProcedure = gcstrTest_PSADOBE;
        break;

    case PSINJECT_COMMENTS:
        VERBOSE(("OEMCommand PSINJECT_COMMENTS\n"));
        pProcedure = gcstrTest_COMMENTS;
        break;

    case PSINJECT_DEFAULTS:
        VERBOSE(("OEMCommand PSINJECT_DEFAULTS\n"));
        pProcedure = gcstrTest_DEFAULTS;
        break;

    case PSINJECT_BEGINPROLOG:
        VERBOSE(("OEMCommand PSINJECT_BEGINPROLOG\n"));
        pProcedure = gcstrTest_BEGINPROLOG;
        break;

    case PSINJECT_ENDPROLOG:
        VERBOSE(("OEMCommand PSINJECT_ENDPROLOG\n"));
        pProcedure = gcstrTest_ENDPROLOG;
        break;

    case PSINJECT_BEGINSETUP:
        VERBOSE(("OEMCommand PSINJECT_BEGINSETUP\n"));
        pProcedure = gcstrTest_BEGINSETUP;
        break;

    case PSINJECT_ENDSETUP:
        VERBOSE(("OEMCommand PSINJECT_ENDSETUP\n"));
        pProcedure = gcstrTest_ENDSETUP;
        break;

    case PSINJECT_BEGINPAGESETUP:
        VERBOSE(("OEMCommand PSINJECT_BEGINPAGESETUP\n"));
        pProcedure = gcstrTest_BEGINPAGESETUP;
        break;

    case PSINJECT_ENDPAGESETUP:
        VERBOSE(("OEMCommand PSINJECT_ENDPAGESETUP\n"));
        pProcedure = gcstrTest_ENDPAGESETUP;
        break;

    case PSINJECT_PAGETRAILER:
        VERBOSE(("OEMCommand PSINJECT_PAGETRAILER\n"));
        pProcedure = gcstrTest_PAGETRAILER;
        break;

    case PSINJECT_TRAILER:
        VERBOSE(("OEMCommand PSINJECT_TRAILER\n"));
        pProcedure = gcstrTest_TRAILER;
        break;

    case PSINJECT_PAGES:
        VERBOSE(("OEMCommand PSINJECT_PAGES\n"));
        pProcedure = gcstrTest_PAGES;
        break;

    case PSINJECT_PAGENUMBER:
        VERBOSE(("OEMCommand PSINJECT_PAGENUMBER\n"));
        pProcedure = gcstrTest_PAGENUMBER;
        break;

    case PSINJECT_PAGEORDER:
        VERBOSE(("OEMCommand PSINJECT_PAGEORDER\n"));
        pProcedure = gcstrTest_PAGEORDER;
        break;

    case PSINJECT_ORIENTATION:
        VERBOSE(("OEMCommand PSINJECT_ORIENTATION\n"));
        pProcedure = gcstrTest_ORIENTATION;
        break;

    case PSINJECT_BOUNDINGBOX:
        VERBOSE(("OEMCommand PSINJECT_BOUNDINGBOX\n"));
        pProcedure = gcstrTest_BOUNDINGBOX;
        break;

    case PSINJECT_DOCNEEDEDRES:
        VERBOSE(("OEMCommand PSINJECT_DOCNEEDEDRES\n"));
        pProcedure = gcstrTest_DOCNEEDEDRES;
        break;

    case PSINJECT_DOCSUPPLIEDRES:
        VERBOSE(("OEMCommand PSINJECT_DOCSUPPLIEDRES\n"));
        pProcedure = gcstrTest_DOCSUPPLIEDRES;
        break;

    case PSINJECT_EOF:
        VERBOSE(("OEMCommand PSINJECT_EOF\n"));
        pProcedure = gcstrTest_EOF;
        break;

    case PSINJECT_ENDSTREAM:
        VERBOSE(("OEMCommand PSINJECT_ENDSTREAM\n"));
        pProcedure = gcstrTest_ENDSTREAM;
        break;

    case PSINJECT_VMSAVE:
        VERBOSE(("OEMCommand PSINJECT_VMSAVE\n"));
        pProcedure = gcstrTest_VMSAVE;
        break;

    case PSINJECT_VMRESTORE:
        VERBOSE(("OEMCommand PSINJECT_VMRESTORE\n"));
        pProcedure = gcstrTest_VMRESTORE;
        break;

    default:
        VERBOSE(("Entering OEMCommand...\n"));

    }

    return
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj->hPrinter,
                                         pProcedure,
                                         strlen(pProcedure));

}

#elif UNIDRV
PBYTE OEMImageProcessing(
    PDEVOBJ     pdevobj,
    PBYTE       pSrcBitmap,
    PBITMAPINFO pBitmapInfo,
    POINT       ptOffset,
    WORD        wHalftone,
    PBYTE       pColorTable,
    DWORD       dwCallbackID,
    PPOINT      pptCursor,
    WORD        wMode)
{

    VERBOSE(("Entering OEMImageProcessing...\n"));

    return 0;
}

BOOL OEMFilterGraphics (
    PDEVOBJ pdevobj,         // OEM PDEVICE
    PSTR    pBuf,            // Pointer to buffer to holding data
    DWORD   dwLen)           // Size in bytes of data pointed to pBuf.
{
    VERBOSE(("Entering OEMFilterGraphics...\n"));

    return 0;
}

VOID OEMCommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       wCmdCbID,
    PEXTRAPARAM pdwParams)
{
    UNREFERENCED_PARAMETER(pdevobj);
    UNREFERENCED_PARAMETER(wCmdCbID);
    UNREFERENCED_PARAMETER(pdwParams);

    VERBOSE(("Entering OEMCommandCallback...\n"));
}

DWORD OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    FONTOBJ    *pFontObj,
    DWORD       dwType,
    DWORD       dwFontID)
{
    UNREFERENCED_PARAMETER(pdevobj);
    UNREFERENCED_PARAMETER(pFontObj);
    UNREFERENCED_PARAMETER(dwType);
    UNREFERENCED_PARAMETER(dwFontID);

    VERBOSE(("Entering OEMDownloadFontHeader...\n"));

    return 0;
}

DWORD OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    FONTOBJ    *pFontObj,
    DWORD       dwFontID,
    DWORD       dwGlyphID,
    DWORD       dwType,
    DWORD       dwCharWidth)
{
    UNREFERENCED_PARAMETER(pdevobj);
    UNREFERENCED_PARAMETER(pFontObj);
    UNREFERENCED_PARAMETER(dwFontID);
    UNREFERENCED_PARAMETER(dwGlyphID);
    UNREFERENCED_PARAMETER(dwType);
    UNREFERENCED_PARAMETER(dwCharWidth);

    VERBOSE(("Entering OEMDownloadCharGlyph...\n"));

    return 0;
}

DWORD OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    FONTOBJ    *pFontObj,
    DWORD       dwRemainedMemory)
{
    UNREFERENCED_PARAMETER(pdevobj);
    UNREFERENCED_PARAMETER(pFontObj);
    UNREFERENCED_PARAMETER(dwRemainedMemory);

    VERBOSE(("Entering OEMTTDownloadMethod...\n"));

    return 0;
}

VOID OEMOutputChar(
    PDEVOBJ       pdevobj,
    FONTOBJ      *pFontObj,
    PSHORT       *pWidthTbl,
    DWORD         dwFontID)
{
    UNREFERENCED_PARAMETER(pdevobj);
    UNREFERENCED_PARAMETER(pFontObj);
    UNREFERENCED_PARAMETER(pWidthTbl);
    UNREFERENCED_PARAMETER(dwFontID);

    VERBOSE(("Entering OEMOutputChar...\n"));
}

VOID OEMSendFontCmd(
    PDEVOBJ       pdevobj,
    FNTCMD       *pFontCmd,
    FONTOBJ      *pFontObj)
{
    UNREFERENCED_PARAMETER(pdevobj);
    UNREFERENCED_PARAMETER(pFontCmd);
    UNREFERENCED_PARAMETER(pFontObj);

    VERBOSE(("Entering OEMSendFontCmd...\n"));
}

#endif

#ifdef DDI_HOOK

BOOL
OEMBitBlt(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMask,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    POINTL   *pptlSrc,
    POINTL   *pptlMask,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4      rop4)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;
    VERBOSE(("Entering OEMBitBlt...\n"));

    pDevObj  = (PDEVOBJ) psoDst->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvBitBlt])
    {
        return ((PFN_OEMBitBlt)pOEMPDev->pfnFunc[INDEX_DrvBitBlt])(psoDst,
       psoSrc,
       psoMask,
       pco,
       pxlo,
       prclDst,
       pptlSrc,
       pptlMask,
       pbo,
       pptlBrush,
       rop4);
    }
    else
    {
        return FALSE;
    }
}

BOOL
OEMCopyBits(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    POINTL   *pptlSrc)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    UNREFERENCED_PARAMETER(psoDst);
    UNREFERENCED_PARAMETER(psoSrc);
    UNREFERENCED_PARAMETER(pco);
    UNREFERENCED_PARAMETER(pxlo);
    UNREFERENCED_PARAMETER(prclDst);
    UNREFERENCED_PARAMETER(pptlSrc);

    VERBOSE(("Entering OEMCopyBits...\n"));

    pDevObj  = (PDEVOBJ) psoDst->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvCopyBits])
    {
        return ((PFN_OEMCopyBits) pOEMPDev->pfnFunc[INDEX_DrvCopyBits])(psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            pptlSrc);
    }
    else
    {
        return FALSE;
    }
}

BOOL
OEMStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMStrethcBltROP...\n"));

    pDevObj  = (PDEVOBJ) psoDst->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvStretchBltROP])
    {
        return ((PFN_OEMStretchBltROP)pOEMPDev->pfnFunc[INDEX_DrvStretchBltROP])
                  (psoDst,
                   psoSrc,
                   psoMask,
                   pco,
                   pxlo,
                   pca,
                   pptlHTOrg,
                   prclDest,
                   prclSrc,
                   pptlMask,
                   iMode,
                   pbo,
                   rop4);
    }
    else
    {
        return FALSE;
    }
}
BOOL
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMStretchBlt...\n"));

    pDevObj  = (PDEVOBJ) psoDest->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvStretchBlt])
    {
        return ((PFN_OEMStretchBlt)pOEMPDev->pfnFunc[INDEX_DrvStretchBlt])(
                   psoDest,
                   psoSrc,
                   psoMask,
                   pco,
                   pxlo,
                   pca,
                   pptlHTOrg,
                   prclDest,
                   prclSrc,
                   pptlMask,
                   iMode);
    }
    else
    {
        return FALSE;
    }
}

BOOL
APIENTRY
OEMAlphaBlend(
    SURFOBJ       *psoDest,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    BLENDFUNCTION  BlendFunction)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMAlphaBlend...\n"));

    pDevObj  = (PDEVOBJ) psoDest->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvAlphaBlend])
    {
        return ((PFN_OEMAlphaBlend)pOEMPDev->pfnFunc[INDEX_DrvAlphaBlend])(
                psoDest,
                psoSrc,
                pco,
                pxlo,
                prclDest,
                prclSrc,
                BlendFunction);
    }
    else
    {
        return FALSE;
    }

}

BOOL
APIENTRY
OEMTriangleMesh(
    SURFOBJ         *psoDest,
    CLIPOBJ         *pco,
    TRIVERTEX       *pVertex,
    ULONG            nVertex,
    USHORT          *pusMesh,
    ULONG            nMesh,
    ULONG            ulMode)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMTriangleMesh...\n"));

    pDevObj  = (PDEVOBJ) psoDest->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvTriangleMesh])
    {
        return ((PFN_OEMTriangleMesh)pOEMPDev->pfnFunc[INDEX_DrvTriangleMesh])(
                psoDest,
                pco,
                pVertex,
                nVertex,
                pusMesh,
                nMesh,
                ulMode);
    }
    else
    {
        return FALSE;
    }
}

BOOL
OEMTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX      mix)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMTextOut...\n"));

    pDevObj  = (PDEVOBJ) pso->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvTextOut])
    {
        return ((PFN_OEMTextOut)pOEMPDev->pfnFunc[INDEX_DrvTextOut])(pso,
               pstro,
               pfo,
               pco,
               prclExtra,
               prclOpaque,
               pboFore,
               pboOpaque,
               pptlOrg,
               mix);
    }
    else
    {
        return FALSE;
    }
}

BOOL
OEMFillPath(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg,
    MIX      mix,
    FLONG    flOptions)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMFillPath...\n"));

    pDevObj  = (PDEVOBJ) pso->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvFillPath])
    {
        return ((PFN_OEMFillPath)pOEMPDev->pfnFunc[INDEX_DrvFillPath])(
                   pso,
                   ppo,
                   pco,
                   pbo,
                   pptlBrushOrg,
                   mix,
                   flOptions);
    }
    else
    {
        return FALSE;
    }
}

BOOL
OEMStrokePath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX        mix)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMStrokePath...\n"));

    pDevObj  = (PDEVOBJ) pso->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvStrokePath])
    {
        return ((PFN_OEMStrokePath)pOEMPDev->pfnFunc[INDEX_DrvStrokePath])(
                   pso,
                   ppo,
                   pco,
                   pxo,
                   pbo,
                   pptlBrushOrg,
                   plineattrs,
                   mix);
    }
    else
    {
        return FALSE;
    }
}


BOOL
OEMStrokeAndFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX       mixFill,
    FLONG     flOptions)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMStrokeAndFillPath...\n"));

    pDevObj  = (PDEVOBJ) pso->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvStrokeAndFillPath])
    {
        return ((PFN_OEMStrokeAndFillPath)
                pOEMPDev->pfnFunc[INDEX_DrvStrokeAndFillPath])(
                    pso,
                    ppo,
                    pco,
                    pxo,
                    pboStroke,
                    plineattrs,
                    pboFill,
                    pptlBrushOrg,
                    mixFill,
                    flOptions);
    }
    else
    {
        return FALSE;
    }
}

BOOL
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMRealizeBrush...\n"));

    pDevObj  = (PDEVOBJ) psoTarget->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvRealizeBrush])
    {
        return ((PFN_OEMRealizeBrush)pOEMPDev->pfnFunc[INDEX_DrvRealizeBrush])(
                   pbo,
                   psoTarget,
                   psoPattern,
                   psoMask,
                   pxlo,
                   iHatch);
    }
    else
    {
        return FALSE;
    }
}

BOOL
OEMStartPage(
    SURFOBJ *pso)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMStartPage...\n"));

    pDevObj  = (PDEVOBJ) pso->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvRealizeBrush])
    {
        return ((PFN_OEMStartPage)pOEMPDev->pfnFunc[INDEX_DrvStartPage])(pso);
    }
    else
    {
        return FALSE;
    }
}

BOOL
OEMStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMStartDoc...\n"));

    pDevObj  = (PDEVOBJ) pso->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvStartDoc])
    {
        return ((PFN_OEMStartDoc)pOEMPDev->pfnFunc[INDEX_DrvStartDoc])(
                   pso,
                   pDocName,
                   jobId);
    }
    else
    {
        return FALSE;
    }
}

ULONG
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID      *pvIn,
    ULONG       cjOut,
    PVOID      *pvOut)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMEscape...\n"));

    pDevObj  = (PDEVOBJ) pso->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvEscape])
    {
        return ((PFN_OEMEscape)pOEMPDev->pfnFunc[INDEX_DrvEscape])(pso,
                     iEsc,
                     cjIn,
                     pvIn,
                     cjOut,
                     pvOut);
    }
    else
    {
        return 0;
    }
}

BOOL
OEMEndDoc(
    SURFOBJ *pso,
    FLONG   flags)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMEndDoc...\n"));

    pDevObj  = (PDEVOBJ) pso->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvEndDoc])
    {
        return ((PFN_OEMEndDoc)pOEMPDev->pfnFunc[INDEX_DrvEndDoc])(pso, flags);
    }
    else
    {
        return FALSE;
    }
}

BOOL
OEMSendPage(
    SURFOBJ *pso)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMSendPage...\n"));

    pDevObj  = (PDEVOBJ) pso->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvSendPage])
    {
        return ((PFN_OEMSendPage)pOEMPDev->pfnFunc[INDEX_DrvSendPage])(pso);
    }
    else
    {
        return FALSE;
    }
}

ULONG
OEMGetGlyphMode(
    DHPDEV   dhpdev,
    FONTOBJ *pfo)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMGetGlyphMode...\n"));

    pDevObj  = (PDEVOBJ) dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvGetGlyphMode])
    {
        return ((PFN_OEMGetGlyphMode)pOEMPDev->pfnFunc[INDEX_DrvGetGlyphMode])(
                   dhpdev,
                   pfo);
    }
    else
    {
        return 0;
    }
}

ULONG
OEMFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG    iMode,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMFontManagement...\n"));

    pDevObj  = (PDEVOBJ) pso->dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvFontManagement])
    {
        return ((PFN_OEMFontManagement)
               pOEMPDev->pfnFunc[INDEX_DrvFontManagement])(pso,
                                                          pfo,
                                                          iMode,
                                                          cjIn,
                                                          pvIn,
                                                          cjOut,
                                                          pvOut);
    }
    else
    {
        return 0;
    }
}

PIFIMETRICS
OEMQueryFont(
    DHPDEV dhpdev,
    ULONG  iFile,
    ULONG  iFace,
    ULONG_PTR *pid)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMQueryFont...\n"));

    pDevObj  = (PDEVOBJ) dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvQueryFont])
    {
        return ((PFN_OEMQueryFont)pOEMPDev->pfnFunc[INDEX_DrvQueryFont])(dhpdev,
           iFile,
           iFace,
           pid);
    }
    else
    {
        return NULL;
    }
}

PVOID
OEMQueryFontTree(
    DHPDEV dhpdev,
    ULONG  iFile,
    ULONG  iFace,
    ULONG  iMode,
    ULONG_PTR  *pid)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMQueryFontTree...\n"));

    pDevObj  = (PDEVOBJ) dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvQueryFontTree])
    {
        return ((PFN_OEMQueryFontTree)pOEMPDev->pfnFunc[INDEX_DrvQueryFontTree])
                (dhpdev,
                 iFile,
                 iFace,
                 iMode,
                 pid);
    }
    else
    {
        return NULL;
    }
}

LONG
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMQueryFontData...\n"));

    pDevObj  = (PDEVOBJ) dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvQueryFontData])
    {
        return ((PFN_OEMQueryFontData)pOEMPDev->pfnFunc[INDEX_DrvQueryFontData])
                  (dhpdev,
                   pfo,
                   iMode,
                   hg,
                   pgd,
                   pv,
                   cjSize);
    }
    else
    {
        return 0;
    }
}

BOOL
OEMQueryAdvanceWidths(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    PVOID    pvWidths,
    ULONG    cGlyphs)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMQueryAdvanceWidths...\n"));

    pDevObj  = (PDEVOBJ) dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvQueryAdvanceWidths])
    {
        return ((PFN_OEMQueryAdvanceWidths)
               pOEMPDev->pfnFunc[INDEX_DrvQueryAdvanceWidths])(
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs);
    }
    else
    {
        return FALSE;
    }
}

HANDLE
OEMIcmCreateTransformW(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    PVOID            pvDestProfile,
    PVOID            pvTargetProfile,
    DWORD            dwReserved)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMIcmCreateTransformW...\n"));

    pDevObj  = (PDEVOBJ) dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvIcmCreateTransformW])
    {
        return ((PFN_OEMIcmCreateTransformW)
               pOEMPDev->pfnFunc[INDEX_DrvIcmCreateTransformW])(
                   dhpdev,
                   pLogColorSpace,
                   pvSourceProfile,
                   pvDestProfile,
                   pvTargetProfile,
                   dwReserved);
    }
    else
    {
        return NULL;
    }
}

BOOL
OEMIcmDeleteTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform)
{
    PDEVOBJ  pDevObj;
    POEMPDEV pOEMPDev;

    VERBOSE(("Entering OEMIcmDeleteTransfrom...\n"));

    pDevObj  = (PDEVOBJ) dhpdev;
    pOEMPDev =  pDevObj->pdevOEM;

    if (pOEMPDev->pfnFunc[INDEX_DrvIcmDeleteTransform])
    {
        return ((PFN_OEMIcmDeleteTransform)
               pOEMPDev->pfnFunc[INDEX_DrvIcmDeleteTransform])(dhpdev,
                                                              hcmXform);
    }
    else
    {
        return FALSE;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\um\export.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    export.c

Abstract:

    This file handles the OEM extension functions.

Environment:

    Win32 subsystem, OEM UI module, user mode

Revision History:

    09/13/96 -eigos-
        Created it.

    dd-mm-yy -author-
        description

--*/

#include "oem.h"

//
// Globals
//

#ifdef DBG
INT giDebugLevel;
#endif

DWORD gdwOEMSig = 0x4955454f; //"OEUI"

//
// Prototype definition
//

LONG PSUICallback( PCPSUICBPARAM );

BOOL
OEMGetInfo(
    DWORD  dwInfo,
    PVOID  pvBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{

    BOOL  bRet;
    DWORD dwSigSize;

    VERBOSE(("Entering OEMGetInfo...\n"));

    switch (dwInfo) 
    {
    case OEM_GETSIGNATURE:

        if (cbSize != sizeof(DWORD))
        {
            *pcbNeeded = sizeof(DWORD);
            bRet = FALSE;
        }
        else
        {
            *(PDWORD)pvBuffer = gdwOEMSig;
            *pcbNeeded = sizeof(DWORD);
            bRet = TRUE;
        }

        break;
    case OEM_GETINTERFACEVERSION:

        if (cbSize != sizeof(DWORD))
        {
            *pcbNeeded = sizeof(DWORD);
            bRet = FALSE;
        }
        else
        {
            *(PDWORD)pvBuffer = PRINTER_OEMINTF_VERSION;
            *pcbNeeded = sizeof(DWORD);
            bRet = TRUE;
        }

        break;

    default:
        bRet = FALSE;

    }

    return bRet;
}


BOOL
OEMDevMode(
    POEM_DEVMODEPARAM pOEMDevModeParam)
{

    POEMDEVMODE pOEMDevMode;
    INT         iI;
    BOOL        bRet;

    VERBOSE(("Entering OEMDevMode...\n"));
    ASSERT(pOEMDevModeParam != NULL);

    bRet = FALSE;

    switch (pOEMDevModeParam->fMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMDEVMODE);
        bRet = TRUE;
        break;

    case OEMDM_DEFAULT:
        pOEMDevModeParam->cbBufSize = sizeof(OEMDEVMODE);
        pOEMDevMode                 = pOEMDevModeParam->pOEMDMOut;

        pOEMDevMode->DMExtraHdr.dwSize      = sizeof(OEMDEVMODE);
        pOEMDevMode->DMExtraHdr.dwSignature = gdwOEMSig;
        pOEMDevMode->DMExtraHdr.dwVersion   = OEM_DEVMODE_VERSION_1_0;

        #ifdef PSCRIPT
        for (iI = 0; iI < NUM_OF_PS_INJECTION; iI ++)
        {
            pOEMDevMode->InjectCmd[iI].dwbSize   = 0;
            pOEMDevMode->InjectCmd[iI].loOffset = 0;
        }
        #endif

        bRet = TRUE;
        break;

    case OEMDM_CONVERT:
        pOEMDevModeParam->cbBufSize = sizeof(OEMDEVMODE);
        bRet = TRUE;
        break;

    case OEMDM_VALIDATE:
        pOEMDevMode = pOEMDevModeParam->pOEMDMOut;
        if (pOEMDevMode->DMExtraHdr.dwSize != sizeof(OEMDEVMODE)        ||
            pOEMDevMode->DMExtraHdr.dwSignature != gdwOEMSig            ||
            pOEMDevMode->DMExtraHdr.dwVersion != OEM_DEVMODE_VERSION_1_0 )
        {
            break;
        }
        bRet = TRUE;
        break;
    }

    return bRet;
}


BOOL
OEMCommonUI(
    DWORD dwReason,
    PVOID pParam
)
{
    POEM_PROPERTYHEADER pOEMPropertyHeader;
    BOOL                bReturn;

    VERBOSE(("Entering OEMCommonUI...\n"));

    switch (dwReason)
    {
    case OEMUI_PROPERTIES:

        pOEMPropertyHeader = (POEM_PROPERTYHEADER)pParam;

        switch(pOEMPropertyHeader->fMode)
        {
        case OEMUI_PRNPROP:
            break;

        case OEMUI_DOCPROP:
            break;
        }

        bReturn = TRUE;
        break;

    default:
        bReturn = FALSE;
        break;
    }

    return bReturn;
}

#ifdef DDI_HOOK
LONG
OEMDocumentPropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam)
{
    VERBOSE(("Entering OEMDocumentPropertySheets...\n"));

    return 0;
}

LONG APIENTRY
OEMDevicePropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam)
{
    VERBOSE(("Entering OEMDevQueryPrintEx...\n"));

    return 0;
}

BOOL
OEMDevQueryPrintEx(
    PDEVQUERYPRINT_INFO  pDQPInfo,
    PDEVMODE             pPublicDM,
    PVOID                pOEMDM)
{
    VERBOSE(("Entering OEMDevQueryPrintEx...\n"));

    return TRUE;
}


DWORD
OEMDeviceCapabilities(
    HANDLE   hPrinter,
    PWSTR    pDeviceName,
    WORD     wCapability,
    VOID    *pvOutput,
    PDEVMODE pPublicDM,
    PVOID    pOEMDM,
    DWORD    dwResult)
{
    VERBOSE(("Entering OEMDeviceCapabilities...\n"));

    return dwResult;
}


BOOL
OEMUpgradePrinter(
    DWORD  Level,
    PBYTE  pDriverUpgradeInfo)
{
    VERBOSE(("Entering OEMUpgradePrinter...\n"));

    return TRUE;
}

BOOL
OEMPrinterEvent(
    PWSTR  pPrinterName,
    INT    iDriverEvent,
    DWORD  dwFlags,
    LPARAM lParam)
{
    VERBOSE(("Entering OEMPrinterEvent...\n"));

    return TRUE;
}

#endif

CPSUICALLBACK
cpcbPrinterPropertyCallback(
    IN PCPSUICBPARAM pComPropSheetUICBParam)
/*++

Routine Description:

    Callback function provided to common UI DLL for handling
    printer properties dialog.

Arguments:

    pCallbackParam - Pointer to CPSUICBPARAM structure

Return Value:

    CPSUICB_ACTION_NONE - no action needed
    CPSUICB_ACTION_OPTIF_CHANGED - items changed and should be refreshed


--*/

{
    POPTITEM pOptItem;

    pOptItem = pComPropSheetUICBParam->pOptItem;

    switch (pComPropSheetUICBParam->Reason)
    {
    case CPSUICB_REASON_SEL_CHANGED:
        break;

    case CPSUICB_REASON_ECB_CHANGED:
        break;

    case CPSUICB_REASON_ITEMS_REVERTED:
        break;

    case CPSUICB_REASON_APPLYNOW:
        break;
    }

    return CPSUICB_ACTION_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\inc\tty.h ===
// Some General Includes

#include <stddef.h>
#include <stdlib.h>

#ifdef OEMCOM
#include <objbase.h>
#endif

#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include <tchar.h>
#include <excpt.h>


// Macros for Memory Allocation

#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\um\initdll.c ===
Copyright (c) 1996  Microsoft Corporation

Module Name:

    initdll.c

Abstract:


Environment:

    Windows NT OEM UI DLL

Revision History:

    09/09/96 -eigos-
        Initiali framework.

--*/

#include "oem.h"

//
// Globals
//

HINSTANCE ghInstance;


BOOL 
DllMain(
    HANDLE   hModule,
    DWORD    dwReason,
    PCONTEXT pContext)
/*++

Routine Description:

    This function is called when the system loads/unloads the DriverUI module.
    At DLL_PROCESS_ATTACH, InitializeCriticalSection is called to initialize
    the critical section objects.
    At DLL_PROCESS_DETACH, DeleteCriticalSection is called to release the
    critical section objects.

Arguments:

    hModule     handle to DLL module
    dwReason    reason for the call
    pContext    pointer to context (not used by us)


Return Value:

    TRUE if DLL is initialized successfully.
    FALSE otherwise.

Note:

--*/

{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;

        #if !DBG

        //
        // Keep our driver UI dll always loaded in memory
        //

        if (GetModuleFileName(hModule, wchDllName, MAX_PATH))
            LoadLibrary(wchDllName);

        #endif

        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\render\kmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       KMode.h
//
//
//  PURPOSE:    Definitions and routines for compiling kernel mode instead of user mode.
//
//  PLATFORMS:
//    Windows NT
//
//

#ifndef _KMODE_H
#define _KMODE_H


// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif



#ifdef USERMODE_DRIVER

//
// User mode difinitions to get rid of defines for kernel mode.
//

// Don't need critical section in user mode.

#define DECLARE_CRITICAL_SECTION    ;
#define INIT_CRITICAL_SECTION()     NOP_FUNCTION
#define DELETE_CRITICAL_SECTION()   NOP_FUNCTION
#define IS_VALID_CRITICAL_SECTION() (TRUE)


#else // !USERMODE_DRIVER


////////////////////////////////////////////////////////
//      Kernel Mode Defines
////////////////////////////////////////////////////////

extern HSEMAPHORE ghOEMSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghOEMSemaphore = NULL;
#define INIT_CRITICAL_SECTION()     ghOEMSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghOEMSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghOEMSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghOEMSemaphore)
#define IS_VALID_CRITICAL_SECTION() (NULL != ghOEMSemaphore)
#define DebugBreak                  EngDebugBreak

// Pool tag marker for memory marking memory allocations.
#define DRV_MEM_POOL_TAG    'meoD'

// Debug prefix that is outputted in the debug messages.
#define DEBUG_PREFIX        "OEMDLL: "


// Remap user mode functions that don't have kernel mode
// equivalents to functions that we implement ourselves.

#define OutputDebugStringA(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%hs", pszMsg))
#define OutputDebugStringW(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%ls", pszMsg))

#if !defined(_M_ALPHA) && !defined(_M_IA64)
    #define InterlockedIncrement        DrvInterlockedIncrement
    #define InterlockedDecrement        DrvInterlockedDecrement
#endif


#define SetLastError                NOP_FUNCTION
#define GetLastError                NOP_FUNCTION



////////////////////////////////////////////////////////
//      Kernel Mode Functions
////////////////////////////////////////////////////////

//
// Implement inline functions to replace user mode 
// functions that don't have kernel mode equivalents.
//


inline int __cdecl _purecall (void)
{
#ifdef DEBUG
    EngDebugBreak();
#endif

    return E_FAIL;
}


inline LONG DrvInterlockedIncrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline LONG DrvInterlockedDecrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline void* __cdecl operator new(size_t nSize)
{
    // return pointer to allocated memory
    return  EngAllocMem(0, nSize, DRV_MEM_POOL_TAG);
}


inline void __cdecl operator delete(void *pMem)
{
    if(pMem)
        EngFreeMem(pMem);
}


inline VOID MyDebugPrint(PCHAR pszPrefix, PCHAR pszFormat, ...)
{
    va_list VAList;

    va_start(VAList, pszFormat);
    EngDebugPrint(DEBUG_PREFIX, pszFormat, VAList);
    va_end(VAList);

    return;
}



#endif // USERMODE_DRIVER


#endif // _KMODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdll\um\oem.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oem.h

Abstract:

    This file contains definitions and declarations of GPD resource ID.

Environment:

    Windows NT PostScript driver

Revision History:

    09/13/96 -eigos-
        Created it.

    dd-mm-yy -author-
        description

--*/

#ifndef _OEM_H_
#define _OEM_H_
#include "lib.h"
#include "devmode.h"
#include "regdata.h"
#include <windows.h>
#include <winspool.h>
#include <commctrl.h>
#include <winddiui.h>
#include <stddef.h>
#include <winddi.h>
#include <compstui.h>

#include "printoem.h"
#include "oemdev.h"

//
// Tree view item level
//

#define TVITEM_LEVEL1 1
#define TVITEM_LEVEL2 2

//
// UserData value
//

#define UNKNOWN_ITEM 0
#define PS_INJECTION 1


#endif // _OEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\inc\ttyui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:   TTYUI.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//              for TTYUI user mode Module.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//
#ifndef _TTYUI_H
#define _TTYUI_H


////////////////////////////////////////////////////////
//      TTY UI Defines
////////////////////////////////////////////////////////

// fMode values.
#define OEMDM_SIZE      1
#define OEMDM_DEFAULT   2
#define OEMDM_CONVERT   3
#define OEMDM_VALIDATE  4

// tty Signature and version.
    #define OEM_SIGNATURE   'TTY0'
    #define TESTSTRING      "This is the TTY driver"
    #define PROP_TITLE      L"TTY UI Page"
    #define DLLTEXT(s)      __TEXT("TTYUI:  ") __TEXT(s)

#define OEM_VERSION      0x92823141L

// OEM UI Misc defines.
#define OEM_ITEMS       5
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define PATH_SEPARATOR  '\\'


#define MAX_INT_FIELD_WIDTH  4
#define MAX_CMD_LEN  100
#define RADIX  10
#define TTYSTRUCT_VER  8
#define FIRSTSTRINGID   IDS_STRING1
#define LASTSTRINGID     IDS_STRING14

#define  TTY_CB_BEGINJOB             1
#define  TTY_CB_ENDJOB                 2
#define  TTY_CB_PAPERSELECT        3
#define  TTY_CB_FEEDSELECT          4
#define  TTY_CB_BOLD_ON                7
#define  TTY_CB_BOLD_OFF                8
#define  TTY_CB_UNDERLINE_ON             9
#define  TTY_CB_UNDERLINE_OFF             10



////////////////////////////////////////////////////////
//      tty UI Type Defines
////////////////////////////////////////////////////////

typedef struct tag_DMEXTRAHDR {
    DWORD   dwSize;
    DWORD   dwSignature;
    DWORD   dwVersion;
} DMEXTRAHDR, *PDMEXTRAHDR;


typedef struct tag_OEMUI_EXTRADATA {
    DMEXTRAHDR  dmExtraHdr;
    BYTE        cbTestString[sizeof(TESTSTRING)];
} OEMUI_EXTRADATA, *POEMUI_EXTRADATA;





typedef  struct
{
    BYTE  strCmd[MAX_CMD_LEN] ;
    DWORD   dwLen ;
}   CMDSTR, *PCMDSTR ;



// this structure used as static storage inside dialog proc.
//  update  #define TTYSTRUCT_VER  8  defined above.
//   when changing this struct.

typedef  struct
{
    DWORD       dwVersion ;   // holds version of REGSTRUCT.
    INT       iCodePage ;         //  negative for built in GTT, the CP value otherwise
    BOOL    bIsMM ;  //  set true if units are tenths of mm, else 1/100 of inch.
    RECT  rcMargin ;   // user defined unprintable margins in above units.
    CMDSTR     BeginJob, EndJob, PaperSelect, FeedSelect,
        Sel_10_cpi, Sel_12_cpi, Sel_17_cpi,
        Bold_ON, Bold_OFF, Underline_ON, Underline_OFF;
    DWORD       dwGlyphBufSiz,   // size of  aubGlyphBuf
                        dwSpoolBufSiz;  //  size of aubSpoolBuf
    PBYTE  aubGlyphBuf, aubSpoolBuf ;  //  used by  OutputCharStr method
}       REGSTRUCT, *PREGSTRUCT ;





typedef  struct
{
// per invocation globals
    HANDLE  hPrinter ;   // so we can access registry within DialogProc.
    HANDLE  hOEMHeap ;
    PWSTR   pwHelpFile ;  // fully qualified path to helpfile.
    DWORD       dwUseCount ;  // usage count
    REGSTRUCT   regStruct ;    // stuff that goes into registry
}   GLOBALSTRUCT ,  *PGLOBALSTRUCT ;



////////////////////////////////////////////////////////
//      TTY UI Prototypes
////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\render\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"
#include "kmode.h"



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\render\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\render\oemcom.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif 
#include <tty.h>
#include <printoem.h>
#include <prntfont.h>
#include "..\inc\name.h"
#include <initguid.h>
#include <prcomoem.h>
#include <assert.h>
#include "oemcom.h"
#include "ttyui.h"
#include "debug.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{
    VERBOSE(DLLTEXT("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
        VERBOSE(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ;
    }
    else if (iid == IID_IPrintOemUni2)
    {
        *ppv = static_cast<IPrintOemUni2*>(this) ;
        VERBOSE(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ;
    }
    else
    {
        *ppv = NULL ;
        WARNING(DLLTEXT("IOemCB:Return NULL.\n")) ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release()
{
    VERBOSE(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

IOemCB::~IOemCB()
{
    //
    // Make sure that driver's helper function interface is released.
    //
    if(NULL != pOEMHelp)
    {
        pOEMHelp->Release();
        pOEMHelp = NULL;
    }

    //
    // If this instance of the object is being deleted, then the reference
    // count should be zero.
    //

    assert(0 == m_cRef) ;
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

    //
    // Need to store pointer to Driver Helper functions, if we already haven't.
    //
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        //
        // Get Interface to Helper Functions.
        //
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            //
            // Make sure that interface pointer reflects interface query failure.
            //
            this->pOEMHelp = NULL;
        }
    }

    if (this->pOEMHelp)
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));

    if(OEMEnableDriver(dwDriverVersion, cbSize, pded) )
        return S_OK;
    return S_FALSE;
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
    
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL ;
    }
    return S_OK;
}


// the following OEM function is called by Unidrv to provide
// the OEM dll with an interface it can use to access Unidrv's
// helper functions like WriteSpoolBuf etc.
//  warning: calling this more per IOemCB object than once will result
//  in mismatched reference counts.


LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *ppDevOem)
{
    VERBOSE(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));

    if(*ppDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,
                phsurfPatterns, cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded) )
        return S_OK;
    return S_FALSE;

}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    VERBOSE(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));

    OEMDisablePDEV(pdevobj) ;
    return S_OK;
};

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));

    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{

    LONG lReturn = FALSE;
    VERBOSE(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    VERBOSE(DLLTEXT("        Function:%s:"),pMethodName);

    if (pMethodName == NULL)
    {
        lReturn = FALSE;
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;
#endif
#if 0
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
#endif
#if 0
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
#endif
#if 0
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
#if 0
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'I':
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'M':
#if 0
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'O':

                if (!strcmp(pstrOutputCharStr, pMethodName))
                   lReturn = TRUE;

                break;

            case (WCHAR)'R':
#if 0
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'S':
         
				if (!strcmp(pstrSendFontCmd, pMethodName))
						   lReturn = TRUE;
              
				break;

            case (WCHAR)'T':
                if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
#endif
#if 0
                else if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
#endif
			    break;
#if 0
			case (WCHAR)'W':
				if (!strcmp(pstrWritePrinter,pMethodName) )
					Result = S_OK ;
#endif				
				break;
        }
    }

    if (lReturn)
    {
        VERBOSE(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
{
    VERBOSE(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    
	return E_NOTIMPL;

}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    VERBOSE(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    VERBOSE(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    DWORD dwResult;
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    PCMDSTR      pSelectCmd = NULL ;   // points to one of the command structures
                                                //  in pMyStuff.

    *piResult =  0 ;   //  for all non movement commands
    pMyStuff = (PREGSTRUCT)pdevobj->pdevOEM ;

    switch(dwCallbackID)
    {
        case  TTY_CB_BEGINJOB:
            pSelectCmd = &pMyStuff->BeginJob ;
            break;
        case  TTY_CB_ENDJOB:
            pSelectCmd = &pMyStuff->EndJob ;
            break;
        case  TTY_CB_PAPERSELECT:
            pSelectCmd = &pMyStuff->PaperSelect ;
            break;
        case  TTY_CB_FEEDSELECT:
            pSelectCmd = &pMyStuff->FeedSelect ;
            break;
        case  TTY_CB_BOLD_ON:
            pSelectCmd = &pMyStuff->Bold_ON ;
            break;
        case  TTY_CB_BOLD_OFF:
            pSelectCmd = &pMyStuff->Bold_OFF ;
            break;
        case  TTY_CB_UNDERLINE_ON:
            pSelectCmd = &pMyStuff->Underline_ON ;
            break;
        case  TTY_CB_UNDERLINE_OFF:
            pSelectCmd = &pMyStuff->Underline_OFF ;
            break;

        default:
            return S_OK;
    }

    if(pSelectCmd)
         pOEMHelp->DrvWriteSpoolBuf(pdevobj, pSelectCmd->strCmd, pSelectCmd->dwLen,
                &dwResult);

#if 0

    //  this code is just to test new Unidrv helper functions.


     pOEMHelp->DrvWriteAbortBuf(pdevobj, pSelectCmd->strCmd, pSelectCmd->dwLen,
                3000);


     //  temp variables:
     DWORD     dwcursorPosX,  dwcursorPosY,  cbNeeded ;
     PBYTE      pBuffer;

        pOEMHelp->DrvGetStandardVariable(      pdevobj,
                                                        SVI_CURSORORIGINX,
                                                        &dwcursorPosX,
                                                        sizeof(DWORD),
                                                        &cbNeeded);

        pOEMHelp->DrvGetStandardVariable(      pdevobj,
                                                        SVI_CURSORORIGINY,
                                                        &dwcursorPosY,
                                                        sizeof(DWORD),
                                                        &cbNeeded);

        pOEMHelp->DrvGetGPDData(       pdevobj,
            GPD_OEMCUSTOMDATA,     // Type of the data
            NULL,   // reserved. Should be set to 0
            NULL,     // Caller allocated Buffer to be copied
            0,     // Size of the buffer
            &cbNeeded   // New Size of the buffer if needed.
            ) ;

        pBuffer = (PBYTE)MemAlloc(cbNeeded);

        pOEMHelp->DrvGetGPDData(       pdevobj,
            GPD_OEMCUSTOMDATA,     // Type of the data
            NULL,   // reserved. Should be set to 0
            pBuffer,     // Caller allocated Buffer to be copied
            cbNeeded,     // Size of the buffer
            &cbNeeded   // New Size of the buffer if needed.
            ) ;

     pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuffer, cbNeeded,
                &dwResult);


    MemFree(pBuffer);

#endif

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
   
	if (*ppbResult = OEMImageProcessing(pdevobj, pSrcBitmap,
            pBitmapInfoHeader, pColorTable, dwCallbackID, pIPParams))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    VERBOSE(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    
	if (OEMFilterGraphics( pdevobj,  pBuf,  dwLen))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    
	return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    
	return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    
	return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
{
    VERBOSE(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult)
{
    VERBOSE(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
{
    VERBOSE(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));

    return E_NOTIMPL;
}



LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
    DWORD  dwI, dwGetInfo, dwResult, dwGlyphBufSiz, dwSpoolBufSiz, dwDst;
    PREGSTRUCT pMyStuff;
	
    VERBOSE(DLLTEXT("OEMOutputCharStr() entry.\r\n"));
    
    pMyStuff = (PREGSTRUCT)pdevobj->pdevOEM ;

    //  is the glyph buffers cache large enough?

    dwGlyphBufSiz = dwCount * sizeof(TRANSDATA);

    if(dwGlyphBufSiz > pMyStuff->dwGlyphBufSiz)   //  need to realloc mem.
    {
        if(pMyStuff->aubGlyphBuf)
        {
            MemFree(pMyStuff->aubGlyphBuf) ;
            pMyStuff->dwGlyphBufSiz = 0 ;
        }
        if(pMyStuff->aubGlyphBuf = (PBYTE)MemAlloc(dwGlyphBufSiz))
            pMyStuff->dwGlyphBufSiz = dwGlyphBufSiz ;
        else
            return(E_FAIL);   //  unable to alloc needed buffers.
    }


    dwSpoolBufSiz = dwCount * sizeof(WORD);  // assume worst case.

    if(dwSpoolBufSiz > pMyStuff->dwSpoolBufSiz)   //  need to realloc mem.
    {
        if(pMyStuff->aubSpoolBuf)
        {
            MemFree(pMyStuff->aubSpoolBuf) ;
            pMyStuff->dwSpoolBufSiz = 0 ;
        }
        if(pMyStuff->aubSpoolBuf = (PBYTE)MemAlloc(dwSpoolBufSiz))
            pMyStuff->dwSpoolBufSiz = dwSpoolBufSiz ;
        else
            return(E_FAIL);   //  unable to alloc needed buffers.
    }

    if(dwType != TYPE_GLYPHHANDLE)
        return(E_FAIL);  // E_FAIL  can only handle device fonts.

        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = dwType;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
		GStr.pGlyphOut = pMyStuff->aubGlyphBuf ;
	    GStr.dwGlyphOutSize = dwGlyphBufSiz;   // instead of pMyStuff->dwGlyphBufSiz, which cause AV
        dwGetInfo = GStr.dwSize;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            dwGetInfo, &dwGetInfo))
        {
            WARNING(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return(E_FAIL);
        }

        
        pTrans = (PTRANSDATA)pMyStuff->aubGlyphBuf;

        for (dwDst =  dwI = 0 ; dwI < dwCount; dwI++, pTrans++)
        {
            VERBOSE(DLLTEXT("TYPE_TRANSDATA:ubCodePageID:0x%x\n"),pTrans->ubCodePageID);
            VERBOSE(DLLTEXT("TYPE_TRANSDATA:ubType:0x%x\n"),pTrans->ubType);
            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
                case MTYPE_DIRECT:
                    pMyStuff->aubSpoolBuf[dwDst++] =  pTrans->uCode.ubCode ;
                    break;
                case MTYPE_PAIRED:		       
                    VERBOSE(DLLTEXT("TYPE_TRANSDATA:ubPairs:0x%x\n"),*(PWORD)(pTrans->uCode.ubPairs));
                    pMyStuff->aubSpoolBuf[dwDst++] =  pTrans->uCode.ubPairs[0] ;
                    pMyStuff->aubSpoolBuf[dwDst++] =  pTrans->uCode.ubPairs[1] ;
                    break;
                default:
                    return (E_FAIL);  // no other MTYPE is supported.
                    break;
            }
        }
        

        // send dst bytes to printer.
        pOEMHelp->DrvWriteSpoolBuf(pdevobj, pMyStuff->aubSpoolBuf, dwDst,
           &dwResult);

        if(dwResult == dwDst)
            return S_OK;
        return E_FAIL ;
}


LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
{
    VERBOSE(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    
	PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    PCMDSTR      pSelectCmd ;   // points to one of the font selection
            // command structures in pMyStuff.
    DWORD dwResult;

     //  I expect pFInv to contain either "10", "12" or "17"

    pMyStuff = (PREGSTRUCT)pdevobj->pdevOEM ;

    if(pFInv->dwCount == 2  &&  pFInv->pubCommand[0] == '1')
    {
        if (pFInv->pubCommand[1] == '2')
            pSelectCmd = &pMyStuff->Sel_12_cpi ;
        else if (pFInv->pubCommand[1] == '7')
            pSelectCmd = &pMyStuff->Sel_17_cpi ;
        else if (pFInv->pubCommand[1] == '0')
            pSelectCmd = &pMyStuff->Sel_10_cpi ;
        else
            return S_OK;    //  maybe asking to deselect a font.  Don't do anything!
    }
    else
        return S_OK;    //  maybe asking to deselect a font.  Don't do anything!

     pOEMHelp->DrvWriteSpoolBuf(pdevobj, pSelectCmd->strCmd, pSelectCmd->dwLen,
                &dwResult);

    return S_OK;
}



LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    
	return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    
	return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded
    )
{
    VERBOSE(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    
	if(OEMTTYGetInfo( pdevobj,      dwInfoIndex,
           pOutputBuf,    dwSize,   pcbcNeeded) )
        return S_OK;
    return S_FALSE ;
}


LONG __stdcall  IOemCB:: WritePrinter (  PDEVOBJ    pdevobj,
	                                  PVOID      pBuf,
		                             DWORD      cbBuffer,
    								PDWORD     pcbWritten)
{
	VERBOSE(DLLTEXT("IOemCB::WritePrinter() entry.\r\n"));
	
	return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    VERBOSE(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}



///////////////////////////////////////////////////////////

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\render\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H

#include "kmode.h"


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\render\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.

// kill 2 lines for IA 64
//#define WINVER          0x0500
//#define _WIN32_WINNT    0x0500


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\render\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Copyright (c) 1996  - 1999  Microsoft Corporation
// Used by OEMUD.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\render\oemcom.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB
//
class IOemCB:public IPrintOemUni2
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
    										MIX         mix);
	
	//
	// OEMWritePrinter - UNIDRV only
	//
	
	STDMETHOD(WritePrinter) (THIS_   PDEVOBJ    pdevobj,
	                                 PVOID      pBuf,
		                             DWORD      cbBuffer,
    								 PDWORD     pcbWritten);


    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };

    ~IOemCB();

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\kmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       KMode.h
//
//
//  PURPOSE:    Definitions and routines for compiling kernel mode instead of user mode.
//
//  PLATFORMS:
//    Windows NT
//
//

#ifndef _KMODE_H
#define _KMODE_H


// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif



#ifdef USERMODE_DRIVER

//
// User mode difinitions to get rid of defines for kernel mode.
//

// Don't need critical section in user mode.

#define DECLARE_CRITICAL_SECTION    ;
#define INIT_CRITICAL_SECTION()     NOP_FUNCTION
#define DELETE_CRITICAL_SECTION()   NOP_FUNCTION
#define IS_VALID_CRITICAL_SECTION() (TRUE)


#else // !USERMODE_DRIVER


////////////////////////////////////////////////////////
//      Kernel Mode Defines
////////////////////////////////////////////////////////

extern HSEMAPHORE ghOEMSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghOEMSemaphore = NULL;
#define INIT_CRITICAL_SECTION()     ghOEMSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghOEMSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghOEMSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghOEMSemaphore)
#define IS_VALID_CRITICAL_SECTION() (NULL != ghOEMSemaphore)
#define DebugBreak                  EngDebugBreak

// Pool tag marker for memory marking memory allocations.
#define DRV_MEM_POOL_TAG    'meoD'

// Debug prefix that is outputted in the debug messages.
#define DEBUG_PREFIX        "OEMDLL: "


// Remap user mode functions that don't have kernel mode
// equivalents to functions that we implement ourselves.

#define OutputDebugStringA(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%hs", pszMsg))
#define OutputDebugStringW(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%ls", pszMsg))

#if !defined(_M_ALPHA) && !defined(_M_IA64)
    #define InterlockedIncrement        DrvInterlockedIncrement
    #define InterlockedDecrement        DrvInterlockedDecrement
#endif


#define SetLastError                NOP_FUNCTION
#define GetLastError                NOP_FUNCTION



////////////////////////////////////////////////////////
//      Kernel Mode Functions
////////////////////////////////////////////////////////

//
// Implement inline functions to replace user mode 
// functions that don't have kernel mode equivalents.
//


inline int __cdecl _purecall (void)
{
#ifdef DEBUG
    EngDebugBreak();
#endif

    return E_FAIL;
}


inline LONG DrvInterlockedIncrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline LONG DrvInterlockedDecrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline void* __cdecl operator new(size_t nSize)
{
    // return pointer to allocated memory
    return  EngAllocMem(0, nSize, DRV_MEM_POOL_TAG);
}


inline void __cdecl operator delete(void *pMem)
{
    if(pMem)
        EngFreeMem(pMem);
}


inline VOID MyDebugPrint(PCHAR pszPrefix, PCHAR pszFormat, ...)
{
    va_list VAList;

    va_start(VAList, pszFormat);
    EngDebugPrint(DEBUG_PREFIX, pszFormat, VAList);
    va_end(VAList);

    return;
}



#endif // USERMODE_DRIVER


#endif // _KMODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\inc\name.h ===
//   Copyright (c) 1996  - 1999  Microsoft Corporation

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";



CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrWritePrinter[] = "WritePrinter";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include <WINDDIUI.H>
#include <PRINTOEM.H>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\render\ttyud.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:   TTYUD.cpp
//
//
//  PURPOSE:  Main file for TTY kernel mode module.
//
//
//  Functions:
//
//
//
//
//  PLATFORMS:  Windows 95, Windows NT
//
//

#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <winspool.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <winddi.h>

#ifdef __cplusplus
}
#endif


#include <tchar.h>
#include <excpt.h>


#include <PRINTOEM.H>

#include "ttyui.h"
#include "TTYUD.h"
#include "debug.h"

DWORD gdwDrvMemPoolTag = 'Oem5';      // for MemAlloc debugging purposes



#define     TTY_INFO_MARGINS  1
#define     TTY_INFO_CODEPAGE  2
#define     TTY_INFO_NUM_UFMS    3
#define     TTY_INFO_UFM_IDS    4

#define     NUM_UFMS    3             //  for internal use only.  use TTY_INFO_NUM_UFMS
    //  to query number of font sizes supported.



////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////



BOOL APIENTRY OEMGetInfo(IN DWORD dwInfo, OUT PVOID pBuffer, IN DWORD cbSize,
                         OUT PDWORD pcbNeeded) ;
PDEVOEM APIENTRY OEMEnablePDEV(PDEVOBJ pdevobj, PWSTR pPrinterName, ULONG cPatterns,
                               HSURF *phsurfPatterns, ULONG cjGdiInfo, GDIINFO *pGdiInfo,
                               ULONG cjDevInfo, DEVINFO *pDevInfo, DRVENABLEDATA *pded) ;
VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj) ;
BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded) ;


PBYTE APIENTRY OEMImageProcessing(PDEVOBJ pdevobj, PBYTE pSrcBitmap, PBITMAPINFOHEADER pBitmapInfo,
                                  PBYTE pColorTable, DWORD dwCallbackID, PIPPARAMS pIPParams) ;

BOOL APIENTRY OEMFilterGraphics(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen) ;




// Need to export these functions as c declarations.
extern "C" {


PBYTE APIENTRY OEMImageProcessing(PDEVOBJ pdevobj, PBYTE pSrcBitmap, PBITMAPINFOHEADER pBitmapInfo,
                                  PBYTE pColorTable, DWORD dwCallbackID, PIPPARAMS pIPParams)
{
    VERBOSE(DLLTEXT("OEMImageProcessing() entry.\r\n"));

    return ((PBYTE)TRUE);
}


BOOL APIENTRY OEMFilterGraphics(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen)
{
    VERBOSE(DLLTEXT("OEMFilterGraphics() entry.\r\n"));

    return TRUE;
}




BOOL APIENTRY OEMGetInfo(IN DWORD dwInfo, OUT PVOID pBuffer, IN DWORD cbSize,
                         OUT PDWORD pcbNeeded)
{

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo)
          &&
          (OEMGI_GETINTERFACEVERSION != dwInfo)
          &&
          (OEMGI_GETVERSION != dwInfo)
        )
        ||
        (NULL == pcbNeeded)
      )
    {
      VERBOSE(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
            *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer)
        ||
        (4 > cbSize)
      )
    {
        // VERBOSE(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        EngSetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
        case OEMGI_GETSIGNATURE:
            *(LPDWORD)pBuffer = OEM_SIGNATURE;
            break;

        case OEMGI_GETINTERFACEVERSION:
            *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
            break;

        case OEMGI_GETVERSION:
            *(LPDWORD)pBuffer = OEM_VERSION;
            break;
    }

    return TRUE;
}



PDEVOEM APIENTRY OEMEnablePDEV(PDEVOBJ pdevobj, PWSTR pPrinterName, ULONG cPatterns,
                               HSURF *phsurfPatterns, ULONG cjGdiInfo, GDIINFO *pGdiInfo,
                               ULONG cjDevInfo, DEVINFO *pDevInfo, DRVENABLEDATA *pded)
{
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    DWORD   dwStatus, cbNeeded, dwType ;
    LPTSTR  pValueName = TEXT("TTY DeviceConfig");
                // these strings must match strings in oemui.cpp - VinitMyStuff()

    VERBOSE(DLLTEXT("OEMEnablePDEV() entry.\r\n"));

    pMyStuff = (PREGSTRUCT)MemAlloc(sizeof(REGSTRUCT)) ;
    if(!pMyStuff)
        return ((PDEVOEM)NULL) ;  //  failed.

    pdevobj->pdevOEM = (PDEVOEM)pMyStuff ;

    dwStatus =  EngGetPrinterData(
    pdevobj->hPrinter, // handle of printer object
    pValueName, // address of value name
    &dwType,    // address receiving value type
    (LPBYTE)pMyStuff,
                // address of array of bytes that receives data
    sizeof(REGSTRUCT),  // size, in bytes, of array
    &cbNeeded   // address of variable
            //  with number of bytes retrieved (or required)
    );
    if (dwStatus != ERROR_SUCCESS || pMyStuff->dwVersion != TTYSTRUCT_VER
        ||  dwType !=  REG_BINARY
        ||  cbNeeded != sizeof(REGSTRUCT))
    {
        //  Init secret block with defaults

        pMyStuff->dwVersion = TTYSTRUCT_VER ;
        //  version stamp to avoid incompatible structures.

        pMyStuff->bIsMM = TRUE ;  // default to mm units
        //  read margin values from registry and store into temp RECT

        pMyStuff->iCodePage =  1252 ;  //   keep in sync with oemui.cpp - VinitMyStuff()
        pMyStuff->rcMargin.left  = pMyStuff->rcMargin.top  =
        pMyStuff->rcMargin.right  =  pMyStuff->rcMargin.bottom  = 0 ;
        pMyStuff->BeginJob.dwLen =
        pMyStuff->EndJob.dwLen =
        pMyStuff->PaperSelect.dwLen =
        pMyStuff->FeedSelect.dwLen =
        pMyStuff->Sel_10_cpi.dwLen =
        pMyStuff->Sel_12_cpi.dwLen =
        pMyStuff->Sel_17_cpi.dwLen =
        pMyStuff->Bold_ON.dwLen =
        pMyStuff->Bold_OFF.dwLen =
        pMyStuff->Underline_ON.dwLen =
        pMyStuff->Underline_OFF.dwLen = 0 ;

        // more fields here!
        pMyStuff->dwGlyphBufSiz =
        pMyStuff->dwSpoolBufSiz = 0 ;
        pMyStuff->aubGlyphBuf =
        pMyStuff->aubSpoolBuf  = NULL ;
    }

    return ((PDEVOEM)pMyStuff) ;
}


VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj)
{
    VERBOSE(DLLTEXT("OEMDisablePDEV() entry.\r\n"));

    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals

    pMyStuff = (PREGSTRUCT)pdevobj->pdevOEM ;
    if(pMyStuff->aubGlyphBuf)
        MemFree(pMyStuff->aubGlyphBuf) ;
    if(pMyStuff->aubSpoolBuf)
        MemFree(pMyStuff->aubSpoolBuf) ;
    MemFree(pdevobj->pdevOEM);
}


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // Validate paramters.
    if(   (PRINTER_OEMINTF_VERSION != dwOEMintfVersion) ||
        //  above check not needed for COM
        (sizeof(DRVENABLEDATA) > dwSize)
        ||
        (NULL == pded)
      )
    {
        //  VERBOSE(ERRORTEXT("OEMEnableDriver() ERROR_INVALID_PARAMETER.\r\n"));

        return FALSE;
    }

    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION ; //   not  DDI_DRIVER_VERSION;
    pded->c = 0;

    return TRUE;
}


BOOL    APIENTRY   OEMTTYGetInfo(PDEVOBJ pdevobj,    DWORD  dwInfoIndex,
        PVOID   pOutBuf,  DWORD  dwSize, DWORD  *pcbNeeded
)
{
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    REGSTRUCT  MyStuff;   // temp  structure to hold registry data

    pMyStuff = (PREGSTRUCT)pdevobj->pdevOEM ;

    if(!pMyStuff)
    {
        DWORD   dwStatus, cbNeeded, dwType ;
        LPTSTR  pValueName = TEXT("TTY DeviceConfig");
                // these strings must match strings in oemui.cpp - VinitMyStuff()
                //  and OEMEnablePDEV()

        pMyStuff =    &MyStuff;
		
		pMyStuff->dwVersion = 0 ;

        dwStatus =  EngGetPrinterData(
            pdevobj->hPrinter, // handle of printer object
            pValueName, // address of value name
            &dwType,    // address receiving value type
            (LPBYTE)pMyStuff ,
                        // address of array of bytes that receives data
            sizeof(REGSTRUCT),  // size, in bytes, of array
            &cbNeeded   // address of variable
                    //  with number of bytes retrieved (or required)
            );
        if (dwStatus != ERROR_SUCCESS || pMyStuff->dwVersion != TTYSTRUCT_VER
                ||  dwType !=  REG_BINARY
                ||  cbNeeded != sizeof(REGSTRUCT))
        {
            //  set to defaults
            pMyStuff->iCodePage =  1252 ;  //   keep in sync with oemui.cpp - VinitMyStuff()
            pMyStuff->rcMargin.left  = pMyStuff->rcMargin.top  =
            pMyStuff->rcMargin.right  =  pMyStuff->rcMargin.bottom  = 0 ;
        }
    }

    switch  (dwInfoIndex)
    {
        case  TTY_INFO_MARGINS:
            *pcbNeeded = sizeof(RECT) ;
            if(!pOutBuf  ||  dwSize < *pcbNeeded)
                return(FALSE) ;
            *(LPRECT)pOutBuf = pMyStuff->rcMargin ;
            break;
        case  TTY_INFO_CODEPAGE:
            *pcbNeeded = sizeof(INT) ;
            if(!pOutBuf  ||  dwSize < *pcbNeeded)
                return(FALSE) ;
            *(INT *)pOutBuf = pMyStuff->iCodePage ;
            break;
        case  TTY_INFO_NUM_UFMS:
            *pcbNeeded = sizeof(DWORD) ;
            if(!pOutBuf  ||  dwSize < *pcbNeeded)
                return(FALSE) ;
            *(DWORD *)pOutBuf = NUM_UFMS ;  //  Number of resource IDs returned
            //  during a query for TTY_INFO_UFM_IDS
            break;
        case  TTY_INFO_UFM_IDS:
            // return resource IDs of the UFMs for 10,12, 17 cpi fonts.
            *pcbNeeded = NUM_UFMS * sizeof(DWORD) ;
            if(!pOutBuf  ||  dwSize < *pcbNeeded)
                return(FALSE) ;
            switch(pMyStuff->iCodePage)
            {
                
				case (-1):  // codepage 437
                    ((DWORD *)pOutBuf)[0] = 4 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 5;
                    ((DWORD *)pOutBuf)[2] = 6;
                    break;
                case (850):  // codepage 850
                    ((DWORD *)pOutBuf)[0] = 7;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 8;
                    ((DWORD *)pOutBuf)[2] = 9;
                    break;

				case (-3):  // codepage 863
                    ((DWORD *)pOutBuf)[0] = 7;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 8;
                    ((DWORD *)pOutBuf)[2] = 9;
                    break;

                case (-17):  // codepage 932
                    ((DWORD *)pOutBuf)[0] = 13 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 14 ;
                    ((DWORD *)pOutBuf)[2] = 15 ;
                    break;
                case (-16):  // codepage 936
                    ((DWORD *)pOutBuf)[0] = 16 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 17 ;
                    ((DWORD *)pOutBuf)[2] = 18 ;
                    break;
                case (-18):  // codepage 949
                    ((DWORD *)pOutBuf)[0] = 19 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 20 ;
                    ((DWORD *)pOutBuf)[2] = 21 ;
                    break;
                case (-10):  // codepage 950
                    ((DWORD *)pOutBuf)[0] = 22 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 23 ;
                    ((DWORD *)pOutBuf)[2] = 24 ;
                    break;
				case (1250):  // codepage 1250
                    ((DWORD *)pOutBuf)[0] = 25 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 26;
                    ((DWORD *)pOutBuf)[2] = 27;
                    break;
                case (1251):  // codepage 1251
                    ((DWORD *)pOutBuf)[0] = 28;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 29;
                    ((DWORD *)pOutBuf)[2] = 30;
                    break;
                case (1252):  // codepage 1252
                    ((DWORD *)pOutBuf)[0] = 31;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 32;
                    ((DWORD *)pOutBuf)[2] = 33;
                    break;
                case (1253):  // codepage 1253
                    ((DWORD *)pOutBuf)[0] = 34 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 35;
                    ((DWORD *)pOutBuf)[2] = 36;
                    break;
                case (1254):  // codepage 1254
                    ((DWORD *)pOutBuf)[0] = 37 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 38;
                    ((DWORD *)pOutBuf)[2] = 39;
                    break;
                case (852):	// codepage 852
					((DWORD *)pOutBuf)[0] = 40 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 41;
                    ((DWORD *)pOutBuf)[2] = 42;
		    
					break;
				case (857):	// codepage 857
					((DWORD *)pOutBuf)[0] = 43 ;           //  see  tty\rc\tty.rc for resID assignments
                    ((DWORD *)pOutBuf)[1] = 44;
                    ((DWORD *)pOutBuf)[2] = 45;
		    
					break;
                default:
                    ((DWORD *)pOutBuf)[0] = 1 ;  //  '10 cpi'
                    ((DWORD *)pOutBuf)[1] = 2 ;  //  '12 cpi'
                    ((DWORD *)pOutBuf)[2] = 3 ;  //  '17 cpi'
                    break;
            }
            break;
        default:
            *pcbNeeded  = 0 ;  // no data availible
            return(FALSE) ;   // unsupported index
    }
    return(TRUE);
}

} // End of extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(__TEXT("pPSUIInfo:\r\n"));
    VERBOSE(__TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(__TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(__TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(__TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(__TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(__TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(__TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(__TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(__TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\render\ttyud.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:   TTYUD.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//              for TTYUD kernel mode Module.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//
#ifndef _TTYUD_H
#define _TTYUD_H


////////////////////////////////////////////////////////
//      TTY UD Defines
////////////////////////////////////////////////////////

extern DWORD    gdwDrvMemPoolTag;

#define MemAlloc(size)      EngAllocMem(0, size, gdwDrvMemPoolTag)
#define MemAllocZ(size)     EngAllocMem(FL_ZERO_MEMORY, size, gdwDrvMemPoolTag)
#define MemFree(p)          { if (p) EngFreeMem(p); }



////////////////////////////////////////////////////////
//      TTY UD Type Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      TTY UD Prototypes
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\resource.h ===
//  Copyright (c) 1996  - 1999  Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ttyui.rc
//
#define IDC_STATIC      -1
#define IDS_STRING1                     1
#define IDS_STRING2                     2
#define IDS_STRING3                     3
#define  IDS_STRING4             4
#define  IDS_STRING5             5
#define  IDS_STRING6             6
#define  IDS_STRING7             7
#define  IDS_STRING8             8
#define  IDS_STRING9             9
#define  IDS_STRING10            10
#define  IDS_STRING11            11
#define  IDS_STRING12            12

#define  IDS_STRING13            13
#define  IDS_STRING14            14
#define  IDS_STRING15            15
#define  IDS_STRING16            16
#define  IDS_STRING17            17
#define  IDS_STRING18            18
#define  IDS_STRING19            19
#define  IDS_STRING20            20
#define  IDS_STRING21            21

#define IDD_DOC_PROPPAGE                102
#define IDD_DEV_PROPPAGE                103
#define IDD_DEV_PROPPAGE2               104
#define IDC_SETUP_STRING                1000
#define IDC_EDIT10                      1000
#define IDC_EDIT1                       1005
#define IDC_EDIT2                       1006
#define IDC_EDIT3                       1007
#define IDC_EDIT4                       1008
#define IDC_EDIT5                       1009
#define IDC_EDIT6                       1011
#define IDC_EDIT7                       1012
#define IDC_EDIT8                       1013
#define IDC_EDIT9                       1014
#define IDC_RADIO1                      1015
#define IDC_RADIO2                      1016
#define IDC_BUTTON1                     1018
#define IDC_COMBO1                      1020
#define IDC_EDIT11                      1021
#define IDC_EDIT12                      1022
#define IDC_EDIT13                      1023
#define IDC_EDIT14                      1024
#define IDC_EDIT15                      1025
#define IDC_EDIT16                      1026
#define IDC_EDIT17                      1027
#define IDC_CHKBOX1                      1028

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1029
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\oemcom.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


#include "stddef.h"
#include "stdlib.h"
#include "objbase.h"
#include <windows.h>
#include <assert.h>
#include <prsht.h>
#include <compstui.h>
#include <winddiui.h>
#include <printoem.h>
#include <initguid.h>
#include <prcomoem.h>
#include "oemcomui.h"
#include "ttyui.h"
#include "debug.h"
#include "name.h"


// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{
    VERBOSE(DLLTEXT("IOemCB:QueryInterface entry.\n\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
        VERBOSE(DLLTEXT("IOemCB:Return pointer to IUnknown.\n\n"));
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IOemCB:Return pointer to IPrintOemUI.\n"));
    }
    else
    {
        *ppv = NULL ;
        WARNING(DLLTEXT("IOemCB:No Interface. Return NULL.\n"));
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE(DLLTEXT("IOemCB:AddRef entry.\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release()
{
    VERBOSE(DLLTEXT("IOemCB:Release entry.\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}


IOemCB::~IOemCB()
{
    //
    // Make sure that driver's helper function interface is released.
    //
    if(NULL != pOEMHelp)
    {
        pOEMHelp->Release();
        pOEMHelp = NULL;
    }

    //
    // If this instance of the object is being deleted, then the reference
    // count should be zero.
    //
    assert (0 == m_cRef) ;
   
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

    //
    // Need to store pointer to Driver Helper functions, if we already haven't.
    //
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        //
        // Get Interface to Helper Functions.
        //
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            //
            // Make sure that interface pointer reflects interface query failure.
            //
            this->pOEMHelp = NULL;
        }
    }

    if (this->pOEMHelp)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
	VERBOSE(DLLTEXT("IOemCB:GetInfo entry.\n\n"));

    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{
	VERBOSE(DLLTEXT("IOemCB:DevMode entry.\n\n"));

    return E_NOTIMPL;

}


LONG __stdcall IOemCB::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
	VERBOSE(DLLTEXT("IOemCB:CommonUIProp entry.\n\n"));

    return E_NOTIMPL;

}


LONG __stdcall IOemCB::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
	VERBOSE(DLLTEXT("IOemCB:DocumentPropertySheets entry.\n\n"));

    return E_NOTIMPL;

}

LONG __stdcall IOemCB::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
	VERBOSE(DLLTEXT("IOemCB:DevicePropertySheets entry.\n\n"));

    if(OEMDevicePropertySheets(pPSUIInfo, lParam) == 1)
        return S_OK;
    return   S_FALSE;
}

LONG __stdcall IOemCB::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{

	VERBOSE(DLLTEXT("IOemCB:DeviceCapabilities entry.\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
	VERBOSE(DLLTEXT("IOemCB:DevQueryPrintEx entry.\n\n"));

    return E_NOTIMPL;

}

LONG __stdcall IOemCB::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
	VERBOSE(DLLTEXT("IOemCB:UpgradePrinter entry.\n\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
	VERBOSE(DLLTEXT("IOemCB:PrinterEvent entry.\n\n"));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemCB:DriverEvent entry.\n"));
    
	return E_NOTIMPL;
};

LONG __stdcall IOemCB::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    VERBOSE(DLLTEXT("IOemCB:QueryColorProfile entry.\n"));
    
	return E_NOTIMPL;
};


    //
    // UpdateExternalFonts
    //

LONG __stdcall IOemCB::UpdateExternalFonts(
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges)
{
	VERBOSE(DLLTEXT("IOemCB:UpdateExternalFonts entry.\n\n"));
    
	return E_NOTIMPL;
};



HRESULT __stdcall IOemCB::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam
        )
{
    VERBOSE(DLLTEXT("IOemCB:FontInstallerDlgProc entry.\n"));
    
	return E_NOTIMPL;
};

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };

    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    VERBOSE(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////


//
// Registration functions
// Testing purpose
//

// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //  VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\oemcomui.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// IOemCB
//
class IOemCB: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );

    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );


    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           );



    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB();


protected:
    IPrintOemDriverUI* pOEMHelp;
    LONG m_cRef;
};


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\ttyuihlp.h ===
// Copyright (c) 1997  - 1999  Microsoft Corporation
//Generic Text Printer Driver (new 10/97)

// ;Printer Commands dialog

#define IDH_TTYUI_BEGIN_PRINTJOB        1000 // IDC_EDIT10
#define IDH_TTYUI_END_PRINTJOB          1021 // IDC_EDIT11
#define IDH_TTYUI_PAPERSIZE_SELECT  1022 // IDC_EDIT12
#define IDH_TTYUI_PAPERFEED_SELECTION   1023 // IDC_EDIT13
#define IDH_TTYUI_CHECK_COMMANDS    1018 // IDC_BUTTON1
#define IDH_TTYUI_UNPRINTABLE_MARGINS_LEFT  1024 // IDC_EDIT14
#define IDH_TTYUI_UNPRINTABLE_MARGINS_TOP   1025 // IDC_EDIT15
#define IDH_TTYUI_UNPRINTABLE_MARGINS_RIGHT 1026 // IDC_EDIT16
#define IDH_TTYUI_UNPRINTABLE_MARGINS_BOTTOM    1027 // IDC_EDIT17
#define IDH_TTYUI_UNITS_10MM     1015 // IDC_RADIO1
#define IDH_TTYUI_UNITS_100INCH     1016 // IDC_RADIO2

// ;Font Selection dialog

#define IDH_TTYUI_SELECT_10CPI     1005 // IDC_EDIT1
#define IDH_TTYUI_SELECT_12CPI     1006 //IDC_EDIT2
#define IDH_TTYUI_SELECT_17CPI     1007 //IDC_EDIT3
#define IDH_TTYUI_DBLWIDE_ON     1008 //IDC_EDIT4
#define IDH_TTYUI_DBLWIDE_OFF     1009 // IDC_EDIT5
#define IDH_TTYUI_BOLD_ON     1011 // IDC_EDIT6
#define IDH_TTYUI_BOLD_OFF     1012 // IDC_EDIT7
#define IDH_TTYUI_UNDERLINE_ON     1013 // IDC_EDIT8
#define IDH_TTYUI_UNDERLINE_OFF     1014 // IDC_EDIT9
#define IDH_TTYUI_CODE_PAGE     1020 // IDC_COMBO1

// Next default values for new objects
//
// #define _APS_NEXT_RESOURCE_VALUE        106
// #define _APS_NEXT_COMMAND_VALUE         40001
// #define _APS_NEXT_CONTROL_VALUE         1028
// #define _APS_NEXT_SYMED_VALUE           101


const DWORD aHelpIDs[]=
{
    IDC_EDIT1,  IDH_TTYUI_SELECT_10CPI,
    IDC_EDIT2,  IDH_TTYUI_SELECT_12CPI,
    IDC_EDIT3,  IDH_TTYUI_SELECT_17CPI,
    IDC_EDIT4,  IDH_TTYUI_DBLWIDE_ON,
    IDC_EDIT5,  IDH_TTYUI_DBLWIDE_OFF,
    IDC_EDIT6,  IDH_TTYUI_BOLD_ON,
    IDC_EDIT7,  IDH_TTYUI_BOLD_OFF,
    IDC_EDIT8,  IDH_TTYUI_UNDERLINE_ON,
    IDC_EDIT9,  IDH_TTYUI_UNDERLINE_OFF,

 IDC_EDIT10,  IDH_TTYUI_BEGIN_PRINTJOB,
 IDC_EDIT11,  IDH_TTYUI_END_PRINTJOB,
 IDC_EDIT12,  IDH_TTYUI_PAPERSIZE_SELECT,
 IDC_EDIT13,  IDH_TTYUI_PAPERFEED_SELECTION,
 IDC_EDIT14,  IDH_TTYUI_UNPRINTABLE_MARGINS_LEFT,
 IDC_EDIT15,  IDH_TTYUI_UNPRINTABLE_MARGINS_TOP,
 IDC_EDIT16,  IDH_TTYUI_UNPRINTABLE_MARGINS_RIGHT,
 IDC_EDIT17,  IDH_TTYUI_UNPRINTABLE_MARGINS_BOTTOM,


    IDC_RADIO1, IDH_TTYUI_UNITS_10MM,
    IDC_BUTTON1,    IDH_TTYUI_CHECK_COMMANDS,
    IDC_COMBO1, IDH_TTYUI_CODE_PAGE,
    IDC_RADIO2, IDH_TTYUI_UNITS_100INCH,
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\constrnt.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  constrnt.c - processing keywords imposing constraints
    between 2 or more option selections.   */





#include    "gpdparse.h"


// ----  functions defined in constrnt.c ---- //


BOOL   BparseConstraint(
PABSARRAYREF   paarValue,
PDWORD         pdwExistingCList,  //  index of start of contraint list.
BOOL           bCreate,
PGLOBL         pglobl) ;

BOOL    BexchangeDataInFOATNode(
DWORD   dwFeature,
DWORD   dwOption,
DWORD   dwFieldOff,  // offset of field in FeatureOption struct
PDWORD  pdwOut,     // previous contents of attribute node
PDWORD  pdwIn,
BOOL    bSynthetic,  //  access synthetic features
PGLOBL  pglobl
) ;

BOOL    BparseInvalidCombination(
PABSARRAYREF  paarValue,
DWORD         dwFieldOff,
PGLOBL        pglobl) ;

BOOL    BparseInvalidInstallableCombination1(
PABSARRAYREF  paarValue,
DWORD         dwFieldOff,
PGLOBL        pglobl) ;


// ---------------------------------------------------- //



/*  if time and circumstances warrent may define a
feature keyword  *ExemptFromConstraints: <optionname>
so in addition to specifying a default option, you
may specify which option is exempt from wildcard constraints.

Now we may introduce the concept of wildcard constraints:

if a constraint statement appears at the Feature level it
is equivalent to that statement appearing withing every
option construct in that feature except the option
named in the *ExemptFromConstraints: <optionname>.

We may introduce a wildcard option for the target of a constraint
say '*'.  This is used in place of the option name in the
a constraint statement say:

*Constraint: <featurename>.*

this means every option in <featurename> is disabled
except for the option named in the  <featurename>'s
*ExemptFromConstraints: <optionname>

*/




BOOL   BparseConstraint(
PABSARRAYREF   paarValue,
PDWORD  pdwExistingCList,  //  index of start of contraint list.
BOOL    bCreate,   //  Create new constraint list vs. appending to existing one.
PGLOBL  pglobl)
{
    BOOL        bStatus  ;
    DWORD       dwNewCnstRoot,
        dwListRoot,  //  holds temp list of qualified names
            //  this list will never be used again.
        dwCNode, dwLNode ;
    PCONSTRAINTS     pcnstr ;  // start of CONSTRAINTS array.
    PLISTNODE    plstBase ;  // start of LIST array
    PQUALNAME  pqn ;   // the dword in the list node is actually a
                        // qualified name structure.


    pcnstr = (PCONSTRAINTS) gMasterTable[MTI_CONSTRAINTS].pubStruct ;
    plstBase = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    bStatus = BparseList(paarValue, &dwListRoot, BparseQualifiedName,
                VALUE_QUALIFIED_NAME, pglobl) ;


    if(bStatus == FALSE  ||   dwListRoot ==  END_OF_LIST)
        return(FALSE) ;

    //  create list of constraints

    if(bStatus)
        bStatus =
            BallocElementFromMasterTable(MTI_CONSTRAINTS, &dwNewCnstRoot, pglobl) ;

    dwCNode = dwNewCnstRoot ;
    dwLNode = dwListRoot ;


    while(bStatus)
    {
        pqn = (PQUALNAME)(&plstBase[dwLNode].dwData) ;
        pcnstr[dwCNode].dwFeature = pqn->wFeatureID ;
        pcnstr[dwCNode].dwOption = pqn->wOptionID ;
        if(plstBase[dwLNode].dwNextItem == END_OF_LIST)
            break ;
        dwLNode = plstBase[dwLNode].dwNextItem ;
        bStatus = BallocElementFromMasterTable(MTI_CONSTRAINTS,
                &pcnstr[dwCNode].dwNextCnstrnt, pglobl) ;
        dwCNode = pcnstr[dwCNode].dwNextCnstrnt ;
    }

    if(!bStatus)
        return(FALSE) ;

    //  tack existing list onto new list.

    if(bCreate)  // there is an existing constraint list
        pcnstr[dwCNode].dwNextCnstrnt = END_OF_LIST ;
    else
        pcnstr[dwCNode].dwNextCnstrnt = *pdwExistingCList ;

    *pdwExistingCList = dwNewCnstRoot ;

    return(bStatus) ;
}




/*  note:  InvalidCombos are
    the only fields where the index of a structure
    is stored directly into a the offset part of
    an attribute tree node.   But this is ok since
    the snapshot code never picks this data up.
    Indicies of Constraint structures are stored in
    heap like all other things.
*/



BOOL    BexchangeDataInFOATNode(
DWORD   dwFeature,
DWORD   dwOption,
DWORD   dwFieldOff,  // offset of field in FeatureOption struct
PDWORD  pdwOut,     // previous contents of attribute node
PDWORD  pdwIn,
BOOL    bSynthetic,  //  access synthetic features
PGLOBL  pglobl)     // new contents of attribute node.
/*  'FOAT'  means  FeatureOption AttributeTree.
this function swaps the specified dword value in the specified
attribute node.   (normally used to hold the heap offset,
but this function writes nothing to the heap.)
The parameters dwFeature, dwOption, dwFieldOffset specify
the structure, field, and branch of the attribute tree.
If the specified option branch does not exist, one will be created,
(if pdwIn is not NULL)
its value will be initialized to *pdwIn and the value
INVALID_INDEX will be returned in pdwOut.
Assumptions:   the value is dword sized - specifically holds
array index of an array of structures.
The tree being accessed is strictly one level deep.  That is the
node is fully specified by just Feature, Option.
*/
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF        patr ;
    ATREEREF     atrFound ;
    DWORD    dwFeaOffset  ; // Start numbering features from this
        // starting point.  This gives synthetic features a separate
        //  non-overlapping number space from normal features.


    PDFEATURE_OPTIONS   pfo ;

    if(bSynthetic)
    {
        pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_SYNTHESIZED_FEATURES].pubStruct +
            dwFeature  ;
        dwFeaOffset = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;
    }
    else
    {
        pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct +
            dwFeature ;
        dwFeaOffset = 0 ;
    }

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    patr = (PATREEREF)((PBYTE)pfo + dwFieldOff) ;

    if(*patr == ATTRIB_UNINITIALIZED)
    {
        if(pdwIn)
        {
            if(!BcreateEndNode(patr, dwFeature + dwFeaOffset , dwOption, pglobl) )
                return(FALSE) ;  // resource exhaustion
            patt[*patr].dwOffset = *pdwIn ;
            patt[*patr].eOffsetMeans = VALUE_AT_HEAP ;
        }
        if(pdwOut)
            *pdwOut = INVALID_INDEX ;
        return(TRUE) ;
    }

    if(*patr & ATTRIB_HEAP_VALUE)
    {
        ERR(("Internal parser error.  BexchangeDataInFOATNode should never create a branchless node.\n"));
        return(FALSE) ;
    }

    // offset field contains index to another node
    if(pdwIn)
    {
        if(!BfindOrCreateMatchingNode(*patr, &atrFound, dwFeature + dwFeaOffset , dwOption, pglobl))
            return(FALSE) ;  // Tree inconsistency error or resource exhaustion
        if(patt[atrFound].eOffsetMeans != VALUE_AT_HEAP)
        {
            //  just created a new node.
    #if 1
            patt[atrFound].dwOffset = *pdwIn ;
    #else
            //  the way it was
            if(!BwriteToHeap(&(patt[atrFound].dwOffset), (PBYTE)pdwIn,
                                                        sizeof(DWORD), 4) )
                return(FALSE) ;  // A fatal error.
    #endif
            patt[atrFound].eOffsetMeans = VALUE_AT_HEAP ;
            if(pdwOut)
                *pdwOut = INVALID_INDEX ;
            return(TRUE) ;
        }

        if(pdwOut)
            *pdwOut = patt[atrFound].dwOffset ;
        patt[atrFound].dwOffset = *pdwIn ;
    }
    else
    {
        if(!BfindMatchingNode(*patr, &atrFound, dwFeature + dwFeaOffset , dwOption, pglobl))
        {
            if(pdwOut)
                *pdwOut = INVALID_INDEX ;
            return(TRUE) ;
        }
        if(pdwOut)
            *pdwOut = patt[atrFound].dwOffset ;
    }
    return(TRUE) ;
}


BOOL    BparseInvalidCombination(
PABSARRAYREF  paarValue,
DWORD         dwFieldOff,
PGLOBL        pglobl)

/*   called by BProcessSpecialKeyword
    when parsing  *InvalidCombination
    (basically is a Non-relocatable Global.)
    After parsing paarValue into a List of qualified names,
    we convert the List into list of INVALIDCOMBO structures
    and prepend this list to any previously existing
    lists of INVALIDCOMBO structures.
*/
{
    BOOL        bStatus, bPrevsExists  ;
    DWORD    dwListRoot,  //  holds temp list of qualified names
            dwNewInvCRoot , // start of new list of INVALIDCOMBO structures
        dwICNode, dwLNode, dwNumNodes ;
    PLISTNODE    plstBase ;  // start of LIST array
    PINVALIDCOMBO   pinvc ;  //  start of InvalidCombo array
    PQUALNAME  pqn ;   // the dword in the list node is actually a
                        // qualified name structure.


    pinvc = (PINVALIDCOMBO) gMasterTable[MTI_INVALIDCOMBO].pubStruct ;
    plstBase = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    bStatus = BparseList(paarValue, &dwListRoot,
                BparseQualifiedName, VALUE_QUALIFIED_NAME, pglobl) ;

    if(!bStatus)
        return(FALSE) ;

    //  if there are more than 2 objects in the list, process
    //  as an InvalidCombo, else store as UIConstraint.


    dwLNode = dwListRoot ;

    for(dwNumNodes = 1 ; plstBase[dwLNode].dwNextItem != END_OF_LIST ;
        dwNumNodes++)      //  locate end of list
    {
        dwLNode = plstBase[dwLNode].dwNextItem ;
    }

    if(dwNumNodes == 1)
    {
        ERR(("Must have at least 2 objects to define an InvalidCombination.\n"));
        return(FALSE) ;
    }
    if(dwNumNodes == 2)
    {
        DWORD       dwNewCnst, dwNextCnstrnt;
        PCONSTRAINTS     pcnstr ;  // start of CONSTRAINTS array.

        bStatus = BallocElementFromMasterTable(
            MTI_CONSTRAINTS, &dwNewCnst, pglobl) ;
        if(!bStatus)
            return(FALSE) ;
        dwLNode = dwListRoot ;
        pqn = (PQUALNAME)(&plstBase[dwLNode].dwData) ;
        pcnstr = (PCONSTRAINTS) gMasterTable[MTI_CONSTRAINTS].pubStruct ;

        //  prepend new constraint node to list

        BexchangeArbDataInFOATNode(pqn->wFeatureID, pqn->wOptionID,
                offsetof(DFEATURE_OPTIONS, atrConstraints),
                sizeof(DWORD), (PBYTE)&dwNextCnstrnt, (PBYTE)&dwNewCnst,
                &bPrevsExists, FALSE, pglobl) ;

        if(bPrevsExists)
            pcnstr[dwNewCnst].dwNextCnstrnt = dwNextCnstrnt ;
        else
            pcnstr[dwNewCnst].dwNextCnstrnt = END_OF_LIST ;

        // copy contents of 2nd list node into first constraint node.
        dwLNode = plstBase[dwLNode].dwNextItem ;
        pqn = (PQUALNAME)(&plstBase[dwLNode].dwData) ;

        pcnstr[dwNewCnst].dwFeature = pqn->wFeatureID ;
        pcnstr[dwNewCnst].dwOption = pqn->wOptionID ;

        return(TRUE) ;
    }


    //  create list of InvalidCombos

    if(bStatus)
        bStatus =
            BallocElementFromMasterTable(MTI_INVALIDCOMBO, &dwNewInvCRoot, pglobl) ;

    dwLNode = dwListRoot ;  //  reset
    dwICNode = dwNewInvCRoot ;

    while(bStatus)
    {
        DWORD   dwPrevsNode ;

        pqn = (PQUALNAME)(&plstBase[dwLNode].dwData) ;

        if(pqn->wOptionID == (WORD)INVALID_SYMBOLID)  // treat partially qualified
            pqn->wOptionID = (WORD)DEFAULT_INIT ;   // name as default initializer

        pinvc[dwICNode].dwFeature = pqn->wFeatureID ;
        pinvc[dwICNode].dwOption = pqn->wOptionID ;

        BexchangeDataInFOATNode(pqn->wFeatureID, pqn->wOptionID,
            dwFieldOff, &dwPrevsNode, &dwNewInvCRoot, FALSE, pglobl) ;

        if(dwPrevsNode == INVALID_INDEX)
            pinvc[dwICNode].dwNewCombo = END_OF_LIST ;
        else
            pinvc[dwICNode].dwNewCombo = dwPrevsNode ;

        if(plstBase[dwLNode].dwNextItem == END_OF_LIST)
            break ;
        dwLNode = plstBase[dwLNode].dwNextItem ;
        bStatus = BallocElementFromMasterTable(MTI_INVALIDCOMBO,
                &pinvc[dwICNode].dwNextElement, pglobl) ;
        dwICNode = pinvc[dwICNode].dwNextElement ;
    }

    if(!bStatus)
        return(FALSE) ;

    pinvc[dwICNode].dwNextElement = END_OF_LIST ;

    return(bStatus) ;
}



BOOL    BparseInvalidInstallableCombination1(
PABSARRAYREF paarValue,
DWORD        dwFieldOff,
PGLOBL       pglobl)
/*   called by BProcessSpecialKeyword
    when parsing  *InvalidInstallableCombination
    (basically is a Non-relocatable Global.)
    After parsing paarValue into a List of qualified names,
    we convert the List into list of INVALIDCOMBO structures
    and prepend this list to any previously existing
    lists of INVALIDCOMBO structures.  The first node of each
    InvalidCombo list points to another new InvalidCombo list.
    The first InvalidCombo is stored in the Global atrInvldInstallCombo.
*/
{
    BOOL        bStatus, bPrevsExists  ;
    DWORD    dwListRoot,  //  holds temp list of qualified names
            dwNewInvCRoot , // start of new list of INVALIDCOMBO structures
        dwICNode, dwLNode, dwNumNodes ;
    PLISTNODE    plstBase ;  // start of LIST array
    PINVALIDCOMBO   pinvc ;  //  start of InvalidCombo array
    PQUALNAME  pqn ;   // the dword in the list node is actually a
                        // qualified name structure.
    PGLOBALATTRIB   pga ;
    PATREEREF        patr ;


    pga =  (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].pubStruct ;
    pinvc = (PINVALIDCOMBO) gMasterTable[MTI_INVALIDCOMBO].pubStruct ;
    plstBase = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    bStatus = BparseList(paarValue, &dwListRoot,
                BparsePartiallyQualifiedName, VALUE_QUALIFIED_NAME, pglobl) ;

    if(!bStatus)
        return(FALSE) ;

    // cannot convert to UIConstraint bacause the synthesized
    //  Feature does not yet exist.

    dwLNode = dwListRoot ;

    for(dwNumNodes = 1 ; plstBase[dwLNode].dwNextItem != END_OF_LIST ;
        dwNumNodes++)      //  locate end of list
    {
        dwLNode = plstBase[dwLNode].dwNextItem ;
    }

    if(dwNumNodes == 1)
    {
        ERR(("Must have at least 2 objects to define an InvalidInstallableCombination.\n"));
        return(FALSE) ;
    }

    //  create list of InvalidCombos

    if(bStatus)
        bStatus =
            BallocElementFromMasterTable(MTI_INVALIDCOMBO, &dwNewInvCRoot, pglobl) ;

    dwLNode = dwListRoot ;  //  reset
    dwICNode = dwNewInvCRoot ;

    //  link to atrInvldInstallCombo
    patr = (PATREEREF)((PBYTE)pga + dwFieldOff) ;

    if(*patr == ATTRIB_UNINITIALIZED)
        pinvc[dwICNode].dwNewCombo = END_OF_LIST ;
    else  //  interpret *patr as index to INVC node.
        pinvc[dwICNode].dwNewCombo = *patr ;

    *patr = dwICNode;

    while(bStatus)
    {
        DWORD   dwPrevsNode ;  // create next element links only

        pqn = (PQUALNAME)(&plstBase[dwLNode].dwData) ;

        if(pqn->wOptionID == (WORD)INVALID_SYMBOLID)  // treat partially qualified
            pqn->wOptionID = (WORD)DEFAULT_INIT ;   // name as default initializer
                                                    //  this lets us know this feature
                                                    //  is installable.

        pinvc[dwICNode].dwFeature = pqn->wFeatureID ;
        pinvc[dwICNode].dwOption = pqn->wOptionID ;

        if(plstBase[dwLNode].dwNextItem == END_OF_LIST)
            break ;
        dwLNode = plstBase[dwLNode].dwNextItem ;
        bStatus = BallocElementFromMasterTable(MTI_INVALIDCOMBO,
                &pinvc[dwICNode].dwNextElement, pglobl) ;
        dwICNode = pinvc[dwICNode].dwNextElement ;
    }

    if(!bStatus)
        return(FALSE) ;

    pinvc[dwICNode].dwNextElement = END_OF_LIST ;

    return(bStatus) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\command.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  command.c - processing command keywords.   */



#include    "gpdparse.h"


// ----  functions defined in  command.c ---- //

BOOL    BprocessParam(
IN      PABSARRAYREF paarValue,
IN      PARRAYREF    parStrValue,
IN  OUT PGLOBL       pglobl) ;

BOOL    BparseCommandString(
IN      PABSARRAYREF   paarValue,
IN      PARRAYREF      parStrValue,
IN  OUT PGLOBL         pglobl ) ;

BOOL    BconstructRPNtokenStream(
IN  OUT PABSARRAYREF  paarValue,
    OUT PARRAYREF     parRPNtokenStream,
IN  OUT PGLOBL        pglobl) ;

VOID    VinitOperPrecedence(
IN  OUT PGLOBL        pglobl) ;

BOOL    BparseArithmeticToken(
IN  OUT PABSARRAYREF  paarValue,
OUT PTOKENSTREAM      ptstr,
    PGLOBL            pglobl
) ;

BOOL    BparseDigits(
IN  OUT PABSARRAYREF   paarValue,
OUT PTOKENSTREAM  ptstr ) ;

BOOL    BparseParamKeyword(
IN  OUT PABSARRAYREF  paarValue,
OUT PTOKENSTREAM      ptstr,
    PGLOBL            pglobl ) ;

BOOL  BcmpAARtoStr(
PABSARRAYREF    paarStr1,
PBYTE       str2) ;

BOOL        bDivByZeroCheck(PTOKENSTREAM  ptstr) ;



// ---------------------------------------------------- //




BOOL    BprocessParam(
IN      PABSARRAYREF   paarValue,
IN      PARRAYREF      parStrValue,
IN  OUT PGLOBL         pglobl)
/*  notice this function will append the substring
"%dddd" (without the double quotes) onto the existing
parStrValue.   To allow the control module to unambiguously
parse out this substring, The GPD spec requires any occurance
of the character '%' within an Invocation String must be
preceeded by another '%'.  So the control module will find two
outcomes when encountering a % char in an invocation string:
it is followed by another % char  in which case only one % should
be emitted.  It is followed by exactly 4 decimal digits.  This
specifies the parameter index and specifies the parameter should be
emitted at this point instead of the "%dddd".  Additional digits
are part of the invocation string and should be emitted.
*/
{
    PSTR   pstrDelimiters = "dDcClmqgnvf" ;
    PPARAMETER  pparamRoot, pparam ;
    DWORD  dwParamIndex, dwDelIndex ;
    ABSARRAYREF    aarToken ;

    if(! BeatDelimiter(paarValue, "%"))
        return(FALSE) ;  // BUG_BUG  paranoid, inconsistency error.
    if(!BdelimitToken(paarValue, pstrDelimiters, &aarToken, &dwDelIndex) )
    {
        ERR(("Command parameter: Missing format character.\n")) ;

        return(FALSE) ;
    }
    pparamRoot = (PPARAMETER) gMasterTable[MTI_PARAMETER].pubStruct ;

    if(!BallocElementFromMasterTable(MTI_PARAMETER, &dwParamIndex, pglobl) )
        return(FALSE) ;  // try again with more resources.

    pparam = pparamRoot + dwParamIndex ;

    pparam->dwFlags = 0 ;
    pparam->dwFormat = (DWORD)(BYTE)pstrDelimiters[dwDelIndex] ;

    (VOID) BeatLeadingWhiteSpaces(&aarToken) ;

    if(aarToken.dw)
    {
        if(pstrDelimiters[dwDelIndex] == 'd' || pstrDelimiters[dwDelIndex] == 'D')
        {
            if(!BparseInteger(&aarToken, &pparam->dwDigits, VALUE_INTEGER, pglobl) )
            {
                ERR(("Command parameter: Syntax error in format width field.\n"));
                return(FALSE) ;
            }
            if(pparam->dwDigits != WILDCARD_VALUE)
                pparam->dwFlags |= PARAM_FLAG_FIELDWIDTH_USED ;
        }
        else
        {
            ERR(("Command parameter: Unexpected chars found preceeding format specifier: '%0.*s'.\n",
                aarToken.dw, aarToken.pub));
            return(FALSE) ;
        }
    }
    //  its ok to omit the fieldwidth specification
    //  now look for optional 'Limits' construct

    pstrDelimiters = "[{" ;
    if(!BdelimitToken(paarValue, pstrDelimiters, &aarToken, &dwDelIndex) )
    {
        ERR(("Command parameter: missing '{' in Value construct.\n"));

        return(FALSE) ;
    }
    (VOID) BeatLeadingWhiteSpaces(&aarToken) ;

    if(aarToken.dw)
    {
        ERR(("Command parameter: unexpected chars found preceeding Limits or Value construct: '%0.*s'.\n",
                aarToken.dw, aarToken.pub));
        return(FALSE) ;
    }
    if(pstrDelimiters[dwDelIndex] == '[')
    {
        if(!BdelimitToken(paarValue, ",", &aarToken, &dwDelIndex) )
        {
            ERR(("Command parameter: missing comma delimiter in Limits construct.\n"));

            return(FALSE) ;
        }
        if(!BparseInteger(&aarToken, &pparam->lMin, VALUE_INTEGER, pglobl) )
        {
            ERR(("Command parameter: syntax error in Min Limit field.\n"));
            return(FALSE) ;
        }
        if(pparam->lMin != WILDCARD_VALUE)
            pparam->dwFlags |= PARAM_FLAG_MIN_USED ;

        if(!BdelimitToken(paarValue, "]", &aarToken, &dwDelIndex) )
        {
            ERR(("Command parameter: missing closing bracket in Limits construct.\n"));

            return(FALSE) ;
        }
        if(!BparseInteger(&aarToken, &pparam->lMax, VALUE_INTEGER, pglobl) )
        {
            ERR(("Command parameter: syntax error in Max Limit field.\n"));
            return(FALSE) ;
        }
        if(pparam->lMax != WILDCARD_VALUE)
            pparam->dwFlags |= PARAM_FLAG_MAX_USED ;

        if(! BeatDelimiter(paarValue, "{"))
        {
            ERR(("Command parameter: missing required '{' in Value construct.\n"));

            return(FALSE) ;
        }
    }
    //  now back to parsing Value construct.

    if(!BconstructRPNtokenStream(paarValue, &pparam->arTokens, pglobl) )
        return(FALSE) ;


    //  convert dwParamIndex  to 4 digit ascii string of
    //  the form  "%dddd"
    {
        BYTE  aub[6] ;  // temp array of unsigned bytes
        DWORD  dwI, dwNdigits = 4 ;  // 4 is number of digits in string
        ARRAYREF      arTmpDest ;  // write result here first.

        // the most significant digit has the smaller byte address!

        aub[0] = '%' ;
        aub[dwNdigits + 1] = '\0' ;  // null terminate, but not needed.

        for(dwI = dwNdigits ; dwI ; dwI--)
        {
            aub[dwI] = (BYTE)('0' + dwParamIndex % 10) ;
            dwParamIndex /= 10 ;
        }

        //  write "%dddd" out to heap.  note if parStrValue->dwCount
        //  is zero, we must initialize parStrValue from
        //  scratch instead of appending.  Must use an Alignment of 1
        //  to avoid creating gaps in the command string.

        if(!BwriteToHeap(&arTmpDest.loOffset, aub, dwNdigits + 1, 1, pglobl))
            return(FALSE) ;
        //  append this run to existing string
        if(!parStrValue->dwCount)  // no prevs string exists
        {
            parStrValue->loOffset = arTmpDest.loOffset ;
        }
        else
        {
            // BUG_BUG paranoid:  may check that string is contiguous
            // parStrValue->loOffset + parStrValue->dwCount
            // should equal arTmpDest.loOffset
            ASSERT(parStrValue->loOffset + parStrValue->dwCount == arTmpDest.loOffset) ;
        }
        parStrValue->dwCount += dwNdigits + 1 ;
    }
    return(TRUE) ;
}



BOOL    BparseCommandString(
IN     PABSARRAYREF   paarValue,
IN     PARRAYREF      parStrValue,
IN OUT PGLOBL         pglobl
)
{
    ABSARRAYREF     aarToken ;  // points to individual string segment.
    DWORD       dwDelIndex, dwNumParams = 0 ;    //  dummy

    parStrValue->dwCount = 0 ;  // tells functions to create new string
        //  in heap.  Don't append to existing string.

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    while(paarValue->dw)
    {
        if(paarValue->pub[0] == '%')
        {
            if(++dwNumParams > 14)
            {
                ERR(("CmdInvocation: Unidrv imposes a max limit of 14 parameters per command.\n"));
                return(FALSE) ;  // Black Death.
            }
            if(!BprocessParam(paarValue, parStrValue, pglobl) )
            //  deposits a little turd on the stringheap,
            //  modifies parStrValue accordingly and
            //  initializes one parameter array element.
            {
                return(FALSE) ;  // Black Death.
            }
        }
        else if(paarValue->pub[0] == '"')
        {
            paarValue->pub++ ;
            paarValue->dw-- ;  // skip the initial quote.
            if(!BdelimitToken(paarValue, "\"", &aarToken, &dwDelIndex) )
            {
                ERR(("CmdInvocation: missing terminating '\"'  in command string.\n"));

                return(FALSE) ;
            }
            if(!BparseStrSegment(&aarToken, parStrValue, pglobl))
            {
                return(FALSE) ;
            }
        }
        else
        {
            ERR(("CmdInvocation: command string segment must begin with '\"' or '%'.\n"));
            return(FALSE) ;
        }
        (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    }

    //  We don't want null terminations to occur between parameter
    //  portion of a string.  We just want to blindly add the NULL
    //  when parsing is really finished.

    {
        DWORD     dwDummy ;  // don't care about result

        if(!BwriteToHeap(&dwDummy, "\0", 1, 1, pglobl) )  //  add Null termination
            return(FALSE) ;
    }
    return(TRUE) ;
}

BOOL    BconstructRPNtokenStream(
IN  OUT PABSARRAYREF   paarValue,
    OUT PARRAYREF      parRPNtokenStream,
IN  OUT PGLOBL         pglobl)
/*   the input stream is parsed into tokens,
    each token is assigned an operator value  see OPERATOR
    enum.
    The Control module interprets the tokenstream just as
    Reverse Polish Notation.
    In the Control Module, each token is processed as follows:
    OP_INTEGER:  take dwValue and copy to stack
    OP_VARI_INDEX: dwValue is an index identifying the
        Unidrv Standard Variable whose current value
        should be placed on the stack.
    OP_MIN :
    OP_MAX :
        pop the top 2 values from the stack and push the
        smaller or larger value back onto the stack.
    OP_ADD :
    OP_SUB :
    OP_MULT :
    OP_DIV :
    OP_MOD :
        pop the top 2 values from the stack perform the
        indicated arithmetic operation, and push the
        result back onto the stack.  The topmost value in the stack
        should be used as the 2nd operand in the operation.
    OP_NEG :  pop the top value from the stack and push its
        negative back on the stack.
    OP_MAX_REPEAT :  this should always be the last command
        executed.  It means take the top value on the stack and
        if it exceeds the MaxValue specified in lMax, emit the
        command invocation multiple times with this parameter no
        larger than lMax so that the sum equals the value on
        the stack.
    OP_HALT:  If the value on the stack has not yet been emitted
        due to processing the OP_MAX_REPEAT operator,
        emit this value or the closest of lMin or lMax if specified.
        processing for this parameter is now complete.


    In the parser, each token is processed as follows:

    OP_INTEGER, OP_VARI_INDEX:  these values are
    placed directly into the RPNtokenStream in the order
    they were encountered.  They cause the valueToken count to
    be incremented.

    Then 2nd group of tokens from OP_MIN to OP_HALT
    are first placed into an operator queue (or is it a stack?)
    They are inserted into the queue in the order in which
    they are encountered, and when they leave the queue, they
    are inserted into the RPNtokenStream.  There are the rules
    governing when an operator token may leave the queue:

    a) each token is assigned a precedence level.
        here they are arranged from highest to lowest.
        OP_NEG    a unary operator
        OP_MULT, OP_DIV, OP_MOD  have the same level
        OP_ADD, OP_SUB  have the same level
        OP_MIN, OP_MAX, OP_MAX_REPEAT have the same level
            but are always preceeded by an OP_OPENPAR token.
        OP_HALT   has the lowest level.  (it is generated when
        the closing } is encountered.)
        OP_CLOSEPAR and OP_OPENPAR have even lower
        precedences for firewall purposes.

    b) no token may leave the queue unless a token with equal
        or lower precedence has just arrived.  At that point
        the token immediately adjacent to the new arrival
        leaves.  If the next token is also of higher or equal
        precedence than the new arrival, it too leaves.
        The tokens depart until this condition is false.

    c) the OP_HALT token is not only able to allow all other
        tokens to leave the queue, but after that, it too
        leaves the queue and enters the tokenStream.

    d)  the OP_OPENPAR and OP_CLOSEPAR  tokens are different.
        They will never be inserted into the RPNtokenStream, but
        only serve to modify the departure rules governing the
        queue.

    e)  OP_OPENPAR  acts to freeze all operators
        already in the queue.  Those operators cannot
        exit the queue until the OP_OPENPAR has been removed
        from the queue.   All subsequent operators entering
        the queue are unaffected by OP_OPENPAR already residing
        within the queue.

    f)  the OP_CLOSEPAR acts to flush all operators in the
        queue up to the first encountered OP_OPENPAR.
        Upon meeting its counterpart, both vanish from the
        queue never to be seen again.

    The max_repeat operator if used, must be first token parsed.
    Obviously it can appear only once in an expression.

    Token counting , unary operator detection and syntax
    error detection:

    for every binary operator parsed the operator count is
    incremented.  Immediately after incrementing, the operator count
    should always be equal to the valueToken count.  An excess in
    the operator count of one may indicate the operator is
    a unary operator.  Any deficit or excess greater than 2 indicates
    a syntax error.  Immediately after incrementing, the valueToken
    count should always be one greater than the operator count.

    For the purposes of the operator count, the following tokens
    qualify:
        OP_ADD, OP_SUB, OP_MULT,
        OP_DIV, OP_MOD, OP_COMMA

    Note:  for function operators the function name and opening
    parenthesis is parsed as one object.

*/

{
    TOKENSTREAM     tstrNode ;
    BOOL    bStatus ;

    DWORD  dwValueToken = 0 ,  //  number of value tokens parsed.
           dwOperatorToken = 0 ,  // number of binary operators parsed.
           dwQueuePtr = 0 , //  current position in the tmp operator queue.
           dwCurToken,      // index of curToken.
           dwQueueSize ;   //  num elements in array
    PDWORD  pdwQueueRoot ;  // Points to root of queue.
    PTOKENSTREAM  ptstr, ptstrRoot ;


    pdwQueueRoot = (PDWORD) gMasterTable[MTI_OP_QUEUE].pubStruct ;
    dwQueueSize = gMasterTable[MTI_OP_QUEUE].dwArraySize ;
    ptstrRoot = (PTOKENSTREAM) gMasterTable[MTI_TOKENSTREAM].pubStruct ;

    parRPNtokenStream->loOffset = gMasterTable[MTI_TOKENSTREAM].dwCurIndex ;
    parRPNtokenStream->dwCount = 0 ;

    while(bStatus = BparseArithmeticToken(paarValue, &tstrNode, pglobl))
    {
        switch(tstrNode.eType)
        {
            case OP_INTEGER :
            case OP_VARI_INDEX :
            {
                if(dwOperatorToken != dwValueToken)
                {
                    ERR(("Command parameter: arithmetic syntax error in value construct.\n"));

                    bStatus = FALSE ;
                }
                dwValueToken++ ;
                break ;
            }
            case OP_ADD :
            case OP_SUB :
            case OP_MULT :
            case OP_DIV :
            case OP_MOD :
            case OP_COMMA :
            {
                dwOperatorToken++ ;
                if(dwOperatorToken == dwValueToken)
                    break ;
                else if(dwOperatorToken == dwValueToken + 1)
                {
                    // maybe interpret operator as Unary.
                    if(tstrNode.eType == OP_SUB)
                    {
                        tstrNode.eType = OP_NEG ;
                        dwOperatorToken-- ;
                        break ;
                    }
                    else if(tstrNode.eType == OP_ADD)
                    {
                        tstrNode.eType = OP_NULL ;
                        dwOperatorToken-- ;
                        break ;
                    }
                }
                ERR(("Command parameter: arithmetic syntax error in value construct.\n"));

                bStatus = FALSE ;
                break ;
            }
            case OP_MIN :
            case OP_MAX :
            case OP_OPENPAR :
            {
                if(dwValueToken != dwOperatorToken)
                {
                    ERR(("Command parameter: arithmetic syntax error in value construct.\n"));

                    bStatus = FALSE ;
                }
                break ;
            }
            case OP_CLOSEPAR :
            case OP_HALT :
            {
                if(dwValueToken != dwOperatorToken + 1)
                {
                    ERR(("Command parameter: arithmetic syntax error in value construct.\n"));

                    bStatus = FALSE ;
                }
                break ;
            }
            case OP_MAX_REPEAT :
            {
                if(dwValueToken || dwOperatorToken  ||  dwQueuePtr)
                {
                    ERR(("Command parameter: syntax error in value construct.\n"));
                    ERR(("  OP_MAX_REPEAT must appear as the outermost operator only.\n"));

                    bStatus = FALSE ;
                }
                break ;
            }
            default:
            {
                break ;
            }
        }
        if(!bStatus )
            break ;
        switch(tstrNode.eType)
        {
            case OP_INTEGER :
            case OP_VARI_INDEX :
            {
                bStatus = BallocElementFromMasterTable(
                            MTI_TOKENSTREAM, &dwCurToken, pglobl) ;
                if(!bStatus )
                    break ;
                parRPNtokenStream->dwCount++ ;
                ptstr = ptstrRoot + dwCurToken ;
                ptstr->eType = tstrNode.eType ;
                ptstr->dwValue = tstrNode.dwValue ;
                break ;
            }
            case OP_ADD :
            case OP_SUB :
            case OP_MULT :
            case OP_DIV :
            case OP_MOD :
            case OP_NEG :
            {
                while (dwQueuePtr  &&
                    (gdwOperPrecedence[tstrNode.eType] <=
                    gdwOperPrecedence[*(pdwQueueRoot + dwQueuePtr - 1)]) )
                {
                    bStatus = BallocElementFromMasterTable(
                                MTI_TOKENSTREAM, &dwCurToken, pglobl) ;
                    if(!bStatus )
                        break ;
                    parRPNtokenStream->dwCount++ ;
                    ptstr = ptstrRoot + dwCurToken ;
                    ptstr->eType = *(pdwQueueRoot + dwQueuePtr - 1) ;
                    ptstr->dwValue = 0 ;  // undefined
                    dwQueuePtr-- ;  // pop off the Queue.
                    bDivByZeroCheck(ptstr);
                }
                if(dwQueuePtr >= dwQueueSize)
                    bStatus = FALSE ;   //  Queue overflow
                if(!bStatus )
                    break ;

                //add current Oper to Queue
                *(pdwQueueRoot + dwQueuePtr) = tstrNode.eType ;
                dwQueuePtr++ ;
                break ;
            }
            case OP_MIN :
            case OP_MAX :
            case OP_MAX_REPEAT :
            case OP_OPENPAR :
            {
                if(dwQueuePtr + 1 >= dwQueueSize)  // room for two?
                    bStatus = FALSE ;   //  Queue overflow
                if(!bStatus )
                    break ;

                //add OP_OPENPAR to Queue
                *(pdwQueueRoot + dwQueuePtr) = OP_OPENPAR ;
                dwQueuePtr++ ;
                //add current Oper to Queue
                if(tstrNode.eType != OP_OPENPAR)
                {
                    *(pdwQueueRoot + dwQueuePtr) = tstrNode.eType ;
                    dwQueuePtr++ ;
                }
                break ;
            }
            case OP_CLOSEPAR :
            case OP_COMMA :
            case OP_HALT :
            {
                while (dwQueuePtr  &&
                    (gdwOperPrecedence[tstrNode.eType] <=
                    gdwOperPrecedence[*(pdwQueueRoot + dwQueuePtr - 1)]) )
                {
                    bStatus = BallocElementFromMasterTable(
                                MTI_TOKENSTREAM, &dwCurToken, pglobl) ;
                    if(!bStatus )
                        break ;
                    parRPNtokenStream->dwCount++ ;
                    ptstr = ptstrRoot + dwCurToken ;
                    ptstr->eType = *(pdwQueueRoot + dwQueuePtr - 1) ;
                    ptstr->dwValue = 0 ;  // undefined
                    dwQueuePtr-- ;  // pop off the Queue.
                    bDivByZeroCheck(ptstr);
                }
                if(!bStatus )
                    break ;
                if(tstrNode.eType == OP_COMMA)
                {
                    //  comma clears all operators in queue up to the
                    //  function.  This completes processing of the
                    //  first argument.  The comma effectively converts
                    //  the syntax   funct(A + B, C * D)  into
                    //  ((A + B) funct (C * D))

                    //  check to see if function operator is now at
                    //  top of queue.
                    if(dwQueuePtr)
                    {
                        OPERATOR   eType ;

                        eType = *(pdwQueueRoot + dwQueuePtr - 1) ;
                        if(eType == OP_MIN  ||  eType == OP_MAX)
                            break ;
                    }
                    ERR(("Command parameter: syntax error in value construct.\n"));
                    ERR(("  comma used outside of function argument list.\n"));
                    bStatus = FALSE ;
                }
                else  if(tstrNode.eType == OP_HALT)
                {
                    if(dwQueuePtr)
                    {
                        ERR(("Command parameter: syntax error in value construct - unmatched  OP_OPENPAR.\n"));
                        bStatus = FALSE ;
                        break ;
                    }
                    //  now add halt operator to tokenStream
                    bStatus = BallocElementFromMasterTable(
                                MTI_TOKENSTREAM, &dwCurToken, pglobl) ;
                    if(!bStatus )
                        break ;
                    parRPNtokenStream->dwCount++ ;
                    ptstr = ptstrRoot + dwCurToken ;
                    ptstr->eType = OP_HALT ;
                    ptstr->dwValue = 0 ;  // undefined
                }
                else if(dwQueuePtr  &&
                    (*(pdwQueueRoot + dwQueuePtr - 1) == OP_OPENPAR))
                {
                    dwQueuePtr-- ;  // pop OP_OPENPAR off the Queue.
                    //  conjugate pairs meet and annihilate
                }
                else
                {
                    ERR(("Command parameter: syntax error in value construct - unmatched  OP_CLOSEPAR.\n"));
                    bStatus = FALSE ;
                }
                break ;
            }

            default:
                break ;
        }
        if(!bStatus  ||  tstrNode.eType == OP_HALT)
            break ;
    }
    if(!bStatus )
    {
        parRPNtokenStream->dwCount = 0 ;
        parRPNtokenStream->loOffset = 0 ;
    }
    return(bStatus);
}


VOID    VinitOperPrecedence(
    IN OUT PGLOBL pglobl)
{
    DWORD   dwP ;  // precedence level ;

    dwP = 0 ;  // lowest level.  fire wall.
    gdwOperPrecedence[OP_OPENPAR] = dwP ;

    dwP++ ;
    gdwOperPrecedence[OP_CLOSEPAR] = dwP ;

    dwP++ ;
    gdwOperPrecedence[OP_HALT] = dwP ;

    dwP++ ;
    gdwOperPrecedence[OP_MIN] = gdwOperPrecedence[OP_MAX] =
        gdwOperPrecedence[OP_MAX_REPEAT] = dwP ;

    dwP++ ; //  comma must be next to function operators
    gdwOperPrecedence[OP_COMMA] = dwP ;   // in precedence level.

    dwP++ ;
    gdwOperPrecedence[OP_ADD] = gdwOperPrecedence[OP_SUB] = dwP ;

    dwP++ ;
    gdwOperPrecedence[OP_MULT] = gdwOperPrecedence[OP_DIV] =
        gdwOperPrecedence[OP_MOD] = dwP ;

    dwP++ ;
    gdwOperPrecedence[OP_NEG] = dwP ;
}

BOOL    BparseArithmeticToken(
IN  OUT PABSARRAYREF  paarValue,
OUT PTOKENSTREAM      ptstr,
    PGLOBL            pglobl
)
/*  objects to parse:
    OP_INTEGER : string of digits delimited by non-Keyword char
    OP_MIN :  "min" and adjacent '('
    OP_MAX :  "max" and adjacent '('
    OP_MAX_REPEAT :   "max_repeat"  and adjacent '('
    OP_MOD :  "MOD"
    OP_VARI_INDEX : string of Keyword chars deliniated by non Keyword
        chars, not starting with a digit.  and not one of the recognized
        operator keywords.
    Note all of the above string objects must be delinated by
        non-Keyword chars.
    OP_ADD :  '+'
    OP_SUB :  '-'
    OP_MULT : '*'
    OP_DIV :  '/'
    OP_HALT : '}'
    OP_OPENPAR :  '('
    OP_CLOSEPAR : ')'
    OP_COMMA :    ','
*/
{
    BYTE    ubSrc ;
    BOOL    bStatus ;

    if(!paarValue->dw)
        return(FALSE);  // nothing left!

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    switch(ubSrc = *paarValue->pub)
    {
        case '+':
        {
            ptstr->eType = OP_ADD ;
            break ;
        }
        case '-':
        {
            ptstr->eType = OP_SUB ;
            break ;
        }
        case '*':
        {
            ptstr->eType = OP_MULT ;
            break ;
        }
        case '/':
        {
            ptstr->eType = OP_DIV ;
            break ;
        }
        case '}':
        {
            ptstr->eType = OP_HALT ;
            break ;
        }
        case '(':
        {
            ptstr->eType = OP_OPENPAR ;
            break ;
        }
        case ')':
        {
            ptstr->eType = OP_CLOSEPAR ;
            break ;
        }
        case ',':
        {
            ptstr->eType = OP_COMMA ;
            break ;
        }
        default:
        {
            bStatus = FALSE ;  // till proven otherwise.

            if(ubSrc  >= '0' &&  ubSrc <= '9')
            {
                bStatus = BparseDigits(paarValue, ptstr) ;
            }
            else if( (ubSrc  >= 'a' &&  ubSrc <= 'z')  ||
                    (ubSrc  >= 'A' &&  ubSrc <= 'Z')  ||
                    ubSrc == '_'  ||  ubSrc == '?')
            {
                bStatus = BparseParamKeyword(paarValue, ptstr, pglobl) ;
            }

            return(bStatus);
        }
    }
    paarValue->pub++ ;
    paarValue->dw-- ;
    return(TRUE);
}



#define    pubM  (paarValue->pub)
#define    dwM   (paarValue->dw)

BOOL    BparseDigits(
IN  OUT PABSARRAYREF   paarValue,
OUT PTOKENSTREAM  ptstr )
/*  paarValue left pointing after last digit  upon exit.
    there may in fact be nothing left in paarValue  */
{
    DWORD   dwNumber  = 0 ;
    BOOL    bStatus = FALSE ;


    if(*pubM == '0')  //  leading zero indicates hexadecimal format
    {
        pubM++ ;
        dwM-- ;

        if(dwM  &&  (*pubM == 'x'  ||  *pubM == 'X'))
        {
            pubM++ ;
            dwM-- ;
        }
        else
        {
            bStatus = TRUE ;
            goto  EndNumber ;     // ignore leading zero and attempt to parse more digits.
        }
        if(!dwM)
        {
            ERR(("Command Param-BparseDigits: no digits found in Hex value.\n"));
            return(FALSE);
        }
        for(  ; dwM  ;  pubM++, dwM-- )
        {
            if(*pubM >= '0'  &&  *pubM <= '9')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - '0') ;
            }
            else if(*pubM >= 'a'  &&  *pubM <= 'f')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - 'a' + 0x0a) ;
            }
            else if(*pubM >= 'A'  &&  *pubM <= 'F')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - 'A' + 0x0a) ;
            }
            else
                break;

            bStatus = TRUE ;
        }
    }

EndNumber:

    for(  ; dwM  &&  *pubM >= '0'  &&  *pubM <= '9' ;  )
    {
        dwNumber *= 10 ;
        dwNumber += (*pubM - '0') ;
        pubM++ ;
        dwM-- ;
        bStatus = TRUE ;
    }
    if( dwM  &&  ((*pubM  >= 'a' &&  *pubM <= 'z')  ||
        (*pubM  >= 'A' &&  *pubM <= 'Z')  ||
        *pubM == '_'  ||  *pubM == '?'))
    {
        ERR(("Command parameter: syntax error in value construct.\n"));
        ERR(("  integer not clearly delimited using non Keyword characters.\n"));
        return(FALSE);
    }

    ptstr->eType = OP_INTEGER ;
    ptstr->dwValue = dwNumber ;
    return(bStatus);
}


BOOL    BparseParamKeyword(
IN  OUT PABSARRAYREF   paarValue,
OUT PTOKENSTREAM  ptstr,
    PGLOBL        pglobl )
/*  if the keyword happens to be a function operator,
    find and eat the opening '('.  If keyword is
    a Standard Variable, determine its index value
    and store in dwValue.
*/
{
    BOOL    bStatus = FALSE ;
    ABSARRAYREF aarKey ;


    aarKey.pub = pubM ;  // start of Keyword

    for(aarKey.dw = 0 ; dwM   ;  aarKey.dw++)
    {
        if( (*pubM  >= 'a' &&  *pubM <= 'z')  ||
            (*pubM  >= 'A' &&  *pubM <= 'Z')  ||
            (*pubM  >= '0' &&  *pubM <= '9')  ||
            *pubM == '_'  ||  *pubM == '?' )
        {
            pubM++ ;
            dwM-- ;
            bStatus = TRUE ;
        }
        else
            break ;
    }
    //  now identify this Keyword
    if(!bStatus)
        return(bStatus);

    if(BcmpAARtoStr(&aarKey, "min"))
    {
        ptstr->eType = OP_MIN ;
        bStatus = BeatDelimiter(paarValue, "(") ;
        if(!bStatus)
        {
            ERR(("Command parameter: '(' must follow 'min' operator.\n"));
        }
    }
    else if(BcmpAARtoStr(&aarKey, "max"))
    {
        ptstr->eType = OP_MAX  ;
        bStatus = BeatDelimiter(paarValue, "(") ;
        if(!bStatus)
        {
            ERR(("Command parameter: '(' must follow 'max' operator.\n"));
        }
    }
    else if(BcmpAARtoStr(&aarKey, "max_repeat"))
    {
        ptstr->eType = OP_MAX_REPEAT ;
        bStatus = BeatDelimiter(paarValue, "(") ;
        if(!bStatus)
        {
            ERR(("Command parameter: '(' must follow 'max_repeat' operator.\n"));
        }
    }
    else if(BcmpAARtoStr(&aarKey, "MOD"))
    {
        ptstr->eType = OP_MOD ;
        //  don't eat any delimiters
    }
    else  // must therefore be the name of a StandardValue
    {
        ptstr->eType = OP_VARI_INDEX ;
        bStatus = BparseConstant(&aarKey, &ptstr->dwValue,
            VALUE_CONSTANT_STANDARD_VARS, pglobl) ;
    }

    return(bStatus);
}

#undef    pubM
#undef    dwM


BOOL  BcmpAARtoStr(
PABSARRAYREF    paarStr1,
PBYTE       str2)
//  Compares two strings, one referenced by 'aar' the other
//  referenced by 'pub or str'.  Returns TRUE if they match, FALSE
//  otherwise.
{
    DWORD   dwCnt ;

    dwCnt = strlen(str2) ;
    if(dwCnt != paarStr1->dw)
        return(FALSE) ;  // Lengths don't even match!
    if(strncmp(paarStr1->pub, str2, dwCnt))
        return(FALSE) ;
    return(TRUE) ;
}



BOOL        bDivByZeroCheck(PTOKENSTREAM  ptstr)
{
    //  assumes ptstr is not pointing to start of tokenstream
    //  else  (ptstr - 1) is undefined.
    //  this assumption is valid because the syntax checking in
    //  BconstructRPNtokenStream  counts
    //  dwValueToken  ,  //  number of value tokens parsed.
    //      and  dwOperatorToken  and ensures that  dwValueToken
    //  is non-zero when OP_DIV is parsed.

    if (ptstr->eType == OP_DIV  &&  (ptstr - 1)->eType == OP_INTEGER  &&
        (ptstr - 1)->dwValue == 0)
    {
        ERR(("Command parameter: Explicit divide by zero detected.\n"));
        return(FALSE) ;
    }
    return(TRUE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\oemdrv\tty\ui\ttyui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:   TTYUI.cpp
//
//
//  PURPOSE:  Main file for TTY UI user mode module.
//
//
//  Functions:
//
//
//
//
//  PLATFORMS:  Windows 95, Windows NT
//
//

#include <WINDOWS.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include <WINDDIUI.H>
#include <PRINTOEM.H>
#include <stdlib.h>
#include <TCHAR.H>
#include <WINSPOOL.H>

#include "resource.h"
#include "TTYUI.h"
#include "ttyuihlp.h"
#include "debug.h"



////////////////////////////////////////////////////////
//      INTERNAL GLOBALS
////////////////////////////////////////////////////////

HINSTANCE ghInstance = NULL;


////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

BOOL APIENTRY DevPropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
BOOL APIENTRY DevPropPage2Proc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
BOOL   HexStringToBinary(LPBYTE  lpHex, LPBYTE  lpBinary,
    DWORD  nHexLen,  //  num bytes in src buffer lpHex.
    DWORD  nBinaryLen,    //  num bytes in dest buffer lpBinary
    DWORD * lpnBinBytes);   //  num bytes written to dest buffer lpBinary
BOOL   BinaryToHexString(LPBYTE  lpBinary, LPBYTE  lpHex,
    DWORD  nBinaryLen,   //  num bytes to process in lpBinary
    DWORD  nHexLen);  //  num bytes in dest buffer lpHex.
void  VinitMyStuff(
    PGLOBALSTRUCT  pGlobals,   // points to private structure for static storage
    BOOL    bSave   // save to registry  instead of reading from...
    ) ;
void            vSetGetCodePage(HWND hDlg,
    INT  *piCodePage,
    BOOL    bMode) ;   // TRUE:  Set,  FALSE:  Get code page.

BOOL   PrintUIHelp(
    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam,
    PGLOBALSTRUCT  pGlobals
    ) ;
BOOL    InitHelpfileName(PGLOBALSTRUCT  pGlobals) ;
PWSTR  PwstrCreateQualifiedName(
    HANDLE  hHeap,
    PWSTR   pDir,
    PWSTR   pFile
    );





// Need to export these functions as c declarations.
extern "C" {



//////////////////////////////////////////////////////////////////////////
//  Function:   DllMain
//
//  Description:  Dll entry point for initialization..
//
//
//  Comments:
//
//
//  History:
//      1/27/97 APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
    switch(wReason)
    {
        case DLL_PROCESS_ATTACH:
            // VERBOSE(DLLTEXT("Process attach.\r\n"));

            // Save DLL instance for use later.
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            // VERBOSE(DLLTEXT("Thread attach.\r\n"));
            break;

        case DLL_PROCESS_DETACH:
            // VERBOSE(DLLTEXT("Process detach.\r\n"));
            break;

        case DLL_THREAD_DETACH:
            // VERBOSE(DLLTEXT("Thread detach.\r\n"));
            break;
    }

    return TRUE;
}


BOOL APIENTRY OEMGetInfo(IN DWORD dwInfo, OUT PVOID pBuffer, IN DWORD cbSize,
                         OUT PDWORD pcbNeeded)
{
    // VERBOSE(DLLTEXT("OEMGetInfo(%#x) entry.\r\n"), dwInfo);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo)
          &&
          (OEMGI_GETINTERFACEVERSION != dwInfo)
          &&
          (OEMGI_GETVERSION != dwInfo)
        )
        ||
        (NULL == pcbNeeded)
      )
    {
        WARNING(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
            *pcbNeeded = 0;

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer)
        ||
        (4 > cbSize)
      )
    {
        WARNING(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        // Return insufficient buffer size.
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
        case OEMGI_GETSIGNATURE:
            *(LPDWORD)pBuffer = OEM_SIGNATURE;
            break;

        case OEMGI_GETINTERFACEVERSION:
            *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
            break;

        case OEMGI_GETVERSION:
            *(LPDWORD)pBuffer = OEM_VERSION;
            break;
    }

    return TRUE;
}



LRESULT APIENTRY OEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LRESULT    lResult ;
    LONG   lRet;


    VERBOSE(DLLTEXT("OEMDevicePropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        VERBOSE(ERRORTEXT("OEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;


                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize = sizeof(PROPSHEETPAGE);
                Page.dwFlags = PSP_DEFAULT;
                Page.hInstance = ghInstance;
                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEV_PROPPAGE);
                Page.pfnDlgProc = (DLGPROC) DevPropPageProc;

                //  allocate structure to hold static data for
                //  PropertySheet Dialog function

                pPSUIInfo->UserData =
                Page.lParam = (LPARAM)HeapAlloc(
                    ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->hOEMHeap,
                    HEAP_ZERO_MEMORY , sizeof(GLOBALSTRUCT) );

                if(!Page.lParam)
                       return -1;   // HeapAlloc failed.

                ((PGLOBALSTRUCT)Page.lParam)->hPrinter =
                    ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->hPrinter ;

                ((PGLOBALSTRUCT)Page.lParam)->hOEMHeap =
                    ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->hOEMHeap ;


                // Add property sheets.
                lResult = (pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                        CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0) > 0 ? TRUE : FALSE);

                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEV_PROPPAGE2);
                Page.pfnDlgProc = (DLGPROC) DevPropPage2Proc;

                // Add another property sheet.
                if(lResult)
                {
                    lResult = (pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                            CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0) > 0 ? TRUE : FALSE);
                }
                lRet = (lResult) ? 1 : -1 ;
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
                lRet = (lResult) ? 1 : -1 ;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            lRet = (lResult) ? 1 : -1 ;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
                lRet =  1  ;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            if(pPSUIInfo->UserData)
                HeapFree(
                    ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->hOEMHeap,
                    0 , (void *)pPSUIInfo->UserData );
            lResult = TRUE;
            lRet = (lResult) ? 1 : -1 ;
            break;
        default:

            lRet =  -1  ;
    }

    pPSUIInfo->Result = lResult;
    return lRet;
}





} // End of extern "C"



//////////////////////////////////////////////////////////////////////////
//  Function:   DevPropPageProc
//
//  Description:  Generic property page procedure.
//
//
//
//
//  Comments:
//
//
//  History:
//      02/12/97    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL APIENTRY DevPropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    //  RECT  rcMargin ;   // temp storage during conversions.
    PGLOBALSTRUCT  pGlobals;   // points to private structure for static storage
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    TCHAR  szIntString[MAX_INT_FIELD_WIDTH + 2] ;
    BYTE   szString[MAX_CMD_LEN + 1] ;
    BOOL bStatus = FALSE;


    switch (uiMsg)
    {
        case WM_INITDIALOG:

            pGlobals = (PGLOBALSTRUCT) ((PROPSHEETPAGE *)lParam)->lParam ;
            pMyStuff = &pGlobals->regStruct ;
            //  at WM_INITDIALOG time, lParam points to   PROPSHEETPAGE.
            //  extract and save ptr to GLOBALSTRUCT for future ref.
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pGlobals) ;

            VinitMyStuff( pGlobals, FALSE) ;


            SendDlgItemMessage(hDlg, IDC_EDIT10, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT11, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT12, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT13, EM_LIMITTEXT, MAX_CMD_LEN, 0);

            SendDlgItemMessage(hDlg, IDC_EDIT14, EM_LIMITTEXT, MAX_INT_FIELD_WIDTH, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT15, EM_LIMITTEXT, MAX_INT_FIELD_WIDTH, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT16, EM_LIMITTEXT, MAX_INT_FIELD_WIDTH, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT17, EM_LIMITTEXT, MAX_INT_FIELD_WIDTH, 0);


            if(pMyStuff->bIsMM)
                CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1) ;
            else
            {
                CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2) ;
                //  convert RECT values to inches
                pMyStuff->rcMargin.left  = MulDiv(pMyStuff->rcMargin.left, 100, 254) ;
                pMyStuff->rcMargin.top  = MulDiv(pMyStuff->rcMargin.top, 100, 254) ;
                pMyStuff->rcMargin.right  = MulDiv(pMyStuff->rcMargin.right, 100, 254) ;
                pMyStuff->rcMargin.bottom  = MulDiv(pMyStuff->rcMargin.bottom, 100, 254) ;
            }
            //   convert int to ascii string
            _itot(pMyStuff->rcMargin.left, szIntString, RADIX ) ;
            SetDlgItemText(hDlg, IDC_EDIT14, szIntString);
            _itot(pMyStuff->rcMargin.top, szIntString, RADIX) ;
            SetDlgItemText(hDlg, IDC_EDIT15, szIntString);
            _itot(pMyStuff->rcMargin.right, szIntString, RADIX) ;
            SetDlgItemText(hDlg, IDC_EDIT16, szIntString);
            _itot(pMyStuff->rcMargin.bottom, szIntString, RADIX) ;
            SetDlgItemText(hDlg, IDC_EDIT17, szIntString);

//**            init other edit boxes with corresponding command strings from registry

            if(BinaryToHexString(pMyStuff->BeginJob.strCmd, szString,
                    pMyStuff->BeginJob.dwLen,   MAX_CMD_LEN + 1))
                SetDlgItemTextA(hDlg, IDC_EDIT10, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->EndJob.strCmd, szString,
                    pMyStuff->EndJob.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT11, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->PaperSelect.strCmd, szString,
                    pMyStuff->PaperSelect.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT12, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->FeedSelect.strCmd, szString,
                    pMyStuff->FeedSelect.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT13, (LPCSTR)szString);

            break;

        case WM_NOTIFY:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            pMyStuff = &pGlobals->regStruct ;
            switch (((LPNMHDR)lParam)->code)  // type of notification message
            {
                case PSN_SETACTIVE:
                    break;

                case PSN_KILLACTIVE:
                //  formerly  case  IDC_BUTTON1:
                // convert user command to binary and back to
                                                //  verify proper entry.
                {
//**                        extract all command strings
                        GetDlgItemTextA(hDlg, IDC_EDIT10, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->BeginJob.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->BeginJob.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT11, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->EndJob.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->EndJob.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT12, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->PaperSelect.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->PaperSelect.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT13, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->FeedSelect.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->FeedSelect.dwLen) ;

                        //  reinitialize edit boxes with binary translated strings.
                        if(BinaryToHexString(pMyStuff->BeginJob.strCmd, szString,
                                pMyStuff->BeginJob.dwLen,   MAX_CMD_LEN + 1))
                            SetDlgItemTextA(hDlg, IDC_EDIT10, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->EndJob.strCmd, szString,
                                pMyStuff->EndJob.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT11, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->PaperSelect.strCmd, szString,
                                pMyStuff->PaperSelect.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT12, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->FeedSelect.strCmd, szString,
                                pMyStuff->FeedSelect.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT13, (LPCSTR)szString);
                }
                break;

                case PSN_APPLY:
                    {

                        //  MessageBox(hDlg, szString, "TTY settings", MB_OK);

                        //  load numbers in edit boxes into rcMargin

                        GetDlgItemText(hDlg, IDC_EDIT14, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.left = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT15, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.top = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT16, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.right = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT17, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.bottom = _ttoi(szIntString) ;

                        if(!pMyStuff->bIsMM )
                        {
                            //  convert RECT values from inches back to mm
                            pMyStuff->rcMargin.left  = MulDiv(pMyStuff->rcMargin.left, 254, 100) ;
                            pMyStuff->rcMargin.top  = MulDiv(pMyStuff->rcMargin.top, 254, 100) ;
                            pMyStuff->rcMargin.right  = MulDiv(pMyStuff->rcMargin.right, 254, 100) ;
                            pMyStuff->rcMargin.bottom  = MulDiv(pMyStuff->rcMargin.bottom, 254, 100) ;
                        }
//**                        extract all command strings
                        GetDlgItemTextA(hDlg, IDC_EDIT10, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->BeginJob.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->BeginJob.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT11, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->EndJob.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->EndJob.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT12, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->PaperSelect.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->PaperSelect.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT13, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->FeedSelect.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->FeedSelect.dwLen) ;

                        //  reinitialize edit boxes with binary translated strings.
                        if(BinaryToHexString(pMyStuff->BeginJob.strCmd, szString,
                                pMyStuff->BeginJob.dwLen,   MAX_CMD_LEN + 1))
                            SetDlgItemTextA(hDlg, IDC_EDIT10, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->EndJob.strCmd, szString,
                                pMyStuff->EndJob.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT11, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->PaperSelect.strCmd, szString,
                                pMyStuff->PaperSelect.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT12, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->FeedSelect.strCmd, szString,
                                pMyStuff->FeedSelect.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT13, (LPCSTR)szString);


                        //   store MyStuff in registry.
                         VinitMyStuff(pGlobals,  TRUE) ;

                    }
                    break;

                case PSN_RESET:
                    break;
            }
            break;
        case  WM_COMMAND:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            pMyStuff = &pGlobals->regStruct ;

            if(HIWORD(wParam) == EN_CHANGE)
                // type of notification message
            {
                switch(LOWORD(wParam))
                {
                    case  IDC_EDIT10:
                    case  IDC_EDIT11:
                    case  IDC_EDIT12:
                    case  IDC_EDIT13:
                    case  IDC_EDIT14:
                    case  IDC_EDIT15:
                    case  IDC_EDIT16:
                    case  IDC_EDIT17:
                        PropSheet_Changed(GetParent( hDlg ), hDlg);
                        break;
                    default:
                        break;
                }

            }


            switch(LOWORD(wParam))
            {
                case  IDC_RADIO1:  // convert to MM
                {
                    if(!pMyStuff->bIsMM )
                    {
                        // assume all values are inches
                        // convert to mm.  and store in edit boxes.

                        //  load numbers in edit boxes into rcMargin

                        GetDlgItemText(hDlg, IDC_EDIT14, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.left = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT15, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.top = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT16, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.right = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT17, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.bottom = _ttoi(szIntString) ;

                        //  convert RECT values from inches back to mm
                        pMyStuff->rcMargin.left  = MulDiv(pMyStuff->rcMargin.left, 254, 100) ;
                        pMyStuff->rcMargin.top  = MulDiv(pMyStuff->rcMargin.top, 254, 100) ;
                        pMyStuff->rcMargin.right  = MulDiv(pMyStuff->rcMargin.right, 254, 100) ;
                        pMyStuff->rcMargin.bottom  = MulDiv(pMyStuff->rcMargin.bottom, 254, 100) ;

                        //  load numbers from  rcMargin into edit boxes

                        _itot(pMyStuff->rcMargin.left, szIntString, RADIX ) ;
                        SetDlgItemText(hDlg, IDC_EDIT14, szIntString);
                        _itot(pMyStuff->rcMargin.top, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT15, szIntString);
                        _itot(pMyStuff->rcMargin.right, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT16, szIntString);
                        _itot(pMyStuff->rcMargin.bottom, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT17, szIntString);

                        pMyStuff->bIsMM = TRUE ;
                    }

                }
                break;
                case  IDC_RADIO2:  // convert to inches
                {
                    if(pMyStuff->bIsMM )
                    {
                        // assume all values are mm
                        // convert to inches.  and store in edit boxes.

                        //  load numbers in edit boxes into rcMargin

                        GetDlgItemText(hDlg, IDC_EDIT14, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.left = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT15, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.top = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT16, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.right = _ttoi(szIntString) ;
                        GetDlgItemText(hDlg, IDC_EDIT17, szIntString, MAX_INT_FIELD_WIDTH + 1);
                        pMyStuff->rcMargin.bottom = _ttoi(szIntString) ;

                        //  convert RECT values from mm back to inches
                        pMyStuff->rcMargin.left  = MulDiv(pMyStuff->rcMargin.left, 100, 254) ;
                        pMyStuff->rcMargin.top  = MulDiv(pMyStuff->rcMargin.top, 100, 254) ;
                        pMyStuff->rcMargin.right  = MulDiv(pMyStuff->rcMargin.right, 100, 254) ;
                        pMyStuff->rcMargin.bottom  = MulDiv(pMyStuff->rcMargin.bottom, 100, 254) ;

                        //  load numbers from  rcMargin into edit boxes

                        _itot(pMyStuff->rcMargin.left, szIntString, RADIX ) ;
                        SetDlgItemText(hDlg, IDC_EDIT14, szIntString);
                        _itot(pMyStuff->rcMargin.top, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT15, szIntString);
                        _itot(pMyStuff->rcMargin.right, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT16, szIntString);
                        _itot(pMyStuff->rcMargin.bottom, szIntString, RADIX) ;
                        SetDlgItemText(hDlg, IDC_EDIT17, szIntString);

                        pMyStuff->bIsMM = FALSE ;
                    }
                }
                break;
            }
            break;
        case WM_HELP:
        case WM_CONTEXTMENU:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            //  pMyStuff = &pGlobals->regStruct ;
            bStatus = PrintUIHelp(uiMsg,  hDlg,  wParam,  lParam, pGlobals) ;
            break;

    }

    return bStatus ;
}

void  VinitMyStuff(
    PGLOBALSTRUCT  pGlobals,   // points to private structure for static storage
    BOOL    bSave   // save to registry  instead of reading from...
)
{
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    DWORD   dwStatus, cbNeeded, dwType ;
    LPTSTR  pValueName = TEXT("TTY DeviceConfig");
                // these strings must match strings in ttyud.cpp - OEMEnablePDEV()

    pMyStuff = &pGlobals->regStruct ;

    if(bSave)    //  save to registry
    {
        if(--pGlobals->dwUseCount)
            return ;
        //  you are the last property page to perform
        //  shutdown routine.  Save MyStuff to registry.

        SetPrinterData(
            pGlobals->hPrinter,    // handle of printer object
            pValueName,  // address of value name
            REG_BINARY, // flag for value type
            (LPBYTE)pMyStuff ,   // address of array that specifies printer data
            sizeof(REGSTRUCT)    // size, in bytes, of array
           );


        return ;
    }

    //  read from registry

    if(pGlobals->dwUseCount)
    {
        pGlobals->dwUseCount++ ;
        return ;
    }
    dwStatus =  GetPrinterData(
        pGlobals->hPrinter, // handle of printer object   saved previously.
        pValueName, // address of value name
        &dwType,    // address receiving value type
        (LPBYTE)pMyStuff,  // address of array of bytes that receives data
        sizeof(REGSTRUCT),  // size, in bytes, of array
        &cbNeeded   // address of variable
                //  with number of bytes retrieved (or required)
        );


    if (dwStatus != ERROR_SUCCESS || pMyStuff->dwVersion != TTYSTRUCT_VER
        ||  dwType !=  REG_BINARY
        ||  cbNeeded != sizeof(REGSTRUCT))
    {
        //  Init secret block with defaults

        pMyStuff->dwVersion = TTYSTRUCT_VER ;
        //  version stamp to avoid incompatible structures.

        pMyStuff->bIsMM = TRUE ;  // default to mm units
        //  read margin values from registry and store into temp RECT
        pMyStuff->iCodePage = 1252 ;
        pMyStuff->rcMargin.left  = pMyStuff->rcMargin.top  =
        pMyStuff->rcMargin.right  =  pMyStuff->rcMargin.bottom  = 0 ;
        pMyStuff->BeginJob.dwLen =
        pMyStuff->EndJob.dwLen =
        pMyStuff->PaperSelect.dwLen =
        pMyStuff->FeedSelect.dwLen =
        pMyStuff->Sel_10_cpi.dwLen =
        pMyStuff->Sel_12_cpi.dwLen =
        pMyStuff->Sel_17_cpi.dwLen =
        pMyStuff->Bold_ON.dwLen =
        pMyStuff->Bold_OFF.dwLen =
        pMyStuff->Underline_ON.dwLen =
        pMyStuff->Underline_OFF.dwLen = 0 ;

        // more fields here!
        pMyStuff->dwGlyphBufSiz =
        pMyStuff->dwSpoolBufSiz = 0 ;
        pMyStuff->aubGlyphBuf =
        pMyStuff->aubSpoolBuf  = NULL ;
    }

    InitHelpfileName(pGlobals) ;

    pGlobals->dwUseCount = 1 ;
    return ;
}

BOOL   BinaryToHexString(LPBYTE  lpBinary, LPBYTE  lpHex,
DWORD  nBinaryLen,   //  num bytes to process in lpBinary
DWORD  nHexLen)  //  num bytes in dest buffer lpHex.
{
    //  how do I translate TCHAR to ascii?
    //   use  Set GetDlgItemTextA
    //  add NULL termination to lpHex

    //  return FALSE if dest buffer exhausted


    DWORD  dwSrc, dwDst ;
    BOOL   bHexmode = FALSE ;
    BYTE  Nibble ;

    for(dwSrc = dwDst = 0 ; dwSrc < nBinaryLen ; dwSrc++)
    {
        if(lpBinary[dwSrc] < 0x21  ||  lpBinary[dwSrc] > 0x7e
            ||  lpBinary[dwSrc] == '<')
        {
            //  enter hexmode if not already
            if(!bHexmode)
            {
                if(dwDst + 5 >  nHexLen)
                    return(FALSE);
                lpHex[dwDst++] = '<' ;
                bHexmode = TRUE ;
            }
            else if(dwDst + 4 >  nHexLen)
                return(FALSE);

            Nibble = (lpBinary[dwSrc]  >> 4) & 0x0f  ;
            if(Nibble < 0x0a)
                lpHex[dwDst++] = '0' + Nibble ;
            else
                lpHex[dwDst++] = 'A' + Nibble - 0x0a ;
            // loNibble
            Nibble = lpBinary[dwSrc]  & 0x0f  ;
            if(Nibble < 0x0a)
                lpHex[dwDst++] = '0' + Nibble ;
            else
                lpHex[dwDst++] = 'A' + Nibble - 0x0a ;
        }
        else
        {
            //  exit hexmode if not already
            if(bHexmode)
            {
                lpHex[dwDst++] = '>' ;
                bHexmode = FALSE ;
            }
            if(dwDst + 2 >  nHexLen)
                return(FALSE);
            lpHex[dwDst++] =  lpBinary[dwSrc];
        }
    }
    if(bHexmode)
    {
        lpHex[dwDst++] = '>' ;
        bHexmode = FALSE ;
    }
    lpHex[dwDst] = '\0' ;  // null terminate string.
    return(TRUE);
}



BOOL   HexStringToBinary(LPBYTE  lpHex, LPBYTE  lpBinary,
DWORD  nHexLen,  //  num bytes in src buffer lpHex.
DWORD  nBinaryLen,    //  num bytes in dest buffer lpBinary
DWORD * lpnBinBytes)   //  num bytes written to dest buffer lpBinary
{
    //  how do I translate TCHAR to ascii?
    //   use  Set GetDlgItemTextA

    //  return FALSE if dest buffer exhausted


    DWORD  dwSrc, dwDst ;
    BOOL   bHexmode = FALSE, bHiByte ;
    BYTE  Nibble ;

    lpHex[nHexLen - 1] = '\0' ;  // null terminate src string
                //  to prevent overrun accidents.

    for(dwSrc = dwDst = 0 ; lpHex[dwSrc] ; dwSrc++)
    {
        if(bHexmode)  //  hexmode processing:
                            //  recognize only 0-9, a-f, A-F and >
                            //  all other chars are ignored.
        {
            if(lpHex[dwSrc] >= '0'  &&  lpHex[dwSrc] <= '9')
            {
                //  digits
                Nibble =   lpHex[dwSrc] - '0' ;
            }
            else if(lpHex[dwSrc] >= 'a'  &&  lpHex[dwSrc] <= 'f')
            {
                //  lower case hex digits
                Nibble =   0x0a + lpHex[dwSrc] - 'a' ;
            }
            else if(lpHex[dwSrc] >= 'A'  &&  lpHex[dwSrc] <= 'F')
            {
                //  upper case hex digits
                Nibble =   0x0a + lpHex[dwSrc] - 'A' ;
            }
            else if(lpHex[dwSrc] == '>')
            {
                    bHexmode = FALSE ;
                    continue;   // do not attempt to save anything.
            }
            else
                continue;   // totally ignore unexpected characters.
            if(bHiByte)
            {
                lpBinary[dwDst] = Nibble << 4 ;
                bHiByte = FALSE ;
            }
            else  // lowByte processing
            {
                if(dwDst + 1 >  nBinaryLen)
                {
                    *lpnBinBytes = dwDst ;
                    return(FALSE);
                }
                lpBinary[dwDst++] |= Nibble ;
                bHiByte = TRUE ;
            }
        }
        else if(lpHex[dwSrc] == '<')
        {
                bHiByte = bHexmode = TRUE ;
        }
        else
        {
            if(dwDst + 1 >  nBinaryLen)
            {
                *lpnBinBytes = dwDst ;
                return(FALSE);
            }
            lpBinary[dwDst++] = lpHex[dwSrc] ;
        }
    }
    *lpnBinBytes = dwDst ;
    return(TRUE);
}


// revised version for drop down list box

void            vSetGetCodePage(HWND hDlg,
INT  *piCodePage,
BOOL    bMode)   // TRUE:  Set,  FALSE:  Get code page.
{

    typedef  struct
    {
        INT  iCodepage ;  //  store this value in registry
    } CODEPAGE ;

    #define   NUM_CODEPAGES  14

    CODEPAGE  codepage[NUM_CODEPAGES] ;
    DWORD  dwI ;


    codepage[0].iCodepage = -1 ;    //    CP437.gtt   "United States"
    codepage[1].iCodepage = 850 ;  //  use 850 instead of -2 (IBM CP850.gtt   "Multilingual - Latin 1"
	codepage[2].iCodepage = -3 ;  //  CP863.gtt   "Canadian French"

    codepage[3].iCodepage = -10 ;     //     950.gtt    Traditional Chinese
    codepage[4].iCodepage = -16 ;     //     936.gtt        Simplified Chinese
    codepage[5].iCodepage = -17 ;     //     932.gtt       Japanese
    codepage[6].iCodepage = -18 ;     //     949.gtt   Korean

    codepage[7].iCodepage = 1250;   //  Eastern European
    codepage[8].iCodepage = 1251;   //  Cyrillic
    codepage[9].iCodepage = 1252;   //  US (ANSI)
   	codepage[10].iCodepage = 1253;   //  Greek
	codepage[11].iCodepage = 1254;   //  Turkish
    
	codepage[12].iCodepage = 852;    //  Slavic - Latin 2
    codepage[13].iCodepage = 857;    //  Turkish IBM 
	
/*
    codepage[17].iCodepage = 1255;   //  Hebrew
    codepage[18].iCodepage = 1256;   //  Arabic
    codepage[19].iCodepage = 1257;   //  Baltic
    codepage[20].iCodepage = 1258;   //  Vietnamese
    codepage[4].iCodepage = -11 ;     //     949_ISC.gtt
    codepage[5].iCodepage = -12 ;     //     932_JIS.gtt
    codepage[6].iCodepage = -13 ;     //     932_JISA.gtt
    codepage[7].iCodepage = -14 ;     //     950_NS86.gtt
    codepage[8].iCodepage = -15 ;     //     950_TCA.gtt
*/




    if(bMode)
    {
        dwI = (DWORD)SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCURSEL, 0, 0);
        if (dwI == CB_ERR)
            dwI = 0 ;

        *piCodePage = codepage[dwI].iCodepage ;
    }
    else        // need to initialize list box selection.
    {
        for(dwI = 0 ; dwI < NUM_CODEPAGES ; dwI++)
        {
            if(codepage[dwI].iCodepage ==  *piCodePage)
                break;
        }
        dwI %= NUM_CODEPAGES ;
        SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, dwI, NULL);
    }

}


BOOL APIENTRY DevPropPage2Proc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    PGLOBALSTRUCT  pGlobals;   // points to private structure for static storage
    PREGSTRUCT  pMyStuff;           //  sebset of pGlobals
    BYTE   szString[MAX_CMD_LEN + 1] ;
    TCHAR  tbuffer[MAX_CMD_LEN] ;
    DWORD   dwI ;
    BOOL    bStatus = FALSE;


    switch (uiMsg)
    {
        case WM_INITDIALOG:

            pGlobals = (PGLOBALSTRUCT) ((PROPSHEETPAGE *)lParam)->lParam ;
            pMyStuff = &pGlobals->regStruct ;
            //  at WM_INITDIALOG time, lParam points to   PROPSHEETPAGE.
            //  extract and save ptr to GLOBALSTRUCT for future ref.
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pGlobals) ;

            VinitMyStuff( pGlobals, FALSE) ;


            SendDlgItemMessage(hDlg, IDC_EDIT1, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT2, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT3, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT6, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT7, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT8, EM_LIMITTEXT, MAX_CMD_LEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT9, EM_LIMITTEXT, MAX_CMD_LEN, 0);

            for(dwI = FIRSTSTRINGID ; dwI <= LASTSTRINGID ; dwI++)
            {
                LoadString( ((PROPSHEETPAGE *)lParam)->hInstance, (UINT)dwI, tbuffer, MAX_CMD_LEN);
                (DWORD)SendDlgItemMessage(hDlg, IDC_COMBO1, CB_ADDSTRING, 0, (LPARAM)tbuffer);
            }

            vSetGetCodePage(hDlg, &pMyStuff->iCodePage, FALSE) ;  // Get code page.

//**            init other edit boxes with corresponding command strings from registry

            if(BinaryToHexString(pMyStuff->Sel_10_cpi.strCmd, szString,
                    pMyStuff->Sel_10_cpi.dwLen,   MAX_CMD_LEN + 1))
                SetDlgItemTextA(hDlg, IDC_EDIT1, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Sel_12_cpi.strCmd, szString,
                    pMyStuff->Sel_12_cpi.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT2, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Sel_17_cpi.strCmd, szString,
                    pMyStuff->Sel_17_cpi.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT3, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Bold_ON.strCmd, szString,
                    pMyStuff->Bold_ON.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT6, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Bold_OFF.strCmd, szString,
                    pMyStuff->Bold_OFF.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT7, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Underline_ON.strCmd, szString,
                    pMyStuff->Underline_ON.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT8, (LPCSTR)szString);

            if(BinaryToHexString(pMyStuff->Underline_OFF.strCmd, szString,
                    pMyStuff->Underline_OFF.dwLen,   MAX_CMD_LEN + 1) )
                SetDlgItemTextA(hDlg, IDC_EDIT9, (LPCSTR)szString);



            break;

        case WM_NOTIFY:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            pMyStuff = &pGlobals->regStruct ;

            switch (((LPNMHDR)lParam)->code)  // type of notification message
            {
                case PSN_SETACTIVE:
                    break;

                case PSN_KILLACTIVE:
                //  case  IDC_BUTTON1:
                    // convert user command to binary and back to
                                //  verify proper entry.
                {
                //**                        extract all command strings
                        GetDlgItemTextA(hDlg, IDC_EDIT1, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_10_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_10_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT2, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_12_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_12_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT3, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_17_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_17_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT6, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Bold_ON.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Bold_ON.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT7, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Bold_OFF.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Bold_OFF.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT8, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Underline_ON.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Underline_ON.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT9, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Underline_OFF.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Underline_OFF.dwLen) ;

                        //  reinitialize edit boxes with binary translated strings.

                        if(BinaryToHexString(pMyStuff->Sel_10_cpi.strCmd, szString,
                                pMyStuff->Sel_10_cpi.dwLen,   MAX_CMD_LEN + 1))
                            SetDlgItemTextA(hDlg, IDC_EDIT1, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Sel_12_cpi.strCmd, szString,
                                pMyStuff->Sel_12_cpi.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT2, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Sel_17_cpi.strCmd, szString,
                                pMyStuff->Sel_17_cpi.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT3, (LPCSTR)szString);

						if(BinaryToHexString(pMyStuff->Bold_ON.strCmd, szString,
                                pMyStuff->Bold_ON.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT6, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Bold_OFF.strCmd, szString,
                                pMyStuff->Bold_OFF.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT7, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Underline_ON.strCmd, szString,
                                pMyStuff->Underline_ON.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT8, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Underline_OFF.strCmd, szString,
                                pMyStuff->Underline_OFF.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT9, (LPCSTR)szString);

                }
                break;

                case PSN_APPLY:
                    {
                        // set code page
                        vSetGetCodePage(hDlg, &pMyStuff->iCodePage, TRUE) ;

                       //**                        extract all command strings

                        GetDlgItemTextA(hDlg, IDC_EDIT1, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_10_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_10_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT2, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_12_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_12_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT3, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Sel_17_cpi.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Sel_17_cpi.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT6, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Bold_ON.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Bold_ON.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT7, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Bold_OFF.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Bold_OFF.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT8, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Underline_ON.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Underline_ON.dwLen) ;

                        GetDlgItemTextA(hDlg, IDC_EDIT9, (LPSTR)szString, MAX_CMD_LEN + 1);
                        HexStringToBinary(szString, pMyStuff->Underline_OFF.strCmd,
                            MAX_CMD_LEN + 1, MAX_CMD_LEN,  &pMyStuff->Underline_OFF.dwLen) ;

                        //  reinitialize edit boxes with binary translated strings.

                        if(BinaryToHexString(pMyStuff->Sel_10_cpi.strCmd, szString,
                                pMyStuff->Sel_10_cpi.dwLen,   MAX_CMD_LEN + 1))
                            SetDlgItemTextA(hDlg, IDC_EDIT1, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Sel_12_cpi.strCmd, szString,
                                pMyStuff->Sel_12_cpi.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT2, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Sel_17_cpi.strCmd, szString,
                                pMyStuff->Sel_17_cpi.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT3, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Bold_ON.strCmd, szString,
                                pMyStuff->Bold_ON.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT6, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Bold_OFF.strCmd, szString,
                                pMyStuff->Bold_OFF.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT7, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Underline_ON.strCmd, szString,
                                pMyStuff->Underline_ON.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT8, (LPCSTR)szString);

                        if(BinaryToHexString(pMyStuff->Underline_OFF.strCmd, szString,
                                pMyStuff->Underline_OFF.dwLen,   MAX_CMD_LEN + 1) )
                            SetDlgItemTextA(hDlg, IDC_EDIT9, (LPCSTR)szString);


                        //   store MyStuff in registry.
                         VinitMyStuff(pGlobals,  TRUE) ;

                    }
                    break;


                case PSN_RESET:
                    break;
            }
            break;
        case  WM_COMMAND:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            pMyStuff = &pGlobals->regStruct ;

            if(HIWORD(wParam) == EN_CHANGE)
                // type of notification message
            {
                switch(LOWORD(wParam))
                {
                    case  IDC_EDIT1:
                    case  IDC_EDIT2:
                    case  IDC_EDIT3:
                    case  IDC_EDIT6:
                    case  IDC_EDIT7:
                    case  IDC_EDIT8:
                    case  IDC_EDIT9:
                        PropSheet_Changed(GetParent( hDlg ), hDlg);
                        break;
                    default:
                        break;
                }
            }

            if(HIWORD(wParam) == CBN_SELCHANGE  &&
                LOWORD(wParam) == IDC_COMBO1)
                    PropSheet_Changed(GetParent( hDlg ), hDlg);

            if(HIWORD(wParam) == BN_CLICKED   &&
                LOWORD(wParam) == IDC_CHKBOX1)
                    PropSheet_Changed(GetParent( hDlg ), hDlg);

            break;
        case WM_HELP:
        case WM_CONTEXTMENU:
            pGlobals = (PGLOBALSTRUCT)GetWindowLongPtr(hDlg, DWLP_USER ) ;
            bStatus = PrintUIHelp(uiMsg,  hDlg,  wParam,  lParam, pGlobals) ;
            break;

    }

    return bStatus;
}



BOOL    InitHelpfileName(PGLOBALSTRUCT  pGlobals)
{
    DWORD  cbNeeded = 0;
    PDRIVER_INFO_3   pdrvInfo3 ;

    GetPrinterDriver(pGlobals->hPrinter, NULL, 3,  NULL, 0,  &cbNeeded) ;

    if (! (pdrvInfo3 = (PDRIVER_INFO_3)HeapAlloc(pGlobals->hOEMHeap, HEAP_ZERO_MEMORY,cbNeeded)))
        return(FALSE);  // Alloc failed

    if(!GetPrinterDriver(pGlobals->hPrinter, NULL, 3,  (LPBYTE)pdrvInfo3,
        cbNeeded,  &cbNeeded))
        return(FALSE) ;   // failed to initialize path

    pGlobals->pwHelpFile =  PwstrCreateQualifiedName(
        pGlobals->hOEMHeap,
        pdrvInfo3->pDriverPath,
        TEXT("ttyui.hlp")
        ) ;
    return(TRUE);
}



PWSTR
PwstrCreateQualifiedName(
    HANDLE  hHeap,
    PWSTR   pDir,
    PWSTR   pFile
    )
/*++

Routine Description:

    Create a fully qualified name for the directory and file name passed in.

Arguments:

    pDir - Points to the path
    pFile - Points to file name
    hHeap - Points to the heap to allocate the returned string from.

Return Value:

    Pointer to the fully qualified name.

--*/

{
    DWORD dwLen;
    PWSTR pBasename, pQualifiedName;

    //
    // Figure out the len of the directory
    //

    if (pBasename = wcsrchr(pDir, TEXT(PATH_SEPARATOR)))
    {
        pBasename++;
    }
    else
    {
        WARNING(ERRORTEXT("PwstrCreateQualifiedName(): Invalid path name.\r\n"));
        return NULL;
    }


    dwLen = (DWORD)(pBasename - pDir) ;   //  number of WCHARS


    //
    // Concatenate the input directory with the base filename
    //

    if (! (pQualifiedName = (PWSTR)HeapAlloc(hHeap, HEAP_ZERO_MEMORY,sizeof(WCHAR) *
                                    (dwLen + wcslen(pFile) + 1))))
    {
        WARNING(ERRORTEXT("PwstrCreateQualifiedName(): Memory allocation failed.\r\n"));
        return NULL;
    }

    wcsncpy(pQualifiedName, pDir, dwLen);
    wcscat(pQualifiedName, pFile);

    return pQualifiedName;
}



/*++

Routine Name:

    PrintUIHlep

Routine Description:

    All dialogs and property sheets call this routine
    to handle help.  It is important that control ID's
    are unique to this project for this to work.

Arguments:

    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam

Return Value:

    TRUE if help message was dislayed, FALSE if message not handled,

--*/
BOOL
PrintUIHelp(
    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam,
    PGLOBALSTRUCT  pGlobals   // points to private structure for static storage

    )
{
    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_HELP:

        bStatus = WinHelp(
                    (HWND) ((LPHELPINFO) lParam)->hItemHandle,
                    pGlobals->pwHelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR) (LPTSTR)aHelpIDs );
        break;

    case WM_CONTEXTMENU:

        bStatus = WinHelp(
                    (HWND)wParam,
                    pGlobals->pwHelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR) (LPTSTR)aHelpIDs );
        break;

    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\globals.h ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  globals.h - this file contains the
    definitions for all global variables
    used by the parser.  */


/*  note:  const PARSERPROCS gParserProcs = {
    has been moved to helper1.c since it is also
    used in kernel mode.
*/


CONST CONSTANTDEF  gConstantsTable[] =
{

    {NULL, CL_BOOLEANTYPE},
    {"CL_BOOLEANTYPE", 0},
    {"FALSE", BT_FALSE},
    {"TRUE",  BT_TRUE},


    {NULL, CL_PRINTERTYPE},   // Note each section starts with
    {"CL_PRINTERTYPE", 0},
    {"PAGE", PT_PAGE},          // Null ptr , class.  This allows
    {"SERIAL", PT_SERIAL},      //  indexing code to work.
    {"TTY", PT_TTY},      //  indexing code to work.


    {NULL, CL_FEATURETYPE},
    {"CL_FEATURETYPE", 0},
    {"DOC_PROPERTY", FT_DOCPROPERTY},
    {"JOB_PROPERTY", FT_JOBPROPERTY},
    {"PRINTER_PROPERTY", FT_PRINTERPROPERTY},

    {NULL, CL_UITYPE},
    {"CL_UITYPE", 0},
    {"PICKMANY", UIT_PICKMANY},
    {"PICKONE", UIT_PICKONE},


    {NULL, CL_PROMPTTIME},
    {"CL_PROMPTTIME", 0},
    {"UI_SETUP", PROMPT_UISETUP},
    {"PRT_STARTDOC", PROMPT_PRTSTARTDOC},


    {NULL, CL_PAPERFEED_ORIENT},   //  constants defined in print.h
    {"CL_PAPERFEED_ORIENT", 0},
    { "FACEUP_NONE", DCBA_FACEUPNONE },
    { "FACEUP_CENTER", DCBA_FACEUPCENTER },
    { "FACEUP_LEFT", DCBA_FACEUPLEFT },
    { "FACEUP_RIGHT", DCBA_FACEUPRIGHT },
    { "FACEDOWN_NONE", DCBA_FACEDOWNNONE },
    { "FACEDOWN_CENTER", DCBA_FACEDOWNCENTER },
    { "FACEDOWN_LEFT", DCBA_FACEDOWNLEFT },
    { "FACEDOWN_RIGHT", DCBA_FACEDOWNRIGHT },


    {NULL, CL_COLORPLANE},
    {"CL_COLORPLANE", 0},
    {"YELLOW", COLOR_YELLOW},
    {"MAGENTA", COLOR_MAGENTA},
    {"CYAN", COLOR_CYAN},
    {"BLACK", COLOR_BLACK},
    {"RED", COLOR_RED},
    {"GREEN", COLOR_GREEN},
    {"BLUE", COLOR_BLUE},

    {NULL, CL_SEQSECTION},
    {"CL_SEQSECTION", 0},
    {"JOB_SETUP", SS_JOBSETUP},
    {"DOC_SETUP", SS_DOCSETUP},
    {"PAGE_SETUP", SS_PAGESETUP},
    {"PAGE_FINISH", SS_PAGEFINISH},
    {"DOC_FINISH", SS_DOCFINISH},
    {"JOB_FINISH", SS_JOBFINISH},


    {NULL, CL_RASTERCAPS},  // BUG_BUG!!!!!  placeholders
    {"CL_RASTERCAPS", 0},
    {"AT_PRINTABLE_X_ORIGIN", CXCR_AT_PRINTABLE_X_ORIGIN},
    {"AT_GRXDATA_ORIGIN", CXCR_AT_CURSOR_X_ORIGIN},


    {NULL, CL_TEXTCAPS },
    {"CL_TEXTCAPS", 0},
    {"TC_OP_CHARACTER", TEXTCAPS_OP_CHARACTER},
    {"TC_OP_STROKE", TEXTCAPS_OP_STROKE},
    {"TC_CP_STROKE", TEXTCAPS_CP_STROKE},
    {"TC_CR_90", TEXTCAPS_CR_90},
    {"TC_CR_ANY", TEXTCAPS_CR_ANY},
    {"TC_SF_X_YINDEP", TEXTCAPS_SF_X_YINDEP},
    {"TC_SA_DOUBLE", TEXTCAPS_SA_DOUBLE},
    {"TC_SA_INTEGER", TEXTCAPS_SA_INTEGER},
    {"TC_SA_CONTIN", TEXTCAPS_SA_CONTIN},
    {"TC_EA_DOUBLE", TEXTCAPS_EA_DOUBLE},
    {"TC_IA_ABLE", TEXTCAPS_IA_ABLE},
    {"TC_UA_ABLE", TEXTCAPS_UA_ABLE},
    {"TC_SO_ABLE", TEXTCAPS_SO_ABLE},
    {"TC_RA_ABLE", TEXTCAPS_RA_ABLE},
    {"TC_VA_ABLE", TEXTCAPS_VA_ABLE},


    {NULL, CL_MEMORYUSAGE},
    {"CL_MEMORYUSAGE", 0},
    {"FONT", MEMORY_FONT},
    {"RASTER", MEMORY_RASTER},
    {"VECTOR", MEMORY_VECTOR},


    {NULL, CL_RESELECTFONT},
    {"CL_RESELECTFONT", 0},
    {"AFTER_GRXDATA", RESELECTFONT_AFTER_GRXDATA},
    {"AFTER_XMOVE", RESELECTFONT_AFTER_XMOVE},
    {"AFTER_FF", RESELECTFONT_AFTER_FF},


    {NULL, CL_OEMPRINTINGCALLBACKS},
    {"CL_OEMPRINTINGCALLBACKS", 0},
    {"OEMDownloadFontheader", OEMPC_OEMDownloadFontheader},
    {"OEMDownloadCharGlyph", OEMPC_OEMDownloadCharGlyph},
    {"OEMTTDownloadMethod", OEMPC_OEMTTDownloadMethod},
    {"OEMOutputCharStr", OEMPC_OEMOutputCharStr},
    {"OEMImageProcessing", OEMPC_OEMImageProcessing},
    {"OEMCompression", OEMPC_OEMCompression},
    {"OEMHalftonePattern", OEMPC_OEMHalftonePattern},
    {"OEMFilterGraphics", OEMPC_OEMFilterGraphics},


    {NULL, CL_CURSORXAFTERCR},
    {"CL_CURSORXAFTERCR", 0},
    {"AT_PRINTABLE_X_ORIGIN", CXCR_AT_PRINTABLE_X_ORIGIN},
    {"AT_CURSOR_X_ORIGIN", CXCR_AT_CURSOR_X_ORIGIN},


    {NULL, CL_BADCURSORMOVEINGRXMODE},
    {"CL_BADCURSORMOVEINGRXMODE", 0},
    {"X_PORTRAIT", NOCM_X_PORTRAIT},
    {"X_LANDSCAPE", NOCM_X_LANDSCAPE},
    {"Y_PORTRAIT", NOCM_Y_PORTRAIT},
    {"Y_LANDSCAPE", NOCM_Y_LANDSCAPE},


//    {NULL, CL_SIMULATEXMOVE },
//    {"CL_SIMULATEXMOVE", 0},
//    {"SPACE_CHAR", SIMXM_USE_SPACECHAR},
//    {"NULL_GRX", SIMXM_USE_NULLGRX},

    {NULL, CL_PALETTESCOPE},
    {"CL_PALETTESCOPE", 0},
    {"RASTER", PALS_FOR_RASTER},
    {"TEXT", PALS_FOR_TEXT},
    {"VECTOR", PALS_FOR_VECTOR},

    {NULL, CL_OUTPUTDATAFORMAT},
    {"CL_OUTPUTDATAFORMAT", 0},
    {"H_BYTE", ODF_H_BYTE},
    {"V_BYTE", ODF_V_BYTE},

    {NULL, CL_STRIPBLANKS },
    {"CL_STRIPBLANKS", 0},
    {"LEADING", SB_LEADING},
    {"ENCLOSED", SB_ENCLOSED},
    {"TRAILING", SB_TRAILING},

    // may be obsolete.  if you delete must
    // also delete enum from CONSTANT_CLASSES.
    {NULL, CL_LANDSCAPEGRXROTATION },
    {"CL_LANDSCAPEGRXROTATION", 0},
    {"NONE", ROTATE_NONE},
    {"CC_90", ROTATE_90},
    {"CC_270", ROTATE_270},


    {NULL, CL_CURSORXAFTERSENDBLOCKDATA },
    {"CL_CURSORXAFTERSENDBLOCKDATA", 0},
    {"AT_GRXDATA_END", CXSBD_AT_GRXDATA_END},
    {"AT_GRXDATA_ORIGIN", CXSBD_AT_GRXDATA_ORIGIN},
    {"AT_CURSOR_X_ORIGIN", CXSBD_AT_CURSOR_X_ORIGIN},
        // explicitly changed to match GPD spec.



    {NULL, CL_CURSORYAFTERSENDBLOCKDATA },
    {"CL_CURSORYAFTERSENDBLOCKDATA", 0},
    {"NO_MOVE", CYSBD_NO_MOVE},
    {"AUTO_INCREMENT", CYSBD_AUTO_INCREMENT},



    {NULL, CL_CHARPOSITION },
    {"CL_CHARPOSITION", 0},
    {"UPPERLEFT", CP_UPPERLEFT},
    {"BASELINE", CP_BASELINE},
//    {"LOWERLEFT", CP_LOWERLEFT},


    {NULL, CL_FONTFORMAT},
    {"CL_FONTFORMAT", 0},
    {"HPPCL", FF_HPPCL},
    {"HPPCL_RES", FF_HPPCL_RES},
    {"HPPCL_OUTLINE", FF_HPPCL_OUTLINE},
    {"OEM_CALLBACK", FF_OEM_CALLBACK},



    {NULL, CL_QUERYDATATYPE},
    {"CL_QUERYDATATYPE", 0},
    {"DWORD", QDT_DWORD},
    {"CONCATENATED_STRINGS", QDT_CONCATENATED_STRINGS},


    {NULL, CL_YMOVEATTRIB},
    {"CL_YMOVEATTRIB", 0},
//    {"FAVOR_ABS", YMOVE_FAVOR_ABS},  dead
    {"FAVOR_LF", YMOVE_FAVOR_LINEFEEDSPACING},
    {"SEND_CR_FIRST", YMOVE_SENDCR_FIRST},

    {NULL, CL_DLSYMBOLSET},
    {"CL_DLSYMBOLSET", 0},
    {"PC_8", DLSS_PC8},
    {"ROMAN_8", DLSS_ROMAN8},


    {NULL, CL_CURXAFTER_RECTFILL},
    {"CL_CURXAFTER_RECTFILL", 0},
    {"AT_RECT_X_ORIGIN", CXARF_AT_RECT_X_ORIGIN},
    {"AT_RECT_X_END", CXARF_AT_RECT_X_END},

    {NULL, CL_CURYAFTER_RECTFILL},
    {"CL_CURYAFTER_RECTFILL", 0},
    {"AT_RECT_Y_ORIGIN", CYARF_AT_RECT_Y_ORIGIN},
    {"AT_RECT_Y_END", CYARF_AT_RECT_Y_END},

#ifndef WINNT_40

    {NULL, CL_PRINTRATEUNIT},
    {"CL_PRINTRATEUNIT", 0},
    {"PPM", PRINTRATEUNIT_PPM},
    {"CPS", PRINTRATEUNIT_CPS},
    {"LPM", PRINTRATEUNIT_LPM},
    {"IPM", PRINTRATEUNIT_IPM},
    {"LPS", PRINTRATEUNIT_LPS},   // not supported in wingdi.h
    {"IPS", PRINTRATEUNIT_IPS},     //   not supported
#endif

    {NULL, CL_RASTERMODE},
    {"CL_RASTERMODE", 0},
    {"DIRECT", RASTMODE_DIRECT},
    {"INDEXED", RASTMODE_INDEXED},

    {NULL, CL_QUALITYSETTING},
    {"CL_QUALITYSETTING", 0},
    {"DRAFTQUALITY", QS_DRAFT},
    {"BETTERQUALITY", QS_BETTER},
    {"BESTQUALITY", QS_BEST},


    //  ---- Standard Variable Names Section ---- //



    {NULL, CL_STANDARD_VARS},
    {"CL_STANDARD_VARS", 0},
    {"NumOfDataBytes", SV_NUMDATABYTES},
    {"RasterDataWidthInBytes", SV_WIDTHINBYTES},
    {"RasterDataHeightInPixels", SV_HEIGHTINPIXELS},
    {"NumOfCopies", SV_COPIES},
    {"PrintDirInCCDegrees", SV_PRINTDIRECTION},
    {"DestX", SV_DESTX},
    {"DestY", SV_DESTY},
    {"DestXRel", SV_DESTXREL},
    {"DestYRel", SV_DESTYREL},
    {"LinefeedSpacing", SV_LINEFEEDSPACING},
    {"RectXSize", SV_RECTXSIZE},
    {"RectYSize", SV_RECTYSIZE},
    {"GrayPercentage", SV_GRAYPERCENT},
    {"NextFontID", SV_NEXTFONTID},
    {"NextGlyph", SV_NEXTGLYPH},
    {"PhysPaperLength", SV_PHYSPAPERLENGTH},
    {"PhysPaperWidth", SV_PHYSPAPERWIDTH},
    {"FontHeight", SV_FONTHEIGHT},
    {"FontWidth", SV_FONTWIDTH},
    {"FontMaxWidth", SV_FONTMAXWIDTH},
    {"FontBold", SV_FONTBOLD},
    {"FontItalic", SV_FONTITALIC},
    {"FontUnderline", SV_FONTUNDERLINE},
    {"FontStrikeThru", SV_FONTSTRIKETHRU},
    {"CurrentFontID", SV_CURRENTFONTID},
    {"TextYRes", SV_TEXTYRES},
    {"TextXRes", SV_TEXTXRES},
//  #ifdef  BETA2
    {"GraphicsYRes", SV_GRAPHICSYRES},
    {"GraphicsXRes", SV_GRAPHICSXRES},
//  #endif
    {"Rop3", SV_ROP3},
    {"RedValue", SV_REDVALUE},
    {"GreenValue", SV_GREENVALUE},
    {"BlueValue", SV_BLUEVALUE},
    {"PaletteIndexToProgram", SV_PALETTEINDEXTOPROGRAM},
    {"CurrentPaletteIndex", SV_CURRENTPALETTEINDEX},
    {"PatternBrushType", SV_PATTERNBRUSH_TYPE},
    {"PatternBrushID", SV_PATTERNBRUSH_ID},
    {"PatternBrushSize", SV_PATTERNBRUSH_SIZE},
    {"CursorOriginX", SV_CURSORORIGINX},
    {"CursorOriginY", SV_CURSORORIGINY},
    {"PageNumber",   SV_PAGENUMBER} ,


    //  ---- Unidrv Command Names Section ---- //


    {NULL, CL_COMMAND_NAMES},
    {"CL_COMMAND_NAMES", 0},
    {"CmdSelect", CMD_SELECT},
    {"CmdStartJob", CMD_STARTJOB},
    {"CmdStartDoc", CMD_STARTDOC},
    {"CmdStartPage", CMD_STARTPAGE},
    {"CmdEndPage", CMD_ENDPAGE},
    {"CmdEndDoc", CMD_ENDDOC},
    {"CmdEndJob", CMD_ENDJOB},
    {"CmdCopies", CMD_COPIES},
//    {"CmdCollate", CMD_COLLATE},
    {"CmdSleepTimeOut", CMD_SLEEPTIMEOUT},

    //
    //  GENERAL
    //

    //
    // CURSOR CONTROL
    //


    {"CmdXMoveAbsolute", CMD_XMOVEABSOLUTE},
    {"CmdXMoveRelLeft", CMD_XMOVERELLEFT},
    {"CmdXMoveRelRight", CMD_XMOVERELRIGHT},
    {"CmdYMoveAbsolute", CMD_YMOVEABSOLUTE},
    {"CmdYMoveRelUp", CMD_YMOVERELUP},
    {"CmdYMoveRelDown", CMD_YMOVERELDOWN},
//    {"CmdXYMoveAbsolute", CMD_XYMOVEABSOLUTE},

    {"CmdSetSimpleRotation", CMD_SETSIMPLEROTATION},
    {"CmdSetAnyRotation", CMD_SETANYROTATION},
    {"CmdUniDirectionOn", CMD_UNIDIRECTIONON},
    {"CmdUniDirectionOff", CMD_UNIDIRECTIONOFF},
    {"CmdSetLineSpacing", CMD_SETLINESPACING},
    {"CmdPushCursor", CMD_PUSHCURSOR},
    {"CmdPopCursor", CMD_POPCURSOR},
    {"CmdBackSpace", CMD_BACKSPACE},
    {"CmdFF", CMD_FORMFEED},
    {"CmdCR", CMD_CARRIAGERETURN},
    {"CmdLF", CMD_LINEFEED},


    //
    // COLOR
    //

    {"CmdSelectBlackColor", CMD_SELECTBLACKCOLOR},
    {"CmdSelectRedColor", CMD_SELECTREDCOLOR},
    {"CmdSelectGreenColor", CMD_SELECTGREENCOLOR},
    {"CmdSelectYellowColor", CMD_SELECTYELLOWCOLOR},
    {"CmdSelectBlueColor", CMD_SELECTBLUECOLOR},
    {"CmdSelectMagentaColor", CMD_SELECTMAGENTACOLOR},
    {"CmdSelectCyanColor", CMD_SELECTCYANCOLOR},
    {"CmdSelectWhiteColor", CMD_SELECTWHITECOLOR},
    {"CmdBeginPaletteDef", CMD_BEGINPALETTEDEF},
    {"CmdEndPaletteDef", CMD_ENDPALETTEDEF},
    {"CmdDefinePaletteEntry", CMD_DEFINEPALETTEENTRY},
    {"CmdBeginPaletteReDef", CMD_BEGINPALETTEREDEF},
    {"CmdEndPaletteReDef", CMD_ENDPALETTEREDEF},
    {"CmdReDefinePaletteEntry", CMD_REDEFINEPALETTEENTRY},
    {"CmdSelectPaletteEntry", CMD_SELECTPALETTEENTRY},
    {"CmdPushPalette", CMD_PUSHPALETTE},
    {"CmdPopPalette", CMD_POPPALETTE},

    //
    // BRUSH SELECTION
    //

    {"CmdDownloadPattern", CMD_DOWNLOAD_PATTERN},
    {"CmdSelectPattern", CMD_SELECT_PATTERN},
    {"CmdSelectWhiteBrush", CMD_SELECT_WHITEBRUSH},
    {"CmdSelectBlackBrush", CMD_SELECT_BLACKBRUSH},



    //
    // DATACOMPRESSION
    //

//    {"CmdOverlayRegStart", CMD_OVERLAYREGSTART},
//    {"CmdOverlayRegEnd", CMD_OVERLAYREGEND},
//    {"CmdEnableOverlay", CMD_ENABLEOVERLAY},
//    {"CmdDisableOverlay", CMD_DISABLEOVERLAY},
    {"CmdEnableTIFF4", CMD_ENABLETIFF4},
    {"CmdEnableDRC", CMD_ENABLEDRC},
    {"CmdEnableFE_RLE", CMD_ENABLEFERLE},
    {"CmdEnableOEMComp", CMD_ENABLEOEMCOMP},
    {"CmdDisableCompression", CMD_DISABLECOMPRESSION},

    //
    //  Raster Data Emission
    //

    {"CmdBeginRaster", CMD_BEGINRASTER},
    {"CmdEndRaster", CMD_ENDRASTER},
    {"CmdSetDestBmpWidth", CMD_SETDESTBMPWIDTH},
    {"CmdSetDestBmpHeight", CMD_SETDESTBMPHEIGHT},
    {"CmdSetSrcBmpWidth", CMD_SETSRCBMPWIDTH},
    {"CmdSetSrcBmpHeight", CMD_SETSRCBMPHEIGHT},
    {"CmdSendBlockData", CMD_SENDBLOCKDATA},
    {"CmdEndBlockData", CMD_ENDBLOCKDATA},
    {"CmdSendRedData", CMD_SENDREDDATA},
    {"CmdSendGreenData", CMD_SENDGREENDATA},
    {"CmdSendBlueData", CMD_SENDBLUEDATA},
    {"CmdSendCyanData", CMD_SENDCYANDATA},
    {"CmdSendMagentaData", CMD_SENDMAGENTADATA},
    {"CmdSendYellowData", CMD_SENDYELLOWDATA},
    {"CmdSendBlackData", CMD_SENDBLACKDATA},

    //
    //  Font Downloading
    //

    {"CmdSetFontID", CMD_SETFONTID},
    {"CmdSelectFontID", CMD_SELECTFONTID},
    {"CmdSetCharCode", CMD_SETCHARCODE},
//  #ifdef  BETA2
    {"CmdDeselectFontID", CMD_DESELECTFONTID},
    {"CmdSelectFontHeight", CMD_SELECTFONTHEIGHT},
    {"CmdSelectFontWidth", CMD_SELECTFONTWIDTH},
//  #endif
    {"CmdDeleteFont", CMD_DELETEFONT},

    //
    //  Font Simulation
    //

    {"CmdSetFontSim", CMD_SETFONTSIM},
    {"CmdBoldOn", CMD_BOLDON},
    {"CmdBoldOff", CMD_BOLDOFF},
    {"CmdItalicOn", CMD_ITALICON},
    {"CmdItalicOff", CMD_ITALICOFF},
    {"CmdUnderlineOn", CMD_UNDERLINEON},
    {"CmdUnderlineOff", CMD_UNDERLINEOFF},
    {"CmdStrikeThruOn", CMD_STRIKETHRUON},
    {"CmdStrikeThruOff", CMD_STRIKETHRUOFF},
    {"CmdWhiteTextOn", CMD_WHITETEXTON},
    {"CmdWhiteTextOff", CMD_WHITETEXTOFF},
    {"CmdSelectSingleByteMode", CMD_SELECTSINGLEBYTEMODE},
    {"CmdSelectDoubleByteMode", CMD_SELECTDOUBLEBYTEMODE},
    {"CmdVerticalPrintingOn", CMD_VERTICALPRINTINGON},
    {"CmdVerticalPrintingOff", CMD_VERTICALPRINTINGOFF},
    {"CmdClearAllFontAttribs", CMD_CLEARALLFONTATTRIBS},

    //
    // Misc
    //
    {"CmdSetTextHTAlgo",     CMD_SETTEXTHTALGO},
    {"CmdSetGraphicsHTAlgo", CMD_SETGRAPHICSHTALGO},
    {"CmdSetPhotoHTAlgo",    CMD_SETPHOTOHTALGO},

    //
    //  Vector Printing
    //

    {"CmdSetRectWidth", CMD_SETRECTWIDTH},
    {"CmdSetRectHeight", CMD_SETRECTHEIGHT},
    {"CmdSetRectSize", CMD_SETRECTSIZE},
    {"CmdRectGrayFill", CMD_RECTGRAYFILL},
    {"CmdRectWhiteFill", CMD_RECTWHITEFILL},
    {"CmdRectBlackFill", CMD_RECTBLACKFILL},

#if 0
    {"CmdSetTransparencyMode", CMD_SETTRANSPARENCYMODE},
    {"CmdSetOpaqueMode", CMD_SETOPAQUEMODE},
    {"CmdSetClipRect", CMD_SETCLIPRECT},
    {"CmdSetClipPath", CMD_SETCLIPPATH},
    {"CmdSetR3Blackness", CMD_SETR3BLACKNESS},
    {"CmdSetR3PatInvert", CMD_SETR3PATINVERT},
    {"CmdSetR3SrcInvert", CMD_SETR3SRCINVERT},
    {"CmdSetR3MergePaint", CMD_SETR3MERGEPAINT},
    {"CmdSetR3MergeCopy", CMD_SETR3MERGECOPY},
    {"CmdSetR3SrcCopy", CMD_SETR3SRCCOPY},
    {"CmdSetR3SrcPaint", CMD_SETR3SRCPAINT},
    {"CmdSetR3PatCopy", CMD_SETR3PATCOPY},
    {"CmdSetR3PatPaint", CMD_SETR3PATPAINT},
    {"CmdSetR3Whiteness", CMD_SETR3WHITENESS},
    {"CmdSetR3Code", CMD_SETR3CODE},
#endif



    //  ---- reserved symbol names  for each construct keyword ---- //

    {NULL, CL_CONS_FEATURES},
    {"CL_CONS_FEATURES", 0},
    {"PaperSize", GID_PAGESIZE},
    {"Resolution", GID_RESOLUTION},
    {"MediaType", GID_MEDIATYPE},
    {"InputBin", GID_INPUTSLOT},
    {"Duplex", GID_DUPLEX},
    {"Memory", GID_MEMOPTION},
    {"ColorMode", GID_COLORMODE},
    {"Orientation", GID_ORIENTATION},
    {"Halftone", GID_HALFTONING},
    {"PageProtect", GID_PAGEPROTECTION},
    {"Collate", GID_COLLATE},
    {"OutputBin", GID_OUTPUTBIN},
    // "Stapling"   is a special Feature string recognized by the UI
    //  though it is not associated with a GID value.

    // all other predefined GIDs are Pscript specific.


    {NULL, CL_CONS_PAPERSIZE},
    {"CL_CONS_PAPERSIZE", 0},

    {"LETTER", DMPAPER_LETTER},
    {"LETTERSMALL", DMPAPER_LETTERSMALL},
    {"TABLOID", DMPAPER_TABLOID},
    {"LEDGER", DMPAPER_LEDGER},
    {"LEGAL", DMPAPER_LEGAL},
    {"STATEMENT", DMPAPER_STATEMENT},
    {"EXECUTIVE", DMPAPER_EXECUTIVE},
    {"A3", DMPAPER_A3},
    {"A4", DMPAPER_A4},
    {"A4SMALL", DMPAPER_A4SMALL},
    {"A5", DMPAPER_A5},
    {"B4", DMPAPER_B4},
    {"B5", DMPAPER_B5},
    {"FOLIO", DMPAPER_FOLIO},
    {"QUARTO", DMPAPER_QUARTO},
    {"10X14", DMPAPER_10X14},
    {"11X17", DMPAPER_11X17},
    {"NOTE", DMPAPER_NOTE},
    {"ENV_9", DMPAPER_ENV_9},
    {"ENV_10", DMPAPER_ENV_10},
    {"ENV_11", DMPAPER_ENV_11},
    {"ENV_12", DMPAPER_ENV_12},
    {"ENV_14", DMPAPER_ENV_14},
    {"CSHEET", DMPAPER_CSHEET},
    {"DSHEET", DMPAPER_DSHEET},
    {"ESHEET", DMPAPER_ESHEET},
    {"ENV_DL", DMPAPER_ENV_DL},
    {"ENV_C5", DMPAPER_ENV_C5},
    {"ENV_C3", DMPAPER_ENV_C3},
    {"ENV_C4", DMPAPER_ENV_C4},
    {"ENV_C6", DMPAPER_ENV_C6},
    {"ENV_C65", DMPAPER_ENV_C65},
    {"ENV_B4", DMPAPER_ENV_B4},
    {"ENV_B5", DMPAPER_ENV_B5},
    {"ENV_B6", DMPAPER_ENV_B6},
    {"ENV_ITALY", DMPAPER_ENV_ITALY},
    {"ENV_MONARCH", DMPAPER_ENV_MONARCH},
    {"ENV_PERSONAL", DMPAPER_ENV_PERSONAL},
    {"FANFOLD_US", DMPAPER_FANFOLD_US},
    {"FANFOLD_STD_GERMAN", DMPAPER_FANFOLD_STD_GERMAN},
    {"FANFOLD_LGL_GERMAN", DMPAPER_FANFOLD_LGL_GERMAN},
    {"ISO_B4", DMPAPER_ISO_B4},
    {"JAPANESE_POSTCARD", DMPAPER_JAPANESE_POSTCARD},
    {"9X11", DMPAPER_9X11},
    {"10X11", DMPAPER_10X11},
    {"15X11", DMPAPER_15X11},
    {"ENV_INVITE", DMPAPER_ENV_INVITE},
    {"LETTER_EXTRA", DMPAPER_LETTER_EXTRA},
    {"LEGAL_EXTRA", DMPAPER_LEGAL_EXTRA},
    {"TABLOID_EXTRA", DMPAPER_TABLOID_EXTRA},
    {"A4_EXTRA", DMPAPER_A4_EXTRA},
    {"LETTER_TRANSVERSE", DMPAPER_LETTER_TRANSVERSE},
    {"A4_TRANSVERSE", DMPAPER_A4_TRANSVERSE},
    {"LETTER_EXTRA_TRANSVERSE", DMPAPER_LETTER_EXTRA_TRANSVERSE},
    {"A_PLUS", DMPAPER_A_PLUS},
    {"B_PLUS", DMPAPER_B_PLUS},
    {"LETTER_PLUS", DMPAPER_LETTER_PLUS},
    {"A4_PLUS", DMPAPER_A4_PLUS},
    {"A5_TRANSVERSE", DMPAPER_A5_TRANSVERSE},
    {"B5_TRANSVERSE", DMPAPER_B5_TRANSVERSE},
    {"A3_EXTRA", DMPAPER_A3_EXTRA},
    {"A5_EXTRA", DMPAPER_A5_EXTRA},
    {"B5_EXTRA", DMPAPER_B5_EXTRA},
    {"A2", DMPAPER_A2},
    {"A3_TRANSVERSE", DMPAPER_A3_TRANSVERSE},
    {"A3_EXTRA_TRANSVERSE", DMPAPER_A3_EXTRA_TRANSVERSE},
    #ifndef WINNT_40
    {"DBL_JAPANESE_POSTCARD", DMPAPER_DBL_JAPANESE_POSTCARD},
    {"A6", DMPAPER_A6},
    {"JENV_KAKU2", DMPAPER_JENV_KAKU2},
    {"JENV_KAKU3", DMPAPER_JENV_KAKU3},
    {"JENV_CHOU3", DMPAPER_JENV_CHOU3},
    {"JENV_CHOU4", DMPAPER_JENV_CHOU4},
    {"LETTER_ROTATED", DMPAPER_LETTER_ROTATED},
    {"A3_ROTATED", DMPAPER_A3_ROTATED},
    {"A4_ROTATED", DMPAPER_A4_ROTATED},
    {"A5_ROTATED", DMPAPER_A5_ROTATED},
    {"B4_JIS_ROTATED", DMPAPER_B4_JIS_ROTATED},
    {"B5_JIS_ROTATED", DMPAPER_B5_JIS_ROTATED},
    {"JAPANESE_POSTCARD_ROTATED", DMPAPER_JAPANESE_POSTCARD_ROTATED},
    {"DBL_JAPANESE_POSTCARD_ROTATED", DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED},
    {"A6_ROTATED", DMPAPER_A6_ROTATED},
    {"JENV_KAKU2_ROTATED", DMPAPER_JENV_KAKU2_ROTATED},
    {"JENV_KAKU3_ROTATED", DMPAPER_JENV_KAKU3_ROTATED},
    {"JENV_CHOU3_ROTATED", DMPAPER_JENV_CHOU3_ROTATED},
    {"JENV_CHOU4_ROTATED", DMPAPER_JENV_CHOU4_ROTATED},
    {"B6_JIS", DMPAPER_B6_JIS},
    {"B6_JIS_ROTATED", DMPAPER_B6_JIS_ROTATED},
    {"12X11", DMPAPER_12X11},
    {"JENV_YOU4", DMPAPER_JENV_YOU4},
    {"JENV_YOU4_ROTATED", DMPAPER_JENV_YOU4_ROTATED},
    {"P16K", DMPAPER_P16K},
    {"P32K", DMPAPER_P32K},
    {"P32KBIG", DMPAPER_P32KBIG},
    {"PENV_1", DMPAPER_PENV_1},
    {"PENV_2", DMPAPER_PENV_2},
    {"PENV_3", DMPAPER_PENV_3},
    {"PENV_4", DMPAPER_PENV_4 },
    {"PENV_5", DMPAPER_PENV_5 },
    {"PENV_6", DMPAPER_PENV_6 },
    {"PENV_7", DMPAPER_PENV_7 },
    {"PENV_8", DMPAPER_PENV_8 },
    {"PENV_9", DMPAPER_PENV_9 },
    {"PENV_10", DMPAPER_PENV_10},
    {"P16K_ROTATED", DMPAPER_P16K_ROTATED},
    {"P32K_ROTATED", DMPAPER_P32K_ROTATED},
    {"P32KBIG_ROTATED", DMPAPER_P32KBIG_ROTATED  },
    {"PENV_1_ROTATED", DMPAPER_PENV_1_ROTATED   },
    {"PENV_2_ROTATED", DMPAPER_PENV_2_ROTATED   },
    {"PENV_3_ROTATED", DMPAPER_PENV_3_ROTATED   },
    {"PENV_4_ROTATED", DMPAPER_PENV_4_ROTATED   },
    {"PENV_5_ROTATED", DMPAPER_PENV_5_ROTATED  },
    {"PENV_6_ROTATED", DMPAPER_PENV_6_ROTATED  },
    {"PENV_7_ROTATED", DMPAPER_PENV_7_ROTATED   },
    {"PENV_8_ROTATED", DMPAPER_PENV_8_ROTATED   },
    {"PENV_9_ROTATED", DMPAPER_PENV_9_ROTATED   },
    {"PENV_10_ROTATED", DMPAPER_PENV_10_ROTATED  },
    #endif
    {"CUSTOMSIZE", DMPAPER_USER  },
    //   DMPAPER_USER and beyond



    {NULL, CL_CONS_MEDIATYPE},
    {"CL_CONS_MEDIATYPE", 0},
    {"STANDARD", DMMEDIA_STANDARD},
    {"TRANSPARENCY", DMMEDIA_TRANSPARENCY},
    {"GLOSSY", DMMEDIA_GLOSSY},
    //   DMMEDIA_USER and beyond



    {NULL, CL_CONS_INPUTSLOT},
    {"CL_CONS_INPUTSLOT", 0},
    {"FORMSOURCE", DMBIN_FORMSOURCE },
    {"UPPER", DMBIN_UPPER},
    {"LOWER", DMBIN_LOWER},
    {"MIDDLE", DMBIN_MIDDLE},
    {"MANUAL", DMBIN_MANUAL},
    {"ENVFEED", DMBIN_ENVELOPE},
    {"ENVMANUAL", DMBIN_ENVMANUAL},
    {"AUTO", DMBIN_AUTO},
    {"TRACTOR", DMBIN_TRACTOR},
    {"SMALLFMT", DMBIN_SMALLFMT},
    {"LARGEFMT", DMBIN_LARGEFMT},
    {"LARGECAPACITY", DMBIN_LARGECAPACITY},
    {"CASSETTE", DMBIN_CASSETTE},

    //   DMBIN_USER and beyond


    {NULL, CL_CONS_DUPLEX},
    {"CL_CONS_DUPLEX", 0},
    {"NONE", DMDUP_SIMPLEX},
    {"VERTICAL", DMDUP_VERTICAL},
    {"HORIZONTAL", DMDUP_HORIZONTAL},

    //  No custom options.


    {NULL, CL_CONS_ORIENTATION},
    {"CL_CONS_ORIENTATION", 0},
    {"PORTRAIT", ROTATE_NONE},
    {"LANDSCAPE_CC90", ROTATE_90},
    {"LANDSCAPE_CC270", ROTATE_270},
    //  No custom options.


    {NULL, CL_CONS_PAGEPROTECT},
    {"CL_CONS_PAGEPROTECT", 0},
    {"ON",  PAGEPRO_ON},
    {"OFF",  PAGEPRO_OFF},
    //  No custom options.


    {NULL, CL_CONS_COLLATE},
    {"CL_CONS_COLLATE", 0},
    {"ON",  DMCOLLATE_TRUE},
    {"OFF",  DMCOLLATE_FALSE},
    //  No custom options.

    {NULL, CL_CONS_HALFTONE},
    {"CL_CONS_HALFTONE", 0},
    {"HT_PATSIZE_2x2",  HT_PATSIZE_2x2},
    {"HT_PATSIZE_2x2_M",  HT_PATSIZE_2x2_M},
    {"HT_PATSIZE_4x4",  HT_PATSIZE_4x4},
    {"HT_PATSIZE_4x4_M",  HT_PATSIZE_4x4_M},
    {"HT_PATSIZE_6x6",  HT_PATSIZE_6x6},
    {"HT_PATSIZE_6x6_M",  HT_PATSIZE_6x6_M},
    {"HT_PATSIZE_8x8",  HT_PATSIZE_8x8},
    {"HT_PATSIZE_8x8_M",  HT_PATSIZE_8x8_M},
    {"HT_PATSIZE_10x10",  HT_PATSIZE_10x10},
    {"HT_PATSIZE_10x10_M",  HT_PATSIZE_10x10_M},
    {"HT_PATSIZE_12x12",  HT_PATSIZE_12x12},
    {"HT_PATSIZE_12x12_M",  HT_PATSIZE_12x12_M},
    {"HT_PATSIZE_14x14",  HT_PATSIZE_14x14},
    {"HT_PATSIZE_14x14_M",  HT_PATSIZE_14x14_M},
    {"HT_PATSIZE_16x16",  HT_PATSIZE_16x16},
    {"HT_PATSIZE_16x16_M",  HT_PATSIZE_16x16_M},
    #ifndef WINNT_40
    {"HT_PATSIZE_SUPERCELL",  HT_PATSIZE_SUPERCELL},
    {"HT_PATSIZE_SUPERCELL_M",  HT_PATSIZE_SUPERCELL_M},
    #endif
    {"HT_PATSIZE_AUTO",  HT_PATSIZE_AUTO},


    {NULL, CL_NUMCLASSES}         //  signifies end of table.
}  ;

// This global is now in gpdparse.h in the structure GLOBL
// CLASSINDEXENTRY  gcieTable[CL_NUMCLASSES] ;
//

CONST PBYTE   gpubStateNames[] =
{
    "STATE_ROOT",
    "STATE_UIGROUP",
    "STATE_FEATURE",
    "STATE_OPTIONS",
    "STATE_SWITCH_ROOT",
    "STATE_SWITCH_FEATURE",
    "STATE_SWITCH_OPTION",
    "STATE_CASE_ROOT",
    "STATE_DEFAULT_ROOT",
    "STATE_CASE_FEATURE",
    "STATE_DEFAULT_FEATURE",
    "STATE_CASE_OPTION",
    "STATE_DEFAULT_OPTION",
    "STATE_COMMAND",
    "STATE_FONTCART",
    "STATE_TTFONTSUBS",
    "STATE_OEM",
    //  any other passive construct
    "STATE_LAST",   //  must terminate list of valid states
    "STATE_INVALID"  //  must be after STATE_LAST
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\framwrk1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  framwrk.c - functions that tie different functions together.
    a supporting framework so to speak.

 History of Changes
  9/30/98 --hsingh--
          Added call to function BsetUQMFlag(). The function enables
          making the UpdateQualityMacro? keyword optional in
          .gpd file.

*/


#include    "gpdparse.h"
#include    "globals.h"


// ----  functions defined in  framwrk.c ---- //


BOOL   BcreateGPDbinary(
PWSTR   pwstrFileName,
DWORD   dwVerbosity)  ;

VOID      VinitMainKeywordTable(
PGLOBL  pglobl)  ;

DWORD        DWinitMainKeywordTable1(
        DWORD  dwI,
    PGLOBL pglobl) ;

DWORD        DWinitMainKeywordTable2(
        DWORD  dwI,
    PGLOBL pglobl) ;

DWORD        DWinitMainKeywordTable3(
        DWORD  dwI,
    PGLOBL pglobl) ;

DWORD        DWinitMainKeywordTable4(
        DWORD  dwI,
    PGLOBL pglobl) ;

DWORD        DWinitMainKeywordTable5(
        DWORD  dwI,
    PGLOBL pglobl) ;


VOID    VinitValueToSize(
PGLOBL  pglobl) ;

VOID  VinitGlobals(
DWORD   dwVerbosity,
PGLOBL  pglobl);

BOOL   BpreAllocateObjects(
PGLOBL  pglobl) ;

BOOL  BreturnBuffers(
PGLOBL  pglobl) ;

BOOL   BallocateCountableObjects(
PGLOBL  pglobl) ;

BOOL   BinitPreAllocatedObjects(
PGLOBL  pglobl) ;

BOOL   BinitCountableObjects(
PGLOBL  pglobl) ;

BOOL  BevaluateMacros(
PGLOBL  pglobl) ;

BOOL BpostProcess(
PWSTR   pwstrFileName,
PGLOBL  pglobl)  ;

BOOL    BconsolidateBuffers(
PWSTR   pwstrFileName,
PGLOBL  pglobl)  ;

BOOL    BexpandMemConfigShortcut(DWORD       dwSubType) ;

BOOL    BexpandCommandShortcut(DWORD       dwSubType) ;



// ---------------------------------------------------- //

BOOL   BcreateGPDbinary(
PWSTR   pwstrFileName,   // root GPD file
DWORD   dwVerbosity )  // Verbosity Level
{
    BOOL    bStatus ;
    GLOBL   globl;

    PGLOBL pglobl = &globl;

    // check. Temporary global.
    // check. pglobl = &globl;

    VinitGlobals(dwVerbosity, &globl) ;

    while(geErrorSev < ERRSEV_FATAL)
    {
        bStatus = BpreAllocateObjects(&globl) ;


        if(bStatus)
        {
            bStatus = BinitPreAllocatedObjects(&globl) ;
        }
        if(bStatus)
        {
            bStatus = BcreateTokenMap(pwstrFileName, &globl ) ;
        }
        if(bStatus)
        {
            bStatus = BexpandShortcuts(&globl) ;
        }
        if(bStatus)
        {
            bStatus = BevaluateMacros(&globl)  ;
        }
        if(bStatus)
        {
            bStatus = BInterpretTokens((PTKMAP)gMasterTable[MTI_NEWTOKENMAP].
                pubStruct,   TRUE, &globl ) ;  // is first pass
        }
        if(bStatus)
        {
            bStatus = BallocateCountableObjects(&globl) ;
        }
        if(bStatus)
        {
            bStatus = BinitCountableObjects(&globl) ;
        }
        if(bStatus)
        {
            bStatus = BInterpretTokens((PTKMAP)gMasterTable[MTI_NEWTOKENMAP].
                pubStruct,   FALSE, &globl ) ;  // second pass
        }
        if(bStatus)
        {
            bStatus = BpostProcess(pwstrFileName, &globl) ;
        }
        ;  // execution reaches here regardless
                    //  sets error code if needed.
        if(BreturnBuffers(&globl) )  // clears ERRSEV_RESTART but
        {                      // returns FALSE in this case.
            if(geErrorSev < ERRSEV_RESTART)
            {
                return(bStatus) ;  // escape
            }
        }
    }
    return(FALSE) ;  // died due to Fatal , unrecoverable error.
} // BcreateGPDbinary(...)


VOID      VinitMainKeywordTable(
    PGLOBL pglobl)
{
    DWORD  dwI = 0 ;  //  index to MainKeywordTable.

    dwI =   DWinitMainKeywordTable1(dwI,  pglobl) ;
    dwI =   DWinitMainKeywordTable2(dwI,  pglobl) ;
    dwI =   DWinitMainKeywordTable3(dwI,  pglobl) ;
    dwI =   DWinitMainKeywordTable4(dwI,  pglobl) ;
    dwI =   DWinitMainKeywordTable5(dwI,  pglobl) ;

    if(dwI >= gMasterTable[MTI_MAINKEYWORDTABLE].dwArraySize)
        RIP(("Too many entries to fit inside MainKeywordTable\n"));
}

DWORD        DWinitMainKeywordTable1(
        DWORD  dwI,
    PGLOBL pglobl)
/*
    note:
    VinitDictionaryIndex()  assumes the MainKeywordTable
    is divided into sections.  Each section is terminated by
    a NULL entry, that is an entry where pstrKeyword = NULL.
    The sections and their order in the KeywordTable are defined
    by the enum   KEYWORD_SECTS.   Make sure the MainKeywordTable
    has enough slots to hold all entries defined here.
*/
{
    /*  NON_ATTR  - constructs and special keywords. */

    //  *UIGroup:
    mMainKeywordTable[dwI].pstrKeyword  = "UIGroup" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_UIGROUP ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *Feature:
    mMainKeywordTable[dwI].pstrKeyword  = "Feature" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_FEATURE ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *Option:
    mMainKeywordTable[dwI].pstrKeyword  = "Option" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_OPTION ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    gdwOptionConstruct = dwI ;
    dwI++ ;


    //  *switch:
    mMainKeywordTable[dwI].pstrKeyword  = "switch" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_SWITCH ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *case:
    mMainKeywordTable[dwI].pstrKeyword  = "case" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_CASE  ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *Switch:
    mMainKeywordTable[dwI].pstrKeyword  = "Switch" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_SWITCH ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *Case:
    mMainKeywordTable[dwI].pstrKeyword  = "Case" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_CASE  ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *default:
    mMainKeywordTable[dwI].pstrKeyword  = "default" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_DEFAULT ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *Command:
    mMainKeywordTable[dwI].pstrKeyword  = "Command" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_COMMAND ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    gdwCommandConstruct  = dwI ;
    dwI++ ;

    //  *FontCartridge:
    mMainKeywordTable[dwI].pstrKeyword  = "FontCartridge" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_FONTCART ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *TTFS:
    mMainKeywordTable[dwI].pstrKeyword  = "TTFS" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_TTFONTSUBS ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *OEM:
    mMainKeywordTable[dwI].pstrKeyword  = "OEM" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_OEM  ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;



    //  BlockMacro:
    mMainKeywordTable[dwI].pstrKeyword  = "BlockMacro" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_DEF  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_BLOCKMACRO ;
    mMainKeywordTable[dwI].dwOffset = 0 ;  // not used
    dwI++ ;

    //  Macros:
    mMainKeywordTable[dwI].pstrKeyword  = "Macros" ;
    mMainKeywordTable[dwI].eAllowedValue = NO_VALUE  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_MACROS;
    mMainKeywordTable[dwI].dwOffset = 0 ;  // not used
    dwI++ ;

    //  {:
    mMainKeywordTable[dwI].pstrKeyword  = "{" ;
    mMainKeywordTable[dwI].eAllowedValue = NO_VALUE  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_OPENBRACE ;
    mMainKeywordTable[dwI].dwOffset = 0 ;  // not used
    gdwOpenBraceConstruct  = dwI ;
    dwI++ ;

    //  }:
    mMainKeywordTable[dwI].pstrKeyword  = "}" ;
    mMainKeywordTable[dwI].eAllowedValue = NO_VALUE  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_CONSTRUCT ;
    mMainKeywordTable[dwI].dwSubType = CONSTRUCT_CLOSEBRACE ;
    mMainKeywordTable[dwI].dwOffset = 0 ;  // not used
    gdwCloseBraceConstruct = dwI ;
    dwI++ ;


    //  end of constructs.

    //  *Include:
    mMainKeywordTable[dwI].pstrKeyword  = "Include" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_DEF_CONVERT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_INCLUDE ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;

    //  *InsertBlock:
    mMainKeywordTable[dwI].pstrKeyword  = "InsertBlock" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_BLOCKMACRO ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_INSERTBLOCK ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    dwI++ ;


    //  *IgnoreBlock:
    mMainKeywordTable[dwI].pstrKeyword  = "IgnoreBlock" ;
    mMainKeywordTable[dwI].eAllowedValue = NO_VALUE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_IGNOREBLOCK ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    gdwID_IgnoreBlock = dwI ;
    dwI++ ;


    //  *InvalidCombination:
    mMainKeywordTable[dwI].pstrKeyword  = "InvalidCombination" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_INVALID_COMBO ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                            atrInvalidCombos) ;
    dwI++ ;

    //  *InvalidInstallableCombination:
    mMainKeywordTable[dwI].pstrKeyword  = "InvalidInstallableCombination" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARTIALLY_QUALIFIED_NAME ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_INVALID_INS_COMBO ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrInvldInstallCombo) ;
    dwI++ ;

    //  *Cmd:
//    mMainKeywordTable[dwI].pstrKeyword  = "Cmd" ;
//    mMainKeywordTable[dwI].eAllowedValue = VALUE_COMMAND_SHORTCUT ;
//    mMainKeywordTable[dwI].flAgs = KWF_SHORTCUT  ;
//    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
//    mMainKeywordTable[dwI].dwSubType = SPEC_COMMAND_SHORTCUT ;
//    mMainKeywordTable[dwI].dwOffset = 0 ;
//    dwI++ ;



    //  *TTFS:
//    mMainKeywordTable[dwI].pstrKeyword  = "TTFS" ;
//    mMainKeywordTable[dwI].eAllowedValue = VALUE_FONTSUB ;
//    mMainKeywordTable[dwI].flAgs = KWF_SHORTCUT ;
//    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
//    mMainKeywordTable[dwI].dwSubType = SPEC_TTFS ;
//    mMainKeywordTable[dwI].dwOffset = 0 ;
//    dwI++ ;



    // these memconfig keywords must be expanded into
    // options.

    //  *MemConfigKB:
    mMainKeywordTable[dwI].pstrKeyword  = "MemConfigKB" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT ;
    mMainKeywordTable[dwI].flAgs = KWF_SHORTCUT ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_MEM_CONFIG_KB ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    gdwMemConfigKB = dwI ;

    dwI++ ;

    //  *MemConfigMB:
    mMainKeywordTable[dwI].pstrKeyword  = "MemConfigMB" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT ;
    mMainKeywordTable[dwI].flAgs = KWF_SHORTCUT ;
    mMainKeywordTable[dwI].eType = TY_SPECIAL ;
    mMainKeywordTable[dwI].dwSubType = SPEC_MEM_CONFIG_MB ;
    mMainKeywordTable[dwI].dwOffset = 0 ;
    gdwMemConfigMB = dwI ;
    dwI++ ;

    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;

    return  dwI ;
}

DWORD        DWinitMainKeywordTable2(
        DWORD  dwI,
    PGLOBL pglobl)
{


    /* ---- GLOBAL  Construct keywords: ----- */

    //  *GPDSpecVersion:
    mMainKeywordTable[dwI].pstrKeyword  = "GPDSpecVersion" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_NO_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrGPDSpecVersion) ;
    dwI++ ;

    //  *MasterUnits:
    mMainKeywordTable[dwI].pstrKeyword  = "MasterUnits" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMasterUnits) ;
    dwI++ ;


    //  *ModelName:
    mMainKeywordTable[dwI].pstrKeyword  = "ModelName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrModelName) ;
    dwI++ ;

    //  *rcModelNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcModelNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrModelNameID) ;
    dwI++ ;


    //  *GPDFileVersion:
    mMainKeywordTable[dwI].pstrKeyword  = "GPDFileVersion" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_NO_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrGPDFileVersion) ;
    dwI++ ;

    //  *GPDFileName:
    mMainKeywordTable[dwI].pstrKeyword  = "GPDFileName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_DEF_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrGPDFileName) ;
    dwI++ ;



    //  *InstalledOptionName:
    mMainKeywordTable[dwI].pstrKeyword  = "InstalledOptionName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrNameInstalled) ;
    dwI++ ;

    //  *rcInstalledOptionNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcInstalledOptionNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrNameIDInstalled) ;
    dwI++ ;


    //  *NotInstalledOptionName:
    mMainKeywordTable[dwI].pstrKeyword  = "NotInstalledOptionName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrNameNotInstalled) ;
    dwI++ ;

    //  *rcNotInstalledOptionNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcNotInstalledOptionNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrNameIDNotInstalled) ;
    dwI++ ;

    //  *DraftQualitySettings:
    mMainKeywordTable[dwI].pstrKeyword  = "DraftQualitySettings" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME  ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDraftQualitySettings) ;
    dwI++ ;

    //  *BetterQualitySettings:
    mMainKeywordTable[dwI].pstrKeyword  = "BetterQualitySettings" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME  ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrBetterQualitySettings) ;
    dwI++ ;

    //  *BestQualitySettings:
    mMainKeywordTable[dwI].pstrKeyword  = "BestQualitySettings" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME  ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrBestQualitySettings) ;
    dwI++ ;

    //  *DefaultQuality:
    mMainKeywordTable[dwI].pstrKeyword  = "DefaultQuality" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_QUALITYSETTING  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDefaultQuality) ;
    dwI++ ;

    //  *PrinterType:
    mMainKeywordTable[dwI].pstrKeyword  = "PrinterType" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PRINTERTYPE  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPrinterType) ;
    dwI++ ;

    //  *Personality:
    mMainKeywordTable[dwI].pstrKeyword  = "Personality" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPersonality) ;
    dwI++ ;

    //  *rcPersonalityID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPersonalityID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRcPersonalityID) ;
    dwI++ ;

    //  *ResourceDLL:
    mMainKeywordTable[dwI].pstrKeyword  = "ResourceDLL" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_DEF_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrResourceDLL) ;
    dwI++ ;

    //  *CodePage:
    mMainKeywordTable[dwI].pstrKeyword  = "CodePage" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCodePage) ;
    dwI++ ;

    //  *MaxCopies:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxCopies" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxCopies) ;
    dwI++ ;

    //  *FontCartSlots:
    mMainKeywordTable[dwI].pstrKeyword  = "FontCartSlots" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrFontCartSlots) ;
    dwI++ ;

    //  *MaxPrintableArea:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxPrintableArea" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT  ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxPrintableArea) ;
    dwI++ ;

    //  *OutputDataFormat:
    mMainKeywordTable[dwI].pstrKeyword  = "OutputDataFormat" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_OUTPUTDATAFORMAT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrOutputDataFormat) ;
    dwI++ ;

    //  *LookaheadRegion:
    mMainKeywordTable[dwI].pstrKeyword  = "LookAheadRegion" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrLookaheadRegion) ;
    dwI++ ;

    //  *rcPrinterIconID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPrinterIconID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPrinterIcon) ;
    dwI++ ;

    //  *HelpFile:
    mMainKeywordTable[dwI].pstrKeyword  = "HelpFile" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_DEF_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrHelpFile) ;
    dwI++ ;

    //  *OEMCustomData:
    mMainKeywordTable[dwI].pstrKeyword  = "OEMCustomData" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_NO_CONVERT  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrOEMCustomData) ;
    dwI++ ;



    //
    // Printer Capabilities related information
    //

    //  *RotateCoordinate?:
    mMainKeywordTable[dwI].pstrKeyword  = "RotateCoordinate?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRotateCoordinate) ;
    dwI++ ;

    //  *RasterCaps:
    mMainKeywordTable[dwI].pstrKeyword  = "RasterCaps" ;
    mMainKeywordTable[dwI].eAllowedValue =  VALUE_CONSTANT_RASTERCAPS ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRasterCaps) ;
    dwI++ ;

    //  *RotateRaster?:
    mMainKeywordTable[dwI].pstrKeyword  = "RotateRaster?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRotateRasterData) ;
    dwI++ ;

    //  *TextCaps:
    mMainKeywordTable[dwI].pstrKeyword  = "TextCaps" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_TEXTCAPS ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrTextCaps) ;
    dwI++ ;

    //  *RotateFont?:
    mMainKeywordTable[dwI].pstrKeyword  = "RotateFont?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRotateFont) ;
    dwI++ ;

    //  *MemoryUsage:
    mMainKeywordTable[dwI].pstrKeyword  = "MemoryUsage" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_MEMORYUSAGE ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMemoryUsage) ;
    dwI++ ;

    //  *ReselectFont:
    mMainKeywordTable[dwI].pstrKeyword  = "ReselectFont" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_RESELECTFONT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrReselectFont) ;
    dwI++ ;

    //  *PrintRate:
    mMainKeywordTable[dwI].pstrKeyword  = "PrintRate" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER   ;
    mMainKeywordTable[dwI].flAgs = 0  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPrintRate) ;

    dwI++ ;

    #ifndef WINNT_40
    //  *PrintRateUnit:
    mMainKeywordTable[dwI].pstrKeyword  = "PrintRateUnit" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PRINTRATEUNIT ;
    mMainKeywordTable[dwI].flAgs = 0  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPrintRateUnit) ;
    dwI++ ;
    #endif

    //  *PrintRatePPM:
    mMainKeywordTable[dwI].pstrKeyword  = "PrintRatePPM" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPrintRatePPM) ;
    dwI++ ;


     //  *OutputOrderReversed?:
     //   note this keyword is also an option Keyword with type:
     //   ATT_LOCAL_OPTION_ONLY
     mMainKeywordTable[dwI].pstrKeyword  = "OutputOrderReversed?" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
     mMainKeywordTable[dwI].flAgs = 0 ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
     mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                         atrOutputOrderReversed) ;
     dwI++ ;


     //  *ReverseBandOrderForEvenPages?:
     //   special flag for HP970C  with AutoDuplexer
     //
     mMainKeywordTable[dwI].pstrKeyword  = "ReverseBandOrderForEvenPages?" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
     mMainKeywordTable[dwI].flAgs = 0 ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
     mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                         atrReverseBandOrderForEvenPages) ;
     dwI++ ;


     //  *OEMPrintingCallbacks:
     mMainKeywordTable[dwI].pstrKeyword  = "OEMPrintingCallbacks" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_OEMPRINTINGCALLBACKS ;
     mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_ONLY ;
     mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                         atrOEMPrintingCallbacks) ;
     dwI++ ;


    //
    // Cursor Control related information
    //


    //  *CursorXAfterCR:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorXAfterCR" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CURSORXAFTERCR  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterCR) ;
    dwI++ ;

    //  *BadCursorMoveInGrxMode:
    mMainKeywordTable[dwI].pstrKeyword  = "BadCursorMoveInGrxMode" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BADCURSORMOVEINGRXMODE ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrBadCursorMoveInGrxMode) ;
    dwI++ ;

    //  *YMoveAttributes:
    mMainKeywordTable[dwI].pstrKeyword  = "YMoveAttributes" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_YMOVEATTRIB ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrYMoveAttributes) ;
    dwI++ ;

    //  *MaxLineSpacing:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxLineSpacing" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxLineSpacing) ;
    dwI++ ;


    //  *UseSpaceForXMove?:
    mMainKeywordTable[dwI].pstrKeyword  = "UseSpaceForXMove?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrbUseSpaceForXMove) ;
    dwI++ ;

    //  *AbsXMovesRightOnly?:
    mMainKeywordTable[dwI].pstrKeyword  = "AbsXMovesRightOnly?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrbAbsXMovesRightOnly) ;
    dwI++ ;



#if 0
    //  *SimulateXMove:
    mMainKeywordTable[dwI].pstrKeyword  = "SimulateXMove" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_SIMULATEXMOVE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrSimulateXMove) ;
    dwI++ ;
#endif

    //  *EjectPageWithFF?:
    mMainKeywordTable[dwI].pstrKeyword  = "EjectPageWithFF?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrEjectPageWithFF) ;
    dwI++ ;

    //  *XMoveThreshold:
    mMainKeywordTable[dwI].pstrKeyword  = "XMoveThreshold" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrXMoveThreshold) ;
    dwI++ ;

    //  *YMoveThreshold:
    mMainKeywordTable[dwI].pstrKeyword  = "YMoveThreshold" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrYMoveThreshold) ;
    dwI++ ;

    //  *XMoveUnit:
    mMainKeywordTable[dwI].pstrKeyword  = "XMoveUnit" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrXMoveUnits) ;
    dwI++ ;

    //  *YMoveUnit:
    mMainKeywordTable[dwI].pstrKeyword  = "YMoveUnit" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrYMoveUnits) ;
    dwI++ ;


    //  *LineSpacingMoveUnit:
    mMainKeywordTable[dwI].pstrKeyword  = "LineSpacingMoveUnit" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrLineSpacingMoveUnit) ;
    dwI++ ;




    return  dwI ;
}

DWORD        DWinitMainKeywordTable3(
        DWORD  dwI,
    PGLOBL pglobl)
{



    //
    // Color related information
    //



    //  *ChangeColorModeOnPage?:
    mMainKeywordTable[dwI].pstrKeyword  = "ChangeColorModeOnPage?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrChangeColorMode) ;
    dwI++ ;

    //  *ChangeColorModeOnDoc?:
    mMainKeywordTable[dwI].pstrKeyword  = "ChangeColorModeOnDoc?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrChangeColorModeDoc) ;
    dwI++ ;

    //  *MagentaInCyanDye:
    mMainKeywordTable[dwI].pstrKeyword  = "MagentaInCyanDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMagentaInCyanDye) ;
    dwI++ ;

    //  *YellowInCyanDye:
    mMainKeywordTable[dwI].pstrKeyword  = "YellowInCyanDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrYellowInCyanDye) ;
    dwI++ ;

    //  *CyanInMagentaDye:
    mMainKeywordTable[dwI].pstrKeyword  = "CyanInMagentaDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCyanInMagentaDye) ;
    dwI++ ;

    //  *YellowInMagentaDye:
    mMainKeywordTable[dwI].pstrKeyword  = "YellowInMagentaDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrYellowInMagentaDye) ;
    dwI++ ;

    //  *CyanInYellowDye:
    mMainKeywordTable[dwI].pstrKeyword  = "CyanInYellowDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCyanInYellowDye) ;
    dwI++ ;

    //  *MagentaInYellowDye:
    mMainKeywordTable[dwI].pstrKeyword  = "MagentaInYellowDye" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMagentaInYellowDye) ;
    dwI++ ;

    //  *UseExpColorSelectCmd?:
    mMainKeywordTable[dwI].pstrKeyword  = "UseExpColorSelectCmd?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrUseColorSelectCmd) ;
    dwI++ ;

    //  *MoveToX0BeforeSetColor?:
    mMainKeywordTable[dwI].pstrKeyword  = "MoveToX0BeforeSetColor?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMoveToX0BeforeColor) ;
    dwI++ ;

    //  *EnableGDIColorMapping?:
    mMainKeywordTable[dwI].pstrKeyword  = "EnableGDIColorMapping?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrEnableGDIColorMapping) ;
    dwI++ ;

//    obsolete fields
    //  *MaxNumPalettes:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxNumPalettes" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxNumPalettes) ;
    dwI++ ;

#if 0

    //  *PaletteSizes:
    mMainKeywordTable[dwI].pstrKeyword  = "PaletteSizes" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPaletteSizes) ;
    dwI++ ;

    //  *PaletteScope:
    mMainKeywordTable[dwI].pstrKeyword  = "PaletteScope" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PALETTESCOPE ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrPaletteScope) ;
    dwI++ ;

#endif

    //  *MinOverlayID:
    mMainKeywordTable[dwI].pstrKeyword  = "MinOverlayID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMinOverlayID) ;
    dwI++ ;

    //  *MaxOverlayID:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxOverlayID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxOverlayID) ;
    dwI++ ;

    //  *OptimizeLeftBound?:
    mMainKeywordTable[dwI].pstrKeyword  = "OptimizeLeftBound?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrOptimizeLeftBound) ;
    dwI++ ;

    //  *StripBlanks:
    mMainKeywordTable[dwI].pstrKeyword  = "StripBlanks" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_STRIPBLANKS ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrStripBlanks) ;
    dwI++ ;

    //  *LandscapeGrxRotation:
    mMainKeywordTable[dwI].pstrKeyword  = "LandscapeGrxRotation" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_LANDSCAPEGRXROTATION ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrLandscapeGrxRotation) ;
    dwI++ ;

    //  *RasterZeroFill?:
    mMainKeywordTable[dwI].pstrKeyword  = "RasterZeroFill?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRasterZeroFill) ;
    dwI++ ;

    //  *RasterSendAllData?:
    mMainKeywordTable[dwI].pstrKeyword  = "RasterSendAllData?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRasterSendAllData) ;
    dwI++ ;

    //  *SendMultipleRows?:
    mMainKeywordTable[dwI].pstrKeyword  = "SendMultipleRows?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrSendMultipleRows) ;
    dwI++ ;

    //  *MaxMultipleRowBytes:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxMultipleRowBytes" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxMultipleRowBytes) ;
    dwI++ ;

    //  *CursorXAfterSendBlockData:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorXAfterSendBlockData" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CURSORXAFTERSENDBLOCKDATA ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterSendBlockData) ;
    dwI++ ;

    //  *CursorYAfterSendBlockData:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorYAfterSendBlockData" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CURSORYAFTERSENDBLOCKDATA ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCursorYAfterSendBlockData) ;
    dwI++ ;

    //  *MirrorRasterByte?:
    mMainKeywordTable[dwI].pstrKeyword  = "MirrorRasterByte?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMirrorRasterByte) ;
    dwI++ ;

    //  *MirrorRasterPage?
    mMainKeywordTable[dwI].pstrKeyword  = "MirrorRasterPage?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMirrorRasterPage) ;
    dwI++ ;


    //  *DeviceFonts:     formerly known as *Font:
    mMainKeywordTable[dwI].pstrKeyword  = "DeviceFonts" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_ADDITIVE ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT  ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDeviceFontsList ) ;
    dwI++ ;

    //  *DefaultFont:
    mMainKeywordTable[dwI].pstrKeyword  = "DefaultFont" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDefaultFont) ;
    dwI++ ;

    //  *TTFSEnabled?:
    mMainKeywordTable[dwI].pstrKeyword  = "TTFSEnabled?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrTTFSEnabled ) ;
    dwI++ ;

    //  *RestoreDefaultFont?:
    mMainKeywordTable[dwI].pstrKeyword  = "RestoreDefaultFont?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRestoreDefaultFont) ;
    dwI++ ;

    //  *DefaultCTT:
    mMainKeywordTable[dwI].pstrKeyword  = "DefaultCTT" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDefaultCTT) ;
    dwI++ ;

    //  *MaxFontUsePerPage:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxFontUsePerPage" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxFontUsePerPage) ;
    dwI++ ;

    //  *RotateFont?:
    mMainKeywordTable[dwI].pstrKeyword  = "RotateFont?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrRotateFont) ;
    dwI++ ;

    //  *TextYOffset:
    mMainKeywordTable[dwI].pstrKeyword  = "TextYOffset" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrTextYOffset) ;
    dwI++ ;

    //  *CharPosition:
    mMainKeywordTable[dwI].pstrKeyword  = "CharPosition" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CHARPOSITION ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCharPosition) ;
    dwI++ ;

    // ------- Font Downloading

    //  *MinFontID:
    mMainKeywordTable[dwI].pstrKeyword  = "MinFontID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMinFontID) ;
    dwI++ ;

    //  *MaxFontID:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxFontID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxFontID) ;
    dwI++ ;

    //  *MaxNumDownFonts:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxNumDownFonts" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxNumDownFonts) ;
    dwI++ ;

    //  *DLSymbolSet:
    mMainKeywordTable[dwI].pstrKeyword  = "DLSymbolSet" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_DLSYMBOLSET  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDLSymbolSet) ;
    dwI++ ;

    //  *MinGlyphID:
    mMainKeywordTable[dwI].pstrKeyword  = "MinGlyphID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMinGlyphID) ;
    dwI++ ;

    //  *MaxGlyphID:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxGlyphID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxGlyphID) ;
    dwI++ ;

    //  *IncrementalDownload?:
    mMainKeywordTable[dwI].pstrKeyword  = "IncrementalDownload?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrIncrementalDownload) ;
    dwI++ ;

    //  *FontFormat:
    mMainKeywordTable[dwI].pstrKeyword  = "FontFormat" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_FONTFORMAT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrFontFormat) ;
    dwI++ ;

    //  *MemoryUsage:
    mMainKeywordTable[dwI].pstrKeyword  = "MemoryUsage" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMemoryForFontsOnly) ;
    dwI++ ;

    //  *DiffFontsPerByteMode?:
    mMainKeywordTable[dwI].pstrKeyword  = "DiffFontsPerByteMode?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrDiffFontsPerByteMode) ;
    dwI++ ;

    // -----

    //  *CursorXAfterRectFill:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorXAfterRectFill" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CURXAFTER_RECTFILL ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterRectFill) ;
    dwI++ ;

    //  *CursorYAfterRectFill:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorYAfterRectFill" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_CURYAFTER_RECTFILL ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrCursorYAfterRectFill) ;
    dwI++ ;

    //  *MinGrayFill:
    mMainKeywordTable[dwI].pstrKeyword  = "MinGrayFill" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMinGrayFill) ;
    dwI++ ;

    //  *MaxGrayFill:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxGrayFill" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrMaxGrayFill) ;
    dwI++ ;

    //  *TextHalftoneThreshold:
    mMainKeywordTable[dwI].pstrKeyword  = "TextHalftoneThreshold" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_GLOBAL_FREEFLOAT ;
    mMainKeywordTable[dwI].dwOffset = offsetof(GLOBALATTRIB,
                                        atrTextHalftoneThreshold) ;
    dwI++ ;




    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;


    return  dwI ;
}

DWORD        DWinitMainKeywordTable4(
        DWORD  dwI,
    PGLOBL pglobl)
{



    /* ---- FEATURE  Construct keywords: ----- */

    //  *FeatureType:
    mMainKeywordTable[dwI].pstrKeyword  = "FeatureType" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_FEATURETYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeatureType) ;
    dwI++ ;

    //  *UIType:     aka  PickMany?
    mMainKeywordTable[dwI].pstrKeyword  = "UIType" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_UITYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrUIType) ;
    dwI++ ;

    //  *DefaultOption:
    mMainKeywordTable[dwI].pstrKeyword  = "DefaultOption" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_SYMBOL_OPTIONS ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrDefaultOption) ;
    dwI++ ;

    //  *ConflictPriority:
    mMainKeywordTable[dwI].pstrKeyword  = "ConflictPriority" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPriority ) ;
    dwI++ ;

    //  *Installable?:
    mMainKeywordTable[dwI].pstrKeyword  = "Installable?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaInstallable) ;
    dwI++ ;

    //  *InstallableFeatureName:
    mMainKeywordTable[dwI].pstrKeyword  = "InstallableFeatureName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrInstallableFeaDisplayName ) ;
    dwI++ ;

    //  *rcInstallableFeatureNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcInstallableFeatureNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrInstallableFeaRcNameID) ;
    dwI++ ;

    //  *Name:
    mMainKeywordTable[dwI].pstrKeyword  = "Name" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaDisplayName ) ;
    dwI++ ;

    //  *rcNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcNameID) ;
    dwI++ ;

    //  *rcIconID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcIconID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcIconID) ;
    dwI++ ;

    //  *rcHelpTextID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcHelpTextID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcHelpTextID) ;
    dwI++ ;

    //  *rcPromptMsgID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPromptMsgID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcPromptMsgID) ;
    dwI++ ;

    //  *rcPromptTime:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPromptTime" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PROMPTTIME ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcPromptTime) ;
    dwI++ ;

    //  *ConcealFromUI?:
    mMainKeywordTable[dwI].pstrKeyword  = "ConcealFromUI?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrConcealFromUI) ;
    dwI++ ;

    //  *UpdateQualityMacro?:
    mMainKeywordTable[dwI].pstrKeyword  = "UpdateQualityMacro?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrUpdateQualityMacro) ;
    dwI++ ;

    //  *HelpIndex:
    mMainKeywordTable[dwI].pstrKeyword  = "HelpIndex" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaHelpIndex) ;
    dwI++ ;

    //  *QueryOptionList:     BUG_BUG!  not supported in 5.0
    mMainKeywordTable[dwI].pstrKeyword  = "QueryOptionList" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrQueryOptionList) ;
    dwI++ ;

    //  *QueryDataType:
    mMainKeywordTable[dwI].pstrKeyword  = "QueryDataType" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_QUERYDATATYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrQueryDataType) ;
    dwI++ ;

    //  *QueryDefaultOption:     BUG_BUG!  not supported in 5.0
    mMainKeywordTable[dwI].pstrKeyword  = "QueryDefaultOption" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrQueryDefaultOption) ;
    dwI++ ;

    //  *InstalledConstraints:
    mMainKeywordTable[dwI].pstrKeyword  = "InstalledConstraints" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTRAINT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaInstallConstraints) ;
    dwI++ ;

    //  *NotInstalledConstraints:
    mMainKeywordTable[dwI].pstrKeyword  = "NotInstalledConstraints" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTRAINT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeaNotInstallConstraints) ;
    dwI++ ;


    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;


    /* ---- OPTION  Construct keywords: ----- */

    //  *Installable?:
    mMainKeywordTable[dwI].pstrKeyword  = "Installable?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptInstallable) ;
    dwI++ ;

    //  *InstallableFeatureName:
    mMainKeywordTable[dwI].pstrKeyword  = "InstallableFeatureName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrInstallableOptDisplayName ) ;
    dwI++ ;

    //  *rcInstallableFeatureNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcInstallableFeatureNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrInstallableOptRcNameID) ;
    dwI++ ;

    //  *Name:
    mMainKeywordTable[dwI].pstrKeyword  = "Name" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptDisplayName ) ;
    gdwOptionName = dwI ;
    dwI++ ;

    //  *rcNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcNameID) ;
    dwI++ ;

    //  *rcIconID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcIconID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcIconID) ;
    dwI++ ;

    //  *rcHelpTextID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcHelpTextID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcHelpTextID) ;
    dwI++ ;

    //  *HelpIndex:
    mMainKeywordTable[dwI].pstrKeyword  = "HelpIndex" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptHelpIndex) ;
    dwI++ ;

    //  *rcPromptMsgID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPromptMsgID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcPromptMsgID) ;
    dwI++ ;

    //  *rcPromptTime:
    mMainKeywordTable[dwI].pstrKeyword  = "rcPromptTime" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PROMPTTIME ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcPromptTime) ;
    dwI++ ;

    //  *Constraints:
    mMainKeywordTable[dwI].pstrKeyword  = "Constraints" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTRAINT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrConstraints) ;
    dwI++ ;

    //  *InstalledConstraints:
    mMainKeywordTable[dwI].pstrKeyword  = "InstalledConstraints" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTRAINT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptInstallConstraints) ;
    dwI++ ;

    //  *NotInstalledConstraints:
    mMainKeywordTable[dwI].pstrKeyword  = "NotInstalledConstraints" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTRAINT ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptNotInstallConstraints) ;
    dwI++ ;

    //  *OptionID:
    mMainKeywordTable[dwI].pstrKeyword  = "OptionID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    dwI++ ;

         //  *DisabledFeatures:
     mMainKeywordTable[dwI].pstrKeyword  = "DisabledFeatures" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_PARTIALLY_QUALIFIED_NAME ;
     mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_ADDITIVE ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
     mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                         atrDisabledFeatures) ;
     dwI++ ;


#ifdef  GMACROS

         //  *DependentSettings:
     mMainKeywordTable[dwI].pstrKeyword  = "DependentSettings" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME ;
     mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_CHAIN ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
     mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                         atrDependentSettings) ;
     dwI++ ;

         //  *UIChangeTriggersMacro:
     mMainKeywordTable[dwI].pstrKeyword  = "UIChangeTriggersMacro" ;
     mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME ;
     mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_CHAIN ;
     mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
     mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
     mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                         atrUIChangeTriggersMacro) ;
     dwI++ ;
#endif




    //  -- Option specific keywords -- //

    //  *PrintableArea:
    mMainKeywordTable[dwI].pstrKeyword  = "PrintableArea" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPrintableSize) ;
    dwI++ ;

    //  *PrintableOrigin:
    mMainKeywordTable[dwI].pstrKeyword  = "PrintableOrigin" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPrintableOrigin) ;
    dwI++ ;

    //  *CursorOrigin:
    mMainKeywordTable[dwI].pstrKeyword  = "CursorOrigin" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCursorOrigin) ;
    dwI++ ;

    //  *VectorOffset:
    mMainKeywordTable[dwI].pstrKeyword  = "VectorOffset" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrVectorOffset) ;
    dwI++ ;

    //  *MinSize:
    mMainKeywordTable[dwI].pstrKeyword  = "MinSize" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMinSize) ;
    dwI++ ;

    //  *MaxSize:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxSize" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMaxSize) ;
    dwI++ ;

    //  *TopMargin:
    mMainKeywordTable[dwI].pstrKeyword  = "TopMargin" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrTopMargin) ;
    dwI++ ;

    //  *BottomMargin:
    mMainKeywordTable[dwI].pstrKeyword  = "BottomMargin" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrBottomMargin) ;
    dwI++ ;

    //  *MaxPrintableWidth:
    mMainKeywordTable[dwI].pstrKeyword  = "MaxPrintableWidth" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMaxPrintableWidth) ;
    dwI++ ;

    //  *MinLeftMargin:
    mMainKeywordTable[dwI].pstrKeyword  = "MinLeftMargin" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMinLeftMargin) ;
    dwI++ ;

    //  *CenterPrintable?:
    mMainKeywordTable[dwI].pstrKeyword  = "CenterPrintable?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE  ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCenterPrintable) ;
    dwI++ ;


    //  *PageDimensions:
    mMainKeywordTable[dwI].pstrKeyword  = "PageDimensions" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPageDimensions) ;
    dwI++ ;

    //  *RotateSize?:
    mMainKeywordTable[dwI].pstrKeyword  = "RotateSize?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrRotateSize) ;
    dwI++ ;

    //  *PortRotationAngle:
    mMainKeywordTable[dwI].pstrKeyword  = "PortRotationAngle" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPortRotationAngle) ;
    dwI++ ;

    //  *PageProtectMem:
    mMainKeywordTable[dwI].pstrKeyword  = "PageProtectMem" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPageProtectMem) ;
    dwI++ ;


    //  *CustCursorOriginX:
    mMainKeywordTable[dwI].pstrKeyword  = "CustCursorOriginX" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustCursorOriginX) ;
    dwI++ ;


    //  *CustCursorOriginY:
    mMainKeywordTable[dwI].pstrKeyword  = "CustCursorOriginY" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustCursorOriginY) ;
    dwI++ ;


    //  *CustPrintableOriginX:
    mMainKeywordTable[dwI].pstrKeyword  = "CustPrintableOriginX" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableOriginX) ;
    dwI++ ;


    //  *CustPrintableOriginY:
    mMainKeywordTable[dwI].pstrKeyword  = "CustPrintableOriginY" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableOriginY) ;
    dwI++ ;


    //  *CustPrintableSizeX:
    mMainKeywordTable[dwI].pstrKeyword  = "CustPrintableSizeX" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableSizeX) ;
    dwI++ ;
    //  *CustPrintableSizeY:
    mMainKeywordTable[dwI].pstrKeyword  = "CustPrintableSizeY" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_PARAMETER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableSizeY) ;
    dwI++ ;




    //  *FeedMargins:
    mMainKeywordTable[dwI].pstrKeyword  = "FeedMargins" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrFeedMargins) ;
    dwI++ ;

    //  *PaperFeed:
    mMainKeywordTable[dwI].pstrKeyword  = "PaperFeed" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_PAPERFEED_ORIENT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPaperFeed) ;
    dwI++ ;

    //  *DPI:
    mMainKeywordTable[dwI].pstrKeyword  = "DPI" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrDPI) ;
    dwI++ ;

    //  *SpotDiameter:
    mMainKeywordTable[dwI].pstrKeyword  = "SpotDiameter" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrSpotDiameter) ;
    dwI++ ;

    //  *TextDPI:
    mMainKeywordTable[dwI].pstrKeyword  = "TextDPI" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrTextDPI) ;
    dwI++ ;

    //  *PinsPerPhysPass:
    mMainKeywordTable[dwI].pstrKeyword  = "PinsPerPhysPass" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPinsPerPhysPass) ;
    dwI++ ;

    //  *PinsPerLogPass:
    mMainKeywordTable[dwI].pstrKeyword  = "PinsPerLogPass" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPinsPerLogPass) ;
    dwI++ ;

    //  *RequireUniDir?:
    mMainKeywordTable[dwI].pstrKeyword  = "RequireUniDir?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrRequireUniDir) ;
    dwI++ ;

    //  *MinStripBlankPixels:
    mMainKeywordTable[dwI].pstrKeyword  = "MinStripBlankPixels" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMinStripBlankPixels) ;
    dwI++ ;

    //  *RedDeviceGamma:
    mMainKeywordTable[dwI].pstrKeyword  = "RedDeviceGamma" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrRedDeviceGamma) ;
    dwI++ ;

    //  *GreenDeviceGamma:
    mMainKeywordTable[dwI].pstrKeyword  = "GreenDeviceGamma" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrGreenDeviceGamma) ;
    dwI++ ;

    //  *BlueDeviceGamma:
    mMainKeywordTable[dwI].pstrKeyword  = "BlueDeviceGamma" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_FF ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrBlueDeviceGamma) ;
    dwI++ ;

    //  *Color?:
    mMainKeywordTable[dwI].pstrKeyword  = "Color?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrColor) ;
    dwI++ ;

    //  *DevNumOfPlanes:
    mMainKeywordTable[dwI].pstrKeyword  = "DevNumOfPlanes" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrDevNumOfPlanes) ;
    dwI++ ;

    //  *DevBPP:
    mMainKeywordTable[dwI].pstrKeyword  = "DevBPP" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrDevBPP) ;
    dwI++ ;

    //  *ColorPlaneOrder:
    mMainKeywordTable[dwI].pstrKeyword  = "ColorPlaneOrder" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_COLORPLANE ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrColorPlaneOrder) ;
    dwI++ ;

    //  *DrvBPP:
    mMainKeywordTable[dwI].pstrKeyword  = "DrvBPP" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrDrvBPP) ;
    dwI++ ;

    //  *IPCallbackID:
    mMainKeywordTable[dwI].pstrKeyword  = "IPCallbackID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrIPCallbackID) ;
    dwI++ ;

    //  *ColorSeparation?:
    mMainKeywordTable[dwI].pstrKeyword  = "ColorSeparation?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrColorSeparation) ;
    dwI++ ;

    //  *RasterMode:
    mMainKeywordTable[dwI].pstrKeyword  = "RasterMode" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_RASTERMODE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrRasterMode) ;
    dwI++ ;

    //  *PaletteSize:
    mMainKeywordTable[dwI].pstrKeyword  = "PaletteSize" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPaletteSize) ;
    dwI++ ;

    //  *PaletteProgrammable?:
    mMainKeywordTable[dwI].pstrKeyword  = "PaletteProgrammable?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrPaletteProgrammable) ;
    dwI++ ;

    //  *rcHTPatternID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcHTPatternID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrRcHTPatternID) ;
    dwI++ ;

    //  *HTPatternSize:
    mMainKeywordTable[dwI].pstrKeyword  = "HTPatternSize" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrHTPatternSize) ;
    dwI++ ;

    //  *HTNumPatterns:
    mMainKeywordTable[dwI].pstrKeyword  = "HTNumPatterns" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrHTNumPatterns) ;
    dwI++ ;

    //  *HTCallbackID:
    mMainKeywordTable[dwI].pstrKeyword  = "HTCallbackID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrHTCallbackID) ;
    dwI++ ;

    //  *Luminance:
    mMainKeywordTable[dwI].pstrKeyword  = "Luminance" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrLuminance) ;
    dwI++ ;


    //  *MemoryConfigKB:
    mMainKeywordTable[dwI].pstrKeyword  = "MemoryConfigKB" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigKB) ;
    gdwMemoryConfigKB  = dwI ;

    dwI++ ;


    //  *MemoryConfigMB:
    mMainKeywordTable[dwI].pstrKeyword  = "MemoryConfigMB" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_POINT ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigMB) ;
    gdwMemoryConfigMB  = dwI ;

    dwI++ ;


    //  *OutputOrderReversed?:
    mMainKeywordTable[dwI].pstrKeyword  = "OutputOrderReversed?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = 0 ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_OPTION_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(DFEATURE_OPTIONS,
                                        atrOutputOrderReversed) ;
    dwI++ ;





    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;


    return  dwI ;
}

DWORD        DWinitMainKeywordTable5(
        DWORD  dwI,
    PGLOBL pglobl)
{



    /* ---- COMMAND  Construct keywords: ----- */

    //  *Cmd:
    mMainKeywordTable[dwI].pstrKeyword  = "Cmd" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_COMMAND_INVOC ;
    mMainKeywordTable[dwI].flAgs = KWF_COMMAND ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_COMMAND_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(COMMAND, strInvocation ) ;
    gdwCommandCmd = dwI ;
    dwI++ ;

    //  *CallbackID:
    mMainKeywordTable[dwI].pstrKeyword  = "CallbackID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER;
    mMainKeywordTable[dwI].flAgs =  KWF_COMMAND ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_COMMAND_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(COMMAND, dwCmdCallbackID ) ;
    dwI++ ;

    //  *Order:
    mMainKeywordTable[dwI].pstrKeyword  = "Order" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_ORDERDEPENDENCY;
    mMainKeywordTable[dwI].flAgs = KWF_COMMAND ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_COMMAND_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(COMMAND, ordOrder ) ;
    dwI++ ;

    //  *Params:
    mMainKeywordTable[dwI].pstrKeyword  = "Params" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_STANDARD_VARS ;
    mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_COMMAND ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_COMMAND_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(COMMAND, dwStandardVarsList) ;
    dwI++ ;

    //  *NoPageEject?:
    mMainKeywordTable[dwI].pstrKeyword  = "NoPageEject?" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_CONSTANT_BOOLEANTYPE ;
    mMainKeywordTable[dwI].flAgs = KWF_COMMAND ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_COMMAND_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(COMMAND, bNoPageEject) ;
    dwI++ ;


    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;


    /* ---- FONTCART  Construct keywords: ----- */



    //  *rcCartridgeNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcCartridgeNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = KWF_FONTCART  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FONTCART_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(FONTCART , dwRCCartNameID ) ;
    dwI++ ;

    //  *CartridgeName:
    mMainKeywordTable[dwI].pstrKeyword  = "CartridgeName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT;
    mMainKeywordTable[dwI].flAgs = KWF_FONTCART  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FONTCART_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(FONTCART , strCartName  ) ;
    dwI++ ;

    //  *Fonts:
    mMainKeywordTable[dwI].pstrKeyword  = "Fonts" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_FONTCART  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FONTCART_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(FONTCART , dwFontLst  ) ;
    dwI++ ;

    //  *PortraitFonts:
    mMainKeywordTable[dwI].pstrKeyword  = "PortraitFonts" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_FONTCART  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FONTCART_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(FONTCART , dwPortFontLst  ) ;
    dwI++ ;

    //  *LandscapeFonts:
    mMainKeywordTable[dwI].pstrKeyword  = "LandscapeFonts" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX;
    mMainKeywordTable[dwI].flAgs = KWF_LIST | KWF_FONTCART  ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FONTCART_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(FONTCART , dwLandFontLst  ) ;
    dwI++ ;



    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;



    /* ---- TTFONTSUBS  Construct keywords: ----- */
    //  these keywords may be synthesized along with the construct
    //  *TTFontSub  from the shortcut:
    //  *TTFS: "font name" : <fontID>


    //  *TTFontName:
    mMainKeywordTable[dwI].pstrKeyword  = "TTFontName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT ;
    mMainKeywordTable[dwI].flAgs = KWF_TTFONTSUBS ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_TTFONTSUBS_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(TTFONTSUBTABLE, arTTFontName) ;
    dwI++ ;

    //  *DevFontName:
    mMainKeywordTable[dwI].pstrKeyword  = "DevFontName" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_STRING_CP_CONVERT ;
    mMainKeywordTable[dwI].flAgs = KWF_TTFONTSUBS ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_TTFONTSUBS_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(TTFONTSUBTABLE, arDevFontName) ;
    dwI++ ;

    //  *rcTTFontNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcTTFontNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = KWF_TTFONTSUBS ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_TTFONTSUBS_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(TTFONTSUBTABLE,
                                        dwRcTTFontNameID) ;
    dwI++ ;

    //  *rcDevFontNameID:
    mMainKeywordTable[dwI].pstrKeyword  = "rcDevFontNameID" ;
    mMainKeywordTable[dwI].eAllowedValue = VALUE_QUALIFIED_NAME_EX ;
    mMainKeywordTable[dwI].flAgs = KWF_TTFONTSUBS ;
    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_TTFONTSUBS_ONLY ;
    mMainKeywordTable[dwI].dwOffset = offsetof(TTFONTSUBTABLE,
                                        dwRcDevFontNameID) ;
    dwI++ ;

    //  *DevFontID:
//    mMainKeywordTable[dwI].pstrKeyword  = "DevFontID" ;
//    mMainKeywordTable[dwI].eAllowedValue = VALUE_INTEGER ;
//    mMainKeywordTable[dwI].flAgs = KWF_TTFONTSUBS ;
//    mMainKeywordTable[dwI].eType = TY_ATTRIBUTE ;
//    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_TTFONTSUBS_ONLY ;
//    mMainKeywordTable[dwI].dwOffset = offsetof(TTFONTSUBTABLE, dwDevFontID) ;
//    dwI++ ;



    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;




    /* ---- OEM  Construct keywords: ----- */

    // ----  End of Section  ---- //
    mMainKeywordTable[dwI].pstrKeyword  = NULL ;
    dwI++ ;


    /* ---- END_ATTR  No more Construct keywords: ----- */

    return  dwI ;
}


VOID    VinitValueToSize(
            PGLOBL pglobl)
{
    DWORD   dwI ;

    // initialize to DWORD size as defaults.

    for(dwI = 0 ; dwI < VALUE_MAX ; dwI++)
        gValueToSize[dwI] = sizeof(DWORD) ;

    gValueToSize[NO_VALUE]                  =  0 ;
    gValueToSize[VALUE_LARGEST]             =  0 ;
    gValueToSize[VALUE_STRING_NO_CONVERT]   =  sizeof(ARRAYREF) ;
    gValueToSize[VALUE_STRING_DEF_CONVERT]  =  sizeof(ARRAYREF) ;
    gValueToSize[VALUE_STRING_CP_CONVERT]   =  sizeof(ARRAYREF) ;
    gValueToSize[VALUE_COMMAND_INVOC]       =  sizeof(ARRAYREF) ;
    gValueToSize[VALUE_PARAMETER]       =  sizeof(ARRAYREF) ;

    //  SYMBOLS and CONSTANTS are all DWORD sized.
    gValueToSize[VALUE_POINT]               =  sizeof(POINT) ; // etc
    gValueToSize[VALUE_RECT]                =  sizeof(RECT) ; // etc
    gValueToSize[VALUE_QUALIFIED_NAME]      =  sizeof(DWORD) ; // currently

    //  VALUE_CONSTRAINT,  VALUE_INVALID_INSTALL_COMBO
    //      are currently all accessed via DWORD indicies to nodes.

    gValueToSize[VALUE_ORDERDEPENDENCY]     =  sizeof(ORDERDEPENDENCY) ;
    gValueToSize[VALUE_FONTSUB]             =  sizeof(TTFONTSUBTABLE) ;
        // not really used since its a special keyword.

    gValueToSize[VALUE_LIST]                =  sizeof(DWORD) ; // etc
        // only the index of first listnode is stored.


    for(dwI = 0 ; dwI < VALUE_MAX ; dwI++)
    {
        if(gValueToSize[dwI] > gValueToSize[VALUE_LARGEST])
            gValueToSize[VALUE_LARGEST] = gValueToSize[dwI] ;
    }

}



VOID  VinitGlobals(
            DWORD dwVerbosity,
            PGLOBL pglobl)
{
    DWORD       dwIndex;
    CONST PBYTE pubStar = "*"; // Used for initializing  gaarPPPrefix

    if(MAX_GID > 32)
        RIP(("MAX_GID > 32 violates some GPD parser assumptions.\n"));

    memset(pglobl, 0, sizeof(GLOBL));


    //  initialize all globals to default state.

    geErrorType = ERRTY_NONE ;  // start with a clean slate
    geErrorSev = ERRSEV_NONE ;


// check. Adding initializations that were previously done when variables were global
    gdwResDLL_ID      =  0 ;  // no Feature yet defined to hold Resource DLLs.
    gdwVerbosity      =  dwVerbosity ;
                            //  0 = min verbosity, 4 max verbosity.

    //  set preprocessor prefix to '*'
    gaarPPPrefix.pub = pubStar;
    gaarPPPrefix.dw  = 1;

    VinitValueToSize(pglobl) ;    //  size of value links.

    VinitAllowedTransitions(pglobl) ;  //  AllowedTransitions and Attributes
    (VOID) BinitClassIndexTable(pglobl) ; //  gcieTable[]  constant classes.
    VinitOperPrecedence(pglobl) ;  // arithmetic operators used in command
                            // parameters.

    //  no memory buffers allocated.

    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        gMasterTable[dwIndex].pubStruct = NULL ;
    }

    gMasterTable[MTI_STRINGHEAP].dwArraySize =    0x010000  ;
    gMasterTable[MTI_STRINGHEAP].dwMaxArraySize = 0x200000  ;
    gMasterTable[MTI_STRINGHEAP].dwElementSiz = sizeof(BYTE) ;

    gMasterTable[MTI_GLOBALATTRIB].dwArraySize = 1  ;
    gMasterTable[MTI_GLOBALATTRIB].dwMaxArraySize = 1  ;
    gMasterTable[MTI_GLOBALATTRIB].dwElementSiz =  sizeof(GLOBALATTRIB) ;

    gMasterTable[MTI_COMMANDTABLE].dwArraySize = CMD_MAX  ;
    gMasterTable[MTI_COMMANDTABLE].dwMaxArraySize = CMD_MAX  ;
    gMasterTable[MTI_COMMANDTABLE].dwElementSiz =  sizeof(ATREEREF) ;

    gMasterTable[MTI_ATTRIBTREE].dwArraySize = 5000  ;
    gMasterTable[MTI_ATTRIBTREE].dwMaxArraySize = 50,000  ;
    gMasterTable[MTI_ATTRIBTREE].dwElementSiz =  sizeof(ATTRIB_TREE) ;

    gMasterTable[MTI_COMMANDARRAY].dwArraySize =  500 ;
    gMasterTable[MTI_COMMANDARRAY].dwMaxArraySize = 5000 ;
    gMasterTable[MTI_COMMANDARRAY].dwElementSiz = sizeof(COMMAND)  ;

    gMasterTable[MTI_PARAMETER].dwArraySize =  500 ;
    gMasterTable[MTI_PARAMETER].dwMaxArraySize = 5000 ;
    gMasterTable[MTI_PARAMETER].dwElementSiz = sizeof(PARAMETER)  ;

    gMasterTable[MTI_TOKENSTREAM].dwArraySize =  3000 ;
    gMasterTable[MTI_TOKENSTREAM].dwMaxArraySize = 30000 ;
    gMasterTable[MTI_TOKENSTREAM].dwElementSiz = sizeof(TOKENSTREAM)  ;

    gMasterTable[MTI_LISTNODES].dwArraySize =  3000 ;
    gMasterTable[MTI_LISTNODES].dwMaxArraySize = 50000 ;
    gMasterTable[MTI_LISTNODES].dwElementSiz = sizeof(LISTNODE)  ;

    gMasterTable[MTI_CONSTRAINTS].dwArraySize =  300 ;
    gMasterTable[MTI_CONSTRAINTS].dwMaxArraySize = 5000 ;
    gMasterTable[MTI_CONSTRAINTS].dwElementSiz = sizeof(CONSTRAINTS)  ;

    gMasterTable[MTI_INVALIDCOMBO].dwArraySize =  40 ;
    gMasterTable[MTI_INVALIDCOMBO].dwMaxArraySize = 500 ;
    gMasterTable[MTI_INVALIDCOMBO].dwElementSiz = sizeof(INVALIDCOMBO )  ;

    gMasterTable[MTI_GPDFILEDATEINFO].dwArraySize =  10 ;
    gMasterTable[MTI_GPDFILEDATEINFO].dwMaxArraySize = 100 ;
    gMasterTable[MTI_GPDFILEDATEINFO].dwElementSiz = sizeof(GPDFILEDATEINFO )  ;


    /*  set dwArraySize = 0 for objects that are allocated on 2nd pass  */

    gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize = 0  ;
    gMasterTable[MTI_DFEATURE_OPTIONS].dwMaxArraySize = 300  ;
    gMasterTable[MTI_DFEATURE_OPTIONS].dwElementSiz =
                                    sizeof(DFEATURE_OPTIONS) ;

    gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize = 0  ;
    gMasterTable[MTI_SYNTHESIZED_FEATURES].dwMaxArraySize = 100  ;
    gMasterTable[MTI_SYNTHESIZED_FEATURES].dwElementSiz =
                                        sizeof(DFEATURE_OPTIONS) ;


    gMasterTable[MTI_PRIORITYARRAY].dwArraySize = 0  ;
    gMasterTable[MTI_PRIORITYARRAY].dwMaxArraySize =
        gMasterTable[MTI_DFEATURE_OPTIONS].dwMaxArraySize +
        gMasterTable[MTI_SYNTHESIZED_FEATURES].dwMaxArraySize  ;
    gMasterTable[MTI_PRIORITYARRAY].dwElementSiz =
                                        sizeof(DWORD) ;

    gMasterTable[MTI_TTFONTSUBTABLE].dwArraySize = 0  ;
    gMasterTable[MTI_TTFONTSUBTABLE].dwMaxArraySize = 1000  ;
    gMasterTable[MTI_TTFONTSUBTABLE].dwElementSiz =  sizeof(TTFONTSUBTABLE) ;

    gMasterTable[MTI_FONTCART].dwArraySize = 0  ;
    gMasterTable[MTI_FONTCART].dwMaxArraySize = 500  ;
    gMasterTable[MTI_FONTCART].dwElementSiz =  sizeof(FONTCART) ;

    gMasterTable[MTI_SYMBOLROOT].dwArraySize =  SCL_NUMSYMCLASSES ;
    gMasterTable[MTI_SYMBOLROOT].dwMaxArraySize =  SCL_NUMSYMCLASSES ;
    gMasterTable[MTI_SYMBOLROOT].dwElementSiz = sizeof(DWORD)  ;

    gMasterTable[MTI_SYMBOLTREE].dwArraySize =  1500 ;
    gMasterTable[MTI_SYMBOLTREE].dwMaxArraySize =  16000 ;
    gMasterTable[MTI_SYMBOLTREE].dwElementSiz = sizeof(SYMBOLNODE)  ;

    gMasterTable[MTI_TMPHEAP].dwArraySize =    0x010000  ;
    gMasterTable[MTI_TMPHEAP].dwMaxArraySize = 0x200000  ;
    gMasterTable[MTI_TMPHEAP].dwElementSiz = sizeof(BYTE) ;

    gMasterTable[MTI_SOURCEBUFFER].dwArraySize =  10 ;
    gMasterTable[MTI_SOURCEBUFFER].dwMaxArraySize = 100 ;
    gMasterTable[MTI_SOURCEBUFFER].dwElementSiz = sizeof(SOURCEBUFFER)  ;

    //  NEWTOKENMAP is created from unused entries in TOKENMAP.

    gMasterTable[MTI_TOKENMAP].dwArraySize = 0x3000  ;
    gMasterTable[MTI_TOKENMAP].dwMaxArraySize = 0x40000  ;
    gMasterTable[MTI_TOKENMAP].dwElementSiz =  sizeof(TKMAP) ;

    gMasterTable[MTI_NEWTOKENMAP].dwArraySize = 0x3000  ;
    gMasterTable[MTI_NEWTOKENMAP].dwMaxArraySize = 0x40000   ;
    gMasterTable[MTI_NEWTOKENMAP].dwElementSiz =  sizeof(TKMAP) ;

    gMasterTable[MTI_BLOCKMACROARRAY].dwArraySize =  200 ;
    gMasterTable[MTI_BLOCKMACROARRAY].dwMaxArraySize = 3000  ;
    gMasterTable[MTI_BLOCKMACROARRAY].dwElementSiz =  sizeof(BLOCKMACRODICTENTRY) ;

    gMasterTable[MTI_VALUEMACROARRAY].dwArraySize = 800  ;
    gMasterTable[MTI_VALUEMACROARRAY].dwMaxArraySize = 4000  ;
    gMasterTable[MTI_VALUEMACROARRAY].dwElementSiz = sizeof(VALUEMACRODICTENTRY) ;

    gMasterTable[MTI_MACROLEVELSTACK].dwArraySize = 20  ;
    gMasterTable[MTI_MACROLEVELSTACK].dwMaxArraySize = 60  ;
    gMasterTable[MTI_MACROLEVELSTACK].dwElementSiz = sizeof(MACROLEVELSTATE)  ;

    gMasterTable[MTI_STSENTRY].dwArraySize = 20  ;
    gMasterTable[MTI_STSENTRY].dwMaxArraySize = 60  ;
    gMasterTable[MTI_STSENTRY].dwElementSiz =  sizeof(STSENTRY) ;

    gMasterTable[MTI_OP_QUEUE].dwArraySize = 40 ;
    gMasterTable[MTI_OP_QUEUE].dwMaxArraySize = 150  ;
    gMasterTable[MTI_OP_QUEUE].dwElementSiz =  sizeof(DWORD) ;

    gMasterTable[MTI_MAINKEYWORDTABLE].dwArraySize =  400 ;
    gMasterTable[MTI_MAINKEYWORDTABLE].dwMaxArraySize =  3000 ;
    gMasterTable[MTI_MAINKEYWORDTABLE].dwElementSiz =
            sizeof(KEYWORDTABLE_ENTRY) ;

    gMasterTable[MTI_RNGDICTIONARY].dwArraySize =  END_ATTR ;
    gMasterTable[MTI_RNGDICTIONARY].dwMaxArraySize =  END_ATTR ;
    gMasterTable[MTI_RNGDICTIONARY].dwElementSiz =  sizeof(RANGE) ;

    gMasterTable[MTI_FILENAMES].dwArraySize =  40 ;
    gMasterTable[MTI_FILENAMES].dwMaxArraySize =  100 ;
    gMasterTable[MTI_FILENAMES].dwElementSiz =  sizeof(PWSTR) ;

    gMasterTable[MTI_PREPROCSTATE].dwArraySize =  20 ;
    gMasterTable[MTI_PREPROCSTATE].dwMaxArraySize =  100 ;
    gMasterTable[MTI_PREPROCSTATE].dwElementSiz =  sizeof(PPSTATESTACK) ;

}


BOOL   BpreAllocateObjects(
            PGLOBL pglobl)
{
    DWORD   dwIndex, dwBytes ;

    /*  set dwArraySize = 0 for objects that are allocated on 2nd pass  */

    gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize =  0 ;
    gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize =  0 ;
    gMasterTable[MTI_PRIORITYARRAY].dwArraySize =  0 ;
        //  allocation occurs at PostProcessing time.
    gMasterTable[MTI_TTFONTSUBTABLE].dwArraySize =  0 ;
    gMasterTable[MTI_FONTCART].dwArraySize =  0 ;


    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        gMasterTable[dwIndex].dwCurIndex =  0 ;
        //  do initialization first:  bug 308404
    }

    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        if(gMasterTable[dwIndex].dwArraySize)
        {
            dwBytes = gMasterTable[dwIndex].dwArraySize *
                        gMasterTable[dwIndex].dwElementSiz ;
            if(!(gMasterTable[dwIndex].pubStruct = MemAllocZ(dwBytes) ))
            {
                ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
                    dwBytes));
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                geErrorSev = ERRSEV_FATAL ;
                gdwMasterTabIndex = dwIndex ;
                return(FALSE) ;   // This is unrecoverable
            }
        }
    }
    //  do not use heap offset zero because OFFSET_TO_POINTER()
    //  macro will consider this an invalid value!
    gMasterTable[MTI_STRINGHEAP].dwCurIndex =  1 ;

    return(TRUE) ;
}

BOOL  BreturnBuffers(
            PGLOBL pglobl)
/*  FALSE  return indicates a go-round
    is needed.  Otherwise you are
    free to exit caller's loop.
*/
{
    DWORD   dwIndex ;


    //  better close all the memory mapped files.

    while(mCurFile)
    {
        mCurFile-- ;  // pop stack
        MemFree(mpSourcebuffer[mCurFile].pubSrcBuf) ;
    }

    vFreeFileNames(pglobl) ;


    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        if(gMasterTable[dwIndex].pubStruct)
        {
            MemFree(gMasterTable[dwIndex].pubStruct) ;
            gMasterTable[dwIndex].pubStruct = NULL ;
        }
    }
    //  resize one array if needed.
    if((geErrorType ==  ERRTY_MEMORY_ALLOCATION)  &&
        (geErrorSev == ERRSEV_RESTART))
    {
        if( gMasterTable[gdwMasterTabIndex].dwArraySize <
            gMasterTable[gdwMasterTabIndex].dwMaxArraySize )
        {
            DWORD  dwInc ;

            dwInc = gMasterTable[gdwMasterTabIndex].dwArraySize / 2 ;

            gMasterTable[gdwMasterTabIndex].dwArraySize +=
                (dwInc) ? (dwInc) : 1 ;
            geErrorSev = ERRSEV_NONE ;  //  hopefully this fixes
                    //  the problem.
            return(FALSE) ;   // go round needed.
        }
        else
        {
            geErrorSev = ERRSEV_FATAL ;
            ERR(("Internal error: memory usage exceeded hardcoded limits.\n"));
            ERR((" %d bytes requested, %d bytes allowed.\n",
                gMasterTable[gdwMasterTabIndex].dwArraySize,
                gMasterTable[gdwMasterTabIndex].dwMaxArraySize));
        }
    }
    return(TRUE);  // due to success or utter failure, don't
        // try anymore.
}


BOOL   BallocateCountableObjects(
            PGLOBL pglobl)
/*
    The first pass of BinterpretTokens() has registered all
    the unique symbols for the various constructs.
    By querying the SymbolID value stored at the root of
    each symbol tree, we know how many structures of each
    type to allocate.
*/
{
    DWORD   dwIndex, dwBytes ;
    PDWORD  pdwSymbolClass ;
    PSYMBOLNODE     psn ;

    pdwSymbolClass = (PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    if(pdwSymbolClass[SCL_FEATURES] != INVALID_INDEX)
    {
        gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize =
            psn[pdwSymbolClass[SCL_FEATURES]].dwSymbolID + 1 ;
    }
    //  else  no symbols registered - leave dwArraySize = 0 ;
    if(pdwSymbolClass[SCL_TTFONTNAMES] != INVALID_INDEX)
    {
        gMasterTable[MTI_TTFONTSUBTABLE].dwArraySize =
            psn[pdwSymbolClass[SCL_TTFONTNAMES]].dwSymbolID + 1;
    }
    if(pdwSymbolClass[SCL_FONTCART] != INVALID_INDEX)
    {
        gMasterTable[MTI_FONTCART].dwArraySize =
            psn[pdwSymbolClass[SCL_FONTCART]].dwSymbolID + 1;
    }



    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        if(gMasterTable[dwIndex].dwArraySize  &&
            !gMasterTable[dwIndex].pubStruct)
        {
            dwBytes = gMasterTable[dwIndex].dwArraySize *
                        gMasterTable[dwIndex].dwElementSiz ;
            if(!(gMasterTable[dwIndex].pubStruct = MemAllocZ(dwBytes) ))
            {
                ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
                    dwBytes));
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                geErrorSev = ERRSEV_FATAL ;
                gdwMasterTabIndex = dwIndex ;
                return(FALSE) ;   // This is unrecoverable
            }
            else
            {
                gMasterTable[dwIndex].dwCurIndex =  0 ;
            }
        }
    }

    return(TRUE) ;   // success !
}

BOOL   BinitPreAllocatedObjects(
            PGLOBL pglobl)
{
    DWORD    dwI, dwJ ;

    VinitMainKeywordTable(pglobl) ;    //  contents of mMainKeywordTable[] itself
    VinitDictionaryIndex(pglobl) ;  // inits  MTI_RNGDICTIONARY

    /*  init roots of symbol trees */

    for(dwI = 0  ;  dwI < gMasterTable[MTI_SYMBOLROOT].dwArraySize ; dwI++)
    {
        ((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct)[dwI] =
            INVALID_INDEX ;
    }

    //  init preprocessor state stack

    mdwNestingLevel = 0 ;
    mppStack[mdwNestingLevel].permState = PERM_ALLOW ;
    mppStack[mdwNestingLevel].ifState =  IFS_ROOT;


    for(dwI = 0  ;  dwI < gMasterTable[MTI_TOKENMAP].dwArraySize ; dwI++)
    {
        ((PTKMAP)gMasterTable[MTI_TOKENMAP].pubStruct)[dwI].dwFlags =
            0 ;     //  must start with this field cleared.
    }


    for(dwI = 0  ;  dwI < gMasterTable[MTI_GLOBALATTRIB].dwArraySize
                    ; dwI++)
    {
        for(dwJ = 0  ;  dwJ < gMasterTable[MTI_GLOBALATTRIB].dwElementSiz /
                        sizeof(ATREEREF)  ; dwJ++)
        {
            ((PATREEREF)( (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].
                    pubStruct + dwI))[dwJ] =
                ATTRIB_UNINITIALIZED ;  // the GLOBALATTRIB struct is
                // comprised entirely of ATREEREFs.
        }
    }

    for(dwI = 0  ;  dwI < gMasterTable[MTI_COMMANDARRAY].dwArraySize ; dwI++)
    {
        ((PCOMMAND)gMasterTable[MTI_COMMANDARRAY].pubStruct)[dwI].
            dwCmdCallbackID  = NO_CALLBACK_ID ;
        ((PCOMMAND)gMasterTable[MTI_COMMANDARRAY].pubStruct)[dwI].
            ordOrder.eSection = SS_UNINITIALIZED ;
        ((PCOMMAND)gMasterTable[MTI_COMMANDARRAY].pubStruct)[dwI].
            dwStandardVarsList = END_OF_LIST ;
        ((PCOMMAND)gMasterTable[MTI_COMMANDARRAY].pubStruct)[dwI].
            bNoPageEject = FALSE ;
    }
    return(TRUE);
}




BOOL   BinitCountableObjects(
            PGLOBL pglobl)
{
    DWORD    dwI, dwJ ;
    PFONTCART   pfc ;

    for(dwI = 0  ;  dwI < gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize
                    ; dwI++)
    {
        for(dwJ = 0  ;  dwJ < gMasterTable[MTI_DFEATURE_OPTIONS].dwElementSiz /
                        sizeof(ATREEREF)  ; dwJ++)
        {
            ((PATREEREF)( (PDFEATURE_OPTIONS)gMasterTable[MTI_DFEATURE_OPTIONS].
                    pubStruct + dwI))[dwJ] =
                ATTRIB_UNINITIALIZED ;  // the DFEATURE_OPTIONS struct is
                // comprised entirely of ATREEREFs.
        }
    }
    for(dwI = 0  ;  dwI < gMasterTable[MTI_COMMANDTABLE].dwArraySize ; dwI++)
    {
        ((PATREEREF)gMasterTable[MTI_COMMANDTABLE].pubStruct)[dwI] =
                ATTRIB_UNINITIALIZED ;  //  the command table is
                // comprised entirely of ATREEREFs.
    }

    pfc = (PFONTCART)gMasterTable[MTI_FONTCART].pubStruct ;

    for(dwI = 0  ;  dwI < gMasterTable[MTI_FONTCART].dwArraySize ; dwI++)
    {
        pfc[dwI].dwFontLst = pfc[dwI].dwPortFontLst = pfc[dwI].dwLandFontLst =
            END_OF_LIST ;
    }
    return(TRUE);
}

#if 0

BOOL  BevaluateMacros(
            PGLOBL pglobl)
//  and expand shortcuts
{
    //  placeholder code - use original tokenMap
    //  BUG_BUG!!!!!  just swap the two entries for now.

    DWORD   dwTmp ;
    PBYTE   pubTmp ;

    dwTmp = gMasterTable[MTI_NEWTOKENMAP].dwArraySize ;
    gMasterTable[MTI_NEWTOKENMAP].dwArraySize =
        gMasterTable[MTI_TOKENMAP].dwArraySize  ;
    gMasterTable[MTI_TOKENMAP].dwArraySize = dwTmp ;

    dwTmp = gMasterTable[MTI_NEWTOKENMAP].dwMaxArraySize ;
    gMasterTable[MTI_NEWTOKENMAP].dwMaxArraySize =
        gMasterTable[MTI_TOKENMAP].dwMaxArraySize ;
    gMasterTable[MTI_TOKENMAP].dwMaxArraySize = dwTmp ;

    pubTmp = gMasterTable[MTI_NEWTOKENMAP].pubStruct ;
    gMasterTable[MTI_NEWTOKENMAP].pubStruct =
        gMasterTable[MTI_TOKENMAP].pubStruct ;
    gMasterTable[MTI_TOKENMAP].pubStruct = pubTmp  ;

    return(TRUE);
}

#endif

BOOL BpostProcess(
PWSTR   pwstrFileName,   // root GPD file
PGLOBL  pglobl)
{
    BOOL    bStatus ;
    DWORD   dwIndex, dwBytes, dwCount ;
    PDWORD  pdwPriority ;

/*

    check to see that all manditory fields
    have been initialized, warn otherwise.
    Have no way to reject entries once allocated.
    verify that all features referenced in switch
    statements are pickone.
    FeatureOption[ptkmap->dwValue].bReferenced = TRUE ;
    check that these features marked true are
    always of type PICK_ONE.


    reflect all constraints in list: if A constrains B, then B constrains A.


    Of course feature only qualified names are not permitted.
    so check for this here since we were cheap and used
    the same parsing routine as for InvalidInstallableCombinations.

    perform checks like all lists being converted must be of
    type installable.   Lists may be rooted at the feature
    or option level.   the Feature/Options named in the
    InvalidInstallableCombinations lists must also be *Installable.

*/


    BappendCommonFontsToPortAndLandscape(pglobl) ;
    BinitSpecialFeatureOptionFields(pglobl) ;

    gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize =
        DwCountSynthFeatures(NULL, pglobl) ;

    gMasterTable[MTI_PRIORITYARRAY].dwArraySize =
        gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize +
        gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize ;

    for(dwIndex = 0 ; dwIndex < MTI_MAX_ENTRIES ; dwIndex++)
    {
        if(gMasterTable[dwIndex].dwArraySize  &&
            !gMasterTable[dwIndex].pubStruct)
        {
            dwBytes = gMasterTable[dwIndex].dwArraySize *
                        gMasterTable[dwIndex].dwElementSiz ;
            if(!(gMasterTable[dwIndex].pubStruct = MemAllocZ(dwBytes) ))
            {
                ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
                    dwBytes));
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                geErrorSev = ERRSEV_FATAL ;
                gdwMasterTabIndex = dwIndex ;
                return(FALSE) ;   // This is unrecoverable
            }
            else
            {
                gMasterTable[dwIndex].dwCurIndex =  0 ;
            }
        }
    }


    if ( !BsetUQMFlag(pglobl))
        return FALSE;   //There are 2 ways that this function will return false.
                        // 1) When space from the heap cannot be allocated.
                        //      Soln: restart.
                        // 2) An unexpected Condition is encountered.
                        //      Soln: Fatal. Stop Parsing.


    VCountPrinterDocStickyFeatures(pglobl) ;
    (VOID)BConvertSpecVersionToDWORD(pwstrFileName, pglobl) ;
    BinitMiniRawBinaryData(pglobl) ;

    DwCountSynthFeatures(BCreateSynthFeatures, pglobl) ;


    BInitPriorityArray(pglobl) ;


    // save selected buffers to file

    bStatus = BconsolidateBuffers(pwstrFileName, pglobl);
    return(bStatus) ;
}



BOOL    BconsolidateBuffers(
PWSTR   pwstrFileName,   // root GPD file
PGLOBL  pglobl)
{
    DWORD   dwCurOffset , dwI;
    ENHARRAYREF   earTableContents[MTI_NUM_SAVED_OBJECTS] ;
    PBYTE   pubDest  ;  // points to new destination buffer
    PWSTR   pwstrBinaryFileName ;
    HANDLE  hFile;
    DWORD   dwBytesWritten,
            dwAlign = 4;  // padding for DWORD alignment of all sub buffers.
    BOOL    bResult = FALSE;
    OPTSELECT   optsel[MAX_COMBINED_OPTIONS] ;   // assume is large enough
    WIN32_FILE_ATTRIBUTE_DATA   File_Attributes ;

    //  first update dwCurIndex  for fixed allocation buffers
    //  since dwCurIndex  does not indicate elements used in this
    //  case.

    dwI = MTI_GLOBALATTRIB ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_DFEATURE_OPTIONS ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_SYNTHESIZED_FEATURES ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_PRIORITYARRAY ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_TTFONTSUBTABLE ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_COMMANDTABLE ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_FONTCART ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;
    dwI = MTI_SYMBOLROOT ;
    gMasterTable[dwI].dwCurIndex = gMasterTable[dwI].dwArraySize ;


    //  at offset zero is the MINIRAWBINARYDATA header.
    //  Immediately after this is the array of ENHARRAYREFS
    //  supplying offsets to all other objects
    //  comprising the GPD binary.

    //  use the MTI_ defines to automate the copying of selected
    //  buffers.  Just make sure the subset that is being copied
    //  occupies the lower MTI_ indicies and is terminated by
    //  MTI_NUM_SAVED_OBJECTS.  The enumeration value will
    //  determine the order in which the various MTI_ buffers
    //  appear in the new buffer.

    dwCurOffset = sizeof(MINIRAWBINARYDATA) ;
    dwCurOffset += sizeof(ENHARRAYREF) * MTI_NUM_SAVED_OBJECTS ;
    dwCurOffset = (dwCurOffset + dwAlign - 1) / dwAlign ;
    dwCurOffset *= dwAlign ;

    for(dwI = 0 ; dwI < MTI_NUM_SAVED_OBJECTS ; dwI++)
    {
        earTableContents[dwI].loOffset = dwCurOffset ;
        earTableContents[dwI].dwCount =
                gMasterTable[dwI].dwCurIndex ;
        earTableContents[dwI].dwElementSiz =
                gMasterTable[dwI].dwElementSiz ;
        dwCurOffset += gMasterTable[dwI].dwElementSiz  *
                gMasterTable[dwI].dwCurIndex ;
        dwCurOffset = (dwCurOffset + dwAlign - 1) / dwAlign ;
        dwCurOffset *= dwAlign ;
    }
    pubDest = MemAlloc(dwCurOffset) ;  //  new destination buffer.
    if(!pubDest)
    {
        ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
            dwCurOffset));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
        return(FALSE) ;   // This is unrecoverable
    }

    //  Last minute initializations:

    gmrbd.rbd.dwFileSize = dwCurOffset ;

    // gmrbd.pvPrivateData is not required by the .bud. It is only initialized
    // at snapshot time. Therefore putting it to NULL.
    // gmrbd.FileDateInfo is not used by the parser at all.

    gmrbd.rbd.pvPrivateData           = (PVOID) NULL;
    gmrbd.rbd.FileDateInfo.dwCount    = 0x00000000;
    gmrbd.rbd.FileDateInfo.loOffset   = (PTRREF)0x00000000;

    //  copy table of contents to start of dest buffer.

    memcpy(pubDest, &gmrbd , sizeof(MINIRAWBINARYDATA) ) ;
    memcpy(pubDest + sizeof(MINIRAWBINARYDATA), earTableContents ,
        sizeof(ENHARRAYREF) * MTI_NUM_SAVED_OBJECTS ) ;

    for(dwI = 0 ; dwI < MTI_NUM_SAVED_OBJECTS ; dwI++)
    {
        memcpy(
            pubDest + earTableContents[dwI].loOffset,   // dest
            gMasterTable[dwI].pubStruct,                // src
            earTableContents[dwI].dwCount *             // count
            earTableContents[dwI].dwElementSiz ) ;
    }


//  priority array is modified at snapshot time
//    if(!BinitDefaultOptionArray(optsel, pubDest))
//  can't call this function from parser DLL.

    // Generate a binary file name based the original filename
    // Create a file and write data to it



    if ((pwstrBinaryFileName = pwstrGenerateGPDfilename(pwstrFileName)) == NULL)
    {
        goto  CLEANUP_BconsolidateBuffers ;
    }


    if(GetFileAttributesEx(   (LPCTSTR) pwstrBinaryFileName,        // assumes widestrings
                    GetFileExInfoStandard,
                    (LPVOID) &File_Attributes)  )
    {
        //  BUD exists - attempt to delete .

        if(! DeleteFile((LPCTSTR) pwstrBinaryFileName))
        {
            WCHAR           awchTmpName[MAX_PATH],
                                    awchPath[MAX_PATH];
            PWSTR           pwstrLastBackSlash ;
                // cannot delete, attempt to rename

                wcsncpy(awchPath, pwstrBinaryFileName , MAX_PATH -1);

                pwstrLastBackSlash = wcsrchr(awchPath,TEXT('\\')) ;
                if (!pwstrLastBackSlash)
                    goto  CLEANUP_BconsolidateBuffers ;

                *(pwstrLastBackSlash + 1) = NUL;

                if(!GetTempFileName(
                      (LPCTSTR) awchPath,
                      TEXT("BUD"),  // pointer to filename prefix
                      0,        // number used to create temporary filename
                      (LPTSTR) awchTmpName))
                        goto  CLEANUP_BconsolidateBuffers ;
                            // failed to make tmp filename

                if( !MoveFileEx(
                              (LPCTSTR) pwstrBinaryFileName,
                              (LPCTSTR) awchTmpName,
                              MOVEFILE_REPLACE_EXISTING))
                        goto  CLEANUP_BconsolidateBuffers ;

                //  Now cause temp file to disappear on reboot.

                MoveFileEx(
                                  (LPCTSTR) awchTmpName,
                                  NULL,
                                  MOVEFILE_DELAY_UNTIL_REBOOT) ;
                           //  not a big problem if temp file cannot be deleted.
        }
    }




     if((hFile = CreateFile(pwstrBinaryFileName,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL)) != INVALID_HANDLE_VALUE)
    {
        bResult = WriteFile(hFile,
                            pubDest,
                            dwCurOffset,
                            &dwBytesWritten,
                            NULL) &&
                  (dwCurOffset == dwBytesWritten);

        CloseHandle(hFile);
    }

CLEANUP_BconsolidateBuffers:

    if (! bResult)
    {
        // Fail fatally if file cannot be opened for writing. If somebody else
        // has opened the file, we do not wait for that guy to close the file.
        // We simply fail.
        geErrorSev  = ERRSEV_FATAL;
        geErrorType = ERRTY_FILE_OPEN;
        ERR(("Unable to save binary GPD data to file.\n"));
    }


    if(pwstrBinaryFileName)
        MemFree(pwstrBinaryFileName);
    if(pubDest)
        MemFree(pubDest);
    return bResult;
}


BOOL    BexpandMemConfigShortcut(DWORD       dwSubType)
{
    BOOL    bStatus = FALSE;
    return(bStatus) ;
}
//  create strings in tmpHeap.
//  checks to make sure there are
//  enough slots in the tokenmap before proceeding.

BOOL    BexpandCommandShortcut(DWORD       dwSubType)
{
    BOOL    bStatus = FALSE;
    return(bStatus) ;
}
//  add sensor to detect colons  within a value as
//  this indicates something extra was tacked on.
//      if(ptkmap[*pdwTKMindex].dwFlags & TKMF_COLON)



/*

BOOL    BinitRemainingFields()
{
    This function initializes synthesized fields
    like these in the FeatureOption array.

    ATREEREF     atrOptIDvalue;  //   ID value

    ATREEREF     atrFeaFlags ;  //  invalid or not
    ATREEREF     atrPriority ;



    //  warning:  any non-attribtreeref added to
    //  the DFEATURE_OPTIONS structure will get stomped on in strange
    //  and wonderful ways by BinitPreAllocatedObjects.

    //  internal consistency checks.
    BOOL        bReferenced ;  // default is FALSE.
    DWORD       dwGID ,  //  GID tag
        dwNumOptions ;  // these are not read in from GPD file.
    maybe also determine count of DocSticky and PrinterSticky
    or maybe that is only stored in the RawBinaryData block.
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\declares.h ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  declares.h - functions declarations

 History of Changes
  9/30/98 --hsingh--
          Added delcaration of function BsetUQMFlag(). This function
          enables making the UpdateQualityMacro? keyword optional in
          .gpd file.
          Bug Report 225088

*/



// ----  functions defined in  command.c ---- //

BOOL    BprocessParam(
IN      PABSARRAYREF paarValue,
IN      PARRAYREF    parStrValue,
IN  OUT PGLOBL       pglobl) ;

BOOL    BparseCommandString(
IN      PABSARRAYREF   paarValue,
IN      PARRAYREF      parStrValue,
IN  OUT PGLOBL         pglobl
) ;

BOOL    BconstructRPNtokenStream(
IN  OUT PABSARRAYREF  paarValue,
    OUT PARRAYREF     parRPNtokenStream,
IN  OUT PGLOBL        pglobl) ;

VOID    VinitOperPrecedence(
IN  OUT PGLOBL        pglobl);

BOOL    BparseArithmeticToken(
IN  OUT PABSARRAYREF paarValue,
OUT PTOKENSTREAM     ptstr,
    PGLOBL           pglobl
) ;

BOOL    BparseDigits(
IN  OUT PABSARRAYREF   paarValue,
OUT PTOKENSTREAM  ptstr ) ;

BOOL    BparseParamKeyword(
IN  OUT PABSARRAYREF  paarValue,
OUT PTOKENSTREAM      ptstr,
    PGLOBL            pglobl ) ;

BOOL  BcmpAARtoStr(
PABSARRAYREF    paarStr1,
PBYTE       str2) ;


// ----  functions defined in constrnt.c ---- //


BOOL   BparseConstraint(
PABSARRAYREF   paarValue,
PDWORD  pdwExistingCList,  //  index of start of contraint list.
BOOL    bCreate,
PGLOBL  pglobl) ;

BOOL    BexchangeDataInFOATNode(
DWORD   dwFeature,
DWORD   dwOption,
DWORD   dwFieldOff,  // offset of field in FeatureOption struct
PDWORD  pdwOut,     // previous contents of attribute node
PDWORD  pdwIn,
BOOL    bSynthetic,  //  access synthetic features
PGLOBL  pglobl
) ;

BOOL    BparseInvalidCombination(
PABSARRAYREF  paarValue,
DWORD         dwFieldOff,
PGLOBL        pglobl) ;

BOOL    BparseInvalidInstallableCombination1(
PABSARRAYREF  paarValue,
DWORD         dwFieldOff,
PGLOBL        pglobl) ;


// ----  functions defined in  framwrk.c ---- //

VOID      VinitMainKeywordTable(
PGLOBL  pglobl)  ;

VOID    VinitValueToSize(
PGLOBL  pglobl) ;

VOID  VinitGlobals(
DWORD   dwVerbosity,
PGLOBL  pglobl);

BOOL   BpreAllocateObjects(
PGLOBL  pglobl) ;

BOOL  BreturnBuffers(
PGLOBL  pglobl) ;

BOOL   BallocateCountableObjects(
PGLOBL  pglobl) ;

BOOL   BinitPreAllocatedObjects(
PGLOBL  pglobl) ;

BOOL   BinitCountableObjects(
PGLOBL  pglobl) ;

BOOL   BcreateGPDbinary(
PWSTR   pwstrFileName,
DWORD   dwVerbosity )  ;


BOOL BpostProcess(
PWSTR   pwstrFileName ,
PGLOBL  pglobl)  ;

BOOL    BconsolidateBuffers(
PWSTR   pwstrFileName ,
PGLOBL  pglobl)  ;

BOOL    BexpandMemConfigShortcut(DWORD       dwSubType) ;

BOOL    BexpandCommandShortcut(DWORD       dwSubType) ;


// ----  functions defined in helper1.c ---- //



PTSTR  pwstrGenerateGPDfilename(
    PTSTR   ptstrSrcFilename
    ) ;


PCOMMAND
CommandPtr(
    IN  PGPDDRIVERINFO  pGPDDrvInfo,
    IN  DWORD           UniCmdID
    ) ;

BOOL
InitDefaultOptions(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      poptsel,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
SeparateOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pCombinedOptions,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
CombineOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      pCombinedOptions,
    IN INT              iMaxOptions,
    IN POPTSELECT       pDocOptions,
    IN POPTSELECT       pPrinterOptions
    ) ;

PINFOHEADER
UpdateBinaryData(
    IN PRAWBINARYDATA   pnRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       poptsel
    ) ;

BOOL
ReconstructOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions
    ) ;

BOOL
ChangeOptionsViaID(
    IN PINFOHEADER  pInfoHdr ,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    ) ;

BOOL    BMapDmColorToOptIndex(
PINFOHEADER  pInfoHdr ,
IN  OUT     PDWORD       pdwOptIndex ,  //  is current setting ok?
                        //  if not return new index to caller
DWORD        dwDmColor  // what is requested in Devmode
) ;

BOOL    BMapOptIDtoOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwFeatureGID,
DWORD        dwOptID
) ;

BOOL    BMapPaperDimToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwWidth,   //  in Microns
DWORD        dwLength,   //  in Microns
OUT  PDWORD    pdwOptionIndexes
) ;

BOOL    BMapResToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwXres,
DWORD        dwYres
) ;

BOOL    BGIDtoFeaIndex(
PINFOHEADER  pInfoHdr ,
PDWORD       pdwFeaIndex ,
DWORD        dwFeatureGID ) ;

DWORD
MapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes
    ) ;

BOOL
CheckFeatureOptionConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwFeature1,
    IN DWORD            dwOption1,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2
    ) ;

BOOL
ResolveUIConflicts(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
EnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions ,
    IN INT              iMode
    ) ;


BOOL
EnumOptionsUnconstrainedByPrinterSticky(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT   pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions
    ) ;


BOOL
EnumNewUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions,
    OUT PCONFLICTPAIR   pConflictPair
    ) ;

BOOL
EnumNewPickOneUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex,
    OUT PCONFLICTPAIR   pConflictPair
    ) ;

BOOL
BIsFeaOptionCurSelected(
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex
    ) ;

BOOL
BSelectivelyEnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL           pbHonorConstraints,  // if non NULL
        // points to array of BOOL corresponding to each feature.
        //  if TRUE means constraint involving this feature is
        //  to be honored.  Otherwise ignore the constraint.
    OUT PBOOL           pbEnabledOptions,  // assume uninitialized
        //  if pConflictPair is NULL else contains current or proposed
        //  selections.  We will leave this array unchanged in this case.
    IN  DWORD   dwOptSel,  //  if pConflictPair exists but  pbEnabledOptions
        //  is NULL, assume pickone and dwOptSel holds that selection for
        //  the feature: dwFeatureIndex.
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
        //  actually lists the current selections.  Function then
        //  exits after encountering the first conflict.
        //  if a conflict exists, all fields in pConflictPair
        //  will be properly initialized  else dwFeatureIndex1 = -1
        //  the return value will be TRUE regardless.
    ) ;

BOOL
BEnumImposedConstraintsOnFeature
(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwTgtFeature,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2,
    OUT PBOOL           pbEnabledOptions,
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
    ) ;

DWORD    DwFindNodeInCurLevel(
PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
PATREEREF        patr ,  // index to a level in the attribute tree.
DWORD   dwOption   // search current level for this option
) ;

BOOL     BIsConstraintActive(
IN  PCONSTRAINTS    pcnstr ,   //  root of Constraint nodes
IN  DWORD   dwCNode,    //  first constraint node in list.
IN  PBOOL           pbHonorConstraints,  // if non NULL
IN  POPTSELECT       pOptions,
OUT PCONFLICTPAIR    pConflictPair   ) ;


// ----  functions defined in installb.c ---- //


DWORD    DwCountSynthFeatures(
IN     BOOL   (*fnBCreateFeature)(DWORD, DWORD, DWORD, PGLOBL ) ,  // callback
IN OUT PGLOBL pglobl
) ;

BOOL    BCreateSynthFeatures(
IN     DWORD   dwFea,  //  index of installable feature
IN     DWORD   dwOpt,  //  index of installable Option or set to INVALID_INDEX
IN     DWORD   dwSynFea,
IN OUT PGLOBL  pglobl) ;

BOOL    BEnableInvInstallableCombos(
PGLOBL pglobl);


// ----  functions defined in postproc.c ---- //

DWORD   dwFindLastNode(
DWORD  dwFirstNode,
PGLOBL pglobl) ;


BOOL    BappendCommonFontsToPortAndLandscape(
PGLOBL pglobl) ;

BOOL    BinitSpecialFeatureOptionFields(
PGLOBL pglobl) ;

BOOL    BIdentifyConstantString(
IN   PARRAYREF parString,
OUT  PDWORD    pdwDest,       //  write dword value here.
IN   DWORD     dwClassIndex,  // which class of constant is this?
     BOOL      bCustomOptOK,
IN   PGLOBL    pglobl
) ;

BOOL    BReadDataInGlobalNode(
PATREEREF   patr,  // address of field in GlobalAttrib struct
PDWORD      pdwHeapOffset,
PGLOBL      pglobl) ;

BOOL    BsetUQMFlag(
PGLOBL  pglobl);

VOID    VCountPrinterDocStickyFeatures(
PGLOBL pglobl) ;

BOOL    BConvertSpecVersionToDWORD(
    PWSTR   pwstrFileName ,
    PGLOBL  pglobl) ;


BOOL        BinitMiniRawBinaryData(
PGLOBL  pglobl) ;

BOOL    BexchangeArbDataInFOATNode(
    DWORD   dwFeature,
    DWORD   dwOption,
    DWORD   dwFieldOff,     // offset of field in FeatureOption struct
    DWORD   dwCount,        //  number bytes to copy.
OUT PBYTE   pubOut,         // previous contents of attribute node
IN  PBYTE   pubIn,          // new contents of attribute node.
    PBOOL   pbPrevsExists,  // previous contents existed.
    BOOL    bSynthetic,     //  access synthetic features
    PGLOBL  pglobl
)  ;

BOOL    BInitPriorityArray(
PGLOBL  pglobl) ;



// ----  functions defined in semanchk.c ---- //

BOOL
BCheckGPDSemantics(
    IN PINFOHEADER  pInfoHdr,
    POPTSELECT   poptsel   // assume fully initialized
    ) ;

// ----  functions defined in snapshot.c ---- //

PINFOHEADER   PINFOHDRcreateSnapshot(
PBYTE   pubnRaw,  //  raw binary data.    PSTATIC.   BETA2
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL  BinitOptionFields(
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,  // option extra structure if any.
PBYTE   pubnRaw,  //  raw binary data.
DWORD   dwFea,
DWORD   dwOpt,
POPTSELECT   poptsel ,  // assume fully initialized
PINFOHEADER  pInfoHdr,   // used to access global structure.
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitUIinfo(
PUIINFO     pUIinfo ,
PBYTE   pubnRaw,  //  PSTATIC.   BETA2
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitFeatures(
PFEATURE    pFeaturesDest,
PDFEATURE_OPTIONS  pfoSrc,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitGlobals(
PGLOBALS pGlobals,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitCommandTable(
PDWORD  pdwCmdTable,  //  dest array
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BinitRawData(
PRAWBINARYDATA   pRawData, // contained in INFOHEADER.
PBYTE   pubnRaw  //  Parser's raw binary data.
) ;

BOOL    BinitGPDdriverInfo(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BinitSequencedCmds(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BaddSequencedCmdToList(
DWORD   dwCmdIn,  // index of a command in CommandArray
PGPDDRIVERINFO  pGPDdriverInfo,
DWORD   dwNewListNode,  //  an unused listnode to add to the list.
PBYTE   pubnRaw  //  raw binary data.
) ;

BinitDefaultOptionArray(
POPTSELECT   poptsel,   // assume is large enough
PBYTE   pubnRaw) ;

TRISTATUS     EdetermineDefaultOption(
PBYTE   pubnRaw,  // start of Rawbinary data
DWORD   dwFeature,   // determine the default for this feature
PDFEATURE_OPTIONS  pfo,
POPTSELECT   poptsel, // assume is large enough
PDWORD       pdwPriority) ;

VOID    VtileDefault(
PBYTE   pubDest,
DWORD   dwDefault,
DWORD   dwBytes) ;

VOID    VtransferValue(
OUT PBYTE   pubDest,
IN  PBYTE   pubSrc ,
IN  DWORD   dwBytes,
IN  DWORD   dwFlags,
IN  DWORD   dwDefaultValue,  // holds bit flag value.
IN  PBYTE   pubHeap ) ;  //  used to form ptr if SSF_MAKE_STRINGPTR

BOOL    BspecialProcessOption(
PBYTE   pubnRaw,  // start of Rawbinary data
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,
PDFEATURE_OPTIONS  pfo ,  // source data
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.
PINFOHEADER  pInfoHdr,   // used to access global structure.
DWORD   dwFea,   //  feature index
DWORD   dwOpt,
BOOL   bDefaultOpt
) ;

TRISTATUS     EextractValueFromTree(
PBYTE   pubnRaw,  // start of Rawbinary data
DWORD   dwSSTableIndex,  // some info about this value.
OUT PBYTE    pubDest,  // write value or link here
OUT PDWORD  pdwUnresolvedFeature,  // if the attribute tree has
            //  a dependency on this feature and the current option
            //  for that feature is not defined  in poptsel, this
            //  function will write the index of the required
            //  feature in pdwUnresolvedFeature.
IN  ATREEREF    atrRoot,    //  root of attribute tree to navigate.
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.  may be filled with OPTION_INDEX_ANY
                //  if we are jumpstarting
IN  DWORD   dwFeature,
IN OUT  PDWORD   pdwNextOpt  //  if multiple options are selected
    //  for dwFeature, pdwNextOpt points to the Nth option to consider
    //  in the  poptsel list,  at return time, this value
    //  is incremented if there are remaining options selected,
    //  else is reset to zero.
    //  For the first call, or PICKONE features,
    //  this value must be set to zero.
) ;

BOOL   RaisePriority(
DWORD   dwFeature1,
DWORD   dwFeature2,
PBYTE   pubnRaw,
PDWORD  pdwPriority) ;

DWORD  dwNumOptionSelected(
IN  DWORD  dwNumFeatures,
IN  POPTSELECT       poptsel
) ;

BOOL  BinitSnapShotIndexTable(PBYTE  pubnRaw) ;

BOOL    BinitSizeOptionTables(PBYTE  pubnRaw) ;

PRAWBINARYDATA
LoadRawBinaryData (
    IN PTSTR    ptstrDataFilename
    ) ;

PRAWBINARYDATA
GpdLoadCachedBinaryData(
    PTSTR   ptstrGpdFilename
    ) ;

VOID
UnloadRawBinaryData (
    IN PRAWBINARYDATA   pnRawData
) ;

PINFOHEADER
InitBinaryData(
    IN PRAWBINARYDATA   pnRawData,        // actually pStatic
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    ) ;

VOID
FreeBinaryData(
    IN PINFOHEADER pInfoHdr
    ) ;

BOOL    BIsRawBinaryDataInDate(
IN  PBYTE   pubRaw) ;  // this is pointer to memory mapped file! BETA2

BOOL BgetLocFeaOptIndex(
    IN     PRAWBINARYDATA   pnRawData,
       OUT PDWORD           pdwFea,
       OUT PDWORD           pdwOptIndex
    );

BOOL BgetLocFeaIndex(
    IN  PRAWBINARYDATA   pnRawData,
    OUT PDWORD           pdwFea
    );

BOOL   BfindMatchingOrDefaultNode(
IN  PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
IN  OUT  PDWORD  pdwNodeIndex,  // Points to first node in chain
IN  DWORD   dwOptionID     //  may even take on the value DEFAULT_INIT
) ;


// ----  functions defined in snaptbl.c ---- //

DWORD   DwInitSnapShotTable1(
PBYTE   pubnRaw) ;

DWORD   DwInitSnapShotTable2(
PBYTE   pubnRaw,
DWORD   dwI) ;



// ----  functions defined in state1.c ---- //

BOOL   BInterpretTokens(
PTKMAP  ptkmap,      // pointer to tokenmap
BOOL    bFirstPass,  //  is this the first or 2nd time around?
PGLOBL  pglobl
) ;

BOOL  BprocessSpecialKeyword(
PTKMAP  ptkmap,      // pointer to tokenmap
BOOL    bFirstPass,  //  is this the first or 2nd time around?
PGLOBL  pglobl
) ;

BOOL  BprocessSymbolKeyword(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
PGLOBL  pglobl
) ;

VOID    VinitAllowedTransitions(
PGLOBL pglobl) ;

BOOL    BpushState(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
BOOL    bFirstPass,
PGLOBL  pglobl
) ;

BOOL   BchangeState(
PTKMAP      ptkmap,  // pointer to construct in tokenmap
CONSTRUCT   eConstruct,   //  this will induce a transition to NewState
STATE       stOldState,
BOOL        bSymbol,      //  should dwValue be saved as a SymbolID ?
BOOL        bFirstPass,
PGLOBL      pglobl
) ;

DWORD   DWregisterSymbol(
PABSARRAYREF  paarSymbol,   // the symbol string to register
CONSTRUCT     eConstruct ,  // type of construct determines class of symbol.
BOOL          bCopy,        //  shall we copy paarSymbol to heap?  May set
DWORD         dwFeatureID,   //  if you are registering an option symbol
PGLOBL        pglobl
) ;

BOOL  BaddAARtoHeap(
PABSARRAYREF    paarSrc,
PARRAYREF       parDest,
DWORD           dwAlign,
PGLOBL          pglobl) ;

BOOL     BwriteToHeap(
OUT  PDWORD  pdwDestOff,   //  heap offset of dest string
     PBYTE   pubSrc,       //  points to src string
     DWORD   dwCnt,        //  num bytes to copy from src to dest.
     DWORD   dwAlign,
     PGLOBL  pglobl) ;

DWORD   DWsearchSymbolListForAAR(
PABSARRAYREF    paarSymbol,
DWORD           dwNodeIndex,
PGLOBL          pglobl) ;

DWORD   DWsearchSymbolListForID(
DWORD       dwSymbolID,   // find node containing this ID.
DWORD       dwNodeIndex,
PGLOBL      pglobl) ;

BOOL  BCmpAARtoAR(
PABSARRAYREF    paarStr1,
PARRAYREF       parStr2,
PGLOBL          pglobl) ;

BOOL  BpopState(
PGLOBL    pglobl) ;

VOID   VinitDictionaryIndex(
PGLOBL    pglobl) ;

VOID    VcharSubstitution(
PABSARRAYREF   paarStr,
BYTE           ubTgt,
BYTE           ubReplcmnt,
PGLOBL         pglobl) ;


VOID   VIgnoreBlock(
PTKMAP      ptkmap,
BOOL        bIgnoreBlock,
PGLOBL      pglobl) ;


// ----  functions defined in state2.c ---- //


BOOL  BprocessAttribute(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreFontCartAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreTTFontSubAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;


BOOL   BstoreCommandAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreFeatureOptionAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL  BstoreGlobalAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL    BaddBranchToTree(
PTKMAP      ptkmap,         // pointer to tokenmap
PATREEREF   patrAttribRoot,  //   pointer to dword with index
PGLOBL      pglobl
) ;

BOOL   BcreateGlobalInitializerNode(
PDWORD  pdwNodeIndex,
DWORD   dwOffset,
PGLOBL  pglobl) ;

BOOL   BcreateEndNode(
PDWORD  pdwNodeIndex,
DWORD   dwFeature,
DWORD   dwOption,
PGLOBL  pglobl
) ;

BOOL   BfindOrCreateMatchingNode(
IN  DWORD   dwRootNodeIndex , //  first node in chain matching feature
OUT PDWORD  pdwNodeIndex,     // points to node in chain also matching option
    DWORD   dwFeatureID,      //
    DWORD   dwOptionID,       //  may even take on the value DEFAULT_INIT
    PGLOBL  pglobl
) ;

BOOL   BfindMatchingNode(
IN   DWORD   dwRootNodeIndex ,  //  first node in chain matching feature
OUT  PDWORD  pdwNodeIndex,  // points to node in chain also matching option
     DWORD   dwFeatureID,
     DWORD   dwOptionID,    //  may even take on the value DEFAULT_INIT
     PGLOBL  pglobl
) ;

BOOL BallocElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
PDWORD       pdwNodeIndex,
PGLOBL       pglobl) ;

BOOL  BreturnElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
DWORD        dwNodeIndex,
PGLOBL       pglobl) ;

BOOL    BconvertSymCmdIDtoUnidrvID(
IN  DWORD   dwCommandID , //  from RegisterSymbol
OUT PDWORD  pdwUnidrvID,
    PGLOBL  pglobl
) ;


// ----  functions defined in token1.c ---- //


BOOL    BcreateTokenMap(
PWSTR   pwstrFileName,
PGLOBL  pglobl )  ;

PARSTATE  PARSTscanForKeyword(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PARSTATE  PARSTparseColon(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PARSTATE  PARSTparseValue(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

BOOL  BparseKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BisExternKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL  BisColonNext(
PGLOBL  pglobl) ;

BOOL    BeatArbitraryWhite(
PGLOBL  pglobl) ;

BOOL    BeatComment(
PGLOBL  pglobl) ;

BOOL    BscanStringSegment(
PGLOBL  pglobl) ;

BOOL    BscanDelimitedString(
BYTE  ubDelimiter,
PBOOL    pbMacroDetected,
PGLOBL  pglobl) ;


PARSTATE    PARSTrestorePrevsFile(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PWSTR
PwstrAnsiToUnicode(
    IN  PSTR    pstrAnsiString ,
        PGLOBL  pglobl) ;

PARSTATE    PARSTloadIncludeFile(
PDWORD   pdwTKMindex,
PWSTR   pwstrFileName,    // root GPD file
PGLOBL  pglobl);

BOOL    BloadFile(
PWSTR   pwstrFileName,
PGLOBL  pglobl ) ;

BOOL        BarchiveStrings(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

DWORD  DWidentifyKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BidentifyAttributeKeyword(
PTKMAP  ptkmap,  // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL    BcopyToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL  pglobl) ;

DWORD    dwStoreFileName(PWSTR    pwstrFileName,
PARRAYREF   parDest,
PGLOBL  pglobl) ;

VOID    vFreeFileNames(
PGLOBL  pglobl) ;

VOID    vIdentifySource(
    PTKMAP   ptkmap ,
    PGLOBL  pglobl) ;


// ----  functions defined in value1.c ---- //


BOOL   BaddValueToHeap(
IN  OUT  PDWORD  ploHeap,  // dest offset to value in binary form
IN   PTKMAP  ptkmap,   // pointer to tokenmap
IN   BOOL    bOverWrite,  // assume ploHeap contains a valid offset
        //  to a reserved region of the heap of the proper size
        //  and write binary value into this location instead of
        //  growing heap.  Note:  defer overwriting lpHeap
        //  until we are certain of success.
IN  OUT PGLOBL      pglobl
) ;

BOOL   BparseAndWrite(
IN      PBYTE   pubDest,       // write binary data or link to this address.
IN      PTKMAP  ptkmap,        // pointer to tokenmap
IN      BOOL    bAddToHeap,    // if true, write to curHeap not pubDest
OUT     PDWORD  pdwHeapOffset, // if (bAddToHeap)  heap offset where
IN  OUT PGLOBL  pglobl
) ;

BOOL    BparseInteger(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue, // dummy
IN  PGLOBL        pglobl
)  ;

BOOL    BparseList(
IN     PABSARRAYREF  paarValue,
IN     PDWORD        pdwDest,       //  location where index to start of list
                                    //  is saved
IN     BOOL          (*fnBparseValue)(PABSARRAYREF, PDWORD, VALUE, PGLOBL),   // callback
IN     VALUE         eAllowedValue,  // dummy
IN OUT PGLOBL
) ;

BOOL    BeatLeadingWhiteSpaces(
IN  OUT  PABSARRAYREF   paarSrc
) ;

BOOL    BeatDelimiter(
IN  OUT  PABSARRAYREF   paarSrc,
IN  PBYTE  pubDelStr        //  points to a string which paarSrc must match
) ;

BOOL    BdelimitToken(
IN  OUT  PABSARRAYREF   paarSrc,    //  source string
IN  PBYTE   pubDelimiters,          //  array of valid delimiters
OUT     PABSARRAYREF   paarToken,   //  token defined by delimiter
OUT     PDWORD      pdwDel      //  which delimiter was first encountered?
) ;

BOOL    BeatSurroundingWhiteSpaces(
IN  PABSARRAYREF   paarSrc
) ;

BOOL    BparseSymbol(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,        //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
)  ;

BOOL    BparseQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,        //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
)  ;

BOOL    BparsePartiallyQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,        //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
) ;

BOOL    BparseOptionSymbol(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue, // which class of symbol is this?
IN  PGLOBL        pglobl
) ;

BOOL    BparseConstant(
IN  OUT  PABSARRAYREF  paarValue,
OUT      PDWORD        pdwDest,       //  write dword value here.
IN       VALUE         eAllowedValue,  // which class of constant is this?
IN       PGLOBL        pglobl
) ;

BOOL  BinitClassIndexTable(
IN  OUT     PGLOBL    pglobl) ;

BOOL    BparseRect(
IN  PABSARRAYREF   paarValue,
IN  PRECT   prcDest,
    PGLOBL   pglobl
) ;

BOOL    BparsePoint(
IN  PABSARRAYREF   paarValue,
IN  PPOINT   pptDest,
    PGLOBL   pglobl
) ;

BOOL    BparseString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  OUT PGLOBL      pglobl
) ;

BOOL    BparseAndTerminateString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  VALUE          eAllowedValue,
IN  OUT PGLOBL     pglobl
) ;

BOOL     BwriteUnicodeToHeap(
IN   PARRAYREF      parSrcString,
OUT  PARRAYREF      parUnicodeString,
IN   INT            iCodepage,
IN  OUT PGLOBL      pglobl
) ;

BOOL    BparseStrSegment(
IN  PABSARRAYREF   paarStrSeg,      // source str segment
IN  PARRAYREF      parStrLiteral,   // dest for result
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseStrLiteral(
IN  PABSARRAYREF   paarStrSeg,      // points to literal substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseHexStr(
IN  PABSARRAYREF   paarStrSeg,      // points to hex substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseOrderDep(
IN  PABSARRAYREF   paarValue,
IN  PORDERDEPENDENCY   pordDest,
    PGLOBL   pglobl
) ;

// ----  functions defined in  macros1.c ---- //

BOOL  BevaluateMacros(
PGLOBL pglobl) ;

BOOL    BDefineValueMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

BOOL    BResolveValueMacroReference(
PTKMAP  ptkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BdelimitName(
PABSARRAYREF    paarValue,   //  the remainder of the string without the Name
PABSARRAYREF    paarToken,   //  contains the Name
PBYTE  pubChar ) ;


BOOL    BCatToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL          pglobl) ;

BOOL    BResolveBlockMacroReference(
PTKMAP   ptkmap,
DWORD    dwMacRefIndex,
PGLOBL   pglobl) ;

BOOL    BDefineBlockMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

BOOL    BIncreaseMacroLevel(
BOOL    bMacroInProgress,
PGLOBL  pglobl) ;

BOOL    BDecreaseMacroLevel(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

VOID    VEnumBlockMacro(
PTKMAP  pNewtkmap,
PBLOCKMACRODICTENTRY    pBlockMacroDictEntry,
PGLOBL  pglobl ) ;



// ----  functions defined in  shortcut.c ---- //


BOOL    BInitKeywordField(
PTKMAP  pNewtkmap,
PGLOBL  pglobl) ;

BOOL    BExpandMemConfig(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BExpandCommand(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL  BexpandShortcuts(
PGLOBL  pglobl) ;


BOOL  BSsyncTokenMap(
PTKMAP   ptkmap,
PTKMAP   pNewtkmap ,
PGLOBL  pglobl) ;



// ------- end function declarations ------- //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\helper1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  helper1.c - helper functions  */



#include    "gpdparse.h"





// ----  functions defined in helper1.c ---- //



PTSTR  pwstrGenerateGPDfilename(
    PTSTR   ptstrSrcFilename
    ) ;

#ifndef  PARSERDLL

PCOMMAND
CommandPtr(
    IN  PGPDDRIVERINFO  pGPDDrvInfo,
    IN  DWORD           UniCmdID
    ) ;

BOOL
InitDefaultOptions(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      poptsel,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
SeparateOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pCombinedOptions,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
CombineOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      pCombinedOptions,
    IN INT              iMaxOptions,
    IN POPTSELECT       pDocOptions,
    IN POPTSELECT       pPrinterOptions
    ) ;

PINFOHEADER
UpdateBinaryData(
    IN PRAWBINARYDATA   pnRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       poptsel
    ) ;

BOOL
ReconstructOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions
    ) ;

BOOL
ChangeOptionsViaID(
    IN PINFOHEADER  pInfoHdr ,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    ) ;

BOOL    BMapDmColorToOptIndex(
PINFOHEADER  pInfoHdr ,
IN  OUT     PDWORD       pdwOptIndex ,  //  is current setting ok?
                        //  if not return new index to caller
DWORD        dwDmColor  // what is requested in Devmode
) ;

BOOL    BMapOptIDtoOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwFeatureGID,
DWORD        dwOptID
) ;

BOOL    BMapPaperDimToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwWidth,   //  in Microns
DWORD        dwLength,   //  in Microns
OUT  PDWORD    pdwOptionIndexes
) ;

BOOL    BMapResToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwXres,
DWORD        dwYres
) ;

BOOL    BGIDtoFeaIndex(
PINFOHEADER  pInfoHdr ,
PDWORD       pdwFeaIndex ,
DWORD        dwFeatureGID ) ;



DWORD
MapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes
    ) ;


DWORD
UniMapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes,       // used only for GID_PAGESIZE
    IN    PDWORD       pdwPaperID   //  optional paperID
    ) ;


DWORD   MapPaperAttribToOptIndex(
PINFOHEADER  pInfoHdr ,
IN     PDWORD       pdwPaperID ,  //  optional paperID
DWORD        dwWidth,   //  in Microns (set to zero to ignore)
DWORD        dwLength,   //  in Microns
OUT  PDWORD    pdwOptionIndexes  //  cannot be NULL
) ;


BOOL
CheckFeatureOptionConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwFeature1,
    IN DWORD            dwOption1,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2
    ) ;

BOOL
ResolveUIConflicts(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    ) ;

BOOL
EnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions ,
    IN INT              iMode
    ) ;


BOOL
EnumOptionsUnconstrainedByPrinterSticky(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT   pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions
    ) ;



BOOL
EnumNewUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions,
    OUT PCONFLICTPAIR   pConflictPair
    ) ;

BOOL
EnumNewPickOneUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex,
    OUT PCONFLICTPAIR   pConflictPair
    ) ;

BOOL
BIsFeaOptionCurSelected(
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex
    ) ;

BOOL
BSelectivelyEnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL           pbHonorConstraints,  // if non NULL
        // points to array of BOOL corresponding to each feature.
        //  if TRUE means constraint involving this feature is
        //  to be honored.  Otherwise ignore the constraint.
    OUT PBOOL           pbEnabledOptions,  // assume uninitialized
        //  if pConflictPair is NULL else contains current or proposed
        //  selections.  We will leave this array unchanged in this case.
    IN  DWORD   dwOptSel,  //  if pConflictPair exists but  pbEnabledOptions
        //  is NULL, assume pickone and dwOptSel holds that selection for
        //  the feature: dwFeatureIndex.
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
        //  actually lists the current selections.  Function then
        //  exits after encountering the first conflict.
        //  if a conflict exists, all fields in pConflictPair
        //  will be properly initialized  else dwFeatureIndex1 = -1
        //  the return value will be TRUE regardless.
    ) ;

BOOL
BEnumImposedConstraintsOnFeature
(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwTgtFeature,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2,
    OUT PBOOL           pbEnabledOptions,
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
    ) ;

DWORD    DwFindNodeInCurLevel(
PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
PATREEREF        patr ,  // index to a level in the attribute tree.
DWORD   dwOption   // search current level for this option
) ;

BOOL     BIsConstraintActive(
IN  PCONSTRAINTS    pcnstr ,   //  root of Constraint nodes
IN  DWORD   dwCNode,    //  first constraint node in list.
IN  PBOOL           pbHonorConstraints,  // if non NULL
IN  POPTSELECT       pOptions,
OUT PCONFLICTPAIR    pConflictPair   ) ;

#ifdef  GMACROS


BOOL
ResolveDependentSettings(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions
    ) ;


void  EnumSelectedOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeature,
    IN PBOOL            pbSelectedOptions) ;

BOOL
ExecuteMacro(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN    DWORD    dwFea,    //  what feature was selected in UI
    IN    DWORD    dwOpt ,   //  what option was selected in UI
    OUT PBOOL   pbFeaturesChanged  // tell Amanda what Features were changed.
    ) ;

#endif

#endif  PARSERDLL


// ------- end function declarations ------- //



PTSTR  pwstrGenerateGPDfilename(
    PTSTR   ptstrSrcFilename
    )

/*++

Routine Description:

    Generate a filename for the cached binary GPD data given a GPD filename

Arguments:

    ptstrSrcFilename - Specifies the GPD src filename

Return Value:

    Pointer to BPD filename string, NULL if there is an error

--*/

{
    PTSTR   ptstrBpdFilename, ptstrExtension;
    INT     iLength;

    //
    // If the GPD filename has .GPD extension, replace it with .BUD extension.
    // Otherwise, append .BUD extension at the end.
    //

    if(!ptstrSrcFilename)
        return NULL ;   // will never happen in reality, just to silence PREFIX

    iLength = _tcslen(ptstrSrcFilename);

    if ((ptstrExtension = _tcsrchr(ptstrSrcFilename, TEXT('.'))) == NULL ||
        _tcsicmp(ptstrExtension, GPD_FILENAME_EXT) != EQUAL_STRING)
    {
        WARNING(("Bad GPD filename extension: %ws\n", ptstrSrcFilename));

        ptstrExtension = ptstrSrcFilename + iLength;
        iLength += _tcslen(BUD_FILENAME_EXT);
    }

    //
    // Allocate memory and compose the BUD filename
    //

    if (ptstrBpdFilename = MemAlloc((iLength + 1) * sizeof(TCHAR)))
    {
        _tcscpy(ptstrBpdFilename, ptstrSrcFilename);
        _tcscpy(ptstrBpdFilename + (ptstrExtension - ptstrSrcFilename),
                            BUD_FILENAME_EXT);

        VERBOSE(("BUD filename: %ws\n", ptstrBpdFilename));
    }
    else
    {
        ERR(("Fatal: pwstrGenerateGPDfilename - unable to alloc %d bytes.\n",
            (iLength + 1) * sizeof(TCHAR)));
    }

    return (ptstrBpdFilename);
}


#ifndef  PARSERDLL


PCOMMAND
CommandPtr(
    IN  PGPDDRIVERINFO  pGPDDrvInfo,
    IN  DWORD           UniCmdID
    )
{
    return ((((PDWORD)((PBYTE)(pGPDDrvInfo)->pInfoHeader +
              (pGPDDrvInfo)->DataType[DT_COMMANDTABLE].loOffset))
              [(UniCmdID)] == UNUSED_ITEM ) ? NULL :
              (PCOMMAND)((pGPDDrvInfo)->pubResourceData +
              (pGPDDrvInfo)->DataType[DT_COMMANDARRAY].loOffset)
              + ((PDWORD)((PBYTE)(pGPDDrvInfo)->pInfoHeader +
              (pGPDDrvInfo)->DataType[DT_COMMANDTABLE].loOffset))[(UniCmdID)]);
}


BOOL
InitDefaultOptions(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      poptsel,
    IN INT              iMaxOptions,
    IN INT              iMode
    )
{
    INT iOptionsNeeded ;
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    if(iMode != MODE_DOCANDPRINTER_STICKY)
    {
        POPTSELECT      pOptions = NULL;
        BOOL    bStatus = TRUE ;

        if(iMode == MODE_DOCUMENT_STICKY)
            iOptionsNeeded = pRawData->dwDocumentFeatures ;
        else  //  MODE_PRINTER_STICKY
            iOptionsNeeded = pRawData->dwPrinterFeatures ;

        if(iOptionsNeeded > iMaxOptions)
            return(FALSE);

        pOptions = (POPTSELECT)MemAlloc(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS) ;
        if(!poptsel  ||  !pOptions  ||
            !BinitDefaultOptionArray(pOptions, (PBYTE)pnRawData))
        {
            bStatus = FALSE;
        }

        if(!bStatus   ||  !SeparateOptionArray(pnRawData,
                pOptions,   //  pCombinedOptions,
                poptsel,    //  dest array
                iMaxOptions, iMode))
        {
            bStatus = FALSE;
            ERR(("InitDefaultOptions: internal failure.\n"));
        }

        if(pOptions)
            MemFree(pOptions) ;

        return(bStatus);
    }
    else    //  MODE_DOCANDPRINTER_STICKY
    {
        iOptionsNeeded = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures ;
        if(iOptionsNeeded > iMaxOptions)
            return(FALSE);

        if(!poptsel  ||
            !BinitDefaultOptionArray(poptsel, (PBYTE)pnRawData))
        {
            return(FALSE);
        }
    }




    return(TRUE);
}


BOOL
SeparateOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pCombinedOptions,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    )
{
    DWORD   dwNumSrcFea, dwNumDestFea, dwStart, dwI, dwDestTail,
        dwDest, dwSrcTail;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubRaw ;  //  raw binary data.
    INT     iOptionsNeeded;
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA


    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;

    dwStart = 0 ;  // starting src index

    if(iMode == MODE_DOCUMENT_STICKY)
    {
        dwNumSrcFea = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
            //  number of candidates - not same as num of doc sticky features.
        dwNumDestFea = pRawData->dwDocumentFeatures ;
    }
    else  //  MODE_PRINTER_STICKY
    {
        dwNumSrcFea = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount
                    + pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;
        dwNumDestFea = pRawData->dwPrinterFeatures ;
    }

    //  assume pCombinedOptions large enough to
    //  hold all Feature and any pickmany selections.

    dwDestTail = dwNumDestFea ; //  where pickmany selections are stored.
    dwDest = 0 ;  //  where to store first selection for each feature.

    //  first pass:
    //  Just count number of optselect elements needed.

    iOptionsNeeded  = 0 ;

    for(dwI = dwStart ; dwI < dwStart + dwNumSrcFea ; dwI++)
    {
        DWORD   dwNextOpt, dwFeatureType = FT_PRINTERPROPERTY, dwUnresolvedFeature ;
        PATREEREF    patrRoot ;    //  root of attribute tree to navigate.

        //  is this a printer or doc sticky feature?


        patrRoot = &(pfo[dwI].atrFeatureType) ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSFeatureTypeIndex,
            (PBYTE)&dwFeatureType,
            &dwUnresolvedFeature,  *patrRoot, pCombinedOptions,
            0, // set to  any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            ERR(("SeparateOptionArray: EextractValueFromTree failed.\n"));
            return(FALSE) ;
        }



        if(dwI < pearTableContents[MTI_DFEATURE_OPTIONS].dwCount)
        {
            if(dwFeatureType != FT_PRINTERPROPERTY)
            {
                if(iMode == MODE_PRINTER_STICKY)
                    continue ;
            }
            else
            {
                if(iMode == MODE_DOCUMENT_STICKY)
                    continue ;
            }

        }
        else
        {
            //  synthesized features are always printer sticky.
            if(iMode == MODE_DOCUMENT_STICKY)
                continue ;
        }

        iOptionsNeeded++ ;
        dwSrcTail = dwI ;

        while(dwSrcTail = pCombinedOptions[dwSrcTail].ubNext)
        {
            iOptionsNeeded++ ;
        }
    }

    if(iOptionsNeeded > iMaxOptions)
        return(FALSE);

    for(dwI = dwStart ; dwI < dwStart + dwNumSrcFea ; dwI++)
    {
        DWORD   dwNextOpt, dwFeatureType, dwUnresolvedFeature ;
        PATREEREF    patrRoot ;    //  root of attribute tree to navigate.

        //  is this a printer or doc sticky feature?


        patrRoot = &(pfo[dwI].atrFeatureType) ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSFeatureTypeIndex,
            (PBYTE)&dwFeatureType,
            &dwUnresolvedFeature,  *patrRoot, pCombinedOptions,
            0, // set to  any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            ERR(("SeparateOptionArray: EextractValueFromTree failed.\n"));
            return(FALSE) ;
        }



        if(dwI < pearTableContents[MTI_DFEATURE_OPTIONS].dwCount)
        {
            if(dwFeatureType != FT_PRINTERPROPERTY)
            {
                if(iMode == MODE_PRINTER_STICKY)
                    continue ;
            }
            else
            {
                if(iMode == MODE_DOCUMENT_STICKY)
                    continue ;
            }

        }
        else
        {
            //  synthesized features are always printer sticky.
            if(iMode == MODE_DOCUMENT_STICKY)
                continue ;
        }

        pOptions[dwDest].ubCurOptIndex = pCombinedOptions[dwI].ubCurOptIndex;
        if(!pCombinedOptions[dwI].ubNext)  //  end of list
            pOptions[dwDest].ubNext = 0 ;
        else
        {
            dwSrcTail = pCombinedOptions[dwI].ubNext ;
                //  this node holds another selection.
            pOptions[dwDest].ubNext = (BYTE)dwDestTail ;

            while(dwSrcTail)
            {
                pOptions[dwDestTail].ubCurOptIndex =
                        pCombinedOptions[dwSrcTail].ubCurOptIndex;
                pOptions[dwDestTail].ubNext = (BYTE)dwDestTail + 1 ;
                dwDestTail++ ;
                dwSrcTail = pCombinedOptions[dwSrcTail].ubNext ;
            }
            pOptions[dwDestTail - 1].ubNext = 0 ;
        }
        dwDest++ ;
    }

    return(TRUE);
}


BOOL
CombineOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    OUT POPTSELECT      pCombinedOptions,
    IN INT              iMaxOptions,
    IN POPTSELECT       pDocOptions,
    IN POPTSELECT       pPrinterOptions
    )
/*  Note:

    Either pDocOptions or pPrinterOptions could be NULL but not both. If pDocOptions
    is NULL, then in the combined option array, the options for document-sticky
    features will be OPTION_INDEX_ANY. Same is true when pPrinterOptions is NULL.
*/



{
    DWORD           dwNumSrcFea, dwNumDestFea, dwStart, dwI, dwDestTail,
                    dwSrcTail,   dwNDoc,
                    dwSrcPrnStickyIndex,  dwSrcDocStickyIndex ;
    PENHARRAYREF    pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE           pubRaw ;        //  raw binary data.
    INT             iOptionsNeeded;
    PRAWBINARYDATA  pRawData ;
    PSTATICFIELDS   pStatic ;
    DWORD           dwFea,          //Feature Index of Locale
                    dwOptIndex;     // Index of the Option that matches
                                    // the system locale.

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA


    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;

    dwStart = 0 ;  // starting src index


    dwNumDestFea = pRawData->dwDocumentFeatures +
                        pRawData->dwPrinterFeatures ;



    //  how many option nodes will be used in the combined array?

    iOptionsNeeded = pRawData->dwDocumentFeatures ;
    if(pDocOptions)
    {
        for(dwI = 0 ; dwI < pRawData->dwDocumentFeatures ; dwI++)
        {

            dwSrcTail = dwI ;

            while(dwSrcTail = pDocOptions[dwSrcTail].ubNext)
            {
                iOptionsNeeded++ ;
            }
        }
    }
    iOptionsNeeded += pRawData->dwPrinterFeatures ;
    if(pPrinterOptions)
    {
        for(dwI = 0 ; dwI < pRawData->dwPrinterFeatures ; dwI++)
        {

            dwSrcTail = dwI ;

            while(dwSrcTail = pPrinterOptions[dwSrcTail].ubNext)
            {
                iOptionsNeeded++ ;
            }
        }
    }

    if(iOptionsNeeded > iMaxOptions)
        return(FALSE);

    dwDestTail = dwNumDestFea ; //  start of pickmany selections

    dwSrcPrnStickyIndex = dwSrcDocStickyIndex = 0 ;
    // where to start reading from as we interleave the
    // two sources to form the combined array.

    for(dwI = 0 ; dwI < pearTableContents[MTI_DFEATURE_OPTIONS].dwCount +
                    pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount ;
                                    dwI++)
    {
        DWORD   dwNextOpt, dwFeatureType, dwUnresolvedFeature ;
        PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
        POPTSELECT      pSrcOptions ;
        PDWORD          pdwSrcIndex ;


        //  assume printer sticky until proven otherwise.

        pSrcOptions = pPrinterOptions ;  // may be null.
        pdwSrcIndex = &dwSrcPrnStickyIndex ;


        if(dwI < pearTableContents[MTI_DFEATURE_OPTIONS].dwCount)
        {
            //  GPD defined features may be Doc or Printer sticky.

            patrRoot = &(pfo[dwI].atrFeatureType) ;

            dwNextOpt = 0 ;  // extract info for first option selected for
                                //  this feature.

            //  note we give EextractValueFromTree a ptr to
            //  an uninitialized option array pCombinedOptions just
            //  in case it has the urge to access an option array.
            //  I point out that FeatureType is not multi-valued.

            if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSFeatureTypeIndex,
                (PBYTE)&dwFeatureType,
                &dwUnresolvedFeature,  *patrRoot, pCombinedOptions,
                0, // set to  any value.  Doesn't matter.
                &dwNextOpt) != TRI_SUCCESS)
            {
                ERR(("CombineOptionArray: EextractValueFromTree failed.\n"));
                return(FALSE) ;
            }

            if(dwFeatureType != FT_PRINTERPROPERTY)
            {
                pSrcOptions = pDocOptions ;
                pdwSrcIndex = &dwSrcDocStickyIndex ;
            }
        }


        if(!pSrcOptions)  // no option array supplied.
        {
            pCombinedOptions[dwI].ubCurOptIndex = OPTION_INDEX_ANY ;
            pCombinedOptions[dwI].ubNext = 0 ;  // eol
        }
        else
        {
            dwSrcTail = *pdwSrcIndex ;

            pCombinedOptions[dwI].ubCurOptIndex =
                        pSrcOptions[*pdwSrcIndex].ubCurOptIndex ;
            if(pSrcOptions[*pdwSrcIndex].ubNext)
            {
                pCombinedOptions[dwI].ubNext = (BYTE)dwDestTail ;

                while(dwSrcTail = pSrcOptions[dwSrcTail].ubNext)
                {
                    pCombinedOptions[dwDestTail].ubCurOptIndex =
                        pSrcOptions[dwSrcTail].ubCurOptIndex ;
                    pCombinedOptions[dwDestTail].ubNext = (BYTE)dwDestTail + 1;
                    dwDestTail++ ;
                }
                pCombinedOptions[dwDestTail - 1].ubNext = 0 ;
            }
            else
                pCombinedOptions[dwI].ubNext = 0 ;

            (*pdwSrcIndex)++ ;
        }
    }

//  Special case processing for Locale. If there is a conflict between
//  locale as stored in the registry ( i.e. the printer feature option
//  related registry) and the System Locale, then give importance to
//  the option that matches the system locale.


    dwFea = dwOptIndex = (DWORD)-1;    // Safety sake initialization.
    if ( !BgetLocFeaOptIndex(pnRawData, &dwFea, &dwOptIndex) )
    {
        return FALSE;
    }
    if ( dwFea == -1 ) //Locale keyword not in gpd. Nothing to do.
    {
        return TRUE;
    }

    if (dwOptIndex == -1)  // Find the default option.
    {
        // Here we want to find the default option index.
        // The assumption here is that Locale option is not dependent
        // on any other feature. This is true cos Locale is only system
        // dependent and should not depend on any other feature. But
        // in the long run if some other dependency arises, we may have to
        // change the code.
        ATREEREF atrOptIDNode = pfo[dwFea].atrDefaultOption;
        PBYTE    pubHeap      = (PBYTE)(pubRaw +
                        pearTableContents[MTI_STRINGHEAP]. loOffset) ;

        if ( atrOptIDNode & ATTRIB_HEAP_VALUE)
        {
            dwOptIndex = *((PDWORD)(pubHeap +
                            (atrOptIDNode & ~ATTRIB_HEAP_VALUE))) ;
        }
        else {
            ERR(("Error in processing Default Option for Feature Locale. Continuing....\n"));
            return TRUE;    //Dont do any processing.
        }
        // i.e.
    }
    // Could have used ReconstructOptionArray() but prefered to go
    // with the constructs used in this function.
    // Another assumption is that multiple options cannot be selected.
    // Thats why pCombinedOptions[dwFea].ubNext = 0
    pCombinedOptions[dwFea].ubCurOptIndex = (BYTE)dwOptIndex;
    pCombinedOptions[dwFea].ubNext = 0;

    return(TRUE);
}



#ifndef KERNEL_MODE

PINFOHEADER
UpdateBinaryData(
    IN PRAWBINARYDATA   pnRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       poptsel
    )
{

    DWORD               dwNumFeatures, loFeatures, dwFea, dwI, dwNumOptions ,
                        dwSizeOption ;
    PGPDDRIVERINFO      pGPDdriverInfo;
    PUIINFO             pUIinfo ;
    PFEATURE            pFeaturesDest ;
    PENHARRAYREF        pearTableContents ;
    PDFEATURE_OPTIONS   pfo ;
//  PMINIRAWBINARYDATA  pmrbd  ;
    PBYTE               pubRaw,           // raw binary data.
                        pubOptionsDest ,  // ptr to any of the several varieties
                        pubDestOptionEx ; // of option structures.
    PRAWBINARYDATA      pRawData ;
    PSTATICFIELDS       pStatic ;

    pStatic    = (PSTATICFIELDS)pnRawData ;   // transform pubRaw from PSTATIC
    pRawData   = (PRAWBINARYDATA)pStatic->pubBUDData ; //  to BUDDATA

    pubRaw     = (PBYTE)pRawData ;
//    pmrbd    = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    /*   also works ...
    dwNumFeatures =
        pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures ;
    */

    pGPDdriverInfo = (PGPDDRIVERINFO)((PBYTE)(pInfoHdr) +
                        pInfoHdr->loDriverOffset) ;
    if(!BinitGlobals(&pGPDdriverInfo->Globals, (PBYTE)pnRawData, poptsel, TRUE) )
    {
        return(NULL) ;
    }

    pUIinfo = (PUIINFO)((PBYTE)(pInfoHdr) +
                    pInfoHdr->loUIInfoOffset)  ;

     if(!BinitUIinfo(pUIinfo, (PBYTE)pnRawData, poptsel, TRUE) )
     {
         return(NULL) ;
     }


    loFeatures  = pUIinfo->loFeatureList ;  // from  pInfoHdr

    pFeaturesDest =  (PFEATURE)((PBYTE)(pInfoHdr) + loFeatures) ;
    //  always points to first Feature structure in array

    for( dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        dwSizeOption = (pFeaturesDest + dwFea)->dwOptionSize ;
        dwNumOptions = pFeaturesDest[dwFea].Options.dwCount  ;
        pubOptionsDest =  (PBYTE)(pInfoHdr) + pFeaturesDest[dwFea].Options.loOffset ;


        if(!BinitFeatures(pFeaturesDest + dwFea, pfo + dwFea,
                            (PBYTE)pnRawData, poptsel, TRUE))
        {
            return(NULL) ;
        }

        for(dwI = 0 ; dwI < dwNumOptions ; dwI++)
        {
            if(((POPTION)pubOptionsDest)->loRenderOffset)
            {
                pubDestOptionEx =  (PBYTE)(pInfoHdr) +
                                    ((POPTION)pubOptionsDest)->loRenderOffset ;
            }
            else
                pubDestOptionEx = NULL ;

            if(!BinitOptionFields(pubOptionsDest, pubDestOptionEx,
                        (PBYTE)pnRawData, dwFea, dwI, poptsel, pInfoHdr, TRUE) )
            {
                MemFree(pInfoHdr) ;
                return(NULL) ;
            }
            pubOptionsDest += dwSizeOption ;
        }
    }

    return(pInfoHdr);
}
#endif


BOOL
ReconstructOptionArray(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions
    )

/*++

Routine Description:

    Modify an option array to change the selected options for the specified feature

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures to be modified
    iMaxOptions - Max number of entries in pOptions array
    dwFeatureIndex - Specifies the index of printer feature in question
    pbSelectedOptions - Which options of the specified feature is selected

Return Value:

    FALSE if the input option array is not large enough to hold
    all modified option values. TRUE otherwise.

Note:

    Number of BOOLs in pSelectedOptions must match the number of options
    for the specified feature.

    This function always leaves the option array in a compact format (i.e.
    all unused entries are left at the end of the array).

--*/

{
    BOOL    bStatus = TRUE ;
    DWORD   dwDestTail, dwSrcTail, dwNumFea , dwI ;
    //  POPTSELECT   pNewOptions ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    PBYTE   pubRaw ;  //  raw binary data.
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    OPTSELECT  pNewOptions[MAX_COMBINED_OPTIONS] ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;

    if(!pOptions)
    {
        ERR(("ReconstructOptionArray: caller passed in invalid pOptions.\n"));
        return(FALSE);  // Missing array.
    }

    #if 0
    pNewOptions = (POPTSELECT)MemAlloc(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS) ;

    if( !pNewOptions )
    {
        ERR(("Fatal: ReconstructOptionArray - unable to alloc %d bytes.\n",
            sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS));
        return(FALSE);  // Missing array.
    }
    #endif


    dwDestTail = dwNumFea = pRawData->dwDocumentFeatures +
                        pRawData->dwPrinterFeatures ;



    for(dwI = 0 ; dwI < dwNumFea ; dwI++)
    {
        if(dwI == dwFeatureIndex)
        {
            DWORD  dwNumOptions, dwOpt ;

            dwNumOptions = pfo[dwI].dwNumOptions ;

            // determine first selected option, must have
            // at least one.

            for(dwOpt = 0 ; dwOpt < dwNumOptions  &&
                            !pbSelectedOptions[dwOpt]  ; dwOpt++)
            {
                ;  // null body
            }
            if(dwOpt >= dwNumOptions)
            {
                ERR(("ReconstructOptionArray: caller passed in invalid option selection.\n"));
                bStatus = FALSE ;
                break ;
            }
            pNewOptions[dwI].ubCurOptIndex = (BYTE)dwOpt ;
            for(++dwOpt  ; dwOpt < dwNumOptions  &&
                            !pbSelectedOptions[dwOpt]  ; dwOpt++)
            {
                ;  // null body
            }
            if(dwOpt == dwNumOptions)    //  no other options selected.
                pNewOptions[dwI].ubNext = 0 ;
            else
            {
                //  pbSelectedOptions holds another selection.
                pNewOptions[dwI].ubNext = (BYTE)dwDestTail ;

                while(dwOpt < dwNumOptions)
                {
                    pNewOptions[dwDestTail].ubCurOptIndex = (BYTE)dwOpt ;
                    pNewOptions[dwDestTail].ubNext = (BYTE)dwDestTail + 1 ;
                    dwDestTail++ ;
                    if(dwDestTail > MAX_COMBINED_OPTIONS)
                    {
                        ERR(("ReconstructOptionArray: exceeded limit of MAX_COMBINED_OPTIONS.\n"));
                        //  MemFree(pNewOptions) ;
                        return(FALSE);
                    }
                    for(++dwOpt  ; dwOpt < dwNumOptions  &&
                                    !pbSelectedOptions[dwOpt]  ; dwOpt++)
                    {
                        ;  // null body
                    }
                }
                pNewOptions[dwDestTail - 1].ubNext = 0 ;
            }

            continue ;
        }
        pNewOptions[dwI].ubCurOptIndex = pOptions[dwI].ubCurOptIndex;
        if(!(dwSrcTail = pOptions[dwI].ubNext))  //  end of list
            pNewOptions[dwI].ubNext = 0 ;
        else
        {
            //  dwSrcTail holds another selection.
            pNewOptions[dwI].ubNext = (BYTE)dwDestTail ;

            while(dwSrcTail)
            {
                pNewOptions[dwDestTail].ubCurOptIndex =
                        pOptions[dwSrcTail].ubCurOptIndex;
                pNewOptions[dwDestTail].ubNext = (BYTE)dwDestTail + 1 ;
                dwDestTail++ ;
                if(dwDestTail > MAX_COMBINED_OPTIONS)
                {
                    ERR(("ReconstructOptionArray: exceeded limit of MAX_COMBINED_OPTIONS.\n"));
                    //  MemFree(pNewOptions) ;
                    return(FALSE);
                }
                dwSrcTail = pOptions[dwSrcTail].ubNext ;
            }
            pNewOptions[dwDestTail - 1].ubNext = 0 ;
        }
    }

    if (dwDestTail > (DWORD)iMaxOptions)
    {
        ERR(("ReconstructOptionArray: exceeded size of array OPTSELECT.\n"));
        bStatus = FALSE;
    }
    if(bStatus)
    {
        for(dwI = 0 ; dwI < dwDestTail ; dwI++)
          pOptions[dwI] = pNewOptions[dwI] ;
    }
    //  MemFree(pNewOptions) ;
    return(bStatus);
}




BOOL
ChangeOptionsViaID(
    IN PINFOHEADER  pInfoHdr ,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    )

/*++

Routine Description:

    Modifies an option array using the information in public devmode fields

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to the option array to be modified
    dwFeatureID - Specifies which field(s) of the input devmode should be used
    pDevmode - Specifies the input devmode

Return Value:
    TRUE if successful, FALSE if the specified feature ID is not supported
    or there is an error

Note:

    We assume the input devmode fields have been validated by the caller.
 this GID:           is determined by this devmode field:       optID

GID_RESOLUTION      dmPrintQuality, dmYResolution
GID_PAGESIZE        dmPaperSize, dmPaperLength, dmPaperWidth    CL_CONS_PAPERSIZE
GID_PAGEREGION      N/A
GID_DUPLEX          dmDuplex                                    CL_CONS_DUPLEX
GID_INPUTSLOT       dmDefaultSource                             CL_CONS_INPUTSLOT
GID_MEDIATYPE       dmMediaType                                 CL_CONS_MEDIATYPE
GID_MEMOPTION       N/A
GID_COLORMODE       N/A   (hack something if needed.)
GID_ORIENTATION     dmOrientation                               CL_CONS_ORIENTATION
GID_PAGEPROTECTION  N/A
GID_COLLATE         dmCollate                                   CL_CONS_COLLATE
                        {DMCOLLATE_TRUE, DMCOLLATE_FALSE}
GID_OUTPUTBIN       N/A
GID_HALFTONING      N/A

see DEVMODE  in sdk\inc\wingdi.h

--*/

{

    BOOL    bStatus = FALSE ;
    DWORD   dwFeaIndex = 0, dwOptIndex, dwOptID ;


    switch(dwFeatureID)
    {
        case    GID_RESOLUTION:
        {
            DWORD   dwXres, dwYres ;
            //  we assume caller has initialized both dmPrintQuality and
            //  dmYResolution.

            dwXres = pDevmode->dmPrintQuality ;
            dwYres = pDevmode->dmYResolution ;

            bStatus = BMapResToOptIndex(pInfoHdr, &dwOptIndex, dwXres, dwYres) ;
            if(bStatus &&
                (bStatus = BGIDtoFeaIndex(pInfoHdr,
                &dwFeaIndex, dwFeatureID))  )
            {
                //  don't need to worry about truncating
                //  a list of options, these features
                //  are all PICKONE.
                pOptions[dwFeaIndex].ubCurOptIndex = (BYTE)dwOptIndex ;
                pOptions[dwFeaIndex].ubNext = 0 ;
            }
            return (bStatus);
        }
        case    GID_PAGESIZE:
        {
            if( pDevmode->dmFields & DM_PAPERLENGTH  &&
                   pDevmode->dmFields & DM_PAPERWIDTH  &&
                   pDevmode->dmPaperWidth  &&
                   pDevmode->dmPaperLength)
            {
                // must convert devmode's tenths of mm to microns
                // before calling.

                bStatus = BMapPaperDimToOptIndex(pInfoHdr, &dwOptIndex,
                        pDevmode->dmPaperWidth * 100L,
                        pDevmode->dmPaperLength * 100L, NULL) ;
            }
            else if(pDevmode->dmFields & DM_PAPERSIZE)
            {
                dwOptID = pDevmode->dmPaperSize ;
                bStatus = BMapOptIDtoOptIndex(pInfoHdr, &dwOptIndex,
                        dwFeatureID, dwOptID) ;
            }
            else
                bStatus = FALSE ;

            if(bStatus &&
                (bStatus = BGIDtoFeaIndex(pInfoHdr,
                &dwFeaIndex, dwFeatureID))  )
            {
                pOptions[dwFeaIndex].ubCurOptIndex = (BYTE)dwOptIndex ;
                pOptions[dwFeaIndex].ubNext = 0 ;
                return (bStatus);  // must exit now.
            }
            break ;
        }
        case    GID_DUPLEX:
        {
            if(pDevmode->dmFields & DM_DUPLEX)
            {
                dwOptID = pDevmode->dmDuplex ;
                bStatus = TRUE ;
            }
            break ;
        }
        case    GID_INPUTSLOT:
        {
            if(pDevmode->dmFields & DM_DEFAULTSOURCE)
            {
                dwOptID = pDevmode->dmDefaultSource ;
                bStatus = TRUE ;
            }
            break ;
        }
        case    GID_MEDIATYPE:
        {
            if(pDevmode->dmFields & DM_MEDIATYPE)
            {
                dwOptID = pDevmode->dmMediaType ;
                bStatus = TRUE ;
            }
            break ;
        }
        case    GID_COLORMODE:
        {
            if(pDevmode->dmFields & DM_COLOR)
            {
                //  special processing since devmode
                //  only specifies BW or color printing.

                bStatus = BGIDtoFeaIndex(pInfoHdr,
                                &dwFeaIndex, dwFeatureID) ;

                if(!bStatus)  //  dwFeaIndex could be invalid at this point.
                    return (bStatus);

                //  what is the current color setting?
                dwOptIndex = pOptions[dwFeaIndex].ubCurOptIndex ;

                if(bStatus &&
                    (bStatus = BMapDmColorToOptIndex(pInfoHdr, &dwOptIndex,
                    pDevmode->dmColor))  )
                {
                    pOptions[dwFeaIndex].ubCurOptIndex = (BYTE)dwOptIndex ;
                    pOptions[dwFeaIndex].ubNext = 0 ;
                }
            }
            return (bStatus);
        }
        case    GID_ORIENTATION:
        {
            if(pDevmode->dmFields & DM_ORIENTATION)
            {
                dwOptID = pDevmode->dmOrientation ;


                if(dwOptID == DMORIENT_PORTRAIT)
                    dwOptID = ROTATE_NONE ;
                else
                {
                    dwOptID = ROTATE_90 ;
                    bStatus = BMapOptIDtoOptIndex(pInfoHdr, &dwOptIndex,
                        dwFeatureID, dwOptID) ;
                    if(!bStatus)
                    {
                        dwOptID = ROTATE_270 ;
                    }
                }

                bStatus = TRUE ;
            }
            break ;
        }
        case    GID_COLLATE:
        {
            if(pDevmode->dmFields & DM_COLLATE)
            {
                dwOptID = pDevmode->dmCollate ;
                bStatus = TRUE ;
            }
            break ;
        }
        default:
        {
            break ;
        }
    }
    //  Complete processing for typical case.

    if(bStatus)
    {
        bStatus = BMapOptIDtoOptIndex(pInfoHdr, &dwOptIndex,
                        dwFeatureID, dwOptID) ;
    }
    if(bStatus &&
        (bStatus =  BGIDtoFeaIndex(pInfoHdr,
                &dwFeaIndex, dwFeatureID)  ))
    {
        //  don't need to worry about truncating
        //  a list of options, these features
        //  are all PICKONE.
        pOptions[dwFeaIndex].ubCurOptIndex = (BYTE)dwOptIndex ;
        pOptions[dwFeaIndex].ubNext = 0 ;
    }
    return (bStatus);
}

BOOL    BMapDmColorToOptIndex(
PINFOHEADER  pInfoHdr ,
IN  OUT     PDWORD       pdwOptIndex ,  //  is current setting ok?
                        //  if not return new index to caller
DWORD        dwDmColor  // what is requested in Devmode
)
{
    PUIINFO     pUIInfo ;
    PFEATURE    pFeature ;
    DWORD       dwNumOpts, loOptOffset, dwI ;
    PCOLORMODE pColorModeOption ;
    BOOL    bColor  ;
    DWORD       loOptExOffset ;
    PCOLORMODEEX pColorModeOptionEx ;


    bColor = (dwDmColor == DMCOLOR_COLOR) ;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_COLORMODE) ;
    if(!pFeature)
        return(FALSE) ;  //  no such feature defined in GPD
    dwNumOpts = pFeature->Options.dwCount ;
    loOptOffset = pFeature->Options.loOffset ;

    if(*pdwOptIndex >= dwNumOpts)  //  option index out of range - fix for 185245
    {
        *pdwOptIndex = pFeature->dwDefaultOptIndex ;  //  use the default option
        return(FALSE) ;
    }

    pColorModeOption = OFFSET_TO_POINTER(pInfoHdr, loOptOffset) ;

    loOptExOffset = pColorModeOption[*pdwOptIndex].GenericOption.loRenderOffset ;
    pColorModeOptionEx = OFFSET_TO_POINTER(pInfoHdr, loOptExOffset) ;

    if(bColor == pColorModeOptionEx->bColor)
        return(TRUE) ;  // currently selected colormode
                        // matches devmode request.

    loOptExOffset = pColorModeOption[pFeature->dwDefaultOptIndex].
                                            GenericOption.loRenderOffset ;
    pColorModeOptionEx = OFFSET_TO_POINTER(pInfoHdr, loOptExOffset) ;

    if(bColor == pColorModeOptionEx->bColor)
    {
        *pdwOptIndex = pFeature->dwDefaultOptIndex ;
        return(TRUE) ;  // the default colormode option
    }                    // matches devmode request.


    //  last ditch effort - just find the first matching one.
    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        loOptExOffset = pColorModeOption[dwI].GenericOption.loRenderOffset ;
        pColorModeOptionEx = OFFSET_TO_POINTER(pInfoHdr, loOptExOffset) ;

        if(bColor == pColorModeOptionEx->bColor)
        {
            *pdwOptIndex = dwI ;
            return(TRUE) ;
        }
    }
    return(FALSE) ;  //  no matching colormode found.
}

BOOL    BMapOptIDtoOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwFeatureGID,
DWORD        dwOptID
)
{
    PUIINFO     pUIInfo ;
    PFEATURE    pFeature ;
    DWORD       dwNumOpts, loOptOffset, dwI, dwIDOffset, dwOptSize, dwCurID ;
    POPTION pOption ;

    switch(dwFeatureGID)
    {
        case GID_HALFTONING:
            dwIDOffset = offsetof(HALFTONING, dwHTID ) ;
            break ;
        case GID_DUPLEX:
            dwIDOffset = offsetof(DUPLEX, dwDuplexID ) ;
            break ;
        case GID_ORIENTATION:
            dwIDOffset = offsetof(ORIENTATION, dwRotationAngle ) ;
            break ;
        case GID_PAGESIZE:
            dwIDOffset = offsetof(PAGESIZE, dwPaperSizeID ) ;
            break ;
        case GID_INPUTSLOT:
            dwIDOffset = offsetof(INPUTSLOT, dwPaperSourceID ) ;
            break ;
        case GID_MEDIATYPE:
            dwIDOffset = offsetof(MEDIATYPE, dwMediaTypeID ) ;
            break ;
        case    GID_COLLATE:
            dwIDOffset = offsetof(COLLATE, dwCollateID ) ;
            break ;
        default:
            return(FALSE);  // this feature has no ID value!
    }

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureGID) ;
    if(!pFeature)
        return(FALSE) ;  //  no such feature defined in GPD
    dwNumOpts = pFeature->Options.dwCount ;
    loOptOffset = pFeature->Options.loOffset ;
    dwOptSize =  pFeature->dwOptionSize ;

    pOption = OFFSET_TO_POINTER(pInfoHdr, loOptOffset) ;

    //  just find the first matching one.
    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        dwCurID = *(PDWORD)((PBYTE)pOption + dwI * dwOptSize + dwIDOffset) ;
        if(dwOptID  == dwCurID)
        {
            *pdwOptIndex = dwI ;
            return(TRUE) ;
        }
    }
    return(FALSE) ;  //  no matching ID found.
}


BOOL    BMapPaperDimToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwWidth,   //  in Microns
DWORD        dwLength,   //  in Microns
OUT  PDWORD    pdwOptionIndexes
)
/*++

Routine Description:

    Map logical values to PaperSize option index

Arguments:

    pdwOptIndex - if pdwOptionIndexs == NULL, this
        holds the option index of the first paper matching the
        requested dimensions.   Otherwise this holds the number
        of papers matching the requested dimensions.
    dwWidth , dwLength  - requested Paper Size in Microns
    pdwOptionIndexes - if Not NULL,  this array will be initialized
        with all option  indicies of papers which match the requested size.
        In this case the return value
        is the number of elements in the array initialized.   Currently
        we assume the array is large enough (256 elements).


Return Value:

TRUE:  found one or more papers of the size requested.

--*/

{
    PUIINFO     pUIInfo ;
    PGPDDRIVERINFO  pDrvInfo ;
    PFEATURE    pFeature ;
    DWORD       dwNumOpts, loOptOffset, dwI ,
                dwError, dwErrorY, dwCustomIndex,
                dwOptWidth , dwOptLength,
                dwMinWidth , dwMinLength,
                dwMaxWidth , dwMaxLength,
                dwOutArrayIndex = 0;
    PPAGESIZE pPaperOption ;
    BOOL    bFits = FALSE ;  // does custom size fit request?

    //  Convert from Microns to Master units.


    dwWidth /= 100 ;  // microns to tenths of mm
    dwLength /= 100 ;

    pDrvInfo = (PGPDDRIVERINFO) GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHdr) ;

    dwWidth *= pDrvInfo->Globals.ptMasterUnits.x ;
    dwLength *= pDrvInfo->Globals.ptMasterUnits.y ;

    dwWidth /= 254 ;
    dwLength /= 254 ;

    dwError = pDrvInfo->Globals.ptMasterUnits.x / 100 ;
    dwErrorY = pDrvInfo->Globals.ptMasterUnits.y / 100 ;

    dwError = (dwError > dwErrorY) ? dwError : dwErrorY ;
    dwError = (dwError > 3) ? dwError : 3 ;

    //  give leeway of 3 master units or 1/100 inch whichever
    //  is greater.

    dwMinWidth = (dwWidth < dwError) ? 0 : (dwWidth - dwError) ;
    dwMinLength = (dwLength < dwError) ? 0 : (dwLength - dwError) ;

    dwMaxWidth = dwWidth + dwError ;
    dwMaxLength = dwLength + dwError ;


    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE) ;
    if(!pFeature)
        return(FALSE) ;  //  no such feature defined in GPD
    dwNumOpts = pFeature->Options.dwCount ;
    loOptOffset = pFeature->Options.loOffset ;

    pPaperOption = OFFSET_TO_POINTER(pInfoHdr, loOptOffset) ;



    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        if(pPaperOption[dwI].dwPaperSizeID != DMPAPER_USER)
        {
            dwOptWidth = pPaperOption[dwI].szPaperSize.cx  ;
            dwOptLength = pPaperOption[dwI].szPaperSize.cy ;
            if(dwOptWidth > dwMinWidth   &&  dwOptWidth < dwMaxWidth  &&
                dwOptLength > dwMinLength   &&  dwOptLength < dwMaxLength )
            {
                if(pdwOptionIndexes)
                    pdwOptionIndexes[dwOutArrayIndex++] = dwI ;
                else
                {
                    *pdwOptIndex = dwI ;
                    return(TRUE) ;
                }
            }
        }
        else // this is the custom size:
        {
            DWORD       loOptExOffset ;
            PPAGESIZEEX pPaperOptionEx ;

            loOptExOffset = pPaperOption[dwI].GenericOption.loRenderOffset ;
            pPaperOptionEx = OFFSET_TO_POINTER(pInfoHdr, loOptExOffset) ;

            //  does it fit the requested size?
            if(dwWidth <= (DWORD)pPaperOptionEx->ptMaxSize.x  &&
                dwWidth >= (DWORD)pPaperOptionEx->ptMinSize.x  &&
                dwLength <= (DWORD)pPaperOptionEx->ptMaxSize.y  &&
                dwLength >= (DWORD)pPaperOptionEx->ptMinSize.y  )
            {
                bFits = TRUE ;
                dwCustomIndex = dwI ;
            }
        }
    }

    if(pdwOptionIndexes)
    {
        if(bFits)
        {
            pdwOptionIndexes[dwOutArrayIndex++] = dwCustomIndex ;
        }
        *pdwOptIndex = dwOutArrayIndex ;
            //  cover the case where dwOutArrayIndex = 0.
        if(dwOutArrayIndex)
            return(TRUE) ;
        return(FALSE) ;
    }

    if(bFits)
    {
        *pdwOptIndex = dwCustomIndex ;
        return(TRUE) ;
    }
    return(FALSE) ;
}




BOOL    BMapResToOptIndex(
PINFOHEADER  pInfoHdr ,
OUT     PDWORD       pdwOptIndex ,  //  return index to caller
DWORD        dwXres,
DWORD        dwYres
)
{
    PUIINFO     pUIInfo ;
    PFEATURE    pFeature ;
    DWORD       dwNumOpts, loOptOffset, dwI ;
    DWORD  dwHighRes, dwLowRes, dwMedRes, dwDefRes,  dwCurRes,
                   //  in pixels per square inch.
       dwHighIndex, dwLowIndex, dwMedIndex, dwDefIndex ;
    PRESOLUTION pResOption ;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_RESOLUTION) ;
    if(!pFeature)
        return(FALSE) ;  //  no such feature defined in GPD
    dwNumOpts = pFeature->Options.dwCount ;
    loOptOffset = pFeature->Options.loOffset ;

    pResOption = OFFSET_TO_POINTER(pInfoHdr, loOptOffset) ;


    if((signed)dwXres > 0)
    {

        dwDefIndex = pFeature->dwDefaultOptIndex ;
        if(dwXres == (DWORD)pResOption[dwDefIndex].iXdpi  &&
                           dwYres ==  (DWORD)pResOption[dwDefIndex].iYdpi)
        {
            *pdwOptIndex = dwDefIndex ;
            return(TRUE) ;
        }

        for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
        {
            if(dwXres == (DWORD)pResOption[dwI].iXdpi  &&
                   dwYres == (DWORD)pResOption[dwI].iYdpi)
            {
                *pdwOptIndex = dwI ;
                return(TRUE) ;
            }
        }
    }
    else if ((signed)dwXres  > RES_ID_IGNORE)  //  OEM defined ID
    {
        for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
        {
            if(dwXres == (DWORD)pResOption[dwI].dwResolutionID)
            {
                *pdwOptIndex = dwI ;
                return(TRUE) ;
            }
        }
    }

     //  if exact match fails, or predefined negative value or nonsense
     //     resort to fuzzy match.

     //  first determine the highest, lowest, 2nd highest and default resolutions.

    dwHighIndex = dwLowIndex = dwMedIndex = dwDefIndex =
            pFeature->dwDefaultOptIndex ;

    dwHighRes = dwLowRes = dwMedRes = dwDefRes =
                            (DWORD)pResOption[dwDefIndex].iXdpi  *
                            (DWORD)pResOption[dwDefIndex].iYdpi ;

     //  note overflow possible if resolution exceeds 64k dpi.

     for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
     {
         dwCurRes =  (DWORD)pResOption[dwI].iXdpi  *
                            (DWORD)pResOption[dwI].iYdpi ;

         if(dwCurRes > dwHighRes)
         {
             dwHighIndex = dwI ;
             dwHighRes = dwCurRes ;
         }
         else        if(dwCurRes < dwLowRes)
         {
             dwLowIndex = dwI ;
             dwLowRes = dwCurRes ;
         }
         else  if(dwCurRes < dwHighRes  &&  dwCurRes > dwLowRes  &&
             (dwMedRes == dwHighRes  ||  dwMedRes == dwLowRes  ||  dwCurRes > dwMedRes))
         {
             dwMedIndex = dwI ;         //  if more than one middle res possible
             dwMedRes = dwCurRes ;      //  choose the largest.
         }

     }

     //  if (default res is not the highest or lowest, make default res the middle resolution
      if(dwDefRes < dwHighRes  &&  dwDefRes > dwLowRes)
     {
          dwMedIndex = dwDefIndex ;
          dwMedRes = dwDefRes ;           //  unnecessary code, but just in case
                                                            //  like the last break in a switch statement.
     }

     switch(dwXres)
     {
         case(DMRES_DRAFT):
         case(DMRES_LOW):
             *pdwOptIndex = dwLowIndex ;
             break;
         case(DMRES_MEDIUM):
             *pdwOptIndex = dwMedIndex ;
             break;
         case(DMRES_HIGH):
             *pdwOptIndex = dwHighIndex ;
             break;
         default:
             *pdwOptIndex = dwDefIndex ;
             break;
     }
     return(TRUE) ;
}


BOOL    BGIDtoFeaIndex(
PINFOHEADER  pInfoHdr ,
PDWORD       pdwFeaIndex ,
DWORD        dwFeatureGID )
{
    PUIINFO     pUIInfo ;
    PFEATURE    pFeature ;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureGID) ;
    if(!pFeature)
        return(FALSE) ;  //  no such feature defined in GPD

    *pdwFeaIndex  = (DWORD)GET_INDEX_FROM_FEATURE(pUIInfo, pFeature) ;
    return(TRUE) ;
}


DWORD
MapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes       // used only for GID_PAGESIZE
    )
{
    return (          UniMapToDeviceOptIndex(
                pInfoHdr , dwFeatureID,  lParam1,  lParam2,
                pdwOptionIndexes,       // used only for GID_PAGESIZE
                NULL) ) ;
}



DWORD
UniMapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes,       // used only for GID_PAGESIZE
    IN    PDWORD       pdwPaperID   //  optional paperID
    )
/*++

Routine Description:

    Map logical values to device feature option index

Arguments:

    pRawData - Points to raw binary printer description data
    dwFeatureID - Indicate which feature the logical values are related to
    lParam1, lParam2  - Parameters depending on dwFeatureID
    pdwOptionIndexes - if Not NULL, means fill this array with all indicies
        which match the search criteria.   In this case the return value
        is the number of elements in the array initialized.   Currently
        we assume the array is large enough (256 elements).

    dwFeatureID = GID_PAGESIZE:
        map logical paper specification to physical page size option

        lParam1 = paper width in microns
        lParam2 = paper height in microns

        IF lParam1 or 2 is set to zero, this function assumes
        pdwPaperID points to the OptionID of a paper.
        It will return the first paper found matching this ID.

    dwFeatureID = GID_RESOLUTION:
        map logical resolution to physical resolution option

        lParam1 = x-resolution in dpi
        lParam2 = y-resolution in dpi

Return Value:

    Index of the feature option corresponding to the specified logical values;
    OPTION_INDEX_ANY if the specified logical values cannot be mapped to
    any feature option.

    if pdwOptionIndexes  Not NULL, the return value is the number of elements
    written to.  Zero means  the specified logical values cannot be mapped to
    any feature option.


--*/

{

    DWORD   dwOptIndex;


    switch (dwFeatureID)
    {
        case    GID_PAGESIZE:
        {
            if(pdwOptionIndexes)
                return(   MapPaperAttribToOptIndex(
                    pInfoHdr ,
                    pdwPaperID ,  //  optional paperID
                    (DWORD)lParam1, (DWORD)lParam2,  //  in Microns
                    pdwOptionIndexes) ) ;

            if(BMapPaperDimToOptIndex(pInfoHdr, &dwOptIndex,
                (DWORD)lParam1, (DWORD)lParam2, NULL) )
                return(dwOptIndex) ;
            break ;
        }
        case    GID_RESOLUTION:
        {
            if( BMapResToOptIndex(pInfoHdr, &dwOptIndex,
                (DWORD)lParam1, (DWORD)lParam2) )
                return(dwOptIndex) ;
            break ;
        }
        default:
            break ;
    }
    return(OPTION_INDEX_ANY) ;
}

DWORD   MapPaperAttribToOptIndex(
PINFOHEADER  pInfoHdr ,
IN     PDWORD       pdwPaperID ,  //  optional paperID
DWORD        dwWidth,   //  in Microns (set to zero to ignore)
DWORD        dwLength,   //  in Microns
OUT  PDWORD    pdwOptionIndexes  //  cannot be NULL
)
{
    DWORD  dwNumFound;
    BOOL    bStatus ;

    if(dwWidth  &&  dwLength)
    {
        if( BMapPaperDimToOptIndex(pInfoHdr, &dwNumFound,
                dwWidth , dwLength, pdwOptionIndexes) )
              return(dwNumFound);
        return(0);
    }

    if(pdwPaperID)  // use paperID instead of dimensions
    {
        bStatus = BMapOptIDtoOptIndex(pInfoHdr, pdwOptionIndexes,
                GID_PAGESIZE, *pdwPaperID) ;
        return(bStatus ? 1 : 0) ;
    }
    return(0);  // if given nothing, return nothing
}


BOOL
CheckFeatureOptionConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwFeature1,
    IN DWORD            dwOption1,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2
    )
{
#ifndef KERNEL_MODE

    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubHeap ,  // start of string heap.
            pubRaw ;  //  raw binary data.
    DWORD           dwNodeIndex ,
                    dwCNode ;  //  index to a Constraint node
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
//    PINVALIDCOMBO   pinvc ;    //  root of invalid combo nodes
    PCONSTRAINTS    pcnstr ;   //  root of Constraint nodes
    BOOL    bReflected = FALSE ;
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    patt = (PATTRIB_TREE)(pubRaw +
            pearTableContents[MTI_ATTRIBTREE].loOffset) ;
//    pinvc = (PINVALIDCOMBO) (pubRaw +
//            pearTableContents[MTI_INVALIDCOMBO].loOffset) ;
    pcnstr = (PCONSTRAINTS) (pubRaw +
            pearTableContents[MTI_CONSTRAINTS].loOffset) ;
    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;

TRYAGAIN:

    patrRoot = &(pfo[dwFeature1].atrConstraints) ;

    dwNodeIndex = DwFindNodeInCurLevel(patt , patrRoot , dwOption1) ;

    if(dwNodeIndex == INVALID_INDEX)
        goto  REFLECTCONSTRAINT ;

    if(patt[dwNodeIndex].eOffsetMeans != VALUE_AT_HEAP)
    {
        ERR(("Internal error.  CheckFeatureOptionConflict - Unexpected Sublevel found for atrConstraints.\n"));
        goto  REFLECTCONSTRAINT ;
    }

    dwCNode = *(PDWORD)(pubHeap + patt[dwNodeIndex].dwOffset) ;

    while(1)
    {
        if(pcnstr[dwCNode].dwFeature == dwFeature2  &&
            pcnstr[dwCNode].dwOption == dwOption2)
            return(TRUE) ;  // a constraint does exist.

        dwCNode = pcnstr[dwCNode].dwNextCnstrnt ;
        if(dwCNode == END_OF_LIST)
            break ;
    }

REFLECTCONSTRAINT :

    if(!bReflected)
    {
        DWORD   dwSwap ;

        dwSwap = dwFeature2 ;
        dwFeature2 = dwFeature1 ;
        dwFeature1 = dwSwap ;

        dwSwap = dwOption2 ;
        dwOption2 = dwOption1 ;
        dwOption1 = dwSwap ;

        bReflected = TRUE ;
        goto    TRYAGAIN;
    }

//  else  continue on to FINDINVALIDCOMBOS

//  oops this function doesn't care about
//  InvalidCombos!  It only knows about
//  2 qualified objects.



#else
    RIP(("CheckFeatureOptionConflict not implemented in Kernel Mode")) ;
#endif
    return(FALSE);  //  no constraint found.
}




VOID
ValidateDocOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions
    )

/*++

Routine Description:

    Validate the devmode option array and correct any invalid option selections

Arguments:

    pnRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures that need validation
    iMaxOptions - Max number of entries in pOptions array

Return Value:

    None

--*/

{
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubRaw ;  //  raw binary data.
    INT     NumDocFea = 0;
    INT   iIndex = 0;
    DWORD  nFeatures = 0 ;  //  total number of Doc and Printer Features
    DWORD  FeaIndex = 0 ;
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    POPTSELECT      pCombinedOptions = NULL;  //  holds result of merging pOptions with a NULL array
    POPTSELECT      pDefaultOptions = NULL;      //  holds a default option array.  Source of default values.
    BOOL  bStatus = TRUE ;
    DWORD  MaxIndex = (iMaxOptions < MAX_COMBINED_OPTIONS) ? iMaxOptions : MAX_COMBINED_OPTIONS ;


    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA
    NumDocFea = pRawData->dwDocumentFeatures ;

    if(!pOptions)
    {
        RIP(("ValidateDocOptions: NULL  Option array not permitted.\n"));
        return ;
    }

    if(iMaxOptions < NumDocFea)
    {
        RIP(("ValidateDocOptions: Option array too small: %d < %d\n", iMaxOptions, NumDocFea));
        goto Abort;
    }
    pubRaw = (PBYTE)pRawData ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;  //  location of Feature 0.

    //  allocate memory to hold combined option array
    //  allocate another one to hold initialized default option array

    pCombinedOptions = (POPTSELECT)MemAlloc(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS) ;
    pDefaultOptions = (POPTSELECT)MemAlloc(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS) ;

    if( !pCombinedOptions  || !pDefaultOptions )
        goto Abort;

    //  verify any pick many slots don't create overlapping or endless loops.
    //  use pCombinedOptions to track them.
    for(iIndex =  NumDocFea  ; iIndex < MAX_COMBINED_OPTIONS ; iIndex++)
    {
        pCombinedOptions[iIndex].ubCurOptIndex = 0 ; // these are available to hold pickmany selections
    }
    for(iIndex = 0 ; iIndex < NumDocFea ; iIndex++)
    {
        DWORD  NextArrayEle = pOptions[iIndex].ubNext ;

        for (   ; (NextArrayEle != NULL_OPTSELECT)  ; NextArrayEle = pOptions[NextArrayEle].ubNext)
        {
            if((NextArrayEle >= MaxIndex) || ((INT)NextArrayEle <  NumDocFea) ||
                        (pCombinedOptions[NextArrayEle].ubCurOptIndex) )
            {  //  NextArrayEle out of bounds or overwrites a previous slot.
                pOptions[iIndex].ubNext = NULL_OPTSELECT;
                break;  //  just terminate this pickmany list.
            }
            pCombinedOptions[NextArrayEle].ubCurOptIndex = 1 ; // reserve this slot.
        }
    }


    bStatus = InitDefaultOptions( pnRawData, pDefaultOptions, MAX_COMBINED_OPTIONS,
                                                    MODE_DOCANDPRINTER_STICKY) ;

    if(!bStatus)
        goto Abort;

    //  must merge input pOptions to create a combined option array.

    bStatus = CombineOptionArray( pnRawData,  pCombinedOptions,  iMaxOptions,
                pOptions,  NULL) ;

    if(!bStatus)
        goto Abort;


    nFeatures = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures ;

    if(nFeatures > MAX_COMBINED_OPTIONS)
        goto Abort;

    for(FeaIndex = 0 ; FeaIndex < nFeatures ; FeaIndex++)
    {
        DWORD  nOptions = 0 ;  //  number of options available for this Feature
        DWORD  NextArrayEle = 0 ;  //  index into option array esp for PickMany
        DWORD  cSelectedOptions = 0;  //  how many options have been selected for this feature?

        nOptions = pfo[FeaIndex].dwNumOptions ;
        NextArrayEle = FeaIndex;
        bStatus = TRUE;

        do
        {
            cSelectedOptions++;

            if ((NextArrayEle >= MAX_COMBINED_OPTIONS) ||       //  index out of range
                (pCombinedOptions[NextArrayEle].ubCurOptIndex >= nOptions) ||  //  selected option out of range
                (cSelectedOptions > nOptions))  //  too many options selected (for pick many)
            {
                //
                // either the option index is out of range,
                // or the current option selection is invalid,
                // or the number of selected options (for PICKMANY)
                // exceeds available options
                //

                bStatus = FALSE;
                break;
            }

            NextArrayEle = pCombinedOptions[NextArrayEle].ubNext;

        } while (NextArrayEle != NULL_OPTSELECT);
        if (!bStatus)
        {
            pCombinedOptions[FeaIndex].ubCurOptIndex =
                    pDefaultOptions[FeaIndex].ubCurOptIndex;

            pCombinedOptions[FeaIndex].ubNext = NULL_OPTSELECT;
        }
    }
    //  separate combined option array into doc sticky part and
    //  store that in pOptions.

    bStatus = SeparateOptionArray(pnRawData, pCombinedOptions,
              pOptions, iMaxOptions, MODE_DOCUMENT_STICKY ) ;

    if(!bStatus)
        goto Abort;


    if(pCombinedOptions)
        MemFree(pCombinedOptions) ;
    if(pDefaultOptions)
        MemFree(pDefaultOptions) ;
    return ;  //  Normal return path

Abort:                  // something has gone totally haywire.
    if(iMaxOptions > NumDocFea )
        iMaxOptions = NumDocFea ;

    for(iIndex = 0 ; iIndex < iMaxOptions ; iIndex++)
    {
        pOptions[iIndex].ubCurOptIndex = 0 ;
        pOptions[iIndex].ubNext = NULL_OPTSELECT;
    }
    if(pCombinedOptions)
        MemFree(pCombinedOptions) ;
    if(pDefaultOptions)
        MemFree(pDefaultOptions) ;
    return ;    // error return path.
}



BOOL
ResolveUIConflicts(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    )
{
    DWORD   dwNumFeatures, dwFea, dwStart, dwI, dwDestTail,
        dwDest, dwSrcTail, dwNumOpts, dwNEnabled, dwJ ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubRaw ;  //  raw binary data.
    PDWORD   pdwPriority ;
    BOOL   bStatus = FALSE, bUnresolvedConflict = FALSE ,
        bEnable = FALSE ;  //  feature will constrain others
    PBOOL   pbUseConstrnt, pbEnabledOptions, pbSelectedOptions ;
    INT     iOptionsNeeded;
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;


#ifdef  GMACROS
    if(!ResolveDependentSettings( pnRawData,  pOptions, iMaxOptions) )
        return(FALSE);
#endif


    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    pdwPriority = (PDWORD)(pubRaw +
            pearTableContents[MTI_PRIORITYARRAY].loOffset) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    if(dwNumFeatures > (DWORD)iMaxOptions)
    {
        iOptionsNeeded = dwNumFeatures ;
        return(FALSE);  // too many to save in option array.
    }

#if 0
    pbUseConstrnt = (PBOOL)MemAlloc(dwNumFeatures * sizeof(BOOL) ) ;
    pbEnabledOptions = (PBOOL)MemAlloc(256 * sizeof(BOOL) ) ;
    pbSelectedOptions = (PBOOL)MemAlloc(256 * sizeof(BOOL) ) ;
#endif

    pbSelectedOptions = (PBOOL)MemAlloc((256*2 + dwNumFeatures) * sizeof(BOOL) ) ;
    //  this is the union of the allowable selections
    //  and what was actually selected in pOptions for this feature.
    //  BUG_BUG:  assumes we won't have more than 256 options

    pbEnabledOptions = pbSelectedOptions + 256  ;
    //  these are the allowable selections
    pbUseConstrnt = pbEnabledOptions + 256    ;

    if(!(pbUseConstrnt && pbEnabledOptions && pbSelectedOptions ))
    {
        ERR(("Fatal: ResolveUIConflicts - unable to alloc requested memory: %d bytes.\n",
                    dwNumFeatures * sizeof(BOOL)));
        goto    ABORTRESOLVEUICONFLICTS ;
    }

    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
        pbUseConstrnt[dwI] = FALSE ;


    for(dwNEnabled = dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        //  The order of evaluation is determined
        //  by the priority array.

        dwFea = pdwPriority[dwI] ;

        bEnable = FALSE ;

        if(iMode == MODE_DOCANDPRINTER_STICKY)
            bEnable = TRUE ;
        else
        {
            DWORD   dwFeatureType = FT_PRINTERPROPERTY, dwNextOpt, dwUnresolvedFeature  ;
            PATREEREF    patrRoot ;    //  root of attribute tree to navigate.

            //  is this a printer or doc sticky feature?


            patrRoot = &(pfo[dwFea].atrFeatureType) ;

            dwNextOpt = 0 ;  // extract info for first option selected for
                                //  this feature.

            if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSFeatureTypeIndex,
                (PBYTE)&dwFeatureType,
                &dwUnresolvedFeature,  *patrRoot, pOptions,
                0, // set to  any value.  Doesn't matter.
                &dwNextOpt) != TRI_SUCCESS)
            {
                ERR(("ResolveUIConflicts: EextractValueFromTree failed.\n"));
                bUnresolvedConflict = TRUE ;
                goto    ABORTRESOLVEUICONFLICTS ;  // return(FALSE) ;
            }

            if(dwFeatureType != FT_PRINTERPROPERTY)
            {
                if(iMode == MODE_DOCUMENT_STICKY)
                    bEnable = TRUE ;
            }
            else
            {
                if(iMode == MODE_PRINTER_STICKY)
                    bEnable = TRUE ;
            }
        }

        if(bEnable)  //  Feature is to be applied as constraint
        {
            pbUseConstrnt[dwFea] = TRUE ;
            dwNEnabled++ ;
        }
        else
            continue ;  // not interested in this feature
        if(dwNEnabled < 2)
            continue ;  // not enough Features enabled
                    //  to constrain each other.

        bStatus = BSelectivelyEnumEnabledOptions(
            pnRawData,
            pOptions,
            dwFea,
            pbUseConstrnt,  // if non NULL
            pbEnabledOptions,
            0,
            NULL    //  pConflictPair
            ) ;


        dwNumOpts = pfo[dwFea].dwNumOptions ;

        for(dwJ = 0 ; dwJ < dwNumOpts ; dwJ++)
            pbSelectedOptions[dwJ] = FALSE ;

        if(!bStatus)
        {
            pbSelectedOptions[0] = TRUE ;
            // just set this to a harmless value.
        }
        else
        {
            DWORD   dwNext = dwFea ;
            while(1)
            {
                if(pbEnabledOptions[pOptions[dwNext].ubCurOptIndex])
                    pbSelectedOptions[pOptions[dwNext].ubCurOptIndex] = TRUE ;
                dwNext = pOptions[dwNext].ubNext ;
                if(!dwNext)
                    break ;  //  end of list of options.
            }
        }

        for(dwJ = 0 ; dwJ < dwNumOpts ; dwJ++)
        {
            if(pbSelectedOptions[dwJ])
                break ;  // is anything actually selected?
        }
        if(dwJ >= dwNumOpts)
        {
            DWORD  dwDefaultOption, dwNextOpt, dwUnresolvedFeature  ;
            PATREEREF    patrRoot ;    //  root of attribute tree to navigate.


            //  none of the original selections survived
            //  see if the default option can be used.
            //  first, determine the index of the default option.

            patrRoot = &(pfo[dwFea].atrDefaultOption) ;

            dwNextOpt = 0 ;  // extract info for first option selected for
                                //  this feature.

            if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSdefaultOptionIndex,
               (PBYTE)&dwDefaultOption,
               &dwUnresolvedFeature,  *patrRoot, pOptions,
               0, // set to  any value.  Doesn't matter.
               &dwNextOpt) == TRI_SUCCESS  &&
               pbEnabledOptions[dwDefaultOption])
            {
                pbSelectedOptions[dwDefaultOption] = TRUE ;
            }
            else  //  randomly pick something that isn't constrained.
            {
                if(!dwFea)   // hack for synthesized Inputslot.
                    pbEnabledOptions[0] = FALSE ;   // never allow autoselect to be selected
                    // if it wasn't initially selected.        bug 100722

                for(dwJ = 0 ; dwJ < dwNumOpts ; dwJ++)
                {
                    if(pbEnabledOptions[dwJ])
                        break ;
                }
                if(dwJ >= dwNumOpts)
                {
                    ERR(("ResolveUIConflicts: Constraints prevent any option from being selected!\n"));
                    pbSelectedOptions[0] = TRUE ;  // ignoring constraint.
                    bUnresolvedConflict = TRUE ;
                }
                else
                    pbSelectedOptions[dwJ] = TRUE ;  // Picked one.
            }
        }

        bStatus = ReconstructOptionArray(
            pnRawData,
            pOptions,
            iMaxOptions,
            dwFea,
            pbSelectedOptions) ;
        if(!bStatus)
        {
            ERR(("ResolveUIConflicts: ReconstructOptionArray failed.\n"));
            bUnresolvedConflict = TRUE ;
        }
    }  // end of processing for this feature

ABORTRESOLVEUICONFLICTS:
#if 0
    if(pbUseConstrnt)
        MemFree(pbUseConstrnt) ;
    if(pbEnabledOptions)
        MemFree(pbEnabledOptions) ;
#endif
    if(pbSelectedOptions)
        MemFree(pbSelectedOptions) ;

    return(!bUnresolvedConflict);
}

BOOL
EnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions ,
    IN INT              iMode
    //  either  MODE_DOCANDPRINTER_STICKY  or  MODE_PRINTER_STICKY
    )
{
#ifndef KERNEL_MODE

    if(iMode  ==   MODE_PRINTER_STICKY)
    {
        return(EnumOptionsUnconstrainedByPrinterSticky(
            pnRawData,
            pOptions,
            dwFeatureIndex,
            pbEnabledOptions
            )      ) ;
    }
    else
    {
        return(BSelectivelyEnumEnabledOptions(
            pnRawData,
            pOptions,
            dwFeatureIndex,
            NULL,    // pbHonorConstraints
            pbEnabledOptions,
            0,  //  dwOptSel
            NULL) ) ;
    }
    #else
    RIP(("GpdEnumEnabledOptions not implemented in Kernel Mode")) ;
    return(FALSE);
#endif
}




BOOL
EnumOptionsUnconstrainedByPrinterSticky(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT   pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions
    )
{
    DWORD   dwNumFeatures, dwFea, dwI, dwNumOpts, dwNEnabled, dwJ ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubRaw ;  //  raw binary data.
    BOOL   bStatus = FALSE ;
    PBOOL   pbUseConstrnt ;

    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA
    pubRaw = (PBYTE)pRawData ;
    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    pbUseConstrnt = (PBOOL)MemAlloc(dwNumFeatures * sizeof(BOOL) ) ;

    if(!pbUseConstrnt)
    {
        ERR(("Fatal: EnumOptionsUnconstrainedByPrinterSticky - unable to alloc requested memory: %d bytes.\n",
                    dwNumFeatures * sizeof(BOOL)));
        goto    ABORTENUMOPTIONSUNCONSTRAINEDBYPRINTERSTICKY ;
    }

    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
        pbUseConstrnt[dwI] = FALSE ;


    for(dwNEnabled = dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        DWORD   dwFeatureType = FT_PRINTERPROPERTY,
        dwNextOpt,  dwUnresolvedFeature ;
        PATREEREF    patrRoot ;    //  root of attribute tree to navigate.


        //  is this a printer or doc sticky feature?


        patrRoot = &(pfo[dwFea].atrFeatureType) ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSFeatureTypeIndex,
            (PBYTE)&dwFeatureType,
            &dwUnresolvedFeature,  *patrRoot, pOptions,
            0, // set to  any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            ERR(("ResolveUIConflicts: EextractValueFromTree failed.\n"));
            bStatus = FALSE ;
            goto    ABORTENUMOPTIONSUNCONSTRAINEDBYPRINTERSTICKY ;
        }


         if(dwFeatureType == FT_PRINTERPROPERTY)
        {
            pbUseConstrnt[dwFea] = TRUE ;
            dwNEnabled++ ;
        }
    }


    if(!pbUseConstrnt[dwFeatureIndex])  // queried feature isn't PrinterSticky
    {
        pbUseConstrnt[dwFeatureIndex] = TRUE ;
        dwNEnabled++ ;
    }

    if(dwNEnabled < 2)
    {
        dwNumOpts = pfo[dwFeatureIndex].dwNumOptions ;

        for(dwJ = 0 ; dwJ < dwNumOpts ; dwJ++)
            pbEnabledOptions[dwJ] = TRUE ;

        bStatus = TRUE  ;  // not enough Features enabled
                //  to constrain each other.
    }
    else
    {
        bStatus = BSelectivelyEnumEnabledOptions(
            pnRawData,
            pOptions,
            dwFeatureIndex,
            pbUseConstrnt,  // if non NULL
            pbEnabledOptions,
            0,
            NULL    //  pConflictPair
            ) ;
    }

ABORTENUMOPTIONSUNCONSTRAINEDBYPRINTERSTICKY:
    if(pbUseConstrnt)
        MemFree(pbUseConstrnt) ;

    return(bStatus);
}







BOOL
EnumNewUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions,
    OUT PCONFLICTPAIR   pConflictPair
    )
{
#ifndef KERNEL_MODE


    BSelectivelyEnumEnabledOptions(
        pnRawData,
        pOptions,
        dwFeatureIndex,
        NULL,
        pbSelectedOptions,
        0,  //  dwOptSel
        pConflictPair   ) ;


    return (pConflictPair->dwFeatureIndex1 != 0xFFFFFFFF);
#else
    RIP(("GpdEnumNewUIConflict not implemented in Kernel Mode")) ;
    return(FALSE);
#endif
}

BOOL
EnumNewPickOneUIConflict(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex,
    OUT PCONFLICTPAIR   pConflictPair
    )
{
#ifndef KERNEL_MODE

    BSelectivelyEnumEnabledOptions(
        pnRawData,
        pOptions,
        dwFeatureIndex,
        NULL,
        NULL,   //  pbSelectedOptions
        dwOptionIndex,
        pConflictPair   ) ;

    return (pConflictPair->dwFeatureIndex1 != 0xFFFFFFFF);
#else
    RIP(("GpdEnumNewPickOneUIConflict not implemented in Kernel Mode")) ;
    return(FALSE);
#endif
}





BOOL
BIsFeaOptionCurSelected(
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex
    )
/*
    returns TRUE  if the specified Feature/Option is
    currently selected in pOptions.  FALSE otherwise.
*/
{
    DWORD   dwSrcTail ;

    if(pOptions[dwFeatureIndex].ubCurOptIndex == dwOptionIndex)
        return(TRUE);

    dwSrcTail = pOptions[dwFeatureIndex].ubNext ;

    while(dwSrcTail)    //  PickMany options
    {
        if(pOptions[dwSrcTail].ubCurOptIndex == dwOptionIndex)
            return(TRUE);
        dwSrcTail = pOptions[dwSrcTail].ubNext ;
    }
    return(FALSE);
}




BOOL
BSelectivelyEnumEnabledOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL           pbHonorConstraints,  // if non NULL
        // points to array of BOOL corresponding to each feature.
        //  if TRUE means constraint involving this feature is
        //  to be honored.  Otherwise ignore the constraint.
    OUT PBOOL           pbEnabledOptions,  // assume uninitialized
        //  if pConflictPair is NULL else contains current or proposed
        //  selections.  We will leave this array unchanged in this case.
    IN  DWORD   dwOptSel,  //  if pConflictPair exists but  pbEnabledOptions
        //  is NULL, assume pickone and dwOptSel holds that selection for
        //  the feature: dwFeatureIndex.
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
        //  actually lists the current selections.  Function then
        //  exits after encountering the first conflict.
        //  if a conflict exists, all fields in pConflictPair
        //  will be properly initialized  else dwFeatureIndex1 = -1
        //  the return value will be TRUE regardless.
    )
/*
    return value is FALSE if every option for this
    feature is constrained or other abnormal condition
    was encountered.

*/
{
    PDFEATURE_OPTIONS  pfo ;
    PBYTE   pubHeap ,  // start of string heap.
            pubRaw ;  //  raw binary data.
    PENHARRAYREF   pearTableContents ;
    DWORD   dwI, dwNumFea , dwNumOpts, dwFea, dwSrcTail, dwNodeIndex,
        dwCFeature, dwCOption ,
        dwCNode, dwICNode, dwNextInvCombo;
    BOOL    bStatus, bConstrained, bNextLinkFound  ;
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    PCONSTRAINTS    pcnstr ;   //  root of Constraint nodes
    PINVALIDCOMBO   pinvc ;    //  root of invalid combo nodes
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    BOOL   pbNewEnabledOptions[MAX_COMBINED_OPTIONS] ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA



    pubRaw = (PBYTE)pRawData ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    patt = (PATTRIB_TREE)(pubRaw +
            pearTableContents[MTI_ATTRIBTREE].loOffset) ;
    pcnstr = (PCONSTRAINTS) (pubRaw +
            pearTableContents[MTI_CONSTRAINTS].loOffset) ;
    pinvc = (PINVALIDCOMBO) (pubRaw +
            pearTableContents[MTI_INVALIDCOMBO].loOffset) ;
    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;


    dwNumFea = pRawData->dwDocumentFeatures +
                        pRawData->dwPrinterFeatures ;

    dwNumOpts = pfo[dwFeatureIndex].dwNumOptions ;


    if(pConflictPair)
    {
        pConflictPair->dwFeatureIndex1 = dwFeatureIndex ;
        pConflictPair->dwFeatureIndex2 = 0xFFFFFFFF;
            // Gets set to indicate we have a constraint.
        //  leave  pbEnabledOptions  as is.  These are
        //  the options currently selected for this feature.

        #if 0
        if(!(pbNewEnabledOptions = (PBOOL)MemAlloc(dwNumOpts * sizeof(BOOL) ) ))
        {
            ERR(("Fatal: BSelectivelyEnumEnabledOptions - unable to alloc %d bytes.\n",
                dwNumOpts * sizeof(BOOL) ));
            return(FALSE) ;
        }
        #endif

        if(pbEnabledOptions)
        {
            for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
                pbNewEnabledOptions[dwI] = pbEnabledOptions[dwI] ;
        }
        else
        {
            for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
                pbNewEnabledOptions[dwI] = FALSE ;
            pbNewEnabledOptions[dwOptSel] = TRUE ;
        }

        pbEnabledOptions = pbNewEnabledOptions ;  // forget the original.
    }
    else
    {
        for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
            pbEnabledOptions[dwI] = TRUE ;
    }

    if(!pbEnabledOptions)
    {
        RIP(("BSelectivelyEnumEnabledOptions: pbEnabledOptions is NULL")) ;
        return(FALSE);
    }


    for(dwFea = 0 ; dwFea < dwNumFea ; dwFea++)
    {
        if(dwFea == dwFeatureIndex)
            continue ;
        if(pbHonorConstraints  &&  !pbHonorConstraints[dwFea])
            continue ;

        bStatus = BEnumImposedConstraintsOnFeature(pnRawData, dwFeatureIndex,
            dwFea, pOptions[dwFea].ubCurOptIndex, pbEnabledOptions, pConflictPair) ;
        if(pConflictPair  &&  pConflictPair->dwFeatureIndex2 != 0xFFFFFFFF)
        {
            //  MemFree(pbEnabledOptions) ;
            return(TRUE) ;  // Meaningless return value.
        }

        dwSrcTail = pOptions[dwFea].ubNext ;

        while(dwSrcTail)    //  PickMany options
        {
            if(!BEnumImposedConstraintsOnFeature(pnRawData, dwFeatureIndex,
                dwFea, pOptions[dwSrcTail].ubCurOptIndex, pbEnabledOptions,
                pConflictPair) )
                bStatus = FALSE;
            if(pConflictPair  &&  pConflictPair->dwFeatureIndex2 != 0xFFFFFFFF)
            {
                //  MemFree(pbEnabledOptions) ;
                return(TRUE) ;  // Meaningless return value.
            }
            dwSrcTail = pOptions[dwSrcTail].ubNext ;
        }
    }

    patrRoot = &(pfo[dwFeatureIndex].atrConstraints) ;

    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        if(!pbEnabledOptions[dwI])
            continue ;
        dwNodeIndex = DwFindNodeInCurLevel(patt , patrRoot , dwI) ;

        if(dwNodeIndex == INVALID_INDEX)
            continue ;  // this option has no constraints
        if(patt[dwNodeIndex].eOffsetMeans != VALUE_AT_HEAP)
        {
            ERR(("Internal error.  BSelectivelyEnumEnabledOptions - Unexpected Sublevel found for atrConstraints.\n"));
            continue ;  // skip this anomaly
        }
        dwCNode = *(PDWORD)(pubHeap + patt[dwNodeIndex].dwOffset) ;

        if(BIsConstraintActive(pcnstr , dwCNode, pbHonorConstraints, pOptions, pConflictPair) )
        {
            pbEnabledOptions[dwI] = FALSE ;
            if(pConflictPair)
            {
                //  MemFree(pbEnabledOptions) ;
                pConflictPair->dwOptionIndex1 = dwI ;
                return(TRUE) ;  // Meaningless return value.
            }
        }
    }

    //  lastly must walk InvalidCombos for each option of dwFeatureIndex
    //  and mark   pbEnabledOptions accordingly.

    patrRoot = &(pfo[dwFeatureIndex].atrInvalidCombos) ;

    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        if(!pbEnabledOptions[dwI])
            continue ;

        dwNodeIndex = DwFindNodeInCurLevel(patt , patrRoot , dwI) ;

        if(dwNodeIndex == INVALID_INDEX)
            continue ;  // this option has no invalid combos
        if(patt[dwNodeIndex].eOffsetMeans != VALUE_AT_HEAP)
        {
            ERR(("Internal error.  BSelectivelyEnumEnabledOptions - Unexpected Sublevel found for atrInvalidCombos.\n"));
            continue ;  // skip this anomaly
        }
        dwICNode = patt[dwNodeIndex].dwOffset ;

        while(dwICNode != END_OF_LIST)
        //  search through each applicable invalid combo
        {
            dwNextInvCombo = END_OF_LIST ;  //  fail safe - stop
                // search in the event this invalid combo doesn't
                //  contain dwFeatureIndex/dwI
            bConstrained = TRUE ;  // Assume true initially
            bNextLinkFound = FALSE ;
            while(dwICNode != END_OF_LIST)
            //    for each element comprising the invalid combo
            {
                if(!bNextLinkFound  &&
                    pinvc[dwICNode].dwFeature == dwFeatureIndex  &&
                    (pinvc[dwICNode].dwOption == dwI ||
                    (WORD)pinvc[dwICNode].dwOption == (WORD)DEFAULT_INIT))
                {
                    dwNextInvCombo = pinvc[dwICNode].dwNewCombo ;
                    bNextLinkFound = TRUE ;
                    //  we are just asking if this option was selected
                    //  will it trigger an invalid combo?
                    //  this means currently this option is not selected
                    //  but we want to pretend for the purposes of
                    //  evaluating invalid combos that it is.
                    //  this is why an else if()  statement follows.
                }
                else if(bConstrained  &&  ((pbHonorConstraints  &&
                        !pbHonorConstraints[pinvc[dwICNode].dwFeature])
                        ||  !BIsFeaOptionCurSelected(pOptions,
                        pinvc[dwICNode].dwFeature,
                        pinvc[dwICNode].dwOption) ) )
                {
                    bConstrained = FALSE ;
                }
                else if(pConflictPair)
                {
                    //  need to remember one of the constrainers
                    //  so we can emit a warning message.
                    dwCFeature = pinvc[dwICNode].dwFeature ;
                    dwCOption = pinvc[dwICNode].dwOption ;
                }

                if(!bConstrained  &&  bNextLinkFound)
                    break ;  //  no need to keep traversing elements
                        //  in this invalid combo.
                dwICNode = pinvc[dwICNode].dwNextElement ;
            }
            if(bConstrained)
            {
                pbEnabledOptions[dwI] = FALSE ;

                if(pConflictPair)
                {
                    pConflictPair->dwOptionIndex1 = dwI ;
                    pConflictPair->dwFeatureIndex2 = dwCFeature ;
                    pConflictPair->dwOptionIndex2 = dwCOption ;

                    //  MemFree(pbEnabledOptions) ;
                    return(TRUE) ;  // Meaningless return value.
                }

                break ;     //  no need to see if any other invalid
                            //  combos apply.  One is enough.
            }
            dwICNode = dwNextInvCombo ;
        }
    }
    if(pConflictPair)
    {
        pConflictPair->dwFeatureIndex1 = 0xFFFFFFFF ;
        //  no constraints found.
        //  MemFree(pbEnabledOptions) ;
        return(TRUE) ;  // Meaningless return value.
    }
    for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
    {
        if(pbEnabledOptions[dwI])
            break ;
    }
    if(dwI >= dwNumOpts)
        bStatus = FALSE ;  // Feature is disabled.
    return(bStatus) ;
}


BOOL
BEnumImposedConstraintsOnFeature
(
    IN PRAWBINARYDATA   pnRawData,
    IN DWORD            dwTgtFeature,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2,
    OUT PBOOL           pbEnabledOptions,
    OUT PCONFLICTPAIR    pConflictPair   // if present, pbEnabledOptions
    )
/*
    This function only searches for the unidirctional
    constraints found at dwFeature2, dwOption2 and
    records their effect on the options of feature1 by
    setting to FALSE the  BOOL element in pbEnabledOptions
    corresponding to the option disabled.
    (ANDing mask)
    Assumes:  pbEnabledOptions is properly initialized to all
    TRUE (or was that way at some point.)  This function never
    sets any elements TRUE.  Only sets some elements FALSE.
*/
{

    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
//    PMINIRAWBINARYDATA pmrbd  ;
    PBYTE   pubHeap ,  // start of string heap.
            pubRaw ;  //  raw binary data.
    DWORD           dwNodeIndex ,
                    dwCNode ;  //  index to a Constraint node
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
//    PINVALIDCOMBO   pinvc ;    //  root of invalid combo nodes
    PCONSTRAINTS    pcnstr ;   //  root of Constraint nodes
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA


    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    patt = (PATTRIB_TREE)(pubRaw +
            pearTableContents[MTI_ATTRIBTREE].loOffset) ;
//    pinvc = (PINVALIDCOMBO) (pubRaw +
//            pearTableContents[MTI_INVALIDCOMBO].loOffset) ;
    pcnstr = (PCONSTRAINTS) (pubRaw +
            pearTableContents[MTI_CONSTRAINTS].loOffset) ;
    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;



    patrRoot = &(pfo[dwFeature2].atrConstraints) ;

    dwNodeIndex = DwFindNodeInCurLevel(patt , patrRoot , dwOption2) ;

    if(dwNodeIndex == INVALID_INDEX)
        return(TRUE) ;  //  no imposed constraints found

    if(patt[dwNodeIndex].eOffsetMeans != VALUE_AT_HEAP)
    {
        ERR(("Internal error.  BEnumImposedConstraintsOnFeature - Unexpected Sublevel found for atrConstraints.\n"));
        return(FALSE) ;
    }

    dwCNode = *(PDWORD)(pubHeap + patt[dwNodeIndex].dwOffset) ;

    while(1)
    {
        if(pcnstr[dwCNode].dwFeature == dwTgtFeature  &&
            pbEnabledOptions[pcnstr[dwCNode].dwOption] == TRUE )
        {
            pbEnabledOptions[pcnstr[dwCNode].dwOption] = FALSE ;
            //  this option in dwTgtFeature is constrained.
            if(pConflictPair)
            {
                pConflictPair->dwOptionIndex1 = pcnstr[dwCNode].dwOption ;
                pConflictPair->dwFeatureIndex2 = dwFeature2 ;
                pConflictPair->dwOptionIndex2 = dwOption2 ;
                return(TRUE) ;  // Meaningless return value.
            }
        }

        dwCNode = pcnstr[dwCNode].dwNextCnstrnt ;
        if(dwCNode == END_OF_LIST)
            break ;
    }

    return(TRUE) ;  //  nothing bad happened.
}

DWORD    DwFindNodeInCurLevel(
PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
PATREEREF        patr ,  // index to a level in the attribute tree.
DWORD   dwOption   // search current level for this option
)

/*
this function returns the node index to the node containing
the specified dwOption in the selected level of the tree.
If the specified option branch does not exist,  the function returns
INVALID_INDEX.
Assumes caller has verified dwFeature matches.
*/
{
    DWORD           dwNodeIndex ;

    if(*patr == ATTRIB_UNINITIALIZED)
        return(INVALID_INDEX) ;

    if(*patr & ATTRIB_HEAP_VALUE)
    {
        ERR(("Internal error.  DwFindNodeInCurLevel - Unexpected branchless node found.\n"));
        return(INVALID_INDEX) ;
    }

    // search for matching option.

    dwNodeIndex = *patr  ;

    while(1)
    {
        if(patt[dwNodeIndex].dwOption == dwOption )
        {
            //  we found it!
            return(dwNodeIndex) ;
        }
        if(patt[dwNodeIndex].dwNext == END_OF_LIST)
            break ;
        dwNodeIndex = patt[dwNodeIndex].dwNext ;
    }
    return(INVALID_INDEX) ;
}


BOOL     BIsConstraintActive(
IN  PCONSTRAINTS    pcnstr ,   //  root of Constraint nodes
IN  DWORD   dwCNode,    //  first constraint node in list.
IN  PBOOL           pbHonorConstraints,  // if non NULL
IN  POPTSELECT       pOptions,
OUT PCONFLICTPAIR    pConflictPair   )
/*
    This function walks the list of constraint nodes
    starting at dwNodeIndex and checks to see if the
    Feature/Option specified within is in fact currently
    selected in pOptions.  If yes, immediately return true.
    If not, go to the next node in the list and repeat.
*/
{
    while(1)
    {
        if(!pbHonorConstraints  ||  pbHonorConstraints[pcnstr[dwCNode].dwFeature])
        {
            if(BIsFeaOptionCurSelected(pOptions,
                    pcnstr[dwCNode].dwFeature,
                    pcnstr[dwCNode].dwOption) )
            {
                if(pConflictPair)
                {
                    pConflictPair->dwFeatureIndex2 = pcnstr[dwCNode].dwFeature;
                    pConflictPair->dwOptionIndex2 = pcnstr[dwCNode].dwOption ;
                }
                return(TRUE) ;  // a constraint does exist.
            }
        }

        dwCNode = pcnstr[dwCNode].dwNextCnstrnt ;
        if(dwCNode == END_OF_LIST)
            break ;
    }
    return(FALSE);
}


#ifdef  GMACROS

//  note:  must precede calls  to ResolveUIConflict
//  with a call to ResolveDependentSettings

BOOL
ResolveDependentSettings(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions
    )
//  Note this function does  handle multiple selections
//  it will treat them as additional links in the chain.
{
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    PBYTE   pubRaw ;  //  raw binary data.
    PLISTNODE    plstRoot ;  // start of LIST array
    DWORD    dwListsRoot, dwListIndex;   //  Root of the chain
    DWORD   dwNumFeatures, dwI, dwJ, dwFea, dwNodeIndex,
        dwFeature, dwOption ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    PDWORD   pdwPriority ;
    PQUALNAME  pqn ;   // the dword in the list node is actually a
                        // qualified name structure.
    INT     iOptionsNeeded;
    PBOOL   pbOneShotFlag, pbSelectedOptions ;
    BOOL    bMatchFound ;  //  a DependentSettings matches the current config.
    POPTSELECT   pDestOptions ;
    BOOL   bStatus = TRUE ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;



    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    pdwPriority = (PDWORD)(pubRaw +
            pearTableContents[MTI_PRIORITYARRAY].loOffset) ;

    plstRoot = (PLISTNODE)(pubRaw + pearTableContents[MTI_LISTNODES].
                            loOffset) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    if(dwNumFeatures > (DWORD)iMaxOptions)
    {
        iOptionsNeeded = dwNumFeatures ;
        return(FALSE);  // too many to save in option array.
    }

    pbOneShotFlag = (PBOOL)MemAlloc(dwNumFeatures * sizeof(BOOL) ) ;
    pbSelectedOptions = (PBOOL)MemAlloc(iMaxOptions * sizeof(BOOL) ) ;
    //  iMaxOptions must be greater than the max number of options availible for
    //  any feature.


    //  to extend to pickmany, have a dest optionarray.
    //  each time the source optionarray completely contains
    //  a  DependentSettings  list (in that each Fea.Option
    //  listed as a DependentSetting  is also selected in the
    //  source option array) we turn on those Fea.Options
    //  in the dest option array.  After all DependentSettings
    //  lists for that feature have been processed, we set
    //  the OneShotFlag for each Feature that has been affected
    //  in the dest option array.  For each such feature we will
    //  let the dest option array determine the setting of the
    //  source option array.
    //  this code does not verify that a Feature is pickmany
    //  before treating it as pickmany.  If the source option
    //  array has more than one option selected for a feature,
    //  that feature is automatically treated as a pickmany.


    pDestOptions = (POPTSELECT)MemAlloc(iMaxOptions * sizeof(OPTSELECT) ) ;
        //  'or' all acceptable DependentSettings here.

    if(!(pbOneShotFlag && pDestOptions  &&  pbSelectedOptions))
    {
        ERR(("Fatal: ResolveDependentSettings - unable to alloc requested memory: %d bytes.\n",
                    dwNumFeatures * sizeof(BOOL)));
        bStatus = FALSE ;
        goto    ABORTRESOLVEDEPENDENTSETTINGS ;
    }

    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
        pbOneShotFlag[dwI] = FALSE ;
    //  this boolean array tracks if the feature has been
    // referenced in a DependentSettings entry.
    //  If a feature is referenced again in DependentSettings
    //  entry belonging to another feature, the subsequent
    //  references will be ignored.  This ensures only the
    //  highest priority Feature's request shall have precedence.


    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        DWORD   dwNextOpt, dwListsRootOpt1 ;
        //  The order of evaluation is determined
        //  by the priority array.


        dwFea = pdwPriority[dwI] ;
        pbOneShotFlag[dwFea] = TRUE ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.
        dwListsRootOpt1 = END_OF_LIST ;   // list for the 1st selected
        // option of a pickmany feature.

        for( dwJ = 0 ; dwJ < dwNumFeatures ; dwJ++)
        {
            pDestOptions[dwJ].ubCurOptIndex = OPTION_INDEX_ANY ;
            pDestOptions[dwJ].ubNext = 0 ;  // eol
            //  DestOptions is now blank.
        }

        bMatchFound = FALSE ;


        do
         {   //  for each option selected in a pick many feature
             //  treat associated DepSettings same as more than
             //  one DepSettings entry defined for one feature.

        {
            DWORD   dwUnresolvedFeature  ;
            PATREEREF    patrRoot ;    //  root of attribute tree to navigate.

            patrRoot = &(pfo[dwFea].atrDependentSettings) ;


            if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSDepSettingsIndex,
                (PBYTE)&dwListsRoot,
                &dwUnresolvedFeature,  *patrRoot, pOptions,
                dwFea,
                &dwNextOpt) != TRI_SUCCESS)
            {
                goto  END_OF_FOR_LOOP ;  //  no DependentSettings to apply.
            }
            if(dwListsRoot == END_OF_LIST)
                continue;  // maybe another option does have a list.

        }

        if(dwListsRootOpt1 == END_OF_LIST)  // first time thru do loop?
            dwListsRootOpt1 = dwListsRoot ;

        //  now we need to see if the current pOption matches any
        //  of the lists accessed using dwListsRoot.

        for(dwListIndex = dwListsRoot  ;
                dwListIndex != END_OF_LIST   ;
                dwListIndex = plstRoot[dwListIndex].dwNextItem  )
        {
            //  for each DepSettings list....
            //  now walk that DepSettings list at dwListIndex and compare
            //  to current settings at pOptions.   If there is a match, use
            //  depSettings list to OR on options in pDestOptions.
            //   Note:  Features with their one-shot flag set cannot be
            //  considered.  They will be ignored.
            BOOL     bActiveMatch = FALSE,  // requires an actual match
                bOptionArrayMatchesDepSettings = TRUE ;  // assume true
                //  until proven otherwise.
            for(dwNodeIndex = plstRoot[dwListIndex].dwData ; dwNodeIndex != END_OF_LIST ;
                       dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
            {
                pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                dwFeature = pqn->wFeatureID ;
                dwOption = pqn->wOptionID ;
                if(pbOneShotFlag[dwFeature] == TRUE)
                    continue;
                if(!BIsFeaOptionCurSelected(pOptions,  dwFeature, dwOption) )
                {
                    bOptionArrayMatchesDepSettings = FALSE ;
                    break;
                }
                else
                    bActiveMatch  = TRUE;
            }

            if(bOptionArrayMatchesDepSettings  &&  bActiveMatch)
                //   at least one DepSetting was honored.
           {
                //  'or' DepSettings into DestOptions
                for(dwNodeIndex = plstRoot[dwListIndex].dwData ; dwNodeIndex != END_OF_LIST ;
                           dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
                {
                    pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                    dwFeature = pqn->wFeatureID ;
                    dwOption = pqn->wOptionID ;
                    if(pbOneShotFlag[dwFeature] == TRUE)
                        continue;
                    //  select dwOption in DestOptions in addition to any other options
                    //  already selected.
                    EnumSelectedOptions(pnRawData, pDestOptions, dwFeature,
                                                         pbSelectedOptions) ;
                    if(!pbSelectedOptions[dwOption])   //  the option that should be selected isn't.
                    {                                                        //  so let's turn it on.
                        pbSelectedOptions[dwOption] = TRUE ;   //  This is the ORing process.
                        ReconstructOptionArray( pnRawData, pDestOptions, iMaxOptions,
                            dwFeature, pbSelectedOptions ) ;
                        bMatchFound = TRUE ;  // there really is something to set.
                    }
                }
           }
        }

         } while (dwNextOpt);

        if (dwListsRootOpt1 == END_OF_LIST)
            continue;   // you cannot set anything if there is no list to use.

        if (!bMatchFound)
        {
            //  set dest Option array  according to depSettings(dwListsRoot)
            for(dwNodeIndex = plstRoot[dwListsRootOpt1].dwData ; dwNodeIndex != END_OF_LIST ;
                       dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
            {
                pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                dwFeature = pqn->wFeatureID ;
                dwOption = pqn->wOptionID ;
                if(pbOneShotFlag[dwFeature] == TRUE)
                    continue;
                pDestOptions[dwFeature].ubCurOptIndex  = (BYTE)dwOption ;
            }
        }

        //  propagate Dest option array settings to pOptions
        //  note which features got set and set their one-shot
        //  flag.


        for( dwFeature = 0 ; dwFeature < dwNumFeatures ; dwFeature++)
        {
            if(pDestOptions[dwFeature].ubCurOptIndex == OPTION_INDEX_ANY)
                continue;
            EnumSelectedOptions( pnRawData,  pDestOptions,
                                                    dwFeature,  pbSelectedOptions) ;

            ReconstructOptionArray( pnRawData, pOptions, iMaxOptions,
                    dwFeature, pbSelectedOptions ) ;
            pbOneShotFlag[dwFeature] = TRUE ;
        }

END_OF_FOR_LOOP:
          ;   //  dummy statement after every label.
    }   // end for loop.  for each Feature in order of priority.

ABORTRESOLVEDEPENDENTSETTINGS:
    if(pbOneShotFlag)
        MemFree(pbOneShotFlag);
    if(pDestOptions)
        MemFree(pDestOptions);
    if(pbSelectedOptions)
        MemFree(pbSelectedOptions);
    return(bStatus);
}


void  EnumSelectedOptions(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeature,
    IN PBOOL            pbSelectedOptions)
{
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    PBYTE   pubRaw ;  //  raw binary data.
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    DWORD  dwNumOptions, dwI, dwOption, dwNextOpt ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;


    dwNumOptions = pfo[dwFeature].dwNumOptions ;

    for( dwI = 0 ; dwI < dwNumOptions ; dwI++)
        pbSelectedOptions[dwI] = FALSE ;


    if((dwOption = pOptions[dwFeature].ubCurOptIndex) == OPTION_INDEX_ANY)
        return;

    pbSelectedOptions[dwOption] = TRUE ;
    dwNextOpt = dwFeature ;  // case of pick many
    while(dwNextOpt = pOptions[dwNextOpt].ubNext)
    {
        pbSelectedOptions[pOptions[dwNextOpt].ubCurOptIndex] = TRUE ;
    }
    return;
}


BOOL
ExecuteMacro(
    IN PRAWBINARYDATA   pnRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN    DWORD    dwFea,    //  what feature was selected in UI
    IN    DWORD    dwOpt ,   //  what option was selected in UI
    OUT PBOOL   pbFeaturesChanged  // tell Amanda what Features were changed.
    )
//  does this for one feature and one option  only!
{
    PRAWBINARYDATA   pRawData ;
    PSTATICFIELDS   pStatic ;
    PBYTE   pubRaw ;  //  raw binary data.
    PLISTNODE    plstRoot ;  // start of LIST array
    DWORD    dwListsRoot, dwListIndex;   //  Root of the chain
    DWORD   dwNumFeatures, dwI, dwJ,  dwNodeIndex,
        dwFeature, dwOption ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    PDWORD   pdwPriority ;
    PQUALNAME  pqn ;   // the dword in the list node is actually a
                        // qualified name structure.
    INT     iOptionsNeeded;
    PBOOL   pbOneShotFlag, pbSelectedOptions ;
    BOOL    bHigherPri,   //  divides features into two groups those with higher priority
                                    // than dwFea, and those with lower priority.
                                    //  the Macro cannot change Features with higher priority.
            bMatchFound ;  //  a DependentSettings matches the current config.
    POPTSELECT   pDestOptions ;
    BOOL   bStatus = TRUE ;

    pStatic = (PSTATICFIELDS)pnRawData ;      // transform pubRaw from PSTATIC
    pRawData  = (PRAWBINARYDATA)pStatic->pubBUDData ;
                                                                        //  to BUDDATA

    pubRaw = (PBYTE)pRawData ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;



    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw +
            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset) ;
    pdwPriority = (PDWORD)(pubRaw +
            pearTableContents[MTI_PRIORITYARRAY].loOffset) ;

    plstRoot = (PLISTNODE)(pubRaw + pearTableContents[MTI_LISTNODES].
                            loOffset) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    if(dwNumFeatures > (DWORD)iMaxOptions)
    {
        iOptionsNeeded = dwNumFeatures ;
        return(FALSE);  // too many to save in option array.
    }

    pbOneShotFlag = (PBOOL)MemAlloc(dwNumFeatures * sizeof(BOOL) ) ;
    pbSelectedOptions = (PBOOL)MemAlloc(iMaxOptions * sizeof(BOOL) ) ;
    //  iMaxOptions must be greater than the max number of options availible for
    //  any feature.


    //  to extend to pickmany, have a dest optionarray.
    //  each time the source optionarray completely contains
    //  a  DependentSettings  list (in that each Fea.Option
    //  listed as a DependentSetting  is also selected in the
    //  source option array) we turn on those Fea.Options
    //  in the dest option array.  After all DependentSettings
    //  lists for that feature have been processed, we set
    //  the OneShotFlag for each Feature that has been affected
    //  in the dest option array.  For each such feature we will
    //  let the dest option array determine the setting of the
    //  source option array.
    //  this code does not verify that a Feature is pickmany
    //  before treating it as pickmany.  If the source option
    //  array has more than one option selected for a feature,
    //  that feature is automatically treated as a pickmany.


    pDestOptions = (POPTSELECT)MemAlloc(iMaxOptions * sizeof(OPTSELECT) ) ;
        //  'or' all acceptable DependentSettings here.

    if(!(pbOneShotFlag && pDestOptions  &&  pbSelectedOptions))
    {
        ERR(("Fatal: ResolveDependentSettings - unable to alloc requested memory: %d bytes.\n",
                    dwNumFeatures * sizeof(BOOL)));
        bStatus = FALSE ;
        goto    ABORTEXECUTEMACROS ;
    }


    for(bHigherPri = TRUE, dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        pbFeaturesChanged[dwI] = FALSE ;   //  start with no Features changed
        pbOneShotFlag[pdwPriority[dwI]] = bHigherPri ;
        if(pdwPriority[dwI] == dwFea)
             bHigherPri = FALSE ;   //  all remaining features are of lower priority
                                        //  and therefore susceptible to getting changed by the macro.
    }
    //  this boolean array tracks if the feature has been
    // referenced in a DependentSettings entry.
    //  If a feature is referenced again in DependentSettings
    //  entry belonging to another feature, the subsequent
    //  references will be ignored.  This ensures only the
    //  highest priority Feature's request shall have precedence.


    {
        DWORD   dwNextOpt ;
        //  The order of evaluation is determined
        //  by the priority array.


        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        for( dwJ = 0 ; dwJ < dwNumFeatures ; dwJ++)
        {
            pDestOptions[dwJ].ubCurOptIndex = OPTION_INDEX_ANY ;
            pDestOptions[dwJ].ubNext = 0 ;  // eol
            //  DestOptions is now blank.
        }

        bMatchFound = FALSE ;



        {
            DWORD   dwUnresolvedFeature, dwOldOpt  ;
            PATREEREF    patrRoot ;    //  root of attribute tree to navigate.

            patrRoot = &(pfo[dwFea].atrUIChangeTriggersMacro) ;

            //   if dwFea is a pickmany, we must force selection of
            //   the Macro associated with just dwOpt.  We do this by
            //   changing the optionarray temporarily.

            dwOldOpt = pOptions[dwFea].ubCurOptIndex ;
            pOptions[dwFea].ubCurOptIndex = (BYTE)dwOpt ;

            if(EextractValueFromTree((PBYTE)pnRawData, pStatic->dwSSUIChangeTriggersMacroIndex,
                (PBYTE)&dwListsRoot,
                &dwUnresolvedFeature,  *patrRoot, pOptions,
                dwFea,
                &dwNextOpt) != TRI_SUCCESS)
            {
                pOptions[dwFea].ubCurOptIndex = (BYTE)dwOldOpt ;   // restore
                goto  ABORTEXECUTEMACROS ;  //  no UIChangeTriggersMacro to apply.
            }
            pOptions[dwFea].ubCurOptIndex = (BYTE)dwOldOpt ;    // restore
            if(dwListsRoot == END_OF_LIST)
                goto  ABORTEXECUTEMACROS ;  //  no UIChangeTriggersMacro to apply.
        }


        //  now we need to see if the current pOption matches any
        //  of the lists accessed using dwListsRoot.

        for(dwListIndex = dwListsRoot  ;
                dwListIndex != END_OF_LIST   ;
                dwListIndex = plstRoot[dwListIndex].dwNextItem  )
        {
            //  for each DepSettings list....
            //  now walk that DepSettings list at dwListIndex and compare
            //  to current settings at pOptions.   If there is a match, use
            //  depSettings list to OR on options in pDestOptions.
            //   Note:  Features with their one-shot flag set cannot be
            //  considered.  They will be ignored.
            BOOL     bActiveMatch = FALSE,  // requires an actual match
                bOptionArrayMatchesDepSettings = TRUE ;  // assume true
                //  until proven otherwise.
            for(dwNodeIndex = plstRoot[dwListIndex].dwData ; dwNodeIndex != END_OF_LIST ;
                       dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
            {
                pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                dwFeature = pqn->wFeatureID ;
                dwOption = pqn->wOptionID ;
                if(pbOneShotFlag[dwFeature] == TRUE)
                    continue;
                if(!BIsFeaOptionCurSelected(pOptions,  dwFeature, dwOption) )
                {
                    bOptionArrayMatchesDepSettings = FALSE ;
                    break;
                }
                else
                    bActiveMatch  = TRUE;
            }

            if(bOptionArrayMatchesDepSettings  &&  bActiveMatch)
                //   at least one DepSetting was honored.
           {
                //  'or' DepSettings into DestOptions
                for(dwNodeIndex = plstRoot[dwListIndex].dwData ; dwNodeIndex != END_OF_LIST ;
                           dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
                {
                    pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                    dwFeature = pqn->wFeatureID ;
                    dwOption = pqn->wOptionID ;
                    if(pbOneShotFlag[dwFeature] == TRUE)
                        continue;
                    //  select dwOption in DestOptions in addition to any other options
                    //  already selected.
                    EnumSelectedOptions(pnRawData, pDestOptions, dwFeature,
                                                         pbSelectedOptions) ;
                    if(!pbSelectedOptions[dwOption])   //  the option that should be selected isn't.
                    {                                                        //  so let's turn it on.
                        pbSelectedOptions[dwOption] = TRUE ;   //  This is the ORing process.
                        ReconstructOptionArray( pnRawData, pDestOptions, iMaxOptions,
                            dwFeature, pbSelectedOptions ) ;
                        bMatchFound = TRUE ;  // there really is something to set.
                    }
                }
           }
        }


        if (!bMatchFound)
        {
            //  set dest Option array  according to depSettings(dwListsRoot)
            for(dwNodeIndex = plstRoot[dwListsRoot].dwData ; dwNodeIndex != END_OF_LIST ;
                       dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem)
            {
                pqn = (PQUALNAME)(&plstRoot[dwNodeIndex].dwData) ;
                dwFeature = pqn->wFeatureID ;
                dwOption = pqn->wOptionID ;
                if(pbOneShotFlag[dwFeature] == TRUE)
                    continue;
                pDestOptions[dwFeature].ubCurOptIndex  = (BYTE)dwOption ;
            }
        }

        //  propagate Dest option array settings to pOptions
        //  note which features got set and set their one-shot
        //  flag.


        for( dwFeature = 0 ; dwFeature < dwNumFeatures ; dwFeature++)
        {
            if(pDestOptions[dwFeature].ubCurOptIndex == OPTION_INDEX_ANY)
                continue;
            EnumSelectedOptions( pnRawData,  pDestOptions,
                                                    dwFeature,  pbSelectedOptions) ;

            ReconstructOptionArray( pnRawData, pOptions, iMaxOptions,
                    dwFeature, pbSelectedOptions ) ;
            pbOneShotFlag[dwFeature] = TRUE ;
            pbFeaturesChanged[dwFeature] = TRUE ;   //  this Feature may have changed
        }

    }   // end non-existent for loop.

ABORTEXECUTEMACROS:
    if(pbOneShotFlag)
        MemFree(pbOneShotFlag);
    if(pDestOptions)
        MemFree(pDestOptions);
    if(pbSelectedOptions)
        MemFree(pbSelectedOptions);
    return(bStatus);
}
#endif

#endif PARSERDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\gpdparse.h ===
/*++

  Copyright (c) 1996-1999  Microsoft Corporation


Module Name:

    gpdparse.h

Abstract:

    Header file for GPD parser

Environment:

    Windows NT Universal printer driver.

Revision History:

--*/

/*
    gpdparse.h - this holds structure definitions
    and other defines specific to the GPD parser
*/

#ifndef _GPDPARSE_H_
#define _GPDPARSE_H_

#include "lib.h"
#include "gpd.h"






#ifdef  GMACROS
#define     PRIVATE_PARSER_VERSION    0x0053
#else
#define     PRIVATE_PARSER_VERSION    0x0052
#endif

#define GPD_PARSER_VERSION      MAKELONG(PRIVATE_PARSER_VERSION, SHARED_PARSER_VERSION)


//  extra printrate units not defined in wingdi.h

#define   PRINTRATEUNIT_LPS     5
#define   PRINTRATEUNIT_IPS     6







// ----  General Section ---- //

typedef DWORD   DWFLAGS  ;


#define FIRST_NON_STANDARD_ID        257

#define  FOREVER  (1)

#define  BUD_FILENAME_EXT   TEXT(".BUD")
    //  "bud"  in unicode. GPD -> BUD.

//  a non-relocatable string reference, but unlike an ARRAYREF, can access
//  addresses outside of the memory buffer defined by the base reference
//  pointer used by an ARRAYREF.

//  note: for all arrayrefs containing Strings the dw field holds the number
//  of bytes which the string contains.  For Unicode strings this is TWICE
//  the number of Unicode characters.

#define LOCALE_KEYWORD  "Locale"

typedef struct
{
    PBYTE   pub ;
    DWORD   dw ;
} ABSARRAYREF ,  * PABSARRAYREF ;  //  assign this struct the type  'aar'

typedef  struct
{
    DWORD   loOffset ;
    DWORD   dwCount  ;
    DWORD   dwElementSiz ;
} ENHARRAYREF , * PENHARRAYREF ;  //  assign this struct the type  'ear'


// ----  End of General Section ---- //



// ---- Constant Classes  Section ---- //


typedef   enum
{
    //  -- Constant Classes -- //

    CL_BOOLEANTYPE,
    CL_PRINTERTYPE,
    CL_FEATURETYPE,
    CL_UITYPE,
    CL_PROMPTTIME,
    CL_PAPERFEED_ORIENT,
    CL_COLORPLANE,
    CL_SEQSECTION,
    CL_RASTERCAPS,
    CL_TEXTCAPS,
    CL_MEMORYUSAGE,
    CL_RESELECTFONT,
    CL_OEMPRINTINGCALLBACKS,
    CL_CURSORXAFTERCR,
    CL_BADCURSORMOVEINGRXMODE,
//    CL_SIMULATEXMOVE,
    CL_PALETTESCOPE,
    CL_OUTPUTDATAFORMAT,
    CL_STRIPBLANKS,
    CL_LANDSCAPEGRXROTATION,
    CL_CURSORXAFTERSENDBLOCKDATA,
    CL_CURSORYAFTERSENDBLOCKDATA,
    CL_CHARPOSITION,
    CL_FONTFORMAT,
    CL_QUERYDATATYPE,
    CL_YMOVEATTRIB,
    CL_DLSYMBOLSET,
    CL_CURXAFTER_RECTFILL,
    CL_CURYAFTER_RECTFILL,
    #ifndef WINNT_40
    CL_PRINTRATEUNIT,
    #endif
    CL_RASTERMODE,
    CL_QUALITYSETTING ,

    //  the following aren't true constant classes per se,
    //  but if the construct fits...


    CL_STANDARD_VARS, //  names of Unidrv Standard Variables
    CL_COMMAND_NAMES, //  Unidrv Command Names and index.

    CL_CONS_FEATURES, // reserved feature symbol names

    // reserved  option symbol names for these predefined features

    CL_CONS_PAPERSIZE,
    CL_CONS_MEDIATYPE,
    CL_CONS_INPUTSLOT,
    CL_CONS_DUPLEX,
    CL_CONS_ORIENTATION,
    CL_CONS_PAGEPROTECT,
    CL_CONS_COLLATE,
    CL_CONS_HALFTONE,

    CL_NUMCLASSES
}  CONSTANT_CLASSES ;  //  enumerate types of constant classes

typedef  struct   //  only used in static gConstantsTable.
{
    PBYTE   pubName ;
    DWORD   dwValue ;
}  CONSTANTDEF, * PCONSTANTDEF ;
//  this table associates ConstantNames with their defined values.
//  The table is divided into sections, one section per class.
//  the index table - gcieTable[] provides the index range
//  that each class occupies.  Note the similarity to the arrangement
//  of the MainKeywordTable.

extern  CONST CONSTANTDEF  gConstantsTable[] ;


typedef  struct
{
    DWORD   dwStart ;     //  index of first member of class
    DWORD   dwCount ;     //  number of members in this class.
} CLASSINDEXENTRY,  * PCLASSINDEXENTRY ;


// extern  CLASSINDEXENTRY  gcieTable[CL_NUMCLASSES] ;
// This is now in GLOBL structure.


// ---- End of Constant Classes  Section ---- //



// ---- MasterTable  Section ---- //

/*  The master table keeps track of all allocated memory buffers.
The buffers are typically used to store an array of structures.
The master table is an array of entries of the form:
*/

typedef  struct  _MASTER_TABLE_ENTRY
{
    PBYTE  pubStruct ;  // address of element zero of array
    DWORD  dwArraySize ;  // number of array elements requested
    DWORD   dwCurIndex ;  //  points to first uninitialized element
    DWORD   dwElementSiz ;  // size of each element in array.
    DWORD   dwMaxArraySize ;  //  This is the absolute max size
                        //  we allow this resource to grow.
}  MASTERTAB_ENTRY ;


//  the following Enums represent indicies in the master table
//  reserved for each of the following objects:

typedef enum
{
    MTI_STRINGHEAP,   //  Permanent heap for GPD strings and binary data.
    MTI_GLOBALATTRIB,   //   structure holding value of global attributes.
    MTI_COMMANDTABLE,   //  array of ATREEREF (or DWORD indicies to
                        //  COMMAND_ARRAY)
            // note:  the IDs used to index this table are the
            // Unidrv IDs.
    MTI_ATTRIBTREE, //  array of ATTRIB_TREE structures.
    MTI_COMMANDARRAY,   //  array of COMMAND structures.
            // size varies depending on number of commands and variants
            // defined in the GPD file.
    MTI_PARAMETER, //  parameters for command
    MTI_TOKENSTREAM,  //  contains value tokens to populate the value stack
                    //  and commands to operate on them. For command
                    //  parameters
    MTI_LISTNODES,  //   array of LISTNODEs.
    MTI_CONSTRAINTS,  //  array of CONSTRAINTS
    MTI_INVALIDCOMBO,  //  array of INVALIDCOMBO
    MTI_GPDFILEDATEINFO,   //  array of GPDFILEDATEINFO

    /*  buffers allocated on 2nd pass  */

    MTI_DFEATURE_OPTIONS, //  references a whole bunch of treeroots.
        //  should be initialized to ATTRIB_UNINITIALIZED values.
        //  SymbolID pointed to by dwFeatureSymbols contains largest
        //  array index appropriated.  We won't need to allocate
        //  more elements in the final array than this.
    MTI_SYNTHESIZED_FEATURES,  //  this holds synthesized
        // features.     an array of DFEATURE_OPTIONS
    MTI_PRIORITYARRAY,  //  array of feature indicies
    MTI_TTFONTSUBTABLE, //  array of arrayrefs and integers.
    MTI_FONTCART,   //   array of FontCartridge structures - one per
                //  construct.
    //  end of buffers allocated on 2nd pass

    //  gray area: do we need to save the following objects?
    MTI_SYMBOLROOT, //  index to root of symbol tree
    MTI_SYMBOLTREE, //  symbolTree Array

    MTI_NUM_SAVED_OBJECTS ,  // denotes end of list of objects to be saved
        //  to the GPD binary file.
    MTI_TMPHEAP = MTI_NUM_SAVED_OBJECTS ,
        //  store strings referenced in tokenmap.
    MTI_SOURCEBUFFER, //  Tracks Source file (GPD  input stream)
        //  gMasterTable[MTI_SOURCEBUFFER].dwCurIndex
        //  indexes the current SOURCEBUFFER.
    MTI_TOKENMAP, //  tokenMap   large enough to hold an old and New copy!
    MTI_NEWTOKENMAP, //  newtokenMap   (not a separate buffer from TOKENMAP -
        //  just points immediately after oldTokenMap).
    MTI_BLOCKMACROARRAY, // (one for Block and another for Value macros)
    MTI_VALUEMACROARRAY, //  an array of DWORDS holding a
                //  tokenindex where a valuemacro ID value is stored
    MTI_MACROLEVELSTACK,  //  is operated as a two dword stack that saves the
            //  values of curBlockMacroArray and curValueMacroArray ,
            //  each time a brace is encountered.
    MTI_STSENTRY,  // this is the StateStack
    MTI_OP_QUEUE,    // temp queue of operators (array of DWORDS)
    MTI_MAINKEYWORDTABLE,  //  the keyword dictionary!
    MTI_RNGDICTIONARY,   //   specifies the range of indicies in the
        // mainKeyword table which comprises the specified dictionary.
    MTI_FILENAMES,  // array of ptrs to buffers containing widestrings
                    // representing GPD filenames that were read in
                    // used for friendly error messages.
    MTI_PREPROCSTATE,  //  array of PPSTATESTACK structures
            //  which hold state of preprocessor.

    MTI_MAX_ENTRIES,    //  Last entry.

}  MT_INDICIES ;


// extern MASTERTAB_ENTRY   gMasterTable[MTI_MAX_ENTRIES] ;
// This is now in GLOBL structure.


// ---- End Of MasterTable  Section ---- //


// ---- SourceBuffer  Section ---- //

/*  array of structures to track the MemoryMapped src files.
multiple files may be open at the same time due to nesting
imposed by the *Include keyword.
The array of SOURCEBUFFERS is operated as a stack.
The  MasterTable[MTI_SOURCEBUFFER] field dwCurIndex
serves as the stack pointer.
*/

typedef  struct
{
    PBYTE  pubSrcBuf ;      //  start of file bytes.
    DWORD  dwCurIndex ;     //  stream ptr
    DWORD  dwArraySize ;    //  filesize
    DWORD   dwFileNameIndex ;  //  index into MTI_FILENAMES
    DWORD   dwLineNumber    ;  //  zero indexed
    HFILEMAP  hFile ;         //  used to access/close file.
} SOURCEBUFFER, * PSOURCEBUFFER ;
//  the tagname is 'sb'


//
//    define macros to access what were global variables but are now packed
//    in PGLOBL structure.
//

#define     gMasterTable            (pglobl->GMasterTable)
#define     gmrbd                   (pglobl->Gmrbd)
#define     gastAllowedTransitions  (pglobl->GastAllowedTransitions)
#define     gabAllowedAttributes    (pglobl->GabAllowedAttributes)
#define     gdwOperPrecedence       (pglobl->GdwOperPrecedence)
#define     gdwMasterTabIndex       (pglobl->GdwMasterTabIndex)
#define     geErrorSev              (pglobl->GeErrorSev)
#define     geErrorType             (pglobl->GeErrorType)
#define     gdwVerbosity            (pglobl->GdwVerbosity)
#define     gdwID_IgnoreBlock       (pglobl->GdwID_IgnoreBlock)
#define     gValueToSize            (pglobl->GValueToSize)
#define     gdwMemConfigKB          (pglobl->GdwMemConfigKB)
#define     gdwMemConfigMB          (pglobl->GdwMemConfigMB)
#define     gdwOptionConstruct      (pglobl->GdwOptionConstruct)
#define     gdwOpenBraceConstruct   (pglobl->GdwOpenBraceConstruct)
#define     gdwCloseBraceConstruct  (pglobl->GdwCloseBraceConstruct)
#define     gdwMemoryConfigMB       (pglobl->GdwMemoryConfigMB)
#define     gdwMemoryConfigKB       (pglobl->GdwMemoryConfigKB)
#define     gdwCommandConstruct     (pglobl->GdwCommandConstruct)
#define     gdwCommandCmd           (pglobl->GdwCommandCmd)
#define     gdwOptionName           (pglobl->GdwOptionName)
#define     gdwResDLL_ID            (pglobl->GdwResDLL_ID)
#define     gdwLastIndex            (pglobl->GdwLastIndex)
#define     gaarPPPrefix            (pglobl->GaarPPPrefix)
#define     gcieTable               (pglobl->GcieTable)



//    define  Local Macro to access info for current file:

#define     mCurFile   (gMasterTable[MTI_SOURCEBUFFER].dwCurIndex)
    //  which file are we currently accessing ?
#define     mMaxFiles   (gMasterTable[MTI_SOURCEBUFFER].dwArraySize)
    //  max number of files open at one time (nesting depth)

#define     mpSourcebuffer  ((PSOURCEBUFFER)(gMasterTable \
                            [MTI_SOURCEBUFFER].pubStruct))
    //  location of first SOURCEBUFFER element in array

#define    mpubSrcRef  (mpSourcebuffer[mCurFile - 1].pubSrcBuf)
        //  start of file bytes
#define    mdwSrcInd  (mpSourcebuffer[mCurFile - 1].dwCurIndex)
        //  current position in file bytes
#define    mdwSrcMax  (mpSourcebuffer[mCurFile - 1].dwArraySize)
        // filesize

// ---- End Of SourceBuffer  Section ---- //


//  -----  Preprocessor Section ---- //

    enum  IFSTATE  {IFS_ROOT, IFS_CONDITIONAL , IFS_LAST_CONDITIONAL } ;
        //  tracks correct syntatical use of #ifdef, #elseifdef, #else and #endif directives.
    enum  PERMSTATE  {PERM_ALLOW, PERM_DENY ,  PERM_LATCHED } ;
        //  tracks current state of preprocessing,
        //  PERM_ALLOW:  all statements in this section are passed to body gpdparser
        //  PERM_DENY:  statements in this section are discarded
        //  PERM_LATCHED:  all statements until the end of  this nesting level are discarded.
    enum  DIRECTIVE  {NOT_A_DIRECTIVE, DIRECTIVE_EOF, DIRECTIVE_DEFINE , DIRECTIVE_UNDEFINE ,
                       DIRECTIVE_INCLUDE , DIRECTIVE_SETPPPREFIX , DIRECTIVE_IFDEF ,
                       DIRECTIVE_ELSEIFDEF , DIRECTIVE_ELSE , DIRECTIVE_ENDIF } ;


typedef  struct
{
    enum  IFSTATE  ifState ;
    enum  PERMSTATE  permState ;
} PPSTATESTACK, * PPPSTATESTACK ;
//  the tagname is 'ppss'


#define     mppStack  ((PPPSTATESTACK)(gMasterTable \
                            [MTI_PREPROCSTATE].pubStruct))
    //  location of first SOURCEBUFFER element in array

#define     mdwNestingLevel   (gMasterTable[MTI_PREPROCSTATE].dwCurIndex)
    //  current preprocessor directive nesting level

#define     mMaxNestingLevel   (gMasterTable[MTI_PREPROCSTATE].dwArraySize)
    //  max preprocessor directive nesting depth


// ---- End Of Preprocessor  Section ---- //



// ----  Symbol Trees Section ---- //

/*  this structure is used to implement the symbol trees which
track all user defined symbol names  and associate with each name
a zero indexed integer.  */

typedef  struct
{
    ARRAYREF   arSymbolName;
    DWORD   dwSymbolID;    // has nothing to do with array of symbol structs.
            //  value begins at zero and is incremented to obtain
            //  next value.
    DWORD   dwNextSymbol;   // index to next element in this space.
    DWORD   dwSubSpaceIndex ;  // index to first element in new symbol space
            //  which exists within the catagory represented by this symbol.
            //  for example in the catagory represented by the
            //  symbol  PAPERSIZES:  we may have the subspace
            //  comprised of Letter, A4, Legal, etc.
}   SYMBOLNODE , * PSYMBOLNODE ;
//  assign this struct the type  'psn'



#define  INVALID_SYMBOLID  (0xffffffff)
    //  this value is returned instead of a valid SymbolID
    //  to indicate a failure condition - symbol not found, or
    //  unable to register symbol.
    //  Warning!  this value may be truncated to WORD to
    //  fit into a qualified name!
#define  INVALID_INDEX     (0xffffffff)
    //  used to denote the end of a chain of nodes.
    //  dwNextSymbol  may be assigned this value.


//  there is one symbol tree for each symbol class.
//  actually the options tree is a sublevel of the features
//  tree.   This enumeration is used to access the MTI_SYMBOLROOT
//  array.

typedef   enum
{
    SCL_FEATURES,  SCL_FONTCART, SCL_TTFONTNAMES,
    SCL_BLOCKMACRO,   SCL_VALUEMACRO,  SCL_OPTIONS,
    SCL_COMMANDNAMES,  SCL_PPDEFINES, SCL_NUMSYMCLASSES
}  SYMBOL_CLASSES ;

// ----  End of Symbol Trees Section ---- //


// ----  TokenMap Section ---- //


/*  the tokenMap contains an array entry for each logical statement
    in the GPD source file.  It identifies the token string
    representing the Keyword and its associated Value.
*/

typedef  struct _TOKENMAP
{
    DWORD  dwKeywordID ;  // index of entry in KeywordTable
    ABSARRAYREF  aarKeyword ; // points to keyword in the source file
    ABSARRAYREF  aarValue ;  // value associated with this keyword.
    DWORD   dwValue  ;  // interpretation of Value string - see flags.
         // maybe commandID, numerical value of constant, MacroID assigned
         // to MacroSymbol  ,  SymbolID  etc.
    DWORD   dwFileNameIndex ;  //  GPD filename
    DWORD   dwLineNumber    ;  //  zero indexed

    DWFLAGS    dwFlags ;  // bitfield with the following flags
        //  * TKMF_NOVALUE     no value was found
        //  TKMF_VALUE_SAVED     independently of the tokenmap.
        //  TKMF_COMMAND_SHORTCUT  only used when parsing commands.
        //  TKMF_INLINE_BLOCKMACROREF   need to know when resolving macros.
        //  *TKMF_COLON     additional token found in value - shortcut?
        //  *TKMF_MACROREF    indicates a value macro reference that must
        //                  be resolved
        //  TKMF_SYMBOLID  dwValue contains a symbolID.
        //  * TKMF_SYMBOL_KEYWORD   keyword is a symbol
        //  * TKMF_SYMBOL_REGISTERED  set when the symbolID is registered
        //          by ProcessSymbolKeyword  which also sets dwValue.
        //  * TKMF_EXTERN_GLOBAL  The extern Qualifier was prepended to the
        //  * TKMF_EXTERN_FEATURE    attribute keyword and has now been
        //                      truncated.
        //  *  indicates actually set by code.
        //  !  indicates actually read by code.

} TKMAP, *PTKMAP ;
//  assign this struct the type  'tkmap'


//  allowed flags for dwFlags  field:

#define     TKMF_NOVALUE                (0x00000001)
#define     TKMF_VALUE_SAVED            (0x00000002)
#define     TKMF_COMMAND_SHORTCUT       (0x00000004)
#define     TKMF_INLINE_BLOCKMACROREF   (0x00000008)
#define     TKMF_COLON                  (0x00000010)
#define     TKMF_MACROREF               (0x00000020)
#define     TKMF_SYMBOLID               (0x00000040)
#define     TKMF_SYMBOL_KEYWORD         (0x00000080)
#define     TKMF_SYMBOL_REGISTERED      (0x00000100)
#define     TKMF_EXTERN_GLOBAL          (0x00000200)
#define     TKMF_EXTERN_FEATURE         (0x00000400)


    // ---- special KeywordIDs for TokenMap ---- //
#define  ID_SPECIAL         0xff00      // larger than any KeywordTable index
#define  ID_NULLENTRY       (ID_SPECIAL + 0)
    //  ignore this, either expired code, parsing error etc.
#define  ID_UNRECOGNIZED    (ID_SPECIAL + 1)
    //  conforms to correct syntax, but not in my keyword table.
    //  could be a keyword defined in a newer spec or an attribute name
    //  or some other OEM defined stuff.
#define  ID_SYMBOL          (ID_SPECIAL + 2)
    //  this identifies a user-defined keyword like a fontname
    //  does not begin with * , but conforms to syntax for a symbol.
#define  ID_EOF             (ID_SPECIAL + 3)
    //  end of file - no more tokenMap entries


// ----  End of TokenMap Section ---- //


// ----  MainKeyword table Section ---- //

/*  the MainKeyword table contains static information that
describes each main keyword.  This table controls what action
the parser takes.  First define several enumerations used
in the table.  */

typedef  enum
{
    TY_CONSTRUCT, TY_ATTRIBUTE, TY_SPECIAL
}   KEYWORD_TYPE ;


typedef  enum
{
    ATT_GLOBAL_ONLY, ATT_GLOBAL_FREEFLOAT,
    ATT_LOCAL_FEATURE_ONLY,  ATT_LOCAL_FEATURE_FF ,
    ATT_LOCAL_OPTION_ONLY,  ATT_LOCAL_OPTION_FF ,
    ATT_LOCAL_COMMAND_ONLY,  ATT_LOCAL_FONTCART_ONLY,
    ATT_LOCAL_TTFONTSUBS_ONLY,  ATT_LOCAL_OEM_ONLY,
    ATT_LAST   // Must be last in list.
}   ATTRIBUTE ;  // subtype

typedef  enum
{
    CONSTRUCT_UIGROUP ,
    CONSTRUCT_FEATURE ,
    CONSTRUCT_OPTION ,
    CONSTRUCT_SWITCH,
    CONSTRUCT_CASE ,
    CONSTRUCT_DEFAULT ,
    CONSTRUCT_COMMAND ,
    CONSTRUCT_FONTCART ,
    CONSTRUCT_TTFONTSUBS ,
    CONSTRUCT_OEM ,
    CONSTRUCT_LAST,  // must end list of transition inducing constructs.
    // constructs below do not cause state transitions
    CONSTRUCT_BLOCKMACRO ,
    CONSTRUCT_MACROS,
    CONSTRUCT_OPENBRACE,
    CONSTRUCT_CLOSEBRACE,
    CONSTRUCT_PREPROCESSOR,
}  CONSTRUCT ;      //  SubType if Type = CONSTRUCT

typedef  enum
{
    SPEC_TTFS, SPEC_FONTSUB, SPEC_INVALID_COMBO,
    SPEC_COMMAND_SHORTCUT,
    SPEC_CONSTR, SPEC_INS_CONSTR,
    SPEC_NOT_INS_CONSTR, SPEC_INVALID_INS_COMBO,
    SPEC_MEM_CONFIG_KB, SPEC_MEM_CONFIG_MB,
    SPEC_INCLUDE, SPEC_INSERTBLOCK, SPEC_IGNOREBLOCK
}   SPECIAL ;



//  what value type does the parser expect after each keyword?

typedef  enum
{
    NO_VALUE ,  //  a linebreak OR  an effective linebreak:   ({)  or comment
        //  or optional value.
    VALUE_INTEGER,  //   integer
    VALUE_POINT,  //   point
    VALUE_RECT,  //   rectangle
    //  VALUE_BOOLEAN,  //   a subset of constants.
    VALUE_QUALIFIED_NAME,  //   Qualified name (two symbols separated by .
    VALUE_QUALIFIED_NAME_EX,  //    QualifiedName followed
                           //    by   an unsigned integer  with a  .  delimiter.
    VALUE_PARTIALLY_QUALIFIED_NAME ,  //  (just one symbol or two symbols
                        //  separated  by .)
    VALUE_CONSTRAINT,  //  list of qualified names but stored differently.
    VALUE_ORDERDEPENDENCY,
    VALUE_FONTSUB,   // "fontname" : <int>
//    VALUE_STRING,  //  Quoted String, hexstring, string MACROREF,
        //  parameterless invocation.
    VALUE_STRING_NO_CONVERT,  // string will not undergo unicode conversion
            // for example *GPDSpecVersion must remain an ascii string.
    VALUE_STRING_DEF_CONVERT,  //  string will be converted using the
                                //  system codepage  - filenames
    VALUE_STRING_CP_CONVERT,  // string will be converted using the
        // codepage specified by *CodePage

    VALUE_COMMAND_INVOC,  //   like VALUE_STRING but allowed to contain
        //  one or more parameter references.
    VALUE_COMMAND_SHORTCUT,  // Commandname:VALUE_COMMAND_INVOC
    VALUE_PARAMETER,  //  substring only containing a parameter reference.
    VALUE_SYMBOL_DEF,  //   * the value defines a symbol or value macro
        // { and } are not permitted.   Is this ever used ? yes

    VALUE_SYMBOL_FIRST,  //     base of user-defined symbol catagory
    VALUE_SYMBOL_FEATURES = VALUE_SYMBOL_FIRST + SCL_FEATURES ,  //
    VALUE_SYMBOL_FONTCART = VALUE_SYMBOL_FIRST + SCL_FONTCART ,  //
    VALUE_SYMBOL_TTFONTNAMES = VALUE_SYMBOL_FIRST + SCL_TTFONTNAMES ,  //
    VALUE_SYMBOL_BLOCKMACRO = VALUE_SYMBOL_FIRST + SCL_BLOCKMACRO ,  //
    VALUE_SYMBOL_VALUEMACRO = VALUE_SYMBOL_FIRST + SCL_VALUEMACRO ,  //
    VALUE_SYMBOL_OPTIONS = VALUE_SYMBOL_FIRST + SCL_OPTIONS ,  //
    //  SCL_COMMANDNAMES  intentionally omitted.
    VALUE_SYMBOL_LAST = VALUE_SYMBOL_FIRST + SCL_NUMSYMCLASSES - 1 ,  //

    VALUE_CONSTANT_FIRST,  //    base of enumeration catagory.
    VALUE_CONSTANT_BOOLEANTYPE = VALUE_CONSTANT_FIRST + CL_BOOLEANTYPE ,
    VALUE_CONSTANT_PRINTERTYPE = VALUE_CONSTANT_FIRST + CL_PRINTERTYPE ,
    VALUE_CONSTANT_FEATURETYPE = VALUE_CONSTANT_FIRST + CL_FEATURETYPE ,
    VALUE_CONSTANT_UITYPE = VALUE_CONSTANT_FIRST + CL_UITYPE ,
    VALUE_CONSTANT_PROMPTTIME = VALUE_CONSTANT_FIRST + CL_PROMPTTIME ,
    VALUE_CONSTANT_PAPERFEED_ORIENT = VALUE_CONSTANT_FIRST + CL_PAPERFEED_ORIENT ,
    VALUE_CONSTANT_COLORPLANE = VALUE_CONSTANT_FIRST + CL_COLORPLANE ,
    VALUE_CONSTANT_SEQSECTION = VALUE_CONSTANT_FIRST + CL_SEQSECTION ,

    VALUE_CONSTANT_RASTERCAPS = VALUE_CONSTANT_FIRST + CL_RASTERCAPS ,
    VALUE_CONSTANT_TEXTCAPS = VALUE_CONSTANT_FIRST + CL_TEXTCAPS ,
    VALUE_CONSTANT_MEMORYUSAGE = VALUE_CONSTANT_FIRST + CL_MEMORYUSAGE ,
    VALUE_CONSTANT_RESELECTFONT = VALUE_CONSTANT_FIRST + CL_RESELECTFONT ,
    VALUE_CONSTANT_OEMPRINTINGCALLBACKS = VALUE_CONSTANT_FIRST + CL_OEMPRINTINGCALLBACKS ,

    VALUE_CONSTANT_CURSORXAFTERCR = VALUE_CONSTANT_FIRST + CL_CURSORXAFTERCR ,
    VALUE_CONSTANT_BADCURSORMOVEINGRXMODE = VALUE_CONSTANT_FIRST + CL_BADCURSORMOVEINGRXMODE ,
//    VALUE_CONSTANT_SIMULATEXMOVE = VALUE_CONSTANT_FIRST + CL_SIMULATEXMOVE ,
    VALUE_CONSTANT_PALETTESCOPE = VALUE_CONSTANT_FIRST + CL_PALETTESCOPE ,
    VALUE_CONSTANT_OUTPUTDATAFORMAT = VALUE_CONSTANT_FIRST + CL_OUTPUTDATAFORMAT ,
    VALUE_CONSTANT_STRIPBLANKS = VALUE_CONSTANT_FIRST + CL_STRIPBLANKS ,
    VALUE_CONSTANT_LANDSCAPEGRXROTATION = VALUE_CONSTANT_FIRST + CL_LANDSCAPEGRXROTATION ,
    VALUE_CONSTANT_CURSORXAFTERSENDBLOCKDATA = VALUE_CONSTANT_FIRST + CL_CURSORXAFTERSENDBLOCKDATA ,
    VALUE_CONSTANT_CURSORYAFTERSENDBLOCKDATA = VALUE_CONSTANT_FIRST + CL_CURSORYAFTERSENDBLOCKDATA ,
    VALUE_CONSTANT_CHARPOSITION = VALUE_CONSTANT_FIRST + CL_CHARPOSITION ,
    VALUE_CONSTANT_FONTFORMAT = VALUE_CONSTANT_FIRST + CL_FONTFORMAT ,
    VALUE_CONSTANT_QUERYDATATYPE = VALUE_CONSTANT_FIRST + CL_QUERYDATATYPE ,
    VALUE_CONSTANT_YMOVEATTRIB = VALUE_CONSTANT_FIRST + CL_YMOVEATTRIB ,
    VALUE_CONSTANT_DLSYMBOLSET = VALUE_CONSTANT_FIRST + CL_DLSYMBOLSET ,
    VALUE_CONSTANT_CURXAFTER_RECTFILL = VALUE_CONSTANT_FIRST + CL_CURXAFTER_RECTFILL ,
    VALUE_CONSTANT_CURYAFTER_RECTFILL = VALUE_CONSTANT_FIRST + CL_CURYAFTER_RECTFILL ,
    #ifndef WINNT_40
    VALUE_CONSTANT_PRINTRATEUNIT = VALUE_CONSTANT_FIRST + CL_PRINTRATEUNIT ,
    #endif
    VALUE_CONSTANT_RASTERMODE = VALUE_CONSTANT_FIRST + CL_RASTERMODE,
    VALUE_CONSTANT_QUALITYSETTING = VALUE_CONSTANT_FIRST + CL_QUALITYSETTING,



    VALUE_CONSTANT_STANDARD_VARS = VALUE_CONSTANT_FIRST + CL_STANDARD_VARS ,
    VALUE_CONSTANT_COMMAND_NAMES = VALUE_CONSTANT_FIRST + CL_COMMAND_NAMES ,

    VALUE_CONSTANT_CONS_FEATURES = VALUE_CONSTANT_FIRST + CL_CONS_FEATURES ,
    VALUE_CONSTANT_CONS_PAPERSIZE = VALUE_CONSTANT_FIRST + CL_CONS_PAPERSIZE ,
    VALUE_CONSTANT_CONS_MEDIATYPE = VALUE_CONSTANT_FIRST + CL_CONS_MEDIATYPE ,
    VALUE_CONSTANT_CONS_INPUTSLOT = VALUE_CONSTANT_FIRST + CL_CONS_INPUTSLOT ,
    VALUE_CONSTANT_CONS_DUPLEX = VALUE_CONSTANT_FIRST + CL_CONS_DUPLEX ,
    VALUE_CONSTANT_CONS_ORIENTATION = VALUE_CONSTANT_FIRST + CL_CONS_ORIENTATION ,
    VALUE_CONSTANT_CONS_PAGEPROTECT = VALUE_CONSTANT_FIRST + CL_CONS_PAGEPROTECT ,
    VALUE_CONSTANT_CONS_COLLATE = VALUE_CONSTANT_FIRST + CL_CONS_COLLATE ,
    VALUE_CONSTANT_CONS_HALFTONE = VALUE_CONSTANT_FIRST + CL_CONS_HALFTONE ,

    VALUE_CONSTANT_LAST = VALUE_CONSTANT_FIRST + CL_NUMCLASSES - 1 ,

    VALUE_LIST,  //    no attribute actually is assigned this descriptor,
        // but used in the gValueToSize table.
    VALUE_LARGEST,  //   not a real descriptor, but this position in the
        //  gValueToSize table  holds the largest of the above values.
    VALUE_MAX, //  number of elements in gValueToSize table.
}  VALUE ;

//  --  allowed values for KEYWORDTABLE_ENTRY.flAgs:  --


#define   KWF_LIST  (0x00000001)
    //  the value may be a LIST containing one or more
    //  items of type AllowedValue.  The storage format
    //  must be of type LIST.  Only certain values may qualify
    //  for list format.
#define   KWF_ADDITIVE  (0x00000002)
    //  this flag implies KWF_LIST and also specifies the behavior
    //  that any redefinition of this keyword simply adds its items
    //  onto the existing list. (removal of redundant items is not
    //  performed.)
#define   KWF_MACROREF_ALLOWED  (0x00000004)
    //   since only a handful of keywords cannot accept
    //  macro references, it may be a waste of a flag, but reserve this
    //  to alert us that this special case must accounted for.
#define   KWF_SHORTCUT  (0x00000008)
    //    This keyword has multiple variants of syntax.

    //  one of the following 3 flags is set
    //  if the values in the nodes of the attribute tree
    //  refer to indicies of dedicated arrays, (which obviously
    //  contain data fields not ATREEREFs) AND
    //  gMainKeywordTable[].dwOffset  is an offset into
    //  this dedicated array, then set this flag.
    //  else dwOffset is used to select the treeroot.

#define   KWF_COMMAND       (0x00000010)
    //    This attribute is stored in a dedicated structure
#define   KWF_FONTCART      (0x00000020)
    //    This attribute is stored in a dedicated structure
#define   KWF_OEM           (0x00000040)
    //    This attribute is stored in a dedicated structure
#define   KWF_TTFONTSUBS    (0x00000080)
    //    This attribute is stored in a dedicated structure


#define   KWF_DEDICATED_FIELD   (KWF_COMMAND | KWF_FONTCART | \
            KWF_OEM | KWF_TTFONTSUBS)
    //  this flag is never set in the MainKeywordTable[].

#define   KWF_REQUIRED    (0x00000100)
    //  this keyword must appear in the GPD file

#ifdef  GMACROS
#define   KWF_CHAIN    (0x00000200)
    //  if more than one entry exists for a given treenode,
    //  subsequent entries are chained onto the first
    //  creating a parent list which holds in its values
    //  the actual inhabitants of the treenode.
#endif

//  The mainKeyword Table is an array of structures of the form:

typedef  struct
{
    PSTR        pstrKeyword ;  // keywordID is the index of this entry.
    DWORD       dwHashValue ;  // optional - implement as time permits.
    VALUE       eAllowedValue ;
    DWORD       flAgs ;
    KEYWORD_TYPE    eType;   // may replace Type/Subtype with a function
    DWORD       dwSubType ;  // if there is minimal code duplication.
    DWORD       dwOffset ;  //  into appropriate struct for attributes only.
    //  the size   (num bytes to copy) of an attribute is easily determined
    //   from the AllowedValue field.
} KEYWORDTABLE_ENTRY, * PKEYWORDTABLE_ENTRY;





// ----  End of MainKeyword table Section ---- //

// ----  MainKeyword Dictionary Section ---- //

/*  note the MainKeywordTable is subdivided into sections
with each section terminated by a NULL pstrKeyword.
this enumerates the sections.  The MTI_RNGDICTIONARY
provides the starting and ending indicies of the
the Keyword entries which each section spans.  */

typedef  enum {NON_ATTR, GLOBAL_ATTR, FEATURE_ATTR,
OPTION_ATTR, COMMAND_ATTR, FONTCART_ATTR, TTFONTSUBS_ATTR,
OEM_ATTR , END_ATTR
} KEYWORD_SECTS ;


typedef  struct
{
    DWORD  dwStart  ;  // index of first keyword in this section
    DWORD  dwEnd    ;
}  RANGE,  *PRANGE  ;   // tag shall be rng

// ----  End of MainKeyword Dictionary Section ---- //


// ----  Attribute Trees Section ---- //

/*  an Attribute Tree is comprised of a set of ATTRIB_TREE
    nodes linked together.  The root of the tree (the first node)
    may be a global default initializer.  */

typedef  enum
{
    NEXT_FEATURE,  // offset field contain index to another node
    VALUE_AT_HEAP,          //  offset is a heap offset
    UNINITIALIZED   //  offset has no meaning yet. (a transient state)
} ATTOFFMEANS ;

#define  DEFAULT_INIT  (0xffffffff)
    //  Warning!  this value may be truncated to WORD to
    //  fit into a qualified name!
//  #define  END_OF_LIST   (0xffffffff)
//  moved to gpd.h
    // may used where a node index is expected

typedef  struct
{
    DWORD   dwFeature ;  //  may also be set to DEFAULT_INIT
    DWORD   dwOption  ;  //  DEFAULT_INIT indicates this if set
    DWORD   dwNext    ;  // index to another node or END_OF_LIST
    DWORD   dwOffset  ;  // either offset in heap to value
                        //  or index to node containing another feature.
    ATTOFFMEANS  eOffsetMeans ;
}  ATTRIB_TREE,  * PATTRIB_TREE ;
//  the prefix tag shall be 'att'




//  these flags are used with ATREEREFS, this complication exists
//    because of the overloading of ATREEREFS.

#define  ATTRIB_HEAP_VALUE     (0x80000000)
    //  high bit set to indicate this value is an offset into
    //  the heap.
#define  ATTRIB_UNINITIALIZED  (ATTRIB_HEAP_VALUE - 1)
    //  this value indicates no memory location has been allocated
    //  to hold the value for this attribute.


typedef  DWORD  ATREEREF ;  //  hold the index to attribute array
//  that is the root of an attribute tree or if high bit is set
//  is an offset to the heap where the actual value lies.
//
//  the prefix tag shall be 'atr'
typedef  PDWORD  PATREEREF ;


// ----  End of Attribute Trees Section ---- //


// ----  UI Constraints Section ---- //

// slightly different from that defined in parser.h

typedef struct
{
    DWORD   dwNextCnstrnt ;
    DWORD   dwFeature ;
    DWORD   dwOption ;
}
CONSTRAINTS, *  PCONSTRAINTS ;
//  the prefix tag shall be 'cnstr'


// ----  End of UI Constraints Section ---- //

// ----  InvalidCombo Section ---- //
//  R.I.P. - moved to parser.h
//  typedef  struct
//  {
//      DWORD   dwFeature ;     //  the INVALIDCOMBO construct defines
//      DWORD   dwOption ;      //  a set of elements subject to the constraint
//      DWORD   dwNextElement ;  // that all elements of the set  cannot be
//      DWORD   dwNewCombo ;     // selected at the same time.
//  }
//  INVALIDCOMBO , * PINVALIDCOMBO ;
//  the prefix tag shall be 'invc'

//  Note:  both dwNextElement and dwNewCombo are terminated by END_OF_LIST.

// ----  End of InvalidCombo Section ---- //


// store timestamp of GPD files and included files here.

typedef struct _GPDFILEDATEINFO {

    ARRAYREF        arFileName;
    FILETIME        FileTime;

} GPDFILEDATEINFO, *PGPDFILEDATEINFO;


// ----  State Machine Section ---- //

/*  the state machine is used to define different parsing contexts
introduced by the construct keywords.  Each state recognizes a different
set of Construct and Attribute Keywords.  The 2 dimensional matricies
AllowedTransitions and AllowedAttributes define these.  The states
are nested, so a stack is a good way to track the complete state
of the system.  Each state is introduced by a construct keyword
with its optional symbol value which is stored in the stack for
subsequent use.   */

typedef  enum
{
    STATE_ROOT,
    STATE_UIGROUP,
    STATE_FEATURE,
    STATE_OPTIONS,
    STATE_SWITCH_ROOT,
    STATE_SWITCH_FEATURE,
    STATE_SWITCH_OPTION,
    STATE_CASE_ROOT,
    STATE_DEFAULT_ROOT,
    STATE_CASE_FEATURE,
    STATE_DEFAULT_FEATURE,
    STATE_CASE_OPTION,
    STATE_DEFAULT_OPTION,
    STATE_COMMAND,
    STATE_FONTCART,
    STATE_TTFONTSUBS,
    STATE_OEM,
    //  any other passive construct
    STATE_LAST,   //  must terminate list of valid states
    STATE_INVALID  //  must be after STATE_LAST
} STATE, * PSTATE ;   //  the prefix tag shall be 'st'


extern  CONST PBYTE   gpubStateNames[] ;

//  note if STATE enum changes, update the global gpubStateNames[]


typedef  struct
{
    STATE   stState ;
    DWORD   dwSymbolID ;
}  STSENTRY , * PSTSENTRY; //  StateStackEntry  the prefix tag shall be 'sts'


//  The AllowedTransitions Table determines/defines
//  the state changes produced by each construct keyword
//  Each entry in the table is a NewState and is indexed
//  by the OldState and a ConstructKeyword

// extern  STATE   gastAllowedTransitions[STATE_LAST][CONSTRUCT_LAST] ;
// This is now in GLOBL structure

//  the AllowedAttributes table defines which attributes are
//  allowed in each state.

//  extern  BOOL   gabAllowedAttributes[STATE_LAST][ATT_LAST] ;
// This is now in GLOBL structure


//  state of token parser (not to be confused with
//  state machine defined above.)
typedef   enum
{
    PARST_EXIT, PARST_EOF,  PARST_KEYWORD, PARST_COLON,
    PARST_VALUE,  PARST_INCLUDEFILE, PARST_ABORT
}  PARSTATE  ;  //  tag shall be  'parst'



// ----  End of State Machine Section ---- //


// ----  Value Structures Section ---- //

/*  the values from the attribute keywords are stored
in various structures.   Typically there is one type of
structure for each construct  and one instance of
a structure for each unique Symbol name.  The SymbolID
is normally used to index the instance of the structure
within the array of structures.   */





#if TODEL
typedef  struct
{
    ARRAYREF    arTTFontName ;
    ARRAYREF    arDevFontName ;
} TTFONTSUBTABLE, *PTTFONTSUBTABLE ;
//  tag  'ttft'


//
// Data structure used to represent the format of loOffset when indicating resource Ids
//

typedef  struct
{
    WORD    wResourceID ;   // ResourceID
    BYTE    bFeatureID ;    // Feature index for the resource DLL feature.
                            // If zero, we will use the name specified
                            // in ResourceDLL
    BYTE    bOptionID ;     // Option index for the qualified resource dll name.
}  QUALNAMEEX, * PQUALNAMEEX  ;



typedef  struct
{
    DWORD   dwRCCartNameID ;
    ARRAYREF   strCartName ;
    DWORD   dwFontLst ;  // Index to list of FontIDs
    DWORD   dwPortFontLst ;
    DWORD   dwLandFontLst ;
} FONTCART , * PFONTCART ;  // the prefix tag shall be  'fc'
#endif




typedef  struct   // for ease of processing shall contain only ATREEREFs
{
    ATREEREF     atrGPDSpecVersion ;    // "GPDSpecVersion"
    ATREEREF     atrMasterUnits ;       // "MasterUnits"
    ATREEREF     atrModelName ;         // "ModelName"
    ATREEREF     atrModelNameID ;         // "rcModelNameID"
    ATREEREF     atrGPDFileVersion ;         // "GPDFileVersion"
    ATREEREF     atrGPDFileName ;         // "GPDFileName"
    ATREEREF     atrOEMCustomData ;         // "OEMCustomData"

    //  next four fields used by Synthesized Features
    ATREEREF     atrNameInstalled ;         // "OptionNameInstalled"
    ATREEREF     atrNameIDInstalled ;         // "rcOptionNameInstalledID"

    ATREEREF     atrNameNotInstalled ;         // "OptionNameNotInstalled"
    ATREEREF     atrNameIDNotInstalled ;         // "rcOptionNameNotInstalledID"

    //   support for common UI macro controls

    ATREEREF     atrDraftQualitySettings;          // "DraftQualitySettings"
    ATREEREF     atrBetterQualitySettings;          // "BetterQualitySettings"
    ATREEREF     atrBestQualitySettings;          // "BestQualitySettings"
    ATREEREF     atrDefaultQuality ;                  //  "DefaultQuality"


    ATREEREF     atrPrinterType ;       // "PrinterType"
    ATREEREF     atrPersonality ;       // "Personality"
    ATREEREF     atrRcPersonalityID ;       // "rcPersonalityID"
//    ATREEREF     atrIncludeFiles;      // "Include"
    ATREEREF     atrResourceDLL;       // "ResourceDLL"
    ATREEREF     atrCodePage;           //   "CodePage"
    ATREEREF     atrMaxCopies;            // "MaxCopies"
    ATREEREF     atrFontCartSlots;        // "FontCartSlots"
    ATREEREF     atrPrinterIcon;       // "rcPrinterIconID"
    ATREEREF     atrHelpFile;       // "HelpFile"

    //  obsolete?
    ATREEREF     atrOutputDataFormat;     // "OutputDataFormat"
    ATREEREF     atrMaxPrintableArea;     // "MaxPrintableArea"

    //
    // Printer Capabilities related information
    //

    ATREEREF     atrRotateCoordinate;       // "RotateCoordinate?"
    ATREEREF     atrRasterCaps;       // "RasterCaps"
    ATREEREF     atrRotateRasterData;       // "RotateRaster?"
    ATREEREF     atrTextCaps;       // "TextCaps"
    ATREEREF     atrRotateFont;       // "RotateFont?"
    ATREEREF     atrMemoryUsage;       // "MemoryUsage"
    ATREEREF     atrReselectFont;       // "ReselectFont"
    ATREEREF     atrPrintRate;       // "PrintRate"
    ATREEREF     atrPrintRateUnit;       // "PrintRateUnit"
    ATREEREF     atrPrintRatePPM;       // "PrintRatePPM"
    ATREEREF     atrOutputOrderReversed;  //   "OutputOrderReversed?"
             // may change per snapshot.
    ATREEREF     atrReverseBandOrderForEvenPages;  //   "ReverseBandOrderForEvenPages?"
    ATREEREF     atrOEMPrintingCallbacks;       // "OEMPrintingCallbacks"
//    ATREEREF     atrDisabledFeatures ;  // "*DisabledFeatures"


    //
    // Cursor Control related information
    //

    ATREEREF     atrCursorXAfterCR;       // "CursorXAfterCR"
    ATREEREF     atrBadCursorMoveInGrxMode; // "BadCursorMoveInGrxMode"
    ATREEREF     atrSimulateXMove;        // "SimulateXMove"
    ATREEREF     atrEjectPageWithFF;       // "EjectPageWithFF?"
    ATREEREF     atrLookaheadRegion;       // "LookaheadRegion"
    ATREEREF     atrYMoveAttributes ;       // "YMoveAttributes"
    ATREEREF     atrMaxLineSpacing ;       // "MaxLineSpacing"
    ATREEREF     atrbUseSpaceForXMove ;     // "UseSpaceForXMove?"
    ATREEREF     atrbAbsXMovesRightOnly ;     // "AbsXMovesRightOnly?"


    ATREEREF     atrXMoveThreshold;        // "XMoveThreshold"
    ATREEREF     atrYMoveThreshold;        // "YMoveThreshold"
    ATREEREF     atrXMoveUnits;        // "XMoveUnits"
    ATREEREF     atrYMoveUnits;        // "YMoveUnits"
    ATREEREF     atrLineSpacingMoveUnit;        // "LineSpacingMoveUnit"

    //
    // Color related information
    //

    ATREEREF     atrChangeColorMode;       // "ChangeColorModeOnPage?"
    ATREEREF     atrChangeColorModeDoc;       // "ChangeColorModeOnDoc?"
    ATREEREF     atrMagentaInCyanDye;       // "MagentaInCyanDye"
    ATREEREF     atrYellowInCyanDye;       // "YellowInCyanDye"
    ATREEREF     atrCyanInMagentaDye;       // "CyanInMagentaDye"
    ATREEREF     atrYellowInMagentaDye;       // "YellowInMagentaDye"
    ATREEREF     atrCyanInYellowDye;       // "CyanInYellowDye"
    ATREEREF     atrMagentaInYellowDye;       // "MagentaInYellowDye"
    ATREEREF     atrUseColorSelectCmd;     // "UseExpColorSelectCmd?"
    ATREEREF     atrMoveToX0BeforeColor;   // "MoveToX0BeforeSetColor?"
    ATREEREF     atrEnableGDIColorMapping;   // "EnableGDIColorMapping?"


    // obsolete fields
    ATREEREF     atrMaxNumPalettes;        // "MaxNumPalettes"
//    ATREEREF     atrPaletteSizes;           // "PaletteSizes"
//    ATREEREF     atrPaletteScope;           // "PaletteScope"

    //
    // Overlay related information
    //

    ATREEREF     atrMinOverlayID;          // "MinOverlayID"
    ATREEREF     atrMaxOverlayID;          // "MaxOverlayID"

    //
    // Raster data related information
    //

    ATREEREF     atrOptimizeLeftBound;  //   "OptimizeLeftBound?"
    ATREEREF     atrStripBlanks;  //   "StripBlanks"
    ATREEREF     atrLandscapeGrxRotation;  //   "LandscapeGrxRotation"
    ATREEREF     atrRasterZeroFill;  //   "RasterZeroFill?"
    ATREEREF     atrRasterSendAllData;  //   "RasterSendAllData?"
    ATREEREF     atrSendMultipleRows;  //   "SendMultipleRows?"
    ATREEREF     atrMaxMultipleRowBytes;  //   "MaxMultipleRowBytes"
    ATREEREF     atrCursorXAfterSendBlockData;  //   "CursorXAfterSendBlockData"
    ATREEREF     atrCursorYAfterSendBlockData;  //   "CursorYAfterSendBlockData"
    ATREEREF     atrMirrorRasterByte;  //   "MirrorRasterByte?"
    ATREEREF     atrMirrorRasterPage;  //   "MirrorRasterPage?"

    //
    // Device Font related information
    //

    ATREEREF     atrDeviceFontsList ;   //  "DeviceFonts"
    ATREEREF     atrDefaultFont;  //   "DefaultFont"
    ATREEREF     atrTTFSEnabled ;  //   "TTFSEnabled?"
    ATREEREF     atrRestoreDefaultFont;  //   "RestoreDefaultFont?"
    ATREEREF     atrDefaultCTT;  //   "DefaultCTT"
    ATREEREF     atrMaxFontUsePerPage;  //   "MaxFontUsePerPage"
    ATREEREF     atrTextYOffset;  //   "TextYOffset"
    ATREEREF     atrCharPosition;  //   "CharPosition"
    ATREEREF     atrDiffFontsPerByteMode;  //   "DiffFontsPerByteMode?"

    //
    // Font Downloading related information
    //

    ATREEREF     atrMinFontID;  //   "MinFontID"
    ATREEREF     atrMaxFontID;  //   "MaxFontID"
    ATREEREF     atrMaxNumDownFonts;  //   "MaxNumDownFonts"
    ATREEREF     atrMinGlyphID;  //   "MinGlyphID"
    ATREEREF     atrMaxGlyphID;  //   "MaxGlyphID"
    ATREEREF     atrDLSymbolSet;  //   "DLSymbolSet"
    ATREEREF     atrIncrementalDownload;  //   "IncrementalDownload?"
    ATREEREF     atrFontFormat;  //   "FontFormat"
    ATREEREF     atrMemoryForFontsOnly;  //   "MemoryForFontsOnly?"

    //
    //  Rect Fill related information
    //

    ATREEREF     atrCursorXAfterRectFill;  //   "CursorXAfterRectFill"
    ATREEREF     atrCursorYAfterRectFill;  //   "CursorYAfterRectFill"
    ATREEREF     atrMinGrayFill;  //   "MinGrayFill"
    ATREEREF     atrMaxGrayFill;  //   "MaxGrayFill"
    ATREEREF     atrTextHalftoneThreshold;  //   "TextHalftoneThreshold"


    //  Internal Parser Use Only

    ATREEREF     atrInvldInstallCombo ;  //  holds all InvalidCombos
        // involving synthesized features.
    ATREEREF     atrLetterSizeExists ;
    ATREEREF     atrA4SizeExists ;

//    ATREEREF     atr;  //   ""  prototype

}  GLOBALATTRIB, * PGLOBALATTRIB ;  // the prefix tag shall be 'ga'


//  warning:  any non-attribtreeref added to
//  the GLOBALATTRIB structure will get stomped on in strange
//  ways by BinitPreAllocatedObjects.


//  note:  some fields in the snapshot won't be initialized.
//  they include orderdependencies and constraints.  The
//  helper functions will do all the grovelling.

//  there are two classes of fields in the FeatureOption structure,
//  those initialized by a corresponding field in the GPD file
//  and those the parser initializes at postprocessing time.
//  These fields have no associated GPD keyword.

//  For the fields that are keyword initialized, note also
//  the keyword may be a Feature attribute only, an Option attribute
//  only or both a Feature and Option attribute.

typedef  struct
{
    // -- Feature Level -- //

    ATREEREF     atrFeatureType;  //   "FeatureType"
    ATREEREF     atrUIType;  //   "UIType"  PickMany or PickOne?
    ATREEREF     atrDefaultOption;  //   "DefaultOption"
    ATREEREF     atrPriority ;
    ATREEREF     atrFeaInstallable;  //   "Installable?"
    ATREEREF     atrInstallableFeaDisplayName;   //  "InstallableFeatureName"
    ATREEREF     atrInstallableFeaRcNameID; //  "rcInstallableFeatureNameID"
    //  above 3 fields not used by snapshot.

    ATREEREF     atrFeaKeyWord ;   // symbol name
    ATREEREF     atrFeaDisplayName ;   //  "Name"
    ATREEREF     atrFeaRcNameID;  //   "rcNameID"
    ATREEREF     atrFeaRcIconID;  //   "rcIconID"
    ATREEREF     atrFeaRcHelpTextID;  //   "rcHelpTextID"
    ATREEREF     atrFeaRcPromptMsgID;  //   "rcPromptMsgID"
    ATREEREF     atrFeaRcPromptTime;  //   "rcPromptTime"
    ATREEREF     atrConcealFromUI; //   "ConcealFromUI?"
    ATREEREF     atrUpdateQualityMacro; //   "UpdateQualityMacro?"
    ATREEREF     atrFeaHelpIndex;  //   "HelpIndex"

    // Bi-Di Query related information

    ATREEREF     atrQueryOptionList;  //   "QueryOptionList"
    ATREEREF     atrQueryDataType;  //   "QueryDataType"
    ATREEREF     atrQueryDefaultOption;  //   "QueryDefaultOption"

    // scaffolding until Installable Features are synthesized.
//    ATREEREF     atrFeaInvldInstallCombo ;  //  // referenced from
                        //  "InvalidInstallableCombination"
    ATREEREF     atrFeaInstallConstraints ; //  "InstalledConstraints"
    ATREEREF     atrFeaNotInstallConstraints ;  // "NotInstalledConstraints"



    // -- Option Level -- //

    ATREEREF     atrOptInstallable;  //   "Installable?"
    ATREEREF     atrInstallableOptDisplayName ;   //  "InstallableFeatureName"
    ATREEREF     atrInstallableOptRcNameID; //  "rcInstallableFeatureNameID"
    //  above 3 fields not used by snapshot.

    ATREEREF     atrOptKeyWord ;   // symbol name
    ATREEREF     atrOptDisplayName ;   //  "Name"
    ATREEREF     atrOptRcNameID;  //   "rcNameID"
    ATREEREF     atrOptRcIconID;  //   "rcIconID"
    ATREEREF     atrOptRcHelpTextID;  //   "rcHelpTextID"
    ATREEREF     atrOptHelpIndex;  //   "HelpIndex"
    ATREEREF     atrOptRcPromptMsgID;  //   "rcPromptMsgID"
    ATREEREF     atrOptRcPromptTime;  //   "rcPromptTime"
    ATREEREF     atrCommandIndex ;
    //  these 2 fields are the only permanent types of constraints
    ATREEREF     atrConstraints ;
    ATREEREF     atrInvalidCombos ; // referenced from "InvalidCombination"
    //  all of these serve as scaffolding till the Installable
    //  features are synthesized!
//    ATREEREF     atrOptInvldInstallCombo ;  //  // referenced from
                        //  "InvalidInstallableCombination"
    ATREEREF     atrOptInstallConstraints ; //  "InstalledConstraints"
    ATREEREF     atrOptNotInstallConstraints ; //  "NotInstalledConstraints"
    ATREEREF     atrDisabledFeatures ;  // "*DisabledFeatures"

#ifdef  GMACROS

    ATREEREF     atrDependentSettings ;  // "*DependentSettings"
    ATREEREF     atrUIChangeTriggersMacro ;  // "*UIChangeTriggersMacro"

#endif

    //  -- Option specific fields -- //
    //  -- PaperSize option specific fields -- //

    ATREEREF     atrPrintableSize;  //   "PrintableSize"
    ATREEREF     atrPrintableOrigin;  //   "PrintableOrigin"
    ATREEREF     atrCursorOrigin;  //   "CursorOrigin"
    ATREEREF     atrVectorOffset;  //   "VectorOffset"
    ATREEREF     atrMinSize;  //   "MinSize"
    ATREEREF     atrMaxSize;  //   "MaxSize"
    ATREEREF     atrTopMargin;         // "TopMargin"
    ATREEREF     atrBottomMargin;         // "BottomMargin"
    ATREEREF     atrMaxPrintableWidth;     // "MaxPrintableWidth"
    ATREEREF     atrMinLeftMargin;         // "MinLeftMargin"
    ATREEREF     atrCenterPrintable;       // "CenterPrintable?"
    ATREEREF     atrPageDimensions;  //   "PageDimensions"
    ATREEREF     atrRotateSize;  //   "RotateSize?"
    ATREEREF     atrPortRotationAngle;  //   "PortRotationAngle"
    ATREEREF     atrPageProtectMem;  //   "PageProtectMem"

    ATREEREF     atrCustCursorOriginX ;  //  "CustCursorOriginX"
    ATREEREF     atrCustCursorOriginY ;  //  "CustCursorOriginY"
    ATREEREF     atrCustPrintableOriginX ;  //  "CustPrintableOriginX"
    ATREEREF     atrCustPrintableOriginY ;  //  "CustPrintableOriginY"
    ATREEREF     atrCustPrintableSizeX;  //   "CustPrintableSizeX"
    ATREEREF     atrCustPrintableSizeY;  //   "CustPrintableSizeY"


    //  -- InputBin option specific fields -- //

    ATREEREF     atrFeedMargins;  //   "FeedMargins"
    ATREEREF     atrPaperFeed;  //   "PaperFeed"

    //  -- OutputBin option specific fields -- //


    //  -- Resolution option specific fields -- //

    ATREEREF     atrDPI;  //   "DPI"
    ATREEREF     atrSpotDiameter;  //   "SpotDiameter"
    ATREEREF     atrTextDPI;  //   "TextDPI"
    ATREEREF     atrPinsPerPhysPass;  //   "PinsPerPhysPass"
    ATREEREF     atrPinsPerLogPass;  //   "PinsPerLogPass"
    ATREEREF     atrRequireUniDir;  //   "RequireUniDir?"
    ATREEREF     atrMinStripBlankPixels;  //   "MinStripBlankPixels"
    ATREEREF     atrRedDeviceGamma ;   // "RedDeviceGamma"
    ATREEREF     atrGreenDeviceGamma ;   // "GreenDeviceGamma"
    ATREEREF     atrBlueDeviceGamma ;   // "BlueDeviceGamma"

    //  -- ColorMode option specific fields -- //

    ATREEREF     atrColor;  //   "Color?"
    ATREEREF     atrDevNumOfPlanes;  //   "DevNumOfPlanes"
    ATREEREF     atrDevBPP;  //   "DevBPP"
    ATREEREF     atrColorPlaneOrder;  //   "ColorPlaneOrder"
    ATREEREF     atrDrvBPP;  //   "DrvBPP"
    ATREEREF     atrIPCallbackID;  //   "IPCallbackID"
    ATREEREF     atrColorSeparation;  //   "ColorSeparation?"

    ATREEREF     atrRasterMode;  //   "RasterMode"
    ATREEREF     atrPaletteSize;  //   "PaletteSize"
    ATREEREF     atrPaletteProgrammable;  //   "PaletteProgrammable?"

    //  -- Memory option specific fields -- //

    ATREEREF     atrMemoryConfigKB;  //   "MemoryConfigKB"
    ATREEREF     atrMemoryConfigMB;  //   "MemoryConfigMB"

    //  -- Halftone option specific fields -- //

    ATREEREF     atrRcHTPatternID;  //   "rcHTPatternID"
    ATREEREF     atrHTPatternSize;  //   "HTPatternSize"
    ATREEREF     atrHTNumPatterns;  //   "HTNumPatterns"
    ATREEREF     atrHTCallbackID;  //   "HTCallbackID"
    ATREEREF     atrLuminance;  //   "Luminance"

    //  --  OUTPUTBIN  option specific fields -- //

    ATREEREF     atrOutputOrderReversed ;  //  *OutputOrderReversed? (option level)

    //  -- fields synthesized at Post Processing time --  //

//    ATREEREF     atrGIDvalue;  //   GID value
    ATREEREF     atrOptIDvalue;  //   ID value

    ATREEREF     atrFeaFlags ;  //  invalid or not

    //  If this option is installable, this points to the index of the
    //  resulting synthesized feature.
    ATREEREF     atrOptionSpawnsFeature ;  // must support an attrib tree.


    //  warning:  any non-attribtreeref added to
    //  the DFEATURE_OPTIONS structure will get stomped on in strange
    //  and wonderful ways by BinitPreAllocatedObjects.

    //  if this is a synthesized feature:
    DWORD       dwInstallableFeatureIndex ; //  backlink to Feature/Option
    DWORD       dwInstallableOptionIndex ;  //  that prompted this feature.

    //  If this feature is installable, this points to the index of the
    //  resulting synthesized feature.
    DWORD       dwFeatureSpawnsFeature ;




    //  internal consistency checks.
    BOOL        bReferenced ;  // default is FALSE.
    DWORD       dwGID ,  //  GID tag
        dwNumOptions ;  // these are not read in from GPD file.

}DFEATURE_OPTIONS, * PDFEATURE_OPTIONS ;    //  the prefix tag shall be 'fo'


//  R.I.P. - moved to gpd.h
//  typedef  struct
//  {
//      SEQSECTION     eSection;    // Specifies the section
//      DWORD          dwOrder   ;  // order within each section.
//  }  ORDERDEPENDENCY  , * PORDERDEPENDENCY  ;
//  assign this struct the type  'ord'

// ----  End of Value Structures Section ---- //


// ---- Header  Section ---- //


typedef   struct
{
    PSTR        pstrKeyword ;  // keyword associated with this entry
    VALUE       dwDefaultValue ;  //  One DWORD that will be copied
                            // to the destination if nothing is found
                            // in the attribute tree.  If the field
                            //  requires more than one DWORD, this
                            //  value is repeatedly copied.
                            //
                            //  if the value being copied is actually
                            //  a bit flag, this member shall contain
                            //  the value of the bit flag to be set.
                            //  Setting the flag shall be accomplished by
                            //  OR-ing this value into the destination.

    DWORD       dwNbytes  ;  //  # bytes occupied by value or link
    DWORD       dwSrcOffset ;   //  location of ATREEREF
    DWORD       dwDestOffset ;   //  offset in snapshot (dest) Structure to
                                //  copy link to object or object itself.
    DWORD       dwFlags ;         //  is this a dedicated structure?
                                //  ideally to ensure consistency, should
                        //  copy flags directly from the mainkeyword table.
    DWORD       dwGIDflags ;  //  BitField indicating which GID this
        //  field is a member of.  Only one bit should be set.
}  SNAPSHOTTABLE , * PSNAPSHOTTABLE ;

// the snapshot table determines which fields in the
//  rawbinarydata are copied over to each structure in the
//  snapshot.  This table is initialized only when a
//  rawbinarydata block is read from file.


typedef struct  {

    RAWBINARYDATA   rbd ;  // may be accessed by UI and control module.

    DWORD   dwSpecVersion ;         //  store converted version number
    // ptrs to tables required to generate snapshot.
    //  these tables are allocated and initialized when
    //  the RawBinaryData is read from file.  They are not saved
    //  to file.

    //  max buffer size needed to store option array in keyword form:
    DWORD     dwMaxDocKeywordSize, // Doc-Sticky,not used now but might later.
              dwMaxPrnKeywordSize; // Printer-Sticky

#if 0
    PSNAPSHOTTABLE  snapShotTable ;
    PRANGE  ssTableIndex ;
    PDWORD   pdwSizeOption ;
    PDWORD   pdwSizeOptionEx ;
    DWORD   dwSSCmdSelectIndex ;  // SS index of atrCommandIndex in pfo
    DWORD   dwSSdefaultOptionIndex ;   // SSindex of atrDefaultOption in pfo
    DWORD   dwSSTableCmdIndex ;  // SSindex of MTI_COMMANDTABLE entry.
    DWORD   dwSSPaperSizeMinSizeIndex ;  //  index not actually used
    DWORD   dwSSPaperSizeMaxSizeIndex ;
    DWORD   dwSSPaperSizeMarginsIndex ;
    DWORD   dwSSPaperSizeCursorOriginIndex ;
    DWORD   dwSSFeatureTypeIndex ;
    DWORD   dwSSConstraintsIndex ;
    DWORD   dwSSInvalidCombosIndex ;
    //  add other special case indicies here.
#endif

} MINIRAWBINARYDATA, * PMINIRAWBINARYDATA;

//  assign this struct the type  'mrbd'
//  First 6 or so fields are same as RAWBINARYDATA.

// global !

// extern  MINIRAWBINARYDATA  gmrbd ;
// This is now in GLOBL structure.



typedef struct  {
    RAWBINARYDATA   rbd ;  // may be accessed by UI and control module.
        //  this must be the FIRST!  field, so Amanda's code will still function.
        //  so initialize with beginning of pubBUDData.
    HFILEMAP        hFileMap;  // handle to memory mapped  BUD file.
    PBYTE    pubBUDData ;  // ptr to image of BUD file.
                                        //  first structure is RAWBINARYDATA


    PSNAPSHOTTABLE  snapShotTable ;
    PRANGE  ssTableIndex ;
    PDWORD   pdwSizeOption ;
    PDWORD   pdwSizeOptionEx ;

    DWORD   dwSSFeatureTypeIndex ;
    DWORD   dwSSdefaultOptionIndex ;   // SSindex of atrDefaultOption in pfo
    DWORD   dwSSPaperSizeMinSizeIndex ;  //  index not actually used
    DWORD   dwSSPaperSizeMaxSizeIndex ;
    DWORD   dwSSTableCmdIndex ;  // SSindex of MTI_COMMANDTABLE entry.
    DWORD   dwSSCmdSelectIndex ;  // SS index of atrCommandIndex in pfo
    DWORD   dwSSPaperSizeCursorOriginIndex ;
    DWORD   dwSSConstraintsIndex ;
    DWORD   dwSSInvalidCombosIndex ;
#ifdef  GMACROS
    DWORD   dwSSDepSettingsIndex ;
    DWORD   dwSSUIChangeTriggersMacroIndex ;
#endif

#if 0  // Don't define unless necessary.
    DWORD   dwSSPaperSizeMarginsIndex ;
    //  add other special case indicies here.
#endif

}   STATICFIELDS, *PSTATICFIELDS ;   //  These are fields that contain static data that is used
//  to create the snapshot,  but would be repetitive and waste space if kept in the BUD file.




// ----  End of Header Section ---- //


// ---- CommandArray  Section ---- //


//  #define  NO_CALLBACK_ID   (0xffffffff)


#define   CMD_SELECT   (0xfffffffe)
    //  used in place of a symbolID resulting from
    //  registering a command name.


//  R.I.P. - moved to gpd.h
//  typedef  struct
//  {
//      ARRAYREF   strInvocation ; // use only if NOT a CmdCallback.
//      ORDERDEPENDENCY  ordOrder ;
//      DWORD  dwCmdCallbackID ;    // set to UNUSED if not a CmdCallback
//      DWORD   dwStandardVarsList ;  // use only if CmdCallback.  Points to
//                          //  root of list holding indicies of Standard Vars
//                          //  to be passed into the callback.
//  }  COMMAND, * PCOMMAND ;
//  assign this struct the type  'cmd'


//  typedef  struct
//  {
//      DWORD   dwFormat ;    //  first letter after the %
//      DWORD   dwDigits ;    //  used if wFormat = 'd' or 'D' and
//                          //  PARAM_FLAG_FIELDWIDTH_USED
//      DWORD   dwFlags ;   //  see param_flags
//      LONG   lMin   ;     //  optional lower limit
//      LONG   lMax   ;     //  optional upper limit
//  //    DWORD   dwMaxRepeat ;  //  optional max repeat count
//  //    doesn't really exist!
//      ARRAYREF    arTokens ;  //  tokens for RPN calculator
//  }  PARAMETER, * PPARAMETER ;
//  assign this struct the type  'param'


//  #define PARAM_FLAG_MIN_USED  0x00000001
//      //  lMin field is used
//  #define PARAM_FLAG_MAX_USED  0x00000002
//      //  lMax field is used
//  #define PARAM_FLAG_FIELDWIDTH_USED  0x00000004
//      //  if fieldwidth was specified for 'd' or 'D' format.
//  #define PARAM_FLAG_MAXREPEAT_USED  0x00000008  //  dead
//      //  dwMaxRepeat field is used


//  typedef  struct
//  {
//      DWORD  dwValue ;    // integer or Standard Variable index
//      OPERATOR eType;    // type of Value or operator
//  }  TOKENSTREAM, * PTOKENSTREAM ;
//  assign this struct the type  'tstr'




//  typedef  enum
//  {   OP_INTEGER,   //  dwValue contains an integer
//      OP_VARI_INDEX,
//          //  dwValue contains index to Standard Variable Table.
//
//      //  these operators will actually be inserted into the token
//      //  stream.
//      OP_MIN, OP_MAX, OP_ADD, OP_SUB, OP_MULT,
//      OP_DIV, OP_MOD, OP_MAX_REPEAT, OP_HALT
//
//      //  these operators are used only in the temporary stack
//      OP_OPENPAR, OP_CLOSEPAR, OP_NEG,
//
//      //  these operators are processed immediately by the
//      //  token parser and are not stored.
//      OP_COMMA, OP_NULL, OP_LAST
//  }  OPERATOR ;   // parameter operator.
//

// extern  DWORD   gdwOperPrecedence[OP_LAST] ;
// This is now in GLOBL structure.

// ---- End of CommandArray  Section ---- //


// ----  List Values Section ---- //


/*  this defines the nodes used to implement a singly-linked
    list of DWORD  items.  Some values are stored in Lists.  */


//  typedef  struct
//  {
//      DWORD       dwData ;
//      DWORD       dwNextItem ;  //  index of next listnode
//  }  LISTNODE, * PLISTNODE ;
//  assign this struct the type  'lst'

// ----  End of List Values Section ---- //

// ---- Macros Section ---- //


//  BLOCKMACRODICT  is an array of BLOCKMACRODICTENTRY structs
//  that allows the function to resolve references to BlockMacros.

typedef  struct
{
    DWORD  dwSymbolID;  //  macro name ID value (obtained by RegisterSymbol)
    DWORD  dwTKIndexOpen;  //   index of open brace (in newTokenMap)
    DWORD  dwTKIndexClose;  //  index of closing brace
} BLOCKMACRODICTENTRY, * PBLOCKMACRODICTENTRY ;


//  VALUEMACRODICT  is an array of VALUEMACRODICTENTRY structs
//  that allows the function to  resolve references to valueMacros.

typedef  struct
{
    DWORD  dwSymbolID;      //  macro name ID value
    DWORD  dwTKIndexValue;  //  token index of valueMacro defintion
} VALUEMACRODICTENTRY, * PVALUEMACRODICTENTRY ;


//  MACROLEVELSTACK:   is operated as a stack of MACROLEVELSTATE
//  structs that saves the values of curBlockMacroEntry
//  and curValueMacroEntry , each time a brace is encountered.

typedef  struct
{
    DWORD  dwCurBlockMacroEntry;
    DWORD  dwCurValueMacroEntry;
    BOOL    bMacroInProgress ;
} MACROLEVELSTATE, * PMACROLEVELSTATE  ;



// ---- End of Macros Section ---- //

// ---- Global and state Variables ---- //
// {

    // ---- Error handling variables ---- //


typedef   enum
    {ERRSEV_NONE, ERRSEV_CONTINUE, ERRSEV_RESTART, ERRSEV_FATAL} SEVERITY ;

typedef   enum
    {ERRTY_NONE, ERRTY_SYNTAX, ERRTY_MEMORY_ALLOCATION,
    ERRTY_FILE_OPEN, ERRTY_CODEBUG} ERRTYPE  ;



// All of the following are now in GLOBL structure.
// extern      DWORD   gdwMasterTabIndex ;  // which resource ran out
// extern      SEVERITY    geErrorSev ;    // how bad an error?
// extern      ERRTYPE     geErrorType ;   // what type of error?

// extern      DWORD   gdwVerbosity ;  //  0 = min verbosity 4 max verbosity.

// extern      DWORD   gdwID_IgnoreBlock  ;  //  index of *IgnoreBlock

// extern  DWORD   gdwMemConfigKB, gdwMemConfigMB, gdwOptionConstruct,
//    gdwOpenBraceConstruct, gdwCloseBraceConstruct,
//    gdwMemoryConfigMB,  gdwMemoryConfigKB,
//    gdwCommandConstruct, gdwCommandCmd,
//    gdwOptionName ;

// extern  DWORD   gdwResDLL_ID   ;   //  Feature index of feature holding
                                                       //  names of all resource DLLs.
    //  Table to convert allowed values to sizes:
//  extern      DWORD  gValueToSize[VALUE_MAX] ;   // size of various values in bytes



    // ---- track value of curBlockMacroArray and curValueMacroArray ---- //

//            BUG_BUG!!!!!    may be part of master table !
//      DWORD   gdwCurBlockMacroArray ;   // initially set to zero.  First
//      DWORD   gdwCurValueMacroArray ;   // writable slot in MacroArray.
//      DWORD   gdwMacroLevelStackPtr ;   // Push: write values into
            // MacroLevelStack[MacroLevelStackPtr++]
            //  Pop: read values from
            // MacroLevelStack[--MacroLevelStackPtr]

//  }


//  These commonly used entities will be MACROS.

#define  mMainKeywordTable   ((PKEYWORDTABLE_ENTRY)(gMasterTable[MTI_MAINKEYWORDTABLE].pubStruct))

#define  mpubOffRef     (gMasterTable[MTI_STRINGHEAP].pubStruct)
    //      All stringheap offsets are referenced from this pointer.
#define  mloCurHeap     (gMasterTable[MTI_STRINGHEAP].dwCurIndex)
    //      current writable position on heap.
#define  mdwMaxHeap     (gMasterTable[MTI_STRINGHEAP].dwArraySize)
    //      maximum size of heap.

#define  mpstsStateStack     ((PSTSENTRY)gMasterTable[MTI_STSENTRY].pubStruct)
    //      base of state stack
#define  mdwCurStsPtr     (gMasterTable[MTI_STSENTRY].dwCurIndex)
    //      current writable (uninitialized) position on stack.
#define  mdwMaxStackDepth     (gMasterTable[MTI_STSENTRY].dwArraySize)
    //      maximum size of heap.

    // ---- Index in SYMBOLNODE array to each type of tree ---- //
    // initially set to INVALID_INDEX

#define   mdwFeatureSymbols  (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_FEATURES))
#define   mdwFontCartSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_FONTCART))
#define   mdwTTFontSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_TTFONTNAMES))
#define   mdwBlockMacroSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_BLOCKMACRO))
#define   mdwValueMacroSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_VALUEMACRO))
#define   mdwCmdNameSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_COMMANDNAMES))
#define   mdwPreProcDefinesSymbols (*((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct\
                                + SCL_PPDEFINES))


/*  -----  tables of constants ----- */




typedef enum {BT_FALSE, BT_TRUE} BOOLEANTYPE ;

typedef enum { UIT_PICKONE, UIT_PICKMANY }  UITYPE ;

typedef enum _QUERYDATATYPE {
    QDT_DWORD,  QDT_CONCATENATED_STRINGS
} QUERYDATATYPE;

//  typedef  enum
//  {ORIENT_PORTRAIT, ORIENT_CC90, ORIENT_CC270 }
//  ORIENTATION ;   //  decided to overload LANDSCAPEGRXROTATION
//                  //  instead of using a separate enum for orientation
//                  //  option keywords.


//  typedef  enum
//  {
//      SECT_UNINITIALIZED, JOB_SETUP, DOC_SETUP, PAGE_SETUP, PAGE_FINISH,
//      DOC_FINISH, JOB_FINISH
//  }  SECTION ;   replaced by SEQ_SECTION




typedef  struct
{
    DWORD  tIndexID;  //  tokenindex where a macro ID value is stored
    DWORD  tIndexOpen;  //  index of open brace
    DWORD  tIndexClose;  //  index of closing brace
} BLOCKMACROARRAY ;


//  snapshot and helper functions.

#define     OPTION_PENDING  (OPTION_INDEX_ANY - 1)

#define NUM_CONFIGURATION_CMDS (LAST_CONFIG_CMD - FIRST_CONFIG_CMD)
    // number of predefined commands that are emitted
    // at a fixed point in the job determined by order dependency.

#define     MAX_SNAPSHOT_ELEMENTS  (200)
    //  increase as more entries are added to the snapshot table.


typedef  enum
{
    TRI_UTTER_FAILURE, TRI_SUCCESS, TRI_AGAIN, TRI_UNINITIALIZED
}  TRISTATUS ;


typedef  enum
  { SSTI_GLOBALS,   SSTI_UPDATE_GLOBALS,
    SSTI_UIINFO,    SSTI_UPDATE_UIINFO,
    SSTI_FEATURES,  SSTI_UPDATE_FEATURES,
    SSTI_OPTIONS,   SSTI_UPDATE_OPTIONS,
    SSTI_OPTIONEX,  SSTI_UPDATE_OPTIONEX,
    SSTI_SPECIAL,   MAX_STRUCTURETYPES
  } SSTABLEINDEX ;



//  flags for snapshot table.

#define     SSF_REQUIRED        0x00000001
    //  fail if there is no value to copy
#define     SSF_DONT_USEDEFAULT 0x00000002
    //  if there is no value to copy leave dest
    //  undisturbed.  Do not copy the default value.
#define     SSF_OFFSETONLY      0x00000004
    // Copy only the loOffset of an arrayref.
#define     SSF_MAKE_STRINGPTR  0x00000008
    // Convert arrayref to stringptr
#define     SSF_SETRCID         0x00000010
    // set high bit after copying the value (if found)
#define     SSF_FAILIFZERO      0x00000020
    //  unlike SSF_REQUIRED, allow current copy
    //  to fail, then fail only if dest is zero.
#define     SSF_SECOND_DWORD    0x00000040
    //  treat src value object as array of DWORDS
    //  and copy the 2nd DWORD to the destination.
    //  used to transfer just the Y value of a point
    //  to the dest.
#define     SSF_KB_TO_BYTES    0x00000080
    //  treat dest as a dword and left shift by 10 bits.
#define     SSF_HEAPOFFSET    0x00000100
    //  instead of copying the bytes at pheap + heapoffset
    //  just copy heapoffset to the destination.
    //  this is used with dedicated structures where
    //  the heapoffset is actually the array index of a dedicated
    //  structure.
#define     SSF_RETURN_UNINITIALIZED        0x00000200
    //  if no value exists, cause EextractValueFromTree
    //  to return TRI_UNINITIALIZED, but don't complain
    //  to user.
#define     SSF_NON_LOCALIZABLE        0x00000400
    //  this keyword contains an explicit string and the resulting
    //  GPD file is not localizable.  The parser will emit a
    //  warning whenever such a keyword is parsed.

#define     SSF_MB_TO_BYTES    0x00000800
    //  treat dest as a dword and left shift by 20 bits.
#define     SSF_STRINGLEN    0x00001000
    //  just copy dwCount portion of arrayref to the destination.

//  the next 3 flags are to support the helper function
//  GetGPDResourceIDs() which is used only by Bob's MDT tool.
//  Note when any new entries are added to snaptbl.c
//  you should see if any of these flags need to be set.
//  otherwise  GetGPDResourceIDs will not report any
//  IDs used by the new entries.

#define     SSF_FONTID    0x00002000
    //  This entry is a Font resource ID.
#define     SSF_STRINGID    0x00004000
    //  This entry is a String resource ID.
#define     SSF_LIST    0x00008000
    //  This entry is a LIST (the index of a LISTNODE)
#define     SSF_ICONID    0x00010000
    //  This entry is an Icon  resource ID.
#define     SSF_OTHER_RESID    0x00020000
    //  This entry is an unclassified  resource ID.
    //   ie  CTT,  rcPromptMsgID, HelpIndex, rcHTPatternID


#define     SSF_BITFIELD_DEF_FALSE    (0x00040000)
    //  This entry is a Bitfield, which is CLEARED
    //   by default.
#define     SSF_BITFIELD_DEF_TRUE    (0x00080000)
    //  This entry is a Bitfield, which is SET
    //   by default.
    //   bitflags may be used with SSF_REQUIRED.

//   Bitfields are SET and CLEARED depending on the
//   value of the Boolean in the attribute tree.
//   the Bits to SET are defined by dwDefaultValue.


//  how do we verify proper initialization in the case when a dest
//  field must be initialized by at least one of several keywords?

//  The first keyword has a default initializer value of zero.
//  and has no flags set.  The last keyword has the
//  SSF_DONT_USEDEFAULT | SSF_FAILIFZERO   flags set.
//  The keywords in between has the SSF_DONT_USEDEFAULT flag set.




#define GIDF_RESOLUTION      (1 << GID_RESOLUTION)
#define GIDF_PAGESIZE        (1 << GID_PAGESIZE)
#define GIDF_PAGEREGION      (1 << GID_PAGEREGION)
#define GIDF_DUPLEX          (1 << GID_DUPLEX)
#define GIDF_INPUTSLOT       (1 << GID_INPUTSLOT)
#define GIDF_MEDIATYPE       (1 << GID_MEDIATYPE)
#define GIDF_MEMOPTION       (1 << GID_MEMOPTION)
#define GIDF_COLORMODE       (1 << GID_COLORMODE)
#define GIDF_ORIENTATION     (1 << GID_ORIENTATION)
#define GIDF_PAGEPROTECTION  (1 << GID_PAGEPROTECTION)
#define GIDF_COLLATE         (1 << GID_COLLATE)
#define GIDF_OUTPUTBIN       (1 << GID_OUTPUTBIN)
#define GIDF_HALFTONING      (1 << GID_HALFTONING)


//
// All the thread-unsafe data that was previously global has now
// been packed into this structure.
//

typedef struct {



    MASTERTAB_ENTRY     GMasterTable[MTI_MAX_ENTRIES] ;

    MINIRAWBINARYDATA   Gmrbd ;

        //  The AllowedTransitions Table determines/defines
        //  the state changes produced by each construct keyword
        //  Each entry in the table is a NewState and is indexed
        //  by the OldState and a ConstructKeyword
    STATE       GastAllowedTransitions[STATE_LAST][CONSTRUCT_LAST] ;

    BOOL        GabAllowedAttributes[STATE_LAST][ATT_LAST] ;

    DWORD       GdwOperPrecedence[OP_LAST] ;


    DWORD       GdwMasterTabIndex ;   // which resource ran out
    SEVERITY    GeErrorSev ;          // how bad an error?
    ERRTYPE     GeErrorType ;         // what type of error?

    DWORD       GdwVerbosity ;        //  0 = min verbosity 4 max verbosity.

    DWORD       GdwID_IgnoreBlock  ;  //  index of *IgnoreBlock

    DWORD       GValueToSize[VALUE_MAX] ;   // size of various values in bytes

        // MainKeywordTable ID values for  keywords
        // that will be synthesized or read by shortcuts code.
    DWORD       GdwMemConfigKB,         GdwMemConfigMB,     GdwOptionConstruct,
                GdwOpenBraceConstruct,  GdwCloseBraceConstruct,
                GdwMemoryConfigMB,      GdwMemoryConfigKB,
                GdwCommandConstruct,    GdwCommandCmd,
                GdwOptionName ;

    DWORD       GdwResDLL_ID  ;   //  Feature index of feature holding
                                  //  names of all resource DLLs.

    DWORD       GdwLastIndex;  // Used only in token1.c. Used to suppress
                               // BarchiveStrings() from doing redundant
                               // copying of the same strings in the event there
                               // are multiple parsing errors.
    ABSARRAYREF GaarPPPrefix;   // used only in preproc1.c

    CLASSINDEXENTRY  GcieTable[CL_NUMCLASSES] ;
} GLOBL, * PGLOBL;  // All the thread-unsafe data that was previously global has
                    // been packed into this structure.


//   function declarations.

#include "declares.h"

#if defined(DEVSTUDIO)

HANDLE MDSCreateFileW(LPCWSTR lpstrFile, DWORD dwDesiredAccess,
                      DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa,
                      DWORD dwCreateFlags, DWORD dwfAttributes,
                      HANDLE hTemplateFile);

#undef  CreateFile
#define CreateFile  MDSCreateFileW
#endif

#endif // _GPDPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\initdll.c ===
/*++

 Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    intidll.c

Abstract:

    This file handles the DLLInitialize spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    07/17/96 -amandan-
        Created it.

--*/


#include "gpdparse.h"

//
// Global instance handle and critical section
//


BOOL
DllInitialize(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    This function is called when the system loads/unloads the DriverUI module.
    At DLL_PROCESS_ATTACH, InitializeCriticalSection is called to initialize
    the critical section objects.
    At DLL_PROCESS_DETACH, DeleteCriticalSection is called to release the
    critical section objects.

Arguments:

    hModule     handle to DLL module
    ulReason    reason for the call
    pContext    pointer to context (not used by us)


Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\installb.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*
 *  installb.c - creates synthesized features and options and
 *          associated constraints and links to the installable
 *          feature or options.
 */


#include    "gpdparse.h"


// ----  functions defined in installb.c ---- //


DWORD    DwCountSynthFeatures(
IN     BOOL   (*fnBCreateFeature)(DWORD, DWORD, DWORD, PGLOBL ),   // callback
IN OUT PGLOBL pglobl
) ;

BOOL    BCreateSynthFeatures(
IN     DWORD   dwFea,  //  index of installable feature
IN     DWORD   dwOpt,  //  index of installable Option or set to INVALID_INDEX
IN     DWORD   dwSynFea,
IN OUT PGLOBL  pglobl) ;

BOOL    BEnableInvInstallableCombos(
PGLOBL pglobl) ;



// ---------------------------------------------------- //



DWORD    DwCountSynthFeatures(
IN     BOOL   (*fnBCreateFeature)(DWORD, DWORD, DWORD, PGLOBL ),   // callback
IN OUT PGLOBL pglobl
)
/*
    This function is called twice by PostProcess().

    the first pass sets fnBCreateFeature = NULL
    we just need to find out how many installable features and options
    exist.   Then we allocate this many synthesized features (outside of
    this function)
    In the second pass, we actually initialize the synthesized features
    and all the constraints applicable to that feature.  This is the
    job of fnBCreateFeature.
*/
{
    DWORD   dwOpt , dwHeapOffset, dwNodeIndex,
        dwFea, dwNumFea, dwNumOpt, dwNumSynFea ;
    PDFEATURE_OPTIONS   pfo ;
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF   patr ;

    if(fnBCreateFeature  &&
        !gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize)
        return(0) ;   //    May skip 2nd pass if  dwNumSynFea == 0

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;
    pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;
    dwNumFea = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;
    dwNumSynFea = 0 ;


    for(dwFea = 0 ; dwFea < dwNumFea ; dwFea++)
    {
        if(!fnBCreateFeature)
        {   //  first pass clear all links to synthesiszed features.
            //  this will catch errors if gpd writer attempts to
            //  reference non-installable feature/options in
            //  InstalledConstraints and invalidInstallableCombinations.

            pfo[dwFea].dwInstallableFeatureIndex = //  backlink to Feature/Option
            pfo[dwFea].dwInstallableOptionIndex =  //  that prompted this feature.
            pfo[dwFea].dwFeatureSpawnsFeature = INVALID_INDEX;
                //  If this feature is installable, this points to the
                //  index of the resulting synthesized feature.
        }

        if(BReadDataInGlobalNode(&pfo[dwFea].atrFeaInstallable,
                &dwHeapOffset, pglobl)   &&
                *(PDWORD)(mpubOffRef + dwHeapOffset) == BT_TRUE)
        {
            if(fnBCreateFeature)
            {
                if(!fnBCreateFeature(dwFea, INVALID_INDEX, dwNumSynFea, pglobl) )
                //  featureIndex, optionIndex, index of SynFea
                {
                    ERR(("DwCountSynthFeatures: Unable to create synthesized feature for installable Feature index %d.\n",
                        dwFea));
                    pfo[dwFea].dwFeatureSpawnsFeature = INVALID_INDEX;
                }

            }

            dwNumSynFea++ ;
        }
        dwNumOpt = pfo[dwFea].dwNumOptions ;
        patr = &pfo[dwFea].atrOptInstallable ;
        if(*patr == ATTRIB_UNINITIALIZED)
            continue ;
        if(*patr & ATTRIB_HEAP_VALUE)
        {
            ERR(("Internal error:  DwCountSynthFeatures - atrOptInstallable should never be branchless.\n"));
            continue ;
        }

        for(dwOpt = 0 ; dwOpt < dwNumOpt  ; dwOpt++)
        {
            DWORD   dwNodeIndex  ;

            dwNodeIndex = *patr ;  // to avoid overwriting
                // the attribute tree.
            if(BfindMatchingOrDefaultNode(
                patt ,  // start of ATTRIBUTE tree array.
                &dwNodeIndex,  // Points to first node in chain
                dwOpt     //  may even take on the value DEFAULT_INIT
                ) )
            {
                if((patt[dwNodeIndex].eOffsetMeans == VALUE_AT_HEAP)  &&
                    *(PDWORD)(mpubOffRef + patt[dwNodeIndex].dwOffset) == BT_TRUE )
                {
                    if(fnBCreateFeature)
                    {
                        if(!fnBCreateFeature(dwFea, dwOpt, dwNumSynFea, pglobl) )
                        //  featureIndex, optionIndex, index of SynFea
                        {
                            ERR(("DwCountSynthFeatures: Unable to create synthesized feature for installable option: fea=%d, opt=%d.\n",
                                dwFea, dwOpt));
                            pfo[dwFea].atrOptionSpawnsFeature = ATTRIB_UNINITIALIZED ;
                            //  destroys the entire attribute tree for this feature,
                            //  but what choice do we have?  Something has gone terribly
                            //  wrong.
                        }
                    }
                    dwNumSynFea++ ;
                }
            }
        }
    }
    if(fnBCreateFeature)
        BEnableInvInstallableCombos(pglobl) ;

    return(dwNumSynFea) ;
}



BOOL    BCreateSynthFeatures(
IN     DWORD   dwFea,  //  index of installable feature
IN     DWORD   dwOpt,  //  index of installable Option or set to INVALID_INDEX
IN     DWORD   dwSynFea,  //  index of synthesized feature
IN OUT PGLOBL  pglobl)
{
    DWORD   dwOptI , dwHeapOffset, dwNodeIndex, dwValue,
        dwPrevsNode, dwNewCnstRoot, dwJ, dwCNode ,
        dwNumFea, dwNumOpt, dwOut, dwIn ;
    BOOL    bPrevsExists, bStatus = TRUE ;
    PDFEATURE_OPTIONS   pfo, pfoSyn ;
    PGLOBALATTRIB   pga ;
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PATREEREF   patr ;
    PCONSTRAINTS     pcnstr ;  // start of CONSTRAINTS array.

    pcnstr = (PCONSTRAINTS) gMasterTable[MTI_CONSTRAINTS].pubStruct ;
    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;
    pga =  (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].pubStruct ;
    pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;
    pfoSyn = (PDFEATURE_OPTIONS) gMasterTable[MTI_SYNTHESIZED_FEATURES].pubStruct ;

    dwNumFea = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;

    //  initialize all fields with UNINITIALIZED just like normal fea/opt;

    for(dwJ = 0  ;  dwJ < gMasterTable[MTI_SYNTHESIZED_FEATURES].dwElementSiz /
                    sizeof(ATREEREF)  ; dwJ++)
    {
        ((PATREEREF)( (PDFEATURE_OPTIONS)gMasterTable[MTI_SYNTHESIZED_FEATURES].
                pubStruct + dwSynFea))[dwJ] =
            ATTRIB_UNINITIALIZED ;  // the DFEATURE_OPTIONS struct is
            // comprised entirely of ATREEREFs.
    }

    //  create links between installable feature/option and
    //  the synthesized feature.

    if(dwOpt != INVALID_INDEX)
    {
        if(!BexchangeDataInFOATNode(
        dwFea,
        dwOpt,
        offsetof(DFEATURE_OPTIONS, atrOptionSpawnsFeature),
        &dwOut,     // previous contents of attribute node
        &dwSynFea, FALSE, pglobl))       // new contents of attribute node.
            return(FALSE);

        //  If this option is installable, this points to the
        //  index of the resulting synthesized feature.
    }
    else
        pfo[dwFea].dwFeatureSpawnsFeature = dwSynFea;
        //  If this feature is installable, this points to the
        //  index of the resulting synthesized feature.
        //  note because this is temporary information,
        //  the index is stored directly into the atr node without
        //  even a HEAP_OFFSET flag.



    //  backlink to Feature/Option that created this syn feature.
    //  note dwOpt always initializes properly even if invalid.
    pfoSyn[dwSynFea].dwInstallableFeatureIndex = dwFea ;
    pfoSyn[dwSynFea].dwInstallableOptionIndex = dwOpt ;

    //  now initialize all other fields needed to establish
    //  a legitimate feature with 2 options!


    // -------- Synthesize a Feature name. ------ //



    if(dwOpt == INVALID_INDEX)
    {   //  installable Feature
        pfoSyn[dwSynFea].atrFeaDisplayName =
            pfo[dwFea].atrInstallableFeaDisplayName ;
        pfoSyn[dwSynFea].atrFeaRcNameID =
            pfo[dwFea].atrInstallableFeaRcNameID ;
    }
    else    //  installable Option
    {
        if(!BexchangeDataInFOATNode(
            dwFea,
            dwOpt,
            offsetof(DFEATURE_OPTIONS, atrInstallableOptDisplayName ) ,
            &dwHeapOffset,     // previous contents of attribute node
            NULL, FALSE, pglobl))       // NULL means Don't overwrite.
            return(FALSE) ;
        if(dwHeapOffset != INVALID_INDEX)
        {
            pfoSyn[dwSynFea].atrFeaDisplayName =
                    dwHeapOffset | ATTRIB_HEAP_VALUE ;
        }
        if(!BexchangeDataInFOATNode(
            dwFea,
            dwOpt,
            offsetof(DFEATURE_OPTIONS, atrInstallableOptRcNameID ) ,
            &dwHeapOffset,     // previous contents of attribute node
            NULL, FALSE, pglobl))       // NULL means Don't overwrite.
            return(FALSE) ;
        if(dwHeapOffset != INVALID_INDEX)
        {
            pfoSyn[dwSynFea].atrFeaRcNameID =
                    dwHeapOffset | ATTRIB_HEAP_VALUE ;
        }
    }


{   //   !!! new stuff
    PBYTE  pubBaseKeyword = "SynthesizedFea_";
    BYTE    aubNum[4] ;
    DWORD  dwBaselen, dwDummy , dwI, dwNum = dwSynFea;
    ARRAYREF      arSymbolName ;

    //  compose featurekeyword string  incorporating  dwSynFea
    //  convert dwSynFea into 3 digit number.
    for(dwI = 0 ; dwI < 3 ; dwI++)
    {
        aubNum[2 - dwI] =  '0' + (BYTE)(dwNum % 10);
        dwNum /= 10 ;
    }
    aubNum[3] = '\0' ;   // null terminate

    dwBaselen = strlen(pubBaseKeyword);

    if(!BwriteToHeap(&arSymbolName.loOffset,
        pubBaseKeyword, dwBaselen, 1, pglobl))
        return(FALSE);

    if(!BwriteToHeap(&dwDummy,
        aubNum, 4, 1, pglobl))   //  append 3 digit number to base + null terminator
        return(FALSE);

    arSymbolName.dwCount = dwBaselen + 3 ;

    gmrbd.dwMaxPrnKeywordSize += arSymbolName.dwCount + 2 ;
        // add 2 bytes for every feature

    if(!BwriteToHeap(&(pfoSyn[dwSynFea].atrFeaKeyWord),
        (PBYTE)&arSymbolName, sizeof(ARRAYREF), 4, pglobl))
        return(FALSE);

    pfoSyn[dwSynFea].atrFeaKeyWord |= ATTRIB_HEAP_VALUE ;
}  //   !!! end new stuff

    #if 0
    pfoSyn[dwSynFea].atrFeaKeyWord =
        pfo[dwFea].atrFeaKeyWord ;  // just to fill something in.
    #endif


    //  grab offsets to "Installed" and  "Not Installed"
    //  option name templates:

    if(BReadDataInGlobalNode(&pga->atrNameInstalled, &dwHeapOffset, pglobl) )
    {
        if(!BexchangeDataInFOATNode(
            dwSynFea,
            1,
            offsetof(DFEATURE_OPTIONS, atrOptDisplayName) ,
            &dwOut,     // previous contents of attribute node
            &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.
            return(FALSE) ;
    }
    if(BReadDataInGlobalNode(&pga->atrNameNotInstalled, &dwHeapOffset, pglobl) )
    {
        if(!BexchangeDataInFOATNode(
            dwSynFea,
            0,
            offsetof(DFEATURE_OPTIONS, atrOptDisplayName) ,
            &dwOut,     // previous contents of attribute node
            &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.

            return(FALSE) ;
    }
    if(BReadDataInGlobalNode(&pga->atrNameIDInstalled, &dwHeapOffset, pglobl) )
    {
        if(!BexchangeDataInFOATNode(
            dwSynFea,
            1,
            offsetof(DFEATURE_OPTIONS, atrOptRcNameID) ,
            &dwOut,     // previous contents of attribute node
            &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.

            return(FALSE) ;
    }
    if(BReadDataInGlobalNode(&pga->atrNameIDNotInstalled, &dwHeapOffset, pglobl) )
    {
        if(!BexchangeDataInFOATNode(
            dwSynFea,
            0,
            offsetof(DFEATURE_OPTIONS, atrOptRcNameID) ,
            &dwOut,     // previous contents of attribute node
            &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.
            return(FALSE) ;
    }


    pfoSyn[dwSynFea].dwGID = GID_UNKNOWN ;
    pfoSyn[dwSynFea].dwNumOptions = 2 ;


    //  label this FeatureType as PrinterSticky
    dwValue = FT_PRINTERPROPERTY ;
    patr  = &pfoSyn[dwSynFea].atrFeatureType ;

    if(!BwriteToHeap(patr, (PBYTE)&dwValue ,
        sizeof(DWORD), 4, pglobl) )
    {
        bStatus = FALSE ;  // heap overflow start over.
    }
    *patr  |= ATTRIB_HEAP_VALUE ;


    //  leave optionID, atrFeaKeyWord, atrOptKeyWord uninitialized.


{   //   !!! new stuff     init atrOptKeyWord , hardcode to ON and OFF
    ARRAYREF      arSymbolName ;

    if(!BwriteToHeap(&arSymbolName.loOffset,
        "OFF", 4, 1, pglobl))
        return(FALSE);

    arSymbolName.dwCount = 3 ;

    if(!BwriteToHeap(&dwHeapOffset,
        (PBYTE)&arSymbolName, sizeof(ARRAYREF), 4, pglobl))
        return(FALSE);

    if(!BexchangeDataInFOATNode(
        dwSynFea,
        0,
        offsetof(DFEATURE_OPTIONS, atrOptKeyWord) ,
        &dwOut,     // previous contents of attribute node
        &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.

        return(FALSE) ;

// -----   init "ON"  -----


    if(!BwriteToHeap(&arSymbolName.loOffset,
        "ON", 3, 1, pglobl))
        return(FALSE);

    arSymbolName.dwCount = 2 ;

    if(!BwriteToHeap(&dwHeapOffset,
        (PBYTE)&arSymbolName, sizeof(ARRAYREF), 4, pglobl))
        return(FALSE);

    if(!BexchangeDataInFOATNode(
        dwSynFea,
        1,
        offsetof(DFEATURE_OPTIONS, atrOptKeyWord) ,
        &dwOut,     // previous contents of attribute node
        &dwHeapOffset, TRUE, pglobl) )       // new contents of attribute node.
        return(FALSE) ;

    gmrbd.dwMaxPrnKeywordSize += 4 ;  //   sufficient to hold "OFF\0".
            //  note synthesized features are always pick_one.
}

    //  transfer atrOptInstallConstraints etc to atrConstraints.

    if(dwOpt != INVALID_INDEX)
    {
        if(!BexchangeDataInFOATNode(
        dwFea,
        dwOpt,
        offsetof(DFEATURE_OPTIONS, atrOptInstallConstraints ),
        &dwOut,     // previous contents of attribute node
        NULL,              // don't change contents of attribute node.
        FALSE , pglobl) )   // not synthetic feature
            return(FALSE);

        dwIn = dwOut ;
        if(dwIn != INVALID_INDEX)
            BexchangeDataInFOATNode(
                dwSynFea,
                1,  //  "Installed"
                offsetof(DFEATURE_OPTIONS, atrConstraints) ,
                &dwOut,     // previous contents of attribute node
                &dwIn,     // new contents of attribute node.
                TRUE , pglobl) ;

        if(!BexchangeDataInFOATNode(
        dwFea,
        dwOpt,
        offsetof(DFEATURE_OPTIONS, atrOptNotInstallConstraints ),
        &dwOut,     // previous contents of attribute node
        NULL,              // don't change contents of attribute node.
        FALSE , pglobl) )   // not synthetic feature
            return(FALSE);

        dwIn = dwOut ;

        if(dwIn != INVALID_INDEX)
            BexchangeDataInFOATNode(
                dwSynFea,
                0,  //  "Not Installed"
                offsetof(DFEATURE_OPTIONS, atrConstraints) ,
                &dwOut,     // previous contents of attribute node
                &dwIn,       // new contents of attribute node.
                TRUE , pglobl) ;
    }
    else
    {
        if(BReadDataInGlobalNode(&pfo[dwFea].atrFeaInstallConstraints, &dwHeapOffset, pglobl) )
            BexchangeDataInFOATNode(
                dwSynFea,
                1,  //  "Installed"
                offsetof(DFEATURE_OPTIONS, atrConstraints) ,
                &dwOut,     // previous contents of attribute node
                &dwHeapOffset,       // new contents of attribute node.
                TRUE , pglobl) ;

        if(BReadDataInGlobalNode(&pfo[dwFea].atrFeaNotInstallConstraints , &dwHeapOffset, pglobl) )
            BexchangeDataInFOATNode(
                dwSynFea,
                0,  //  "Not Installed"
                offsetof(DFEATURE_OPTIONS, atrConstraints) ,
                &dwOut,     // previous contents of attribute node
                &dwHeapOffset,       // new contents of attribute node.
                TRUE , pglobl) ;
    }


    //  now synthesize:  selecting option 0 constrains all
    //  options of an Installable feature except option 0.
    //  Selecting option 0 constrains an installable option.

    if(bStatus)
        bStatus =
            BallocElementFromMasterTable(MTI_CONSTRAINTS, &dwNewCnstRoot, pglobl) ;
    dwCNode = dwNewCnstRoot ;

    if(dwOpt != INVALID_INDEX)
    {                           //  installable option
        pcnstr[dwCNode].dwFeature = dwFea ;
        pcnstr[dwCNode].dwOption = dwOpt ;
    }
    else    //  installable feature
    {
        dwNumOpt = pfo[dwFea].dwNumOptions ;

        for(dwOptI = 1 ; bStatus  &&  dwOptI < dwNumOpt ; dwOptI++)
        {
            pcnstr[dwCNode].dwFeature = dwFea ;
            pcnstr[dwCNode].dwOption = dwOptI ;
            if(dwOptI + 1 < dwNumOpt)
            {
                bStatus = BallocElementFromMasterTable(MTI_CONSTRAINTS,
                        &pcnstr[dwCNode].dwNextCnstrnt, pglobl) ;
                dwCNode = pcnstr[dwCNode].dwNextCnstrnt ;
            }
        }
    }

    //  get existing list and prepend new list to it.


    bStatus = BexchangeArbDataInFOATNode(
            dwSynFea,
            0,  //  "Not Installed"
            offsetof(DFEATURE_OPTIONS, atrConstraints) ,
            sizeof(DWORD) ,    //  number bytes to copy.
            (PBYTE)&dwPrevsNode,     //  pubOut
            (PBYTE)&dwNewCnstRoot,   //  pubIn
            &bPrevsExists,  // previous contents existed?
            TRUE,     // access the synthetic features.
            pglobl
    ) ;
    if(bPrevsExists)
    {        //  tack existing list onto new list.
        pcnstr[dwCNode].dwNextCnstrnt = dwPrevsNode ;
    }
    else
    {
        pcnstr[dwCNode].dwNextCnstrnt = END_OF_LIST ;
    }

    return(bStatus) ;
}


BOOL    BEnableInvInstallableCombos(
PGLOBL pglobl)
{
    DWORD   dwPrevsNode, dwRootNode, dwNewCombo , dwCurNode,
        dwFeaInstallable, dwOpt, dwSynFea, dwFeaOffset  ;
    PDFEATURE_OPTIONS   pfo;
    PGLOBALATTRIB   pga ;
    PINVALIDCOMBO   pinvc ;  //  start of InvalidCombo array


    pga =  (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].pubStruct ;
    pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;
    pinvc = (PINVALIDCOMBO) gMasterTable[MTI_INVALIDCOMBO].pubStruct ;
    dwFeaOffset = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;




    dwRootNode = pga->atrInvldInstallCombo ;
    if(dwRootNode == ATTRIB_UNINITIALIZED)
        return(TRUE) ;  //  no InvalidInstallableCombos found.

    while(dwRootNode != END_OF_LIST)
    {
        dwNewCombo = pinvc[dwRootNode].dwNewCombo ;
        dwCurNode = dwRootNode ;
        while(dwCurNode != END_OF_LIST)
        {
            dwFeaInstallable = pinvc[dwCurNode].dwFeature ;

            dwOpt = pinvc[dwCurNode].dwOption ;

            if(dwOpt != (WORD)DEFAULT_INIT)
            {       //  this option is installable
                if(!BexchangeDataInFOATNode(
                dwFeaInstallable,
                dwOpt,
                offsetof(DFEATURE_OPTIONS, atrOptionSpawnsFeature),
                &dwSynFea,     // previous contents of attribute node
                NULL, FALSE, pglobl))       // new contents of attribute node.
                    return(FALSE);

            }
            else
                dwSynFea = pfo[dwFeaInstallable].dwFeatureSpawnsFeature ;


            pinvc[dwCurNode].dwFeature = dwSynFea + dwFeaOffset ;
                //  dwSynFea is the index of the resulting
                //  synthesized feature.
            pinvc[dwCurNode].dwOption = 1 ; //  can't tolerate
                //  all these things installed at the same time.

            if(!BexchangeDataInFOATNode(dwSynFea , 1,
                offsetof(DFEATURE_OPTIONS, atrInvalidCombos),
                &dwPrevsNode, &dwRootNode, TRUE, pglobl))
            return(FALSE);

            if(dwPrevsNode == INVALID_INDEX)
                pinvc[dwCurNode].dwNewCombo = END_OF_LIST ;
            else
                pinvc[dwCurNode].dwNewCombo = dwPrevsNode ;

            dwCurNode = pinvc[dwCurNode].dwNextElement ;  //    last line
        }
        dwRootNode = dwNewCombo ;  //    last line
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\macros1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  macros1.c - functions that implement macros  */


#include    "gpdparse.h"



// ----  functions defined in  macros1.c ---- //

BOOL  BevaluateMacros(
PGLOBL  pglobl) ;

BOOL    BDefineValueMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

BOOL    BResolveValueMacroReference(
PTKMAP  ptkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BdelimitName(
PABSARRAYREF    paarValue,   //  the remainder of the string without the Name
PABSARRAYREF    paarToken,   //  contains the Name
PBYTE  pubChar ) ;


BOOL    BCatToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL          pglobl) ;

BOOL    BResolveBlockMacroReference(
PTKMAP  ptkmap,
DWORD   dwMacRefIndex,
PGLOBL  pglobl) ;

BOOL    BDefineBlockMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

BOOL    BIncreaseMacroLevel(
BOOL    bMacroInProgress,
PGLOBL  pglobl) ;

BOOL    BDecreaseMacroLevel(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl) ;

VOID    VEnumBlockMacro(
PTKMAP  pNewtkmap,
PBLOCKMACRODICTENTRY    pBlockMacroDictEntry,
PGLOBL  pglobl ) ;


// ---------------------------------------------------- //




BOOL  BevaluateMacros(
PGLOBL pglobl)
//  and expand shortcuts
//    this function scans through the tokenMap
//    making a copy of the tokenMap without
//    the macrodefinitions or references.  All references
//    are replaced by the definitions inserted in-line!
//    This function assumes the temp heap is availible for
//    storage of expanded macros.
{
    PTKMAP   ptkmap, pNewtkmap ;   // start of tokenmap
    DWORD   dwNewTKMindex, dwEntry, dwKeywordID ;
    CONSTRUCT   eConstruct ;
    KEYWORD_TYPE    eType ;
    BOOL    bStatus = TRUE ,
        bValueMacroState = FALSE ;   // set to TRUE when
        //  we parse into a *Macros  construct.


    gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex =
    gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex =
    gMasterTable[MTI_MACROLEVELSTACK].dwCurIndex = 0 ;
    //  to push new values onto stack:  write then increment stackptr
    //  to pop values off the stack:  decrement stackptr then read from stack


    pNewtkmap = (PTKMAP)gMasterTable[MTI_NEWTOKENMAP].pubStruct ;
    ptkmap = (PTKMAP)gMasterTable[MTI_TOKENMAP].pubStruct  ;


    for(dwEntry = 0 ; geErrorSev < ERRSEV_RESTART ; dwEntry++)
    {
        //  These ID's must be processed separately
        //  because they do not index into the mainKeyword table.
        //  The code for generic ID's will fail.

        dwKeywordID = ptkmap[dwEntry].dwKeywordID ;


        if (dwKeywordID == gdwID_IgnoreBlock)
        {
            VIgnoreBlock(ptkmap + dwEntry, TRUE, pglobl) ;
            continue ;
        }

        switch(dwKeywordID)
        {
            case (ID_EOF):
            {
                {
                    DWORD   dwEntry, dwTKMindex, dwTKIndexOpen, dwTKIndexClose ;
                    PBLOCKMACRODICTENTRY    pBlockMacroDictEntry ;
                    PVALUEMACRODICTENTRY    pValueMacroDictEntry ;


                    //  remove all traces of expired block and value macro definitions

                    pBlockMacroDictEntry =
                        (PBLOCKMACRODICTENTRY)gMasterTable[MTI_BLOCKMACROARRAY].pubStruct ;
                    pValueMacroDictEntry =
                        (PVALUEMACRODICTENTRY)gMasterTable[MTI_VALUEMACROARRAY].pubStruct ;

                    for(dwEntry = 0 ;
                        dwEntry < gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex ;
                        dwEntry++)
                    {
                        dwTKMindex = pValueMacroDictEntry[dwEntry].dwTKIndexValue ;
                        pNewtkmap[dwTKMindex].dwKeywordID = ID_NULLENTRY ;
                    }

                    for(dwEntry = 0 ;
                        dwEntry < gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex ;
                        dwEntry++)
                    {
                        dwTKIndexOpen = pBlockMacroDictEntry[dwEntry].dwTKIndexOpen ;
                        dwTKIndexClose = pBlockMacroDictEntry[dwEntry].dwTKIndexClose ;
                        for(dwTKMindex = dwTKIndexOpen ; dwTKMindex <= dwTKIndexClose ;
                            dwTKMindex++)
                            pNewtkmap[dwTKMindex].dwKeywordID = ID_NULLENTRY ;
                    }
                }

                if(gMasterTable[MTI_MACROLEVELSTACK].dwCurIndex)
                {
                    ERR(("Too few closing braces.  Fatal syntax error.\n"));
                    geErrorSev = ERRSEV_FATAL ;
                    geErrorType = ERRTY_SYNTAX  ;
                    return(FALSE);
                }

                //  transfer all tokenmap fields to newTokenMap
                if(!BallocElementFromMasterTable(
                        MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
                {
                    geErrorSev = ERRSEV_RESTART ;
                    geErrorType = ERRTY_MEMORY_ALLOCATION ;
                    gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                    return(FALSE);
                }
                pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;

                bStatus = (mdwCurStsPtr) ? (FALSE) : (TRUE);
                if(geErrorSev >= ERRSEV_RESTART)
                    bStatus = FALSE ;
                return(bStatus) ;
            }
            case (ID_NULLENTRY):
            {
                continue ;  //  skip to next entry.
            }
            default :
                break ;
        }


        if(bValueMacroState)
        {
            if(dwKeywordID == ID_UNRECOGNIZED)
            {
                vIdentifySource(ptkmap + dwEntry, pglobl) ;
                ERR(("Only valueMacroDefinitions permitted within *Macros  constructs.\n"));
            }
            else if(dwKeywordID == ID_SYMBOL)
            {
                //  transfer all tokenmap fields to newTokenMap
                if(!BallocElementFromMasterTable(
                        MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
                {
                    geErrorSev = ERRSEV_RESTART ;
                    geErrorType = ERRTY_MEMORY_ALLOCATION ;
                    gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                    continue ;
                }
                pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;
                if(!BDefineValueMacroName(pNewtkmap, dwNewTKMindex, pglobl) )
                {
                    pNewtkmap[dwNewTKMindex].dwKeywordID = ID_NULLENTRY ;
                    vIdentifySource(ptkmap + dwEntry, pglobl) ;
                    ERR(("Internal Error: valueMacro name registration failed.\n"));
                }
                else if(ptkmap[dwEntry].dwFlags & TKMF_MACROREF)
                {
                    if(!BResolveValueMacroReference(pNewtkmap , dwNewTKMindex, pglobl))
                    {
                        pNewtkmap[dwNewTKMindex].dwKeywordID = ID_NULLENTRY ;
                        gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex-- ;
                        //  remove macrodef from dictionary.
                    }
                }
            }
            else //  keywords that should be defined in the MainKeywordTable
            {
                eType = mMainKeywordTable[dwKeywordID].eType ;
                eConstruct = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;

                if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_CLOSEBRACE)
                {
                    bValueMacroState = FALSE ;  //  just don't copy it.
                }
                else
                {
                    vIdentifySource(ptkmap + dwEntry, pglobl) ;
                    ERR(("Only valueMacroDefinitions permitted within *Macros  constructs.\n"));
                }
            }
            continue ;   //  end of processing for this statement
        }

        //  the remainder of the block handles the case
        //   bValueMacroState = FALSE ;

        if(dwKeywordID == ID_UNRECOGNIZED  ||  dwKeywordID == ID_SYMBOL)
        {
            //  Note:  currently SYMBOLs only occur within ValueMacro
            //  constructs so they could be flagged as an error here.  But
            //  let it slide here since one day the parser may allow them
            //  to be used elsewhere.

            //  do nothing in this block, just use it to skip to code at the
            //  bottom after all the else if statements.
            ; // empty statement.
        }
        else  // only valid KeywordIDs enter this block.
        {
            eType = mMainKeywordTable[dwKeywordID].eType ;
            eConstruct = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;

            if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_BLOCKMACRO)
            {
                if(!BDefineBlockMacroName(ptkmap, dwEntry, pglobl))
                {
                    vIdentifySource(ptkmap + dwEntry, pglobl) ;
                    ERR(("Internal Error: blockMacro name registration failed.\n"));
                    continue ;
                }

                //  skip NULL_ENTRIES
                for( dwEntry++ ; ptkmap[dwEntry].dwKeywordID == ID_NULLENTRY ; dwEntry++)
                    ;

                dwKeywordID = ptkmap[dwEntry].dwKeywordID ;

                if(dwKeywordID  <  ID_SPECIAL)
                {
                    eType = mMainKeywordTable[dwKeywordID].eType ;
                    eConstruct = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;

                    if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_OPENBRACE)
                    {
                        PBLOCKMACRODICTENTRY    pBlockMacroDictEntry ;

                        if(!BallocElementFromMasterTable(
                                MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
                        {
                            geErrorSev = ERRSEV_RESTART ;
                            geErrorType = ERRTY_MEMORY_ALLOCATION ;
                            gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                            continue ;
                        }
                        pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;

                        pBlockMacroDictEntry =
                            (PBLOCKMACRODICTENTRY)gMasterTable[MTI_BLOCKMACROARRAY].pubStruct ;

                        pBlockMacroDictEntry[gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex - 1].dwTKIndexOpen =
                            dwNewTKMindex ;

                        BIncreaseMacroLevel(TRUE, pglobl) ;
                        continue ;   //  end of processing for this statement
                    }
                }
                vIdentifySource(ptkmap + dwEntry, pglobl) ;
                ERR(("expected openbrace to follow *BlockMacros keyword.\n"));
                geErrorType = ERRTY_SYNTAX ;
                geErrorSev = ERRSEV_FATAL ;
                continue ;   //  end of processing for this statement
            }
            else if(eType == TY_SPECIAL   &&  eConstruct == SPEC_INSERTBLOCK)
            {
                if(ptkmap[dwEntry].dwFlags & TKMF_MACROREF)
                {
                    if(!BResolveBlockMacroReference(ptkmap, dwEntry, pglobl))
                    {
                        vIdentifySource(ptkmap + dwEntry, pglobl) ;
                        ERR(("   *InsertBlockMacro Construct ignored.\n"));
                        VIgnoreBlock(ptkmap + dwEntry, TRUE, pglobl) ;
                    }
                }
                else
                {
                    vIdentifySource(ptkmap + dwEntry, pglobl) ;
                    ERR(("expected a =MacroName as the value of *InsertBlockMacro keyword.\n"));
                    ERR(("   *InsertBlockMacro Construct ignored.\n"));
                    VIgnoreBlock(ptkmap + dwEntry, TRUE, pglobl) ;
                }
                continue ;   //  end of processing for this statement
            }
            else if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_MACROS)
            {   //  *Macros  definition
                dwEntry++;   // don't copy *Macros statement
                while(ptkmap[dwEntry].dwKeywordID == ID_NULLENTRY)
                     dwEntry++;     //  skip NULL_ENTRIES

                dwKeywordID = ptkmap[dwEntry].dwKeywordID  ;

                if(dwKeywordID  <  ID_SPECIAL)
                {
                    eType = mMainKeywordTable[dwKeywordID].eType ;
                    eConstruct = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;

                    if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_OPENBRACE)
                    {
                        // don't copy openbrace
                        bValueMacroState = TRUE ;
                        continue ;   //  end of processing for this statement
                    }
                }
                vIdentifySource(ptkmap + dwEntry, pglobl) ;
                ERR(("expected openbrace to follow *Macros keyword.\n"));
                geErrorType = ERRTY_SYNTAX ;
                geErrorSev = ERRSEV_FATAL ;
                continue ;   //  end of processing for this statement
            }
            else if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_OPENBRACE)
            {
                if(!BallocElementFromMasterTable(
                        MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
                {
                    geErrorSev = ERRSEV_RESTART ;
                    geErrorType = ERRTY_MEMORY_ALLOCATION ;
                    gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                }
                pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;
                BIncreaseMacroLevel(FALSE, pglobl) ;
                continue ;   //  end of processing for this statement
            }
            else if(eType == TY_CONSTRUCT  &&  eConstruct == CONSTRUCT_CLOSEBRACE)
            {
                if(!BallocElementFromMasterTable(
                        MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
                {
                    geErrorSev = ERRSEV_RESTART ;
                    geErrorType = ERRTY_MEMORY_ALLOCATION ;
                    gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                }
                pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;
                BDecreaseMacroLevel(pNewtkmap, dwNewTKMindex, pglobl) ;
                continue ;   //  end of processing for this statement
            }
        }
        //  execution path for ID_UNRECOGNIZED  and ID_SYMBOL
        //  rejoins here.   This code is executed only if
        //  keyword was not processed in the special cases above.

        //  transfer all tokenmap fields to newTokenMap
        if(!BallocElementFromMasterTable(
                MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_NEWTOKENMAP ;
            continue ;
        }
        pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;

        if(ptkmap[dwEntry].dwFlags & TKMF_MACROREF)
        {
            if(!BResolveValueMacroReference(pNewtkmap , dwNewTKMindex, pglobl))
            {
                pNewtkmap[dwNewTKMindex].dwKeywordID = ID_NULLENTRY ;
            }
            if(gdwVerbosity >= 4)
            {
                ERR(("\nEnumerate ValueMacro Reference at:\n")) ;
                vIdentifySource(pNewtkmap + dwNewTKMindex, pglobl) ;

                ERR(("    %0.*s : %0.*s\n",
                    pNewtkmap[dwNewTKMindex].aarKeyword.dw,
                    pNewtkmap[dwNewTKMindex].aarKeyword.pub,
                    pNewtkmap[dwNewTKMindex].aarValue.dw,
                    pNewtkmap[dwNewTKMindex].aarValue.pub
                    ));
            }


        }
    }  //  end of for each tkmap entry loop

    if(geErrorSev >= ERRSEV_RESTART)
        bStatus = FALSE ;
    return(bStatus) ;
}




BOOL    BDefineValueMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl)
{
    DWORD   dwValueMacroEntry, dwSymbolID ;
    PVALUEMACRODICTENTRY    pValueMacroDictEntry ;

    if(!BeatSurroundingWhiteSpaces(&pNewtkmap[dwNewTKMindex].aarKeyword) )
    {
        vIdentifySource(pNewtkmap + dwNewTKMindex, pglobl) ;
        ERR(("syntax error in ValueMacro name.\n"));
        return(FALSE);
    }

    dwSymbolID = DWregisterSymbol(&pNewtkmap[dwNewTKMindex].aarKeyword,
                               CONSTRUCT_MACROS, TRUE, INVALID_SYMBOLID, pglobl ) ;
    if(dwSymbolID == INVALID_SYMBOLID)
        return(FALSE);

    if(!BallocElementFromMasterTable(
            MTI_VALUEMACROARRAY, &dwValueMacroEntry, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_VALUEMACROARRAY ;
        return(FALSE);
    }

    pValueMacroDictEntry = (PVALUEMACRODICTENTRY)gMasterTable[MTI_VALUEMACROARRAY].pubStruct ;

    pValueMacroDictEntry[dwValueMacroEntry].dwSymbolID = dwSymbolID ;
    pValueMacroDictEntry[dwValueMacroEntry].dwTKIndexValue = dwNewTKMindex ;

    return(TRUE);
}






BOOL    BResolveValueMacroReference(
 PTKMAP  ptkmap,
 DWORD   dwTKMindex,
 PGLOBL  pglobl)
{
    BYTE  ubChar ;
    PVALUEMACRODICTENTRY    pValueMacroDictEntry ;
    ABSARRAYREF    aarNewValue, aarValue, aarToken  ;
    PBYTE   pubDelimiters  = "=\"%" ;      //  array of valid delimiters
    DWORD   dwEntry, dwDelim ;  // index to pubDelimiters

    // ------ original strict interpretation ------
    //  because the value contains a =MacroRef, we assume
    //  the value is comprised purely of =MacroRef, "substrings" and
    //  %{params}  mixed up in any order.  A new value string
    //  without the =MacroRefs will replace the original.
    // ------ lenient interpretation --------
    //  if the GPD writer only uses the reserved characters
    //  = to indicate a MacroRef and as part of a string literal
    //      or comment,
    //  " to delimit a string literal, or as part of a string literal
    //      or comment,
    //  % to begin a parameter construct , or as part of a string literal
    //      or comment, or as the escape character within a string literal
    //
    //  then the parser can allow 1 or more valuemacro references to be
    //  embedded in any arbitrary value string subject to
    //  these conditions:
    //  a)  "string literals" and %{param constructs}  may not
    //      contain =MacroRefs
    //  b)  the value associated with each *Macro:  must be
    //      a syntatically valid value object.
    //      ie   an INT, PAIR(,) , ENUM_CONSTANT, SUBSTRING, PARAM etc.
    //  c)  when all macro references are expanded, the resulting value
    //      must itself satisfy b)  for every keyword and macrodefinition
    //      which contains one or more =Macroref.



    aarNewValue.dw = 0 ;  // initialize so BCatToTmpHeap
                            //  will overwrite instead of append

    pValueMacroDictEntry = (PVALUEMACRODICTENTRY)gMasterTable[MTI_VALUEMACROARRAY].pubStruct ;

    aarValue = ptkmap[dwTKMindex].aarValue ;

    if(!BeatLeadingWhiteSpaces( &aarValue) )
    {
        vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
        ERR(("Internal error: =MacroRef expected, but No value found.\n"));
        return(FALSE) ;
    }


    ubChar = *aarValue.pub ;  // first char in value string
    aarValue.dw-- ;
    aarValue.pub++ ;    //  clip off the first char to simulate
                        //  effect of BdelimitToken()

    while(1)
    {

        switch(ubChar)
        {
            case  '=':  // macroname indicator
            {
                DWORD   dwRefSymbolID,  //  ID of MacroReference.
                        dwNewTKMindex,  //  tokenmap index containing valueMacro.
                        dwMaxIndex ;    // one past last valMacro dictionary entry


                if(!BdelimitName(&aarValue, &aarToken, &ubChar ) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("No MacroName detected after '='.\n"));
                    return(FALSE) ;
                }
                if(aarValue.dw)
                {
                    aarValue.dw-- ;
                    aarValue.pub++ ;    //  clip off the first char to simulate
                }

                if(!BparseSymbol(&aarToken,
                    &dwRefSymbolID,
                    VALUE_SYMBOL_VALUEMACRO, pglobl) )
                {
                    return(FALSE) ;
                }

                //  search ValueMacro Dict starting from most recent entry

                dwMaxIndex = gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex ;

                for(dwEntry = 0 ; dwEntry < dwMaxIndex ; dwEntry++)
                {
                    if(pValueMacroDictEntry[dwMaxIndex - 1 - dwEntry].dwSymbolID
                            == dwRefSymbolID)
                        break ;
                }
                if(dwEntry >= dwMaxIndex)
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("=MacroRef not resolved. Not defined or out of scope.\n"));
                    return(FALSE) ;
                }
                dwNewTKMindex =
                    pValueMacroDictEntry[dwMaxIndex - 1 - dwEntry].dwTKIndexValue ;


                if(dwNewTKMindex >= dwTKMindex )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("ValueMacro cannot reference itself.\n"));
                    return(FALSE) ;
                }

                //  concat valuestring onto tmpHeap.
                if(!BCatToTmpHeap(&aarNewValue, &ptkmap[dwNewTKMindex].aarValue, pglobl) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("Concatenation to produce expanded macro value failed.\n"));
                    return(FALSE) ;
                }
                break ;
            }
            case  '%':  // command parameter
            {
                if(!BdelimitToken(&aarValue, "}", &aarToken, &dwDelim) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("missing terminating '}'  in command parameter.\n"));
                    return(FALSE) ;
                }

                //  when concatenating you must restore the delimiters
                //  % and } that were stripped by DelimitToken.

                aarToken.dw += 2 ;
                aarToken.pub--  ;

                if(!BCatToTmpHeap(&aarNewValue, &aarToken, pglobl) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("Concatenation to produce expanded macro value failed.\n"));
                    return(FALSE) ;
                }

                if(aarValue.dw)
                {
                    ubChar = *aarValue.pub;
                    aarValue.dw-- ;
                    aarValue.pub++ ;    //  clip off the first char to simulate
                }
                else
                    ubChar = '\0' ;    // no more objects

                break ;
            }
            case  '"' :   // this is a string construct
            {
                if(!BdelimitToken(&aarValue, "\"", &aarToken, &dwDelim) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("missing terminating '\"'  in substring.\n"));
                    return(FALSE) ;
                }

                //  when concatenating you must restore the delimiters
                //  " and " that were stripped by DelimitToken.

                aarToken.dw += 2 ;
                aarToken.pub--  ;

                if(!BCatToTmpHeap(&aarNewValue, &aarToken, pglobl) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("Concatenation to produce expanded macro value failed.\n"));
                    return(FALSE) ;
                }

                if(aarValue.dw)
                {
                    ubChar = *aarValue.pub;
                    aarValue.dw-- ;
                    aarValue.pub++ ;    //  clip off the first char to simulate
                }
                else
                    ubChar = '\0' ;    // no more objects

                break ;
            }
            case  '\0': //  end of value string
            {
                (VOID) BeatLeadingWhiteSpaces(&aarValue) ;
                if(aarValue.dw)   //  is stuff remaining?
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("Error parsing value containing =MacroRef: %0.*s.\n",
                        ptkmap[dwTKMindex].aarValue.dw,
                        ptkmap[dwTKMindex].aarValue.pub));
                    ERR(("    only %{parameter} or \"substrings\" may coexist with =MacroRefs.\n"));
                    return(FALSE);
                }
                ptkmap[dwTKMindex].aarValue = aarNewValue ;
                return(TRUE);
            }
            default:
            {
                aarValue.dw++ ;
                aarValue.pub-- ;    //  restore the first char

                if(!BdelimitToken(&aarValue, pubDelimiters,
                    &aarToken, &dwDelim ) )
                {
                    aarToken = aarValue ;
                    ubChar = '\0' ;    // no more objects
                    aarValue.dw = 0 ;
                }
                else
                    ubChar = pubDelimiters[dwDelim];

                //  concat valuestring onto tmpHeap.
                if(!BCatToTmpHeap(&aarNewValue, &aarToken, pglobl) )
                {
                    vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
                    ERR(("Concatenation to produce expanded macro value failed.\n"));
                    return(FALSE) ;
                }
                break ;
            }
        }   //  end switch
    }       //  end while
    return(TRUE);  //  unreachable statement.
}


BOOL    BdelimitName(
PABSARRAYREF    paarValue,   //  the remainder of the string without the Name
PABSARRAYREF    paarToken,   //  contains the Name
PBYTE  pubChar )  //  first char after Name  - NULL is returned if nothing
                    //      remains.
{
    BYTE    ubSrc ;
    DWORD   dwI ;

    for(dwI = 0 ; dwI < paarValue->dw ; dwI++)
    {
        ubSrc = paarValue->pub[dwI] ;

        if( (ubSrc  < 'a' ||  ubSrc > 'z')  &&
            (ubSrc  < 'A' ||  ubSrc > 'Z')  &&
            (ubSrc  < '0' ||  ubSrc > '9')  &&
            (ubSrc  != '_')  )
        {
            break ;  // end of keyword token.
        }
    }
    paarToken->pub = paarValue->pub ;
    paarToken->dw = dwI ;
    paarValue->pub += dwI;
    paarValue->dw -= dwI ;

    if(paarValue->dw)
        *pubChar = ubSrc ;
    else
        *pubChar = '\0' ;

    return(paarToken->dw != 0) ;
}


BOOL    BCatToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL          pglobl)
/*  if paarDest->dw is zero, copy paarSrc to the temp heap
    else append paarSrc to existing Heap.
    Note:  assumes existing string in parrDest is the most
    recent item on the Heap.
    does not create null terminated strings!  */
{
    ABSARRAYREF    aarTmpDest ;

    if(!BcopyToTmpHeap(&aarTmpDest, paarSrc, pglobl))
        return(FALSE) ;
    //  append this run to existing string
    if(!paarDest->dw)  // no prevs string exists
    {
        paarDest->pub = aarTmpDest.pub ;
    }
    else
    {
        // BUG_BUG paranoid:  may check that string is contiguous
        ASSERT(paarDest->pub + paarDest->dw ==  aarTmpDest.pub) ;
    }
    paarDest->dw += aarTmpDest.dw ;

    return(TRUE);
}


BOOL    BResolveBlockMacroReference(
PTKMAP   ptkmap,
DWORD    dwMacRefIndex,
PGLOBL   pglobl)
{
    DWORD   dwRefSymbolID, dwTKIndexOpen, dwTKIndexClose,
        dwEntry, //  note used to index MacroDict and later TKmap
        dwNewTKMindex, dwMaxIndex;
    ABSARRAYREF    aarValue  ;
    PBLOCKMACRODICTENTRY    pBlockMacroDictEntry ;
    PTKMAP   pNewtkmap ;


    aarValue = ptkmap[dwMacRefIndex].aarValue ;

    if(!BeatDelimiter(&aarValue, "=") )
    {
        ERR(("expected a =MacroName as the only value of *InsertBlockMacro keyword.\n"));
        return(FALSE);
    }

    if(!BparseSymbol(&aarValue,
        &dwRefSymbolID,
        VALUE_SYMBOL_BLOCKMACRO, pglobl) )
    {
        return(FALSE) ;
    }

    //  search BlockMacro Dict starting from most recent entry

    pBlockMacroDictEntry =
        (PBLOCKMACRODICTENTRY)gMasterTable[MTI_BLOCKMACROARRAY].pubStruct ;

    dwMaxIndex = gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex ;

    for(dwEntry = 0 ; dwEntry < dwMaxIndex ; dwEntry++)
    {
        if(pBlockMacroDictEntry[dwMaxIndex - 1 - dwEntry].dwSymbolID
                == dwRefSymbolID)
            break ;
    }
    if(dwEntry >= dwMaxIndex)
    {
        ERR(("=MacroRef not resolved. Not defined or out of scope.\n"));
        return(FALSE) ;
    }

    dwTKIndexOpen =
        pBlockMacroDictEntry[dwMaxIndex - 1 - dwEntry].dwTKIndexOpen ;

    dwTKIndexClose =
        pBlockMacroDictEntry[dwMaxIndex - 1 - dwEntry].dwTKIndexClose ;

    if(dwTKIndexOpen == INVALID_INDEX  ||   dwTKIndexClose == INVALID_INDEX )
    {
        ERR(("Macro cannot be referenced until it has been fully defined.\n"));
        return(FALSE);
    }

    pNewtkmap = (PTKMAP)gMasterTable[MTI_NEWTOKENMAP].pubStruct ;

    for(dwEntry = dwTKIndexOpen + 1 ; dwEntry < dwTKIndexClose ; dwEntry++)
    {
        //  transfer all tokenmap fields to newTokenMap
        //  except NULL entries.

        if(pNewtkmap[dwEntry].dwKeywordID == ID_NULLENTRY)
            continue ;
        if(!BallocElementFromMasterTable(
                MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_NEWTOKENMAP ;
            return(FALSE);
        }
        pNewtkmap[dwNewTKMindex] = pNewtkmap[dwEntry] ;
    }
    return(TRUE);
}


BOOL    BDefineBlockMacroName(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl)
{
    DWORD   dwBlockMacroEntry, dwSymbolID ;
    PBLOCKMACRODICTENTRY    pBlockMacroDictEntry ;

    if(!BeatSurroundingWhiteSpaces(&pNewtkmap[dwNewTKMindex].aarValue) )
    {
        vIdentifySource(pNewtkmap + dwNewTKMindex, pglobl) ;
        ERR(("syntax error in BlockMacro name.\n"));
        return(FALSE);
    }

    dwSymbolID = DWregisterSymbol(&pNewtkmap[dwNewTKMindex].aarValue,
                               CONSTRUCT_BLOCKMACRO, TRUE, INVALID_SYMBOLID, pglobl ) ;
    if(dwSymbolID == INVALID_SYMBOLID)
        return(FALSE);


    if(!BallocElementFromMasterTable(
            MTI_BLOCKMACROARRAY, &dwBlockMacroEntry, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_BLOCKMACROARRAY ;
        return(FALSE);
    }

    pBlockMacroDictEntry = (PBLOCKMACRODICTENTRY)gMasterTable[MTI_BLOCKMACROARRAY].pubStruct ;

    pBlockMacroDictEntry[dwBlockMacroEntry].dwSymbolID = dwSymbolID ;
    pBlockMacroDictEntry[dwBlockMacroEntry].dwTKIndexOpen = INVALID_INDEX ;
    pBlockMacroDictEntry[dwBlockMacroEntry].dwTKIndexClose = INVALID_INDEX ;

    return(TRUE);
}



BOOL    BIncreaseMacroLevel(
BOOL    bMacroInProgress,
PGLOBL  pglobl)
//  called in response to parsing open brace.
{
    DWORD   dwMacroLevel ;
    PMACROLEVELSTATE    pMacroLevelStack ;

    if(!BallocElementFromMasterTable(
            MTI_MACROLEVELSTACK, &dwMacroLevel, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_MACROLEVELSTACK ;
        return(FALSE);
    }

    pMacroLevelStack = (PMACROLEVELSTATE)gMasterTable[MTI_MACROLEVELSTACK].pubStruct ;

    pMacroLevelStack[dwMacroLevel].dwCurBlockMacroEntry =
        gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex ;
    pMacroLevelStack[dwMacroLevel].dwCurValueMacroEntry =
        gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex;
    pMacroLevelStack[dwMacroLevel].bMacroInProgress =
        bMacroInProgress  ;

    return(TRUE);
}

BOOL    BDecreaseMacroLevel(
PTKMAP  pNewtkmap,
DWORD   dwNewTKMindex,
PGLOBL  pglobl)
//  called in response to parsing close brace.
{
    DWORD   dwMacroLevel, dwCurBlockMacroEntry, dwCurValueMacroEntry ,
        dwTKIndexOpen, dwTKIndexClose,
        dwTKMindex,  //  location of expired macros.
        dwEntry;  // index value and block macro dicts
    BOOL    bMacroInProgress ;
    PMACROLEVELSTATE    pMacroLevelStack ;
    PBLOCKMACRODICTENTRY    pBlockMacroDictEntry ;
    PVALUEMACRODICTENTRY    pValueMacroDictEntry ;

    if(!gMasterTable[MTI_MACROLEVELSTACK].dwCurIndex)
    {
        ERR(("Too many closing braces.  Fatal syntax error.\n"));
        geErrorSev = ERRSEV_FATAL ;
        geErrorType = ERRTY_SYNTAX  ;
        return(FALSE);
    }


    pBlockMacroDictEntry = (PBLOCKMACRODICTENTRY)gMasterTable[MTI_BLOCKMACROARRAY].pubStruct ;
    pValueMacroDictEntry = (PVALUEMACRODICTENTRY)gMasterTable[MTI_VALUEMACROARRAY].pubStruct ;
    pMacroLevelStack = (PMACROLEVELSTATE)gMasterTable[MTI_MACROLEVELSTACK].pubStruct ;
    dwMacroLevel = --gMasterTable[MTI_MACROLEVELSTACK].dwCurIndex;
    dwCurBlockMacroEntry = pMacroLevelStack[dwMacroLevel].dwCurBlockMacroEntry ;
    dwCurValueMacroEntry = pMacroLevelStack[dwMacroLevel].dwCurValueMacroEntry ;
    bMacroInProgress = pMacroLevelStack[dwMacroLevel].bMacroInProgress ;


    //  Does this closing brace end a macro definition?

    if(bMacroInProgress)
    {
        if(pBlockMacroDictEntry[dwCurBlockMacroEntry - 1].dwTKIndexClose
                != INVALID_INDEX)
        {
            ERR(("Internal Error: macro nesting level inconsistency.\n"));
            geErrorSev = ERRSEV_FATAL ;
            geErrorType = ERRTY_CODEBUG ;
            return(FALSE);
        }
        pBlockMacroDictEntry[dwCurBlockMacroEntry - 1].dwTKIndexClose =
            dwNewTKMindex ;  // location of } in newtokenArray;
    }

    //  remove all traces of expired block and value macro definitions

    for(dwEntry = dwCurValueMacroEntry ;
        dwEntry < gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex ;
        dwEntry++)
    {
        dwTKMindex = pValueMacroDictEntry[dwEntry].dwTKIndexValue ;
        pNewtkmap[dwTKMindex].dwKeywordID = ID_NULLENTRY ;
    }

    for(dwEntry = dwCurBlockMacroEntry ;
        dwEntry < gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex ;
        dwEntry++)
    {
        dwTKIndexOpen = pBlockMacroDictEntry[dwEntry].dwTKIndexOpen ;
        dwTKIndexClose = pBlockMacroDictEntry[dwEntry].dwTKIndexClose ;
        for(dwTKMindex = dwTKIndexOpen ; dwTKMindex <= dwTKIndexClose ;
            dwTKMindex++)
            pNewtkmap[dwTKMindex].dwKeywordID = ID_NULLENTRY ;
    }

    if(bMacroInProgress  &&  gdwVerbosity >= 4)
    {
        VEnumBlockMacro(pNewtkmap,
                pBlockMacroDictEntry + dwCurBlockMacroEntry - 1, pglobl) ;
    }

    //  must ensure these values are restored even in the event
    //  of premature return;
    gMasterTable[MTI_BLOCKMACROARRAY].dwCurIndex = dwCurBlockMacroEntry;
    gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex = dwCurValueMacroEntry;

    return(TRUE);
}


VOID    VEnumBlockMacro(
PTKMAP  pNewtkmap,
PBLOCKMACRODICTENTRY    pBlockMacroDictEntry,
PGLOBL  pglobl )
{
    DWORD   dwTKIndexOpen, dwTKIndexClose, dwTKMindex ;

    dwTKIndexOpen = pBlockMacroDictEntry->dwTKIndexOpen ;
    dwTKIndexClose = pBlockMacroDictEntry->dwTKIndexClose ;

    ERR(("\nContents of Block Macro ID value: %d at:\n",
        pBlockMacroDictEntry->dwSymbolID)) ;
    vIdentifySource(pNewtkmap + dwTKIndexOpen, pglobl) ;

    for(dwTKMindex = dwTKIndexOpen + 1 ; dwTKMindex < dwTKIndexClose ;
        dwTKMindex++)
    {
        if(pNewtkmap[dwTKMindex].dwKeywordID == ID_NULLENTRY)
            continue ;

        ERR(("    %0.*s : %0.*s\n",
            pNewtkmap[dwTKMindex].aarKeyword.dw,
            pNewtkmap[dwTKMindex].aarKeyword.pub,
            pNewtkmap[dwTKMindex].aarValue.dw,
            pNewtkmap[dwTKMindex].aarValue.pub
            ));
    }
}


//  ----   scrap pile - may find some useful odds and ends here -----

//                gMasterTable[MTI_VALUEMACROARRAY].dwCurIndex-- ;
                //  remove macrodef from dictionary.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\memtrack.h ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  memtrack.h - debug memory allocation functions   */

#if 0

#ifndef KERNEL_MODE

#undef  MemAllocZ
#undef  MemAlloc
#undef  MemFree

PVOID   MemAllocZ(DWORD) ;
PVOID   MemAlloc(DWORD) ;
VOID    MemFree(PVOID) ;

#define  MEMTRACK   1

#endif

#endif


//  insert into one source function:
/*  comment out here to prevent re-definition

#ifdef  MEMTRACK

PVOID   MemAllocZ(DWORD dwSize)
{
    PVOID   pv ;

    pv = (PVOID) LocalAlloc(LPTR, dwSize) ;
    ERR(("allocated %d zeroed bytes at address %X\n", dwSize, pv)) ;
    return(pv);
}

PVOID   MemAlloc(DWORD dwSize) ;
{
    PVOID   pv ;

    pv = (PVOID) LocalAlloc(LMEM_FIXED, dwSize) ;
    ERR(("allocated %d bytes at address %X\n", dwSize, pv)) ;
    return(pv);
}

VOID    MemFree(PVOID   pv) ;
{
    ERR(("Freeing memory at address %X\n", pv)) ;
    if(pv)
        LocalFree((HLOCAL) pv) ;
    return ;
}

#endif

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\notes.c ===
#if 0

now:

rip out code that sets RulesAble flag.
Maybe recognize hex integers.
UIGroups

rip out check for cursor origin same as printable origin.






update docs with *IgnoreBlock and *Macros constructs.
note we require =Macroname not to have a space between.

new rule:  the value of any ValueMacro must be a syntatically valid
value all by itself.
for example
    parenthesis: (
is not a legal macro value since '(' is not a valid value by itself.

ValueMacro references may not appear within "quoted strings"
or %{param constructs}.







update declares.h


if you need to fudge *Color?  go to snapshot.c  and look for

    if(dwGID == GID_COLORMODE   &&
        ((PCOLORMODEEX)pubDestOptionEx)->bColor )
    {
        pUIinfo->dwFlags |= FLAG_COLOR_DEVICE ;
    }


eventually maybe add function callbacks to the snapshot table
which will provide different defaults depending on the
value of other structures in the bud file.

think about this:
zhanw wants multiple *case to refer to one block.
just like in 'C'.




classify errors into Errors and Warnings
assign each message a verbosity threshold.



more intentional errors for sample file.

complete warning of NON_LOCALIZEABLE keywords
add DisableMultipleCompression?  keyword for alvin.

flag a warning if any *name keyword is
present.





remove hardcoded globals from parser.





could delete 4 unnecessary indicies in mrbd structure.




should parser synthesize an extra %
if a literal % is found in a command
invocation?





code review of command:  move initoperPrecedence to
framwrk1.c
move list of delimiters to gpd.h




------

-----


---- Sanity checks as time permits ----

verify a movement and resolution units are multiples
of the masterunits.

verify there is no switch dependence on pickmany types of
features.

check that number of features and number of options
in each feature does not exceed 255.

if any parameter in a command uses MAXLIMIT(),  it must
be the ONLY parameter in the command.

during BInterpretTokens()  if a syntax error occurs, the
return value is set to false, but it is completely ignored.
No error condition is raised or anything!
examples:  mismatched closing braces


are all required fields for each GID type
present?  if not are there acceptable
defaults?   if not warn user.

check all papersizes against
*MinSize and *MaxSize defined for
a custom papersize to make sure they are
in range.   warn user if not.
If no cust size defined skip the check.



----  far in the future: -----



countrycode  as an implicit feature.
The current value is set at snapshot time.



state1.c : initAllowedTransitions
change FEATURE_FF so its only valid for states:
STATE_FEATURE, STATE_CASE_FEATURE and  STATE_OPTION_FEATURE









BUG_BUG !!!!!

check that all cases are terminated by break.

flags being set by |=  not just =.

always check to see dwKeywordID is a valid value before
using it to access any table.
ensure any failure clears tokenmap.flags.

are copies of aarValue being used when tkmap->aarValue
is required?  and vice versa?

Search through all uses of enumeration constants to verify
code does not need updating due to fact I added more
items to the list.

also symbol tree roots.  gdwTTFontSymbols
    with prefix m  since they are actually macros.

update each module header with correct function declarations.

not implemented:   factor out first part of qualified
    name outside of LIST construct.


be sure to clarify what structures are referenced from
UIInfo and which must be referenced from the offset pointer.


provide an overview of the attribute storing processing
use handwritten notes as a guide.


are tkmap flags like TKMF_COLON set when they should not be?


probably give shorthand version of *Command a
different name so there is no confusion .

features to implement:
---------------------


go through and fix the highest priority BUG_BUG!!!!! s.

implement shortcut converter and rip out hack code.






Testing hints:
------

must test all code in constrnts.c  and the
constraints code in helper1.c   I have changed
BexchangeDataInFOATNode().



an acid test of determinedefault option
is to make each default option multivalued
and use dependencies which conflict with
the default priority array.

make some features printer sticky, like interleave them.

VOID    VinitAllowedTransitions() ;   throwaway bp.
BOOL   BInterpretTokens( see keyword - value strings.
BOOL    BparseAndTerminateString(  unicode Xlation
BOOL BpostProcess(




create some defaultoptions with an upside down
dependence, forcing the priority array to be re initialized.

note looking at BarchiveStrings or BcopyToTmpHeap  is
a great way to see what is being parsed as a keyword and value!

test symbol registry by creating multiple features each
with multiple options.  Also by defining more features for
the same option in a separate section.
In fact alternate two or more feature definitions
to cause searches through several layers.

maybe nested switch constructs too.

BscanStringSegment().
try strings containing %"  or %< chars  or real
hex substrings.

prepend whitechars  and other forms of
arbitrary whitespace to keywords and insert between
tokens.  Try continuation lines etc.

try various types of constructs terminated immediately
by eof.

try some include files (nested includes too!)

make some symbol keywords.


{, }


keywords without : or values.

keywords or statements terminating with { or }.


try some fully invalid keywords.
try some structure or non-attribute keywords.
preface keyword with the EXTERN_GLOBAL or EXTERN_FEATURE
tag.  (BidentifyAttributeKeyword)

try some improper syntaxes.


test every type of value.
Lists etc.


attribute trees:

global initializer

then add switch conditionals.

do this both outside and within a feature/option construct.

remember to write down at allocation time
the address of the heap.

force propagation of lower level values as default initializers
by causing the tree to branch out more.

----- done ----

at high verbosity level, emit
keyword and value strings of all block macros
when fully defined.   And all keywords that reference
value macros.



force an error by defining this valuemacro:
MacroName: =MacroName "stuff"


note that all error messages need to be check to see
that
            vIdentifySource(ptkmap + dwTKMindex) ;
and other ERR messages that reference ptkmap
don't suffer from cut and paste syndrome.


note: when passing values to register symbol or whatever, you
must first strip the leading '=' since this is not automatically done.
need to fix for ?




debug   BdelimitName and BResolveValueMacroReference
must modify token1.c so it allows scanning for tokenRefs
within ().

ganesh wants invocation.dwcount to be initialized with
CommandIndex.

if a construct keyword is not recognized,
ignore everything up to matching closing brace.

If an error occurs parsing a construct , say missing a
required symbol, the entire body of the construct
enclosed by braces should be deleted.


implement by creating an IGNORE_STATE ?
could define a specific keyword that
can serve to ifdef out large chunks of code.


init  MINIRAWBINARYDATA  gmrbd ;


maybe add an new entry to the constants table
just after the {NULL, BOOLEANTYPE}
separator:  this will contain {"Boolean class", 0}

and the indexing code will skip this when constructing
the index.  However, we can find it by subtracting 1
from the start index.

also modify BOOL    BparseConstant(  in value1.c

postproc.c

let    BIdentifyConstantString(&arSymbolName,
                    &dwDevmodeID, dwConsClass)
    take a fourth param:  bCustomOptOK
    if true, then a much less severe warning is emitted.

also modify so it emits the class string instead
of a number.


add global to control warning level.
elaborate enumeration class messages, is such
a message fatal (ie SERIAL, PAGE)  or is it
tolerable (Option3) ?   give a friendly
explaination.   Enum Class 31  - what's that?


re-enabled *MaxNumPalettes for alvin to use.
default value is now 0.

add RIP if MAX_GID exceeds 32.


remove if DBCS from postproc.c

abort and retry if number of entries exceeds
dictionary size in framwrk1.c
also implement in sanpshot.c   see DwInitSnapShotTable2

new standard var:  rop3
another keyword:  *MirrorRasterByte?   in globals.

add to semantics check:
    *Helpindex value must be non-zero.


update constants for printingrate
move private defines out of gpdparse.h



Synthesize installable features for *Installable keyword.


Initialize missing fields with defaults.
sanity checks, features with zero options etc.
emit warning messages if needed.

set the priority array using *DefaultOption
(if needed) what other structures need to be saved?

reflect UIConstraints after parsing keywords.

convert Installation constraints list to UIConstraints
reflect as needed.

(from Zhanw: gpd changes)
I added two entries for custom help support:
- one global entry: *HelpFile which specifies the custom help file name.
- a generic entry for any feature/option: *HelpIndex which specifies the specific help index for that item.
CmdFF and CmdCR.

ganesh wants to split parser into DLL + lib.

modify Halftone processing in Postproc.c
to conform to alvins mail.



Alvin wants new keyword: count of halftone matricies

implement TTFontSub construct processing code.



Later a codepage keyword will let the parser know
whether to interpret such strings as single or double byte.

modify macro in gpd.h so a non-existent command
will cause a NULL to be returned , ganesh wants same for
fontlist.

Notes:  UNUSED_ITEM  will be used whenever a dword value, ResourceID
    has not been explicitly specified in the GPD file.
an empty list of items will be denoted by the value END_OF_LIST
instead of a valid index to the first listnode.



    warning GPD keywords missing from snapshot:
    ATREEREF     atrOptimizeLeftBound;  //   "OptimizeLeftBound?"
    ATREEREF     atrStripBlanks;  //   "StripBlanks"
    ATREEREF     atrRasterZeroFill;  //   "RasterZeroFill?"
    ATREEREF     atrRasterSendAllData;  //   "RasterSendAllData?"
    ATREEREF     atrCursorXAfterSendBlockData;  //   "CursorXAfterSendBlockData"
          Option Attribute:  *PromptTime
    ATREEREF     atrIPCallbackID;  //   "IPCallbackID"
    ATREEREF     atrColorSeparation;  //   "ColorSeparation?"
                atrMinStripBlankPixels  // a resolution option
    ATREEREF     atrColor;  //   "Color?"
    ATREEREF     atrDrvBPP;  //   "DrvBPP"
    ATREEREF     atrRotateSize;  //   "RotateSize?"





    /*   UIINFO fields not initialized in Snapshot :

    loNickName
    ARRAYREF        UIConstraints;              // array of UICONSTRAINTs
    ARRAYREF        UpdateRequiredItems;        //
    ARRAYREF        InvalidCombinations;        // array of INVALIDCOMBOs
    DWORD           dwMinScale;                 // mimimum scale factor (percent)
    DWORD           dwMaxScale;                 // maximum scale factor (percent)
    DWORD           dwLangEncoding;             // translation string language encoding
    DWORD           dwLangLevel;                // page description langauge level
    INVOCATION      Password;                   // password invocation string
    INVOCATION      ExitServer;                 // exitserver invocation string
    DWORD           dwProtocols;                // supported comm protocols
    DWORD           dwJobTimeout;               // default job timeout value
    DWORD           dwWaitTimeout;              // default wait timeout value
    DWORD           dwTTRasterizer;             // TrueType rasterizer option
    FIX_24_8        fxScreenAngle;              // screen angle - global default
    FIX_24_8        fxScreenFreq;               // screen angle - global default
    PTRREF          loFontInstallerName;        //
                                        dwFreeMem) ;

    /*   FEATURE fields not initialized in Snapshot :

    DWORD           dwNoneFalseOptIndex;        // None or False option index
    INVOCATION      QueryInvocation;            // query invocation string
    DWORD           dwFirstOrderIndex;          //
    DWORD           dwEnumID;                   //
    DWORD           dwEnumFormat;               //
    DWORD           dwCurrentID;                //
    DWORD           dwCurrentFormat;            //
        dwInstallableFeatureIndex) ;  not needed by snapshot.
        dwInstallableOptionIndex) ;
        dwUIConstraintList) ;

    /*   OPTION fields not initialized in Snapshot :

    INVOCATION      Invocation;                 // invocation string
        use sequenced command list instead.
    DWORD           dwUIConstraintList;         // index to the list of UIConstraints
    DWORD           dwOrderIndexNext;           //
    DWORD           dwInvalidComboIndex;        //
    DWORD           dwInstallableOptionIndex;   //


How do I initialize the various
    DWORD       dwFlags;                        // flag bits
    for various options from the GPD information?


!    DWORD           dwTechnology;               // see TECHNOLOGY enumeration
    what should this be set to?

There is no GPD keyword corresponding to
    uiinfo.loPrinterIcon.
        szMaxExtent) ;
        szMinExtent) ;

    papersizeoption.rcMaxExtent) ;
                rcMinExtent


    MemoryOption.dwFreeFontMem

    resolution.wDefaultDithering) ;



wFlags is mispelled in COLORMODEEX.

change to be a string!     dwSpecVersion) ;

ARRAYREF        CartridgeSlot;              // array of font cartridges names
    will now be
ARRAYREF        FontCartridges;              // array of font cartridge structures
    holds same arrayref as  GPDDrvInfo.DataType[DT_FONTSCART]


deleted from GPD spec:

    ATREEREF     atrSimulateXMove;        // "SimulateXMove"
    VectorOffset, ColorSeparation


MemoryForFontsOnly is now MemoryUsage?
add *Min/MaxGrayFill



CRC checksum
Date and time stamping
Bug preventing enumeration of UserDefined
    papersizes.

implement sematchk.c

lots of work to make sure we can handle option = FF
in all helper functions, and disabled features.



fix BInterpretTokens to elaborate error message:
which keyword is bad?

Do lines starting with a comment cause warnings? (no!)
maybe should run eat white spaces first!

test partially qualified name.
Test InvalidCon with just 2 items.

new pallete entries in colormode option find old e-mail.
(delete global entries find BUG_BUG!)


First InputSlot should be left uninitialized
and say "Use Form To Tray assignment"
paperbin = DMBIN_FORMSOURCE  I have no such bin!



implement *ConflictPriority, and 2 new keywords. see Zhanw's mail.

Also modify priority array code to assign higher priority
to printer sticky options.  In order they will be
Highest : Synthesized options
Higher  : printer sticky
Lowest  : doc sticky

Also implement a new keyword which allows user to
set relative priorities of doc and printer sticky
options.  (but keeps lists separate)



cannon wants to be able to specify the priority of
each feature.  but all synthesized options will have a
higher priority than non-synthesized.


update framwrk1.c to use new Installable keywords.


    copy master units to UIinfo when amanda updates parser.h
    verify bug and fix value1.c page 16.
    add PT_TTY to printertype.
At this time update
    instructions for adding new keywords to snapshot.c


    Postprocessing.
    must grovel through symbol tree and initialize
    atrFeaKeyWord and atrOptKeyWord for each feature and option.
    and translate from ansi to unicode

    set flags field in UIinfo.

newkeywords:  replace with actual defs in gpd.h
    ATREEREF     atrYMoveAttributes;        // "YMoveAttributes"
    ATREEREF     atrMaxLineSpacing;        // "MaxLineSpacing"
        do we special case its default?
    ATREEREF     atrMinGlyphID;        // "MinGlyphID"
    ATREEREF     atrMaxGlyphID;        // "MaxGlyphID"
    ATREEREF     atrDLSymbolSet;        // "DLSymbolSet"
        need to add its constants class
    ATREEREF     atrHelpFile;        // "HelpFile"
                atrCodePage     //"CodePage"
    ATREEREF     atrOptHelpIndex;        // "HelpIndex"
    ATREEREF     atrFeaHelpIndex;        // "HelpIndex"
        both Features and Options keyword.

    finish updating snapshot once gpd is updated.

    *PromptTime should be a Option only keyword.

    also init GID and option count for each feature.
    assume a normal dwGID and dwNumOptions field exists in DFEATURE_OPTION
    and it has been initialized as part of postprocessing.


    priority field is properly initialized at postprocessing?

    When assigning paperIDs to various papersize options,
    fill in paper dimensions if not already explicitly initialized
    note assign the custom paper DMPAPER_USER, and any
    driver defined paper sizes values larger than that.

    determine these by counting # setting for FeatureType keyword.
    pmrbd->dwDocumentFeatures;
    pmrbd->dwPrinterFeatures;

    search for all occurances of VALUE_STRING and
    replace by one of the 3 variants.

    use AP_APC to map filenames
    use *CodePage to map display strings and fontnames
    ParserVersion, symbolnames leave in ansi.
    define subvalues to control string translation.
    and key the unicode Xlation accordingly.
    Note: The *CodePage keyword affect the parsing of
    all applicable strings encountered after the *CodePage keyword.
    The *CodePage keyword my be subsequently re-defined.

    add dwSpecVersion field to MINIRAWBINARYDATA, convert string version
    stored in global attributes atrGPDSpecVersion to 2 words
    and store here during postprocessing.

    replace points with pairs

add single and double byte to unicode converter.
where should this be placed?  Note name of include file
uses a string, but should not be converted make this flag
controllable or define a new value, TO_UNICODE?.
remember:  Davidx says store Unicode strings on Word boundary.

line duplicated: postproc.c line 209.
        arSymbolName = psn[dwFeatureIndex].arSymbolName ;
remove before flight in value1.c

ExchangeDataInFOATNode needs changing: specifically,
it exchanges the dword at the heapoffset not the heapoffset
itself.   Need to change it so it can handle arbitrary sized
data.


replace rawbinary data by pinfo hdr for 2 functions:

GpdChangeOptionsViaID(
    IN PINFOHEADER  pInfoHdr ,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    )

GpdMapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2
    )



    collation and page protect use the predefined options
    ON/OFF, should assign these options optionID values of
    1/0 respectively.   need to modify  BinitSpecialFeatureOptionFields()
    in postproc.c


    when amanda adds collate to Parser.h, remove my private
    def from gpdparse.h

    also transfer my defs in snapshot.h to gpd.h

RotateRasterData? is now RotateRaster?
*YMoveUnits is now *YMoveUnit   (same for X)


GPDSpecVersion string not set.
snapshot.c : 400,000   is invalid syntax.

Last line of gpdloadrawbinarydata - snapshot.c
should be return(NULL);

atrPageDimensions) ; Is not required for custom papers.

Why are all except 2 items in the GID array NULL ?
and one is -1 ?   not repro.

prepare for reading resources from dll.  copy pcl5ems.dll
to printers directory.  check that RC values are correctly
initialized.

has the enum constant for the keyword
CursorXafterCR been changed from AT_GRXDATA_ORIGIN
to AT_CURSOR_X_ORIGIN ?  if so change spec and parser.

cause entire number string to be printed as an error
value1.c  -  line 552.


change GpdChangeOptionsViaID so
if paperID doesn't match, fall back to paper dimensions.
This is because the Spooler assigns new papers
IDs on a first come first serve basis.

why is test.gpd locked?
bug fix for uninitialized *CursorOrigin

snapshot.c 1467
        if(dwFlags & SSF_RETURN_UNINITIALIZED)
            return(TRI_UNINITIALIZED) ;

gpdparse.h     1448

#define     SSF_RETURN_UNINITIALIZED        0x00000200
    //  if no value exists, cause EextractValueFromTree
    //  to return TRI_UNINITIALIZED, but don't complain
    //  to user.

snaptbl.c  1849
    pmrbd->snapShotTable[dwI].dwFlags = SSF_RETURN_UNINITIALIZED ;

suppress the no integer found message by
not calling parseinteger if LIST code detects
nothing is there (dwCount = 0).


major bugs found in installable feature code!

Why did BparseInvalidInstallableCombination mess up
unable to recognize the option name?

Currently ExchangeDataInFOATNode
stores dwSynFea into dwFeature of patt.
Yet to the rest of the Snapshot code
this isn't SynFea 0 or 1, its Feature 8 or 9!

Verify no one in the snapshot accesses anything via
SynFea, then modify the two Exchange functions
when SynFea = TRUE.



note:  features must be synthesized after most postprocessing
    has occured so that constraints and things have been
    processed, but just before priority array is initialized.

new function:
 if(!BfindMatchingNode(&atrCur, dwFeature, dwOption))


BexchangeDataInFOATNode  and  BexchangeArbDataInFOATNode
    2 changes:  add new boolean bSynFeature
    dwIn is now pdwIn,  if this is NULL,
    this means we don't want to alter the attribute tree.


Handling of special keywords during the 2nd pass:

*InvalidInstallableCombination:
    parse into links of INVC nodes, with the
    new invalidcombo field of the first node
    pointing down to another invalid combo.
    A new field in the GlobalAttributes structure
    will point to the first (most recently created)
    INVC list.

    See state1.c  SPEC_INVALID_INS_COMBO
     currently calls BparseInvalidCombination()



*NotInstalledConstraints:
*InstalledConstraints:
    parse just like a normal constraint except the root
    is placed in the appropriate field.  Note there are two
    types:  LocalFeature and LocalOption.  Will the single
    function handle both?  Apparently yes.



*Installable:  treat just like another non-relocatable attribute.

after the 2nd pass, can FeaOpt array to see how many
Installable fields are set to TRUE.  (count both Fea and Opts)

Allocate this many synthesized features.

Scan FeaOpt array and link the Installable Feature/Option
with its synthesized feature using the links.

create a default list of Constraints that says SynFea/Not Installed
constrains  all options of the associated InstallableFeature/All
except option zero.   or if an installable option was specified
only one constraint constraining that one Fea/Option is synthesized.


copy the links for
*NotInstalledConstraints:
*InstalledConstraints:
to the associated Synthesized Feature/Installed
                            Feature/Not Installed
                                options.

look at each InvalidInstallableCombination
dereference each Qualified name , replace by associated
Synthesized Feature/Installed, and link to each SyntheFea.
No wildcards needed here.

must set breakpt in KM and see why GpdMapToDeviceOptIndex
keeps getting hit.


    return value is FALSE if every option for this
    feature is constrained (as may well be the case for
    an installable feature.)  Note, setup of sequenced
    commands may want to call these functions to determine
    if a command should be sent.
    How would init default option array work?  (just see if
    feature is constrained and automatically set option = FF)

make sure
          (WORD)pinvc[dwICNode].dwOption == (WORD)DEFAULT_INIT))
is handled properly everywhere!
if we define DEFAULT_INIT appearing in a constraint as matching
all options except index 0, then features don't have to be disabled,
and no special case code need be written!  to take care of FF
etc.

What about installable features?
if a feature is declared installable,
and the feature is specified to be NOT installed,
the option value for that feature must be set to
Don't care.   All the Constraints helper functions will
interpret a DON'T_CARE value as an anti wildcard that
doesn't match any option.
Must also modify code to make sequenced commands and
any code to expect an option may be don't care.

complete and test UI constraints helper functions.

check out latest GPD converted files and resources.
attempt to eliminate all warning messages during parsing.

what is needed to fully sync to latest stuff?

should an empty list be permitted?  YES.

this is called twice if first is successful!  memory leak!
in snapshot.c  line 3438
    if (!(pRawData = GpdLoadCachedBinaryData(ptstrDataFilename)))


    add new keywords for rectangle fills.  see alvin's
    mail.

    need to implement both helpstring and help index.
    revise gpd spec.

    fix CL_CONS_PAPERSIZE   DMPAPER_USER
    so it compares dwDevmodeID not FeatureID.



    initialize fields in minirawdata so when test.bud is
    loaded, it won't get rejected by the parser.

    debug all remaining code.


    verify all keywords are enumerated in snapshot.c


    don't restore DFEATURE_OPTIONS.atrGIDvalue - leave as dwGID

    test BwriteUnicodeToHeap.


    The split and combine helper function must recognize
    *FeatureType.

    decide what fields need to be updated as a result of
    the user changing a feature selection.
    Write this helper function.  Add optimization to return quickly
    if no update is required.

more special processing:
to save time do this only if atrModelName is not
initialized.  must load resource file and extract
Unicode string at atrModelNameID
and add to stringheap then place offset
in atrModelName.


    wait for constants to be defined for *DLSymbolSet
    and for ROMAN-8 .  and for Halftone options.



         ---  obsolete -----
no need to implement wildcards.
if the attribute tree for invalidcombinations
is allowed to contain the node  dwOpt = (WORD)DEFAULT_INIT
then the helper function accessing any InvalidCombo tree must
check for option = (WORD)DEFAULT_INIT as well as for dwOpt
if dwOpt != 0.   If an InvalidCombo node is encountered
containing [dwFea1, (WORD)DEFAULT_INIT]  this matches dwFea1, any
non-zero dwOpt.  So why (WORD) truncation?  Why not store as
dword?

should eventually remove the fully qualified pathname hack
I made since this is better implemented in
resource caching of dll.  (binary file should not be
installation dependent.  If GPD defines multiple
dlls, this hack will fail.




Locality stuff.


change from arrayref to dword:
iMin and MaxOverlayID in Globals.  ?




* if open brace is missing after a construct keyword, must
flag this as a fatal error.

* When consolidating data, add DWORD padding between each block of data.
Also need to free dest block of memory!

* BparseConstant()
should first check to see if strlen matches before
doing string compare.

* BstoreCommandAttrib()  note must compare string(dwCommandID)
with string associated with commandID.

* must change eOffsetMeans to VALUE_AT_HEAP after we write
something there.

* state1.c  BUG_BUG:   openbrace encountered
make this a fatal syntax error.


* mismatched braces should be considered a fatal error.
see PopStack().

* error parsing a construct should be considered a fatal error
due to messing up the stack.



* BidentifyAttributeKeyword  currently fails to identify any
keyword with TKMF_EXTERN_ flag set.

* Register symbol doesn't even check for NULL symbol
(aar.dw = 0)  or TKMF_NOVALUE !



give newtokenmap its own memory buffer else this buffer
will get freed twice.  But leave as is for now since the
GP fault allows me to set breakpts.


add comment saying all string refs use resourceptr.

look for MemAlloc  , if fails, make sure
            geErrorSev = ERRSEV_FATAL ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
are set.

also look for BUG_BUG comments of the type paranoid
or internal cons error.  also make this a fatal error.




When modifying DWregisterSymbol()   update
all references to this by doing fgrep in *.c *.h
and declarations too!

        eConstruct = CONSTRUCT_OPTION, CONSTRUCT_FEATURE  :



------  notes for amanda: -----

defaults if keyword is missing from GPD file:

pwstrResourceDLL:  0 or NULL  (strings)
iMaxNumPalettes:  NO_LIMIT_NUM means unlimited.  (int, dwords)
dwBadCursorMoveInGrxMode:  END_OF_LIST  means empty list.
dwDefaultCTT: NO_RC_CTT_ID
 0 normally indicates no resource.

ptMaxPrintableArea: (0, 0) means unlimited.
dwMaxLineSpacing:  UNUSED_ITEM    driver must compute the correct value
dwSymbolSetID: UNUSED_ITEM
iHelpIndex:  UNUSED_ITEM
dwIPCallbackID: 0 indicates no callback.
ptPrinterCursorOrig: WILDCARD_VALUE   assume cursor origin is same
    as printable origin.



typedef enum _UIDATATYPE {
    UIDT_FEATURE,
    UIDT_OPTION,
    UIDT_OPTIONEX,
    UIDT_CONSTRAINT,
    UIDT_GROUPS,
    UIDT_LISTNODE,                        // holds a LIST of dword values
    UIDT_FONTSCART,                       // list of FontCartridges
    UIDT_FONTSUBST,                       // Font Substitution table.

    UIDT_LAST
} UIDATATYPE;


add this to UIINFO:

DWORD   dwWhichBasePtr[UIDT_LAST] ;


#define     BASE_USE_RESOURCE_DATA  0x0001

Determine which BasePtr to use as follows:

if(uiinfo.dwWhichBasePtr[UIDT_GROUPS] & BASE_USE_RESOURCE_DATA)
    ptr = pubResourceData + loOffset ;
else
    ptr = (PBYTE)pInfoHeader + loOffset ;


PaletteSizes and PaletteScope should not be arrayrefs.
They are lists.



------ modification of zhanw's gpd files: ----

replace =Macroname with "Macroname"

comment out *Include:

must remove all uses of the shortcut *Command: name: "invocation"

EXTERN_GLOBAL:  must have the colon.

Add *CodePage: 1252  near front of file.


Add
        *SpotDiameter:100
to each resolution option.

Add
    *ModelName: "HP LazyJet 5Si"
    to replace *rcModelNameID

remove  Memory feature if it only
contains the shortcut
    *MemConfigKB: PAIR(9216, 7650)

    qualifiy path name as shown:
*ResourceDLL: "c:\tmp\pcl5ems.dll"

---- GPD file errors: ----

not a keyword:  EjectPageWithFF  missing ?



---  debugging process ------

build debug binary:

a) run chkbld
b) run ssync -r in \inc \unidrv \parsers  \libs  \driverui
c) run  build -c
    in \libs  \parsers  \driverui
d) prepare test.gpd  in \parsers\gpd
e) delete c:\winnt35\system32\spool\drivers\w32x86\2\test.bud
    whenever test.gpd  or parsercode is altered.

e) on the test machine run newdrvr.bat  then
    windbg notepad
f)  type

bp vinitglobals

    at the command window.
    type g  then hit <cr> everytime the "Unresolved Breakpoint"
    dialog box appears.
g) when notepad comes up click on file, page setup
h) when DRIVERUI.DLL (symbols loaded)  appears
    don't hit <cr>, instead click on set breakpoint
    and enter the actual break points you want set.
    Press Add, don't hit return until all breakpoints have
    been set.
    examples:
    BcreateGPDbinary,
    BisExternKeyword,
    BexchangeArbDataInFOATNode,
    GPDLOADCACHEDBINARYDATA
    gpdinitbinarydata
    gpdfreebinarydata
    gpdloadrawbinarydata
    gpdunloadrawbinarydata
    GpdInitDefaultOptions(
GpdSeparateOptionArray(
GpdCombineOptionArray(
GpdUpdateBinaryData(
GpdReconstructOptionArray(
GpdChangeOptionsViaID(
GpdMapToDeviceOptIndex(
BinitDefaultOptionArray


to restart debugging, clear all breakpoints,
click run / stop debugging.

return to step f)

i)  the string heap is the first element in gMasterTable.
    its address may be 147a68 no 1cd130


some parser warning messages and their source.

Warning, unrecognized keyword.
    Issued by  BInterpretTokens()  in state1.c when
    BidentifyAttributeKeyword()  returns failure.

constant value not a member of enumeration class:  nn
    Issued by BparseConstant() in value1.c

unrecognized Unidrv command name
    Issued by BstoreCommandAttrib() in state2.c

user supplied constant not a member of enumeration class nn
    Issued by BIdentifyConstantString()  in postproc.c

    enum classes:   26: standard values
                    27: Command names
                    28: feature names
                    31: Paper Source names

-------
error messages notes:

line numbers count \n and \r separately.  If
a program is using linenumbers, it should interpret
the count appropriately.

Not all errors will pinpoint a file and line number.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\semanchk.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    semanchk.c

Abstract:

    function for checking GPD semantics which involves dependency between
    entries.

Environment:

    user-mode only.

Revision History:

    02/15/97 -zhanw-
        Created it.

--*/

#ifndef KERNEL_MODE

#include "gpdparse.h"


// ----  functions defined in semanchk.c ---- //

BOOL
BCheckGPDSemantics(
    IN PINFOHEADER  pInfoHdr,
    POPTSELECT   poptsel   // assume fully initialized
    ) ;

// ------- end function declarations ------- //


BOOL
BCheckGPDSemantics(
    IN PINFOHEADER  pInfoHdr,
    POPTSELECT   poptsel   // assume fully initialized
    )
/*++
Routine Description:
    This function checks if the given snapshot makes sense. It covers only
    conditionally required entries and printing commands since other
    statically required entries are already covered by snapshot functions.

Arguments:
    pInfoHdr: pointer to INFOHEADER structure.

Return Value:
    TRUE if the semantics is correct. Otherwise, FALSE.

--*/
{
    DWORD   dwFeaIndex, dwI, dwNumOpts, dwListIndex ,
            dwMoveUnitsX, dwMoveUnitsY, dwResX, dwResY ;
    BOOL    bStatus = TRUE ;  // until fails.
    PGPDDRIVERINFO  pDrvInfo ;
    PUIINFO     pUIInfo ;
    PFEATURE    pFeature ;


    if(!pInfoHdr)
        return  FALSE ;
    pDrvInfo = (PGPDDRIVERINFO) GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHdr) ;
    if(!pDrvInfo)
        return  FALSE ;
    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;
    if(!pUIInfo)
        return  FALSE ;


//  Fix for bug 6774

    if(pUIInfo->dwPrintRate  &&  (pUIInfo->dwPrintRateUnit == INVALID_INDEX))
    {
        ERR(("*PrintRateUnit must be present if *PrintRate exists.\n")) ;
        bStatus = FALSE ;
    }
//  end fix for bug 6774

    //
    // 1. global printing entries
    //
    // - *MemoryUsage cannot be an empty list if *Memory feature exists.
    //
    // - *XMoveUnit (*YMoveUnit) must be non-trivial (greater than 1) if
    //   there is any x-move (y-move) command.
    //
    // - *DefaultFont cannot be 0 if *DeviceFonts is not an empty list.
    //
    // - CmdCR, CmdLF, and CmdFF are always required.
    //



    if(BGIDtoFeaIndex(pInfoHdr , &dwFeaIndex , GID_MEMOPTION )  &&
            (pDrvInfo->Globals.liMemoryUsage == END_OF_LIST) )
    {
        ERR(("*MemoryUsage cannot be an empty list if *Memory feature exists.\n")) ;
#ifdef  STRICT_CHECKS
        bStatus = FALSE ;
#endif
    }


    if((COMMANDPTR(pDrvInfo , CMD_XMOVEABSOLUTE ) ||
        COMMANDPTR(pDrvInfo , CMD_XMOVERELLEFT ) ||
        COMMANDPTR(pDrvInfo , CMD_XMOVERELRIGHT ))  &&
        pDrvInfo->Globals.ptDeviceUnits.x <= 1)
    {
        ERR(("*XMoveUnit must be > 1 if any x-move command exists.\n")) ;
        bStatus = FALSE ;
    }

    if((COMMANDPTR(pDrvInfo , CMD_YMOVEABSOLUTE ) ||
        COMMANDPTR(pDrvInfo , CMD_YMOVERELUP ) ||
        COMMANDPTR(pDrvInfo , CMD_YMOVERELDOWN ))  &&
        pDrvInfo->Globals.ptDeviceUnits.y <= 1)
    {
        ERR(("*YMoveUnit must be > 1 if any y-move command exists.\n")) ;
        bStatus = FALSE ;
    }

    if((pDrvInfo->Globals.liDeviceFontList != END_OF_LIST)  &&
            (pDrvInfo->Globals.dwDefaultFont == 0) )
    {
        ERR(("*DefaultFont cannot be 0 if *DeviceFonts is not an empty list.\n")) ;
#ifdef  STRICT_CHECKS
        bStatus = FALSE ;
#endif
    }

    if (!COMMANDPTR(pDrvInfo , CMD_FORMFEED ) ||
        !COMMANDPTR(pDrvInfo , CMD_CARRIAGERETURN ) ||
        !COMMANDPTR(pDrvInfo , CMD_LINEFEED )  )
    {
        ERR(("CmdCR, CmdLF, and CmdFF are always required.\n")) ;
        bStatus = FALSE ;
    }

    //  are there an integral number of master units per
    //  moveunit?

    if( pDrvInfo->Globals.ptMasterUnits.x %
        pDrvInfo->Globals.ptDeviceUnits.x )
    {
        ERR(("Must be whole number of master units per x move unit.\n")) ;
        bStatus = FALSE ;
    }
    if( pDrvInfo->Globals.ptMasterUnits.y %
        pDrvInfo->Globals.ptDeviceUnits.y )
    {
        ERR(("Must be whole number of master units per y move unit.\n")) ;
        bStatus = FALSE ;
    }

    if(pDrvInfo->Globals.ptDeviceUnits.x > 1)
    {
        dwMoveUnitsX = pDrvInfo->Globals.ptMasterUnits.x /
            pDrvInfo->Globals.ptDeviceUnits.x ;
    }
    else
        dwMoveUnitsX = 1 ;

    if(pDrvInfo->Globals.ptDeviceUnits.y > 1)
    {
        dwMoveUnitsY = pDrvInfo->Globals.ptMasterUnits.y /
            pDrvInfo->Globals.ptDeviceUnits.y ;
    }
    else
        dwMoveUnitsY = 1 ;

    if(!dwMoveUnitsX  ||  !dwMoveUnitsY)
    {
        ERR(("master units cannot be coarser than  X or Y MoveUnit.\n")) ;
        return  FALSE ;
    }


    //
    // 2. printing commands
    //
    // - if *XMoveThreshold (*YMoveThreshold) is 0, then CmdXMoveAbsolute
    //   (CmdYMoveAbsolute) must exist. Similarly, if *XMoveThreshold
    //   (*YMoveThreshold) is *, then CmdXMoveRelRight (CmdYMoveRelDown and
    //   (CmdYMoveRelUp) must exist.
    //

#if 0
    //  if Threshold is omitted by user, its set to 0 by default
    //  by the snapshot code.  So this check will fail when
    //  everything is ok.


    if((pDrvInfo->Globals.dwXMoveThreshold == 0)  &&
        !COMMANDPTR(pDrvInfo , CMD_XMOVEABSOLUTE ))
    {
        ERR(("*CmdXMoveAbsolute must exist if *XMoveThreshold is 0.\n")) ;
        bStatus = FALSE ;
    }

    if((pDrvInfo->Globals.dwYMoveThreshold == 0)  &&
        !COMMANDPTR(pDrvInfo , CMD_YMOVEABSOLUTE ))
    {
        ERR(("*CmdYMoveAbsolute must exist if *YMoveThreshold is 0.\n")) ;
        bStatus = FALSE ;
    }
#endif


    if((pDrvInfo->Globals.dwXMoveThreshold == WILDCARD_VALUE)  &&
        !COMMANDPTR(pDrvInfo , CMD_XMOVERELRIGHT ) )
    {
        ERR(("XMoveRelativeRight must exist if *XMoveThreshold is *.\n")) ;
        bStatus = FALSE ;
    }

    if((pDrvInfo->Globals.dwYMoveThreshold == WILDCARD_VALUE)  &&
        !COMMANDPTR(pDrvInfo , CMD_YMOVERELDOWN ))
    {
        ERR(("YMoveRelativeDown must exist if *YMoveThreshold is *.\n")) ;
        bStatus = FALSE ;
    }

    // - CmdSendBlockData must exist if *PrinterType is not TTY.

    if((pDrvInfo->Globals.printertype != PT_TTY)  &&
        !COMMANDPTR(pDrvInfo , CMD_SENDBLOCKDATA ))
    {
        ERR(("*CmdSendBlockData must exist if *PrinterType is not TTY.\n")) ;
        bStatus = FALSE ;
    }


    //
    // - CmdSetFontID, CmdSelectFontID, CmdSetCharCode must be consistent
    //   in their presence (i.e. all or none). Furthermore, if
    //   CmdSetFontID/CmdSelectFontID/CmdSetCharCode all exist, then
    //   *FontFormat must be one of the pre-defined constants.
    //
    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_SETFONTID ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_SELECTFONTID ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_SETCHARCODE ) )
        dwI++ ;

    if(dwI  &&  dwI != 3)
    {
        ERR(("CmdSetFontID, CmdSelectFontID, CmdSetCharCode must be present or absent together.\n")) ;
        bStatus = FALSE ;
    }

    if((dwI == 3)  && (pDrvInfo->Globals.fontformat == UNUSED_ITEM) )
    {
        ERR(("if font cmds exist, then *FontFormat must be defined\n")) ;
        bStatus = FALSE ;
    }


    // - CmdBoldOn and CmdBoldOff must be paired (i.e. both or none). The
    //   same goes for:
    //      CmdItalicOn & CmdItalicOff,
    //      CmdUnderlineOn & CmdUnderlineOff,
    //      CmdStrikeThruOn & CmdStrikeThruOff,
    //      CmdWhiteTextOn & CmdWhiteTextOff,
    //      CmdSelectSingleByteMode & CmdSelectDoubleByteMode,
    //      CmdVerticalPrintingOn/CmdVerticalPrintingOff.
    //
    // - CmdSetRectWidth and CmdSetRectHeight must be paired.
    //

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_BOLDON ) )
        dwI++ ;
    if(dwI  &&  (COMMANDPTR(pDrvInfo , CMD_BOLDOFF ) ||
            COMMANDPTR(pDrvInfo , CMD_CLEARALLFONTATTRIBS )) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdBoldOn and CmdBoldOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_ITALICON) )
        dwI++ ;
    if(dwI  &&  (COMMANDPTR(pDrvInfo , CMD_ITALICOFF ) ||
                COMMANDPTR(pDrvInfo , CMD_CLEARALLFONTATTRIBS )) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdItalicOn & CmdItalicOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_UNDERLINEON ) )
        dwI++ ;
    if(dwI  &&  (COMMANDPTR(pDrvInfo , CMD_UNDERLINEOFF ) ||
                COMMANDPTR(pDrvInfo , CMD_CLEARALLFONTATTRIBS )) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdUnderlineOn & CmdUnderlineOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_STRIKETHRUON ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_STRIKETHRUOFF ) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdStrikeThruOn & CmdStrikeThruOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_WHITETEXTON ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_WHITETEXTOFF ) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdWhiteTextOn & CmdWhiteTextOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_SELECTSINGLEBYTEMODE ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_SELECTDOUBLEBYTEMODE ) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdSelectSingleByteMode & CmdSelectDoubleByteMode must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_VERTICALPRINTINGON ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_VERTICALPRINTINGOFF ) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdVerticalPrintingOn/CmdVerticalPrintingOff must be paired.\n")) ;
        bStatus = FALSE ;
    }

    dwI = 0 ;

    if(COMMANDPTR(pDrvInfo , CMD_SETRECTWIDTH ) )
        dwI++ ;
    if(COMMANDPTR(pDrvInfo , CMD_SETRECTHEIGHT ) )
        dwI++ ;

    if(dwI  &&  dwI != 2)
    {
        ERR(("CmdSetRectWidth and CmdSetRectHeight must be paired.\n")) ;
        bStatus = FALSE ;
    }



    //  Note because this check involves looking at the command table
    //  which is snapshot specific, we cannot perform this for every
    //  option as Zhanw requested.  Only the current option.
    //
    // 3. special entries in various types of *Option constructs
    //
    // - For each ColorMode option whose *DevNumOfPlanes is greater than 1,
    //   *ColorPlaneOrder cannot be an empty list.
    //
    // - For each ColorMode option whose *DevNumOfPlanes is greater than 1,
    //   and *DevBPP is 1, search through its *ColorPlaneOrder list:
    //   if YELLOW is in the list, then CmdSendYellowData must exist. The
    //   same goes for other colors: MAGENTA, CYAN, BLACK, RED, GREEN, BLUE.

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr) ;

    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_COLORMODE) ;
    if(pFeature)
    {
        PCOLORMODE      pColorMode ;
        PCOLORMODEEX    pCMex ;
        PLISTNODE       pLNode ;
        DWORD           dwOptIndex ;


        dwNumOpts = pFeature->Options.dwCount ;

        pColorMode = OFFSET_TO_POINTER(pInfoHdr, pFeature->Options.loOffset ) ;

        if(BGIDtoFeaIndex(pInfoHdr , &dwFeaIndex , GID_COLORMODE ) )
        {
            dwOptIndex = poptsel[dwFeaIndex].ubCurOptIndex ;


            pCMex = OFFSET_TO_POINTER(pInfoHdr,
                    pColorMode[dwOptIndex].GenericOption.loRenderOffset) ;

            if((pCMex->dwPrinterNumOfPlanes > 1)  &&
                (pCMex->liColorPlaneOrder == END_OF_LIST) )
            {
                ERR(("*ColorPlaneOrder must be specified if *DevNumOfPlanes > 1.\n")) ;
                bStatus = FALSE ;
            }
            if((pCMex->dwPrinterNumOfPlanes > 1)  &&
                (pCMex->dwPrinterBPP == 1) )
            {
                for(dwListIndex = pCMex->liColorPlaneOrder ;
                    pLNode = LISTNODEPTR(pDrvInfo  , dwListIndex ) ;
                    dwListIndex = pLNode->dwNextItem)
                {
                    switch(pLNode->dwData)
                    {
                        case COLOR_YELLOW:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDYELLOWDATA))
                            {
                                ERR(("*CmdSendYellowData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_MAGENTA:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDMAGENTADATA))
                            {
                                ERR(("*CmdSendMagentaData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_CYAN:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDCYANDATA))
                            {
                                ERR(("*CmdSendCyanData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_BLACK:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDBLACKDATA))
                            {
                                ERR(("*CmdSendBlackData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_RED:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDREDDATA))
                            {
                                ERR(("*CmdSendRedData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_GREEN:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDGREENDATA))
                            {
                                ERR(("*CmdSendGreenData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        case COLOR_BLUE:
                        {
                            if(!COMMANDPTR(pDrvInfo , CMD_SENDBLUEDATA))
                            {
                                ERR(("*CmdSendBlueData must exist.\n")) ;
                                bStatus = FALSE ;
                            }
                            break ;
                        }
                        default:
                        {
                            ERR(("Unrecogized color.\n")) ;
                            bStatus = FALSE ;
                            break ;
                        }
                    }
                }
            }
        }
    }

    dwResX = dwResY = 1 ;  // default in case something goes wrong.

    if(BGIDtoFeaIndex(pInfoHdr , &dwFeaIndex , GID_RESOLUTION ) )
    {
        pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_RESOLUTION) ;
        if(pFeature)
        {
            PRESOLUTION      pRes ;
            DWORD           dwOptIndex ;

            dwOptIndex = poptsel[dwFeaIndex].ubCurOptIndex ;
            dwNumOpts = pFeature->Options.dwCount ;


            pRes = OFFSET_TO_POINTER(pInfoHdr, pFeature->Options.loOffset ) ;

            for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
            {

                if( pDrvInfo->Globals.ptMasterUnits.x < pRes[dwI].iXdpi )
                {
                    ERR(("master units  cannot be coarser than  x res unit.\n")) ;
                    return FALSE ;        //  fatal error
                }
                if( pDrvInfo->Globals.ptMasterUnits.x % pRes[dwI].iXdpi )
                {
                    ERR(("Must be whole number of master units per x res unit.\n")) ;
                    bStatus = FALSE ;
                }

                if( pDrvInfo->Globals.ptMasterUnits.y < pRes[dwI].iYdpi )
                {
                    ERR(("master units  cannot be coarser than  y res unit.\n")) ;
                    return FALSE ;
                }
                if ( pDrvInfo->Globals.ptMasterUnits.y %  pRes[dwI].iYdpi )
                {
                    ERR(("Must be whole number of master units per y res unit.\n")) ;
                    bStatus = FALSE ;
                }
            }

            //  number of master units per resolution unit.

            dwResX = pDrvInfo->Globals.ptMasterUnits.x /
                        pRes[dwOptIndex].iXdpi ;
            dwResY = pDrvInfo->Globals.ptMasterUnits.y /
                        pRes[dwOptIndex].iYdpi ;
        }
    }
    else
    {
        ERR(("Resolution is a required feature.\n")) ;
    }




    //
    // - For each non-standard Halftone option, *rcHPPatternID must be
    //   greater than 0 and *HTPatternSize must be a pair of postive integers.
    //   NOTE: check with DanielC --- should we enforce that xSize==ySize?
    //

    //  Halftone check is performed in BinitSpecialFeatureOptionFields
    //  see postproc.c

    pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE) ;
    if(pFeature)
    {
        PPAGESIZE      pPagesize ;
        PPAGESIZEEX    pPageSzEx ;

        dwNumOpts = pFeature->Options.dwCount ;

        pPagesize = OFFSET_TO_POINTER(pInfoHdr, pFeature->Options.loOffset ) ;

        for(dwI = 0 ; dwI < dwNumOpts ; dwI++)
        {
            if(GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGEPROTECTION)  &&
                    !pPagesize[dwI].dwPageProtectionMemory)
            {
                ERR(("*PageProtectMem must be greater than 0 if PageProtect feature exists.\n")) ;
#ifdef  STRICT_CHECKS
                bStatus = FALSE ;
#endif
                break ;
            }
            pPageSzEx = OFFSET_TO_POINTER(pInfoHdr,
                    pPagesize[dwI].GenericOption.loRenderOffset) ;
            if(pPagesize[dwI].dwPaperSizeID != DMPAPER_USER)
            {
                INT   iPDx, iPDy ;  // holds page dimensions
                    // in same coordinate system as ImageableArea

                if(pPageSzEx->bRotateSize)
                {
                    iPDx = (INT)pPagesize[dwI].szPaperSize.cy ;
                    iPDy = (INT)pPagesize[dwI].szPaperSize.cx ;
                }
                else
                {
                    iPDx = (INT)pPagesize[dwI].szPaperSize.cx ;
                    iPDy = (INT)pPagesize[dwI].szPaperSize.cy ;
                }

                if((iPDx  <=  0)  ||  (iPDy  <=  0))
                {
                    ERR(("*PageDimensions is required for non-standard sizes.\n")) ;
                    bStatus = FALSE ;
                    break ;
                }
                if(((INT)pPageSzEx->szImageArea.cx  <=  0)  ||
                    ((INT)pPageSzEx->szImageArea.cy  <=  0) )
                {
                    ERR(("*PrintableArea is required and must be positive.\n")) ;
                    bStatus = FALSE ;
                    break ;
                }
                if(((INT)pPageSzEx->ptImageOrigin.x  <  0)  ||
                    ((INT)pPageSzEx->ptImageOrigin.y  <  0) )

                {
                    ERR(("*PrintableOrigin is required and cannot be negative.\n")) ;
                    bStatus = FALSE ;
                    break ;
                }

                if((pPageSzEx->szImageArea.cx % dwResX)  ||
                    (pPageSzEx->szImageArea.cy % dwResY) )
                {
                    ERR(("*PrintableArea must be a integral number of ResolutionUnits.\n")) ;
#ifdef  STRICT_CHECKS
                    bStatus = FALSE ;
#endif
                    break ;
                }
                if((pPageSzEx->ptImageOrigin.x % dwResX)  ||
                    (pPageSzEx->ptImageOrigin.y % dwResY) )
                {
                    ERR(("*PrintableOrigin must be a integral number of ResolutionUnits.\n")) ;
#ifdef  STRICT_CHECKS
                    bStatus = FALSE ;
#endif
                    break ;
                }


                if(pDrvInfo->Globals.bRotateCoordinate)
                {   //  zhanw assumes printing offset is zero otherwise
                    if((pPageSzEx->ptImageOrigin.x % dwMoveUnitsX)  ||
                        (pPageSzEx->ptImageOrigin.y % dwMoveUnitsY) )

                    {
                        ERR(("*PrintableOrigin must be a integral number of MoveUnits.\n")) ;
#ifdef  STRICT_CHECKS
                        bStatus = FALSE ;
#endif
                        break ;
                    }
                    if((pPageSzEx->ptPrinterCursorOrig.x % dwMoveUnitsX)  ||
                        (pPageSzEx->ptPrinterCursorOrig.y % dwMoveUnitsY) )

                    {
                        ERR(("*CursorOrigin must be a integral number of MoveUnits.\n")) ;
#ifdef  STRICT_CHECKS
                        bStatus = FALSE ;
#endif
                        break ;
                    }
                }
                else if((pPageSzEx->ptImageOrigin.x != pPageSzEx->ptPrinterCursorOrig.x)  ||
                        (pPageSzEx->ptImageOrigin.y != pPageSzEx->ptPrinterCursorOrig.y) )

                {
                    ;  // this may be unnecessary.
//                    ERR(("For non-rotating printers, *PrintableOrigin should be same as *CursorOrigin.\n")) ;
                }

                if((iPDx + iPDx/100 <  pPageSzEx->szImageArea.cx + pPageSzEx->ptImageOrigin.x)   ||
                    (iPDy + iPDy/100 <  pPageSzEx->szImageArea.cy + pPageSzEx->ptImageOrigin.y) )
                {
                    //  I give up to 1 percent leeway
                    ERR(("*PrintableArea must be contained within *PageDimensions.\n")) ;
                    bStatus = FALSE ;
                    break ;
                }
            }
            else    //  (dwPaperSizeID == DMPAPER_USER)
            {
                if(((INT)pPageSzEx->ptMinSize.x  <=  0)  ||
                    ((INT)pPageSzEx->ptMinSize.y  <=  0) )
                {
                    ERR(("If User Defined papersize exists *MinSize is required and must be positive.\n")) ;
#ifdef  STRICT_CHECKS
                    bStatus = FALSE ;
#endif
                }
                if(((INT)pPageSzEx->ptMaxSize.x  <=  0)  ||
                    ((INT)pPageSzEx->ptMaxSize.y  <=  0) )
                {
                    ERR(("If User Defined papersize exists *MaxSize is required and must be positive.\n")) ;
                    bStatus = FALSE ;
                }
                if((INT)pPageSzEx->dwMaxPrintableWidth  <=  0)
                {
                    ERR(("If User Defined papersize exists *MaxPrintableWidth is required and must be positive.\n")) ;
                    bStatus = FALSE ;
                }
            }
        }
    }



    // - For each PaperSize option, *PageProtectMem must be greater than 0
    //   if PageProtect feature exists.
    //
    // - For all non-CUSTOMSIZE PaperSize options, *PrintableArea and
    //   *PrintableOrigin must be explicitly defined. Specifically,
    //   *PrintableArea must be a pair of positive integers, and
    //   *PrintableOrigin must be a pair of non-negative integers.
    //   note:  BInitSnapshotTable function assigns
    //   UNUSED_ITEM (-1) as the default value for *PrintableOrigin.
    //
    // - For CUSTOMSIZE option, *MinSize, *MaxSize, and *MaxPrintableWidth
    //   must be explicitly defined. Specifically, both *MinSize and *MaxSize
    //   must be a pair of positive integers. *MaxPrintableWidth must be a
    //   positive integer.
    //   BInitSnapshotTable function assigns 0 (instead of NO_LIMIT_NUM)
    //   as the default value for *MaxPrintableWidth.
    //
    // - For all non-standard non-CUSTOMSIZE PaperSize options, *PageDimensions
    //   must be explicitly defined. Specifically, it must be a pair of positive
    //   integers.
    //
    // - For any feature or option, if *Installable entry is TRUE, then
    //   either *InstallableFeatureName or *rcInstallableFeatureNameID must
    //   be present in that particular feature or option construct.
    //
    // - If any feature or option has *Installable being TRUE, then
    //   either *InstalledOptionName/*NotInstalledOptionName or
    //   *rcInstalledOptionNameID/*rcNotInstalledOptionNameID must be
    //   defined at the root level.
    //

    //   once synthetic features are created by BCreateSynthFeatures()
    //  they undergo the same checks at createsnapshot time as
    //  other features, triggering a warning if the Names of the feature and
    //  its options are absent.
#if 1
    {
        DWORD   dwNumFea, dwFea, dwNumOpt, dwOpt, dwOptSize ;
        PENHARRAYREF   pearTableContents ;
        PBYTE   pubRaw ;  //  raw binary data.
        PBYTE   pubOptions ;    // points to start of array of OPTIONS
        PFEATURE    pFea ;
        PBYTE   pubnRaw ; //  Parser's raw binary data.
        PSTATICFIELDS   pStatic ;

        pubnRaw = pInfoHdr->RawData.pvPrivateData ;
        pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
        pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

        pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

        dwNumFea = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;

        pFea = (PFEATURE)((PBYTE)pInfoHdr + pUIInfo->loFeatureList) ;

        for(dwFea = 0 ; dwFea < dwNumFea ; dwFea++)
        {
            if(!pFea[dwFea].iHelpIndex)
            {
                ERR(("*HelpIndex must be positive.\n")) ;
                bStatus = FALSE ;
            }

            dwNumOpt = pFea[dwFea].Options.dwCount ;
            pubOptions = (PBYTE)pInfoHdr + pFea[dwFea].Options.loOffset ;
            dwOptSize = pFea[dwFea].dwOptionSize ;

            for(dwOpt = 0 ; dwOpt < dwNumOpt ; dwOpt++)
            {
                if(!((POPTION)(pubOptions + dwOptSize * dwOpt))->iHelpIndex )
                {
                    ERR(("*HelpIndex must be positive.\n")) ;
                    bStatus = FALSE ;
                }
            }
        }
    }
#else
    {
        DWORD   dwNumFea, dwFea, dwNumOpt, dwOpt;
        PENHARRAYREF   pearTableContents ;
        PBYTE   pubRaw ;  //  raw binary data.
        PBYTE   pubOptions ;    // points to start of array of OPTIONS
        PFEATURE    pFea ;

        pubRaw = pInfoHdr->RawData.pvPrivateData ;

        pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

        dwNumFea = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;

        for(dwFea = 0 ; dwFea < dwNumFea ; dwFea++)
        {
            pFea = PGetIndexedFeature(pUIInfo, dwFea) ;

            if(!pFea->iHelpIndex)
            {
                ERR(("*HelpIndex must be positive.\n")) ;
                bStatus = FALSE ;
            }

            dwNumOpt = pFea->Options.dwCount ;

            for(dwOpt = 0 ; dwOpt < dwNumOpt ; dwOpt++)
            {
                pubOptions = PGetIndexedOption(pUIInfo, pFea, dwOpt);

                if(!((POPTION)pubOptions))->iHelpIndex )
                {
                    ERR(("*HelpIndex must be positive.\n")) ;
                    bStatus = FALSE ;
                }
            }
        }
    }

#endif
    return (bStatus);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\shortcut.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  shortcut.c - functions that expand shortcuts  */


#include    "gpdparse.h"



// ----  functions defined in  shortcut.c ---- //


BOOL    BInitKeywordField(
PTKMAP  pNewtkmap,
PGLOBL  pglobl) ;

BOOL    BExpandMemConfig(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BExpandCommand(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL  BexpandShortcuts(
PGLOBL  pglobl) ;


BOOL  BSsyncTokenMap(
PTKMAP   ptkmap,
PTKMAP   pNewtkmap,
PGLOBL  pglobl) ;


// ---------------------------------------------------- //


BOOL    BInitKeywordField(
PTKMAP  pNewtkmap,
PGLOBL  pglobl)
/*  all synthesized entries must have aarKeyword initialized
    via mainkeyword table since ERR code may want to print
    it out if a parsing error occurs further downstream.  */
{
    ABSARRAYREF    aarKeywordName ;
    DWORD   dwKeyID ;

    dwKeyID = pNewtkmap->dwKeywordID ;

    aarKeywordName.pub = mMainKeywordTable[dwKeyID].pstrKeyword ;
    aarKeywordName.dw = strlen(aarKeywordName.pub) ;


    pNewtkmap->aarKeyword.dw = 0 ;  // copy mode

    if(!BCatToTmpHeap( &pNewtkmap->aarKeyword,
            &aarKeywordName, pglobl) )
    {
        vIdentifySource(pNewtkmap, pglobl) ;
        ERR(("Internal error - unable to store keyword name.\n"));
        return(FALSE) ;
    }
    return(TRUE) ;
}


BOOL    BExpandMemConfig(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*   this function is pretty lax about syntax checking.
    It just assumes the existence of some non trivial string
    between open parent  and a comma.  It assumes this is the
    amount of installed memory.   The value parser will rigorously
    determine if the syntax is conforming.
*/
{
    DWORD   dwNewTKMindex, dwDelim ;
    BOOL    bMB = FALSE ;  //  KB otherwise
    ABSARRAYREF    aarTmpValue, aarToken, aarNewValue, aarUnits, aarDQuote;

    aarUnits.pub = "KB" ;  // hardcode strings
    aarUnits.dw = 2 ;
    aarDQuote.pub = "\"" ;
    aarDQuote.dw = 1 ;

    if(ptkmap[dwTKMindex].dwKeywordID == gdwMemConfigMB)
    {
        aarUnits.pub = "MB" ;
        bMB = TRUE ;
    }

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }

    //  parse out the amount of installed memory

    aarTmpValue = ptkmap[dwTKMindex].aarValue ;
    if(!BdelimitToken(&aarTmpValue, "(", &aarToken, &dwDelim ) ||
        dwDelim  ||
        !BdelimitToken(&aarTmpValue, ",", &aarToken, &dwDelim ) ||
        dwDelim  ||  !BeatSurroundingWhiteSpaces(&aarToken) )
    {
        vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
        ERR(("Syntax error in value of *MemConfig shortcut: %0.*s.\n",
            ptkmap[dwTKMindex].aarValue.dw ,
            ptkmap[dwTKMindex].aarValue.pub   ));
        return(FALSE);
    }

    aarNewValue.dw = 0 ;  // initialize so BCatToTmpHeap
                            //  will overwrite instead of append

    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwOptionConstruct ;


    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl)  ||
        !BCatToTmpHeap(&aarNewValue, &aarToken, pglobl) ||
        !BCatToTmpHeap(&aarNewValue, &aarUnits, pglobl))
    {
        vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
        ERR(("Concatenation to synthesize Memory option name failed.\n"));
        return(FALSE) ;
    }

    pNewtkmap[dwNewTKMindex].aarValue = aarNewValue ;
    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;

    //  --  synthesize entry for open brace

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwOpenBraceConstruct ;
    pNewtkmap[dwNewTKMindex].aarValue.dw = 0 ;

    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);
    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;




    //  --  synthesize *Name entry

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwOptionName ;

    pNewtkmap[dwNewTKMindex].aarValue.dw = 0 ;   // initialize so
                      //  BCatToTmpHeap will overwrite instead of append
    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl)  ||
        !BCatToTmpHeap(&pNewtkmap[dwNewTKMindex].aarValue, &aarDQuote, pglobl) ||
        !BCatToTmpHeap(&pNewtkmap[dwNewTKMindex].aarValue, &aarNewValue, pglobl) ||
        !BCatToTmpHeap(&pNewtkmap[dwNewTKMindex].aarValue, &aarDQuote, pglobl) )
    {
        vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
        ERR(("Concatenation to synthesize Memory option name failed.\n"));
        return(FALSE) ;
    }
    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;

    //  --  synthesize *MemoryConfigX entry

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID =
        (bMB) ? gdwMemoryConfigMB : gdwMemoryConfigKB ;

    pNewtkmap[dwNewTKMindex].aarValue = ptkmap[dwTKMindex].aarValue ;

    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);

    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;

    //  --  synthesize entry for close brace

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwCloseBraceConstruct ;
    pNewtkmap[dwNewTKMindex].aarValue.dw = 0 ;
    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);

    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;

    return(TRUE) ;
}




BOOL    BExpandCommand(
PTKMAP  ptkmap,
PTKMAP  pNewtkmap,
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*   this function is pretty lax about syntax checking.
    It just assumes the existence of some non trivial string
    between the two colons.  It assumes this is the
    name of the command. The portion after the 2nd colon is
    the actual command invocation.  The value parser will rigorously
    determine if the syntax is conforming.
*/
{
    DWORD   dwNewTKMindex, dwDelim ;
    ABSARRAYREF    aarTmpValue, aarToken, aarNewValue, aarUnits ;


    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }

    pNewtkmap[dwNewTKMindex] = ptkmap[dwTKMindex] ;
    //  parse out the command name

    aarTmpValue = ptkmap[dwTKMindex].aarValue ;
    if(!BdelimitToken(&aarTmpValue, ":", &aarToken, &dwDelim ) ||
        dwDelim  )
    {
        vIdentifySource(ptkmap + dwTKMindex, pglobl) ;
        ERR(("Syntax error in *Command shortcut: %0.*s.\n",
            ptkmap[dwTKMindex].aarValue.dw ,
            ptkmap[dwTKMindex].aarValue.pub   ));
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].aarValue = aarToken ;



    //  --  synthesize entry for open brace

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwOpenBraceConstruct ;
    pNewtkmap[dwNewTKMindex].aarValue.dw = 0 ;
    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);

    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;


    //  --  synthesize *Cmd entry

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwCommandCmd ;

    pNewtkmap[dwNewTKMindex].aarValue = aarTmpValue ;

    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);

    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;


    //  --  synthesize entry for close brace

    if(!BallocElementFromMasterTable(
            MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
    {
        geErrorSev = ERRSEV_RESTART ;
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        gdwMasterTabIndex = MTI_NEWTOKENMAP ;
        return(FALSE);
    }
    pNewtkmap[dwNewTKMindex].dwKeywordID = gdwCloseBraceConstruct ;
    pNewtkmap[dwNewTKMindex].aarValue.dw = 0 ;
    if(!BInitKeywordField(pNewtkmap + dwNewTKMindex, pglobl) )
        return(FALSE);

    pNewtkmap[dwNewTKMindex].dwFileNameIndex =
        ptkmap[dwTKMindex].dwFileNameIndex ;
    pNewtkmap[dwNewTKMindex].dwLineNumber =
        ptkmap[dwTKMindex].dwLineNumber ;

    return(TRUE) ;
}




BOOL  BexpandShortcuts(
PGLOBL  pglobl)
//    this function scans through the TokenMap
//    making a copy to NewTokenMap without
//    the shortcuts.  At the end transfers
//  all NewTokenMap entries back to TokenMap so
//  subsequent passes can work.
//    This function assumes the temp heap is availible for
//    storage of strings.
{
    PTKMAP   ptkmap, pNewtkmap ;   // start of tokenmap
    DWORD   dwNewTKMindex, dwEntry, dwKeywordID ;
    BOOL    bStatus = TRUE ;

    //  this function is called before resolveMacros.
    //  it will leave the result on ptkmap.

    //  source
    ptkmap = (PTKMAP)gMasterTable[MTI_TOKENMAP].pubStruct ;
    //  dest
    pNewtkmap = (PTKMAP)gMasterTable[MTI_NEWTOKENMAP].pubStruct  ;

    for(dwEntry = 0 ; geErrorSev < ERRSEV_RESTART ; dwEntry++)
    {
        //  These ID's must be processed separately
        //  because they do not index into the mainKeyword table.
        //  The code for generic ID's will fail.

        dwKeywordID = ptkmap[dwEntry].dwKeywordID ;


        if (dwKeywordID == gdwID_IgnoreBlock)
        {
            VIgnoreBlock(ptkmap + dwEntry, TRUE, pglobl) ;
            continue ;
        }
        if (dwKeywordID == ID_EOF)
        {

            //  transfer all tokenmap fields to newTokenMap
            if(!BallocElementFromMasterTable(
                    MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
            {
                geErrorSev = ERRSEV_RESTART ;
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                return(FALSE);
            }
            pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;
            //  must reset tokenmap so it can be reused.
            gMasterTable[MTI_TOKENMAP].dwCurIndex = 0 ;

            if(bStatus)
                bStatus = BSsyncTokenMap(ptkmap, pNewtkmap , pglobl) ;

            return(bStatus) ;
        }
        if (dwKeywordID == ID_NULLENTRY)
        {
            continue ;  //  skip to next entry.
        }
        else if (dwKeywordID == gdwMemConfigMB  ||
                dwKeywordID == gdwMemConfigKB)
        {
            if(!BExpandMemConfig(ptkmap, pNewtkmap, dwEntry, pglobl))
                return(FALSE);
        }
        else if (dwKeywordID == gdwCommandConstruct  &&
            ptkmap[dwEntry].dwFlags & TKMF_COLON)
        {
            if(!BExpandCommand(ptkmap, pNewtkmap, dwEntry, pglobl))
                return(FALSE);
        }
        else
        {
            //  transfer all tokenmap fields to newTokenMap
            if(!BallocElementFromMasterTable(
                    MTI_NEWTOKENMAP, &dwNewTKMindex, pglobl) )
            {
                geErrorSev = ERRSEV_RESTART ;
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                gdwMasterTabIndex = MTI_NEWTOKENMAP ;
                return(FALSE);
            }
            pNewtkmap[dwNewTKMindex] = ptkmap[dwEntry] ;

        }
    }
    return(FALSE);  // failsafe derail.
}



BOOL  BSsyncTokenMap(
PTKMAP   ptkmap,
PTKMAP   pNewtkmap,
PGLOBL   pglobl )
{
    DWORD   dwTKMindex, dwEntry, dwKeywordID ;

    for(dwEntry = 0 ; geErrorSev < ERRSEV_RESTART ; dwEntry++)
    {
        //  transfer all newTokenMap fields back to tokenmap
        if(!BallocElementFromMasterTable(
                MTI_TOKENMAP, &dwTKMindex, pglobl) )
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_TOKENMAP ;
            return(FALSE);  // failsafe derail.
        }
        ptkmap[dwTKMindex] = pNewtkmap[dwEntry]  ;
        if (pNewtkmap[dwEntry].dwKeywordID == ID_EOF)
        {
            gMasterTable[MTI_NEWTOKENMAP].dwCurIndex = 0 ;
            return(TRUE) ;
        }
    }
    return(FALSE);  // failsafe derail.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\preproc1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*
 *  preproc1.c - syntax generic preprocessor for parser
 */



#include    "gpdparse.h"




//check.  static   ABSARRAYREF  gaarPPPrefix = {"*", 1} ;
    //  set preprocessor prefix to '*'
// Now moved to GLOBL structure.

// ----  functions defined in preproc1.c ---- //

BOOL  DefineSymbol(PBYTE   symbol, PGLOBL pglobl) ;


BOOL       SetPPPrefix(PABSARRAYREF   parrPrefix, PGLOBL pglobl) ;

BOOL  BPreProcess(PGLOBL pglobl) ;  //  from current file position, use file macros to access.

enum  DIRECTIVE  ParseDirective(
PABSARRAYREF   paarCurPos,
PABSARRAYREF   parrSymbol,
PGLOBL         pglobl) ;

BOOL   bSkipAnyWhite(PABSARRAYREF   paarCurPos) ;

BOOL   bSkipWhiteSpace(PABSARRAYREF   paarCurPos) ;

BOOL   bmatch(PABSARRAYREF   paarCurPos,  ABSARRAYREF aarReference) ;

BOOL   extractSymbol(PABSARRAYREF   paarSymbol, PABSARRAYREF   paarCurPos) ;

BOOL   strmatch(PABSARRAYREF   paarCurPos,   PCHAR  pref ) ;

BOOL   ExtractColon(PABSARRAYREF   paarCurPos) ;

enum  DIRECTIVE   IsThisPPDirective(
IN  OUT  PABSARRAYREF  paarFile ,    //  current pos in GPD file
         PABSARRAYREF  paarSymbol,   // return reference to heap copy of directive symbol
         PGLOBL        pglobl);

void  deleteToEOL(PABSARRAYREF   paarCurPos) ;

int  BytesToEOL(PABSARRAYREF   paarCurPos) ;

BOOL  SymbolTableAdd(
PABSARRAYREF   parrSymbol,
PGLOBL         pglobl) ;

BOOL  SymbolTableRemove(
PABSARRAYREF   parrSymbol,
PGLOBL         pglobl) ;

BOOL  SymbolTableExists(
PABSARRAYREF   parrSymbol,
PGLOBL         pglobl) ;



// ---------------------------------------------------- //

 //       ERR(("%*s\n",  BytesToEOL(paarCurPos), paarCurPos->pub ));


BOOL  DefineSymbol(
PBYTE   symbol,
PGLOBL  pglobl)
{
    ABSARRAYREF   aarSymbol ;
    ARRAYREF        arSymbolName ;

    aarSymbol.pub = symbol ;
    aarSymbol.dw = strlen(symbol);

    #if 0

    this is not needed because SymbolTableAdd now always
       makes a copy of the aarSymbol.

    if(!BaddAARtoHeap(&aarSymbol, &arSymbolName, 1, pglobl))
    {
        ERR(("Internal error, unable to define %s!\n", symbol));
        return FALSE ;
    }

    aarSymbol.pub = arSymbolName.loOffset + mpubOffRef ;
    aarSymbol.dw = arSymbolName.dwCount  ;

    #endif

    if(!  SymbolTableAdd(&aarSymbol, pglobl) )
    {
        ERR(("Internal error, unable to define %s!\n", symbol));
        return FALSE ;
    }
    return  TRUE ;
}



BOOL       SetPPPrefix(
PABSARRAYREF   parrPrefix,
PGLOBL         pglobl)
{
    if(!parrPrefix->dw)
    {
        ERR(("#SetPPPrefix: syntax error - preprocessor prefix cannot be NULL !\n"));
        //  optional:  report filename and line number
        geErrorType = ERRTY_SYNTAX ;
        geErrorSev = ERRSEV_FATAL ;

        return  FALSE ;
    }
    gaarPPPrefix = *parrPrefix ;
    return  TRUE ;
}


//  GPD preprocessor:  implements the following preprocessor directives:
//      #Define: symbol
//      #Undefine: symbol
//      #Include:  filename     Note: this uses the exact syntax used by
//          The GPD *Include:  keyword except * is replaced by #
//      #Ifdef:      symbol
//      #Elseifdef:      symbol
//      #Else:
//      #Endif:
//      #SetPPPrefix:      symbol
//
//    notes:   when #Include:  is found, just  replace prefix with '*'.
//    instead of compressing file when #ifdefs are processed, just 'erase' unwanted
//    sections with space chars.  (leaving \n and \r  unchanged to preserve line #'s)
//    Need to store some  global state information.   like how many nesting levels
//    what are we currently doing, what symbols are defined etc.
//    Definitions:
//      Section:  these directives act as section delimiters:
//      #Ifdef:      symbol
//      #Elseifdef:      symbol
//      #Else:
//      #Endif:
//      Nesting level:  the number of unmatched  #ifdefs at the current position
//      determines the  nesting level at that position.
//     Note in these source code comments '#' represents the current preprocessor prefix.
//      This is set to '*' by default, but is changed using the  #SetPPPrefix:  directive.

BOOL  BPreProcess(
PGLOBL pglobl)
//  from current file position, use file macros to access.
{
    BOOL   bStatus = FALSE ;

    ABSARRAYREF   arrSymbol ,   //  holds symbol portion of directive.
                aarCurPos ;  //  holds current position in source file buffer.
    enum  DIRECTIVE    directive ;
    enum  IFSTATE    prevsIFState ;
    enum  PERMSTATE  prevsPermState ;

    aarCurPos.pub    = mpubSrcRef + mdwSrcInd ;
    aarCurPos.dw     =   mdwSrcMax -  mdwSrcInd ;


    while((directive = ParseDirective(&aarCurPos, &arrSymbol, pglobl)) != DIRECTIVE_EOF)
    {
        switch(directive)
        {
            case  DIRECTIVE_DEFINE:
                if(mppStack[mdwNestingLevel].permState == PERM_ALLOW)
                {
                    if(!SymbolTableAdd(&arrSymbol, pglobl) )
                        return(FALSE);  // error!
                }
                break;
            case  DIRECTIVE_UNDEFINE:
                if(mppStack[mdwNestingLevel].permState == PERM_ALLOW)
                {
                    if(!SymbolTableRemove(&arrSymbol, pglobl) )
                    {
                        if(geErrorSev != ERRSEV_FATAL )
                        {
                            ERR(("syntax error - attempting to undefine a symbol that isn't defined !\n"));
                            ERR(("%.*s\n",  BytesToEOL(&arrSymbol), arrSymbol.pub ));
                            geErrorType = ERRTY_SYNTAX ;
                            geErrorSev = ERRSEV_FATAL ;
                            goto  PREPROCESS_FAILURE;
                        }
                    }
                }
                break;
            case  DIRECTIVE_INCLUDE:
                if(mppStack[mdwNestingLevel].permState != PERM_ALLOW)
                {
                    deleteToEOL(&aarCurPos) ;
                    break;   //  it never happened.
                }
                goto   PREPROCESS_SUCCESS ;
                break;
            case  DIRECTIVE_SETPPPREFIX :
                if(mppStack[mdwNestingLevel].permState == PERM_ALLOW)
                    SetPPPrefix(&arrSymbol, pglobl);
                break;
            case  DIRECTIVE_IFDEF:
                //  state-invariant behavior
                prevsPermState =  mppStack[mdwNestingLevel].permState ;
                mdwNestingLevel++ ;
                if(mdwNestingLevel >= mMaxNestingLevel)
                {
                    if(ERRSEV_RESTART > geErrorSev)
                    {
                        geErrorType = ERRTY_MEMORY_ALLOCATION ;
                        geErrorSev = ERRSEV_RESTART ;
                        gdwMasterTabIndex = MTI_PREPROCSTATE ;
                    }
                    goto  PREPROCESS_FAILURE;
                }

                if(SymbolTableExists(&arrSymbol, pglobl))
                    mppStack[mdwNestingLevel].permState = PERM_ALLOW ;
                else
                    mppStack[mdwNestingLevel].permState = PERM_DENY ;

                if(prevsPermState != PERM_ALLOW)
                    mppStack[mdwNestingLevel].permState = PERM_LATCHED ;

                mppStack[mdwNestingLevel].ifState =  IFS_CONDITIONAL;

                break;
            case  DIRECTIVE_ELSEIFDEF:
                if(mppStack[mdwNestingLevel].ifState ==  IFS_ROOT)
                {
                    ERR(("syntax error - #Elseifdef directive must be preceeded by #Ifdef !\n"));
                    //  optional:  report filename and line number
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    goto  PREPROCESS_FAILURE;
                }
                if(mppStack[mdwNestingLevel].ifState ==  IFS_LAST_CONDITIONAL)
                {
                    ERR(("syntax error - #Elseifdef directive cannot follow #Else !\n"));
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    goto  PREPROCESS_FAILURE;
                }

                if(mppStack[mdwNestingLevel].permState == PERM_ALLOW)
                    mppStack[mdwNestingLevel].permState = PERM_LATCHED ;
                else if(mppStack[mdwNestingLevel].permState == PERM_DENY)
                {
                    if(SymbolTableExists(&arrSymbol, pglobl))
                        mppStack[mdwNestingLevel].permState = PERM_ALLOW ;
                }


                break;
            case  DIRECTIVE_ELSE :
                if(mppStack[mdwNestingLevel].ifState ==  IFS_ROOT)
                {
                    ERR(("syntax error - #Else directive must be preceeded by #Ifdef or #Elseifdef !\n"));
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    goto  PREPROCESS_FAILURE;
                }
                if(mppStack[mdwNestingLevel].ifState ==  IFS_LAST_CONDITIONAL)
                {
                    ERR(("syntax error - #Else directive cannot follow #Else !\n"));
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    goto  PREPROCESS_FAILURE;
                }
                mppStack[mdwNestingLevel].ifState =  IFS_LAST_CONDITIONAL ;


                if(mppStack[mdwNestingLevel].permState == PERM_ALLOW)
                    mppStack[mdwNestingLevel].permState = PERM_LATCHED ;
                else if(mppStack[mdwNestingLevel].permState == PERM_DENY)
                {
                    mppStack[mdwNestingLevel].permState = PERM_ALLOW ;
                }

                break;
            case  DIRECTIVE_ENDIF :
                if(mppStack[mdwNestingLevel].ifState ==  IFS_ROOT)
                {
                    ERR(("syntax error - #Endif directive must be preceeded by #Ifdef or #Elseifdef or #Else !\n"));
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    goto  PREPROCESS_FAILURE;
                }
                mdwNestingLevel-- ;   //  restore previous nesting level.
                break;
            default:
                ERR(("internal consistency error - no such preprocessor directive!\n"));
                ERR(("%.*s\n",  BytesToEOL(&aarCurPos), aarCurPos.pub ));
                geErrorType = ERRTY_CODEBUG ;
                geErrorSev = ERRSEV_FATAL ;
                goto  PREPROCESS_FAILURE;

                break;
        }
    }




    PREPROCESS_SUCCESS:
    return  TRUE  ;

    PREPROCESS_FAILURE:
    return  FALSE ;
}





enum  DIRECTIVE  ParseDirective(PABSARRAYREF   paarCurPos,
PABSARRAYREF   parrSymbol,
PGLOBL         pglobl)
{
    //  this function parses from the 'current' position:  mdwSrcInd
    //  for any recognized directive and returns that directive.

    //  if (mppStack[mdwNestingLevel].permState != PERM_ALLOW)
    //      all characters   != \n  or \r encountered while looking for the directive
    //      will be replaced by space characters.
    //
    //  the entire line containing the directive is replaced by spaces.
    //  (except for the Include directive - only the prefix is replaced by '*'
    //   with leftpadded spaces if needed.)
    //  cur pos is set to the line following the one containing the directive.
    //  before the directive is destroyed, a copy is made of the symbol argument
    //  and a reference parrSymbol is initialized to point to this copy.
    //  this copy is stored on the heap so it's lifetime is effectively 'forever'.

    //  syntax of directive:
    //  a directive token must  be immediately preceeded by the current preprocessor
    //  prefix.  The prefix must be preceeded by a line delimiter (unless its the
    //  first line in the file).   Optional whitespace characters (space or tab) may reside between
    //  the line delimiter and the prefix.
    //  the actual DIRECTIVE  Token may be followed by Optional whitespace, then must
    //  be followed by the Colon delimiter, the next non-whitespace token is interpreted
    //  as the symbol.   Any characters following the symbol token to the line delimiter
    //   will be ignored.   A Directive cannot occupy more than one line.

    //   this function assumes cur pos points to start of line when it is called.

    enum  DIRECTIVE  directive ;
    BOOL    bStartOfNewLine  = TRUE ;
    BYTE     ubSrc ;


    while(  paarCurPos->dw  )   //  EOF detector
    {
        if(bStartOfNewLine  &&         //  directives must start at newline or
            //  have only whitespace intervening
            (directive = IsThisPPDirective( paarCurPos, parrSymbol, pglobl)) !=  NOT_A_DIRECTIVE )
        {
            return  directive;
        }

        ubSrc = *paarCurPos->pub ;
            //extract current character
        if(ubSrc != '\n'  &&  ubSrc != '\r')
        {
            bStartOfNewLine = FALSE ;
            if(mppStack[mdwNestingLevel].permState != PERM_ALLOW)
            {
                *paarCurPos->pub = ' ' ;   //  replace with harmless space.
            }
        }
        else
            bStartOfNewLine = TRUE ;

        (paarCurPos->pub)++ ;   // advance to next character.
        (paarCurPos->dw)-- ;
    }
    return  DIRECTIVE_EOF ;
}


BOOL   bSkipAnyWhite(PABSARRAYREF   paarCurPos)
//  checks for EOF
{
    while(  paarCurPos->dw  )   //  EOF detector
    {
        BYTE  ubSrc = *paarCurPos->pub ;
            //extract current character
        if(ubSrc != ' '  &&  ubSrc != '\t'  &&  ubSrc != '\n'  &&  ubSrc != '\r')
        {
            return  TRUE ;   //  Non-white char encountered
        }
        (paarCurPos->pub)++ ;   // advance to next character.
        (paarCurPos->dw)-- ;
    }
    return  FALSE ;  //  reached  eof
}


BOOL   bSkipWhiteSpace(PABSARRAYREF   paarCurPos)
{
//  checks for EOF
    while(  paarCurPos->dw  )   //  EOF detector
    {
        BYTE  ubSrc = *paarCurPos->pub ;
            //extract current character
        if(ubSrc != ' '  &&  ubSrc != '\t' )
        {
            return  TRUE ;   //  Non-white char encountered
        }
        (paarCurPos->pub)++ ;   // advance to next character.
        (paarCurPos->dw)-- ;
    }
    return  FALSE ;  //  reached  eof
}

BOOL   bmatch(PABSARRAYREF   paarCurPos,  ABSARRAYREF aarReference)
//  checks for EOF
{
    if(!paarCurPos->dw)
        return  FALSE ;  //  reached  eof
    if(paarCurPos->dw < aarReference.dw)
        return  FALSE ;  //  not enough chars in buffer to match reference.
    if(strncmp(paarCurPos->pub, aarReference.pub, aarReference.dw))
        return  FALSE ;
    paarCurPos->pub += aarReference.dw ;   //  otherwise we match the reference!!
    paarCurPos->dw -=  aarReference.dw ;    //  advance pointer past matching substring
    return  TRUE ;
}

BOOL   extractSymbol(PABSARRAYREF   paarSymbol, PABSARRAYREF   paarCurPos)
//  checks for EOF
{
    paarSymbol->pub = paarCurPos->pub ;

    for(paarSymbol->dw = 0 ; paarCurPos->dw  ; paarSymbol->dw++,
             (paarCurPos->pub)++ , paarCurPos->dw--)
    {
        BYTE  ubSrc = *paarCurPos->pub ;
            //extract current character
        if(ubSrc == ' '  ||  ubSrc == '\t'  ||  ubSrc == '\n'  ||  ubSrc == '\r')
        {
            break;
        }
    }

    if(!paarSymbol->dw)
        return  FALSE ;     //  nothing?

    return  TRUE ;   // this is our preprocessor symbol.
}

BOOL   strmatch(PABSARRAYREF   paarCurPos,   PCHAR  pref )
//  checks for EOF  - means dw cannot go neg.
{
    DWORD   dwRefLen ;

    if(!paarCurPos->dw)
        return  FALSE ;  //  reached  eof

    dwRefLen = strlen(pref);

    if(paarCurPos->dw < dwRefLen)
        return  FALSE ;  //  not enough chars in buffer to match reference.
    if(strncmp(paarCurPos->pub, pref, dwRefLen))
        return  FALSE ;     //  no match
    paarCurPos->pub += dwRefLen ;   //  otherwise we match the reference!!
    paarCurPos->dw -=  dwRefLen ;    //  advance pointer past matching substring
    return  TRUE ;   // match!
}

BOOL   ExtractColon(PABSARRAYREF   paarCurPos)
//  checks for EOF  - means dw cannot go neg.
{
    if(! bSkipWhiteSpace( paarCurPos) )
        return  FALSE ;     //  reached EOF
    if(!strmatch(paarCurPos,   ":" ) )
        return  FALSE ;     //  no match
    if(! bSkipWhiteSpace( paarCurPos) )
        return  FALSE ;     //  reached EOF
    return  TRUE ;   // match!
}

enum  DIRECTIVE   IsThisPPDirective(
IN  OUT  PABSARRAYREF  paarFile ,   //  current pos in GPD file
      PABSARRAYREF   paarSymbol,    // return reference to heap copy of directive symbol
      PGLOBL         pglobl)
//  This function only processes the current line and determines if
//  the current line is a valid preprocessor directive.
//  This function assumes paarFile initially points to start of the line
//  if this is a directive, advances paarFile->pub  to EOL  and replaces the
//    line with spaces.
//  if not a directive,  advances paarFile->pub  past initial whitespace padding.
//  to reduce repeat processing.
{
    ABSARRAYREF     aarPrefix,   // points to first non-white char found
    aarDirective;   // points right after prefix.
    enum  DIRECTIVE   directive ;
//    PBYTE  pBuff = paarFile->pub ;

    //  there can only be whitespace padding or linebreaks preceeding prefix:
    if(!bSkipAnyWhite(paarFile ))   //  skip any combination of spaces , tabs  and linebreaks
        return  DIRECTIVE_EOF ;
         //   EOF overflow has occured or some bizzare failure!


    aarPrefix =  *paarFile;   //  remember location of the prefix or first non-white char

    if(!bmatch(paarFile, gaarPPPrefix))   //  advances paarFile
    {
        *paarFile = aarPrefix ;    //  restore to just beyond white padding
        return  NOT_A_DIRECTIVE ;
    }

    aarDirective = *paarFile ;

    if(strmatch(paarFile, "Define")  )
            directive =  DIRECTIVE_DEFINE;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Undefine")  )
            directive =  DIRECTIVE_UNDEFINE;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Include")  )
            directive =   DIRECTIVE_INCLUDE;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Ifdef")  )
            directive =   DIRECTIVE_IFDEF;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Elseifdef")  )
            directive =   DIRECTIVE_ELSEIFDEF;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Else")  )
            directive =   DIRECTIVE_ELSE;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "Endif")  )
            directive =   DIRECTIVE_ENDIF;
    else  if((*paarFile = aarDirective, 1)   && strmatch(paarFile, "SetPPPrefix")  )
            directive =  DIRECTIVE_SETPPPREFIX ;
    else
    {               //   (directive ==  NOT_A_DIRECTIVE)
        *paarFile = aarPrefix ;    //  restore to just beyond white padding
        return  NOT_A_DIRECTIVE ;
    }


    if(directive == DIRECTIVE_INCLUDE)
    {
        //  replace prefix with  leftpadded   '*' ;
        DWORD  dwI ;
        for(dwI = 0 ; dwI < gaarPPPrefix.dw ; dwI++)
            (aarPrefix.pub)[dwI] = ' ' ;   // replace prefix with all spaces
        (aarPrefix.pub)[ gaarPPPrefix.dw - 1] = '*' ;   //  last char becomes '*'.

        *paarFile = aarPrefix ;    //   this allows *Include: entry to be deleted if != PERM_ALLOW
        return  directive;
    }

    if(!ExtractColon(paarFile))   //  parse surrounding spaces also.
    {
        ERR(("syntax error - colon delimiter required after preprocessor directive !\n"));
        ERR(("%.*s\n",  BytesToEOL(&aarPrefix), aarPrefix.pub ));
        if(geErrorSev < ERRSEV_CONTINUE)
        {
            geErrorType = ERRTY_SYNTAX ;
            geErrorSev = ERRSEV_CONTINUE ;
        }
        *paarFile = aarPrefix ;    //  restore to just beyond white padding
        return  NOT_A_DIRECTIVE ;
    }
    if(directive ==  DIRECTIVE_SETPPPREFIX  ||
        directive ==   DIRECTIVE_ELSEIFDEF  ||
        directive ==   DIRECTIVE_IFDEF  ||
        directive ==  DIRECTIVE_UNDEFINE  ||
        directive ==  DIRECTIVE_DEFINE)
    {
        ARRAYREF        arSymbolName ;

        if(!extractSymbol(paarSymbol, paarFile))   //  identifies substring of paarFile
        {
            ERR(("syntax error - symbol required after this  preprocessor directive !\n"));
            ERR(("%.*s\n",  BytesToEOL(&aarPrefix), aarPrefix.pub ));
            if(geErrorSev < ERRSEV_CONTINUE)
            {
                geErrorType = ERRTY_SYNTAX ;
                geErrorSev = ERRSEV_CONTINUE ;
            }
            *paarFile = aarPrefix ;    //  restore to just beyond white padding
            return  NOT_A_DIRECTIVE ;
        }

        /*  I would  use
        BOOL    BcopyToTmpHeap()             (token1.c)
        except this will confuse the
        heck out of Register symbol, which is expecting all strings to
        be stored in the regular heap!     */


        if(!BaddAARtoHeap(paarSymbol, &arSymbolName, 1, pglobl))
            return(DIRECTIVE_EOF );  //  cause a swift abort


        paarSymbol->pub = arSymbolName.loOffset + mpubOffRef ;
        paarSymbol->dw = arSymbolName.dwCount  ;
        //  permanent location of symbol in Heap.
    }

    //  replace all non-white chars on the line to EOL or EOF  with spaces ;
    *paarFile = aarPrefix  ;
    deleteToEOL(paarFile) ;
    return  directive;
}


void  deleteToEOL(PABSARRAYREF   paarCurPos)
//   actually replace with space chars
{
    for( ; paarCurPos->dw  ;  paarCurPos->pub++, paarCurPos->dw--)
    {
        BYTE  ubSrc = *(paarCurPos->pub) ;
        if(ubSrc != '\n'  &&  ubSrc != '\r')
            *(paarCurPos->pub) = ' ' ;   //  replace with harmless space.
        else
            break;  //  reached EOL.  paarFile points to EOL.
    }
}


int  BytesToEOL(PABSARRAYREF   paarCurPos)
{
    int     iCount ;

    for(iCount = 0 ; paarCurPos->dw > (DWORD)iCount  ;  iCount++)
    {
        BYTE  ubSrc = paarCurPos->pub[iCount] ;
        if(ubSrc == '\n'  ||  ubSrc == '\r')
            break;  //  reached EOL.
    }
    return(iCount) ;
}



BOOL  SymbolTableAdd(
PABSARRAYREF   paarSymbol,
PGLOBL         pglobl)
{
    DWORD   dwSymbolID ;

    dwSymbolID = DWregisterSymbol(paarSymbol, CONSTRUCT_PREPROCESSOR,
                    TRUE, INVALID_SYMBOLID, pglobl) ;
    if(dwSymbolID == INVALID_SYMBOLID)
    {
        return(FALSE );
    }
    return  TRUE ;
}


BOOL  SymbolTableRemove(
PABSARRAYREF   paarSymbol,
PGLOBL         pglobl)
{
    DWORD   dwSymbolID , dwCurNode;
    PSYMBOLNODE     psn ;

    dwSymbolID =   DWsearchSymbolListForAAR(paarSymbol,  mdwPreProcDefinesSymbols, pglobl) ;
    if(dwSymbolID == INVALID_SYMBOLID)
    {
        return(FALSE );
    }

    dwCurNode = DWsearchSymbolListForID(dwSymbolID,
        mdwPreProcDefinesSymbols, pglobl) ;
    if(dwCurNode == INVALID_INDEX)
    {
        ERR(("Parser error - can't find symbol node !\n"));
         geErrorType = ERRTY_CODEBUG ;
         geErrorSev = ERRSEV_FATAL ;
         return(FALSE );  //  cause a swift abort
    }


    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;


    //  how do you remove this node from the symbol tree?
    psn[dwCurNode].arSymbolName.dwCount = 0 ;
    //  can't navigate backwards along tree so just truncate string!
    return  TRUE ;
}

BOOL  SymbolTableExists(
PABSARRAYREF   paarSymbol,
PGLOBL         pglobl)
{
    DWORD   dwSymbolID ;

    dwSymbolID =   DWsearchSymbolListForAAR(paarSymbol,  mdwPreProcDefinesSymbols, pglobl) ;
    if(dwSymbolID == INVALID_SYMBOLID)
    {
        return(FALSE );
    }
    return  TRUE ;
}



#if 0
>>>>


    DWORD   dwCurNode, dwSymbolID ;
    PSYMBOLNODE     psn ;

    dwSymbolID = DWregisterSymbol(paarSymbol, CONSTRUCT_PREPROCESSOR,
                    FALSE, INVALID_SYMBOLID) ;
    if(dwSymbolID == INVALID_SYMBOLID)
    {
        return(DIRECTIVE_EOF );  //  cause a swift abort
    }

    dwCurNode = DWsearchSymbolListForID(dwSymbolID,
        mdwPreProcDefinesSymbols) ;
    if(dwCurNode == INVALID_INDEX);
    {
        ERR(("Parser error - can't find symbol node !\n"));
         geErrorType = ERRTY_CODEBUG ;
         geErrorSev = ERRSEV_FATAL ;
         return(DIRECTIVE_EOF );  //  cause a swift abort
    }


    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    paarSymbol->pub = psn[dwCurNode].arSymbolName.loOffset + mpubOffRef ;
    paarSymbol->dw = psn[dwCurNode].arSymbolName.dwCount  ;


    SymbolTableAdd(&aarSymbol);

    may use  from state1.c

DWORD   DWregisterSymbol(
PABSARRAYREF  paarSymbol,  // the symbol string to register
CONSTRUCT eConstruct ,  // type of construct determines class of symbol.
BOOL    bCopy,   //  shall we copy paarSymbol to heap?  May set
DWORD   dwFeatureID   //  if you are registering an option symbol
                //   and you already know the feature , pass it in
                //  here.  Otherwise set to INVALID_SYMBOLID
)
/*  this function registers the entire string specified
    in paarSymbol.  The caller must isolate the string.
*/
{
    //  returns SymbolID, a zero indexed ordinal
    //    for extra speed we may hash string


but what do we define for symbol class?
            if(eConstruct == CONSTRUCT_FONTCART)
                pdwSymbolClass += SCL_FONTCART ;
            else if(eConstruct == CONSTRUCT_TTFONTSUBS)
                pdwSymbolClass += SCL_TTFONTNAMES ;
            else if(eConstruct == CONSTRUCT_COMMAND)
                pdwSymbolClass += SCL_COMMANDNAMES ;
            else if(eConstruct == CONSTRUCT_BLOCKMACRO)
                pdwSymbolClass +=  SCL_BLOCKMACRO;
            else if(eConstruct == CONSTRUCT_MACROS)
                pdwSymbolClass +=  SCL_VALUEMACRO;
            else if(eConstruct == CONSTRUCT_PREPROCESSOR)
                pdwSymbolClass +=  SCL_PPDEFINES;
            else
                pdwSymbolClass += SCL_FEATURES ;



DWORD   DWsearchSymbolListForAAR(
PABSARRAYREF    paarSymbol,
DWORD           dwNodeIndex) ;
//  given a 'aar' to a string representing a symbol, search
//  the SymbolList beginning at dwNodeIndex for this symbol.
//  Return its symbolID  if found, else return the INVALID_SYMBOLID.
{
    PSYMBOLNODE     psn ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    for( ; dwNodeIndex != INVALID_INDEX ;
        dwNodeIndex = psn[dwNodeIndex].dwNextSymbol)
    {
        if(BCmpAARtoAR(paarSymbol,  &(psn[dwNodeIndex].arSymbolName)) )
            return(psn[dwNodeIndex].dwSymbolID);  // string matches !
    }
    return(INVALID_SYMBOLID);
}



fragments for future use:

from framwrk1.c:

VOID  VinitGlobals()
    gMasterTable[MTI_SYMBOLROOT].dwArraySize =  SCL_NUMSYMCLASSES ;
    gMasterTable[MTI_SYMBOLROOT].dwMaxArraySize =  SCL_NUMSYMCLASSES ;
    gMasterTable[MTI_SYMBOLROOT].dwElementSiz = sizeof(DWORD)  ;

    gMasterTable[MTI_STSENTRY].dwArraySize = 20  ;
    gMasterTable[MTI_STSENTRY].dwMaxArraySize = 60  ;
    gMasterTable[MTI_STSENTRY].dwElementSiz =  sizeof(STSENTRY) ;
    modify to serve as the preprocessor state Stack
    need also macros to access the stack.




//  -----  Preprocessor Section ---- //               from gpdparse.h

    enum  IFSTATE  {IFS_ROOT, IFS_CONDITIONAL , IFS_LAST_CONDITIONAL } ;
        //  tracks correct syntatical use of #ifdef, #elseifdef, #else and #endif directives.
    enum  PERMSTATE  {PERM_ALLOW, PERM_DENY ,  PERM_LATCHED } ;
        //  tracks current state of preprocessing,
        //  PERM_ALLOW:  all statements in this section are passed to body gpdparser
        //  PERM_DENY:  statements in this section are discarded
        //  PERM_LATCHED:  all statements until the end of  this nesting level are discarded.
    enum  DIRECTIVE  {NOT_A_DIRECTIVE, DIRECTIVE_EOF, DIRECTIVE_DEFINE , DIRECTIVE_UNDEFINE ,
                       DIRECTIVE_INCLUDE , DIRECTIVE_SETPPPREFIX , DIRECTIVE_IFDEF ,
                       DIRECTIVE_ELSEIFDEF , DIRECTIVE_ELSE , DIRECTIVE_ENDIF }


typedef  struct
{
    enum  IFSTATE  ifState ;
    enum  PERMSTATE  permState ;
} PPSTATESTACK, * PPPSTATESTACK ;
//  the tagname is 'ppss'


    MTI_PREPROCSTATE,  //  array of PPSTATESTACK structures
            //  which hold state of preprocessor.
    gMasterTable[MTI_PREPROCSTATE].dwArraySize =  20 ;
    gMasterTable[MTI_PREPROCSTATE].dwMaxArraySize =  100 ;
    gMasterTable[MTI_PREPROCSTATE].dwElementSiz =  sizeof(PPSTATESTACK) ;


#define     mppStack  ((PPPSTATESTACK)(gMasterTable \
                            [MTI_PREPROCSTATE].pubStruct))
    //  location of first SOURCEBUFFER element in array

#define     mdwNestingLevel   (gMasterTable[MTI_PREPROCSTATE].dwCurIndex)
    //  current preprocessor directive nesting level

#define     mMaxNestingLevel   (gMasterTable[MTI_PREPROCSTATE].dwArraySize)
    //  max preprocessor directive nesting depth





    //  init preprocessor state stack

    mdwNestingLevel = 0 ;
    mppStack[mdwNestingLevel].permState = PERM_ALLOW ;
    mppStack[mdwNestingLevel].ifState =  IFS_ROOT;

#endif

// ---- End Of Preprocessor  Section ---- //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\postproc.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*
 *  postproc.c - postprocessing functions



 History of Changes
  9/30/98 --hsingh--
          Added three functions BsetUQMFlag(), BRecurseNodes(), BsetUQMTrue()
          to enable making the UpdateQualityMacro? keyword optional in
          .gpd file.
          Bug Report 225088
*/


#include    "gpdparse.h"


// ----  functions defined in postproc.c ---- //


DWORD   dwFindLastNode(
            DWORD  dwFirstNode,
            PGLOBL pglobl) ;

BOOL    BappendCommonFontsToPortAndLandscape(
            PGLOBL pglobl) ;

BOOL    BinitSpecialFeatureOptionFields(
            PGLOBL pglobl) ;

BOOL    BIdentifyConstantString(
            IN  PARRAYREF   parString,
            OUT PDWORD      pdwDest,        //  write dword value here.
            IN  DWORD       dwClassIndex,   // which class of constant is this?
                BOOL        bCustomOptOK,
                PGLOBL      pglobl
) ;



BOOL    BReadDataInGlobalNode(
            PATREEREF   patr,     // address of field in GlobalAttrib struct
            PDWORD      pdwHeapOffset,
            PGLOBL      pglobl
) ;


BOOL    BsetUQMFlag(PGLOBL pglobl);
BOOL    BRecurseNodes(
            IN DWORD  dwNodeIndex,
            PGLOBL pglobl);
BOOL    BsetUQMTrue(
            IN DWORD dwFeature,
            PGLOBL pglobl);


VOID    VCountPrinterDocStickyFeatures(
            PGLOBL pglobl) ;

BOOL    BConvertSpecVersionToDWORD (
            PWSTR   pwstrFileName ,
            PGLOBL  pglobl) ;





BOOL    BinitMiniRawBinaryData(
            PGLOBL pglobl) ;

BOOL    BexchangeArbDataInFOATNode(
                DWORD   dwFeature,
                DWORD   dwOption,
                DWORD   dwFieldOff,   // offset of field in FeatureOption struct
                DWORD   dwCount,       //  number bytes to copy.
            OUT PBYTE   pubOut,        // previous contents of attribute node
            IN  PBYTE   pubIn,         // new contents of attribute node.
                PBOOL   pbPrevsExists, // previous contents existed.
                BOOL    bSynthetic,     //  access synthetic features
                PGLOBL  pglobl
)  ;

BOOL    BInitPriorityArray(
            PGLOBL pglobl) ;



// ---------------------------------------------------- //



typedef struct
{
    DWORD   paperID ;
    DWORD   x ;
    DWORD   y ;
}  PAPERDIM ;

CONST   PAPERDIM aPaperDimensions[] = {
    DMPAPER_LETTER,                          215900, 279400,
    DMPAPER_LETTERSMALL,                     215900, 279400,
    DMPAPER_TABLOID,                         279400, 431800,
    DMPAPER_LEDGER,                          431800, 279400,
    DMPAPER_LEGAL,                           215900, 355600,
    DMPAPER_STATEMENT,                       139700, 215900,
    DMPAPER_EXECUTIVE,                       184150, 266700,
    DMPAPER_A3,                              297000, 420000,
    DMPAPER_A4,                              210000, 297000,
    DMPAPER_A4SMALL,                         210000, 297000,
    DMPAPER_A5,                              148000, 210000,
    DMPAPER_B4,                              257000, 364000,
    DMPAPER_B5,                              182000, 257000,
    DMPAPER_FOLIO,                           215900, 330200,
    DMPAPER_QUARTO,                          215000, 275000,
    DMPAPER_10X14,                           254000, 355600,
    DMPAPER_11X17,                           279400, 431800,
    DMPAPER_NOTE,                            215900, 279400,
    DMPAPER_ENV_9,                            98425, 225425,
    DMPAPER_ENV_10,                          104775, 241300,
    DMPAPER_ENV_11,                          114300, 263525,
    DMPAPER_ENV_12,                          120650, 279400,
    DMPAPER_ENV_14,                          127000, 292100,
    DMPAPER_CSHEET,                          431800, 558800,
    DMPAPER_DSHEET,                          558800, 863600,
    DMPAPER_ESHEET,                          863600,1117600,
    DMPAPER_ENV_DL,                          110000, 220000,
    DMPAPER_ENV_C5,                          162000, 229000,
    DMPAPER_ENV_C3,                          324000, 458000,
    DMPAPER_ENV_C4,                          229000, 324000,
    DMPAPER_ENV_C6,                          114000, 162000,
    DMPAPER_ENV_C65,                         114000, 229000,
    DMPAPER_ENV_B4,                          250000, 353000,
    DMPAPER_ENV_B5,                          176000, 250000,
    DMPAPER_ENV_B6,                          176000, 125000,
    DMPAPER_ENV_ITALY,                       110000, 230000,
    DMPAPER_ENV_MONARCH,                     98425, 190500,
    DMPAPER_ENV_PERSONAL,                    92075, 165100,
    DMPAPER_FANFOLD_US,                      377825, 279400,
    DMPAPER_FANFOLD_STD_GERMAN,              215900, 304800,
    DMPAPER_FANFOLD_LGL_GERMAN,              215900, 330200,

    DMPAPER_ISO_B4,                          250000, 353000,
    DMPAPER_JAPANESE_POSTCARD,               100000, 148000,
    DMPAPER_9X11,                            228600, 279400,
    DMPAPER_10X11,                           254000, 279400,
    DMPAPER_15X11,                           381000, 279400,
    DMPAPER_ENV_INVITE,                      220000, 220000,
    DMPAPER_LETTER_EXTRA,                    241300, 304800,

    DMPAPER_LEGAL_EXTRA,                     241300, 381000,
    DMPAPER_TABLOID_EXTRA,                   296926, 457200,
    DMPAPER_A4_EXTRA,                        235458, 322326,
    DMPAPER_LETTER_TRANSVERSE,               215900, 279400,
    DMPAPER_A4_TRANSVERSE,                   210000, 297000,
    DMPAPER_LETTER_EXTRA_TRANSVERSE,         241300, 304800,
    DMPAPER_A_PLUS,                          227000, 356000,
    DMPAPER_B_PLUS,                          305000, 487000,
    DMPAPER_LETTER_PLUS,                     215900, 322326,
    DMPAPER_A4_PLUS,                         210000, 330000,
    DMPAPER_A5_TRANSVERSE,                   148000, 210000,
    DMPAPER_B5_TRANSVERSE,                   182000, 257000,
    DMPAPER_A3_EXTRA,                        322000, 445000,
    DMPAPER_A5_EXTRA,                        174000, 235000,
    DMPAPER_B5_EXTRA,                        201000, 276000,
    DMPAPER_A2,                              420000, 594000,
    DMPAPER_A3_TRANSVERSE,                   297000, 420000,
    DMPAPER_A3_EXTRA_TRANSVERSE,             322000, 445000,

    // Predefined forms currently availble only in Win95.  Included here
    // for compatibility.

    // FE-only predefined forms.
    #ifndef WINNT_40
    DMPAPER_DBL_JAPANESE_POSTCARD,           200000, 148000,
    DMPAPER_A6,                              105000, 148000,
    DMPAPER_JENV_KAKU2,                      240000, 332000,
    DMPAPER_JENV_KAKU3,                      216000, 277000,
    DMPAPER_JENV_CHOU3,                      120000, 235000,
    DMPAPER_JENV_CHOU4,                       90000, 205000,
    DMPAPER_LETTER_ROTATED,                  279400, 215900,
    DMPAPER_A3_ROTATED,                      420000, 297000,
    DMPAPER_A4_ROTATED,                      297000, 210000,
    DMPAPER_A5_ROTATED,                      210000, 148000,
    DMPAPER_B4_JIS_ROTATED,                  364000, 257000,
    DMPAPER_B5_JIS_ROTATED,                  257000, 182000,
    DMPAPER_JAPANESE_POSTCARD_ROTATED,       148000, 100000,
    DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED,   148000, 200000,
    DMPAPER_A6_ROTATED,                      148000, 105000,
    DMPAPER_JENV_KAKU2_ROTATED,              332000, 240000,
    DMPAPER_JENV_KAKU3_ROTATED,              277000, 216000,
    DMPAPER_JENV_CHOU3_ROTATED,              235000, 120000,
    DMPAPER_JENV_CHOU4_ROTATED,              205000,  90000,
    DMPAPER_B6_JIS,                          128000, 182000,
    DMPAPER_B6_JIS_ROTATED,                  182000, 128000,
    DMPAPER_12X11,                           304932, 279521,
    DMPAPER_JENV_YOU4,                       105000, 235000,
    DMPAPER_JENV_YOU4_ROTATED,               235000, 105000,
    DMPAPER_P16K,                            146000, 215000,
    DMPAPER_P32K,                            970000, 151000,
    DMPAPER_P32KBIG,                         101000, 160000,
    DMPAPER_PENV_1,                          102000, 165000,
    DMPAPER_PENV_2,                          110000, 176000,
    DMPAPER_PENV_3,                          125000, 176000,
    DMPAPER_PENV_4,                          110000, 208000,
    DMPAPER_PENV_5,                          110000, 220000,
    DMPAPER_PENV_6,                          120000, 230000,
    DMPAPER_PENV_7,                          160000, 230000,
    DMPAPER_PENV_8,                          120000, 309000,
    DMPAPER_PENV_9,                          229000, 324000,
    DMPAPER_PENV_10,                         324000, 458000,
    DMPAPER_P16K_ROTATED,                    215000, 146000,
    DMPAPER_P32K_ROTATED,                    151000, 970000,
    DMPAPER_P32KBIG_ROTATED,                 160000, 101000,
    DMPAPER_PENV_1_ROTATED,                  165000, 102000,
    DMPAPER_PENV_2_ROTATED,                  176000, 110000,
    DMPAPER_PENV_3_ROTATED,                  176000, 125000,
    DMPAPER_PENV_4_ROTATED,                  208000, 110000,
    DMPAPER_PENV_5_ROTATED,                  220000, 110000,
    DMPAPER_PENV_6_ROTATED,                  230000, 120000,
    DMPAPER_PENV_7_ROTATED,                  230000, 160000,
    DMPAPER_PENV_8_ROTATED,                  309000, 120000,
    DMPAPER_PENV_9_ROTATED,                  324000, 229000,
    DMPAPER_PENV_10_ROTATED,                 458000, 324000,
    #endif
    0,                                       0,      0
};




DWORD   dwFindLastNode(
DWORD  dwFirstNode,
PGLOBL pglobl)
//  assume dwFirstNode  != END_OF_LIST
{
    PLISTNODE    plstRoot ;  // start of LIST array

    plstRoot = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    while(plstRoot[dwFirstNode].dwNextItem != END_OF_LIST)
        dwFirstNode = plstRoot[dwFirstNode].dwNextItem ;
    return(dwFirstNode);
} // dwFindLastNode(...)


BOOL    BappendCommonFontsToPortAndLandscape(
PGLOBL pglobl)
//   append dwFontLst to dwPortFontLst and dwLandFontLst
//   in the FontCart  structure.
{
    DWORD       dwNumFontCarts , dwI, dwNodeIndex;
    PFONTCART   pfc ;
    PLISTNODE   plstRoot ;  // start of LIST array

    dwNumFontCarts = gMasterTable[MTI_FONTCART].dwArraySize ;

    if(!dwNumFontCarts)
        return (TRUE);   // no fontcart structs to process.

    pfc      = (PFONTCART)gMasterTable[MTI_FONTCART].pubStruct ;
    plstRoot = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    for(dwI = 0 ; dwI < dwNumFontCarts ; dwI++)
    {
        if(pfc[dwI].dwFontLst == END_OF_LIST)
            continue;   // nothing to append.

        if(pfc[dwI].dwPortFontLst == END_OF_LIST)
            pfc[dwI].dwPortFontLst = pfc[dwI].dwFontLst ;
        else
        {
            dwNodeIndex = dwFindLastNode(pfc[dwI].dwPortFontLst, pglobl) ;
            plstRoot[dwNodeIndex].dwNextItem = pfc[dwI].dwFontLst ;
        }
        if(pfc[dwI].dwLandFontLst == END_OF_LIST)
            pfc[dwI].dwLandFontLst = pfc[dwI].dwFontLst ;
        else
        {
            dwNodeIndex = dwFindLastNode(pfc[dwI].dwLandFontLst, pglobl) ;
            plstRoot[dwNodeIndex].dwNextItem = pfc[dwI].dwFontLst ;
        }
    } //for dwI
    return (TRUE);   //
} //BappendCommonFontsToPortAndLandscape()


BOOL    BinitSpecialFeatureOptionFields(
PGLOBL pglobl)
//  determine num options and Unicode names for feature and
//  option keywords.
{
    DWORD   dwOptionID , dwOptionIndex , dwHeapOffset,
            dwFeatureIndex, dwFeatureID,  dwLargestString ,
            dwAccumulator ;  // tracks amount of buffer needed to store
                             //  Feature/Option keyword strings in devmode.

    PSYMBOLNODE         psn ;
    PDFEATURE_OPTIONS   pfo ;
    ARRAYREF            arSymbolName, arUnicodeName;

    BOOL        bPickMany,  // can user select multiple options?
                bExists ;   // dummy

    PBYTE       pubFeaDelim = " NewFeature " ,
                pubTrue     = " TRUE ",
                pubFalse    = " FALSE ";

    //  do this just for non-synthesized features.
    //  write atrFeaKeyWord directly as heap offset.
    //  write atrOptKeyWord as single level tree
    //  using BexchangeArbDataInFOATNode().

    gmrbd.dwMaxPrnKeywordSize = gmrbd.dwMaxDocKeywordSize = 0 ;
    // tell amanda how much room to reserve in devmode or registry
    //  to store feature/option keywords.
    gmrbd.rbd.dwChecksum32 =   0 ;  // seed


    pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    dwFeatureIndex = mdwFeatureSymbols ;

    while(dwFeatureIndex != INVALID_INDEX)
    {
        DWORD   dwRootOptions ,
            dwNonStandardSizeID = FIRST_NON_STANDARD_ID ;

        dwFeatureID  = psn[dwFeatureIndex].dwSymbolID ;
        arSymbolName = psn[dwFeatureIndex].arSymbolName ;

        //  -----  special checks for Feature describing multiple Resource DLLs.

        if(dwFeatureID   &&  (dwFeatureID  ==  gdwResDLL_ID) )
        {
            //   does feature have correct symbolname?
            PBYTE  pubResName = "RESDLL" ;
            DWORD   dwLen ;

            dwLen = strlen(pubResName);

            if((dwLen != arSymbolName.dwCount)  ||
                strncmp(mpubOffRef + arSymbolName.loOffset,
                            pubResName,  dwLen) )
            {
                ERR(("References to ResourceDLLs must be placed in the feature with symbolname: %s.\n", pubResName));
                return(FALSE);
            }

            //   has   atrOptRcNameID  been defined?

            if(pfo[dwFeatureID].atrOptRcNameID !=  ATTRIB_UNINITIALIZED)
            {
                ERR(("ResourceDLL names must be declared explicitly using *Name not *rcNameID.\n"));
                return(FALSE);
            }
        }



        // -----  compute BUD checksum

        gmrbd.rbd.dwChecksum32 = ComputeCrc32Checksum (
                                    pubFeaDelim,
                                    strlen(pubFeaDelim),
                                    gmrbd.rbd.dwChecksum32 ) ;

        //  perform checksum on arSymbolName

        gmrbd.rbd.dwChecksum32 = ComputeCrc32Checksum(
                                    mpubOffRef + arSymbolName.loOffset,
                                    arSymbolName.dwCount,
                                    gmrbd.rbd.dwChecksum32 ) ;


        //    extract value for atrFeaInstallable using
            if(!BReadDataInGlobalNode(&pfo[dwFeatureID].atrFeaInstallable , &dwHeapOffset, pglobl)
                ||   *(PDWORD)(mpubOffRef + dwHeapOffset)  !=  BT_TRUE)
                    gmrbd.rbd.dwChecksum32 =        //  no synthesized feature associated
                        ComputeCrc32Checksum(
                            pubFalse,
                            strlen(pubFalse),
                            gmrbd.rbd.dwChecksum32      ) ;
            else
                gmrbd.rbd.dwChecksum32 =        //   associated with synthesized feature
                    ComputeCrc32Checksum(
                        pubTrue,
                        strlen(pubTrue),
                        gmrbd.rbd.dwChecksum32      ) ;

        // -----    end part I  compute BUD checksum

        dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;

        pfo[dwFeatureID].dwNumOptions =
            psn[dwRootOptions].dwSymbolID + 1 ;



#if 0
        Don't convert symbol values to Unicode.
        if(!BwriteUnicodeToHeap(&arSymbolName, &arUnicodeName,
                iCodepage = 0))
            return(FALSE) ;
#endif
        if(!BwriteToHeap(&(pfo[dwFeatureID].atrFeaKeyWord),
            (PBYTE)&arSymbolName, sizeof(ARRAYREF), 4, pglobl))
            return(FALSE);

        dwAccumulator = arSymbolName.dwCount + 2 ;


        pfo[dwFeatureID].atrFeaKeyWord |= ATTRIB_HEAP_VALUE ;

        {  //  !!! new stuff
            DWORD   dwHeapOffset  ;

            dwLargestString = 0 ;  //  track the largest option string

            if(!BReadDataInGlobalNode(&pfo[dwFeatureID].atrUIType , &dwHeapOffset, pglobl)
                ||   *(PDWORD)(mpubOffRef + dwHeapOffset)  !=  UIT_PICKMANY)
                bPickMany = FALSE ;
                 //  accumulator += the largest option string;
            else
                bPickMany = TRUE ;
                //   accumulator = sum of all option strings;
        }


        if(!BIdentifyConstantString(&arSymbolName,
            &(pfo[dwFeatureID].dwGID), CL_CONS_FEATURES, TRUE, pglobl) )
        {
            pfo[dwFeatureID].dwGID = GID_UNKNOWN ;
        }

        if((pfo[dwFeatureID].dwGID == GID_MEMOPTION)  ||
            (pfo[dwFeatureID].dwGID == GID_PAGEPROTECTION))
        {
            DWORD   dwHeapOffset, dwValue  ;
            PATREEREF   patr ;

            //  set only if not explictly initialized in GPD file.

            if(!BReadDataInGlobalNode(&pfo[dwFeatureID].atrFeatureType , &dwHeapOffset, pglobl) )
            {
                //  label this FeatureType as PrinterSticky
                dwValue = FT_PRINTERPROPERTY ;
                patr  = &pfo[dwFeatureID].atrFeatureType ;

                if(!BwriteToHeap(patr, (PBYTE)&dwValue ,
                    sizeof(DWORD), 4, pglobl) )
                {
                    return(FALSE) ;  // heap overflow start over.
                }
                *patr  |= ATTRIB_HEAP_VALUE ;
            }
        }

        dwOptionIndex = dwRootOptions ;

        while(dwOptionIndex != INVALID_INDEX)
        {
            DWORD   dwDevmodeID, dwConsClass, dwInstallable ;
            BOOL    bCustomOptOK ;

            dwOptionID = psn[dwOptionIndex].dwSymbolID ;
            arSymbolName = psn[dwOptionIndex].arSymbolName ;



        // -----    part II  compute BUD checksum
            //  perform checksum on arSymbolName

            gmrbd.rbd.dwChecksum32 =
                ComputeCrc32Checksum(
                    mpubOffRef + arSymbolName.loOffset,
                    arSymbolName.dwCount,
                    gmrbd.rbd.dwChecksum32      ) ;


            //    extract value for atrOptInstallable using
            if( BexchangeArbDataInFOATNode(dwFeatureID,  dwOptionID,
                    offsetof(DFEATURE_OPTIONS, atrOptInstallable) ,
                    sizeof(DWORD),
                    (PBYTE)&dwInstallable, NULL, &bExists, FALSE , pglobl)  &&
                bExists  &&  dwInstallable ==  BT_TRUE)
                    gmrbd.rbd.dwChecksum32 =        //   associated with synthesized feature
                        ComputeCrc32Checksum(
                            pubTrue,
                            strlen(pubTrue),
                            gmrbd.rbd.dwChecksum32      ) ;
            else
                    gmrbd.rbd.dwChecksum32 =        //  no synthesized feature associated
                        ComputeCrc32Checksum(
                            pubFalse,
                            strlen(pubFalse),
                            gmrbd.rbd.dwChecksum32 ) ;
        // -----    end part II  compute BUD checksum


#if 0
            if(!BwriteUnicodeToHeap(&arSymbolName, &arUnicodeName,
                    iCodepage = 0))
                return(FALSE) ;
            //  if this is ever used, must use &arUnicodeName
            //  as the 2nd argument to BwriteToHeap.
#endif

            if(! BexchangeArbDataInFOATNode(
                dwFeatureID,  dwOptionID,
                offsetof(DFEATURE_OPTIONS, atrOptKeyWord),
                sizeof(ARRAYREF),
                NULL, (PBYTE)&arSymbolName, &bExists, FALSE , pglobl))
                return(FALSE);   //  this is a fatal error.

            if(bPickMany)
                dwAccumulator += arSymbolName.dwCount + 1 ;
            else
            {
                //  track largest option string
                if(dwLargestString < arSymbolName.dwCount + 1 )
                    dwLargestString = arSymbolName.dwCount + 1 ;
            }


            switch(pfo[dwFeatureID].dwGID)
            {
                case GID_PAGESIZE:
                    dwConsClass = CL_CONS_PAPERSIZE ;
                    bCustomOptOK = TRUE ;
                    break ;
                case GID_MEDIATYPE:
                    dwConsClass = CL_CONS_MEDIATYPE ;
                    bCustomOptOK = TRUE ;
                    break ;
                case GID_INPUTSLOT:
                    dwConsClass = CL_CONS_INPUTSLOT ;
                    bCustomOptOK = TRUE ;
                    break ;
                case GID_HALFTONING:
                    dwConsClass = CL_CONS_HALFTONE ;
                    bCustomOptOK = TRUE ;
                    break ;
                case GID_DUPLEX:
                    dwConsClass = CL_CONS_DUPLEX ;
                    bCustomOptOK = FALSE ;
                    break ;
                case GID_ORIENTATION:
                    dwConsClass = CL_CONS_ORIENTATION ;
                    bCustomOptOK = FALSE ;
                    break ;
                case GID_PAGEPROTECTION:
                    dwConsClass = CL_CONS_PAGEPROTECT ;
                    bCustomOptOK = FALSE ;
                    break ;
                case GID_COLLATE:
                    dwConsClass = CL_CONS_COLLATE ;
                    bCustomOptOK = FALSE ;
                    break ;

                default:
                    dwConsClass = CL_NUMCLASSES ;
                    bCustomOptOK = TRUE ;  // Irrelavent.
                    break ;
            } //switch

            if(dwConsClass != CL_NUMCLASSES)
            {
                if(BIdentifyConstantString(&arSymbolName,
                    &dwDevmodeID, dwConsClass, bCustomOptOK, pglobl) )
                {
                    if(! BexchangeArbDataInFOATNode(
                        dwFeatureID,  dwOptionID,
                        offsetof(DFEATURE_OPTIONS, atrOptIDvalue),
                        sizeof(DWORD),
                        NULL, (PBYTE)&dwDevmodeID, &bExists, FALSE , pglobl))
                        return(FALSE);   //  this is a fatal error.


                    if(dwConsClass == CL_CONS_PAPERSIZE  &&
                        dwDevmodeID < DMPAPER_USER)
                    {
                        //  fill in the page dimensions.
                        POINT   ptDim ;
                        DWORD   dwI ;
                        PGLOBALATTRIB   pga ;
                        BOOL    bTRUE = TRUE ;
                        PBYTE  pub ;

                        if(dwDevmodeID == DMPAPER_LETTER)
                        {
                            //   pointer to dword containing heapoffset
                            PATREEREF      patrAttribRoot ;

                            pub =  gMasterTable[MTI_GLOBALATTRIB].pubStruct ;
                            patrAttribRoot = &(((PGLOBALATTRIB)pub)->atrLetterSizeExists) ;
                            BwriteToHeap((PDWORD)  patrAttribRoot, (PBYTE)&bTRUE,  4 , 4 , pglobl);
                            *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
                        }
                        else if(dwDevmodeID == DMPAPER_A4)
                        {
                            PATREEREF      patrAttribRoot ;  //   pointer to dword containing heapoffset

                            pub =  gMasterTable[MTI_GLOBALATTRIB].pubStruct ;
                            patrAttribRoot = &(((PGLOBALATTRIB)pub)->atrA4SizeExists) ;
                            BwriteToHeap((PDWORD)  patrAttribRoot, (PBYTE)&bTRUE,  4 , 4 , pglobl);
                            *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
                        }

                        for(dwI = 0 ; aPaperDimensions[dwI].x ; dwI++)
                        {
                            if(aPaperDimensions[dwI].paperID == dwDevmodeID)
                                break ;
                        }
                        //  worst case causes (0,0) to be assigned.

                        ptDim.x = aPaperDimensions[dwI].x ;
                        ptDim.y = aPaperDimensions[dwI].y ;

                        //  convert from microns to master units

                        ptDim.x /= 100 ;  // microns to tenths of mm
                        ptDim.y /= 100 ;

                        pga =  (PGLOBALATTRIB)gMasterTable[
                                    MTI_GLOBALATTRIB].pubStruct ;

                        if(!BReadDataInGlobalNode(&pga->atrMasterUnits,
                                &dwHeapOffset, pglobl) )
                            return(FALSE);

                        ptDim.x *= ((PPOINT)(mpubOffRef + dwHeapOffset))->x ;
                        ptDim.y *= ((PPOINT)(mpubOffRef + dwHeapOffset))->y ;

                        ptDim.x /= 254 ;
                        ptDim.y /= 254 ;


                        if(! BexchangeArbDataInFOATNode(
                            dwFeatureID,  dwOptionID,
                            offsetof(DFEATURE_OPTIONS, atrPageDimensions),
                            sizeof(POINT),
                            NULL, (PBYTE)&ptDim, &bExists, FALSE , pglobl))
                            return(FALSE);   //  this is a fatal error.
                    }
                }
                else if(bCustomOptOK)
                //  feature permits GPD defined options
                {
                    DWORD   dwID ,  // pattern size ID used by GDI
                        dwOldID,  // user specified ID value if any.
                        dwRcPatID;
                    POINT   ptSize ;

                    //  Option Symbolvalue not found in tables.
                    //  assume its a user-defined value.

                    #ifndef WINNT_40
                    if((pfo[dwFeatureID].dwGID == GID_HALFTONING)  &&
                        BexchangeArbDataInFOATNode(
                            dwFeatureID,  dwOptionID,
                            offsetof(DFEATURE_OPTIONS, atrRcHTPatternID),
                            sizeof(DWORD),
                            (PBYTE)&dwRcPatID, NULL, &bExists, FALSE , pglobl)  &&
                        bExists  &&  dwRcPatID  &&
                        BexchangeArbDataInFOATNode(
                            dwFeatureID,  dwOptionID,
                            offsetof(DFEATURE_OPTIONS, atrHTPatternSize),
                            sizeof(POINT),
                            (PBYTE)&ptSize, NULL, &bExists, FALSE, pglobl )  &&
                        bExists &&
                        (ptSize.x >= HT_USERPAT_CX_MIN)  &&
                        (ptSize.x <= HT_USERPAT_CX_MAX)  &&
                        (ptSize.y >= HT_USERPAT_CY_MIN)  &&
                        (ptSize.y <= HT_USERPAT_CY_MAX)
                        )
                    {
                        dwID = HT_PATSIZE_USER ;
                        //  GID halftone code is to use
                        //  the user defined halftone matrix.
                    }
                    else
                    #endif
                    {
                        dwID = dwNonStandardSizeID ;
                        dwNonStandardSizeID++ ;
                        //  OEM will supply a halftone function.
                    }

                    if(! BexchangeArbDataInFOATNode(
                        dwFeatureID,  dwOptionID,
                        offsetof(DFEATURE_OPTIONS, atrOptIDvalue),
                        sizeof(DWORD),
                        (PBYTE)&dwOldID, (PBYTE)NULL, &bExists, FALSE , pglobl ))
                        return(FALSE);   //  this is a fatal error.

                    if(!bExists  &&  ! BexchangeArbDataInFOATNode(
                        dwFeatureID,  dwOptionID,
                        offsetof(DFEATURE_OPTIONS, atrOptIDvalue),
                        sizeof(DWORD),
                        NULL, (PBYTE)&dwID, &bExists, FALSE  , pglobl))
                        return(FALSE);   //  this is a fatal error.
                }
            } // if(dwConsClass != CL_NUMCLASSES)

            //  otherwise leave optionID uninitialized.

            dwOptionIndex = psn[dwOptionIndex].dwNextSymbol ;

        } //while




        {  //  !!! new stuff
            DWORD   dwHeapOffset  ;

            dwAccumulator += dwLargestString ;   //  is zero if not needed.

            if(!BReadDataInGlobalNode(&pfo[dwFeatureID].atrFeatureType , &dwHeapOffset, pglobl)
                ||   *(PDWORD)(mpubOffRef + dwHeapOffset)  !=  FT_PRINTERPROPERTY)
                gmrbd.dwMaxDocKeywordSize += dwAccumulator;
            else
                gmrbd.dwMaxPrnKeywordSize += dwAccumulator;

        }


        dwFeatureIndex = psn[dwFeatureIndex].dwNextSymbol ;
    }
    return(TRUE) ;
} // BinitSpecialFeatureOptionFields()




BOOL    BIdentifyConstantString(
    IN      PARRAYREF   parString,
    OUT     PDWORD      pdwDest,      //  write dword value here.
    IN      DWORD       dwClassIndex, // which class of constant is this?
            BOOL        bCustomOptOK,
    IN      PGLOBL      pglobl
)
{
    DWORD   dwI, dwCount, dwStart , dwLen;

    dwStart = gcieTable[dwClassIndex].dwStart ;
    dwCount = gcieTable[dwClassIndex].dwCount ;


    for(dwI = 0 ; dwI < dwCount ; dwI++)
    {
        dwLen = strlen(gConstantsTable[dwStart + dwI].pubName);

        if((dwLen == parString->dwCount)  &&
            !strncmp(mpubOffRef + parString->loOffset,
                        gConstantsTable[dwStart + dwI].pubName,
                        dwLen) )
        {
            *pdwDest = gConstantsTable[dwStart + dwI].dwValue ;
            return(TRUE);
        }
    }

    if(bCustomOptOK)
    {
        if(gdwVerbosity >= 4)
        {
#if defined(DEVSTUDIO)  //  This needs to be a one-liner
            ERR(("Note: '%0.*s' is not a predefined member of enumeration class %s\n",
                parString->dwCount , mpubOffRef + parString->loOffset,
                gConstantsTable[dwStart - 1]));
#else
            ERR(("Note: Feature/Option name not a predefined member of enumeration class %s\n",
                    gConstantsTable[dwStart - 1]));
            ERR(("\t%0.*s\n", parString->dwCount , mpubOffRef + parString->loOffset )) ;
#endif
        }
    }
    else
    {
#if defined(DEVSTUDIO)  //  Same with this one...
        ERR(("Error: '%0.*s'- user defined Option names not permitted for enumeration class %s\n",
            parString->dwCount , mpubOffRef + parString->loOffset, gConstantsTable[dwStart - 1]));
#else
        ERR(("Error: user defined Option names not permitted for enumeration class %s\n",
                gConstantsTable[dwStart - 1]));
        ERR(("\t%0.*s\n", parString->dwCount , mpubOffRef + parString->loOffset )) ;
#endif
    }
    return(FALSE);
}



BOOL    BReadDataInGlobalNode(
    PATREEREF   patr,           // address of field in GlobalAttrib struct
    PDWORD      pdwHeapOffset,   // contents of attribute node.
    PGLOBL      pglobl
  )

/*
this function will grab the first heap offset value it
encounters from the specified attribute tree root.
If the tree is multivalued, it selects the first
option of each level.
The high bit (if set) is cleared before the value is returned.
If root is uninitialized, returns FALSE,  not an error condition
since GPD file is not required to initialize all fields.
*/

{
    PATTRIB_TREE    patt ;      // start of ATTRIBUTE tree array.
    DWORD           dwNodeIndex ;

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    if(*patr == ATTRIB_UNINITIALIZED)
        return(FALSE);

    if(*patr & ATTRIB_HEAP_VALUE)
    {
        *pdwHeapOffset = *patr & ~ATTRIB_HEAP_VALUE ;
        return(TRUE) ;
    }

    dwNodeIndex = *patr ;
    if(patt[dwNodeIndex].dwFeature == DEFAULT_INIT)
    {
        *pdwHeapOffset = patt[dwNodeIndex].dwOffset ;
        return(TRUE) ;
    }
    while(patt[dwNodeIndex].eOffsetMeans == NEXT_FEATURE)
    {
        // Down to the next level we go.
        dwNodeIndex = patt[dwNodeIndex].dwOffset ;
    }
    if(patt[dwNodeIndex].eOffsetMeans == VALUE_AT_HEAP)
    {
        *pdwHeapOffset = patt[dwNodeIndex].dwOffset ;
        return(TRUE) ;
    }
    else
        return(FALSE) ;
} // BReadDataInGlobalNode(...)


//    Following three functions
//    Added on 9/30/98 in response to bug report 225088

// BsetUQMFlag() goes through the attrib trees rooted at
// atrDraftQualitySettings, atrBetterQualitySettings, atrBestQualitySettings,
// & atrDefaultQuality and checks for a feature dependency. If found,
// it updates the UpdateQualityMacro flag for that feature to TRUE.

BOOL    BsetUQMFlag(
PGLOBL pglobl)
{
    DWORD           i;  // Loop Counter.
    PATTRIB_TREE  patt;
    ATREEREF      atrAttribRoot;
    BOOL          bStatus   = TRUE;

    PGLOBALATTRIB pga       =
                    (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].pubStruct ;

    // List of features whose UQM flag needs to be updated.
    ATREEREF patr[] = {  pga->atrDraftQualitySettings,
                         pga->atrBetterQualitySettings,
                         pga->atrBestQualitySettings,
                         pga->atrDefaultQuality,
                      };

    DWORD dwNumAttrib = sizeof(patr)/sizeof(ATREEREF);

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;


    // for the four quality settings
    for ( i = 0; bStatus && (i < dwNumAttrib); i++)
    {
        atrAttribRoot = patr[i] ;

        // It may be possible that only some of the four settings
        // may occur. In that case, atrAttribRoot == ATTRIB_UNINITIALIZED
        // only for those that dont occur.
        if(atrAttribRoot == ATTRIB_UNINITIALIZED)
        {
            // Occurs probably  because patr[i] e.g. DraftQualityMacro keyword
            // appears no where in the .gpd. Continue and check whether other
            // patr[i] occur.
            continue;

        }

        else if (atrAttribRoot & ATTRIB_HEAP_VALUE)
        {
            // Indicates there is no dependency
            // of any feature. So we can safely
            // ignore and continue with the
            // next attribute.
            continue;
        }


        // If the above two are not true, it means atrAttribRoot points
        // to a valid node (in the attrib tree).

        // In the tree, at most
        // the first node can be the global default initializer:
        // (as stated (in treewalk.c line 351) and interpreted (from
        // state2.c  function - BaddBranchToTree (...)  ) )
        // Therefore it is safe check for this condition only once,
        // just before we start
        // recursing down the tree. No need to check once within the tree.


        // In a global default initializer!
        // it may be assumed dwOffset contains heap offset.
        // But we are concerned not with the heap value, but
        // the next Node.

        if(patt[atrAttribRoot].dwFeature == DEFAULT_INIT)
        {
            if ( patt[atrAttribRoot].dwNext == END_OF_LIST)
                continue;

            atrAttribRoot = patt[atrAttribRoot].dwNext ;  // to the next node.
        } //if


        // Walk thru the tree and retrieve the features that are children
        // of the tree rooted at atrAttribRoot.

        bStatus = BRecurseNodes(atrAttribRoot, pglobl);

    } //for

    return bStatus;
} //BsetUQMFlag


//    Recurse down the attribute tree. When we reach a feature we
//    set its UQM flag to true by calling the function BsetUQMTrue(..)
//    It is reasonable to assume that the dwFeature attribute in the
//    structure pointed to by atrAttribNode contains a valid feature ID.
//    The other special cases are handled in the previous function -
//    BsetUQMFlag()

BOOL BRecurseNodes(
    IN      ATREEREF atrAttribNode,
    IN OUT  PGLOBL pglobl
)
{
    PATTRIB_TREE patt;
    BOOL bStatus = TRUE;

    PDFEATURE_OPTIONS pfo =
        (PDFEATURE_OPTIONS) (gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct);

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    // Is it safe to assume that a new feature is encountered only
    // when we go one level down the tree.
    // Yes. Because the nodes at the same level have the SAME feature
    // but DIFFERENT options.


    // Hack. Since ColorMode is handled in a special way in the UI, the
    // Quality Macro should not be executed for Color Mode.
    if ((*(pfo + patt[atrAttribNode].dwFeature)).dwGID !=  GID_COLORMODE)
    {
        bStatus = BsetUQMTrue(patt[atrAttribNode].dwFeature, pglobl);
    }

    // Even though the trees of some gpd's (e.g. cnb5500.gpd) appear very
    // uniform (i.e. most of the branches look similar), we cannot assume it
    // to be true for all .gpd Therefore we have to go through
    // all the branches of the tree.

    for(; bStatus && atrAttribNode != END_OF_LIST;
                        atrAttribNode = patt[atrAttribNode].dwNext)
    {

        // This is what we are really interested in.
        // Check if the node has a sublevel. Yes means another feature.

        if( patt[atrAttribNode].eOffsetMeans == NEXT_FEATURE)
        {
                bStatus = BRecurseNodes(patt[atrAttribNode].dwOffset, pglobl);

        }
    } // for

    return bStatus;
} // End of function BRecurseNodes(...)



BOOL BsetUQMTrue(
    IN     DWORD   dwFeature,
    IN OUT PGLOBL  pglobl)

// For the feature dwFeature
// Set the UpdateQualityMacro Flag to true;

{

    BOOL    bStatus = TRUE;
    DWORD   dwTrue  = BT_TRUE;

    PDFEATURE_OPTIONS pfo =
        (PDFEATURE_OPTIONS) (gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct);


    PATREEREF patrAttribRoot  =  &((*(pfo + dwFeature)).atrUpdateQualityMacro);


    // The tree rooted at atrAttribRoot can either be uninitilized or
    // have a pointer to a heap value.
    // Any other case is a violation of the semantics.


    if(*patrAttribRoot == ATTRIB_UNINITIALIZED)
    {
        // Put BT_TRUE in the heap and make *patrAttribRoot point to it.
        // i.e. have *patrAttribRoot hold a dword that is an offset into
        // the heap. It is then ORed with  ATTRIB_HEAP_VALUE(which has
        // MSB set to 1). The MSB indicates that the DWORD is a
        // Heap Offset and not a ATTRIB_UNINITIALIZED, node index or any
        // other value.

        if((bStatus = BwriteToHeap((PDWORD)patrAttribRoot, (PBYTE)&dwTrue,
                        gValueToSize[VALUE_CONSTANT_BOOLEANTYPE], 4, pglobl) ) )
        {
            *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
        }
        else {
            *patrAttribRoot = ATTRIB_UNINITIALIZED ;

            // The global Error variables have been set in BwriteToHeap().
        }


        return bStatus;
    } //if(*patrAttribRoot == ATTRIB_UNINITIALIZED)


    /*
      Now comes the case when the user has specified the value of
      UpdateQualityMacro to be TRUE or FALSE. If the value is TRUE
      we still overwrite it with TRUE. If FALSE, we update it according
      to the dependencies in the .gpd file.
      Since we have reached here in the program, the dependencies
      indicate that the UQM needs to be set to TRUE.
    */

    else if (*patrAttribRoot & ATTRIB_HEAP_VALUE)
    {
        // The value should be a DWORD because UpdateQualityMacro's
        // mMainKeywordTable[dwI].flAgs = 0 ;  (file framwrk1.c line 1566)
        // Therefore not checking for a list.

        PDWORD pdwValue = (PDWORD) ( (PBYTE) mpubOffRef +
                                (*patrAttribRoot & ~ATTRIB_HEAP_VALUE) );

        //Change to TRUE irrespective of its previous value.
        *pdwValue = BT_TRUE;  //Value in the heap changed to TRUE
    }

    // Since UpdateQualityMacro's
    //    mMainKeywordTable[dwI].dwSubType = ATT_LOCAL_FEATURE_ONLY
    //      (file framwrk1.c line 1574)
    // (i.e. it is not a free-float type), it cannot have a
    // sub-tree. So it should not point to another node.
    //
    // The following condition should never be true because UQM cannot
    // have a DEFAULT_INIT
    //      if(patt[*patrAttribRoot].dwFeature == DEFAULT_INIT)
    // Reason : It cannot form a tree (reason as explained above).
    //
    //Thus control should never reach here.
    else {
        PATTRIB_TREE patt =
                (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

        if(patt[*patrAttribRoot].dwFeature == DEFAULT_INIT) {
            ERR(("Warning: unexpected value atrUpdateQualityMacro ATREEREF\n"));
        }
        else {
            ERR(("Warning: atrUpdateQualityMacro ATREEREF points to a tree. \
                    Unexpected Condition\n"));
        }
        ERR(("Unexpected condition encountered while processing Quality Macros\n "));

        geErrorType = ERRTY_SYNTAX ;
        geErrorSev  = ERRSEV_FATAL ;
        bStatus     = FALSE;
    }

    return bStatus;
} //BsetUQMTrue(...)

//  End of 3 functions added on 9/30/98 in response to
//  bug report no. 225088





VOID    VCountPrinterDocStickyFeatures(
    PGLOBL  pglobl)
{
    PDFEATURE_OPTIONS   pfo ;
    DWORD               dwHeapOffset, dwCount, dwI ;

//  extern  MINIRAWBINARYDATA  gmrbd ;
//  Not required now as it is part of the PGLOBL structure.


    pfo     = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;
    dwCount = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;

    gmrbd.rbd.dwDocumentFeatures = 0 ;
    gmrbd.rbd.dwPrinterFeatures  =
        gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize ;

    for(dwI = 0 ; dwI < dwCount ; dwI++)
    {
        if(BReadDataInGlobalNode(&pfo[dwI].atrFeatureType,
                &dwHeapOffset, pglobl)  &&
                *(PDWORD)(mpubOffRef + dwHeapOffset) == FT_PRINTERPROPERTY)
            gmrbd.rbd.dwPrinterFeatures++ ;
        else
            gmrbd.rbd.dwDocumentFeatures++ ;
    }
} // VCountPrinterDocStickyFeatures()


BOOL    BConvertSpecVersionToDWORD(
    PWSTR   pwstrFileName,
    PGLOBL  pglobl
  )
//  also used to prepend absolute path to resource Dll name.
{
    BOOL          bStatus ;
    DWORD         dwMajor, dwMinor, dwHeapOffset, dwDelim, dwDummy, dwByteCount;
    //  WCHAR         awchDLLQualifiedName[MAX_PATH];
    PWSTR         pwstrLastBackSlash, pwstrDLLName,
                  pwstrDataFileName = NULL;
    ABSARRAYREF   aarValue, aarToken ;
    PGLOBALATTRIB pga ;
    DWORD  pathlen = 0 ;
    DWORD  namelen =  0 ;
    WCHAR * pwDLLQualifiedName = NULL ;

//  extern  MINIRAWBINARYDATA  gmrbd ;
//  Not required now as it is part of the PGLOBL structure.


    pga =  (PGLOBALATTRIB)gMasterTable[MTI_GLOBALATTRIB].pubStruct ;


    if(!BReadDataInGlobalNode(&pga->atrGPDSpecVersion ,
            &dwHeapOffset, pglobl) )
    {
        ERR(("Missing required keyword: *GPDSpecVersion.\n"));
        return(FALSE);
    }

    aarValue.dw = ((PARRAYREF)(mpubOffRef + dwHeapOffset))->dwCount ;
    aarValue.pub = mpubOffRef +
                ((PARRAYREF)(mpubOffRef + dwHeapOffset))->loOffset ;

    bStatus = BdelimitToken(&aarValue, ".", &aarToken, &dwDelim)  ;

    if(bStatus)
        bStatus = BparseInteger(&aarToken, &dwMajor, VALUE_INTEGER, pglobl) ;

    if(bStatus)
        bStatus = BparseInteger(&aarValue, &dwMinor, VALUE_INTEGER, pglobl) ;

    if(bStatus)
    {
        gmrbd.dwSpecVersion = dwMajor << 16;  // place in HiWord
        gmrbd.dwSpecVersion |= dwMinor & 0xffff;  // place in LoWord
    }
    else
    {
        ERR(("BConvertSpecVersionToDWORD: syntax error in *GPDSpecVersion value. unknown version.\n"));
    }


    // -------- now to fix up the helpfile name. ------ //

    if(!BReadDataInGlobalNode(&pga->atrHelpFile ,
            &dwHeapOffset, pglobl) )
    {
        goto  FIX_RESDLLNAME;  // GPD doesn't have this keyword
    }

    pwstrDLLName = (PWSTR)(mpubOffRef +
                ((PARRAYREF)(mpubOffRef + dwHeapOffset))->loOffset) ;


    //  how large should pwDLLQualifiedName be???

    pathlen = wcslen(pwstrFileName) ;
    namelen =  pathlen + wcslen(pwstrDLLName)  + 1;

    if(!(pwDLLQualifiedName = (PWSTR)MemAllocZ(namelen * sizeof(WCHAR)) ))
    {
        ERR(("Fatal: unable to alloc memory for pwDLLQualifiedName: %d WCHARs.\n",
            namelen));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
        return(FALSE) ;   // This is unrecoverable
    }


    wcsncpy(pwDLLQualifiedName, pwstrFileName , namelen);

    if (pwstrLastBackSlash = wcsrchr(pwDLLQualifiedName,TEXT('\\')))
    {
        *(pwstrLastBackSlash + 1) = NUL;

        //Find a BackSlash in the Source DLL Name.
        pwstrDataFileName = wcsrchr( pwstrDLLName, TEXT('\\') );

        //Increment the pointer to first char of the DLL Name.
        if (pwstrDataFileName)
            pwstrDataFileName++;
        else
            pwstrDataFileName = pwstrDLLName;

        wcscat(pwDLLQualifiedName, pwstrDataFileName) ;

        ((PARRAYREF)(mpubOffRef + dwHeapOffset))->dwCount =
                dwByteCount =
                wcslen(pwDLLQualifiedName) * sizeof(WCHAR) ;


        if(BwriteToHeap(&((PARRAYREF)(mpubOffRef + dwHeapOffset))->loOffset,
            //  Store heap offset of dest string here.
                (PBYTE) pwDLLQualifiedName, dwByteCount, 2, pglobl) )
        {
            // add NUL terminator.
            BwriteToHeap(&dwDummy, "\0\0", 2, 1, pglobl) ;
            goto  FIX_RESDLLNAME;
        }

        bStatus = FALSE ;
    }




    // -------- now to fix up the resource Dll name. ------ //

FIX_RESDLLNAME:

    if(pwDLLQualifiedName)
        MemFree(pwDLLQualifiedName) ;

#if 0     //  fix for bug 34042
    if(!BReadDataInGlobalNode(&pga->atrResourceDLL ,
            &dwHeapOffset, pglobl) )
    {
        //  return(bStatus);  // GPD doesn't have this keyword
        //   create a dummy filename!

        PATREEREF   patr ;
        ARRAYREF    arDummyName ;

        arDummyName.dwCount =  wcslen(TEXT("No_Res")) * sizeof(WCHAR) ;
        if(!BwriteToHeap(&arDummyName.loOffset,
               (PBYTE)TEXT("No_Res\0"), arDummyName.dwCount + sizeof(WCHAR), 2, pglobl) )
                //   note:  add null terminator or strcat will derail.
        {
              bStatus = FALSE ;  // heap overflow start over.
        }

        patr  = &pga->atrResourceDLL ;
        if(!BwriteToHeap(patr,  (PBYTE)(&arDummyName) , sizeof(ARRAYREF), 4, pglobl) )
        {
              bStatus = FALSE ;  // heap overflow start over.
        }
        dwHeapOffset = *patr ;
        *patr  |= ATTRIB_HEAP_VALUE ;
    }
//  #if 0  move this to new location 25 lines up.   fix for bug 34042
    //   ganesh's winres lib will take care of prepending fully qualified path...

    pwstrDLLName = (PWSTR)(mpubOffRef +
                ((PARRAYREF)(mpubOffRef + dwHeapOffset))->loOffset) ;


    wcsncpy(awchDLLQualifiedName, pwstrFileName , MAX_PATH -1);

    if (pwstrLastBackSlash = wcsrchr(awchDLLQualifiedName,TEXT('\\')))
    {
        *(pwstrLastBackSlash + 1) = NUL;

        //Find a BackSlash in the Source DLL Name.
        pwstrDataFileName = wcsrchr( pwstrDLLName, TEXT('\\') );

        //Increment the pointer to first char of the DLL Name.
        if (pwstrDataFileName)
            pwstrDataFileName++;
        else
            pwstrDataFileName = pwstrDLLName;

        wcscat(awchDLLQualifiedName, pwstrDataFileName) ;

        ((PARRAYREF)(mpubOffRef + dwHeapOffset))->dwCount =
                dwByteCount =
                wcslen(awchDLLQualifiedName) * sizeof(WCHAR) ;


        if(BwriteToHeap(&((PARRAYREF)(mpubOffRef + dwHeapOffset))->loOffset,
            //  Store heap offset of dest string here.
                (PBYTE) awchDLLQualifiedName, dwByteCount, 2, pglobl) )
        {
            // add NUL terminator.
            BwriteToHeap(&dwDummy, "\0\0", 2, 1, pglobl) ;
            return(bStatus) ;
        }

        return(FALSE) ;
    }
#endif
    return(bStatus) ;
} // BConvertSpecVersionToDWORD(...)


BOOL   BinitMiniRawBinaryData(
    PGLOBL  pglobl)
{
    gmrbd.rbd.dwParserSignature = GPD_PARSER_SIGNATURE ;
    gmrbd.rbd.dwParserVersion   = GPD_PARSER_VERSION ;
    gmrbd.rbd.pvReserved        = NULL;
    return(TRUE) ;
} //BinitMiniRawBinaryData()


BOOL    BexchangeArbDataInFOATNode(
        DWORD   dwFeature,
        DWORD   dwOption,
        DWORD   dwFieldOff,     // offset of field in FeatureOption struct
        DWORD   dwCount,        //  number bytes to copy.
    OUT PBYTE   pubOut,         // previous contents of attribute node
    IN  PBYTE   pubIn,          // new contents of attribute node.
        PBOOL   pbPrevsExists,  // previous contents existed.
        BOOL    bSynthetic,      //  access synthetic features
        PGLOBL  pglobl
)
/*
  'FOAT'  means  FeatureOption AttributeTree.
  this function writes or overwrites the byte string specified by
  pubIn into the heap at the location indicated by the attribute tree
  HeapOffset field.  The previous contents at HeapOffset is saved to
  pubOut and pbPrevsExists is set to TRUE.  If pubIn is NULL,
  the current attribute tree is not altered.

  The parameters dwFeature, dwOption, dwFieldOffset specify
  the structure, field, and branch of the attribute tree.
  If the specified option branch does not exist, one will be created,
  pubOut may be set to NULL if the previous content is unimportant.
Assumptions:
  The tree being accessed is strictly one level deep.  That is the
  node is fully specified by just Feature, Option.  No default initializers.
*/
{
    PATTRIB_TREE  patt ;    // start of ATTRIBUTE tree array.
    PATREEREF     patr ;
    ATREEREF      atrCur ;  // contains index of currently  used attribute node.

    DWORD         dwFeaOffset ;  // Start numbering features from this
                                 // starting point.  This gives synthetic
                                 // features a separate non-overlapping number
                                 // space from normal features.

    PDFEATURE_OPTIONS   pfo ;


    if(bSynthetic)
    {
        pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_SYNTHESIZED_FEATURES].pubStruct +
            dwFeature  ;
        dwFeaOffset = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;
    }
    else
    {
        pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct +
            dwFeature ;
        dwFeaOffset = 0 ;
    }

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    patr = (PATREEREF)((PBYTE)pfo + dwFieldOff) ;
    atrCur = *patr ;

    if(atrCur == ATTRIB_UNINITIALIZED)
    {
        if(pubIn)
        {
            if(!BcreateEndNode(patr, dwFeature + dwFeaOffset , dwOption, pglobl) )
                return(FALSE) ;  // resource exhaustion
            if(!BwriteToHeap(&(patt[*patr].dwOffset), pubIn,
                                                    dwCount, 4, pglobl) )
                return(FALSE) ;  // A fatal error.
            patt[*patr].eOffsetMeans = VALUE_AT_HEAP ;
        }
        *pbPrevsExists = FALSE ;
        return(TRUE) ;
    }

    if(atrCur & ATTRIB_HEAP_VALUE)
    {
        ERR(("Internal error.  BexchangeArbDataInFOATNode should never create a branchless node.\n"));
        return(FALSE) ;
    }

    // offset field contains index to another node
    // but we will tack the new node (if any) after
    // the existing node.  Don't change patr.

    if(pubIn)
    {
        if(!BfindOrCreateMatchingNode(atrCur, &atrCur, dwFeature + dwFeaOffset , dwOption, pglobl))
            return(FALSE) ;  // Tree inconsistency error or resource exhaustion

        if(patt[atrCur].eOffsetMeans != VALUE_AT_HEAP)
        {
            //  just created a new node.
            if(!BwriteToHeap(&(patt[atrCur].dwOffset), pubIn, dwCount, 4, pglobl) )
                return(FALSE) ;  // A fatal error.
            patt[atrCur].eOffsetMeans = VALUE_AT_HEAP ;
            *pbPrevsExists = FALSE ;
            return(TRUE) ;
        }

        if(pubOut)
            memcpy(pubOut, mpubOffRef + patt[atrCur].dwOffset, dwCount) ;
        memcpy(mpubOffRef + patt[atrCur].dwOffset, pubIn, dwCount) ;
    }
    else
    {
        if(!BfindMatchingNode(atrCur, &atrCur, dwFeature + dwFeaOffset , dwOption, pglobl))
        {
            *pbPrevsExists = FALSE ;  // nothing found, don't create.
            return(TRUE) ;
        }
        if(pubOut)
            memcpy(pubOut, mpubOffRef + patt[atrCur].dwOffset, dwCount) ;
    }
    *pbPrevsExists = TRUE ;
    return(TRUE) ;
} // BexchangeArbDataInFOATNode(...)




typedef  struct
{
    DWORD   dwUserPriority ;
    DWORD   dwNext ;  // index of feature with a equal or greater
                      //  numerical value for dwUserPriority .
}  PRIORITY_NODE, *PPRIORITY_NODE ;     // the prefix tag shall be 'pn'


BOOL    BInitPriorityArray(
    PGLOBL pglobl)
{

    DWORD   dwNumFea, dwFea, dwPrnStickyroot, dwDocStickyroot,
            dwPrevsNode, dwCurNode, dwNumSyn, dwIndex, dwHeapOffset,
            adwDefaultPriority[MAX_GID];
    PDWORD  pdwRoot, pdwPriority  ;

    PDFEATURE_OPTIONS   pfo ;
    PPRIORITY_NODE      pnPri ;
    BOOL                bPrinterSticky ;



    // init  adwDefaultPriority[], the default priorities
    // are very low compared to any value a user may
    // explicitly assign.
    // The last term is the priority starting from 0 = highest.

    for(dwIndex = 0 ; dwIndex < MAX_GID ; dwIndex++)
    {
        adwDefaultPriority[dwIndex] =  0xffffffff ;    // default if not enum below.
    }

    adwDefaultPriority[GID_PAGESIZE]    =  0xffffffff -  MAX_GID + 0 ;
    adwDefaultPriority[GID_INPUTSLOT]   =  0xffffffff -  MAX_GID + 1 ;
    adwDefaultPriority[GID_ORIENTATION] =  0xffffffff -  MAX_GID + 2 ;
    adwDefaultPriority[GID_COLORMODE]   =  0xffffffff -  MAX_GID + 3 ;
    adwDefaultPriority[GID_DUPLEX]      =  0xffffffff -  MAX_GID + 4 ;
    adwDefaultPriority[GID_MEDIATYPE]   =  0xffffffff -  MAX_GID + 5 ;
    adwDefaultPriority[GID_RESOLUTION]  =  0xffffffff -  MAX_GID + 6 ;
    adwDefaultPriority[GID_HALFTONING]  =  0xffffffff -  MAX_GID + 7 ;

    dwPrnStickyroot = dwDocStickyroot = INVALID_INDEX ;

    pfo      = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct;
    dwNumFea = gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize ;

    if(!(pnPri = MemAllocZ(dwNumFea * sizeof(PRIORITY_NODE)) ))
    {
        ERR(("Fatal: BInitPriorityArray - unable to alloc %d bytes.\n",
            dwNumFea * sizeof(PRIORITY_NODE)));

        geErrorType       = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev        = ERRSEV_FATAL ;
        gdwMasterTabIndex = 0xffff ;

        return(FALSE) ;   // This is unrecoverable
    }

    for(dwFea = 0 ; dwFea < dwNumFea ; dwFea++)
    {
        if(BReadDataInGlobalNode(&pfo[dwFea].atrFeatureType , &dwHeapOffset, pglobl)
          &&  *(PDWORD)(mpubOffRef + dwHeapOffset) == FT_PRINTERPROPERTY)
            bPrinterSticky = TRUE ;
        else
            bPrinterSticky = FALSE ;

        if(BReadDataInGlobalNode(&pfo[dwFea].atrPriority , &dwHeapOffset, pglobl))
        {
            pnPri[dwFea].dwUserPriority =
                *(PDWORD)(mpubOffRef + dwHeapOffset) ;
        }
        else
        {
            pnPri[dwFea].dwUserPriority = 0xffffffff;   // lowest priority
            if(pfo[dwFea].dwGID != GID_UNKNOWN)
            {
                pnPri[dwFea].dwUserPriority = adwDefaultPriority[pfo[dwFea].dwGID] ;
            }
        }

        pdwRoot = (bPrinterSticky ) ? &dwPrnStickyroot : &dwDocStickyroot ;

        dwCurNode   = *pdwRoot ;
        dwPrevsNode = INVALID_INDEX ;
        while(dwCurNode !=  INVALID_INDEX)
        {
            if(pnPri[dwFea].dwUserPriority  <= pnPri[dwCurNode].dwUserPriority)
                break ;
            dwPrevsNode  = dwCurNode ;
            dwCurNode = pnPri[dw